<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="945f9867a22a1227b0894ab653a76dfd7ba5d099" translate="yes" xml:space="preserve">
          <source>Add locks around &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statements, which results in faster inserts when the dump file is reloaded. Use &lt;code&gt;--skip-add-locks&lt;/code&gt; to disable.</source>
          <target state="translated">&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문에 잠금을 추가 하면 덤프 파일을 다시로드 할 때 삽입 속도가 빨라집니다. &lt;code&gt;--skip-add-locks&lt;/code&gt; 하려면 --skip-add-locks 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f4fdc9efddcc802c85ba517a9cd19626af8d14c" translate="yes" xml:space="preserve">
          <source>Add months to a period</source>
          <target state="translated">기간에 개월 추가</target>
        </trans-unit>
        <trans-unit id="98c879aa169fce93aecb57ac34b530b95dc48ebc" translate="yes" xml:space="preserve">
          <source>Add months to a period.</source>
          <target state="translated">기간에 개월을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8fd7abcb39dffc033d1800bfcd6f36dea06e6290" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/debian-backports.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/debian-backports.list를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="667a6b5d0b60dd0427f04882213fdecdd3ee27cc" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/mariab-columnstore-api.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/mariab-columnstore-api.list를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="a70095cada349c514d18dec083da41b0c6c12927" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/mariab-columnstore-data-adapters.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/mariab-columnstore-data-adapters.list로 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="8203b4ec7ec6d9a21dfdd8e0bacde170782a9219" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/mariab-columnstore-tools.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/mariab-columnstore-tools.list로 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="64d8ac9a039c199f0c2062546f9d691618914d25" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/mariab-columnstore.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/mariab-columnstore.list를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="fd46537c66874361010ba2f811fb3f72f8a8556a" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/apt/sources.list.d/mariadb-maxscale.list</source>
          <target state="translated">저장소 정보 /etc/apt/sources.list.d/mariadb-maxscale.list를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="be1ef8a9a6b9c64154bd01e71f564f127bb5055f" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/yum.repos.d/mariadb-columnstore-api.repo</source>
          <target state="translated">저장소 정보 /etc/yum.repos.d/mariadb-columnstore-api.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="24b85ca26676a92d0c290d8aaef75a20bab9042b" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/yum.repos.d/mariadb-columnstore-data-adapters.repo</source>
          <target state="translated">저장소 정보 /etc/yum.repos.d/mariadb-columnstore-data-adapters.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="ec321e3515941c4ac83c7b4d908fd4b0eb717f0b" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/yum.repos.d/mariadb-columnstore-tools.repo</source>
          <target state="translated">저장소 정보 /etc/yum.repos.d/mariadb-columnstore-tools.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="c8997bbdcc375933b5ae24a3fb6465c612b10cab" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/yum.repos.d/mariadb-columnstore.repo</source>
          <target state="translated">저장소 정보 /etc/yum.repos.d/mariadb-columnstore.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="401b5d9f888422b110012cb2569e0a264f659b66" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/yum.repos.d/mariadb-maxscale.repo</source>
          <target state="translated">저장소 정보 /etc/yum.repos.d/mariadb-maxscale.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="b6a27d5b048352520e75d53aab8cef664c418ae7" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/zypp/repos.d/mariadb-columnstore-tools.repo</source>
          <target state="translated">저장소 정보 /etc/zypp/repos.d/mariadb-columnstore-tools.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="30b4c0c96e2f121e7b0d53f1ec3b281ea2c221e9" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/zypp/repos.d/mariadb-columnstore.repo</source>
          <target state="translated">저장소 정보 /etc/zypp/repos.d/mariadb-columnstore.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="ec8a088814845c183269347a4006886de2d23db0" translate="yes" xml:space="preserve">
          <source>Add new file with repository information, /etc/zypp/repos.d/mariadb-maxscale.repo</source>
          <target state="translated">저장소 정보 /etc/zypp/repos.d/mariadb-maxscale.repo를 사용하여 새 파일 추가</target>
        </trans-unit>
        <trans-unit id="f7cb40aade2ba0cb6e590d4bac1487360c0af89c" translate="yes" xml:space="preserve">
          <source>Add new options to &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; to enable features</source>
          <target state="translated">기능을 활성화 하기 위해 &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 에 새로운 옵션 추가</target>
        </trans-unit>
        <trans-unit id="c3ab52bbd7029e870c6bc52043407c576fc6d98b" translate="yes" xml:space="preserve">
          <source>Add new roles.</source>
          <target state="translated">새로운 역할을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ef99332190c0b37a6b38e0f8d0d27a7ebdf3e9d6" translate="yes" xml:space="preserve">
          <source>Add or update columns in a dynamic columns blob. To delete a column, update its value to a &quot;non-value&quot; of type &lt;code&gt;DYN_COL_NULL&lt;/code&gt;</source>
          <target state="translated">동적 열 Blob에서 열을 추가하거나 업데이트하십시오. 열을 삭제하려면 해당 값을 &lt;code&gt;DYN_COL_NULL&lt;/code&gt; 유형의 &quot;값이 아닌&quot;값으로 업데이트 하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3c589a8fd2b81f1035480b50db513bf54f3984" translate="yes" xml:space="preserve">
          <source>Add possible III-rd coordinate (Attitude).</source>
          <target state="translated">가능한 III 번째 좌표 (태도)를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a3cf593758fd5893d50caebdfa4e71a38013f1" translate="yes" xml:space="preserve">
          <source>Add rows specifying values in columns using the &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; statement. If you only have column-level &lt;code&gt;INSERT&lt;/code&gt; privileges, you must specify the columns you are setting in the &lt;code&gt;INSERT&lt;/code&gt; statement. All other columns will be set to their default values, or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 문을 사용하여 열에 값을 지정하는 행을 추가하십시오 . 열 레벨 &lt;code&gt;INSERT&lt;/code&gt; 특권 만있는 경우 &lt;code&gt;INSERT&lt;/code&gt; 문 에서 설정중인 열을 지정해야합니다 . 다른 모든 열은 기본값 또는 &lt;code&gt;NULL&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="be9ac18b4a6b385bb105b1045af882445dce5975" translate="yes" xml:space="preserve">
          <source>Add rows to a table using the &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; statement. The &lt;code&gt;INSERT&lt;/code&gt; privilege can also be set on individual columns; see &lt;a href=&quot;#column-privileges&quot;&gt;Column Privileges&lt;/a&gt; below for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 문을 사용하여 테이블에 행을 추가하십시오 . &lt;code&gt;INSERT&lt;/code&gt; 의 권한은 개별 열을 설정할 수 있습니다; 자세한 내용은 아래의 &lt;a href=&quot;#column-privileges&quot;&gt;열 권한을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5373756aaa4195064e242af62fe3c01919a5b16" translate="yes" xml:space="preserve">
          <source>Add system versioning.</source>
          <target state="translated">시스템 버전 관리를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7404d3f81767069c543738185dfeaa68121097c4" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;MASTER_HOST&lt;/code&gt; and &lt;code&gt;MASTER_PORT&lt;/code&gt; options for the &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt; statement when using the &lt;code&gt;--dump-slave&lt;/code&gt; option for a slave dump.</source>
          <target state="translated">슬레이브 덤프에 &lt;code&gt;--dump-slave&lt;/code&gt; 옵션을 사용할 때 &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt; 문의 &lt;code&gt;MASTER_HOST&lt;/code&gt; 및 &lt;code&gt;MASTER_PORT&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="930be3b2d52422297681bb00e9b7395e8aa1d070" translate="yes" xml:space="preserve">
          <source>Add the expressions from the &lt;code&gt;ON&lt;/code&gt; and &lt;code&gt;USING&lt;/code&gt; clauses to the &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 및 &lt;code&gt;USING&lt;/code&gt; 절의 표현식을 &lt;code&gt;WHERE&lt;/code&gt; 절에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="81e3565d0d9e029f5255fb947167be3b17d188d4" translate="yes" xml:space="preserve">
          <source>Add the following into your &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; file and restart the database.</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 파일에 다음을 추가하고 데이터베이스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c8f71de17c227cfb26e0534b53e9ad6e22f533f0" translate="yes" xml:space="preserve">
          <source>Add the following line for the non-root user:</source>
          <target state="translated">비 루트 사용자에 대해 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e060b7e7c1a80a347c9d46380b330fa8ad8ff63b" translate="yes" xml:space="preserve">
          <source>Add the following lines to the &lt;code&gt;[mysqld]&lt;/code&gt; section of &lt;code&gt;/etc/my.cnf.d/server.cnf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/etc/my.cnf.d/server.cnf&lt;/code&gt; 의 &lt;code&gt;[mysqld]&lt;/code&gt; 섹션에 다음 행을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="642dd4985f4ec84cb270742f73e318e373498ff3" translate="yes" xml:space="preserve">
          <source>Add the following to the /etc/rc.local or /etc/rc.d/rc.local (centos7) file:</source>
          <target state="translated">/etc/rc.local 또는 /etc/rc.d/rc.local(centos7) 파일에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="704c7e95bb8a1b58ce145e3aaa724c6488885049" translate="yes" xml:space="preserve">
          <source>Add the following to your local startup script (/etc/rc.local or similar), modifying as necessary:</source>
          <target state="translated">필요에 따라 수정하여 로컬 시작 스크립트 (/etc/rc.local 또는 이와 유사한)에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b070ddd0364faf16ae856e941ff67bd49016af2c" translate="yes" xml:space="preserve">
          <source>Add the options to the [mysqld] section of your my.cnf file.</source>
          <target state="translated">my.cnf 파일의 [mysqld] 섹션에 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e403bc38840d03281d778e7a5d3408f1b1e0baec" translate="yes" xml:space="preserve">
          <source>Add the path to it in the CLASSPATH environment variable or in the connect_class_path variable. This is like what is done to declare JDBC drivers.</source>
          <target state="translated">CLASSPATH 환경 변수 또는 connect_class_path 변수에 경로를 추가하십시오. 이것은 JDBC 드라이버를 선언하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ba31e037ce4f981ae1b1a661082832f52ac4d46" translate="yes" xml:space="preserve">
          <source>Add these details to the &lt;code&gt;mysql&lt;/code&gt; section of the config file:</source>
          <target state="translated">구성 파일 의 &lt;code&gt;mysql&lt;/code&gt; 섹션에 다음 세부 정보를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="a036ac60afa32c8e8e7521315c863f9d8b08b0b2" translate="yes" xml:space="preserve">
          <source>Add this C and CXX flags</source>
          <target state="translated">이 C 및 CXX 플래그 추가</target>
        </trans-unit>
        <trans-unit id="f8a4d36a77b32b2c68de6f76d1b67fb33e9b49db" translate="yes" xml:space="preserve">
          <source>Add this line to the my.cnf file</source>
          <target state="translated">이 줄을 my.cnf 파일에 추가하십시오</target>
        </trans-unit>
        <trans-unit id="03a57c29143612f642be2444d0b4d6698eeecbcc" translate="yes" xml:space="preserve">
          <source>Add this text below the &lt;code&gt;&quot;Sid&quot;&lt;/code&gt; line:</source>
          <target state="translated">&lt;code&gt;&quot;Sid&quot;&lt;/code&gt; 줄 아래에이 텍스트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e38ad4e720f8204b875114ca8277d1efa1acc294" translate="yes" xml:space="preserve">
          <source>Add this to C flags</source>
          <target state="translated">이것을 C 플래그에 추가</target>
        </trans-unit>
        <trans-unit id="7e0565441ebdf95443160c7feb63bcb41bf6ba6b" translate="yes" xml:space="preserve">
          <source>Add this to CXX flags</source>
          <target state="translated">이것을 CXX 플래그에 추가</target>
        </trans-unit>
        <trans-unit id="22d9c2dcdddb530473c60e143810aa88656b3951" translate="yes" xml:space="preserve">
          <source>Add this to configure options</source>
          <target state="translated">옵션을 구성하려면 이것을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="acd193f6e5a31b3d637ed2357780d090c5c66bfc" translate="yes" xml:space="preserve">
          <source>Add up Data_length + Index_length for all the InnoDB tables. Set &lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; to no more than 110% of that total.</source>
          <target state="translated">모든 InnoDB 테이블에 대해 Data_length + Index_length를 추가하십시오. &lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; 를 총계의 110 % 이하로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8d339558e1527c35aa3f35dd56a95d2aa301150" translate="yes" xml:space="preserve">
          <source>Add up Index_length for all the MyISAM tables. Set &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; no larger than that size.</source>
          <target state="translated">모든 MyISAM 테이블에 대해 Index_length를 추가하십시오. &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size를&lt;/a&gt; 해당 크기보다 크지 않게 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6c20dcefd63a56b99626427caca45b38c95b8b8" translate="yes" xml:space="preserve">
          <source>Add values. The following are examples:</source>
          <target state="translated">값을 추가하십시오. 다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d7c6c185b57d16051769cf8629919a017406e05" translate="yes" xml:space="preserve">
          <source>Add, where 'user' is the non-root username:</source>
          <target state="translated">여기서 'user'는 루트가 아닌 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0eb8c89efb5bd86049807f84ac540176220f841c" translate="yes" xml:space="preserve">
          <source>Add/remove partitions, or reorganize them, as long as the partitioning function allows these operations (see below);</source>
          <target state="translated">파티셔닝 기능이 이러한 작업을 허용하는 한 파티션을 추가 / 제거하거나 재구성하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c37195fe791a6d5ae7aa1680ddbf075189eb46ce" translate="yes" xml:space="preserve">
          <source>Add:</source>
          <target state="translated">Add:</target>
        </trans-unit>
        <trans-unit id="b68734c259106d131c65a8db8af829cf4fc02fda" translate="yes" xml:space="preserve">
          <source>Added</source>
          <target state="translated">Added</target>
        </trans-unit>
        <trans-unit id="5a8ca209f4e05208f7f172887b600023377d8c25" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;extended_keys=on, exists_to_in=on&lt;/code&gt;</source>
          <target state="translated">추가 &lt;code&gt;extended_keys=on, exists_to_in=on&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad2df9d86312339e3f039dba016cb27c15c7d8c5" translate="yes" xml:space="preserve">
          <source>Added as a deprecated and ignored option in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1026-release-notes/&quot;&gt;MariaDB 10.2.6&lt;/a&gt; (which uses InnoDB as default instead of XtraDB) to allow for easier upgrades.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1026-release-notes/&quot;&gt;MariaDB 10.2.6&lt;/a&gt; 에서 더 이상 사용되지 않고 무시되는 옵션으로 추가되어 (XtraDB 대신 InnoDB를 기본값으로 사용) 업그레이드가 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="ca2d1cd00186c035cdaf5cb8b4f2fca747b42cde" translate="yes" xml:space="preserve">
          <source>Added extra logging to slow log of 'Thread_id, Schema, Query Cache hit, Rows sent and Rows examined'</source>
          <target state="translated">'Thread_id, Schema, Query Cache 적중, 행 전송 및 행 검사'의 느린 로그에 추가 로깅을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="e81c1632ddcd9fde6d05a554839a0023405a4562" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="b80c4f989f7cd3977ddb381cfe422b09e33ada9b" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="d55816af99a8c2e64fd2cbc77e9ab6701c5d7ba6" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="8488b21b6c1a5e6b32a2a632e82b3cd3030e6dc2" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="629d91c154fa1e1e7f40b6fcd2784d048b53fb2b" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="6fde4a9b6ee14dab29865aadd6a4a61d5698e4b5" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;. From &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10212-release-notes/&quot;&gt;MariaDB 10.2.12&lt;/a&gt; only disallowed for table aliases.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; 에서 추가되었습니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10212-release-notes/&quot;&gt;MariaDB 10.2.12&lt;/a&gt; 부터는 테이블 별칭에 대해서만 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f93e1d3aefba8c1b243690ecc076a04963e956c" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="2210416db4d5e18d275fcb3539fd74cf290a0605" translate="yes" xml:space="preserve">
          <source>Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1030-release-notes/&quot;&gt;MariaDB 10.3.0&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1030-release-notes/&quot;&gt;MariaDB 10.3.0&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="55ae615f0320770df382e38fda534d7b2c58351f" translate="yes" xml:space="preserve">
          <source>Added log-slow-file as synonym for 'slow-log-file', as most slow-log variables starts with 'log-slow'</source>
          <target state="translated">대부분의 느린 로그 변수는 'log-slow'로 시작하므로 'slow-log-file'의 동의어로 log-slow-file을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="b0ddf911b839875534b682c07d3ee3ce20add5df" translate="yes" xml:space="preserve">
          <source>Added log-slow-time as synonym for long-query-time.</source>
          <target state="translated">긴 쿼리 시간에 대한 동의어로 log-slow-time을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="a488aa5bda8bf7c92c91f30873a08cd53bd3ddee" translate="yes" xml:space="preserve">
          <source>Added new session variables log_slow_rate_limit, log_slow_verbosity, log_slow_filter</source>
          <target state="translated">새로운 세션 변수 log_slow_rate_limit, log_slow_verbosity, log_slow_filter 추가</target>
        </trans-unit>
        <trans-unit id="881089ec03eb861139ba74b97e5cec8d920d5686" translate="yes" xml:space="preserve">
          <source>Added optional logging to slow log, through log_slow_verbosity, of query plan statistics</source>
          <target state="translated">쿼리 계획 통계의 log_slow_verbosity를 통해 느린 로그에 선택적 로깅을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d2d1c6e882a3eb42bb5fc17e4b5963f6247e2e2d" translate="yes" xml:space="preserve">
          <source>Addenda: The above AND/OR works well in older versions of MySQL; this works better in MariaDB and newer versions of MySQL:</source>
          <target state="translated">부록 : 위의 AND / OR은 이전 버전의 MySQL에서 잘 작동합니다. 이것은 MariaDB 및 최신 버전의 MySQL에서 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="74a3607832c983c1be0996342b182ed538f5151b" translate="yes" xml:space="preserve">
          <source>Adding Another Node to a Cluster</source>
          <target state="translated">클러스터에 다른 노드 추가</target>
        </trans-unit>
        <trans-unit id="59a0e050b39a453b7e61f2fc02cced2730ebd44e" translate="yes" xml:space="preserve">
          <source>Adding DBRoots</source>
          <target state="translated">DBRoot 추가</target>
        </trans-unit>
        <trans-unit id="be8a4a131e0812f1873d0a86821675f22c0147fd" translate="yes" xml:space="preserve">
          <source>Adding DataFlex 3.1c .dat Files As An External Table Type With CONNECT</source>
          <target state="translated">CONNECT를 사용하여 DataFlex 3.1c .dat 파일을 외부 테이블 유형으로 추가</target>
        </trans-unit>
        <trans-unit id="9a0406cb9a2cb72189b61c5daa9de482fe3b95d1" translate="yes" xml:space="preserve">
          <source>Adding MFA</source>
          <target state="translated">MFA 추가</target>
        </trans-unit>
        <trans-unit id="3015f7a0fd5e58aa73219a7a9c618f3f860414a6" translate="yes" xml:space="preserve">
          <source>Adding Support for an InnoDB Page Compression Algorithm</source>
          <target state="translated">InnoDB 페이지 압축 알고리즘에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="3e60bd3c1e5d471bc0f96a80735897207fb82725" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index to a table that does not have a user-defined &lt;code&gt;FTS_DOC_ID&lt;/code&gt; column will require the table to be rebuilt once. When the table is rebuilt, the system adds a hidden &lt;code&gt;FTS_DOC_ID&lt;/code&gt; column. From that point forward, adding additional &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; indexes to the same table will not require the table to be rebuilt when &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;code&gt;FTS_DOC_ID&lt;/code&gt; 열이 없는 테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스를 추가 하려면 테이블을 한 번 다시 작성해야합니다. 테이블이 재 빌드되면 시스템은 숨겨진 &lt;code&gt;FTS_DOC_ID&lt;/code&gt; 열을 추가합니다 . 그 시점부터 동일한 테이블에 추가 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스를 추가 하면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정 될 때 테이블을 다시 빌드 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="40ea823f57e1b86722ecaaf12b82cfd77882cb76" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index to a table that does not have a user-defined &lt;code&gt;FTS_DOC_ID&lt;/code&gt; column will require the table to be rebuilt once. When the table is rebuilt, the system adds a hidden &lt;code&gt;FTS_DOC_ID&lt;/code&gt; column. This initial operation will have to be performed with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.From that point forward, adding additional &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; indexes to the same table will not require the table to be rebuilt, and &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; can be set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;code&gt;FTS_DOC_ID&lt;/code&gt; 열이 없는 테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스를 추가 하려면 테이블을 한 번 다시 작성해야합니다. 테이블이 재 빌드되면 시스템은 숨겨진 &lt;code&gt;FTS_DOC_ID&lt;/code&gt; 열을 추가합니다 . 이 초기 작업은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정 한 상태에서 수행해야합니다. 그 시점 부터 동일한 테이블에 추가 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스를 추가 하면 테이블을 다시 작성할 필요가 없으며 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80b036426108681c2be9a0f2da204a6a42167a4b" translate="yes" xml:space="preserve">
          <source>Adding a Fulltext Index</source>
          <target state="translated">전체 텍스트 색인 추가</target>
        </trans-unit>
        <trans-unit id="de2eb624f6ad84293ee2ef7030f72a12b1d16989" translate="yes" xml:space="preserve">
          <source>Adding a New &lt;code&gt;ENUM&lt;/code&gt; Option</source>
          <target state="translated">새로운 &lt;code&gt;ENUM&lt;/code&gt; 옵션 추가</target>
        </trans-unit>
        <trans-unit id="4c9610783d89261b096989bc8db7a206ff5aff52" translate="yes" xml:space="preserve">
          <source>Adding a New &lt;code&gt;SET&lt;/code&gt; Option</source>
          <target state="translated">새로운 &lt;code&gt;SET&lt;/code&gt; 옵션 추가</target>
        </trans-unit>
        <trans-unit id="8b562f712d5c9a733722d5f356a19d464fa6dc65" translate="yes" xml:space="preserve">
          <source>Adding a Plain Index</source>
          <target state="translated">일반 색인 추가</target>
        </trans-unit>
        <trans-unit id="a3900c08eba141ea0330314b3fb7784d1bd680ad" translate="yes" xml:space="preserve">
          <source>Adding a Spatial Index</source>
          <target state="translated">공간 인덱스 추가</target>
        </trans-unit>
        <trans-unit id="9cf6e8e876624b527d89abb32fb4e72981b0d5d3" translate="yes" xml:space="preserve">
          <source>Adding a column.</source>
          <target state="translated">열 추가</target>
        </trans-unit>
        <trans-unit id="f97ec4281c053bb59bd67b9ccf506d3d40dfc864" translate="yes" xml:space="preserve">
          <source>Adding a compressed table:</source>
          <target state="translated">압축 테이블 추가 :</target>
        </trans-unit>
        <trans-unit id="19c3c16cfa47c9864f4a7269172022b8e5402be3" translate="yes" xml:space="preserve">
          <source>Adding a constant row:</source>
          <target state="translated">상수 행 추가 :</target>
        </trans-unit>
        <trans-unit id="40795264fa947949ab66a7c9db844e5f47313308" translate="yes" xml:space="preserve">
          <source>Adding a constraint:</source>
          <target state="translated">구속 조건 추가 :</target>
        </trans-unit>
        <trans-unit id="ace4a7f41ccab00934dd7b5802733df5d461efa7" translate="yes" xml:space="preserve">
          <source>Adding a large LIMIT to a subquery may make things work. &lt;a href=&quot;../mariadb/why-is-order-by-in-a-from-subquery-ignored/index&quot;&gt;Why ORDER BY in subquery is ignored&lt;/a&gt;</source>
          <target state="translated">하위 쿼리에 큰 LIMIT를 추가하면 문제가 해결 될 수 있습니다. &lt;a href=&quot;../mariadb/why-is-order-by-in-a-from-subquery-ignored/index&quot;&gt;하위 쿼리의 ORDER BY가 무시되는 이유&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c24c88b68be68e6547ee7a881b2c34aa158d3a5" translate="yes" xml:space="preserve">
          <source>Adding a new column:</source>
          <target state="translated">새 열 추가 :</target>
        </trans-unit>
        <trans-unit id="961bb451b5dc48ebf785bea7d96a52beaf8ea03a" translate="yes" xml:space="preserve">
          <source>Adding a new flag:</source>
          <target state="translated">새 플래그 추가하기 :</target>
        </trans-unit>
        <trans-unit id="e7ef1df5849f963f34fc94e7cd4dddd92b1c459a" translate="yes" xml:space="preserve">
          <source>Adding a new row to sq2, causing all evaluations to be false:</source>
          <target state="translated">sq2에 새 행을 추가하면 모든 평가가 거짓이됩니다.</target>
        </trans-unit>
        <trans-unit id="2d13948c0cda594b202883137fc7e27bc4fca219" translate="yes" xml:space="preserve">
          <source>Adding a query to the query cache. This is done automatically for cacheable queries (see (&lt;a href=&quot;#queries-stored-in-the-query-cache&quot;&gt;Queries Stored in the Query Cache&lt;/a&gt;) when the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;ON&lt;/code&gt; and the query contains no SQL_NO_CACHE clause, or when the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;DEMAND&lt;/code&gt;, and the query contains the SQL_CACHE clause.</source>
          <target state="translated">쿼리 캐시에 쿼리 추가 이것은 ((참조 자동으로 캐시 쿼리 수행됩니다 &lt;a href=&quot;#queries-stored-in-the-query-cache&quot;&gt;쿼리 캐시에 저장된 쿼리&lt;/a&gt; )을 할 때 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; 시스템 변수로 설정되어 &lt;code&gt;1&lt;/code&gt; , 또는 &lt;code&gt;ON&lt;/code&gt; 쿼리가 더 SQL_NO_CACHE 절, 또는 경우에 포함되지 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; 시스템 변수가 설정에 &lt;code&gt;2&lt;/code&gt; , 또는 &lt;code&gt;DEMAND&lt;/code&gt; 쿼리에 SQL_CACHE 절이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3daefbc9a0cba05d6d8d86b8a5302c4a3bd7ef7" translate="yes" xml:space="preserve">
          <source>Adding a second row to sq1, where the evaluation for that record is false:</source>
          <target state="translated">sq1에 두 번째 행을 추가하면 해당 레코드에 대한 평가가 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a40384fc16bc0eff1340ea53201903b3fcb8307b" translate="yes" xml:space="preserve">
          <source>Adding a second unique column:</source>
          <target state="translated">두 번째 고유 열 추가 :</target>
        </trans-unit>
        <trans-unit id="42a4724910ce5c13063e404b7187a5511311f3d3" translate="yes" xml:space="preserve">
          <source>Adding an auto-increment column requires a lock</source>
          <target state="translated">자동 증분 열을 추가하려면 잠금이 필요합니다</target>
        </trans-unit>
        <trans-unit id="3f615d2c17c64785437967b733c12dfbf3c36fc5" translate="yes" xml:space="preserve">
          <source>Adding and Removing Time Periods</source>
          <target state="translated">기간 추가 및 제거</target>
        </trans-unit>
        <trans-unit id="5adc509f25e9bdb3357d220fa6160f5cc9baa482" translate="yes" xml:space="preserve">
          <source>Adding and maintaining indexes adds overhead, and even with indexes on &lt;em&gt;dept&lt;/em&gt; and &lt;em&gt;salary&lt;/em&gt;, each subquery execution adds overhead by performing a lookup through the index.</source>
          <target state="translated">인덱스를 추가하고 유지 관리하면 오버 헤드가 추가되고 &lt;em&gt;dept&lt;/em&gt; 및 &lt;em&gt;salary&lt;/em&gt; 에 인덱스가 있더라도 각 하위 쿼리 실행은 인덱스를 통해 조회를 수행하여 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="437cad79a5d24707d0d2bf1818bf31253dcbab04" translate="yes" xml:space="preserve">
          <source>Adding and subtracting 1 (simple arithmetic).</source>
          <target state="translated">1을 더하고 빼기 (간단한 산술).</target>
        </trans-unit>
        <trans-unit id="d50be1683a32089e95891f8253bb817cbaf2cb71" translate="yes" xml:space="preserve">
          <source>Adding foreign keys needs foreign_key_checks=OFF</source>
          <target state="translated">외래 키를 추가하려면 foreign_key_checks = OFF가 필요합니다</target>
        </trans-unit>
        <trans-unit id="15343edf9b54aa6e0d3513cb3092a56bee1b6b8b" translate="yes" xml:space="preserve">
          <source>Adding module to AWS EC2 instances.</source>
          <target state="translated">AWS EC2 인스턴스에 모듈 추가</target>
        </trans-unit>
        <trans-unit id="5ee5537465e7617d742465506e244a79bc1312f3" translate="yes" xml:space="preserve">
          <source>Adding modules</source>
          <target state="translated">모듈 추가</target>
        </trans-unit>
        <trans-unit id="8194fb12f90701141d6cb776d453ac002bc6d45f" translate="yes" xml:space="preserve">
          <source>Adding more data types, in particular unsigned ones (done for unsigned).</source>
          <target state="translated">서명되지 않은 데이터 유형, 특히 서명되지 않은 데이터 유형 추가</target>
        </trans-unit>
        <trans-unit id="769d5e92b0ec5a49a2a8b6d6f6a54030757738c0" translate="yes" xml:space="preserve">
          <source>Adding more optimize tools (block indexing, dynamic indexing, etc.) (done)</source>
          <target state="translated">최적화 도구 (블록 인덱싱, 동적 인덱싱 등) 추가 (완료)</target>
        </trans-unit>
        <trans-unit id="e7487fd68e5ba249b94565867960fe24fb1c8b6c" translate="yes" xml:space="preserve">
          <source>Adding more table types.</source>
          <target state="translated">더 많은 테이블 유형 추가</target>
        </trans-unit>
        <trans-unit id="f15717ee40f2214b3100eea1b5e2bae3dd4ce3b8" translate="yes" xml:space="preserve">
          <source>Adding new keys. The larger the index, the more time it takes to keep keys updated.</source>
          <target state="translated">새 키 추가 인덱스가 클수록 키를 업데이트하는 데 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="e3c088fb0c6195c1115038e78a1b044e76c64391" translate="yes" xml:space="preserve">
          <source>Adding new row to the list of rows to be inserted by the delayed-insert handler thread.</source>
          <target state="translated">지연 삽입 핸들러 스레드에 의해 삽입 될 행 목록에 새 행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="730d6faa735218f5634b66375ea4a391566c434b" translate="yes" xml:space="preserve">
          <source>Adding or Removing System Versioning To/From a Table</source>
          <target state="translated">테이블에 시스템 버전 관리 추가 또는 제거</target>
        </trans-unit>
        <trans-unit id="8bbac103e6e4499a541c58fc3d6a30417519ca43" translate="yes" xml:space="preserve">
          <source>Adding real columns has the following advantages over encoding columns into a single &quot;expandable&quot; column:</source>
          <target state="translated">실제 열을 추가하면 열을 단일 &quot;확장 가능&quot;열로 인코딩하는 것보다 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3531fa8a253fe4c6725dd6e8de9d3420be95ff" translate="yes" xml:space="preserve">
          <source>Adding rows to the storage engine.</source>
          <target state="translated">스토리지 엔진에 행 추가</target>
        </trans-unit>
        <trans-unit id="a4641b297fc0cdd5728016d1a2eb9c6cc5abc17f" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB APT repository</source>
          <target state="translated">MariaDB APT 저장소 추가</target>
        </trans-unit>
        <trans-unit id="6d2751683d09f79169d861324151027f62de6083" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB AX YUM repository</source>
          <target state="translated">MariaDB AX YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="10e29772042b3b6fe5e657ea8f4be67446eb7fef" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore API APT-GET repository</source>
          <target state="translated">MariaDB ColumnStore API APT-GET 저장소 추가</target>
        </trans-unit>
        <trans-unit id="08fca878469937d32d4aba876c59dfcb02f47e36" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore API YUM repository</source>
          <target state="translated">MariaDB ColumnStore API YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="108cffbe28d39a7651aff8fdd1eadbeb805ee338" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore APT-GET repository</source>
          <target state="translated">MariaDB ColumnStore APT-GET 리포지토리 추가</target>
        </trans-unit>
        <trans-unit id="520033138c5dbfae7c53ea2bf4649a9ee3c1d1c6" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore Data Adapters APT-GET repository</source>
          <target state="translated">MariaDB ColumnStore 데이터 어댑터 APT-GET 저장소 추가</target>
        </trans-unit>
        <trans-unit id="622c5b0e3ae4b3c6d493dd9c9a2cabc36e319564" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore Data Adapters YUM repository</source>
          <target state="translated">MariaDB ColumnStore 데이터 어댑터 YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="d9e8c9868c32f3d7c7ed55bf180789818a964d3e" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore Tools APT-GET repository</source>
          <target state="translated">MariaDB ColumnStore 도구 APT-GET 저장소 추가</target>
        </trans-unit>
        <trans-unit id="84bd644a942f82ed2434d9a73eff505b8dbcb78d" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore Tools YUM repository</source>
          <target state="translated">MariaDB ColumnStore 도구 YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="8f659283a580433e0effd8f8910abf32eae7cde4" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore Tools ZYPPER repository</source>
          <target state="translated">MariaDB ColumnStore 도구 ZYPPER 저장소 추가</target>
        </trans-unit>
        <trans-unit id="9a3ed9350c02c601db16ad9e1ebfe065ca962a49" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore YUM repository</source>
          <target state="translated">MariaDB ColumnStore YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="3c7d859fdc2bc990951ccf724990528430ea5880" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ColumnStore ZYPPER repository</source>
          <target state="translated">MariaDB ColumnStore ZYPPER 저장소 추가</target>
        </trans-unit>
        <trans-unit id="db3e84b593ce4d651ee7a0d36803ee847ad4663f" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB MaxScale APT-GET repository</source>
          <target state="translated">MariaDB MaxScale APT-GET 리포지토리 추가</target>
        </trans-unit>
        <trans-unit id="4c82fff5a2e1fc9f3fe673f9bd7014ff6e704e61" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB MaxScale YUM repository</source>
          <target state="translated">MariaDB MaxScale YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="9d87989d9e3c9e08380b925db7f4722d7c3fd859" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB MaxScale ZYPPER repository</source>
          <target state="translated">MariaDB MaxScale ZYPPER 리포지토리 추가</target>
        </trans-unit>
        <trans-unit id="42456285ca2b73c2d05122f4a97622f5906b4ff7" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB YUM repository</source>
          <target state="translated">MariaDB YUM 저장소 추가</target>
        </trans-unit>
        <trans-unit id="d550587825e1997469590cdacd780b7cfc6cafba" translate="yes" xml:space="preserve">
          <source>Adding the MariaDB ZYpp repository</source>
          <target state="translated">MariaDB ZYpp 저장소 추가</target>
        </trans-unit>
        <trans-unit id="87b4f9ce7d3f88bc9ee65268e80377c5213fd3c2" translate="yes" xml:space="preserve">
          <source>Adding/subtracting 1 is rather complex (see the code).</source>
          <target state="translated">1을 더하거나 빼는 것은 다소 복잡합니다 (코드 참조).</target>
        </trans-unit>
        <trans-unit id="01f0b16cc25b38fa01210fc3cc98685517096e09" translate="yes" xml:space="preserve">
          <source>Addition Operator (+)</source>
          <target state="translated">덧셈 연산자 (+)</target>
        </trans-unit>
        <trans-unit id="e67c63595cb7909fbff2aab3aa4fe5c2d201f808" translate="yes" xml:space="preserve">
          <source>Addition information from the tool can be obtained by running 'help'</source>
          <target state="translated">'help'를 실행하여 도구에서 추가 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a2e967a40e9e81fc8d1826dbc41a2c2924ade2b" translate="yes" xml:space="preserve">
          <source>Addition operator</source>
          <target state="translated">덧셈 연산자</target>
        </trans-unit>
        <trans-unit id="e372ea45fd570b0859356c6972474a58f8da3b86" translate="yes" xml:space="preserve">
          <source>Addition.</source>
          <target state="translated">Addition.</target>
        </trans-unit>
        <trans-unit id="a04911213bd718929a3437b4b1fc134fc8971712" translate="yes" xml:space="preserve">
          <source>Additional Dependencies</source>
          <target state="translated">추가 종속성</target>
        </trans-unit>
        <trans-unit id="a3f2eb026851d3fa69c93b750a0dbdd6948d4a4f" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.0, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.0에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="5d9fe4dd2d5cc2fa0387652cf1ee80a5307a5124" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.1, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.1에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="3a54079578f0a061aafebd7e1b2d20ed3fcc408a" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.2, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.2에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="8b79dd184deb025ae41a1520b53ef90f8e77eb99" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.3, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.3에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="d1f16a914841637769a56e5cbc6effff98f84e63" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.4, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.4에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f48d07257a7429e951ab0b409f6d98bb9fb09d14" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.5, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.5에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="219b2ff42c1864da0e68f1e6d89aa7d3e6f368b0" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.6, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.6에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="8ce17ceeb067b706ae53acaf9acf0597e4cc0b9c" translate="yes" xml:space="preserve">
          <source>Additional Dependency Packages exist for 1.1.7, so make sure you install those based on the &quot;Preparing for ColumnStore Installation&quot; Guide.</source>
          <target state="translated">1.1.7에는 추가 종속성 패키지가 있으므로 &quot;ColumStore 설치 준비&quot;안내서에 따라 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="ecfe29ef8fcfc7c6552fb9793fd0884a7b9c0a8b" translate="yes" xml:space="preserve">
          <source>Additional Information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="667a507d073227ce7c45709900307e8822af4f87" translate="yes" xml:space="preserve">
          <source>Additional Information on the ODBC connector:</source>
          <target state="translated">ODBC 커넥터에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="4f5ec75d4137abcaa6fa01901ef8ef95eb751ab6" translate="yes" xml:space="preserve">
          <source>Additional Library Install: Jemalloc</source>
          <target state="translated">추가 라이브러리 설치 : Jemalloc</target>
        </trans-unit>
        <trans-unit id="27d8f16ffb3c47a8db5a28b248db55e1a46c2225" translate="yes" xml:space="preserve">
          <source>Additional SQL statements are supported;</source>
          <target state="translated">추가 SQL 문이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="404361ab64efa6dc15359f7789c9e4793cb7fb5d" translate="yes" xml:space="preserve">
          <source>Additional Software</source>
          <target state="translated">추가 소프트웨어</target>
        </trans-unit>
        <trans-unit id="b1b2de5740308f4c9e44b3faf8398537433de2ab" translate="yes" xml:space="preserve">
          <source>Additional access options</source>
          <target state="translated">추가 액세스 옵션</target>
        </trans-unit>
        <trans-unit id="d30eaddb76b986470210a6e30cbeb9bd1aed739f" translate="yes" xml:space="preserve">
          <source>Additional arguments: If a third integer argument is given, it specifies the position (zero based) of the added value:</source>
          <target state="translated">추가 인수 : 세 번째 정수 인수가 제공되면 추가 된 값의 위치 (0부터 시작)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="14af03f0de3a35eed5ec9cc855aac4f2c35afbd5" translate="yes" xml:space="preserve">
          <source>Additional columns must be either &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;TIMESTAMP&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;FLOAT&lt;/code&gt;. They will be bound to the attributes provided in the Sphinx result set by name, so their names must match the attribute names specified in &lt;code&gt;sphinx.conf&lt;/code&gt;. If there's no such attribute name in the Sphinx search results, the additional columns will have &lt;code&gt;NULL&lt;/code&gt; values.</source>
          <target state="translated">추가 열은 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;TIMESTAMP&lt;/code&gt; , &lt;code&gt;BIGINT&lt;/code&gt; , &lt;code&gt;VARCHAR&lt;/code&gt; 또는 &lt;code&gt;FLOAT&lt;/code&gt; 이어야합니다 . 이름별로 Sphinx 결과 세트에 제공된 속성에 바인딩되므로 이름이 &lt;code&gt;sphinx.conf&lt;/code&gt; 에 지정된 속성 이름과 일치해야합니다 . Sphinx 검색 결과에 해당 속성 이름이 없으면 추가 열에 &lt;code&gt;NULL&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6ed1e3b698afc169958c83b59b5f6c0fe14b55" translate="yes" xml:space="preserve">
          <source>Additional details</source>
          <target state="translated">추가 세부 사항</target>
        </trans-unit>
        <trans-unit id="06798fb94e41ec9754852a49b72c81cc9d8c4aaa" translate="yes" xml:space="preserve">
          <source>Additional documentation</source>
          <target state="translated">추가 문서</target>
        </trans-unit>
        <trans-unit id="8d0db9b2ac3b60fe4dd7939ee2fe34e4c1bdf4b7" translate="yes" xml:space="preserve">
          <source>Additional information about a column, for example whether the column is an &lt;a href=&quot;../invisible-columns/index&quot;&gt;invisible column&lt;/a&gt;, or, from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt;, &lt;code&gt;WITHOUT SYSTEM VERSIONING&lt;/code&gt; if the table is not a &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;system-versioned table&lt;/a&gt;. A MySQL and MariaDB extension.</source>
          <target state="translated">칼럼에 대한 추가 정보는, 예를 들어 열은인지 &lt;a href=&quot;../invisible-columns/index&quot;&gt;보이지 열&lt;/a&gt; 로부터 또는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt; , &lt;code&gt;WITHOUT SYSTEM VERSIONING&lt;/code&gt; 테이블이 아닌 경우 &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;시스템 버전 테이블&lt;/a&gt; . MySQL 및 MariaDB 확장.</target>
        </trans-unit>
        <trans-unit id="23c291d1fea0e9c2d22e40e47fc4139dd64b55cd" translate="yes" xml:space="preserve">
          <source>Additional information can be found in this document on how to setup and install using the 'apt-get' package repo command:</source>
          <target state="translated">이 문서에서 'apt-get'package repo 명령을 사용하여 설정 및 설치하는 방법에 대한 추가 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4716d561403437a202b8bb024cea57d1809a406" translate="yes" xml:space="preserve">
          <source>Additional information can be found in this document on how to setup and install using the 'yum' package repo command:</source>
          <target state="translated">이 문서에서 'yum'package repo 명령을 사용하여 설정 및 설치하는 방법에 대한 추가 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ff6877bfaba4a416c4051af3555430da7637de" translate="yes" xml:space="preserve">
          <source>Additional information on mcsimport:</source>
          <target state="translated">mcsimport에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="819b55e2ff44759e27996d5d9282d467ce598cbc" translate="yes" xml:space="preserve">
          <source>Additional information on setting to Maxscale:</source>
          <target state="translated">Maxscale 설정에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="d3fca83e27bb9be9ebb773e6341b28291d574899" translate="yes" xml:space="preserve">
          <source>Additional information on the Backup and Restore Tool:</source>
          <target state="translated">백업 및 복원 도구에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="8a342c9fcf7fa17d54c3e248bb808b79eb52a35b" translate="yes" xml:space="preserve">
          <source>Additional information on the ColumnStore API (Bulk Write SDK):</source>
          <target state="translated">ColumnStore API (Bulk Write SDK)에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="51f517f3a94f279eb6a5644881766cc845a3d619" translate="yes" xml:space="preserve">
          <source>Additional information on the Data Adapters:</source>
          <target state="translated">데이터 어댑터에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="46a3d55762dbac9547e21c524dc29aefeaad3e0e" translate="yes" xml:space="preserve">
          <source>Additional information on the Java Connector:</source>
          <target state="translated">Java 커넥터에 대한 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="89fc0136192edd174f8b659fbaed57b2ac3c67e1" translate="yes" xml:space="preserve">
          <source>Additional options available for this table type:</source>
          <target state="translated">이 테이블 유형에 사용 가능한 추가 옵션 :</target>
        </trans-unit>
        <trans-unit id="61d4cd7f48249227d331319b872c55a0f081f153" translate="yes" xml:space="preserve">
          <source>Additional package dependencies - snappy for rpms and libsnappy1 for debian</source>
          <target state="translated">추가 패키지 종속성-rpm의 경우 snappy, 데비안의 경우 libsnappy1</target>
        </trans-unit>
        <trans-unit id="36f6304c654ce165c0436ca21c4d03e2cc2988c1" translate="yes" xml:space="preserve">
          <source>Additional packages are required on each ColumnStore node.</source>
          <target state="translated">각 ColumnStore 노드에는 추가 패키지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5d898936415352112186aaae85064e1192c029e3" translate="yes" xml:space="preserve">
          <source>Additionally MariaDB implements a non-standard extension:</source>
          <target state="translated">또한 MariaDB는 비표준 확장을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="90caa1a49c08da6a9e167ccf2043f8eff0b0dc85" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; introduced three new functions that work with regular expressions: &lt;a href=&quot;../regexp_replace/index&quot;&gt;REGEXP_REPLACE()&lt;/a&gt;, &lt;a href=&quot;../regexp_instr/index&quot;&gt;REGEXP_INSTR()&lt;/a&gt; and &lt;a href=&quot;../regexp_substr/index&quot;&gt;REGEXP_SUBSTR()&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; 에는 정규 표현식과 함께 작동하는 &lt;a href=&quot;../regexp_replace/index&quot;&gt;REGEXP_REPLACE ()&lt;/a&gt; , &lt;a href=&quot;../regexp_instr/index&quot;&gt;REGEXP_INSTR ()&lt;/a&gt; 및 &lt;a href=&quot;../regexp_substr/index&quot;&gt;REGEXP_SUBSTR ()의&lt;/a&gt; 세 가지 새로운 함수가 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="45a47b8f2d7ce6d464b85e276915adc3c3b712a2" translate="yes" xml:space="preserve">
          <source>Additionally, internal on-disk tables are in the Aria table format instead of the &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; table format. This should speed up some &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; and &lt;a href=&quot;../count-distinct/index&quot;&gt;DISTINCT&lt;/a&gt; queries because Aria has better caching than MyISAM.</source>
          <target state="translated">또한 내부 온 디스크 테이블은 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블 형식 대신 Aria 테이블 형식 입니다. Aria는 MyISAM보다 캐싱이 더 좋기 때문에 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; 및 &lt;a href=&quot;../count-distinct/index&quot;&gt;DISTINCT&lt;/a&gt; 쿼리 속도가 빨라집니다 .</target>
        </trans-unit>
        <trans-unit id="19e346a3f3377271dcf07052284e6e28b315dd66" translate="yes" xml:space="preserve">
          <source>Additionally, one can choose to encrypt XtraDB/InnoDB log files (recommended).</source>
          <target state="translated">또한 XtraDB / InnoDB 로그 파일을 암호화하도록 선택할 수 있습니다 (권장).</target>
        </trans-unit>
        <trans-unit id="67239fc7fd8e334d33ed725b0e6c4e24b6a50fd0" translate="yes" xml:space="preserve">
          <source>Additionally, the &amp;ldquo;accept&amp;rdquo; option permit to keep those ill formatted lines with the bad field, and all succeeding fields of the record, nullified. If &amp;ldquo;accept&amp;rdquo; is specified without &amp;ldquo;maxerr&amp;rdquo;, all ill formatted lines will be accepted.</source>
          <target state="translated">또한 &quot;accept&quot;옵션을 사용하면 잘못된 필드와 레코드의 모든 후속 필드가 잘못된 형식의 행을 유지할 수 있습니다. &quot;maxerr&quot;없이 &quot;accept&quot;를 지정하면 모든 형식이 잘못된 행이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7da7fd6de393a89591a2cafd5857fff75e3d1876" translate="yes" xml:space="preserve">
          <source>Additionally, the application generates reports analyzing transaction activities. These reports are adapted for categories of customers (business, student, regular checking, savings) or for types of transactions (cash deposits, checks, ATM deposits, in-branch deposits, transfers, withdrawals). These reports can be run by the customers on their individual accounts or by the bank's back office on all customer activities.</source>
          <target state="translated">또한 응용 프로그램은 트랜잭션 활동을 분석하는 보고서를 생성합니다. 이 보고서는 고객 범주 (비즈니스, 학생, 정기 점검, 저축) 또는 거래 유형 (현금 예치금, 수표, ATM 예치금, 지점 내 예치금, 송금, 인출)에 적합합니다. 이 보고서는 고객이 개인 계정을 사용하거나 은행의 백 오피스에서 모든 고객 활동을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41ca4c4055b9f9ee46760a2102760b39660f303" translate="yes" xml:space="preserve">
          <source>Additionally, they are available in most other handler methods: the attributes are stored in the &lt;code&gt;.frm&lt;/code&gt; file and on every open MySQL makes them available to the engine by filling the corresponding &lt;code&gt;option_struct&lt;/code&gt; members of the table, fields, and keys.</source>
          <target state="translated">또한 대부분의 다른 핸들러 메소드에서 사용할 수 있습니다. 속성은 &lt;code&gt;.frm&lt;/code&gt; 파일에 저장 되며 열려있는 모든 MySQL에서 해당 &lt;code&gt;option_struct&lt;/code&gt; 를 채워 엔진에서 사용할 수있게합니다. 에서 테이블, 필드 및 키 멤버를 .</target>
        </trans-unit>
        <trans-unit id="76096b6de94f776b1f63166f930d1c9afc6ca136" translate="yes" xml:space="preserve">
          <source>Additionally, this server converts MariaDB Server query plans into ColumnStore query plan format. This format is essentially a parse tree, but adds execution hints from the optimizer to assist the User Module in converting the parse tree to a Job List.</source>
          <target state="translated">또한이 서버는 MariaDB 서버 쿼리 계획을 ColumnStore 쿼리 계획 형식으로 변환합니다. 이 형식은 기본적으로 구문 분석 트리이지만 사용자 모듈이 구문 분석 트리를 작업 목록으로 변환 할 수 있도록 최적화 프로그램의 실행 힌트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d70f93df5e8f9b55be44fbeee9d203972e3383d4" translate="yes" xml:space="preserve">
          <source>Address</source>
          <target state="translated">Address</target>
        </trans-unit>
        <trans-unit id="968b7eb485224d9200af0beadf4ac79e070cd9f6" translate="yes" xml:space="preserve">
          <source>Address in memory of the instrumented condition.</source>
          <target state="translated">계측 된 조건의 메모리에있는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="cebf2abc1b81636feac057bd082cffe8e470489c" translate="yes" xml:space="preserve">
          <source>Address in memory of the instrumented lock</source>
          <target state="translated">계측 잠금 메모리의 주소</target>
        </trans-unit>
        <trans-unit id="de70682f87b7d7f3f2bafb10d6d2bed721b23ecb" translate="yes" xml:space="preserve">
          <source>Address in memory of the object.</source>
          <target state="translated">객체의 메모리에있는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="4054ea043746fbb9a8d8c975900aa5fd6a02f8ef" translate="yes" xml:space="preserve">
          <source>Address in memory of the statement object.</source>
          <target state="translated">명령문 오브젝트의 메모리 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ec33841b2fe18efcd4387900d9dd7d59a4867fc3" translate="yes" xml:space="preserve">
          <source>Address in memory.</source>
          <target state="translated">메모리의 주소.</target>
        </trans-unit>
        <trans-unit id="3af1257ff7b238925c89b982f7571bcf69299311" translate="yes" xml:space="preserve">
          <source>Address in memory. Together with &lt;code&gt;FILE_NAME&lt;/code&gt; and &lt;code&gt;EVENT_NAME&lt;/code&gt; uniquely identifies a row.</source>
          <target state="translated">메모리의 주소. &lt;code&gt;FILE_NAME&lt;/code&gt; 및 &lt;code&gt;EVENT_NAME&lt;/code&gt; 과 (와) 함께 행을 고유하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="2217d9ceceb01aa2867c77bd94393a3bde67eb25" translate="yes" xml:space="preserve">
          <source>Adds &lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt; prior to &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt; and &lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt; to bottom of dump.</source>
          <target state="translated">&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt; 이전에 &lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE를&lt;/a&gt; 추가 하고 덤프 하단에 &lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe3c09eb051a1b3898107dcc99909ac931d701e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;N&lt;/code&gt; months to period &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;P&lt;/code&gt; is in the format YYMM or YYYYMM, and is not a date value. If &lt;code&gt;P&lt;/code&gt; contains a two-digit year, values from 00 to 69 are converted to from 2000 to 2069, while values from 70 are converted to 1970 upwards.</source>
          <target state="translated">기간 &lt;code&gt;P&lt;/code&gt; 에 &lt;code&gt;N&lt;/code&gt; 개월을 더 합니다 . &lt;code&gt;P&lt;/code&gt; 는 YYMM 또는 YYYYMM 형식이며 날짜 값이 아닙니다. &lt;code&gt;P&lt;/code&gt; 에 두 자리 연도가 포함 된 경우 00에서 69 사이의 값은 2000에서 2069로 변환되고 70에서 값은 1970 이상으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a553ab812be40d7e537b32ee5a815d08053aa8ff" translate="yes" xml:space="preserve">
          <source>Adds RocksDB, an LSM database with a great compression ratio that is optimized for flash storage.</source>
          <target state="translated">플래시 스토리지에 최적화 된 뛰어난 압축 비율을 가진 LSM 데이터베이스 인 RocksDB를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d232b39176b9f119595b1b9844298d971be855f3" translate="yes" xml:space="preserve">
          <source>Adds a column to the table. The syntax is the same as in &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;. If you are using &lt;code&gt;IF NOT_EXISTS&lt;/code&gt; the column will not be added if it was not there already. This is very useful when doing scripts to modify tables.</source>
          <target state="translated">테이블에 열을 추가합니다. 구문은 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일 합니다. &lt;code&gt;IF NOT_EXISTS&lt;/code&gt; 를 사용 중인 경우 열이 없으면 추가되지 않습니다. 스크립트를 수행하여 테이블을 수정할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="efbc685d75cd227632eaeb84f78e3a33bf3526df" translate="yes" xml:space="preserve">
          <source>Adds a time to a time or datetime</source>
          <target state="translated">시간 또는 날짜 시간에 시간을 추가합니다</target>
        </trans-unit>
        <trans-unit id="6083934ed6d59fc7294ace2b13af5c2d6ce32f27" translate="yes" xml:space="preserve">
          <source>Adds a time to a time or datetime.</source>
          <target state="translated">시간을 날짜 또는 시간에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cdea9e18ba0712782fc4b519ac92ea16166a70db" translate="yes" xml:space="preserve">
          <source>Adds extra rows to the resultset that represent super-aggregate summaries</source>
          <target state="translated">통합 집계를 나타내는 추가 행을 결과 집합에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e073b1112429d8f1caaabb5aad43b9f8774ef596" translate="yes" xml:space="preserve">
          <source>Adds or updates &lt;a href=&quot;../dynamic-columns/index&quot;&gt;dynamic columns&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../dynamic-columns/index&quot;&gt;동적 열을&lt;/a&gt; 추가하거나 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="9521eaabf57125856ec326950dca4751752dbaed" translate="yes" xml:space="preserve">
          <source>Adds or updates dynamic columns</source>
          <target state="translated">동적 열 추가 또는 업데이트</target>
        </trans-unit>
        <trans-unit id="1d120de7dfad55ec0c8249ed0c6b5147992f6a98" translate="yes" xml:space="preserve">
          <source>Adds or updates dynamic columns.</source>
          <target state="translated">동적 열을 추가하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="90b5d3ab6be79fb4ce4a0e77e1bee3e2e58fba5e" translate="yes" xml:space="preserve">
          <source>Adds spaces to a JSON document to make it look more readable</source>
          <target state="translated">더 읽기 쉽게 보이도록 JSON 문서에 공백을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5e5c3432d944563a206ea3f001111294438af353" translate="yes" xml:space="preserve">
          <source>Adds spaces to a JSON document to make it look more readable.</source>
          <target state="translated">더 읽기 쉽게 보이도록 JSON 문서에 공백을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9c35bae99391ebbfb4fe66b82f236d231d846407" translate="yes" xml:space="preserve">
          <source>Adds the integer expression interval to the date or datetime expression datetime_expr. The unit for interval is given by the unit argument, which should be one of the following values: MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.</source>
          <target state="translated">정수 표현식 간격을 날짜 또는 날짜 / 시간 표현식 datetime_expr에 추가합니다. 간격 단위는 unit 인수로 제공되며 MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER 또는 YEAR 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c2bea2b512e8820b649192884ca7aed475cab6ad" translate="yes" xml:space="preserve">
          <source>Adds to its first array argument all following arguments.</source>
          <target state="translated">첫 번째 배열 인수에 모든 다음 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="00df794f89a84f62a98091726792d5ca8f9a3948" translate="yes" xml:space="preserve">
          <source>Adds to its first array argument its second arguments (before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt;, all following arguments).</source>
          <target state="translated">첫 번째 배열 인수에 두 번째 인수를 추가합니다 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; 이전 , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt; , 모든 다음 인수).</target>
        </trans-unit>
        <trans-unit id="4525a3c0d763b0865a888fcd27f5fd785ebb9454" translate="yes" xml:space="preserve">
          <source>Adds to its first array argument its second arguments.</source>
          <target state="translated">첫 번째 배열 인수에 두 번째 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="586f80399b3b9af1af364cb06f93913917d76297" translate="yes" xml:space="preserve">
          <source>Adds to its first object argument its second argument.</source>
          <target state="translated">첫 번째 객체 인수에 두 번째 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2a6f035e6288fc6e66571927c203c35a6de95ecc" translate="yes" xml:space="preserve">
          <source>Adds two new Information Schema tables, WSREP_MEMBERSHIP and WSREP_STATUS</source>
          <target state="translated">두 개의 새로운 정보 스키마 테이블 인 WSREP_MEMBERSHIP 및 WSREP_STATUS를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="80ce1a302363e1d200710698497231c374e02608" translate="yes" xml:space="preserve">
          <source>Adjust the row count down if asynchronous replication (Statement Based) causes too much delay on the Slaves or hogs the table too much.</source>
          <target state="translated">비동기 복제 (상태 기반)로 인해 슬레이브에서 너무 많은 지연이 발생하거나 테이블을 너무 많이 끌 경우 행 카운트 다운을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8960142115ce9fa45b06348c549c60dd6d73da81" translate="yes" xml:space="preserve">
          <source>Adjusting table_open_cache to improve performance.</source>
          <target state="translated">성능 향상을 위해 table_open_cache 조정</target>
        </trans-unit>
        <trans-unit id="aa2de3bc70c67caf366a071a28f5b7489ac73ed5" translate="yes" xml:space="preserve">
          <source>Admin tool for monitoring, creating/dropping databases, stopping mysqld etc.</source>
          <target state="translated">모니터링, 데이터베이스 생성 / 삭제, mysqld 중지 등을위한 관리 도구</target>
        </trans-unit>
        <trans-unit id="0edfc27b161e92112452a12850184c80389dae02" translate="yes" xml:space="preserve">
          <source>Administering user accounts in MariaDB</source>
          <target state="translated">MariaDB에서 사용자 계정 관리</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="bf07f471a7ac7d5c68a2dbdfcb8e65ebb7af084f" translate="yes" xml:space="preserve">
          <source>Administrative SQL Statements</source>
          <target state="translated">관리 SQL 문</target>
        </trans-unit>
        <trans-unit id="0395f92d53383333d722f2c3fba6b664c18531d4" translate="yes" xml:space="preserve">
          <source>Advanced Execution Data</source>
          <target state="translated">고급 실행 데이터</target>
        </trans-unit>
        <trans-unit id="222acd06c9cd672f31a0791a5ba3b441a38b5597" translate="yes" xml:space="preserve">
          <source>Advanced R (Hadley Wickham; Chapman &amp;amp; Hall&amp;rsquo;s R Series): Book Online Version</source>
          <target state="translated">Advanced R (Hadley Wickham; Chapman &amp;amp; Hall 's R Series) : 온라인 예약</target>
        </trans-unit>
        <trans-unit id="574f6b08e6f2b3cba1d4b3e3b798531666c55e62" translate="yes" xml:space="preserve">
          <source>Advantages of Aria compared to MyISAM</source>
          <target state="translated">MyISAM과 비교 한 Aria의 장점</target>
        </trans-unit>
        <trans-unit id="9d46ccc95532b1204eaf38a1eadd2cb8e8c2bf0c" translate="yes" xml:space="preserve">
          <source>Advice? Avoid Case 1; too messy. Case 2 is ok if the extra rows are not too common. Case 3 may be the closest to &quot;once size fits all&quot;.</source>
          <target state="translated">조언? 사례 1을 피하십시오. 너무 지저분합니다. 여분의 행이 너무 일반적이지 않은 경우 사례 2는 괜찮습니다. 사례 3은 &quot;한 번에 맞는 크기&quot;에 가장 근접 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57fa55b5bd46c2d15f8c8f0571eb0d73b1e1e04" translate="yes" xml:space="preserve">
          <source>Affected rows</source>
          <target state="translated">영향을받는 행</target>
        </trans-unit>
        <trans-unit id="f9b777990e5834876525394d953bb6e09f4349b3" translate="yes" xml:space="preserve">
          <source>After 10 seconds...</source>
          <target state="translated">10 초 후 ...</target>
        </trans-unit>
        <trans-unit id="2011caf03e73af19874b4a7185d98fb169602dd3" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;INSERT DELAYED&lt;/code&gt;, &lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT()&lt;/a&gt; returns the number of the rows you tried to insert, not the number of the successful writes.</source>
          <target state="translated">후 &lt;code&gt;INSERT DELAYED&lt;/code&gt; , &lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT ()는&lt;/a&gt; 당신이 성공적으로 쓰기하지 수를 삽입하려 행의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05fe15527c28c3e06edf7cc3ce1de3051f0b1074" translate="yes" xml:space="preserve">
          <source>After Building</source>
          <target state="translated">건물 후</target>
        </trans-unit>
        <trans-unit id="342f41c403bf06b18e4d2365bb260cc720ee240d" translate="yes" xml:space="preserve">
          <source>After Installation</source>
          <target state="translated">설치 후</target>
        </trans-unit>
        <trans-unit id="f2662988c3c17a8354159f151b78cec97a726032" translate="yes" xml:space="preserve">
          <source>After MariaDB Server is started, you can log in:</source>
          <target state="translated">MariaDB 서버가 시작되면 다음과 같이 로그인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a7fa2942923eac817ccf5e0cf7bda404f92732" translate="yes" xml:space="preserve">
          <source>After MariaDB is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restarted&lt;/a&gt;, it will use the new log locations and file names.</source>
          <target state="translated">MariaDB가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;다시 시작&lt;/a&gt; 되면 새 로그 위치와 파일 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d28998905fa9e895ee617c3ec5697aaa246f34c6" translate="yes" xml:space="preserve">
          <source>After MariaDB is installed, and as long as the version number issue exists, an '&lt;code&gt;apt-get dist-upgrade&lt;/code&gt;' will try to remove MariaDB in order to install the &quot;upgraded&quot; &lt;code&gt;libmysqlclient&lt;/code&gt; and &lt;code&gt;mysql-common&lt;/code&gt; packages. To prevent this from happening you can &lt;em&gt;hold&lt;/em&gt; them so that apt doesn't try to upgrade them. To do so, open a terminal, become root with '&lt;code&gt;sudo -s&lt;/code&gt;', and then enter the following:</source>
          <target state="translated">MariaDB가 설치되고 버전 번호 문제가있는 한 ' &lt;code&gt;apt-get dist-upgrade&lt;/code&gt; '는 &quot;업그레이드 된&quot; &lt;code&gt;libmysqlclient&lt;/code&gt; 및 &lt;code&gt;mysql-common&lt;/code&gt; 패키지 를 설치하기 위해 MariaDB를 제거하려고 시도 합니다. 이 문제가 발생 하지 않도록 apt가 업그레이드를 시도하지 않도록 &lt;em&gt;유지할&lt;/em&gt; 수 있습니다. 이렇게하려면 터미널을 열고 ' &lt;code&gt;sudo -s&lt;/code&gt; '를 사용하여 루트가 된 후 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="2a99d5032d5f2adca476fbb9e4017c0198fd22a3" translate="yes" xml:space="preserve">
          <source>After MariaDB is installed, use the &lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt; command (as the root user) to install the HandlerSocket plugin. This command only needs to be run once, like so:</source>
          <target state="translated">MariaDB가 설치된 후 &lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt; 명령 (루트 사용자로)을 사용하여 HandlerSocket 플러그인을 설치하십시오. 이 명령은 다음과 같이 한 번만 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8f82eaf30933583ae6bec1208a14c4f16a969d8e" translate="yes" xml:space="preserve">
          <source>After a few tests, we can see that the log rotation is indeed working:</source>
          <target state="translated">몇 번의 테스트 후에 로그 회전이 실제로 작동하고 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54cf89e578424829a34aa2ce46bcb26083b36a6e" translate="yes" xml:space="preserve">
          <source>After a pause,</source>
          <target state="translated">일시 정지 후</target>
        </trans-unit>
        <trans-unit id="a76d892f88013dd3e2c69db4bacd80c7cce1c18a" translate="yes" xml:space="preserve">
          <source>After a temporary split, if the 'good' part of the cluster was still reachable and its state was modified, resynchronization occurs. As a part of it, nodes of the 'bad' part of the cluster drop all client connections. It might be quite unexpected, especially if the client was idle and did not even know anything wrong was happening. Please also note that after the connection to the isolated node is restored, if there is a flow on the node, it takes a long time for it to synchronize, during which the &quot;good&quot; node says that the cluster is already of the normal size and synced, while the rejoining node says it's only joined (but not synced). The connections keep getting 'unknown command'. It should pass eventually.</source>
          <target state="translated">After a temporary split, if the 'good' part of the cluster was still reachable and its state was modified, resynchronization occurs. As a part of it, nodes of the 'bad' part of the cluster drop all client connections. It might be quite unexpected, especially if the client was idle and did not even know anything wrong was happening. Please also note that after the connection to the isolated node is restored, if there is a flow on the node, it takes a long time for it to synchronize, during which the &quot;good&quot; node says that the cluster is already of the normal size and synced, while the rejoining node says it's only joined (but not synced). The connections keep getting 'unknown command'. It should pass eventually.</target>
        </trans-unit>
        <trans-unit id="621a435fefec894cc9beabe9a7eaf46b9d058b13" translate="yes" xml:space="preserve">
          <source>After adding a DBRoot, it must be assigned to a &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Module&lt;/a&gt; before it can be used. Use the &lt;code&gt;mcsadmin assignDbrootPmConfig&lt;/code&gt; command to do so. Note: The &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Module&lt;/a&gt; that the DBRoot is being assigned to must to Manually Offline. The system must be in a STOPPED state</source>
          <target state="translated">DBRoot를 추가 한 후에 는 사용하기 전에 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;성능 모듈에&lt;/a&gt; 할당해야합니다 . &lt;code&gt;mcsadmin assignDbrootPmConfig&lt;/code&gt; 명령을 사용하십시오 . 참고 : DBRoot가 할당 된 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;성능 모듈&lt;/a&gt; 은 수동 오프라인이어야합니다. 시스템은 STOPPED 상태 여야합니다</target>
        </trans-unit>
        <trans-unit id="56a4088fa1a5944c40a2b0af0bdc0aea0f839896" translate="yes" xml:space="preserve">
          <source>After all rows have finished processing, &lt;em&gt;x_deinit()&lt;/em&gt; is called, if present, to clean up by de-allocating any memory that was allocated in &lt;em&gt;x_init()&lt;/em&gt;.</source>
          <target state="translated">모든 행이 처리를 완료 한 후 &lt;em&gt;x_deinit ()&lt;/em&gt; 가 있으면 &lt;em&gt;x_init ()&lt;/em&gt; 에 할당 된 메모리를 할당 해제하여 정리합니다 .</target>
        </trans-unit>
        <trans-unit id="57ac6b583d5435e9596a86d8fbdbe2a9215b5cd4" translate="yes" xml:space="preserve">
          <source>After all the rows of data that were retrieved, you would see:</source>
          <target state="translated">검색된 모든 데이터 행이 끝나면 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc16d5c569452bbc2a8dd7ca765c7d63a51cfb3" translate="yes" xml:space="preserve">
          <source>After any configuration change, you will need to execute the following for the change to go into effect:</source>
          <target state="translated">구성을 변경 한 후 변경 사항을 적용하려면 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bf4b609baca1f231bf3a51abde31a6f67c1311d" translate="yes" xml:space="preserve">
          <source>After building the packages, it is a good idea to put them in a repository. See the &lt;a href=&quot;../creating_a_debian_repository/index&quot;&gt;Creating a Debian Repository&lt;/a&gt; page for instructions.</source>
          <target state="translated">패키지를 만든 후에는 저장소에 넣는 것이 좋습니다. (가)를 참조하십시오 &lt;a href=&quot;../creating_a_debian_repository/index&quot;&gt;데비안 저장소 만들기&lt;/a&gt; 지시 사항을.</target>
        </trans-unit>
        <trans-unit id="a7b97d87a45acee8600bf00a7adde3f10224942c" translate="yes" xml:space="preserve">
          <source>After building, a number of other steps are necessary:</source>
          <target state="translated">구축 후에는 여러 가지 다른 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fe25ce3f5ea3bec87f567a1f146d6de84f1c299d" translate="yes" xml:space="preserve">
          <source>After checking that the LRECL default or specified specification is correct, you can indicate to ignore that extra EOF character by:</source>
          <target state="translated">LRECL 기본 또는 지정된 스펙이 올바른지 확인한 후 다음을 수행하여 해당 추가 EOF 문자를 무시하도록 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="695029aa8af0d7b8ca122ac3c3af3763f61d4ca2" translate="yes" xml:space="preserve">
          <source>After completing one &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;, the next is being opened for sending to the slave.</source>
          <target state="translated">하나의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그를&lt;/a&gt; 완료 하면 슬레이브에 보낼 다음 바이너리 가 열립니다.</target>
        </trans-unit>
        <trans-unit id="1803ae2b5e66fa757a58f2a173361c039b6f047d" translate="yes" xml:space="preserve">
          <source>After conversion, examine &lt;code&gt;client-prog.c&lt;/code&gt; and make any necessary post-conversion revisions.</source>
          <target state="translated">변환 후 &lt;code&gt;client-prog.c&lt;/code&gt; 를 검사 하고 필요한 변환 후 수정을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8848b86501e6a7cd18506fc80b29f9f6045d2c6c" translate="yes" xml:space="preserve">
          <source>After copying a transactional table and before you use the table, we recommend that you run the command:</source>
          <target state="translated">트랜잭션 테이블을 복사 한 후 테이블을 사용하기 전에 다음 명령을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d113148dd8447f9750276fe46d681f11ef936c1" translate="yes" xml:space="preserve">
          <source>After create</source>
          <target state="translated">생성 후</target>
        </trans-unit>
        <trans-unit id="db66c55e6901aa755741244b00baf473eea2ddd9" translate="yes" xml:space="preserve">
          <source>After creating an account or logging in to an existing account, follow these steps to create an IAM User or Role with restricted privileges that will use (but not administer) your master encryption key.</source>
          <target state="translated">계정을 생성하거나 기존 계정에 로그인 한 후 다음 단계에 따라 마스터 암호화 키를 사용하지만 관리하지는 않는 제한된 권한으로 IAM 사용자 또는 역할을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="477914b282018c3d46fad377690e33ae7c0c983f" translate="yes" xml:space="preserve">
          <source>After disabling autocommit mode by setting the autocommit variable to zero, changes to transaction-safe tables (such as those for InnoDB or &lt;code&gt;NDBCLUSTER&lt;/code&gt;) are not made permanent immediately. You must use &lt;code&gt;COMMIT&lt;/code&gt; to store your changes to disk or ROLLBACK to ignore the changes.</source>
          <target state="translated">autocommit 변수를 0으로 설정하여 자동 커밋 모드를 비활성화 한 후에는 트랜잭션 안전 테이블 (InnoDB 또는 &lt;code&gt;NDBCLUSTER&lt;/code&gt; 와 같은 테이블)에 대한 변경 사항이 즉시 영구적으로 적용되지 않습니다. 당신은 사용해야 &lt;code&gt;COMMIT&lt;/code&gt; 변경 사항을 무시하는 디스크 또는 ROLLBACK에 대한 변경 사항을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d4251d3f7ec726aa06f87ccb57149440778dfe8b" translate="yes" xml:space="preserve">
          <source>After downloading the MariaDB RPM files, you might want to check their signatures. See &lt;a href=&quot;../checking-mariadb-rpm-package-signatures/index&quot;&gt;Checking MariaDB RPM Package Signatures&lt;/a&gt; for more information about checking signatures.</source>
          <target state="translated">MariaDB RPM 파일을 다운로드 한 후 서명을 확인할 수 있습니다. &lt;a href=&quot;../checking-mariadb-rpm-package-signatures/index&quot;&gt;서명 확인에&lt;/a&gt; 대한 자세한 내용은 MariaDB RPM 패키지 서명 확인을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fabf0a379a13c4fba85cbd1caefc4820a1c41d9d" translate="yes" xml:space="preserve">
          <source>After dropping the default table constraint called &lt;code&gt; CONSTRAINT_1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt; CONSTRAINT_1&lt;/code&gt; 이라는 기본 테이블 제약 조건을 삭제 한 후 :</target>
        </trans-unit>
        <trans-unit id="681456135fa51d5ce5e7c3b81ffcb6a24a6fb934" translate="yes" xml:space="preserve">
          <source>After editing the sources.list, do:</source>
          <target state="translated">sources.list를 편집 한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8f40c3636d199de4734992ff1936256957bdc116" translate="yes" xml:space="preserve">
          <source>After enabling it, you will be able to run the zypper command to install the build dependencies.</source>
          <target state="translated">활성화 한 후 zypper 명령을 실행하여 빌드 종속성을 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db494851018472da59a0309aaba962a87c6bd015" translate="yes" xml:space="preserve">
          <source>After enabling network connections in MariaDB as described above, we will be able to connect to the server from outside the container.</source>
          <target state="translated">위에서 설명한 것처럼 MariaDB에서 네트워크 연결을 활성화하면 컨테이너 외부에서 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e475a73e0dc2fb580b5a6527bb78f3fe66e458" translate="yes" xml:space="preserve">
          <source>After every transaction &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt;, the server normally has to flush any changes the transaction made to the &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; and the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; to disk (i.e. by calling system calls such as &lt;code&gt;fsync()&lt;/code&gt; or &lt;code&gt;fdatasync()&lt;/code&gt; or similar). This helps ensure that the data changes made by the transaction are stored durably on the disk. Disk flushing is a time-consuming operation, and can easily impose limits on throughput in terms of the number of transactions-per-second (TPS) which can be committed.</source>
          <target state="translated">모든 트랜잭션 &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt; 후에 서버는 일반적으로 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 와 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 에 대한 트랜잭션 을 디스크 로 플러시해야합니다 (예 : &lt;code&gt;fsync()&lt;/code&gt; 또는 &lt;code&gt;fdatasync()&lt;/code&gt; 또는 이와 유사한 시스템 호출 호출 ). 이는 트랜잭션에 의해 변경된 데이터가 디스크에 지속적으로 저장되도록합니다. 디스크 플러싱은 시간이 많이 걸리는 작업이며 커밋 할 수있는 초당 트랜잭션 수 (TPS)와 관련하여 처리량에 대한 제한을 쉽게 부과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9fd9a395ff4e3a60f1961af4b2573871a7e7cd" translate="yes" xml:space="preserve">
          <source>After executing this statement, you can refer to the database as a-b-c without the special #mysql50# prefix.</source>
          <target state="translated">이 명령문을 실행 한 후 특별한 # mysql50 # 접두어없이 데이터베이스를 abc로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be540bf0102c81cb856d3cb051abe01d7db70c5" translate="yes" xml:space="preserve">
          <source>After finding enough, or giving up because we are looking &quot;too far&quot;, make one last pass to get all the data, ORDERed and LIMITed</source>
          <target state="translated">&quot;너무 멀리&quot;보고 있기 때문에 충분한 것을 찾거나 포기한 후 마지막 데이터를 가져 오면 ORDERed 및 LIMITed의 모든 데이터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a620108cbc58e9ba37cf482716a067d08c1c755" translate="yes" xml:space="preserve">
          <source>After installation</source>
          <target state="translated">설치 후</target>
        </trans-unit>
        <trans-unit id="c306978196942a351277507a0f2cc2e585189f5c" translate="yes" xml:space="preserve">
          <source>After installation, start MariaDB Server:</source>
          <target state="translated">설치 후 MariaDB 서버를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2e462d4c01f0979a477c15580fc825eafa315e3a" translate="yes" xml:space="preserve">
          <source>After installation, your MariaDB Server instance will have a &quot;root&quot; user account and a user account named after the username of the user who ran the installer. Both of these accounts use the &lt;a href=&quot;../unix_socket-authentication-plugin/index&quot;&gt;UNIX_SOCKET Authentication Plugin&lt;/a&gt;, which means no password is required to log in.</source>
          <target state="translated">설치 후 MariaDB 서버 인스턴스에는 &quot;루트&quot;사용자 계정과 설치 프로그램을 실행 한 사용자의 사용자 이름을 딴 사용자 계정이 있습니다. 이 두 계정 모두 &lt;a href=&quot;../unix_socket-authentication-plugin/index&quot;&gt;UNIX_SOCKET 인증 플러그인을&lt;/a&gt; 사용하므로 로그인 할 때 비밀번호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="151d583e98fdaeabc7d96e61f419d0cc3a3bdd3b" translate="yes" xml:space="preserve">
          <source>After installing Homebrew, MariaDB Server can be installed with this command:</source>
          <target state="translated">Homebrew를 설치 한 후 다음 명령을 사용하여 MariaDB 서버를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d37f235e0ddd2424ed864675f4f2f673f5951c" translate="yes" xml:space="preserve">
          <source>After installing MariaDB (using &lt;code&gt;sudo make install&lt;/code&gt;), but prior to starting MariaDB for the first time, one should:</source>
          <target state="translated">MariaDB를 설치 한 후 ( &lt;code&gt;sudo make install&lt;/code&gt; 사용 ) MariaDB를 처음 시작하기 전에 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4a17a9ce14ea06e5abe65183892d1dcd6522afd" translate="yes" xml:space="preserve">
          <source>After installing MariaDB locally you&amp;rsquo;ve also used to connect to the unprotected root account using &lt;code&gt;mysql -uroot&lt;/code&gt;. This will not work either, simply use &lt;code&gt;mysql&lt;/code&gt; without specifying a username.</source>
          <target state="translated">MariaDB를 로컬에 설치 한 후 &lt;code&gt;mysql -uroot&lt;/code&gt; 를 사용하여 보호되지 않은 루트 계정에 연결하는 데 사용했습니다 . 이것은 작동하지 않습니다. 단순히 사용자 이름을 지정하지 않고 &lt;code&gt;mysql&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c889d51f1dec81e8e11101b203380e554b1afaf" translate="yes" xml:space="preserve">
          <source>After installing MariaDB system-wide the first thing you&amp;rsquo;ve got used to doing is logging in into the unprotected root account and protecting it, that is, setting the root password:</source>
          <target state="translated">시스템 전체에 MariaDB를 설치 한 후 가장 먼저 사용했던 것은 보호되지 않은 루트 계정에 로그인하여 보호하는 것입니다. 즉, 루트 암호를 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cae0eec94443810a5f84e1a359f3fa257d3ffd6" translate="yes" xml:space="preserve">
          <source>After installing MariaDB you should do the following to restore your configuration options:</source>
          <target state="translated">MariaDB를 설치 한 후 다음을 수행하여 구성 옵션을 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="d02e70eb0e8eebaaff2e789ebf9b6488ce9a12a4" translate="yes" xml:space="preserve">
          <source>After installing MariaDB, just do:</source>
          <target state="translated">MariaDB를 설치 한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc06e5636026c44a2f9657eec74b43d63b0af77" translate="yes" xml:space="preserve">
          <source>After installing MyRocks you will see RocksDB in the list of plugins:</source>
          <target state="translated">MyRocks를 설치하면 플러그인 목록에 RocksDB가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bbfa82362195b69474a4235d423decefd901aa" translate="yes" xml:space="preserve">
          <source>After installing Sphinx, you can check that things are working in MariaDB by doing the following:</source>
          <target state="translated">Sphinx를 설치 한 후 다음을 수행하여 MariaDB에서 작동 중인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4660371facc279d6f664a9a601c4f290e556fb31" translate="yes" xml:space="preserve">
          <source>After installing, update it from the terminal: &lt;code&gt;sudo port -v selfupdate
&lt;/code&gt;</source>
          <target state="translated">설치 후, 터미널에서 업데이트하십시오 : &lt;code&gt;sudo port -v selfupdate &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ad84c0b8260834cb17a52acefad7d66f7cd1e11" translate="yes" xml:space="preserve">
          <source>After issuing the statement, one can examine the &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_file&quot;&gt;binlog_snapshot_file&lt;/a&gt; and &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_position&quot;&gt;binlog_snapshot_position&lt;/a&gt; status variables to see the binlog position that corresponds to the snapshot.</source>
          <target state="translated">명령문을 발행 한 후 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_file&quot;&gt;binlog_snapshot_file&lt;/a&gt; 및 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_position&quot;&gt;binlog_snapshot_position&lt;/a&gt; 상태 변수를 검사 하여 스냅 샷에 해당하는 binlog 위치를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8693e0d568fa8a9499b00928db237b7f20a622" translate="yes" xml:space="preserve">
          <source>After making changes to this restart the syslog process, e.g:</source>
          <target state="translated">이를 변경 한 후 syslog 프로세스를 다시 시작하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="e691e3dd7a297021784af4c125d4544c3f176951" translate="yes" xml:space="preserve">
          <source>After new Install or Upgrade, a MariaDB ColumnStore Function or Engine type might be missing from the MariaDB Database. If this occurs, you can run the following procedure on each of the UMs or PMs with UM front-end modules on the system. This procedure should get all of the Functions and Engines created.</source>
          <target state="translated">새로 설치 또는 업그레이드 한 후 MariaDB 데이터베이스에서 MariaDB ColumnStore 함수 또는 엔진 유형이 누락 될 수 있습니다. 이 경우 시스템의 UM 프런트 엔드 모듈이있는 각 UM 또는 PM에서 다음 절차를 실행할 수 있습니다. 이 절차는 모든 기능과 엔진을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="69cd9ffa2814a3dceef8583a02efe236b0ce6750" translate="yes" xml:space="preserve">
          <source>After normalizing, the data is copied from Staging to Fact.</source>
          <target state="translated">정규화 한 후 데이터가 준비에서 사실로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="4c295f6b753fefe8f2f298fd84ff4fc209404cb4" translate="yes" xml:space="preserve">
          <source>After populating the time zone tables, you should usually restart the server so that the new time zone data is correctly loaded.</source>
          <target state="translated">표준 시간대 테이블을 채운 후에는 일반적으로 새 표준 시간대 데이터가 올바르게로드되도록 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="30ef212a0a77adbc39c9b071f0ecd27b8313ff7e" translate="yes" xml:space="preserve">
          <source>After preparing a statement with &lt;code&gt;&lt;a href=&quot;../prepare-statement/index&quot;&gt;PREPARE&lt;/a&gt;&lt;/code&gt;, you execute it with an &lt;code&gt;EXECUTE&lt;/code&gt; statement that refers to the prepared statement name. If the prepared statement contains any parameter markers, you must supply a &lt;code&gt;USING&lt;/code&gt; clause that lists user variables containing the values to be bound to the parameters. Parameter values can be supplied only by user variables, and the &lt;code&gt;USING&lt;/code&gt; clause must name exactly as many variables as the number of parameter markers in the statement.</source>
          <target state="translated">함께 문을 준비한 후 &lt;code&gt;&lt;a href=&quot;../prepare-statement/index&quot;&gt;PREPARE&lt;/a&gt;&lt;/code&gt; , 당신은 그것을 실행 &lt;code&gt;EXECUTE&lt;/code&gt; 준비된 명령문 이름을 참조 문. 준비된 명령문에 매개 변수 표시 문자가 포함 된 경우 매개 변수에 바인드 할 값이 포함 된 사용자 변수를 나열 하는 &lt;code&gt;USING&lt;/code&gt; 절을 제공해야합니다 . 매개 변수 값은 사용자 변수로만 제공 할 수 있으며 &lt;code&gt;USING&lt;/code&gt; 절은 명령문의 매개 변수 표시 문자 수만큼 정확하게 변수의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="16939852ca2dbcf6eec0217f5bf738c4e855476a" translate="yes" xml:space="preserve">
          <source>After printing the report to screen, email the report to ADDRESS. This option requires sendmail in /usr/sbin/, therefore it does not work on Windows. /usr/sbin/sendmail can be a sym link to qmail, for example, or any MTA that emulates sendmail's -t command line option and operation. The FROM: field is &quot;mysqlreport&quot;, SUBJECT: is &quot;MySQL status report&quot;.</source>
          <target state="translated">보고서를 화면에 인쇄 한 후 보고서를 ADDRESS (으)로 이메일로 보냅니다. 이 옵션은 / usr / sbin /에 sendmail이 필요하므로 Windows에서는 작동하지 않습니다. 예를 들어, / usr / sbin / sendmail은 qmail에 대한 심볼릭 링크이거나 sendmail의 -t 명령 줄 옵션 및 작업을 에뮬레이트하는 모든 MTA 일 수 있습니다. FROM : 필드는 &quot;mysqlreport&quot;이고 SUBJECT :는 &quot;MySQL status report&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="daed6871680cffe72427f19e6f8cfbcfbf58b676" translate="yes" xml:space="preserve">
          <source>After printing the report to screen, print the report to FILE too. Internally, mysqlreport always writes the report to a temp file first: &lt;code&gt;/tmp/mysqlreport.PID&lt;/code&gt; on *nix, &lt;code&gt;c:sqlreport.PID&lt;/code&gt; on Windows (PID is the script's process ID). Then it prints the temp file to screen. Then if &lt;code&gt;--outfile&lt;/code&gt; is specified, the temp file is copied to OUTFILE. After &lt;code&gt;--email&lt;/code&gt; (above), the temp file is deleted.</source>
          <target state="translated">보고서를 화면에 인쇄 한 후 보고서도 FILE로 인쇄하십시오. 내부적으로 mysqlreport는 항상 임시 파일에 보고서를 먼저 작성합니다. * nix의 &lt;code&gt;/tmp/mysqlreport.PID&lt;/code&gt; , Windows의 &lt;code&gt;c:sqlreport.PID&lt;/code&gt; (PID는 스크립트의 프로세스 ID) 그런 다음 임시 파일을 화면에 인쇄합니다. 그런 다음 &lt;code&gt;--outfile&lt;/code&gt; 을 지정하면 임시 파일이 OUTFILE로 복사됩니다. &lt;code&gt;--email&lt;/code&gt; (위) 후에 임시 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="34ec0c709ec1b87a9e777acb7c5621d47f153f01" translate="yes" xml:space="preserve">
          <source>After removing the files you wish to remove, tell pkgutil to forget the MariaDB Server package:</source>
          <target state="translated">제거하려는 파일을 제거한 후 pkgutil에 MariaDB 서버 패키지를 잊도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="224f38b8cce45bbc83adaa06864f18dc60340c53" translate="yes" xml:space="preserve">
          <source>After restarting the system the UDF must be registered with the MariaDB server to be usable:</source>
          <target state="translated">시스템을 다시 시작한 후 UDF를 MariaDB 서버에 등록해야 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3eeb1d90a161cb5d0814cf2267c35a21e17be47" translate="yes" xml:space="preserve">
          <source>After restoring the backup on the slave, you could execute something like this to use the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; position:</source>
          <target state="translated">슬레이브에서 백업을 복원 한 후 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 위치 를 사용하기 위해 다음과 같이 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4b620bac5c264a391d2e4854535f1cdfda4a203" translate="yes" xml:space="preserve">
          <source>After running &lt;code&gt;apt-upgrade mariadb&lt;/code&gt;, it's possible that apt shows a fail in trying to start the server, but in fact the database is up and running, which then provokes apt to remain in a non finished state.</source>
          <target state="translated">&lt;code&gt;apt-upgrade mariadb&lt;/code&gt; 를 실행 한 후 apt는 서버 시작 시도에 실패를 표시 할 수 있지만 실제로 데이터베이스가 작동 및 실행 중이므로 apt는 완료되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="47e1ded01ba1aaab862ba5698312c01c53d27a95" translate="yes" xml:space="preserve">
          <source>After selecting the choice you want you will move to step 3 where you specify the details for your database, including setting up an admin user in the database.</source>
          <target state="translated">원하는 선택을 선택한 후 3 단계로 이동하여 데이터베이스에서 관리자 설정을 포함하여 데이터베이스에 대한 세부 사항을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e6be40dd9d9cc91784c081abee38f64bb2756ff8" translate="yes" xml:space="preserve">
          <source>After setting up the MariaDB Package Repository, you can install the software packages in the supported repositories.</source>
          <target state="translated">MariaDB 패키지 리포지토리를 설정 한 후 지원되는 리포지토리에 소프트웨어 패키지를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e4b2f125933ac2b7f4cb436ef4d058cb53858d5" translate="yes" xml:space="preserve">
          <source>After starting up &lt;code&gt;mysqld&lt;/code&gt; using one of the above methods (with the debugger or without), launch the client (as root if you don't have any users setup yet).</source>
          <target state="translated">위의 방법 중 하나를 사용하여 &lt;code&gt;mysqld&lt;/code&gt; 를 시작한 후 (디버거를 사용하거나 사용하지 않고) 클라이언트를 아직 시작하지 않은 경우 루트로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c82951c4774077991f27acc79b8e6ae35bc223" translate="yes" xml:space="preserve">
          <source>After step 4, the installation will be completed. The last step will be to run &lt;a href=&quot;../mysql_secure_installation/index&quot;&gt;mysql_secure_installation&lt;/a&gt; to secure the production server by dis allowing remote login for root, creating root password and removing the test database.</source>
          <target state="translated">4 단계 후에 설치가 완료됩니다. 마지막 단계는 &lt;a href=&quot;../mysql_secure_installation/index&quot;&gt;mysql_secure_installation&lt;/a&gt; 을 실행 하여 루트에 대한 원격 로그인을 허용하지 않고 루트 비밀번호를 작성하고 테스트 데이터베이스를 제거하여 프로덕션 서버를 보호하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d8e7e631f254f24078486c1bd05f1783e95049b" translate="yes" xml:space="preserve">
          <source>After switching back to the 5.5 repo, the libraries won't get upgraded, they will stay 5.5.32 until you upgrade the server to 5.5.33a.</source>
          <target state="translated">5.5 저장소로 다시 전환 한 후에는 라이브러리가 업그레이드되지 않으며 서버를 5.5.33a로 업그레이드 할 때까지 라이브러리는 5.5.32로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="883d00a6cce6b707262855ee1d1433d0db12a176" translate="yes" xml:space="preserve">
          <source>After that, it will re-read statistics from the SST files and re-compute the summary numbers (TODO: and if the data was already on disk, the result should not be different from the one we had before ANALYZE?)</source>
          <target state="translated">그런 다음 SST 파일에서 통계를 다시 읽고 요약 번호를 다시 계산합니다 (TODO : 데이터가 이미 디스크에있는 경우 결과는 ANALYZE 이전과 다를 것입니까?).</target>
        </trans-unit>
        <trans-unit id="46b8ee2603cf3fda1435cbea988afcfa6d5334da" translate="yes" xml:space="preserve">
          <source>After that, process the key to remove the passphrase using the &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rsa.html&quot;&gt;openssl rsa&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rsa.html&quot;&gt;openssl rsa&lt;/a&gt;&lt;/code&gt; 명령을 사용하여 암호를 제거하도록 키를 처리하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58d57e8591375c9b54bded91fed0e9b3e100c3b1" translate="yes" xml:space="preserve">
          <source>After that, the compilation of the CONNECT JDBC type was completed successfully.</source>
          <target state="translated">그 후, CONNECT JDBC 유형의 컴파일이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="475000a691245b8bce6f2f7851365a182f1481d9" translate="yes" xml:space="preserve">
          <source>After that, the repository should refer to &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;.</source>
          <target state="translated">그런 다음 리포지토리는 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3을&lt;/a&gt; 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="edde425b5ebed0df1854ff5c20c446580c07614d" translate="yes" xml:space="preserve">
          <source>After that, you can add the repository for the new version with the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command. For example, if you wanted to use the repository to install &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; on Ubuntu 18.04 LTS (Bionic), then you could use the following commands to add the MariaDB &lt;code&gt;apt&lt;/code&gt; repository:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; 명령 을 사용하여 새 버전의 저장소를 추가 할 수 있습니다 . 예를 들어, 저장소를 사용하여 Ubuntu 18.04 LTS (Bionic)에 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 을 설치하려는 경우 다음 명령을 사용하여 MariaDB &lt;code&gt;apt&lt;/code&gt; 저장소 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="857d23a46c30654d32a161712ba6a16aa11a3bc6" translate="yes" xml:space="preserve">
          <source>After that, you can add the repository for the new version. For example, if you wanted to use the repository to install &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; on SLES 15, then you could use the following commands to add the MariaDB &lt;code&gt;zypper&lt;/code&gt; repository:</source>
          <target state="translated">그런 다음 새 버전의 저장소를 추가 할 수 있습니다. 예를 들어, 저장소를 사용하여 SLES 15에 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 을 설치하려는 경우 다음 명령을 사용하여 MariaDB &lt;code&gt;zypper&lt;/code&gt; 저장소 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3aeda0a59217493271732c5b6b064866e5728d0a" translate="yes" xml:space="preserve">
          <source>After that, you can use the private key to generate the X509 certificate for the CA using the &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/req.html&quot;&gt;openssl req&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">그런 다음 개인 키를 사용하여 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/req.html&quot;&gt;openssl req&lt;/a&gt;&lt;/code&gt; 명령을 사용하여 CA에 대한 X509 인증서를 생성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c5735a94653d2321445c41f08a7ef9febce4562" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;apt&lt;/code&gt; repository is configured, you can install MariaDB by executing the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man8/apt-get.8.html&quot;&gt;apt-get&lt;/a&gt;&lt;/code&gt; command. The specific command that you would use would depend on which specific packages that you want to install.</source>
          <target state="translated">애프터 &lt;code&gt;apt&lt;/code&gt; 저장소가 구성되어, 당신은 실행하여 MariaDB를 설치 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man8/apt-get.8.html&quot;&gt;apt-get&lt;/a&gt;&lt;/code&gt; 을의 명령을 사용합니다. 사용할 특정 명령은 설치할 특정 패키지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b2b49162081cdc17319dbf279178eb7b073e625a" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;yum&lt;/code&gt; repository is configured, you can install MariaDB by executing the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/yum&quot;&gt;yum&lt;/a&gt;&lt;/code&gt; command. The specific command that you would use would depend on which specific packages that you want to install.</source>
          <target state="translated">애프터 &lt;code&gt;yum&lt;/code&gt; 저장소가 구성되어, 당신은 실행하여 MariaDB를 설치할 수 있습니다 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/yum&quot;&gt;yum&lt;/a&gt;&lt;/code&gt; 명령을 사용합니다. 사용할 특정 명령은 설치할 특정 패키지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="00d3e2e4b1a08c971e7750f60a1c855cf37d671d" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;zypper&lt;/code&gt; repository is configured, you can install MariaDB by executing the &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/SDB:Zypper_manual_(plain)&quot;&gt;zypper&lt;/a&gt;&lt;/code&gt; command. The specific command that you would use would depend on which specific packages that you want to install.</source>
          <target state="translated">애프터 &lt;code&gt;zypper&lt;/code&gt; 의 저장소가 구성되어, 당신은 실행하여 MariaDB를 설치할 수 있습니다 &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/SDB:Zypper_manual_(plain)&quot;&gt;zypper&lt;/a&gt;&lt;/code&gt; 의 명령을 사용합니다. 사용할 특정 명령은 설치할 특정 패키지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2b9f556ec02f788269fbcfebd570f41ab8f21285" translate="yes" xml:space="preserve">
          <source>After the &lt;em&gt;addDbroot&lt;/em&gt; command, dbroots 3 and 4 have been created. You can see that they have been created by using the &lt;em&gt;getStorageConfig&lt;/em&gt; command. Along with other information, towards the bottom of the output you will see information that reflects the additional, unassigned dbroots.</source>
          <target state="translated">&lt;em&gt;addDbroot&lt;/em&gt; 명령 후에 dbroots 3 및 4가 작성되었습니다. &lt;em&gt;getStorageConfig&lt;/em&gt; 명령 을 사용하여 작성되었음을 알 수 있습니다 . 다른 정보와 함께 출력의 맨 아래에는 할당되지 않은 추가 dbroot를 반영하는 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8bfbfcb2ba5588ae20e431ed1793360b0e7900a7" translate="yes" xml:space="preserve">
          <source>After the MariaDB ColumnStore server have been setup based on the Preparing for Installations Document and the required MariaDB ColumnStore Packages have been Installed, use of the following option to configure and install MariaDB ColumnStore:</source>
          <target state="translated">설치 준비 문서를 기반으로 MariaDB ColumnStore 서버를 설정하고 필요한 MariaDB ColumnStore 패키지를 설치 한 후 다음 옵션을 사용하여 MariaDB ColumnStore를 구성 및 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0114663b152e3f4733db01ff0330809a60f6dc" translate="yes" xml:space="preserve">
          <source>After the MariaDB ColumnStore servers have been setup based on the &lt;a href=&quot;../../preparing-for-columnstore-installation/index&quot;&gt;Preparing for Installations&lt;/a&gt; document and the required MariaDB ColumnStore Packages have been Installed, use of the following option to configure and install MariaDB ColumnStore:</source>
          <target state="translated">&lt;a href=&quot;../../preparing-for-columnstore-installation/index&quot;&gt;설치 준비&lt;/a&gt; 문서 를 기반으로 MariaDB ColumnStore 서버를 설정 하고 필요한 MariaDB ColumnStore 패키지를 설치 한 후 다음 옵션을 사용하여 MariaDB ColumnStore를 구성 및 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="db44fb0237e0d5df1b95de9099a92f898a90509c" translate="yes" xml:space="preserve">
          <source>After the MariaDB ColumnStore servers have been setup based on the &lt;a href=&quot;../preparing-for-columnstore-installation/index&quot;&gt;Preparing for Installations&lt;/a&gt; document and the required MariaDB ColumnStore Packages have been Installed, use of the following option to configure and install MariaDB ColumnStore:</source>
          <target state="translated">&lt;a href=&quot;../preparing-for-columnstore-installation/index&quot;&gt;설치 준비&lt;/a&gt; 문서 를 기반으로 MariaDB ColumnStore 서버를 설정 하고 필요한 MariaDB ColumnStore 패키지를 설치 한 후 다음 옵션을 사용하여 MariaDB ColumnStore를 구성 및 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2dfe5874e7be9099dd1b2943acad49499554192d" translate="yes" xml:space="preserve">
          <source>After the audit plugin has been installed and loaded, there will be some new global variables within MariaDB. These can be used to configure many components, limits, and methods related to auditing the server. You may set these variables related to the logs, such as their location, size limits, rotation parameters, and method of logging information. You may also set what information is logged, such connects, disconnects, and failed attempts to connect. You can also have the audit plugin log queries, read and write access to tables. So as not to overload your logs, the audit plugin can be configured based on lists of users. You can include or exclude the activities of specific users in the logs.</source>
          <target state="translated">감사 플러그인을 설치하고로드하면 MariaDB 내에 새로운 전역 변수가 생깁니다. 서버 감사와 관련된 많은 구성 요소, 제한 및 방법을 구성하는 데 사용할 수 있습니다. 위치, 크기 제한, 회전 매개 변수 및 정보 기록 방법과 같은 로그와 관련된 이러한 변수를 설정할 수 있습니다. 연결, 연결 끊기 및 연결 시도 실패와 같이 기록되는 정보를 설정할 수도 있습니다. 또한 감사 플러그인 로그 쿼리, 테이블에 대한 읽기 및 쓰기 액세스 권한을 가질 수 있습니다. 로그에 과부하가 걸리지 않도록 사용자 목록을 기반으로 감사 플러그인을 구성 할 수 있습니다. 로그에 특정 사용자의 활동을 포함하거나 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c5fee25d619ad21e780902d26840537db4f2ea" translate="yes" xml:space="preserve">
          <source>After the initial read, you can use</source>
          <target state="translated">처음 읽은 후 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="560e370a8f37c82234d8a5e0de4a93c8a14e3cd2" translate="yes" xml:space="preserve">
          <source>After the installation completes, follow the configuration and startup steps in the Single-Node and Multi-Node Installation guides using the &lt;a href=&quot;../library/installing-and-configuring-a-multi-server-columnstore-system-11x/index#non-distributed-install&quot;&gt;Non-Distributed Install feature&lt;/a&gt;.</source>
          <target state="translated">설치가 완료된 후 &lt;a href=&quot;../library/installing-and-configuring-a-multi-server-columnstore-system-11x/index#non-distributed-install&quot;&gt;비 분산 설치 기능을&lt;/a&gt; 사용하여 단일 노드 및 다중 노드 설치 안내서의 구성 및 시작 단계를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="7d6a7305fe0c3b03e061086d804261a7af41f491" translate="yes" xml:space="preserve">
          <source>After the installation is complete, you can &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;start MariaDB&lt;/a&gt;.</source>
          <target state="translated">설치가 완료되면 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5c2f59e8408ac521f7083912a8feaf658fa783" translate="yes" xml:space="preserve">
          <source>After the plugin is installed, the &lt;code&gt;root@localhost&lt;/code&gt; user account can be configured to use &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication. How this is done depends on the version of MariaDB.</source>
          <target state="translated">플러그인을 설치 한 후 &lt;code&gt;root@localhost&lt;/code&gt; 사용자 계정을 구성하여 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 을 사용할 수 있습니다 . 이 작업을 수행하는 방법은 MariaDB 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="78eefe1679457b24c30da5c979d3b05859f8ef8e" translate="yes" xml:space="preserve">
          <source>After the recovery process is complete, MariaDB will create a new empty &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; file, so that the old corrupt ones can be ignored.</source>
          <target state="translated">복구 프로세스가 완료되면 MariaDB는 비어있는 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 파일을 새로 만들어 오래된 손상된 파일을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af15708c745605d6e37cfb318d73b8d66c00b2e1" translate="yes" xml:space="preserve">
          <source>After the system is rebooted, the &lt;code&gt;mysql&lt;/code&gt; user should use the new limits, and the user's &lt;code&gt;ulimit&lt;/code&gt; output should look like the following:</source>
          <target state="translated">시스템이 재부팅 된 후, &lt;code&gt;mysql&lt;/code&gt; 사용자는 새로운 한계를 사용해야하며, 사용자의 &lt;code&gt;ulimit&lt;/code&gt; 출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="3d8b833c9c9848116cada837890468df474d1701" translate="yes" xml:space="preserve">
          <source>After the system is rebooted, the above configuration should set new open file limits for the &lt;code&gt;mysql&lt;/code&gt; user, and the user's &lt;code&gt;ulimit&lt;/code&gt; output should look like the following:</source>
          <target state="translated">시스템이 재부팅 된 후, 위의 구성은 &lt;code&gt;mysql&lt;/code&gt; 사용자에 대해 새로운 열린 파일 제한을 설정해야 하며 사용자의 &lt;code&gt;ulimit&lt;/code&gt; 출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d21aaa01e7cbdd53555d60fb64d51c3a838326cf" translate="yes" xml:space="preserve">
          <source>After the table created by a master dump (the &lt;code&gt;Opening master dump table&lt;/code&gt; state) the table is now being read.</source>
          <target state="translated">마스터 덤프 ( &lt;code&gt;Opening master dump table&lt;/code&gt; state)에 의해 작성된 테이블은 이제 테이블을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2c7cc2a1d75d25c1ba37de85fadd30d3802e533c" translate="yes" xml:space="preserve">
          <source>After the table created by a master dump has been opened and read (the &lt;code&gt;Reading master dump table data&lt;/code&gt; state), the index is built.</source>
          <target state="translated">마스터 덤프로 작성된 테이블을 열고 읽은 후 ( &lt;code&gt;Reading master dump table data&lt;/code&gt; 상태) 인덱스가 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="a900f6160c25602d0d1ad8945de634404de22696" translate="yes" xml:space="preserve">
          <source>After the upgrade process the configuration files will be saved at:</source>
          <target state="translated">업그레이드 프로세스 후 구성 파일은 다음 위치에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dd5b15db3bced140a7088fa567535f89d2ab9a23" translate="yes" xml:space="preserve">
          <source>After these CREATE and INSERT operations, the following information can be seen from the INFORMATION SCHEMA:</source>
          <target state="translated">이러한 CREATE 및 INSERT 조작 후 INFORMATION SCHEMA에서 다음 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df7589c57cd6fb1c1443fa686bdbb7827fd470b9" translate="yes" xml:space="preserve">
          <source>After these changes have been made, you can &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restart the server&lt;/a&gt;.</source>
          <target state="translated">이러한 변경을 수행 한 후 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;서버를 다시 시작할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fdd792b1909ed197e10f8b2c8b60606370adfa6" translate="yes" xml:space="preserve">
          <source>After these three updates, the first two responding &quot;Affected rows: 1&quot; and the last one responding &quot;Affected rows: 2&quot;, the last query answers:</source>
          <target state="translated">이 세 가지 업데이트 후에 처음 두 응답 &quot;영향을받는 행 : 1&quot;과 마지막 응답 &quot;영향을받는 행 : 2&quot;에 마지막 쿼리가 응답합니다.</target>
        </trans-unit>
        <trans-unit id="2045a5e738f48dbff8e35b9568e96bfa024796f8" translate="yes" xml:space="preserve">
          <source>After this line:</source>
          <target state="translated">이 줄 후에 :</target>
        </trans-unit>
        <trans-unit id="a7474090e9369fb0e504611d5f8360636cec808e" translate="yes" xml:space="preserve">
          <source>After this these may be used in the same way as any other aggregate or window function like sum:</source>
          <target state="translated">이 후 이들은 sum과 같은 다른 집계 또는 창 함수와 같은 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd80ec9df925e025f5bcf7fd5d53ca057ed1d1cf" translate="yes" xml:space="preserve">
          <source>After this, it is displayed as:</source>
          <target state="translated">그 후에는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="57710660f3b4c1c66d086b4848279c925c3031ae" translate="yes" xml:space="preserve">
          <source>After this, remember to set proper passwords for all accounts accessible from untrusted sources, to avoid exposing the host to security risks! Also consider using the &lt;a href=&quot;../mysqlserver/index&quot;&gt;mysql.server&lt;/a&gt; to &lt;a href=&quot;../starting-and-stopping-mariadb-automatically/index&quot;&gt;start MariaDB automatically&lt;/a&gt; when your system boots.</source>
          <target state="translated">그런 다음 호스트를 보안 위험에 노출시키지 않도록 신뢰할 수없는 출처에서 액세스 할 수있는 모든 계정에 대해 올바른 암호를 설정하십시오! 또한 시스템 부팅시 &lt;a href=&quot;../mysqlserver/index&quot;&gt;mysql.server&lt;/a&gt; 를 사용하여 &lt;a href=&quot;../starting-and-stopping-mariadb-automatically/index&quot;&gt;MariaDB를 자동으로 시작&lt;/a&gt; 하는 것도 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="e82e1180510a14bc0cc559552a5f3413ca74e37f" translate="yes" xml:space="preserve">
          <source>After this, the source files for the database server will be in the &lt;code&gt;/server&lt;/code&gt; directory, and for Galera in the &lt;code&gt;/galera&lt;/code&gt; directory.</source>
          <target state="translated">그 후에 데이터베이스 서버의 소스 파일은 &lt;code&gt;/server&lt;/code&gt; 디렉토리에 있고 Galera는 &lt;code&gt;/galera&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81bfcda86a49302e1efd0e345b6add9b5cabe17" translate="yes" xml:space="preserve">
          <source>After this, there will only be one free block :</source>
          <target state="translated">그 후에는 하나의 사용 가능한 블록 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5b212accb9cbbf72ee41365beb0e9c6b4e79a1f" translate="yes" xml:space="preserve">
          <source>After updating the configuration options, restart MariaDB.</source>
          <target state="translated">구성 옵션을 업데이트 한 후 MariaDB를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b5527aa52a9c15915837bf1efe3cbb0366e22b86" translate="yes" xml:space="preserve">
          <source>After using Instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt;, any table-rebuilding operation such as &lt;code&gt;&lt;a href=&quot;../alter-table/index#force&quot;&gt;ALTER TABLE &amp;hellip; FORCE&lt;/a&gt;&lt;/code&gt; will incorporate instantaneously added columns into the main table body.</source>
          <target state="translated">Instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; 사용한 후 &lt;code&gt;&lt;a href=&quot;../alter-table/index#force&quot;&gt;ALTER TABLE &amp;hellip; FORCE&lt;/a&gt;&lt;/code&gt; 와 같은 테이블 재 구축 작업 은 기본 테이블 본문에 즉시 추가 된 열을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="67c0a988a228708ed84750300ff6283142c4dea8" translate="yes" xml:space="preserve">
          <source>After which you have...</source>
          <target state="translated">그 후 당신은 ...</target>
        </trans-unit>
        <trans-unit id="b3c9bbc870c3706d35019030e161901cff03e6f0" translate="yes" xml:space="preserve">
          <source>After you have completed the part of the package upgrade process (removing the old package and installing the 1.0.2 package), the following file will exist: /usr/local/mariadb/columnstore/etc/Calpont.xml.rpmsave Run the following commands, this is the work-around part that is only required when going from 1.0.0/1.0.1 to 1.0.2</source>
          <target state="translated">패키지 업그레이드 프로세스의 일부 (이전 패키지 제거 및 1.0.2 패키지 설치)를 완료하면 다음 파일이 존재합니다. /usr/local/mariadb/columnstore/etc/Calpont.xml.rpmsave 다음을 실행하십시오. 이 명령은 1.0.0 / 1.0.1에서 1.0.2로 갈 때만 필요한 해결 방법입니다.</target>
        </trans-unit>
        <trans-unit id="0d5763bf633cf167ce552e2a02492d6c11cf3757" translate="yes" xml:space="preserve">
          <source>After you make a change to this configuration file, you have to reboot the system in order for the changes to go into effect.</source>
          <target state="translated">이 구성 파일을 변경 한 후 변경 사항을 적용하려면 시스템을 재부팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a4d962c485db9d05625bd8618e813cfb57c28de" translate="yes" xml:space="preserve">
          <source>Afterwards, you can install mcsimport via:</source>
          <target state="translated">이후 다음을 통해 mcsimport를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311cb293d6ede4c162b44f203bd1c8eba1278634" translate="yes" xml:space="preserve">
          <source>Again, ugly but fast, regardless of table size.</source>
          <target state="translated">테이블 크기에 관계없이 추악하지만 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="60e40886fb455791cfb519372061ffc06780f112" translate="yes" xml:space="preserve">
          <source>Age as of 2014-08-02:</source>
          <target state="translated">2014-08-02 기준 연령 :</target>
        </trans-unit>
        <trans-unit id="6a8e8189f1313ddd69a6c196be4e792c160e8ade" translate="yes" xml:space="preserve">
          <source>Aggregate</source>
          <target state="translated">Aggregate</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="c0bfa4306912521bf85bb7cbeb98f3964b45ce89" translate="yes" xml:space="preserve">
          <source>Aggregate Functions as Window Functions</source>
          <target state="translated">창 함수로 집계 함수</target>
        </trans-unit>
        <trans-unit id="58f0a7b4b513806fc490640c8e53c8d2cee1c97b" translate="yes" xml:space="preserve">
          <source>Aggregate UDF functions can be used as &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">집계 UDF 기능을 &lt;a href=&quot;../window-functions/index&quot;&gt;창 기능&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa4db64f0444c67d2c4de674f488366c8e4c2bd8" translate="yes" xml:space="preserve">
          <source>Aggregate data in a SELECT statement with the GROUP BY clause.</source>
          <target state="translated">GROUP BY 절을 사용하여 SELECT 문에서 데이터를 집계하십시오.</target>
        </trans-unit>
        <trans-unit id="270d3d939ba9ee14251a603b372aa8669303f3fb" translate="yes" xml:space="preserve">
          <source>Aggregate function '%-.192s)' of SELECT #%d belongs to SELECT #%d</source>
          <target state="translated">SELECT # % d의 집계 함수 '%-. 192s)'가 SELECT # % d에 속합니다.</target>
        </trans-unit>
        <trans-unit id="87f163760f116b2edb63fede0883e1c79b2d38a9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are summary functions such as &lt;a href=&quot;../sum/index&quot;&gt;SUM()&lt;/a&gt; and &lt;a href=&quot;../avg/index&quot;&gt;AVG()&lt;/a&gt;.</source>
          <target state="translated">집계 함수는 &lt;a href=&quot;../sum/index&quot;&gt;SUM ()&lt;/a&gt; 및 &lt;a href=&quot;../avg/index&quot;&gt;AVG ()&lt;/a&gt; 와 같은 요약 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="58666e44124cafa8dfb68aee9dc0610316d63b79" translate="yes" xml:space="preserve">
          <source>Aggregate functions are utilized for window functions however differ in behavior from a group by query because the rows remain ungrouped. This provides support for cumulative sums and rolling averages, for example.</source>
          <target state="translated">집계 함수는 창 함수에 사용되지만 행은 그룹화되지 않은 채 쿼리별로 그룹과 동작이 다릅니다. 예를 들어 누적 합계 및 롤링 평균을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="edc5774734f5f0fa88975497e92d8576f77be530" translate="yes" xml:space="preserve">
          <source>Aggregate functions cannot be used in the RETURNING clause. Since aggregate functions work on a set of values and if the purpose is to get the row count, ROW_COUNT() with SELECT can be used, or it can be used in REPLACE...SELECT...RETURNING if the table in the RETURNING clause is not the same as the REPLACE table.</source>
          <target state="translated">RETURNING 절에서 집계 함수를 사용할 수 없습니다. 집계 함수는 값 세트에 대해 작동하며 행 수를 얻는 것이 목적인 경우 SELECT를 사용하는 ROW_COUNT ()를 사용하거나 RETURNING의 테이블 인 경우 REPLACE ... SELECT ... RETURNING에서 사용할 수 있습니다. 절이 REPLACE 테이블과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc37aedd3283f01f19c1a7fa3405f4e704e4a5a2" translate="yes" xml:space="preserve">
          <source>Aggregate functions cannot be used in the RETURNING clause. Since aggregate functions work on a set of values, and if the purpose is to get the row count, ROW_COUNT() with SELECT can be used or it can be used in INSERT...SELECT...RETURNING if the table in the RETURNING clause is not the same as the INSERT table.</source>
          <target state="translated">RETURNING 절에서 집계 함수를 사용할 수 없습니다. 집계 함수는 값 세트에서 작동하며 행 수를 얻는 것이 목적이므로 SELECT를 사용하여 ROW_COUNT ()를 사용하거나 RETURNING의 테이블이 INSERT ... SELECT ... RETURNING에 사용될 수 있습니다. 절은 INSERT 테이블과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="578fd84a5fdbb0caa01d56acc2b05552e1d9bb47" translate="yes" xml:space="preserve">
          <source>Aggregate functions that are currently supported as window functions are: &lt;a href=&quot;../count/index&quot;&gt;COUNT&lt;/a&gt;, &lt;a href=&quot;../sum/index&quot;&gt;SUM&lt;/a&gt;, &lt;a href=&quot;../avg/index&quot;&gt;AVG&lt;/a&gt;, &lt;a href=&quot;../bit_or/index&quot;&gt;BIT_OR&lt;/a&gt;, &lt;a href=&quot;../bit_and/index&quot;&gt;BIT_AND&lt;/a&gt;, &lt;a href=&quot;../bit_xor/index&quot;&gt;BIT_XOR&lt;/a&gt;.</source>
          <target state="translated">현재 창 함수로 지원되는 집계 함수는 &lt;a href=&quot;../count/index&quot;&gt;COUNT&lt;/a&gt; , &lt;a href=&quot;../sum/index&quot;&gt;SUM&lt;/a&gt; , &lt;a href=&quot;../avg/index&quot;&gt;AVG&lt;/a&gt; , &lt;a href=&quot;../bit_or/index&quot;&gt;BIT_OR&lt;/a&gt; , &lt;a href=&quot;../bit_and/index&quot;&gt;BIT_AND&lt;/a&gt; , &lt;a href=&quot;../bit_xor/index&quot;&gt;BIT_XOR&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d2c92eabf58ff6068f34cfa8d400b7e6bfa46d2" translate="yes" xml:space="preserve">
          <source>Aggregate functions used with GROUP BY clauses.</source>
          <target state="translated">GROUP BY 절과 함께 사용되는 집계 함수</target>
        </trans-unit>
        <trans-unit id="60203331bb3947f202be547cb60baaaddfaa5256" translate="yes" xml:space="preserve">
          <source>Aggregate functions with the &lt;code&gt;DISTINCT&lt;/code&gt; specifier (e.g. &lt;code&gt;COUNT( DISTINCT x)&lt;/code&gt;) are not supported as window functions.</source>
          <target state="translated">&lt;code&gt;DISTINCT&lt;/code&gt; 지정자를 사용하는 집계 함수 (예 : &lt;code&gt;COUNT( DISTINCT x)&lt;/code&gt; )는 창 함수로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e9d6609cdcbfbdaa7ee77b4a5464ca410db1a66" translate="yes" xml:space="preserve">
          <source>Aggregate functions, such as &lt;a href=&quot;../sum/index&quot;&gt;SUM&lt;/a&gt; and &lt;a href=&quot;../avg/index&quot;&gt;AVG&lt;/a&gt; ignore NULLs.</source>
          <target state="translated">&lt;a href=&quot;../sum/index&quot;&gt;SUM&lt;/a&gt; 및 &lt;a href=&quot;../avg/index&quot;&gt;AVG&lt;/a&gt; 와 같은 집계 함수 는 NULL을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="61aa25dc0e039d011d4390c5694589a5c2b495af" translate="yes" xml:space="preserve">
          <source>Aggregate table I/O wait events by index.</source>
          <target state="translated">인덱스별로 테이블 I / O 대기 이벤트를 집계하십시오.</target>
        </trans-unit>
        <trans-unit id="b2af767b1b3337f3ce0c4913661536b688fc992a" translate="yes" xml:space="preserve">
          <source>Aggregate table I/O wait events by table.</source>
          <target state="translated">테이블별로 테이블 I / O 대기 이벤트를 집계합니다.</target>
        </trans-unit>
        <trans-unit id="d5b87fedc876c048f365637efbd99be11e4d45bb" translate="yes" xml:space="preserve">
          <source>Aggregate table lock wait events by table.</source>
          <target state="translated">테이블별로 테이블 잠금 대기 이벤트를 집계하십시오.</target>
        </trans-unit>
        <trans-unit id="63f39050c52bcb370d14899c418354db9d1bc3ae" translate="yes" xml:space="preserve">
          <source>Aggregates object wait events</source>
          <target state="translated">객체 대기 이벤트 집계</target>
        </trans-unit>
        <trans-unit id="f78a974d5a5143db73ccd360c6d79e7dab9fd7cf" translate="yes" xml:space="preserve">
          <source>Aggregates timer and byte count statistics for all socket I/O operations by socket instance</source>
          <target state="translated">소켓 인스턴스별로 모든 소켓 I / O 작업에 대한 타이머 및 바이트 수 통계를 집계합니다.</target>
        </trans-unit>
        <trans-unit id="4384bfab8d5e8fdbeab69efb2a6141cfffc0a765" translate="yes" xml:space="preserve">
          <source>Aggregates timer and byte count statistics for all socket I/O operations by socket instrument</source>
          <target state="translated">소켓 계측기 별 모든 소켓 I / O 작업에 대한 타이머 및 바이트 수 통계 집계</target>
        </trans-unit>
        <trans-unit id="ae2ec40c516e09d3fff635e511b041baca91b5be" translate="yes" xml:space="preserve">
          <source>Aggregation performance is also influenced by the number of distinct aggregate column values. Generally you'll see that for the same number of rows 100 distinct values will compute faster than 10000 distinct values. This is due to increased memory management as well as transfer overhead.</source>
          <target state="translated">집계 성능 또한 고유 한 집계 열 값의 수에 영향을받습니다. 일반적으로 같은 수의 행에 대해 100 개의 고유 값이 10000 개의 고유 값보다 빠르게 계산됨을 알 수 있습니다. 이는 메모리 오버 헤드가 증가하고 메모리 관리가 향상 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="88a712aa19feedd2b5d39b7aaf43fc0ec0206cff" translate="yes" xml:space="preserve">
          <source>Aggregations</source>
          <target state="translated">Aggregations</target>
        </trans-unit>
        <trans-unit id="09268b680ea8b0cd2674f84b3a44b803b17a668f" translate="yes" xml:space="preserve">
          <source>Aggressive Mode of In-Order Parallel Replication</source>
          <target state="translated">주문형 병렬 복제의 공격적인 모드</target>
        </trans-unit>
        <trans-unit id="3546bcc1562ee5cd4bde2740b92df28682aa09f0" translate="yes" xml:space="preserve">
          <source>Aggressive mode of in-order parallel replication can be configured by setting the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_mode&quot;&gt;slave_parallel_mode&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;aggressive&lt;/code&gt; on the slave.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_mode&quot;&gt;slave_parallel_mode&lt;/a&gt;&lt;/code&gt; 시스템 변수를 슬레이브 에서 &lt;code&gt;aggressive&lt;/code&gt; 으로 설정하여 순차적 병렬 복제의 공격 모드를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53a6fd87679b273ccf57db8ff27cbb019caf8cbb" translate="yes" xml:space="preserve">
          <source>Aggressive mode of in-order parallel replication is very similar to optimistic mode. The main difference is that the slave does not consider whether transactions conflicted on the master when deciding whether to apply the transactions in parallel.</source>
          <target state="translated">순차적 병렬 복제의 공격적 모드는 낙관적 모드와 매우 유사합니다. 주요 차이점은 트랜잭션을 병렬로 적용할지 여부를 결정할 때 슬레이브가 트랜잭션이 마스터에서 충돌했는지 여부를 고려하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea51aad8c5130a10b2b744c352915d8f1463dd7b" translate="yes" xml:space="preserve">
          <source>Aggressive mode of in-order parallel replication was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt;.</source>
          <target state="translated">순차적 병렬 복제의 공격적 모드가 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="401214e906d4515b4d3331ab557ffa2241e762e6" translate="yes" xml:space="preserve">
          <source>Agimba</source>
          <target state="translated">Agimba</target>
        </trans-unit>
        <trans-unit id="68076c31b9691b5ba92709e40c3dad9106c23060" translate="yes" xml:space="preserve">
          <source>Alain</source>
          <target state="translated">Alain</target>
        </trans-unit>
        <trans-unit id="24b27591ec843a706aeff56ef713623b8b3aefcb" translate="yes" xml:space="preserve">
          <source>Alain Michard</source>
          <target state="translated">알랭 미 카드</target>
        </trans-unit>
        <trans-unit id="d890bcc3e58a03dceffed9e61209b3cad43b47b1" translate="yes" xml:space="preserve">
          <source>Alarm trigger count threshold</source>
          <target state="translated">알람 트리거 카운트 임계 값</target>
        </trans-unit>
        <trans-unit id="ef3cd3a6c4dcf77ddabfd1cf9bbefb70787e3605" translate="yes" xml:space="preserve">
          <source>AlarmID = 31 Brief Description = DBRM_READ_ONLY Alarm Severity = CRITICAL Time Issued = Wed Sep 13 14:32:37 2017 Reporting Module = pm1 Reporting Process = DBRMControllerNode Reported Device = System</source>
          <target state="translated">AlarmID = 31 간략한 설명 = DBRM_READ_ONLY 경보 심각도 = 위험 시간 발행 = 수 9 월 13 일 14:32:37 2017보고 모듈 = pm1보고 프로세스 = DBRMControllerNode보고 된 장치 = 시스템</target>
        </trans-unit>
        <trans-unit id="ea962049f7719e45acbccc293702143ea47210ba" translate="yes" xml:space="preserve">
          <source>Alarms are logged to the &lt;em&gt; /var/log/mariadb/columnstore/alarm.log&lt;/em&gt; file and a summary is displayed in mcsadmin. The &lt;em&gt;getActiveAlarms&lt;/em&gt; command in mcsadmin can be used to retrieve current alarm conditions.</source>
          <target state="translated">경보는 &lt;em&gt;/var/log/mariadb/columnstore/alarm.log&lt;/em&gt; 파일에 기록되고 요약이 mcsadmin에 표시됩니다. mcsadmin 의 &lt;em&gt;getActiveAlarms&lt;/em&gt; 명령을 사용하여 현재 경보 조건을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23cb5ae16e9b2b46bc5bfd235cbd16258bb481f8" translate="yes" xml:space="preserve">
          <source>Alas, there are cases where the pattern is hard to follow.</source>
          <target state="translated">아아, 패턴이 따르기 어려운 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b9d273ac6d2488109d1ea43e2bdb7977bd2b28" translate="yes" xml:space="preserve">
          <source>Albania</source>
          <target state="translated">Albania</target>
        </trans-unit>
        <trans-unit id="d71c45b3d8a817df46d53626270c2cc92e52793f" translate="yes" xml:space="preserve">
          <source>Albanian</source>
          <target state="translated">Albanian</target>
        </trans-unit>
        <trans-unit id="bd6acc8626d118aea60331ce33bf000c9d7d1cee" translate="yes" xml:space="preserve">
          <source>Algeria</source>
          <target state="translated">Algeria</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="dbf375799339eeccb967f16b96e26fcfe319d9f0" translate="yes" xml:space="preserve">
          <source>Algorithm end</source>
          <target state="translated">알고리즘 끝</target>
        </trans-unit>
        <trans-unit id="09de3fe5f192d163abe19b9f904d6ea27abd5e65" translate="yes" xml:space="preserve">
          <source>Algorithm, step 1 (WHERE &quot;column = const&quot;)</source>
          <target state="translated">알고리즘, 1 단계 (여기서 &quot;열 = const&quot;)</target>
        </trans-unit>
        <trans-unit id="f0f2d91c42725fd8435e6ef74e7607292bd4a522" translate="yes" xml:space="preserve">
          <source>Algorithm, step 2</source>
          <target state="translated">알고리즘, 2 단계</target>
        </trans-unit>
        <trans-unit id="b203bc1d2ec632914d5fcd8ec344b429cbc65224" translate="yes" xml:space="preserve">
          <source>Algorithm, step 2a (one range)</source>
          <target state="translated">알고리즘, 2a 단계 (한 범위)</target>
        </trans-unit>
        <trans-unit id="00fc575a709c360b9f2b040fa0afe69224f2d77f" translate="yes" xml:space="preserve">
          <source>Algorithm, step 2b (GROUP BY)</source>
          <target state="translated">알고리즘, 2b 단계 (GROUP BY)</target>
        </trans-unit>
        <trans-unit id="6c286b19ed69ee1668f37251ef6591ece2b759c7" translate="yes" xml:space="preserve">
          <source>Algorithm, step 2c (ORDER BY)</source>
          <target state="translated">알고리즘, 2c 단계 (주문)</target>
        </trans-unit>
        <trans-unit id="dc59c5ee7e967eded5ab99060d719171eb7d32d2" translate="yes" xml:space="preserve">
          <source>Algorithms that employ a join buffer for the first join before starting to look in the second.</source>
          <target state="translated">두 번째를 살펴보기 전에 첫 번째 결합에 결합 버퍼를 사용하는 알고리즘.</target>
        </trans-unit>
        <trans-unit id="c7be017d56770abdd4c80f86c40653ae48ad68d4" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;Last_SQL_Errno&lt;/code&gt; (see below)</source>
          <target state="translated">&lt;code&gt;Last_SQL_Errno&lt;/code&gt; 의 별칭 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="4d772b394b00992ea2a248dc3f20b2f64866fa07" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;Last_SQL_Error&lt;/code&gt; (see below)</source>
          <target state="translated">&lt;code&gt;Last_SQL_Error&lt;/code&gt; 의 별칭 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="7d9e627ff2cc6467521c78ad3dc3750bdf422079" translate="yes" xml:space="preserve">
          <source>Alias for BINARY.</source>
          <target state="translated">이진의 별칭.</target>
        </trans-unit>
        <trans-unit id="516502c829ee66f23e4108dcf2b4f1ee4a5d7d64" translate="yes" xml:space="preserve">
          <source>Alias name of table. Materialized temporary tables for sub queries are named &amp;lt;subquery#&amp;gt;</source>
          <target state="translated">테이블의 별명 이름. 하위 쿼리의 구체화 된 임시 테이블 이름은 &amp;lt;subquery #&amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="6b57faa9280dc218fc32d208020bb75b59ede759" translate="yes" xml:space="preserve">
          <source>Aliases (&lt;code&gt;AS&lt;/code&gt;) are taken into account, and they should always be used when you &lt;code&gt;SELECT&lt;/code&gt; an expression (function, arithmetical operation, etc).</source>
          <target state="translated">별칭 ( &lt;code&gt;AS&lt;/code&gt; 는 ) 고려, 당신은 때 항상 사용되어야한다 &lt;code&gt;SELECT&lt;/code&gt; 식 (등 기능, 산술 연산을,).</target>
        </trans-unit>
        <trans-unit id="1863cf04ab764936ccd709ccf971fa5e8f1be37a" translate="yes" xml:space="preserve">
          <source>Aliases have a maximum length of 256 characters, except for column aliases in &lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt; statements, which adhere to the are checked against the maximum column length of 64 characters (not the maximum alias length of 256 characters).</source>
          <target state="translated">&lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt; 문의 열 별칭을 제외하고 별칭 의 최대 길이는 256 자입니다. 최대 별칭 길이는 64 자 (최대 별칭 길이는 256 자)가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="08be21030e6ddcc6672d5d80cec91556f925033d" translate="yes" xml:space="preserve">
          <source>All &quot;reports&quot; use summary tables, not the Fact table</source>
          <target state="translated">모든 &quot;보고서&quot;는 팩트 테이블이 아닌 요약 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e48eed9faed0f0308f8939dc1574936b8f38afe3" translate="yes" xml:space="preserve">
          <source>All 3 formats can be used in the same XML file; the import routine automatically detects the format for each row and interprets it correctly. Tags are matched based on the tag or attribute name and the column name.</source>
          <target state="translated">3 가지 형식을 모두 동일한 XML 파일로 사용할 수 있습니다. 가져 오기 루틴은 각 행의 형식을 자동으로 감지하여 올바르게 해석합니다. 태그는 태그 또는 속성 이름과 열 이름을 기준으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d870c3fc85096437c16ac8f0cba7cb924b557179" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; / &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; / &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; operations can be used with proxy tables. However, the same restrictions applying to the source table also apply to the proxy table.</source>
          <target state="translated">모든 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; / &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; / &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 작업은 프록시 테이블과 함께 사용할 수 있습니다. 그러나 소스 테이블에 적용되는 것과 동일한 제한 사항이 프록시 테이블에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="48bf5d76153f6966dbbccf9f4db7810d95ba9268" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; events have been processed, now waiting for the I/O thread to write new events to the relay log.</source>
          <target state="translated">모든 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 이벤트가 처리되었으며 이제 I / O 스레드가 릴레이 로그에 새 이벤트를 쓸 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="ba5dbb33c6282f69f528f6e9f2145a62c73c0635" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; queries always route to &lt;code&gt;Server-1&lt;/code&gt; (OLTP)</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 쿼리는 항상 &lt;code&gt;Server-1&lt;/code&gt; (OLTP)로 라우팅</target>
        </trans-unit>
        <trans-unit id="0ea8f667079986456a5578259804d7c897e44aab" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; statements always route to &lt;code&gt;Server-1&lt;/code&gt; for (OLTP)</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 문은 항상 (OLTP) for &lt;code&gt;Server-1&lt;/code&gt; 로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="ed1105f48786eb7f4b655c0a5057a0a19a1ef02c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; queries on loans table always route to MariaDB ColumnStore (OLAP)</source>
          <target state="translated">대출 테이블의 모든 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 쿼리는 항상 MariaDB ColumnStore (OLAP)로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="3286c11214f01f034f852718288ce0de462222b0" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; queries on the loan table always route to MariaDB ColumnStore (OLAP)</source>
          <target state="translated">대출 테이블의 모든 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 쿼리는 항상 MariaDB ColumnStore (OLAP)로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8ab69f80d15a1d70118d5e58ba3a6935751846" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;BUILD&lt;/code&gt; scripts support the following options:</source>
          <target state="translated">모든 &lt;code&gt;BUILD&lt;/code&gt; 스크립트는 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="462647f89f82a4d533b18ac5cc8ef158782d1c4d" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;cmake&lt;/em&gt; configuration options for MariaDB can be displayed with:</source>
          <target state="translated">MariaDB에 대한 모든 &lt;em&gt;cmake&lt;/em&gt; 구성 옵션은 다음과 같이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8143a567a22193687acb91d95e4a4866d4b5bc36" translate="yes" xml:space="preserve">
          <source>All API functions has prefix mariadb_dyncol_ (old prefix dynamic_column_ is depricated</source>
          <target state="translated">모든 API 함수에는 mariadb_dyncol_ 접두사가 있습니다 (이전 접두사 dynamic_column_은 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="72c1565ebd6101864c2d00fc9b924d5dca6b676b" translate="yes" xml:space="preserve">
          <source>All CMake configuration options for MariaDB can be displayed with:</source>
          <target state="translated">MariaDB에 대한 모든 CMake 구성 옵션은 다음과 같이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eba09abbbfbdd4c64d9b0a9ce17415cb438bc097" translate="yes" xml:space="preserve">
          <source>All Database Updates commands like DDL/DML and cpimports are suspend until the module or DBRoot is successfully added</source>
          <target state="translated">모듈 또는 DBRoot가 성공적으로 추가 될 때까지 DDL / DML 및 cpimport와 같은 모든 데이터베이스 업데이트 명령이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4b489a5730fc95cefcf7a3be14f4b4624e067cb1" translate="yes" xml:space="preserve">
          <source>All ICMP</source>
          <target state="translated">모든 ICMP</target>
        </trans-unit>
        <trans-unit id="27875b399176a54a36501cd8bf30fcf060c2ac39" translate="yes" xml:space="preserve">
          <source>All InnoDB row formats can store certain kinds of data in overflow pages. This allows for the maximum row size of an InnoDB table to be larger than the maximum amount of data that can be stored in the row's main data page. See &lt;a href=&quot;#maximum-row-size&quot;&gt;Maximum Row Size&lt;/a&gt; for more information about the other factors that can contribute to the maximum row size for InnoDB tables.</source>
          <target state="translated">모든 InnoDB 행 형식은 특정 종류의 데이터를 오버플로 페이지에 저장할 수 있습니다. 따라서 InnoDB 테이블의 최대 행 크기는 행의 기본 데이터 페이지에 저장할 수있는 최대 데이터 양보다 클 수 있습니다. 참조 &lt;a href=&quot;#maximum-row-size&quot;&gt;최대 행 크기를&lt;/a&gt; InnoDB 테이블의 최대 행 크기에 기여할 수있는 다른 요인에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="30b94cb8724dc7e8bf4e3fc14dde473eff55ddf2" translate="yes" xml:space="preserve">
          <source>All InnoDB-specific Information Schema tables.</source>
          <target state="translated">모든 InnoDB 관련 정보 스키마 테이블.</target>
        </trans-unit>
        <trans-unit id="de945c73082af4e65931db4ed0c07b149ae8f8d1" translate="yes" xml:space="preserve">
          <source>All MariaDB versions</source>
          <target state="translated">모든 MariaDB 버전</target>
        </trans-unit>
        <trans-unit id="a15aefa88bbf69525c5de452f5e2d9603d7396a9" translate="yes" xml:space="preserve">
          <source>All MyRocks &lt;a href=&quot;../myrocks-system-variables/index&quot;&gt;system variables&lt;/a&gt; and &lt;a href=&quot;../myrocks-status-variables/index&quot;&gt;status variables&lt;/a&gt; are prefaced with &quot;rocksdb&quot;, so you can query them with, for example:</source>
          <target state="translated">모든 MyRocks &lt;a href=&quot;../myrocks-system-variables/index&quot;&gt;시스템 변수&lt;/a&gt; 및 &lt;a href=&quot;../myrocks-status-variables/index&quot;&gt;상태 변수&lt;/a&gt; 는 &quot;rocksdb&quot;로 시작하므로 다음과 같이 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="921a3a43a0376a693f2c6d5b9d50d61df2929211" translate="yes" xml:space="preserve">
          <source>All NULL values are also regarded as equivalent for the purposes of the DISTINCT and GROUP BY clauses.</source>
          <target state="translated">DISTINCT 및 GROUP BY 절의 목적 상 모든 NULL 값도 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8311b6bc8af128928b6ab1d7534df540db1106eb" translate="yes" xml:space="preserve">
          <source>All OEM code page characters - padded with blanks to the width of the field.</source>
          <target state="translated">모든 OEM 코드 페이지 문자-필드 너비에 공백으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="cb7a890ce7973afda0b308230b087dd85cab151d" translate="yes" xml:space="preserve">
          <source>All PIVOT tables are read only.</source>
          <target state="translated">모든 PIVOT 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="706ae50910026887744273e3f830dde5f338c240" translate="yes" xml:space="preserve">
          <source>All Performance Modules on a system configured with combined User and Performance Modules</source>
          <target state="translated">결합 된 사용자 및 성능 모듈로 구성된 시스템의 모든 성능 모듈</target>
        </trans-unit>
        <trans-unit id="5e2a03ca37173df61d9038b99cb03c3f0cc3e4c7" translate="yes" xml:space="preserve">
          <source>All Performance Modules on a system configured with separate User and Performance Modules and Local Query Feature is enabled</source>
          <target state="translated">별도의 사용자 및 성능 모듈과 로컬 쿼리 기능으로 구성된 시스템의 모든 성능 모듈이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="9dba1011b531bb4bf1fa9e65622b2e19402d36e4" translate="yes" xml:space="preserve">
          <source>All SQL except &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; is sent to all shards.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; 를 제외한 모든 SQL 이 모든 샤드로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="172e3563f13092309b407125c1801bd0aa61dc04" translate="yes" xml:space="preserve">
          <source>All SST methods except &lt;code&gt;rsync&lt;/code&gt; require authentication via username and password. You can tell the client what username and password to use by setting the &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_auth&quot;&gt;wsrep_sst_auth&lt;/a&gt;&lt;/code&gt; system variable. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; on the node that you intend to be a SST donor. For example:</source>
          <target state="translated">&lt;code&gt;rsync&lt;/code&gt; 를 제외한 모든 SST 방법 은 사용자 이름과 비밀번호를 통한 인증이 필요합니다. &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_auth&quot;&gt;wsrep_sst_auth&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 클라이언트에게 사용할 사용자 이름과 비밀번호를 알려줄 수 있습니다 . SST 기증자가 되려는 노드에서 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22fccf381894a5d9a1454ee449db5007606beadc" translate="yes" xml:space="preserve">
          <source>All User Modules on a system configured with separate User and Performance Modules</source>
          <target state="translated">별도의 사용자 및 성능 모듈로 구성된 시스템의 모든 사용자 모듈</target>
        </trans-unit>
        <trans-unit id="9781ea7a038a9a7ebd15cf9aa83577b03a6556f7" translate="yes" xml:space="preserve">
          <source>All VARCHARs are &quot;normalized&quot;; ids are stored instead</source>
          <target state="translated">모든 VARCHAR는 &quot;정규화&quot;됩니다. 대신 ID가 저장됩니다</target>
        </trans-unit>
        <trans-unit id="de6d2329e2344e264b1d369d80efee4fcd0f5a8f" translate="yes" xml:space="preserve">
          <source>All XtraDB-specific Information Schema tables.</source>
          <target state="translated">모든 XtraDB 관련 정보 스키마 테이블.</target>
        </trans-unit>
        <trans-unit id="29dd3e57c3963946de3828c2d3cd4518021dde81" translate="yes" xml:space="preserve">
          <source>All about online DDL operations with InnoDB.</source>
          <target state="translated">InnoDB에서의 온라인 DDL 작업에 관한 모든 것.</target>
        </trans-unit>
        <trans-unit id="0f0a1fdbc237c43ad0544d542b77aa5c7602b768" translate="yes" xml:space="preserve">
          <source>All access methods of this plan do not touch table rows, which results in much better performance.</source>
          <target state="translated">이 계획의 모든 액세스 방법은 테이블 행을 건드리지 않으므로 성능이 훨씬 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="1e589792154a8061f1fd28c6d8711eb415a46f07" translate="yes" xml:space="preserve">
          <source>All aggregate functions are supported.</source>
          <target state="translated">모든 집계 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="53e0d99dda6ca8b4dee87d6f73dfd32c3fd55768" translate="yes" xml:space="preserve">
          <source>All alter table that changes data or indexes requires a table copy.</source>
          <target state="translated">데이터 또는 인덱스를 변경하는 모든 대체 테이블에는 테이블 사본이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="79da10dd271162e1b02141736ae6b6303fc84827" translate="yes" xml:space="preserve">
          <source>All apps and tools, such as the popular LAMP stack, in the repositories that depend on the &lt;code&gt;mysql-server&lt;/code&gt; package will continue to work using MariaDB as the database. For new installs there is nothing different that needs to be done when installing the mysql-server or mariadb-server packages.</source>
          <target state="translated">&lt;code&gt;mysql-server&lt;/code&gt; 패키지 에 의존하는 저장소에서 널리 사용되는 LAMP 스택과 같은 모든 앱과 도구 는 MariaDB를 데이터베이스로 사용하여 계속 작동합니다. 새로 설치하는 경우 mysql-server 또는 mariadb-server 패키지를 설치할 때 수행해야 할 차이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="686616f8897a6492f556cb27a85d033beced5607" translate="yes" xml:space="preserve">
          <source>All basic calculations (+, -, *, /) with &lt;code&gt;DECIMAL&lt;/code&gt; columns are done with a precision of 65 digits.</source>
          <target state="translated">&lt;code&gt;DECIMAL&lt;/code&gt; 컬럼을 사용한 모든 기본 계산 (+,-, *, /) 은 65 자리의 정밀도로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b8cf19741eed16b6f781a38fa5783f32e89b969c" translate="yes" xml:space="preserve">
          <source>All behavior for naming columns, &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; is the same as for &lt;a href=&quot;../union/index&quot;&gt;&lt;code&gt;UNION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열 이름 지정 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 의 모든 동작 은 &lt;a href=&quot;../union/index&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; &lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1bcc0c0a8e4b70f05563056911f6b4bffc41483d" translate="yes" xml:space="preserve">
          <source>All behavior for naming columns, &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; is the same as for &lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;.</source>
          <target state="translated">열 이름 지정 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 의 모든 동작 은 &lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="059fc1ffc32ec84fedb06b04f6d7272047583cd6" translate="yes" xml:space="preserve">
          <source>All clients see the same data on the master at the same time; after acknowledgement by the slave and after being committed to the storage engine on the master.</source>
          <target state="translated">모든 클라이언트는 마스터에서 동일한 데이터를 동시에 볼 수 있습니다. 슬레이브의 승인 후 및 마스터의 스토리지 엔진에 커밋 된 후.</target>
        </trans-unit>
        <trans-unit id="10b3ca3332c9329ce5ef2b48bc2ea07862a77188" translate="yes" xml:space="preserve">
          <source>All columns in ColumnStore are nullable and the default value for any column is NULL. You may optionally specify NOT NULL for any column and/or one with a DEFAULT value.</source>
          <target state="translated">ColumnStore의 모든 열은 널 입력 가능하며 열의 기본값은 NULL입니다. 선택적으로 열 및 / 또는 DEFAULT 값이있는 열에 NOT NULL을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad980663bdbc926d897f33269d891cc186d5255" translate="yes" xml:space="preserve">
          <source>All columns used in the partitioning expression for a partitioned table must be part of every unique key that the table may have.</source>
          <target state="translated">파티션 된 테이블의 파티셔닝 표현식에 사용 된 모든 컬럼은 테이블이 가질 수있는 모든 고유 키의 일부 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4e24414d57e0653576aa2a8cc7078c1dee396cce" translate="yes" xml:space="preserve">
          <source>All commands including those run by &lt;a href=&quot;../mysqlcheck/index&quot;&gt;mysqlcheck&lt;/a&gt; are written to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. Disabled by default. Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1006-release-notes/&quot;&gt;MariaDB 10.0.6&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5534-release-notes/&quot;&gt;MariaDB 5.5.34&lt;/a&gt;, this was enabled by default, and &lt;code&gt;--skip-write-binlog&lt;/code&gt; should be used when commands should not be sent to replication slaves.</source>
          <target state="translated">&lt;a href=&quot;../mysqlcheck/index&quot;&gt;mysqlcheck&lt;/a&gt; 에 의해 실행되는 명령을 포함한 모든 명령 은 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에 기록&lt;/a&gt; 됩니다. 기본적으로 비활성화되어 있습니다. 전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1006-release-notes/&quot;&gt;MariaDB 10.0.6&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5534-release-notes/&quot;&gt;MariaDB 5.5.34&lt;/a&gt; 이 기본적으로 활성화되고, &lt;code&gt;--skip-write-binlog&lt;/code&gt; 명령이 복제 노예로 전송되지해야 할 때 사용한다.</target>
        </trans-unit>
        <trans-unit id="48a1514d98b55de35a88763b55ca5f95255de1aa" translate="yes" xml:space="preserve">
          <source>All critical errors are logged here.</source>
          <target state="translated">모든 중요한 오류가 여기에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b906b1bfbdb3b47e4087f3fdfaf2a2d67e6db8" translate="yes" xml:space="preserve">
          <source>All data is stored with the low byte first, so all files will still work if copied to other systems or other machines.</source>
          <target state="translated">모든 데이터는 먼저 낮은 바이트로 저장되므로 다른 시스템이나 다른 시스템으로 복사하면 모든 파일이 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="06de5b80dbbf06e87f8d9129b8c06b846b08e7c8" translate="yes" xml:space="preserve">
          <source>All data referenced in the SET and WHERE clause belongs to the data source.</source>
          <target state="translated">SET 및 WHERE 절에서 참조 된 모든 데이터는 데이터 소스에 속합니다.</target>
        </trans-unit>
        <trans-unit id="7b09cd40a4cb00f13ae38915004845eb1ee1d8c4" translate="yes" xml:space="preserve">
          <source>All data that is not supposed to fall into possible attackers hands should be encrypted. Especially information, subject to strict data protection regulations, is to be protected by encryption (e.g. in the healthcare sector: patient records). Additionally data being of interest for criminals should be protected. Data which should be encrypted are:</source>
          <target state="translated">가능한 공격자 손에 들어 가지 않아야하는 모든 데이터는 암호화되어야합니다. 특히 엄격한 데이터 보호 규정이 적용되는 정보는 암호화로 보호해야합니다 (예 : 의료 부문 : 환자 기록). 또한 범죄자에게 관심있는 데이터는 보호해야합니다. 암호화해야 할 데이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0502ad21905bc078635534840e2dc7808dddd8f" translate="yes" xml:space="preserve">
          <source>All data types are supported when defining generated columns.</source>
          <target state="translated">생성 된 열을 정의 할 때 모든 데이터 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="91785501bdca03a393017f9c91199f4369f3250a" translate="yes" xml:space="preserve">
          <source>All database development and administration tasks available from your IDE</source>
          <target state="translated">IDE에서 사용 가능한 모든 데이터베이스 개발 및 관리 작업</target>
        </trans-unit>
        <trans-unit id="f741ba1a4b81ffe3836e76159067d7146ef60580" translate="yes" xml:space="preserve">
          <source>All datatypes in MySQL 5.5 are also in all versions of MariaDB. I'm not sure if MySQL 5.6 introduced IP types; those types seem not to be in MariaDB yet, but it will be, because I see this task in JIRA: &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-274&quot;&gt;MDEV-274&lt;/a&gt;</source>
          <target state="translated">MySQL 5.5의 모든 데이터 유형은 모든 버전의 MariaDB에도 있습니다. MySQL 5.6이 IP 유형을 도입했는지 확실하지 않습니다. 이러한 유형은 아직 MariaDB에없는 것처럼 보이지만 JIRA : &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-274&quot;&gt;MDEV-274&lt;/a&gt; 에서이 작업을 볼 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="181777a2ded07f1a9a90fbe48f9a55282fc1e6ed" translate="yes" xml:space="preserve">
          <source>All discussion here assumes InnoDB tables, however most statements apply to other Engines.</source>
          <target state="translated">여기에서의 모든 논의는 InnoDB 테이블을 가정하지만 대부분의 문장은 다른 엔진에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c81edbe8c424205c3416dd8ce37f3a278eed4646" translate="yes" xml:space="preserve">
          <source>All error messages from a slave with a connection name, that are written to the error log, are prefixed with &lt;code&gt;Master 'connection_name':&lt;/code&gt;. This makes it easy to see from where an error originated.</source>
          <target state="translated">연결 이름을 가진 슬레이브에서 오류 로그에 기록 된 모든 오류 메시지는 &lt;code&gt;Master 'connection_name':&lt;/code&gt; 접두사가 붙습니다 . 따라서 오류가 발생한 위치를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d06843399f39e3217a4d583688ddd8049123cf4" translate="yes" xml:space="preserve">
          <source>All errors and warnings during &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; repair and auto recover.</source>
          <target state="translated">&lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 복구 및 자동 복구 중 모든 오류 및 경고 .</target>
        </trans-unit>
        <trans-unit id="0b57355f72a873d68f042eb18b44dd600a373cb3" translate="yes" xml:space="preserve">
          <source>All events have been read from the binary logs and sent to the slave. Now waiting for the binary log to be updated with new events.</source>
          <target state="translated">모든 이벤트는 이진 로그에서 읽혀져 슬레이브로 전송되었습니다. 이제 이진 로그가 새로운 이벤트로 업데이트되기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="478b6752311c967dba033efeb21f2c229cbb12fa" translate="yes" xml:space="preserve">
          <source>All examples here require running as administrator (and elevated command line in Vista and later)</source>
          <target state="translated">여기의 모든 예제는 관리자 권한으로 실행해야합니다 (Vista 이상에서는 고급 명령 줄).</target>
        </trans-unit>
        <trans-unit id="c1494465fe5e36f70514cdc59d0be470c1dd41d3" translate="yes" xml:space="preserve">
          <source>All except Guilhem Bichot are working for &lt;a href=&quot;http://mariadb.com&quot;&gt;MariaDB Corporation Ab&lt;/a&gt;.</source>
          <target state="translated">Guilhem Bichot를 제외한 모든 사람들이 &lt;a href=&quot;http://mariadb.com&quot;&gt;MariaDB Corporation Ab를&lt;/a&gt; 위해 일하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f2aeac6fd012fd4b63a8583b0b18ab2435b7245" translate="yes" xml:space="preserve">
          <source>All executed commands are stored in the normal binary log (nothing new here).</source>
          <target state="translated">실행 된 모든 명령은 일반 이진 로그에 저장됩니다 (새 항목은 없음).</target>
        </trans-unit>
        <trans-unit id="3fbf1fcee7d4e9e1d54fa79db4b01ed565ac95dc" translate="yes" xml:space="preserve">
          <source>All field formats (except the first one) are a one-character specification&lt;sup id=&quot;_ref-3&quot;&gt;[&lt;a href=&quot;#_note-3&quot;&gt;4&lt;/a&gt;]&lt;/sup&gt;. 'X' is equivalent to not specifying the field format. For the 'C' character specification, &lt;em&gt;n&lt;/em&gt; is the column width as specified with the column type. For one-column formats, the number of bytes of the numeric fields corresponds to what it is on most platforms. However, it could vary for some. The G, I, S and T formats are deprecated because they correspond to supported data types and may not be supported in future versions.</source>
          <target state="translated">모든 필드 형식 (첫 번째 형식 제외)은 한 문자 사양입니다 &lt;sup id=&quot;_ref-3&quot;&gt;[ &lt;a href=&quot;#_note-3&quot;&gt;4&lt;/a&gt; ]&lt;/sup&gt; . 'X'는 필드 형식을 지정하지 않는 것과 같습니다. 'C'문자 스펙의 경우 &lt;em&gt;n&lt;/em&gt; 은 열 유형으로 지정된 열 너비입니다. 1 열 형식의 경우 숫자 필드의 바이트 수는 대부분의 플랫폼에있는 바이트 수에 해당합니다. 그러나 일부 경우 다를 수 있습니다. G, I, S 및 T 형식은 지원되는 데이터 유형에 해당하며 향후 버전에서 지원되지 않을 수 있으므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8112033cf4228963ebcc18732f50a0473dbaf7f" translate="yes" xml:space="preserve">
          <source>All fields will be written between quotes, except null fields.</source>
          <target state="translated">null 필드를 제외한 모든 필드는 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="ddabd80d56ce10bbcf5f0671df8208560fe06e13" translate="yes" xml:space="preserve">
          <source>All fields will be written between quotes, including null fields.</source>
          <target state="translated">null 필드를 포함하여 모든 필드는 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="3dcc86a5658d7d99a90e713a58d688c4812c49f9" translate="yes" xml:space="preserve">
          <source>All functions need to be thread-safe, so not global or static variables that change can be allocated. Memory is allocated in &lt;em&gt;x_init()/ and freed in &lt;/em&gt;x_deinit()&lt;em&gt;. &lt;/em&gt;</source>
          <target state="translated">모든 함수는 스레드로부터 안전해야하므로 변경되는 전역 또는 정적 변수를 할당 할 수 없습니다. 메모리에 할당 &lt;em&gt;) (x_init /과에서 해제&lt;/em&gt; x_deinit () &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4932cebadbbb7dfb0c630af12f2ff14911ec29bc" translate="yes" xml:space="preserve">
          <source>All indexes should have equal speed (clustered index is not on our current road map for Aria. If you need clustered index, you should use XtraDB).</source>
          <target state="translated">모든 인덱스의 속도는 동일해야합니다 (클러스터형 인덱스는 현재 Aria 로드맵에 없습니다. 클러스터형 인덱스가 필요한 경우 XtraDB를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="16c47f53f884b692d2110e13a47863c9ad610772" translate="yes" xml:space="preserve">
          <source>All installed &lt;a href=&quot;../plugins/index&quot;&gt;plugins&lt;/a&gt; and their versions.</source>
          <target state="translated">설치된 모든 &lt;a href=&quot;../plugins/index&quot;&gt;플러그인&lt;/a&gt; 및 해당 버전</target>
        </trans-unit>
        <trans-unit id="3cb4c7987c67158bb7763af8989085191a7865f8" translate="yes" xml:space="preserve">
          <source>All integers in the above table are unsigned big integers.</source>
          <target state="translated">위 표의 모든 정수는 부호없는 큰 정수입니다.</target>
        </trans-unit>
        <trans-unit id="00318f30de8b3ee27030fefbfbba28f02b09f351" translate="yes" xml:space="preserve">
          <source>All is well -- until you have 50,000 items in a list. And someone tries to walk through all 5000 pages. That 'someone' could be a search engine crawler.</source>
          <target state="translated">목록에 50,000 개의 항목이있을 때까지 모든 것이 정상입니다. 그리고 누군가는 5000 페이지를 모두 걸 으려고합니다. 그 '누군가'는 검색 엔진 크롤러 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e746e4aec89ea5dec1d53e7d840a1e2d009ed3" translate="yes" xml:space="preserve">
          <source>All kinds of frame bounds are supported, including &lt;code&gt;RANGE PRECEDING|FOLLOWING n&lt;/code&gt; frame bounds (unlike PostgreSQL or MS SQL Server)</source>
          <target state="translated">&lt;code&gt;RANGE PRECEDING|FOLLOWING n&lt;/code&gt; 프레임 바운드 (PostgreSQL 또는 MS SQL Server와 달리)를 포함한 모든 종류의 프레임 바운드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e8776105920f8ed749dfc0673ef382ff14e792c9" translate="yes" xml:space="preserve">
          <source>All locks are acquired together when the &lt;code&gt;LOCK TABLES&lt;/code&gt; statement is issued and they are released together on &lt;code&gt;UNLOCK TABLES&lt;/code&gt;.</source>
          <target state="translated">모든 잠금은 &lt;code&gt;LOCK TABLES&lt;/code&gt; 문이 발행되고 &lt;code&gt;UNLOCK TABLES&lt;/code&gt; 에서 함께 해제 될 때 함께 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="32078f33a42b4238b637b922ef216cf8c81a48ee" translate="yes" xml:space="preserve">
          <source>All modifying operations are supported. However, inserting into arrays must be done in a specific way. Like with the Fullarray option, we must have enough columns to specify the array values. For instance, we can create a new table by:</source>
          <target state="translated">모든 수정 작업이 지원됩니다. 그러나 배열에 삽입하는 방법은 특정 방식으로 수행해야합니다. Fullarray 옵션과 마찬가지로 배열 값을 지정하기에 충분한 열이 있어야합니다. 예를 들어 다음과 같이 새 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad8491bde6df1dd35ef328e28373facb7d9eb22" translate="yes" xml:space="preserve">
          <source>All must do a full scan. (On the other hand, it can handy to use GROUP BY LEFT(date_col, 7) for monthly grouping, but that is not an INDEX issue.)</source>
          <target state="translated">모두 전체 스캔을 수행해야합니다. 반면에 월별 그룹화에 GROUP BY LEFT (date_col, 7)를 사용하면 편리하지만 INDEX 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d9bfc460bb6b5a15d9b9c5d7871c4ea72c28041e" translate="yes" xml:space="preserve">
          <source>All nodes can perform writes in parallel.</source>
          <target state="translated">모든 노드는 병렬로 쓰기를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f2d388d5593446b12f63f37dea06c22d62721a9" translate="yes" xml:space="preserve">
          <source>All nodes have been running a mysqlslap client attached to the local spider node in the best run.</source>
          <target state="translated">모든 노드는 최상의 성능으로 로컬 스파이더 노드에 연결된 mysqlslap 클라이언트를 실행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="de08e5e9d2843274e39859184e74ad51b26dc7c5" translate="yes" xml:space="preserve">
          <source>All of the restrictions listed in &lt;a href=&quot;../stored-function-limitations/index&quot;&gt;Stored Function Limitations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../stored-function-limitations/index&quot;&gt;저장된 기능&lt;/a&gt; 제한에 나열된 모든 제한 사항 .</target>
        </trans-unit>
        <trans-unit id="f7f50e4b623b789c05f75d32a0b60eb8b14df80c" translate="yes" xml:space="preserve">
          <source>All of the restrictions listed in &lt;a href=&quot;../stored-routine-limitations/index&quot;&gt;Stored Routine Limitations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../stored-routine-limitations/index&quot;&gt;저장된 루틴 제한 사항에&lt;/a&gt; 나열된 모든 제한 사항 .</target>
        </trans-unit>
        <trans-unit id="74a99bd62f0763c620ba436380c81e04135e48d1" translate="yes" xml:space="preserve">
          <source>All of them end a transaction without saving any transaction characteristics. The only other options, the equivalent statements:</source>
          <target state="translated">그들 모두는 거래 특성을 저장하지 않고 거래를 종료합니다. 다른 옵션, 동등한 진술 :</target>
        </trans-unit>
        <trans-unit id="5b8d4e7ae4bff8af91713ec5931b10810a04d2d5" translate="yes" xml:space="preserve">
          <source>All of these are ignored by ColumnStore.The following statement creates a table called orders with two columns: &lt;em&gt;orderkey&lt;/em&gt; with datatype integer and &lt;em&gt;customer&lt;/em&gt; with datatype varchar:</source>
          <target state="translated">다음은 &lt;em&gt;Statement&lt;/em&gt; 가 데이터 유형이 integer 인 &lt;em&gt;orderkey&lt;/em&gt; 와 varchar가 데이터 인 &lt;em&gt;customer&lt;/em&gt; 라는 두 개의 열이있는 orders라는 테이블을 작성하는 명령문입니다 .</target>
        </trans-unit>
        <trans-unit id="603de81e1dcceddb50fa1437a533e10206e56469" translate="yes" xml:space="preserve">
          <source>All of this encoding happens transparently at the filesystem level with one exception. Until MySQL 5.1.6, an old encoding was used. Identifiers created in a version before MySQL 5.1.6, and which haven't been updated to the new encoding, the server prefixes &lt;code&gt;mysql50&lt;/code&gt; to their name.</source>
          <target state="translated">이 인코딩은 모두 파일 시스템 수준에서 투명하게 이루어지며 한 가지 예외가 있습니다. MySQL 5.1.6까지는 오래된 인코딩이 사용되었습니다. MySQL 5.1.6 이전 버전에서 생성되었으며 새 인코딩으로 업데이트되지 않은 식별자는 서버 이름 앞에 &lt;code&gt;mysql50&lt;/code&gt; 을 붙입니다.</target>
        </trans-unit>
        <trans-unit id="b3bd993af5106ee934f996636687b097b1127f31" translate="yes" xml:space="preserve">
          <source>All open tasks and known bugs for multi-source can be found &lt;a href=&quot;https://jira.mariadb.org/issues/?filter=11400&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">다중 소스에 대해 열려있는 모든 작업과 알려진 버그는 &lt;a href=&quot;https://jira.mariadb.org/issues/?filter=11400&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98cbfd1acdcb802cd96138461e920c449ff85e44" translate="yes" xml:space="preserve">
          <source>All option file names must end in &lt;code&gt;.cnf&lt;/code&gt; on Unix-like operating systems. On Windows, all option file names must end in &lt;code&gt;.cnf&lt;/code&gt; or &lt;code&gt;.ini&lt;/code&gt;.</source>
          <target state="translated">모든 옵션 파일 이름은 Unix와 유사한 운영 체제 에서 &lt;code&gt;.cnf&lt;/code&gt; 로 끝나야 합니다. Windows에서 모든 옵션 파일 이름은 &lt;code&gt;.cnf&lt;/code&gt; 또는 &lt;code&gt;.ini&lt;/code&gt; 로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8a650abddaa8255d240472aa8df16283b42d5cb" translate="yes" xml:space="preserve">
          <source>All other classes match the SQLEXCEPTION keyword. The default MYSQL_ERRNO is 1644 and default MESSAGE_TEXT is 'Unhandled user-defined exception condition'.</source>
          <target state="translated">다른 모든 클래스는 SQLEXCEPTION 키워드와 일치합니다. 기본 MYSQL_ERRNO는 1644이고 기본 MESSAGE_TEXT는 '처리되지 않은 사용자 정의 예외 조건'입니다.</target>
        </trans-unit>
        <trans-unit id="fe1e7bd29aefb8b090d82c69c7f384dc65b1a475" translate="yes" xml:space="preserve">
          <source>All other master-related variables are global and affect either only the '' connections or all connections. For example, &lt;a href=&quot;../replication-and-binary-log-status-variables/index#slave_retried_transactions&quot;&gt;Slave_retried_transactions&lt;/a&gt; now shows the total number of retried transactions over all slaves.</source>
          <target state="translated">다른 모든 마스터 관련 변수는 전역 변수이며 ''연결 또는 모든 연결에만 영향을줍니다. 예를 들어, &lt;a href=&quot;../replication-and-binary-log-status-variables/index#slave_retried_transactions&quot;&gt;Slave_retried_transactions는&lt;/a&gt; 이제 모든 슬레이브에서 재 시도 된 총 트랜잭션 수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="65a5e1ff4cb1b3f6e7fbb1a6896f5911473943bc" translate="yes" xml:space="preserve">
          <source>All other systems: &lt;code&gt;OFF&lt;/code&gt;</source>
          <target state="translated">다른 모든 시스템 : &lt;code&gt;OFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e008f5a1efe044af1e40aa26cde9871a25e80a5d" translate="yes" xml:space="preserve">
          <source>All packages should be install as root user or use 'sudo' command when installing as non-root uster</source>
          <target state="translated">모든 패키지는 루트 사용자로 설치하거나 루트가 아닌 uster로 설치할 때 'sudo'명령을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="9b66b0b43a323b8879928cbd2c61b944d71e676b" translate="yes" xml:space="preserve">
          <source>All partitions must use the same storage engine. For a workaround, see &lt;a href=&quot;../using-connect-partitioning-and-sharding/index&quot;&gt;Using CONNECT - Partitioning and Sharding&lt;/a&gt;.</source>
          <target state="translated">모든 파티션은 동일한 스토리지 엔진을 사용해야합니다. 해결 방법은 &lt;a href=&quot;../using-connect-partitioning-and-sharding/index&quot;&gt;CONNECT-파티셔닝 및 샤딩 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09805f1e19cce7e38bf09cc81c677b9c8b56ea96" translate="yes" xml:space="preserve">
          <source>All partitions of a SPIDER table can also live on the same machine. In this case there will be a small overhead (SPIDER will use connections to localhost), but queries that read multiple partitions will use parallel threads.</source>
          <target state="translated">SPIDER 테이블의 모든 파티션도 동일한 머신에있을 수 있습니다. 이 경우 작은 오버 헤드가 발생하지만 (SPIDER는 로컬 호스트에 대한 연결을 사용함) 여러 파티션을 읽는 쿼리는 병렬 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a0da0e13f27145458e967f1b31af4f4c342d95a" translate="yes" xml:space="preserve">
          <source>All parts of a PRIMARY KEY must be NOT NULL; if you need NULL in a key, use UNIQUE instead</source>
          <target state="translated">기본 키의 모든 부분은 NULL이 아니어야합니다. 키에 NULL이 필요한 경우 대신 UNIQUE를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c8711fe7ec30898086e4594b71e75f07805d4aa" translate="yes" xml:space="preserve">
          <source>All parts of a SPATIAL index must be NOT NULL</source>
          <target state="translated">SPATIAL 인덱스의 모든 부분은 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c68ae591df71c298945b4d12487a9d1db3c99b5" translate="yes" xml:space="preserve">
          <source>All paths</source>
          <target state="translated">모든 경로</target>
        </trans-unit>
        <trans-unit id="4cbb8dccf8287d08af7fe3af8804349eeccc1967" translate="yes" xml:space="preserve">
          <source>All paths to which a particular disk has been mounted are reported. The rationale is that someone might want to take different action e.g. depending on which disk is relevant for a particular path. This leads to the same disk being reported multiple times.</source>
          <target state="translated">특정 디스크가 마운트 된 모든 경로가보고됩니다. 이론적 근거는 누군가가 특정 경로와 관련된 디스크에 따라 다른 조치를 취하고 자 할 수 있다는 것입니다. 이로 인해 동일한 디스크가 여러 번보고됩니다.</target>
        </trans-unit>
        <trans-unit id="df64c0fb5f32a7e7d246d62e621e78a2d3c4fd6b" translate="yes" xml:space="preserve">
          <source>All privileges that are specific to a stored routine will be dropped when a &lt;a href=&quot;../drop-function/index&quot;&gt;DROP FUNCTION&lt;/a&gt; or &lt;a href=&quot;drop-routine&quot;&gt;DROP ROUTINE&lt;/a&gt; is run. However, if a &lt;a href=&quot;../create-function/index&quot;&gt;CREATE OR REPLACE FUNCTION&lt;/a&gt; or &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE OR REPLACE PROCEDURE&lt;/a&gt; is used to drop and replace and the routine, any privileges specific to that routine will not be dropped.</source>
          <target state="translated">&lt;a href=&quot;../drop-function/index&quot;&gt;DROP FUNCTION&lt;/a&gt; 또는 &lt;a href=&quot;drop-routine&quot;&gt;DROP ROUTINE&lt;/a&gt; 이 실행될 때 스토어드 루틴과 관련된 모든 특권이 삭제됩니다 . 그러나 &lt;a href=&quot;../create-function/index&quot;&gt;CREATE OR REPLACE FUNCTION&lt;/a&gt; 또는 &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE OR REPLACE PROCEDURE&lt;/a&gt; 를 사용하여 삭제 및 교체 및 루틴을 사용하는 경우 해당 루틴에 특정한 특권은 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f072cb09c5b67fc8735eed85412d87f73b7dd92" translate="yes" xml:space="preserve">
          <source>All relational operations can be applied to this table. The table (and the file) can be updated, inserted and conditionally deleted. The only constraint is that when inserting values, the section name must be the first in the list of values.</source>
          <target state="translated">이 테이블에는 모든 관계형 작업을 적용 할 수 있습니다. 테이블 (및 파일)을 업데이트, 삽입 및 조건부로 삭제할 수 있습니다. 유일한 제약은 값을 삽입 할 때 섹션 이름이 값 목록에서 첫 번째 여야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d639da8767478ab1d51f48accc404f7a271792d4" translate="yes" xml:space="preserve">
          <source>All remaining read queries route to any MariaDB Server (OLTP)</source>
          <target state="translated">나머지 모든 읽기 쿼리는 모든 MariaDB 서버 (OLTP)로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="6dda0e4894f781e242151e6d383ec26ac766a1ca" translate="yes" xml:space="preserve">
          <source>All remaining read queries will route to any MariaDB Server.</source>
          <target state="translated">나머지 모든 읽기 쿼리는 모든 MariaDB 서버로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="88b7c6af01f2cf1b4690a79965bfebea34d6202f" translate="yes" xml:space="preserve">
          <source>All required MariaDB packages are included on the media, so there is no need for an Internet connection.</source>
          <target state="translated">필요한 모든 MariaDB 패키지가 미디어에 포함되어 있으므로 인터넷에 연결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f9da41c499e0ea7156397cda7fa56065a7866e1" translate="yes" xml:space="preserve">
          <source>All rows after the current row (UNBOUNDED FOLLOWING), for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING&lt;/code&gt;</source>
          <target state="translated">현재 행 뒤의 모든 행 (미지정 폴링), 예를 들어 &lt;code&gt;RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5770f6c2d2e625ebb3735e47b7a7f3c8eebe9d50" translate="yes" xml:space="preserve">
          <source>All rows before the current row (UNBOUNDED PRECEDING), for example &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;</source>
          <target state="translated">현재 행 (UNBOUNDED PRECEDING) 앞의 모든 행 (예 : &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="47ed96c0e48460e5758842bfb1b33cad0fdc545e" translate="yes" xml:space="preserve">
          <source>All rows contain the same value.</source>
          <target state="translated">모든 행은 동일한 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="235d717fba10ea0abe0497cfc88ab91dae534d35" translate="yes" xml:space="preserve">
          <source>All session connection attributes.</source>
          <target state="translated">모든 세션 연결 속성</target>
        </trans-unit>
        <trans-unit id="48830dc3d8c46cf86328a383a90efbba6ee47aec" translate="yes" xml:space="preserve">
          <source>All spatial data types</source>
          <target state="translated">모든 공간 데이터 유형</target>
        </trans-unit>
        <trans-unit id="ac93476c6952f91a377dd75487544ea3ac85e514" translate="yes" xml:space="preserve">
          <source>All statements are profiled except &lt;code&gt;SHOW PROFILES&lt;/code&gt; and &lt;code&gt;SHOW PROFILE&lt;/code&gt;, so you will find neither of those statements in the profile list. Malformed statements are profiled. For example, &lt;code&gt;SHOW PROFILING&lt;/code&gt; is an illegal statement, and a syntax error occurs if you try to execute it, but it will show up in the profiling list.</source>
          <target state="translated">&lt;code&gt;SHOW PROFILES&lt;/code&gt; 및 &lt;code&gt;SHOW PROFILE&lt;/code&gt; 을 제외한 모든 명령문은 프로파일 링 되므로 프로파일 목록에서 해당 명령문을 찾을 수 없습니다. 잘못된 진술은 프로파일로 작성됩니다. 예를 들어 &lt;code&gt;SHOW PROFILING&lt;/code&gt; 은 잘못된 명령문이며 실행하려고하면 구문 오류가 발생하지만 프로파일 링 목록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="09edc9ee9148c6f7f30e9512bbb2b946ad635316" translate="yes" xml:space="preserve">
          <source>All statements in ColumnStore run at a particular version (or, snapshot) of the database, which the system refers to as the System Change Number, (SCN).</source>
          <target state="translated">ColumnStore의 모든 명령문은 데이터베이스의 특정 버전 (또는 스냅 샷)에서 실행되며 시스템은 시스템 변경 번호 (SCN)라고합니다.</target>
        </trans-unit>
        <trans-unit id="2a2c9d838b7828ecb87e1de14d91045b67bb660c" translate="yes" xml:space="preserve">
          <source>All string columns with a length of four or more are dynamic.</source>
          <target state="translated">길이가 4 이상인 모든 문자열 열은 동적입니다.</target>
        </trans-unit>
        <trans-unit id="e2d21202a190ec6e10db33d93b3aefcda8b3c49c" translate="yes" xml:space="preserve">
          <source>All subsequent calls to any FederatedX table using the 'server_one' will now be against db2.t1! Guess what? You no longer have to perform an alter table in order to point one or more FederatedX tables to a new server!</source>
          <target state="translated">'server_one'을 사용하는 모든 FederatedX 테이블에 대한 모든 후속 호출은 이제 db2.t1에 대한 것입니다! 뭔지 맞춰봐? 하나 이상의 FederatedX 테이블을 새 서버로 지정하기 위해 더 이상 alter table을 수행 할 필요가 없습니다!</target>
        </trans-unit>
        <trans-unit id="bbe8750cfa10f3c7544e75523e95a5f108766a63" translate="yes" xml:space="preserve">
          <source>All tables in all catalogs and all schemas</source>
          <target state="translated">모든 카탈로그 및 모든 스키마의 모든 테이블</target>
        </trans-unit>
        <trans-unit id="143cd2c91491bb35d6b2145be6bb5d37e7a3aeb9" translate="yes" xml:space="preserve">
          <source>All tables in the join was optimized away. This happens when we are only using &lt;code&gt;COUNT(*)&lt;/code&gt;, &lt;code&gt;MIN()&lt;/code&gt; and &lt;code&gt;MAX()&lt;/code&gt; functions in the &lt;code&gt;SELECT&lt;/code&gt; and we where able to replace all of these with constants.</source>
          <target state="translated">조인의 모든 테이블이 최적화되었습니다. 이것은 &lt;code&gt;SELECT&lt;/code&gt; 에서 &lt;code&gt;COUNT(*)&lt;/code&gt; , &lt;code&gt;MIN()&lt;/code&gt; 및 &lt;code&gt;MAX()&lt;/code&gt; 함수 만 사용 하고 이러한 모든 것을 상수로 바꿀 수있는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f82c6cb99775222986c359d46cc90e2fafd88800" translate="yes" xml:space="preserve">
          <source>All tables in the test schema</source>
          <target state="translated">테스트 스키마의 모든 테이블</target>
        </trans-unit>
        <trans-unit id="edfc22becdca761ae30ca1a9d817daf8d2bb2976" translate="yes" xml:space="preserve">
          <source>All tables should have a primary key (multi-column primary keys are supported). &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; operations are unsupported on tables without a primary key. Also, rows in tables without a primary key may appear in a different order on different nodes.</source>
          <target state="translated">모든 테이블에는 기본 키가 있어야합니다 (여러 열 기본 키가 지원됨). 기본 키가없는 테이블에서는 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 작업이 지원되지 않습니다. 또한 기본 키가없는 테이블의 행은 다른 노드에서 다른 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9060b7e6e3ed20176b5c2e6ebcf85c7b5a94cc1b" translate="yes" xml:space="preserve">
          <source>All tables used in a query cache entry</source>
          <target state="translated">쿼리 캐시 항목에 사용 된 모든 테이블</target>
        </trans-unit>
        <trans-unit id="7329d5830f99cf20ad4a6a42049ba92c996a6a3a" translate="yes" xml:space="preserve">
          <source>All the above strategies can be controlled via the following switches in &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; system variable.</source>
          <target state="translated">위의 모든 전략은 &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; 시스템 변수 의 다음 스위치를 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf1f1a11329cd673f0331e1ad6d9c0d0387b298b" translate="yes" xml:space="preserve">
          <source>All the algorithms given below are &quot;fast&quot;, but most introduce flaws:</source>
          <target state="translated">아래에 주어진 모든 알고리즘은 &quot;빠른&quot;것이지만, 대부분 결함이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4a149d098587b979d872df0607a71d5c0335ec62" translate="yes" xml:space="preserve">
          <source>All the dependent packages have been installed.</source>
          <target state="translated">모든 종속 패키지가 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="41722fbe51be0beb15efa629aeff75feb140713b" translate="yes" xml:space="preserve">
          <source>All the following &lt;code&gt;DATE&lt;/code&gt; literals are valid, and they all represent the same value:</source>
          <target state="translated">다음 &lt;code&gt;DATE&lt;/code&gt; 리터럴은 모두 유효하며 모두 동일한 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57813ac1b43d78659eeebf17a455009c40e406fd" translate="yes" xml:space="preserve">
          <source>All the following examples are valid:</source>
          <target state="translated">다음의 모든 예가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7e35f92af3b46b4aa190a06e476ddead96da2963" translate="yes" xml:space="preserve">
          <source>All the names in alphabetical order:</source>
          <target state="translated">알파벳 순서로 모든 이름 :</target>
        </trans-unit>
        <trans-unit id="55a0e17b98249c6d973d199f5ad7fb8aa14729ce" translate="yes" xml:space="preserve">
          <source>All the options in your original MySQL &lt;a href=&quot;../mysqld-configuration-files-and-groups/index&quot;&gt;&lt;code&gt;my.cnf&lt;/code&gt; file&lt;/a&gt; should work fine for MariaDB.</source>
          <target state="translated">원본 MySQL &lt;a href=&quot;../mysqld-configuration-files-and-groups/index&quot;&gt; &lt;code&gt;my.cnf&lt;/code&gt; 파일의&lt;/a&gt; 모든 옵션이 MariaDB에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e06a8afbfce7aa60a90dc9b1db2a616e42fa37fa" translate="yes" xml:space="preserve">
          <source>All the specified columns are compared to the specified values to determine which partition should contain a specific row. See below for details.</source>
          <target state="translated">지정된 모든 열을 지정된 값과 비교하여 특정 행을 포함해야하는 파티션을 결정합니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ad2ac82497b9f6a482aa8ef762a6e2ec734d78d" translate="yes" xml:space="preserve">
          <source>All the steps are the same, since an index is essentially a &quot;table&quot; except that the &quot;data&quot; is a copy of the PRIMARY KEY.</source>
          <target state="translated">&quot;데이터&quot;가 기본 키의 사본이라는 점을 제외하고 인덱스는 기본적으로 &quot;테이블&quot;이므로 모든 단계가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="25e9bb5aad7718c7737cf5abcdfe85f84a5c2a70" translate="yes" xml:space="preserve">
          <source>All these can be combined or transformed by further SQL operations. This makes working with CONNECT much more flexible than just using the &lt;a href=&quot;../load/index&quot;&gt;LOAD&lt;/a&gt; statement.</source>
          <target state="translated">이 모든 것을 추가 SQL 조작으로 결합하거나 변환 할 수 있습니다. 따라서 &lt;a href=&quot;../load/index&quot;&gt;LOAD&lt;/a&gt; 문을 사용하는 것보다 CONNECT로 작업하는 것이 훨씬 유연 합니다.</target>
        </trans-unit>
        <trans-unit id="c705a5d88924e63a3bcdba765a2fc3ef4016ec0b" translate="yes" xml:space="preserve">
          <source>All these literals are equivalent:</source>
          <target state="translated">이 모든 리터럴은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6feb89ab40a44c3c3ff2e4997acacff391707b5a" translate="yes" xml:space="preserve">
          <source>All these statements can also be executed inside a stored routine. However, only SHOW WARNINGS and SHOW ERRORS can be executed as a prepared statement. After an &lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt; statement, the diagnostics area contains information about the prepared statement, if it produces error conditions.</source>
          <target state="translated">이 모든 명령문은 저장 루틴 내에서 실행될 수도 있습니다. 그러나 SHOW WARNINGS 및 SHOW ERRORS 만 준비된 명령문으로 실행할 수 있습니다. 애프터 &lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt; 는 오류 조건을 생성하는 경우 문, 진단 지역은 준비된 명령문에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8233df255553677bf4b2346e99965dd7ebb043fc" translate="yes" xml:space="preserve">
          <source>All these statements cause an implicit commit before execution. This means that, even if the statement fails with an error, the transaction is committed. Some of them, like &lt;code&gt;CREATE TABLE ... SELECT&lt;/code&gt;, also cause a commit immediatly after execution. Such statements couldn't be rollbacked in any case.</source>
          <target state="translated">이 모든 명령문은 실행 전에 암시 적 커밋을 유발합니다. 이는 오류로 명령문이 실패하더라도 트랜잭션이 커미트됨을 의미합니다. &lt;code&gt;CREATE TABLE ... SELECT&lt;/code&gt; 와 같은 일부는 실행 후 즉시 커밋을 유발합니다. 이러한 진술은 어떤 경우에도 롤백 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ca5267a80c39edf9cd942a7ac7c089538452641" translate="yes" xml:space="preserve">
          <source>All this can be avoided and optimized by forcing the query to be locally executed on each server and retrieving only the small results of the group by queries. Here is how to do it. For each remote machine, create a table that will retrieve the locally executed query. For instance for m1:</source>
          <target state="translated">쿼리가 각 서버에서 로컬로 실행되도록하고 쿼리별로 그룹의 작은 결과 만 검색하면이 모든 것을 피하고 최적화 할 수 있습니다. 방법은 다음과 같습니다. 각 원격 컴퓨터에 대해 로컬로 실행 된 쿼리를 검색 할 테이블을 만듭니다. 예를 들어 m1의 경우 :</target>
        </trans-unit>
        <trans-unit id="48a25fa2ad823f434868142f3eedf3660a7e557e" translate="yes" xml:space="preserve">
          <source>All this is mostly useful when creating a table on a remote file that you cannot easily see.</source>
          <target state="translated">이 모든 것은 대부분 쉽게 볼 수없는 원격 파일에서 테이블을 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6c95e78c9114e2561b69e80692ebf4efedf4f817" translate="yes" xml:space="preserve">
          <source>All this is targeted at running joins which touch small fraction of the tables. The expected typical use-case looks like this:</source>
          <target state="translated">이 모든 것은 테이블의 작은 부분에 닿는 실행 조인을 대상으로합니다. 예상되는 일반적인 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d703b08ac431df26e8f2ab91e508f9bc7c46fb85" translate="yes" xml:space="preserve">
          <source>All user accounts, passwords, and global privileges are now stored in the &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; table. The &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table still exists and has exactly the same set of columns as before, but it&amp;rsquo;s now a view that references the &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; table. Tools that analyze the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table should continue to workas before.</source>
          <target state="translated">모든 사용자 계정, 비밀번호 및 글로벌 권한이 이제 &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; 테이블에 저장됩니다 . &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블은 여전히 존재하고 이전과 열 정확히 같은 설정을 가지고 있지만 지금은보기 참조 그의 &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; 의 테이블. &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블 을 분석하는 도구는 이전과 같이 계속 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="edd663374372a0d7966447fd0bab9ecb44c3ec3b" translate="yes" xml:space="preserve">
          <source>All values must be specified as literals, not expressions. The value of a boolean option may be specified as one of YES, NO, ON, OFF, 1, or 0. A string value may be specified either quoted or not, as an identifier (if it is a valid identifier, of course). Compare with the old behavior:</source>
          <target state="translated">모든 값은 표현식이 아닌 리터럴로 지정해야합니다. 부울 옵션의 값은 YES, NO, ON, OFF, 1 또는 0 중 하나로 지정 될 수 있습니다. 문자열 값은 인용 부호로 지정되거나 식별자로 지정 될 수 있습니다 (물론 유효한 식별자 인 경우). . 이전 동작과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="49e169c59889c9d93e3c0f8db6ace3961a5f8f4d" translate="yes" xml:space="preserve">
          <source>All your old clients and connectors (PHP, Perl, Python, Java, etc.) will work unchanged (no need to recompile). This works because MariaDB and MySQL use the same client protocol and the client libraries are binary compatible. You can also use your old MySQL connector packages with MariaDB if you want.</source>
          <target state="translated">모든 기존 클라이언트 및 커넥터 (PHP, Perl, Python, Java 등)는 변경없이 작동합니다 (다시 컴파일 할 필요 없음). MariaDB와 MySQL은 동일한 클라이언트 프로토콜을 사용하고 클라이언트 라이브러리는 이진 호환 가능하기 때문에 작동합니다. 원하는 경우 이전 MySQL 커넥터 패키지를 MariaDB와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea133b318fdf4b51af92ca62cfe5af844f63412" translate="yes" xml:space="preserve">
          <source>Allocate any required memory. To verify that the arguments are of a required type or, alternatively, to tell MySQL to coerce arguments to the required types when the main function is called.</source>
          <target state="translated">필요한 메모리를 할당하십시오. 인수가 필수 유형인지 확인하거나 주 함수가 호출 될 때 MySQL이 필수 유형에 대한 인수를 강제하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="93c60386590b6f1525e7585e8813bd68cd52253b" translate="yes" xml:space="preserve">
          <source>Allocating RAM for MariaDB - The Short Answer</source>
          <target state="translated">MariaDB에 RAM 할당-간단한 답변</target>
        </trans-unit>
        <trans-unit id="d35aad6327ca3c68183050863e07af37b9aefd5c" translate="yes" xml:space="preserve">
          <source>Allow 'any' length transactions to work (Having long running transactions will cause more log space to be used).</source>
          <target state="translated">'모든'길이의 트랜잭션이 작동하도록 허용 (오래 실행 된 트랜잭션이 있으면 더 많은 로그 공간이 사용됨)</target>
        </trans-unit>
        <trans-unit id="a2fc9a0067f3a68f8e1a374a32726f53f50b1fca" translate="yes" xml:space="preserve">
          <source>Allow anonymous users</source>
          <target state="translated">익명 사용자 허용</target>
        </trans-unit>
        <trans-unit id="d4484acc37b78c0f22c4f1aa8a663b17c907dcf2" translate="yes" xml:space="preserve">
          <source>Allow any day between 1-31 in the day part. This is convenient when you want to read in all (including wrong data) into the database and then manipulate it there.</source>
          <target state="translated">하루 부분에서 1-31 사이의 하루를 허용하십시오. 데이터베이스에있는 모든 데이터 (잘못된 데이터 포함)를 읽은 다음 데이터베이스에서 조작 할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="3db88650cdbf64cfcc0714a38f77663fb3da10d8" translate="yes" xml:space="preserve">
          <source>Allow copying of Aria tables between different Aria servers (under some well-defined constraints).</source>
          <target state="translated">잘 정의 된 제약 조건 하에서 다른 Aria 서버간에 Aria 테이블을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf92556b29944734e14ef268efaba5317fb876b" translate="yes" xml:space="preserve">
          <source>Allow creation of column names that are keywords. This works by prefixing each column name with the table name.</source>
          <target state="translated">키워드 인 열 이름을 만들 수 있습니다. 각 열 이름 앞에 테이블 이름을 붙여서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cf3c9ac40f72695980d2040b100a0038b72b4820" translate="yes" xml:space="preserve">
          <source>Allow duplicate names for subpatterns</source>
          <target state="translated">하위 패턴에 중복 이름 허용</target>
        </trans-unit>
        <trans-unit id="ea9d50cd73e944889f3709dadf5bc4d65291b534" translate="yes" xml:space="preserve">
          <source>Allow log shipping; that is, you can do incremental backups of Aria tables just by copying the Aria logs.</source>
          <target state="translated">로그 배송 허용; 즉, Aria 로그를 복사하여 Aria 테이블의 증분 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88780c68b9714fc0ebb901a7f037740c2ab50599" translate="yes" xml:space="preserve">
          <source>Allow one to have spaces (including tab characters and new line characters) between function name and '('. The drawback is that this causes built in functions to become &lt;a href=&quot;../reserved-words/index&quot;&gt;reserved words&lt;/a&gt;.</source>
          <target state="translated">함수 이름과 '(') 사이에 공백 (탭 문자 및 줄 바꾸기 문자 포함)을 허용하십시오. 단점은 내장 함수가 &lt;a href=&quot;../reserved-words/index&quot;&gt;예약어&lt;/a&gt; 가되게한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ef1c94fc5c54c0d3cbd017d1a428bf641fbda444" translate="yes" xml:space="preserve">
          <source>Allow only those &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; statements that specify which rows to modify by using key values. If you have set this option in an option file, you can override it by using &lt;code&gt;--safe-updates&lt;/code&gt; on the command line. See &lt;a href=&quot;#using-the-safe-updates-option&quot;&gt;using the --safe-updates option&lt;/a&gt; for more.</source>
          <target state="translated">키 값을 사용하여 수정할 행을 지정하는 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 문만 허용하십시오 . 옵션 파일에서이 옵션을 설정 한 경우 명령 줄에서 &lt;code&gt;--safe-updates&lt;/code&gt; 를 사용하여이 옵션을 재정의 할 수 있습니다 . 자세한 내용 &lt;a href=&quot;#using-the-safe-updates-option&quot;&gt;은 --safe-updates 옵션 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba1d30fb1b8a73c8317fb0b2ef8e92c280692052" translate="yes" xml:space="preserve">
          <source>Allow remote access for root user</source>
          <target state="translated">루트 사용자에 대한 원격 액세스 허용</target>
        </trans-unit>
        <trans-unit id="725a064e57d7aea77d0edb7c0ac90d350df2959e" translate="yes" xml:space="preserve">
          <source>Allow remote access from network for user root</source>
          <target state="translated">사용자 루트에 대해 네트워크에서 원격 액세스 허용</target>
        </trans-unit>
        <trans-unit id="0128d278d0cea894c5941a9e910cac09cc75d3f4" translate="yes" xml:space="preserve">
          <source>Allow replication from one master to one slave in many threads</source>
          <target state="translated">많은 스레드에서 하나의 마스터에서 하나의 슬레이브로 복제 허용</target>
        </trans-unit>
        <trans-unit id="0a8362073cb933109e7bdb23b753bcd9ee87747e" translate="yes" xml:space="preserve">
          <source>Allow tests marked as &quot;big&quot; to run. Tests can be thus marked by including the line &lt;code&gt;--source include/big_test.inc&lt;/code&gt;, and they will only be run if this option is given, or if the environment variable BIG_TEST is set to 1. Repeat this option twice to run only &quot;big&quot; tests. This is typically used for tests that take a very long to run, or that use many resources, so that they are not suitable for running as part of a normal test suite run</source>
          <target state="translated">&quot;big&quot;으로 표시된 테스트를 실행하십시오. 따라서 &lt;code&gt;--source include/big_test.inc&lt;/code&gt; 행을 포함하여 테스트를 표시 할 수 있으며이 옵션이 제공되거나 환경 변수 BIG_TEST가 1로 설정된 경우에만 실행됩니다. &quot;big&quot;만 실행하려면이 옵션을 두 번 반복하십시오. &quot;테스트. 일반적으로 실행 시간이 오래 걸리거나 많은 리소스를 사용하는 테스트에 사용되므로 일반 테스트 스위트 실행의 일부로 실행하기에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="584aa492e07ddafb183d89d7fc61fea33be28e1c" translate="yes" xml:space="preserve">
          <source>Allow the contents of one or more master servers to be mirrored on one or more slave servers.</source>
          <target state="translated">하나 이상의 마스터 서버 내용이 하나 이상의 슬레이브 서버에 미러링되도록합니다.</target>
        </trans-unit>
        <trans-unit id="b4b7a21dc6b2fc969f4fc51cf9c7b8ad1886b888" translate="yes" xml:space="preserve">
          <source>Allowable values are:</source>
          <target state="translated">허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41c1ced3f33366c8749731635c679e151ebcc2fa" translate="yes" xml:space="preserve">
          <source>Allowing Access to the Tmpfs File Context</source>
          <target state="translated">Tmpfs 파일 컨텍스트에 대한 액세스 허용</target>
        </trans-unit>
        <trans-unit id="e64af1dd5bd94098bd4366589317f1295504fc60" translate="yes" xml:space="preserve">
          <source>Allowing concurrent DML during the operation does not solve all problems. When a column was added to a table with the older in-place optimization, the resulting table rebuild could still significantly increase the I/O and memory consumption and cause replication lag.</source>
          <target state="translated">작업 중에 동시 DML을 허용해도 모든 문제가 해결되는 것은 아닙니다. 이전 위치 내 최적화로 테이블에 열을 추가 한 경우 결과 테이블 재 구축으로 인해 여전히 I / O 및 메모리 소비가 크게 증가하고 복제 지연이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e52174e61b60431ce563bc1ccd115927bd1923" translate="yes" xml:space="preserve">
          <source>Allows &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; command options to use non-empty target directories.</source>
          <target state="translated">비어 있지 않은 대상 디렉토리를 사용하기 위해 &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; 명령 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="9fc3a6e403af41a47efe6ca3b97d59d256cdc384" translate="yes" xml:space="preserve">
          <source>Allows reference to subqueries as temporary tables within queries.</source>
          <target state="translated">쿼리 내에서 임시 테이블로 하위 쿼리를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fed30439ce7f8043e2b4c475ca6fdb5eef1a40b" translate="yes" xml:space="preserve">
          <source>Allows the creation of password validation plugins to check user passwords as they are set.</source>
          <target state="translated">비밀번호 유효성 검증 플러그인을 작성하여 사용자 비밀번호가 설정된대로 확인할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="24e05d85abd44ee1a08ab7500fdb3665321fe003" translate="yes" xml:space="preserve">
          <source>Allows using the pipe character (ASCII 124) as string concatenation operator. This means that &lt;code&gt;&quot;A&quot; || &quot;B&quot;&lt;/code&gt; can be used in place of &lt;code&gt;CONCAT(&quot;A&quot;, &quot;B&quot;)&lt;/code&gt;.</source>
          <target state="translated">파이프 문자 (ASCII 124)를 문자열 연결 연산자로 사용할 수 있습니다. 이것은 &lt;code&gt;&quot;A&quot; || &quot;B&quot;&lt;/code&gt; &lt;code&gt;CONCAT(&quot;A&quot;, &quot;B&quot;)&lt;/code&gt; 대신 &quot;B&quot;를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="296899f6def10dee5ffd8d36ee90d0205fd913bd" translate="yes" xml:space="preserve">
          <source>Allows you to access a collection of identical MyISAM tables as one.</source>
          <target state="translated">동일한 MyISAM 테이블 컬렉션에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b660b8d6cab5e5cd13c4225ba8e058c16448ba78" translate="yes" xml:space="preserve">
          <source>Allows you to access tables in other MariaDB or MySQL servers.</source>
          <target state="translated">다른 MariaDB 또는 MySQL 서버의 테이블에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc348b917ad835c432bbed7c6f9ef3b32266001" translate="yes" xml:space="preserve">
          <source>Allows you to combine data from different sources.</source>
          <target state="translated">다른 소스의 데이터를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04b46a260db1da3212638194f23f34d1e23be977" translate="yes" xml:space="preserve">
          <source>Allows you to modify the type of a column. The column will be at the same place as the original column and all indexes on the column will be kept. Note that when modifying column, you should specify all attributes for the new column.</source>
          <target state="translated">열 유형을 수정할 수 있습니다. 열은 원래 열과 같은 위치에 있으며 열의 모든 인덱스가 유지됩니다. 열을 수정할 때 새 열에 대한 모든 속성을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa2ee4702d21a946cf5c8ba87fbdd9c015103061" translate="yes" xml:space="preserve">
          <source>Almost all functions returning a json string - whose name begins with &lt;em&gt;Json_&lt;/em&gt; - have a counterpart with a name beginning with &lt;em&gt;Jbin_&lt;/em&gt;. This is both for performance (speed and memory) as well as for better control of what the functions should do.</source>
          <target state="translated">이름이 &lt;em&gt;Json_로&lt;/em&gt; 시작하는 json 문자열을 반환하는 거의 모든 함수에는 &lt;em&gt;Jbin_로&lt;/em&gt; 시작 하는 이름을 가진 &lt;em&gt;함수가&lt;/em&gt; 있습니다. 이는 성능 (속도 및 메모리)과 기능 수행을보다 잘 제어하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a7261d7be649c5429de0fb30d9b7842576025e1" translate="yes" xml:space="preserve">
          <source>Almost all the work will be done on the remote machines, simultaneously thanks to the thread option, making this query super-fast even on big tables placed on many remote machines.</source>
          <target state="translated">스레드 옵션 덕분에 거의 모든 작업이 원격 컴퓨터에서 동시에 수행되므로 많은 원격 컴퓨터에 배치 된 큰 테이블에서도이 쿼리가 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5f0a8affa73b0315a6b71fab3500baa92a03dacb" translate="yes" xml:space="preserve">
          <source>Along with the following Base R reference card: &lt;a href=&quot;https://cran.r-project.org/doc/contrib/Baggott-refcard-v2.pdf&quot;&gt;R Reference Card v2&lt;/a&gt;</source>
          <target state="translated">다음 기본 R 참조 카드와 함께 : &lt;a href=&quot;https://cran.r-project.org/doc/contrib/Baggott-refcard-v2.pdf&quot;&gt;R 참조 카드 v2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58061aa544398a798e33181a443b15b7746fab16" translate="yes" xml:space="preserve">
          <source>Alpha</source>
          <target state="translated">Alpha</target>
        </trans-unit>
        <trans-unit id="e8f8e66481500878ac94177c035b7532b6842b37" translate="yes" xml:space="preserve">
          <source>Alphabet value 63 is encoded as '/'.</source>
          <target state="translated">알파벳 값 63은 '/'로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="fd29a7a4c284c88bffeb18498f923c5936a383d5" translate="yes" xml:space="preserve">
          <source>Alphabet value 64 is encoded as '+'.</source>
          <target state="translated">알파벳 값 64는 '+'로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a707a85edc66a653109fa80da8910d24c0d7d6d7" translate="yes" xml:space="preserve">
          <source>Alphabetic</source>
          <target state="translated">Alphabetic</target>
        </trans-unit>
        <trans-unit id="a9e1dcc7d285ac1293febf75303a25982fcd84ee" translate="yes" xml:space="preserve">
          <source>Alphabetical List</source>
          <target state="translated">알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="36702a454fca0013b719c20da344fb717ab5491f" translate="yes" xml:space="preserve">
          <source>Alphabetical list of all &lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;mysqld Options&lt;/a&gt;, &lt;a href=&quot;../server-system-variables/index&quot;&gt;Server System Variables&lt;/a&gt; and &lt;a href=&quot;../server-status-variables/index&quot;&gt;Server Status Variables&lt;/a&gt;. The convention used is that variable names are listed with '_' and options with '-'. If a variable and option both exist, both versions are listed for easy searching.</source>
          <target state="translated">모든 &lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;mysqld 옵션&lt;/a&gt; , &lt;a href=&quot;../server-system-variables/index&quot;&gt;서버 시스템 변수&lt;/a&gt; 및 &lt;a href=&quot;../server-status-variables/index&quot;&gt;서버 상태 변수&lt;/a&gt; 의 알파벳순 목록 . 사용 된 규칙은 변수 이름이 '_'로 나열되고 옵션이 '-'로 나열된다는 것입니다. 변수와 옵션이 모두 존재하면 쉽게 찾을 수 있도록 두 버전이 모두 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="c34318ee2e23852684418e59038581c523863d11" translate="yes" xml:space="preserve">
          <source>Alphanumeric</source>
          <target state="translated">Alphanumeric</target>
        </trans-unit>
        <trans-unit id="9f033423d9d38c060b8f05c54586f008c8b516e4" translate="yes" xml:space="preserve">
          <source>Alphanumeric: union of properties L and N</source>
          <target state="translated">영숫자 : 속성 L과 N의 합집합</target>
        </trans-unit>
        <trans-unit id="700b6525da5c648711503674cc302fbd88fc5571" translate="yes" xml:space="preserve">
          <source>Also I do not know if all datatypes in Oracle-MySQL are supported by MariaDB. For example, tinyint, bigint. (Sincerly, I know that MariaDB understand these datatypes, but I wonder if they have the same definition as given by the Oracle-MySQL-site.) Thanks for help</source>
          <target state="translated">또한 Oracle-MySQL의 모든 데이터 유형이 MariaDB에서 지원되는지 여부를 알 수 없습니다. 예를 들어 tinyint, bigint입니다. (마침내, MariaDB는 이러한 데이터 유형을 이해하지만 Oracle-MySQL 사이트에서 제공 한 것과 동일한 정의를 가지고 있는지 궁금합니다.)</target>
        </trans-unit>
        <trans-unit id="535ed87f4e355570762b1f9bc7775b6e703d476c" translate="yes" xml:space="preserve">
          <source>Also has the effect of silently converting &lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt; fields into &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt; fields when created or modified.</source>
          <target state="translated">또한 작성하거나 수정할 때 &lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt; 필드를 &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt; 필드 로 자동 변환하는 효과도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cbad765bd9bdd743d8cd8f0dead03126b6c3e71" translate="yes" xml:space="preserve">
          <source>Also in the /var/log/mariadb/columnstore directory, there are a few other logs that are kept:</source>
          <target state="translated">또한 / var / log / mariadb / columnstore 디렉토리에는 몇 가지 다른 로그가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5446f8ac1986f8cb18a22c0b4edcbe0b643f85bf" translate="yes" xml:space="preserve">
          <source>Also make sure that the file .my.cnf doesn't exist if no password is setup.</source>
          <target state="translated">또한 비밀번호가 설정되어 있지 않으면 .my.cnf 파일이 존재하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a15eeaa8cec812e6c198fd7edf99f125cf8368f4" translate="yes" xml:space="preserve">
          <source>Also note that you might not be able to create the &lt;code&gt;''@'%'&lt;/code&gt; anonymous account by default on some systems without doing some extra steps first. See &lt;a href=&quot;../create-user/index#fixing-a-legacy-default-anonymous-account&quot;&gt;Fixing a Legacy Default Anonymous Account&lt;/a&gt; for more information.</source>
          <target state="translated">또한 일부 추가 단계를 먼저 수행하지 않으면 일부 시스템에서 기본적으로 &lt;code&gt;''@'%'&lt;/code&gt; 익명 계정 을 만들지 못할 수도 있습니다 . 자세한 내용 &lt;a href=&quot;../create-user/index#fixing-a-legacy-default-anonymous-account&quot;&gt;은 레거시 기본 익명 계정 수정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8bc995bfc8dfbf07ddfc376f1c08a6c5f9c9ada5" translate="yes" xml:space="preserve">
          <source>Also of note, MariaDB ColumnStore product also allows the user to install the RPMs and Binary packages on Amazon EC2 instances to create a system that performs like a standard hardware install. It's not required to run MariaDB ColumnStore via the use of this AMI. To do so, just follow the install instructions from the Single Serve and Multi Server install guides.</source>
          <target state="translated">또한 MariaDB ColumnStore 제품을 사용하면 Amazon EC2 인스턴스에 RPM 및 이진 패키지를 설치하여 표준 하드웨어 설치와 같은 시스템을 만들 수 있습니다. 이 AMI를 사용하여 MariaDB ColumnStore를 실행할 필요는 없습니다. 이렇게하려면 단일 서버 및 다중 서버 설치 안내서의 설치 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="1be9c7fc7e6f46731913f5caf0c5860ab7923d54" translate="yes" xml:space="preserve">
          <source>Also read groups with a suffix of &lt;em&gt;str&lt;/em&gt;. For example, &lt;code&gt;--defaults-group-suffix=x&lt;/code&gt; would read the groups [myisamchk] and [myisamchk_x]</source>
          <target state="translated">또한 접미 부가 &lt;em&gt;str 인&lt;/em&gt; 그룹을 읽습니다 . 예를 들어 &lt;code&gt;--defaults-group-suffix=x&lt;/code&gt; 는 [myisamchk] 및 [myisamchk_x] 그룹을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="81ae2d4b7210868d5a35b6100aa0b913d0f1c58e" translate="yes" xml:space="preserve">
          <source>Also read groups with a suffix of &lt;em&gt;str&lt;/em&gt;. For example, since &lt;em&gt;mysqlbinlog&lt;/em&gt; normally reads the [client] and [mysqlbinlog] groups, &lt;code&gt;--defaults-group-suffix=x&lt;/code&gt; would cause it to also read the groups [mysqlbinlog_x] and [client_x].</source>
          <target state="translated">또한 접미 부가 &lt;em&gt;str 인&lt;/em&gt; 그룹을 읽습니다 . 예를 들어, &lt;em&gt;mysqlbinlog는&lt;/em&gt; 일반적으로 [client] 및 [mysqlbinlog] 그룹 을 읽으므로 &lt;code&gt;--defaults-group-suffix=x&lt;/code&gt; 는 [mysqlbinlog_x] 및 [client_x] 그룹도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5d5f817259884d13499876281aaf5eb598554c35" translate="yes" xml:space="preserve">
          <source>Also read groups with a suffix of &lt;em&gt;str&lt;/em&gt;. For example, since &lt;em&gt;mysqldump&lt;/em&gt; normally reads the [client] and [mysqldump] groups, --defaults-group-suffix=x would cause it to also read the groups [mysqldump_x] and [client_x].</source>
          <target state="translated">또한 접미 부가 &lt;em&gt;str 인&lt;/em&gt; 그룹을 읽습니다 . 예를 들어, &lt;em&gt;mysqldump는&lt;/em&gt; 일반적으로 [client] 및 [mysqldump] 그룹을 읽으므로 --defaults-group-suffix = x는 [mysqldump_x] 및 [client_x] 그룹도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="686b0e29cff910d68d00db3bc1fbe814976c1033" translate="yes" xml:space="preserve">
          <source>Also remember that option names are case sensitive.</source>
          <target state="translated">또한 옵션 이름은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="151c8c590dabd0b69d4d47e3a964ca163481d3eb" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;../mysqld-options/index#replication-and-binary-logging-options&quot;&gt;mysqld replication options&lt;/a&gt; for related options that are not system variables (such as &lt;a href=&quot;../mysqld-options/index#-binlog-do-db&quot;&gt;binlog_do_db&lt;/a&gt; and &lt;a href=&quot;../mysqld-options/index#-binlog-ignore-db&quot;&gt;binlog_ignore_db&lt;/a&gt;).</source>
          <target state="translated">시스템 변수가 아닌 관련 옵션 (예 : &lt;a href=&quot;../mysqld-options/index#-binlog-do-db&quot;&gt;binlog_do_db&lt;/a&gt; 및 &lt;a href=&quot;../mysqld-options/index#-binlog-ignore-db&quot;&gt;binlog_ignore_db&lt;/a&gt; )에 대해서는 &lt;a href=&quot;../mysqld-options/index#replication-and-binary-logging-options&quot;&gt;mysqld 복제 옵션&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01bdb72b8a5d963a3ebd545a65b7341d0f1d2d44" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;../partitioning-types-overview/index&quot;&gt;Partitioning Types Overview&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;../partitioning-types-overview/index&quot;&gt;파티션 유형 개요를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c24b22711c7001fe5ff58bfa31831ef0d121d503" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;Full list of MariaDB options, system and status variables&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;MariaDB 옵션, 시스템 및 상태 변수&lt;/a&gt; 의 전체 목록 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="41a4072a25b7314e2ba16fb69ba3409bdd5f5c3a" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;Full list of MariaDB options, system and status variables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;MariaDB 옵션, 시스템 및 상태 변수&lt;/a&gt; 의 전체 목록 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90d3438e851e36e242d156f2066c1e021636aa37" translate="yes" xml:space="preserve">
          <source>Also supports:</source>
          <target state="translated">또한 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="c7e720fec8e30ca4c3478b58236f65d903857465" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;N&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; can be used as prefix to convert a literal into the National Character set (which in MariaDB is always utf8).</source>
          <target state="translated">또한 &lt;code&gt;N&lt;/code&gt; 또는 &lt;code&gt;n&lt;/code&gt; 을 리터럴로 사용하여 리터럴을 자국 문자 세트 (MariaDB에서는 항상 utf8 임)로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9645e833a905c7f3f8875517de282d30416cec1c" translate="yes" xml:space="preserve">
          <source>Also, REGEXP/RLIKE, and the new functions, now work correctly with all multi-byte &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character sets&lt;/a&gt; supported by MariaDB, including East-Asian character sets (big5, gb2313, gbk, eucjp, eucjpms, cp932, ujis, euckr), and Unicode character sets (utf8, utf8mb4, ucs2, utf16, utf16le, utf32). In earlier versions of MariaDB (and all MySQL versions) REGEXP/RLIKE works correctly only with 8-bit character sets.</source>
          <target state="translated">또한 REGEXP / RLIKE 및 새 기능은 이제 동아시아 문자 세트 (big5, gb2313, gbk, eucjp, eucjpms, cp932, ujis, euckr) 및 MariaDB가 지원하는 모든 멀티 바이트 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트에서&lt;/a&gt; 올바르게 작동합니다. 유니 코드 문자 집합 (utf8, utf8mb4, ucs2, utf16, utf16le, utf32). 이전 버전의 MariaDB (및 모든 MySQL 버전)에서 REGEXP / RLIKE는 8 비트 문자 세트에서만 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="89a4e83ca5192ee6fdd1463797ae837edf2495ce" translate="yes" xml:space="preserve">
          <source>Also, TODO:</source>
          <target state="translated">또한 TODO :</target>
        </trans-unit>
        <trans-unit id="b6848d9b637cb3138e1b3c9364f983c2634ae231" translate="yes" xml:space="preserve">
          <source>Also, a few &quot;bad&quot; solutions will be presented, together with why they were rejected.</source>
          <target state="translated">또한 거부 된 이유와 함께 몇 가지 &quot;나쁜&quot;솔루션이 제시됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9040bd1a09a047dd79e9ce85243af49fe1a092" translate="yes" xml:space="preserve">
          <source>Also, if the table has &lt;a href=&quot;../triggers/index&quot;&gt;INSERT triggers&lt;/a&gt; or &lt;code&gt;&lt;a href=&quot;../virtual-columns/index&quot;&gt;PERSISTENT&lt;/a&gt;&lt;/code&gt; columns, you may want to drop them, insert all data, and recreate them.</source>
          <target state="translated">또한 테이블에 &lt;a href=&quot;../triggers/index&quot;&gt;INSERT 트리거&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;../virtual-columns/index&quot;&gt;PERSISTENT&lt;/a&gt;&lt;/code&gt; 컬럼이있는 경우이를 삭제하고 모든 데이터를 삽입 한 후 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da486d794470e8297339014e66135316e45dda65" translate="yes" xml:space="preserve">
          <source>Also, long transactions can more likely result in deadlocks, but this problem is not related to the undo log.</source>
          <target state="translated">또한 긴 트랜잭션으로 인해 교착 상태가 발생할 가능성이 높지만이 문제는 실행 취소 로그와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="64363f51b1e035e94d11eacb8d113060de32350a" translate="yes" xml:space="preserve">
          <source>Also, note that as the data grows over time, random indexes will become less and less likely to be cached. That is, even if runs fine with 1 year's worth of data, it may be in trouble with 2 year's worth.</source>
          <target state="translated">또한 시간이 지남에 따라 데이터가 증가함에 따라 임의 인덱스가 캐시 될 가능성이 점점 줄어 듭니다. 즉, 1 년 분량의 데이터로 제대로 실행 되더라도 2 년 분량에 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020357116f584c68db8fe0db7600d0281928c091" translate="yes" xml:space="preserve">
          <source>Also, one can refer to values of environment variables via this group:</source>
          <target state="translated">또한이 그룹을 통해 환경 변수의 값을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="753423fbcef9c99a40c06d0bf496f595cc8a29cb" translate="yes" xml:space="preserve">
          <source>Also, parentheses are used to enclose the list of parameters to be passed to built-in functions, user-defined functions and stored routines. However, when no parameter is passed to a stored procedure, parentheses are optional. For builtin functions and user-defined functions, spaces are not allowed between the function name and the open parenthesis, unless the &lt;code&gt;IGNORE_SPACE&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is set. For stored routines (and for functions if &lt;code&gt;IGNORE_SPACE&lt;/code&gt; is set) spaces are allowed before the open parenthesis, including tab characters and new line characters.</source>
          <target state="translated">또한 괄호는 내장 함수, 사용자 정의 함수 및 저장 루틴에 전달할 매개 변수 목록을 묶는 데 사용됩니다. 그러나 저장 프로 시저에 매개 변수가 전달되지 않으면 괄호는 선택 사항입니다. 내장 함수 및 사용자 정의 함수의 경우 &lt;code&gt;IGNORE_SPACE&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 가 설정되어 있지 않으면 함수 이름과 열린 괄호 사이에 공백이 허용되지 않습니다 . 스토어드 루틴 (및 &lt;code&gt;IGNORE_SPACE&lt;/code&gt; 가 설정된 경우 함수의 경우 )에는 탭 문자 및 줄 바꾸기 문자를 포함하여 열린 괄호 앞에 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="225b8d7c798499e1f97f5cbccad41e77e9e3cf67" translate="yes" xml:space="preserve">
          <source>Also, since the PK and the data coexist:</source>
          <target state="translated">또한 PK와 데이터가 공존하기 때문에 :</target>
        </trans-unit>
        <trans-unit id="759a0ed4111d343fb3968250056fd54c5d6ccd27" translate="yes" xml:space="preserve">
          <source>Also, this function works with some other statements which return a resultset, including &lt;a href=&quot;../show/index&quot;&gt;SHOW&lt;/a&gt;, &lt;a href=&quot;../describe/index&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;../help-command/index&quot;&gt;HELP&lt;/a&gt;. For &lt;a href=&quot;../delete/index&quot;&gt;DELETE ... RETURNING&lt;/a&gt; you should use &lt;a href=&quot;../information-functions-row_count/index&quot;&gt;ROW_COUNT()&lt;/a&gt;. It also works as a &lt;a href=&quot;../prepared-statements/index&quot;&gt;prepared statement&lt;/a&gt;, or after executing a prepared statement.</source>
          <target state="translated">또한이 함수는 &lt;a href=&quot;../show/index&quot;&gt;SHOW&lt;/a&gt; , &lt;a href=&quot;../describe/index&quot;&gt;DESC&lt;/a&gt; 및 &lt;a href=&quot;../help-command/index&quot;&gt;HELP를&lt;/a&gt; 포함하여 결과 집합을 반환하는 다른 명령문과 함께 작동합니다 . 들어 &lt;a href=&quot;../delete/index&quot;&gt;DELETE ... RETURNING&lt;/a&gt; 사용한다 &lt;a href=&quot;../information-functions-row_count/index&quot;&gt;ROW_COUNT을 ()&lt;/a&gt; . 또한 &lt;a href=&quot;../prepared-statements/index&quot;&gt;준비된 명령문&lt;/a&gt; 으로 또는 준비된 명령문 을 실행 한 후 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="fce8f0daff62e1045a5d54e2edb57ce815634207" translate="yes" xml:space="preserve">
          <source>Also, views cannot be moved to another database:</source>
          <target state="translated">또한 뷰를 다른 데이터베이스로 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ce182ccadf711699d4153f03c5452ef9c302cf2" translate="yes" xml:space="preserve">
          <source>Also, you should use &quot;START TRANSACTION READONLY&quot; wherever appropriate.</source>
          <target state="translated">또한 적절한 경우 &quot;START TRANSACTION READONLY&quot;를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="972729e128dbfdf582563156391b8742db8be3dd" translate="yes" xml:space="preserve">
          <source>Alter Algorithms</source>
          <target state="translated">알고리즘 변경</target>
        </trans-unit>
        <trans-unit id="06403a7e9602f5584236c5e6e15f242b80477a98" translate="yes" xml:space="preserve">
          <source>Alter Locking Strategies</source>
          <target state="translated">잠금 전략 변경</target>
        </trans-unit>
        <trans-unit id="84a93875e3d5721eda63531bc8a8ae759ae0f728" translate="yes" xml:space="preserve">
          <source>Alter Specifications</source>
          <target state="translated">사양 변경</target>
        </trans-unit>
        <trans-unit id="17cb9a88128d54255e3014e845d372c7c981100d" translate="yes" xml:space="preserve">
          <source>Alter Table statement</source>
          <target state="translated">테이블 변경 문</target>
        </trans-unit>
        <trans-unit id="5993f8c78abd614919d8a04d9aecb874706349a2" translate="yes" xml:space="preserve">
          <source>Altering Inward tables</source>
          <target state="translated">안쪽 테이블 변경</target>
        </trans-unit>
        <trans-unit id="c6d9ed10ed3a061d1ffb30f67766859508e2dc25" translate="yes" xml:space="preserve">
          <source>Altering Stored Routines</source>
          <target state="translated">저장된 루틴 변경</target>
        </trans-unit>
        <trans-unit id="1ca07344d1b24d306a0d4f7630c5707741199b39" translate="yes" xml:space="preserve">
          <source>Altering events</source>
          <target state="translated">이벤트 변경</target>
        </trans-unit>
        <trans-unit id="25f0888a25e247b525a7287c49437f233f34e499" translate="yes" xml:space="preserve">
          <source>Altering outward tables</source>
          <target state="translated">바깥 쪽 테이블 변경</target>
        </trans-unit>
        <trans-unit id="4173fad860af399470dd79a667bd859c3189733e" translate="yes" xml:space="preserve">
          <source>Altering the User Account to Revert to the Previous Authentication Method</source>
          <target state="translated">이전 인증 방법으로 되돌 리도록 사용자 계정 변경</target>
        </trans-unit>
        <trans-unit id="9778cb9f67bf8db80eb4761f11650380160da0e6" translate="yes" xml:space="preserve">
          <source>Alternate Table Arrangement</source>
          <target state="translated">대체 테이블 배열</target>
        </trans-unit>
        <trans-unit id="2a9597aa0bb59b71a7d7e1928ec82dbf10382b65" translate="yes" xml:space="preserve">
          <source>Alternately try the tracing documented here: &lt;a href=&quot;../loading-the-connect-storage-engine/index&quot;&gt;loading-the-connect-storage-engine&lt;/a&gt;</source>
          <target state="translated">또는 여기에 설명 된 추적을 시도하십시오. &lt;a href=&quot;../loading-the-connect-storage-engine/index&quot;&gt; loading-the-connect-storage-engine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="bdd8143548c99fefde2e2ecdd482f8e96d473dc9" translate="yes" xml:space="preserve">
          <source>Alternative GUIs would be:</source>
          <target state="translated">대체 GUI는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56f54e1d2b98c2b19208d93e378f570ce2c77fb9" translate="yes" xml:space="preserve">
          <source>Alternative strategies for IN-subqueries that cannot be flattened into semi-joins</source>
          <target state="translated">세미 조인으로 병합 할 수없는 IN 서브 쿼리에 대한 대체 전략</target>
        </trans-unit>
        <trans-unit id="07dedfd692de19278dd573b42f81b517399671d5" translate="yes" xml:space="preserve">
          <source>Alternatively (or if you're using MariaDB before version 10.0.2) you specify the federated table structure explicitly:</source>
          <target state="translated">또는 버전 10.0.2 이전의 MariaDB를 사용하는 경우 연합 테이블 구조를 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="80f425482ceac466f7df32a0adf7128809c8c40b" translate="yes" xml:space="preserve">
          <source>Alternatively it is possible to specify what columns of the catalog table we want:</source>
          <target state="translated">또는 카탈로그 테이블에서 원하는 열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326dff1f84cdca33ec4cd86f8765659aceea2acf" translate="yes" xml:space="preserve">
          <source>Alternatively,</source>
          <target state="translated">Alternatively,</target>
        </trans-unit>
        <trans-unit id="d75948d09070ffa95d06fa44a580e079818bf1d8" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;../server_audit-system-variables/index#server_audit_incl_users&quot;&gt;server_audit_incl_users&lt;/a&gt; can be used to specifically include users. Both variables can be used, but if a user appears on both lists, &lt;a href=&quot;../server_audit-system-variables/index#server_audit_incl_users&quot;&gt;server_audit_incl_users&lt;/a&gt; has a higher priority, and their activities will be logged.</source>
          <target state="translated">또는 &lt;a href=&quot;../server_audit-system-variables/index#server_audit_incl_users&quot;&gt;server_audit_incl_users&lt;/a&gt; 를 사용하여 사용자를 구체적으로 포함시킬 수 있습니다. 두 변수를 모두 사용할 수 있지만 사용자가 두 목록에 모두 나타나면 &lt;a href=&quot;../server_audit-system-variables/index#server_audit_incl_users&quot;&gt;server_audit_incl_users의&lt;/a&gt; 우선 순위가 높아지고 해당 활동이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="728e8b4a99d644d1d826bd9dd1dabb13686f790e" translate="yes" xml:space="preserve">
          <source>Alternatively, a JDBC table can specify its connection options via a Federated server. For instance, supposing you have a table accessing an external Postgresql table defined as:</source>
          <target state="translated">또는 JDBC 테이블이 연합 서버를 통해 연결 옵션을 지정할 수 있습니다. 예를 들어 다음과 같이 정의 된 외부 Postgresql 테이블에 액세스하는 테이블이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dc963c9b031adfe94787a2d61b5011b7b076e646" translate="yes" xml:space="preserve">
          <source>Alternatively, a custom file location may be passed as an argument to the ColumnStoreDriver constructor. This is also necessary if you plan to write to multiple ColumnStore servers from the same host. The SDK server must be able to communicate to the ColumnStore PM servers over the standard ColumnStore TCP ports 8616, 8630, and 8800.</source>
          <target state="translated">또는 사용자 정의 파일 위치가 ColumnStoreDriver 생성자에 인수로 전달 될 수 있습니다. 동일한 호스트에서 여러 ColumnStore 서버에 쓰려는 경우에도 필요합니다. SDK 서버는 표준 ColumnStore TCP 포트 8616, 8630 및 8800을 통해 ColumnStore PM 서버와 통신 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9df2e555c98e5d2e916fea8141b8276de2bcd54b" translate="yes" xml:space="preserve">
          <source>Alternatively, install as follows:</source>
          <target state="translated">또는 다음과 같이 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="7c5b170eebc21df93e0ba15b5538f3773e170f0c" translate="yes" xml:space="preserve">
          <source>Alternatively, multiple external users could have been assigned the same user, and there would have been no way to see which actual user was responsible for which action.</source>
          <target state="translated">또는 여러 외부 사용자에게 동일한 사용자가 할당되었을 수 있으며 어떤 실제 사용자가 어떤 작업을 담당했는지 확인할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="f5b6a914397a141d51e02c137fbde41a054ccb55" translate="yes" xml:space="preserve">
          <source>Alternatively, the default connection can be changed by setting the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; system variable, and then the replication filter can be changed in the usual fashion. For example:</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 설정하여 기본 연결을 변경 한 다음 일반적인 방식으로 복제 필터를 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41ceccf8bc66aa660fb85a018a05c7d14eb858d4" translate="yes" xml:space="preserve">
          <source>Alternatively, the following will be returned:</source>
          <target state="translated">또는 다음이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="68abc2707a8ffdd497f68324a77d91c3078cd489" translate="yes" xml:space="preserve">
          <source>Alternatively, the internal source can be directly defined using the &lt;strong&gt;SrcDef&lt;/strong&gt; option that must have the proper group by format.</source>
          <target state="translated">또는 형식별로 적절한 그룹을 가져야하는 &lt;strong&gt;SrcDef&lt;/strong&gt; 옵션을 사용하여 내부 소스를 직접 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f827016f9444092298f3260db9026fc0f0fb606b" translate="yes" xml:space="preserve">
          <source>Alternatively, when looking for a value that doesn't exist, &lt;code&gt;count()&lt;/code&gt; returns 0.</source>
          <target state="translated">또는 존재하지 않는 값을 찾을 때 &lt;code&gt;count()&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9172a5cb361af36d5506fc084cc4be6e72b3d261" translate="yes" xml:space="preserve">
          <source>Alternatively, you can download a tarball from &lt;a href=&quot;http://ftp.osuosl.org/pub/mariadb/mariadb-5.5.27/cassandra-preview/&quot;&gt;http://ftp.osuosl.org/pub/mariadb/mariadb-5.5.27/cassandra-preview/&lt;/a&gt;</source>
          <target state="translated">또는 &lt;a href=&quot;http://ftp.osuosl.org/pub/mariadb/mariadb-5.5.27/cassandra-preview/&quot;&gt;http://ftp.osuosl.org/pub/mariadb/mariadb-5.5.27/cassandra-preview/&lt;/a&gt; 에서 tarball을 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66dce6cde71df975534cecb8fc88903c6f38da3f" translate="yes" xml:space="preserve">
          <source>Alternatively, you can get this information using a catalog table (see below).</source>
          <target state="translated">또는 카탈로그 테이블을 사용하여이 정보를 얻을 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="f2ea5936b428adddb88b87467b2be95882f3cdc3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set the value as follows</source>
          <target state="translated">또는 다음과 같이 값을 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="284e9f0e302b9be38b64b8c3b20873a9d12fa1ee" translate="yes" xml:space="preserve">
          <source>Alternatively, you might simply delete the &lt;code&gt;CMakeCache.txt&lt;/code&gt; file &amp;mdash; this is the file where cmake stores current build configuration &amp;mdash; and rebuild everything from scratch.</source>
          <target state="translated">또는 &lt;code&gt;CMakeCache.txt&lt;/code&gt; 파일 (cmake가 현재 빌드 구성을 저장하는 파일)을 삭제하고 모든 것을 처음부터 다시 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8836ebe6a56223cc7ef601da174819cd2ce415eb" translate="yes" xml:space="preserve">
          <source>Alternatively... Only a few searches will have too many items to count. Keep another table with the search criteria and a count. This count can be computed daily (or hourly) by some background script. When discovering that the topic is a busy one, look it up in the table to get</source>
          <target state="translated">또는 ... 몇 번의 검색 만 계산할 항목이 너무 많습니다. 검색 기준과 개수가있는 다른 테이블을 유지하십시오. 이 수는 일부 백그라운드 스크립트로 매일 (또는 매시간) 계산할 수 있습니다. 주제가 바쁜 주제임을 발견하면 표에서 찾아 주제를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c85c58dec99e5ab948d510b95570ff7548c7b434" translate="yes" xml:space="preserve">
          <source>Alternatively:</source>
          <target state="translated">Alternatively:</target>
        </trans-unit>
        <trans-unit id="76c7131c785f99c975af30ead54596dfcf700d0e" translate="yes" xml:space="preserve">
          <source>Alters the definition of a view. CREATE OR REPLACE VIEW may also be used t...</source>
          <target state="translated">뷰의 정의를 변경합니다. CREATE OR REPLACE VIEW도 사용할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="f62f88b3c8f207be8b4584f70352e5dae218ff27" translate="yes" xml:space="preserve">
          <source>Alters the definition of a view. CREATE OR REPLACE VIEW may also be used to alter the definition of a view.</source>
          <target state="translated">뷰의 정의를 변경합니다. 뷰 생성 또는 교체를 사용하여 뷰의 정의를 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06382ec9b74712caec42b98af84f98d16289a6d1" translate="yes" xml:space="preserve">
          <source>Alters the server information for server_name, adjusting the specified options as per the &lt;a href=&quot;../create-server/index&quot;&gt;CREATE SERVER&lt;/a&gt; command. The corresponding fields in the mysql.servers table are updated accordingly. This statement requires the SUPER privilege.</source>
          <target state="translated">&lt;a href=&quot;../create-server/index&quot;&gt;CREATE SERVER&lt;/a&gt; 명령에 따라 지정된 옵션을 조정하여 server_name에 대한 서버 정보를 변경합니다 . mysql.servers 테이블의 해당 필드가 그에 따라 업데이트됩니다. 이 문장에는 SUPER 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="690a186d4dd0f86205079fa97c7e85cd03e7955e" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;../subqueries/index&quot;&gt;subqueries&lt;/a&gt; are more commonly placed in a WHERE clause, they can also form part of the FROM clause. Such subqueries are commonly called derived tables.</source>
          <target state="translated">&lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리&lt;/a&gt; 는 WHERE 절에 더 일반적으로 배치 되지만 FROM 절의 일부를 구성 할 수도 있습니다. 이러한 하위 쿼리를 일반적으로 파생 테이블이라고합니다.</target>
        </trans-unit>
        <trans-unit id="04c532a61789db279af76f8f4b5382744bff3d06" translate="yes" xml:space="preserve">
          <source>Although CONNECT provides a rich set of table types, specific applications may need to access data organized in a way that is not handled by its existing foreign data wrappers (FDW). To handle these cases, CONNECT features an interface that enables developers to implement in C++ the required table wrapper and use it as if it were part of the standard CONNECT table type list. CONNECT can use these additional handlers providing the corresponding external module (dll or shared lib) be available.</source>
          <target state="translated">CONNECT는 다양한 테이블 유형 세트를 제공하지만 특정 애플리케이션은 기존 FDW (Foreign Data Wrapper)에서 처리하지 않는 방식으로 구성된 데이터에 액세스해야 할 수도 있습니다. 이러한 경우를 처리하기 위해 CONNECT는 개발자가 C ++에서 필수 테이블 랩퍼를 구현하고 표준 CONNECT 테이블 유형 목록의 일부인 것처럼 사용할 수있는 인터페이스를 제공합니다. CONNECT는 이러한 추가 핸들러를 사용하여 해당 외부 모듈 (dll 또는 공유 라이브러리)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c66ae6864c60fc42bff397900bd61e65983871" translate="yes" xml:space="preserve">
          <source>Although MariaDB considers a user as the combination of the username and hostname, the Audit Plugin logs only based on the username. MariaDB uses both the username and hostname so as to grant privileges relevant to the location of the user. Privileges are not relevant though for tracing the access to database objects. The host name is still recorded in the log, but logging is not determined based on that information.</source>
          <target state="translated">MariaDB는 사용자를 사용자 이름과 호스트 이름의 조합으로 간주하지만 감사 플러그인은 사용자 이름을 기반으로 만 기록합니다. MariaDB는 사용자 위치와 관련된 권한을 부여하기 위해 사용자 이름과 호스트 이름을 모두 사용합니다. 데이터베이스 오브젝트에 대한 액세스를 추적하는 데 특권은 관련이 없습니다. 호스트 이름은 여전히 ​​로그에 기록되지만 해당 정보를 기반으로 로깅은 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00148619b92e665f9e82611a568d7140c6194d0c" translate="yes" xml:space="preserve">
          <source>Although Sequence tables can only directly make use of positive integers, they can indirectly be used to return negative results by making use of the &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; statement. For example:</source>
          <target state="translated">시퀀스 테이블은 양의 정수만 직접 사용할 수 있지만 &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; 문 을 사용하여 음의 결과를 리턴하는 데 간접적으로 사용될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dda44d69fe873f98b78c324295b1c53787ab3f63" translate="yes" xml:space="preserve">
          <source>Although data is written twice, the doublewrite buffer does not require twice as much I/O, as data is written to the buffer in a large sequential chunk with a single fsync() call. There is extra time consumed however, and the effect becomes visible with fast storage and a heavy write load.</source>
          <target state="translated">데이터가 두 번 쓰여지지만, 단일 fsync () 호출로 큰 순차 청크에서 데이터가 버퍼에 쓰여 지므로 이중 쓰기 버퍼에는 두 배의 I / O가 필요하지 않습니다. 그러나 추가 시간이 소요되며 빠른 저장 속도와 쓰기로드가 많을 때 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b77454b2429fc57da49ec67deee5d80ca14c178a" translate="yes" xml:space="preserve">
          <source>Although date and time information can be represented in both CHAR and INTEGER data types, the DATE data type has special associated properties. For each DATE value, CONNECT can store all or only some of the following information: century, year, month, day, hour, minute, and second.</source>
          <target state="translated">날짜 및 시간 정보는 CHAR 및 INTEGER 데이터 유형으로 표시 될 수 있지만 DATE 데이터 유형에는 특수한 연관된 ​​특성이 있습니다. 각 DATE 값에 대해 CONNECT는 세기, 년, 월, 일,시, 분 및 초 정보 중 일부 또는 전부를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a6194871b333172816ccb59e0faf6380e24374" translate="yes" xml:space="preserve">
          <source>Although enabled in versions prior to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt;, the &lt;a href=&quot;../server-system-variables/index#query_cache_size&quot;&gt;query_cache_size&lt;/a&gt; is by default 0KB there, which effectively disables the query cache. From 10.1.7 on the cache size defaults to 1MB. If needed set the cache to a size large enough amount, for example:</source>
          <target state="translated">이전에 버전에서 사용할 수 있지만 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt; 의 &lt;a href=&quot;../server-system-variables/index#query_cache_size&quot;&gt;query_cache_type을이&lt;/a&gt; 효과적으로 쿼리 캐시를 비활성화가 기본 0킬로바이트,입니다. 캐시 크기는 10.1.7에서 기본적으로 1MB입니다. 필요한 경우 캐시를 충분한 크기로 설정하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="ec45c29acafa1b06fa22f42e720dfcafaf300e78" translate="yes" xml:space="preserve">
          <source>Although hardware bottlenecks often fall elsewhere, faster processors allow calculations to be performed more quickly, and the results sent back to the client more quickly. Besides processor speed, the processor's bus speed and cache size are also important factors to consider.</source>
          <target state="translated">하드웨어 병목 현상이 발생하는 경우가 많지만 프로세서가 빠를수록 계산을 더 빨리 수행 할 수 있으며 결과는 더 빠르게 클라이언트로 전송됩니다. 프로세서 속도 외에도 프로세서의 버스 속도 및 캐시 크기도 고려해야 할 중요한 요소입니다.</target>
        </trans-unit>
        <trans-unit id="6cd7fb95b909a75b9949c8a334f74b83eaf8af07" translate="yes" xml:space="preserve">
          <source>Although it is possible to change all of the variables shown above, some of them may be reset when the server restarts. Therefore, you may want set them in the configuration file (e.g., &lt;code&gt;/etc/my.cnf.d/server.cnf&lt;/code&gt;) to ensure the values are the same after a restart:</source>
          <target state="translated">위에 표시된 모든 변수를 변경할 수 있지만 서버를 다시 시작할 때 일부 변수가 재설정 될 수 있습니다. 따라서 다시 시작한 후 값이 동일 하도록 구성 파일 (예 : &lt;code&gt;/etc/my.cnf.d/server.cnf&lt;/code&gt; )에 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a38f9adda2ecdf96e6a52e86b184d1465ad19da8" translate="yes" xml:space="preserve">
          <source>Although most PAM modules usually do not do things like this, PAM supports the ability to change the user name in the process of authentication.The MariaDB &lt;code&gt;pam&lt;/code&gt; authentication plugin fully supports this feature of PAM.</source>
          <target state="translated">대부분의 PAM 모듈은 일반적으로 이와 같은 작업을 수행하지 않지만 PAM은 인증 프로세스에서 사용자 이름을 변경하는 기능을 지원합니다. MariaDB &lt;code&gt;pam&lt;/code&gt; 인증 플러그인은 PAM의이 기능을 완전히 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab75d03717490e8228e0c2e70251bbb96c10b7c4" translate="yes" xml:space="preserve">
          <source>Although mysqldump will by default preserve your resources for regular spindle disks and low-core hardware, this doesn't mean that concurrent dumps cannot benefit from hardware architecture like SAN, flash storage, low write workload. The back-up time would benefit from a tool such as MyDumper.</source>
          <target state="translated">mysqldump가 기본적으로 일반 스핀들 디스크 및 낮은 코어 하드웨어에 대한 리소스를 보존하지만 이것이 동시 덤프가 SAN, 플래시 스토리지, 낮은 쓰기 워크로드와 같은 하드웨어 아키텍처의 이점을 누릴 수 없다는 것을 의미하지는 않습니다. 백업 시간은 MyDumper와 같은 도구를 통해 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4d43be8390b62ed3ea9d6d0994ceb0ed38b6bee" translate="yes" xml:space="preserve">
          <source>Although such functions written by other parties do exist,&lt;sup id=&quot;_ref-1&quot;&gt;[&lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt;]&lt;/sup&gt; CONNECT provides its own UDFs that are specifically adapted to the JSON table type and easily available because, being inside the CONNECT library or DLL, they require no additional module to be loaded (see &lt;a href=&quot;../connect-compiling-json-udfs-in-a-separate-library/index&quot;&gt;CONNECT - Compiling JSON UDFs in a Separate Library&lt;/a&gt; to make these functions in a separate library module).</source>
          <target state="translated">다른 당사자가 작성한 이러한 기능이 존재하지만 &lt;sup id=&quot;_ref-1&quot;&gt;[ &lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt; ]&lt;/sup&gt; CONNECT는 JSON 테이블 유형에 맞게 특별히 조정되고 CONNECT 라이브러리 또는 DLL 내부에 있으므로 추가 모듈을로드 할 필요가 없기 때문에 쉽게 사용할 수있는 자체 UDF를 제공합니다. &lt;a href=&quot;../connect-compiling-json-udfs-in-a-separate-library/index&quot;&gt;연결-별도의 라이브러리에서 JSON UDF를 컴파일&lt;/a&gt; 하여 이러한 기능을 별도의 라이브러리 모듈에서 작성)</target>
        </trans-unit>
        <trans-unit id="6d7fa39e52c9629e74ce930a36a2a0532018bf58" translate="yes" xml:space="preserve">
          <source>Although the &lt;strong&gt;Galera provider&lt;/strong&gt; certifies the write set associated with a transaction at commit time on each node in the cluster, this write set is not necessarily applied on that cluster node immediately. Instead, the write set is placed in the cluster node's receive queue on the node, and it is eventually applied by one of the cluster node's Galera slave thread.</source>
          <target state="translated">&lt;strong&gt;Galera 제공자&lt;/strong&gt; 는 클러스터의 각 노드에서 커밋 시간에 트랜잭션과 연관된 쓰기 세트를 인증 하지만 이 쓰기 세트가 해당 클러스터 노드에 즉시 적용되는 것은 아닙니다. 대신 쓰기 세트는 노드의 클러스터 노드 수신 큐에 배치되며 결국 클러스터 노드의 Galera 슬레이브 스레드 중 하나에 의해 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="65285a275a0fb8a0d3b129c81d26ce1c3394610d" translate="yes" xml:space="preserve">
          <source>Although the JSON UDF&amp;rsquo;s can be nicely included in the CONNECT library module, there are cases when you may need to have them in a separate library.</source>
          <target state="translated">JSON UDF는 CONNECT 라이브러리 모듈에 훌륭하게 포함될 수 있지만 별도의 라이브러리에 있어야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5b7172265f7633160f9c544919a9dacd29c2714" translate="yes" xml:space="preserve">
          <source>Although the JSON UDFs can be nicely included in the CONNECT library module, there are cases when you may need to have them in a separate library.</source>
          <target state="translated">JSON UDF는 CONNECT 라이브러리 모듈에 훌륭하게 포함될 수 있지만 별도의 라이브러리에 있어야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f6518ab532c64221ae6b30b524e1f44df8ac5c" translate="yes" xml:space="preserve">
          <source>Although the default values for &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_facility&quot;&gt;server_audit_syslog_facility&lt;/a&gt; and &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_priority&quot;&gt;server_audit_syslog_priority&lt;/a&gt; should be sufficient in most cases, they can be changed based on the definition in &lt;code&gt;syslog.h&lt;/code&gt; for the functions &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_facility&quot;&gt;server_audit_syslog_facility&lt;/a&gt; 및 &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_priority&quot;&gt;server_audit_syslog_priority&lt;/a&gt; 의 기본값 으로 충분 &lt;code&gt;syslog.h&lt;/code&gt; &lt;code&gt;openlog()&lt;/code&gt; 및 &lt;code&gt;syslog()&lt;/code&gt; 함수에 대한 syslog.h 의 정의에 따라 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a83daa67b81285d7c2f76adce7bbce50cdd360a0" translate="yes" xml:space="preserve">
          <source>Although the discussion in this section talks about DELETE, it can be used for any other &quot;chunking&quot;, such as, say, UPDATE, or SELECT plus some complex processing.</source>
          <target state="translated">이 섹션에서는 DELETE에 대해 설명하지만 UPDATE 또는 SELECT와 복잡한 처리와 같은 다른 &quot;청크&quot;에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40f9d0e6d1ebd63935beceec7546acefae7c162" translate="yes" xml:space="preserve">
          <source>Although the field representation is always text in the table file, you can freely choose the corresponding column type, characters, date, integer or floating point according to its contents.</source>
          <target state="translated">필드 표현은 항상 테이블 파일의 텍스트이지만 내용에 따라 해당 열 유형, 문자, 날짜, 정수 또는 부동 소수점을 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eac37223f8b22cd97c42127065e872840660c5e" translate="yes" xml:space="preserve">
          <source>Although the plugin's shared library is distributed with MariaDB by default as &lt;code&gt;auth_ed25519.so&lt;/code&gt; or &lt;code&gt;auth_ed25519.dll&lt;/code&gt; depending on the operating system, the plugin is not actually installed by MariaDB by default. There are two methods that can be used to install the plugin with MariaDB.</source>
          <target state="translated">플러그인의 공유 라이브러리는 운영 체제에 따라 기본적으로 MariaDB와 &lt;code&gt;auth_ed25519.so&lt;/code&gt; 또는 &lt;code&gt;auth_ed25519.dll&lt;/code&gt; 로 배포 되지만 실제로는 기본적으로 MariaDB에 의해 플러그인이 설치되지 않습니다. MariaDB와 함께 플러그인을 설치하는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc814be3a31d6bd0d3c9bb5a3190dab41b6f91ee" translate="yes" xml:space="preserve">
          <source>Although the plugin's shared library is distributed with MariaDB by default, the plugin is not actually installed by MariaDB by default prior to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1026-release-notes/&quot;&gt;MariaDB 10.2.6&lt;/a&gt;. There are two methods that can be used to install the plugin with MariaDB.</source>
          <target state="translated">플러그인의 공유 라이브러리는 기본적으로 MariaDB와 함께 배포되지만 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1026-release-notes/&quot;&gt;MariaDB 10.2.6&lt;/a&gt; 이전에는 실제로 기본적으로 MariaDB에 의해 플러그인이 설치되지 않습니다 . MariaDB와 함께 플러그인을 설치하는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b882f45910dd60992a0549522083a2ce99e372" translate="yes" xml:space="preserve">
          <source>Although the plugin's shared library is distributed with MariaDB by default, the plugin is not actually installed by MariaDB by default. The plugin can be installed by providing the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; options. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">플러그인의 공유 라이브러리는 기본적으로 MariaDB와 함께 배포되지만 실제로 플러그인은 MariaDB에 의해 기본적으로 설치되지 않습니다. &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션 을 제공하여 플러그인을 설치할 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0863fb8f1593afb50d138b6b92558cdb7fd224a4" translate="yes" xml:space="preserve">
          <source>Although the plugin's shared library is distributed with MariaDB by default, the plugin is not actually installed by MariaDB by default. There are two methods that can be used to install the plugin with MariaDB.</source>
          <target state="translated">플러그인의 공유 라이브러리는 기본적으로 MariaDB와 함께 배포되지만 실제로 플러그인은 MariaDB에 의해 기본적으로 설치되지 않습니다. MariaDB와 함께 플러그인을 설치하는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49a9ccbd0ca3208c7b071d78214de7a52769304" translate="yes" xml:space="preserve">
          <source>Although the table is standard in the Information Schema, all but &lt;code&gt;TABLE_CATALOG&lt;/code&gt;, &lt;code&gt;TABLE_SCHEMA&lt;/code&gt;, &lt;code&gt;TABLE_NAME&lt;/code&gt;, &lt;code&gt;TABLE_TYPE&lt;/code&gt;, &lt;code&gt;ENGINE&lt;/code&gt; and &lt;code&gt;VERSION&lt;/code&gt; are MySQL and MariaDB extensions.</source>
          <target state="translated">테이블이 정보 스키마에서 표준이지만 &lt;code&gt;TABLE_CATALOG&lt;/code&gt; , &lt;code&gt;TABLE_SCHEMA&lt;/code&gt; , &lt;code&gt;TABLE_NAME&lt;/code&gt; , &lt;code&gt;TABLE_TYPE&lt;/code&gt; , &lt;code&gt;ENGINE&lt;/code&gt; 및 &lt;code&gt;VERSION&lt;/code&gt; 을 제외한 모든 테이블은 MySQL 및 MariaDB 확장입니다.</target>
        </trans-unit>
        <trans-unit id="d4976d30c1128b9dbe67ebf1300b96cb81b17285" translate="yes" xml:space="preserve">
          <source>Although the third row with an id of 3 has an id2 of 13, which also matched, it was not updated.</source>
          <target state="translated">id가 3 인 세 번째 행의 id2는 13이지만 일치하지는 않았지만 업데이트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3479a0af28b82077582c3636833019ffd09bb26b" translate="yes" xml:space="preserve">
          <source>Although the user executed only one &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statement, there are multiple entries to the log: one for each table accessed and one entry for the query on the view, (i.e., &lt;code&gt;employee_pay&lt;/code&gt;). We know primarily this is all for one query because they all have the same connection and query identification numbers (i.e., &lt;code&gt;29&lt;/code&gt; and &lt;code&gt;913&lt;/code&gt;).</source>
          <target state="translated">사용자는 하나의 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문만 실행했지만 로그에는 여러 개의 항목이 있습니다. 액세스 된 각 테이블에 대한 항목 하나와보기의 쿼리에 대한 항목 항목 ( &lt;code&gt;employee_pay&lt;/code&gt; )이 있습니다. 우리는 이것이 모두 동일한 연결 및 쿼리 식별 번호 (즉, &lt;code&gt;29&lt;/code&gt; 및 &lt;code&gt;913&lt;/code&gt; )를 갖기 때문에 하나의 쿼리에 대한 것임을 주로 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbf3ddee6a5990f5c7d7300f7fd4102e55092853" translate="yes" xml:space="preserve">
          <source>Although there are &lt;a href=&quot;../server-system-variables/index#character_set_database&quot;&gt;character_set_database&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_database&quot;&gt;collation_database&lt;/a&gt; system variables which can be set dynamically, these are used for determining the character set and collation for the default database, and should only be set by the server.</source>
          <target state="translated">동적으로 설정할 수있는 &lt;a href=&quot;../server-system-variables/index#character_set_database&quot;&gt;character_set_database&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_database&quot;&gt;collation_database&lt;/a&gt; 시스템 변수 가 있지만 기본 데이터베이스의 문자 세트 및 데이터 정렬을 판별하는 데 사용되며 서버에서만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="991a3335f2793fa504038966e6d808f18a1ba0a2" translate="yes" xml:space="preserve">
          <source>Although this will increase the size of data sent from the UM to PM to support the join, it means that the join and subsequent aggregates are pushed down, scaled out, and a smaller data set is returned back to the UM.</source>
          <target state="translated">이렇게하면 조인을 지원하기 위해 UM에서 PM으로 전송되는 데이터의 크기가 증가하지만 조인 및 후속 집계는 푸시 다운되고 확장되며 더 작은 데이터 집합이 UM으로 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1a3b804a7c4618688705bd32d908ba2585699d" translate="yes" xml:space="preserve">
          <source>Although, from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;, &lt;a href=&quot;../count/index&quot;&gt;COUNT&lt;/a&gt; can be used as a &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt;, COUNT DISTINCT cannot be.</source>
          <target state="translated">에서, 비록 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; , &lt;a href=&quot;../count/index&quot;&gt;COUNT는&lt;/a&gt; A와 사용할 수있는 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; , DISTINCT 캔되지 COUNT.</target>
        </trans-unit>
        <trans-unit id="68949ea29da8de8b4e3b5e6e81015293a7c4ac06" translate="yes" xml:space="preserve">
          <source>Always #def&lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">항상 #def &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0e8515b2ea2c25b9950a90ff40e3a517d76ee7a" translate="yes" xml:space="preserve">
          <source>Always 0 in MariaDB.</source>
          <target state="translated">MariaDB에서는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="7967d71ceddc328b85296125da36f99f0ad84ece" translate="yes" xml:space="preserve">
          <source>Always 1.</source>
          <target state="translated">항상 1.</target>
        </trans-unit>
        <trans-unit id="c373fd33021ae0c4ff0861f3892d54120aa7b514" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;NEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="add98aa9e25366c9ac8d3e890e8f9c8e98d39717" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;NONE&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;NONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38a3618eb4e3546b783bf20a87b5b4569590566d" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="313aae0e69c13bbe47802be3097508363bf9a121" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;OLD&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;OLD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea10526af2317f06421ee6134cc358e396a80f10" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;ROW&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;ROW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32975dbdccabb114997fa9e8d4c3558d9500a570" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;SQL&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;SQL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1733f8378dc767c0e847bd9aa444a999cbaa66d5" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;def&lt;/code&gt;</source>
          <target state="translated">항상 &lt;code&gt;def&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa1f9ebc32f4f8b3fcd646b5c27bb253d006ea0d" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0e91c27dd69e9784f64f785a53da1114721e3a5" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;default&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b12b2fc22ae19c78ba97a99809086e369147e704" translate="yes" xml:space="preserve">
          <source>Always &lt;code&gt;mysql&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;mysql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6853da1ffac264e13b6ea5c668a5c60bc58e814" translate="yes" xml:space="preserve">
          <source>Always contains the string 'def'.</source>
          <target state="translated">항상 문자열 'def'를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="37b0e7b9c93ec9775712f2951db70955a2f00db1" translate="yes" xml:space="preserve">
          <source>Always enabled</source>
          <target state="translated">항상 활성화</target>
        </trans-unit>
        <trans-unit id="04dfebd2517aecb97c447acbb118f6dcc0a64ac6" translate="yes" xml:space="preserve">
          <source>Always have PRIMARY KEY</source>
          <target state="translated">항상 기본 키가 있습니다</target>
        </trans-unit>
        <trans-unit id="6976edda8b2421e46b36e8085aaf5aca13e352c2" translate="yes" xml:space="preserve">
          <source>Always restart servers between tests.</source>
          <target state="translated">테스트 사이에 항상 서버를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8c221cb8324056d64ea88d84536173b8158bf8" translate="yes" xml:space="preserve">
          <source>Always use UNSIGNED and NOT NULL.</source>
          <target state="translated">항상 UNSIGNED와 NOT NULL을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d059c60be247529e65aaf9b420fbbb30647b0b70" translate="yes" xml:space="preserve">
          <source>Always uses &amp;ldquo;range&amp;rdquo; and (not full &amp;ldquo;index&amp;rdquo; scan) when it switches to an index to satisfy &lt;code&gt;ORDER BY &amp;hellip; LIMIT&lt;/code&gt; (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6657&quot;&gt;MDEV-6657&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ORDER BY &amp;hellip; LIMIT&lt;/code&gt; ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6657&quot;&gt;MDEV-6657&lt;/a&gt; ) 를 충족시키기 위해 인덱스로 전환 할 때는 항상 &quot;범위&quot;및 (전체 &quot;인덱스&quot;스캔 아님 )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8811236412b5f9834def6b56bc525b93b1588437" translate="yes" xml:space="preserve">
          <source>Am I correct in deducing (from the outside, looking in) that MariaDB's optimizations are the cause of the change?</source>
          <target state="translated">MariaDB의 최적화가 변경의 원인이라는 것을 (외부에서 들여다 보면서) 추론하는 것이 맞습니까?</target>
        </trans-unit>
        <trans-unit id="efa2d1e349c33a8eb3cc6efa480c75bf02b3d46f" translate="yes" xml:space="preserve">
          <source>Amazon AMI Certification Keys</source>
          <target state="translated">Amazon AMI 인증 키</target>
        </trans-unit>
        <trans-unit id="2ea98eec3dd76f56078953ad0ed8686d900d40bc" translate="yes" xml:space="preserve">
          <source>Amazon AMI EC2 Instance user and password setup</source>
          <target state="translated">Amazon AMI EC2 인스턴스 사용자 및 비밀번호 설정</target>
        </trans-unit>
        <trans-unit id="0a6052ed2903b1637182fda6325735a4928efb16" translate="yes" xml:space="preserve">
          <source>Amazon AWS setup and AMI Launching</source>
          <target state="translated">Amazon AWS 설정 및 AMI 시작</target>
        </trans-unit>
        <trans-unit id="725272571cc863c756fa64f3870d0cf1bf584959" translate="yes" xml:space="preserve">
          <source>Amazon AWS-CLI Tool Set</source>
          <target state="translated">Amazon AWS-CLI 도구 세트</target>
        </trans-unit>
        <trans-unit id="2c61619132921029765e9a153a30ab95426386c6" translate="yes" xml:space="preserve">
          <source>Amazon EC2 using EBS storage</source>
          <target state="translated">EBS 스토리지를 사용하는 Amazon EC2</target>
        </trans-unit>
        <trans-unit id="921c1eaec302d683bf850062ea6dd7103201251a" translate="yes" xml:space="preserve">
          <source>Amazon IAM Role</source>
          <target state="translated">아마존 IAM 역할</target>
        </trans-unit>
        <trans-unit id="e70d83f4ed276ef95cd9a3f466ca297edc8e1cb7" translate="yes" xml:space="preserve">
          <source>Amazon RDS supports using the MariaDB Audit Plugin on MySQL and MariaDB database instances.</source>
          <target state="translated">Amazon RDS는 MySQL 및 MariaDB 데이터베이스 인스턴스에서 MariaDB 감사 플러그인 사용을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4407cacc447cce8260ae996b26c79b2f8c7278e" translate="yes" xml:space="preserve">
          <source>Amazon Web Services (AWS) Key Management Service (KMS) Encryption Plugin Advanced Usage</source>
          <target state="translated">Amazon Web Services (AWS) 키 관리 서비스 (KMS) 암호화 플러그인 고급 사용법</target>
        </trans-unit>
        <trans-unit id="0660e8abcdae7154c8e7dba203c6385d4468bb1e" translate="yes" xml:space="preserve">
          <source>Amazon Web Services (AWS) Key Management Service (KMS) Encryption Plugin Setup Guide</source>
          <target state="translated">Amazon Web Services (AWS) 키 관리 서비스 (KMS) 암호화 플러그인 설정 안내서</target>
        </trans-unit>
        <trans-unit id="9ac3a79a38e837c058a4399923a637b8d3367774" translate="yes" xml:space="preserve">
          <source>Amazon's CloudTrail service creates JSON-formatted text log files for every API interaction. Enabling CloudTrail requires S3, which incurs additional fees.</source>
          <target state="translated">Amazon CloudTrail 서비스는 모든 API 상호 작용에 대해 JSON 형식의 텍스트 로그 파일을 생성합니다. CloudTrail을 활성화하려면 S3가 필요하며 추가 비용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13af62c3d4a51d224191daa9cd3ced9639bbf613" translate="yes" xml:space="preserve">
          <source>Amazon's CloudWatch service allows you to create alarms and event rules that monitor log information.</source>
          <target state="translated">Amazon CloudWatch 서비스를 사용하면 로그 정보를 모니터링하는 경보 및 이벤트 규칙을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31739f822ff5371266cf39cb36795dfb5eef9494" translate="yes" xml:space="preserve">
          <source>Among the key features users can find the following ones:</source>
          <target state="translated">주요 기능 중 사용자는 다음 기능을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9809728d6f448c2b12733918fbb0ced67c913a" translate="yes" xml:space="preserve">
          <source>Amortizing Disk Flush Costs</source>
          <target state="translated">암 스트링 디스크 플러시 비용</target>
        </trans-unit>
        <trans-unit id="43dc8532f7e57be250d7397de3d14085d51516f0" translate="yes" xml:space="preserve">
          <source>Amount</source>
          <target state="translated">Amount</target>
        </trans-unit>
        <trans-unit id="d14186f2b40b17fbb65c66d9016aec74c4d8bd9c" translate="yes" xml:space="preserve">
          <source>Amount of space in KiB available to non-root users.</source>
          <target state="translated">루트가 아닌 사용자가 사용할 수있는 KiB의 공간입니다.</target>
        </trans-unit>
        <trans-unit id="8b574f49abe5c0415dd6d39bceb2ee2b44195040" translate="yes" xml:space="preserve">
          <source>An 'owner' is an id of your choosing, but smaller is better.</source>
          <target state="translated">'소유자'는 선택의 아이디이지만, 작을수록 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62b4aa258354123059240afc1ffcd8f5f079e960" translate="yes" xml:space="preserve">
          <source>An 'uncorrelated subquery':</source>
          <target state="translated">'무관 한 하위 쿼리':</target>
        </trans-unit>
        <trans-unit id="7b6ae5e18786a1107a1774c71be40a251de652f4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; tablespace is truncated when it exceeds the maximum size that is configured for &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; tablespaces. The maximum size can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_undo_log_size&quot;&gt;innodb_max_undo_log_size&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;../innodb-undo-log/index&quot;&gt;이노 취소 로그&lt;/a&gt; 가 구성된 최대 크기를 초과 할 때 테이블이 잘린 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;이노 로그 UNDO&lt;/a&gt; 테이블을. &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_undo_log_size&quot;&gt;innodb_max_undo_log_size&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 최대 크기를 설정할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8593f23cc81b4126347793d2058406a9b4c1029" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; value (a 5-character string literal) or a MariaDB error code (a number). You should not use &lt;code&gt;SQLSTATE&lt;/code&gt; value '00000' or MariaDB error code 0, because those indicate sucess rather than an error condition. For a list of &lt;code&gt;SQLSTATE&lt;/code&gt; values and MariaDB error codes, see &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;MariaDB Error Codes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE의&lt;/a&gt; 값 (5 문자열 리터) 또는 MariaDB 에러 코드 (번호). 오류 상태가 아닌 성공을 나타내는 &lt;code&gt;SQLSTATE&lt;/code&gt; 값 '00000'또는 MariaDB 오류 코드 0을 사용하지 않아야 합니다. 목록은 &lt;code&gt;SQLSTATE&lt;/code&gt; 의 값과 MariaDB 오류 코드를 참조 &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;MariaDB 오류 코드를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b2a4773ce09dbaece579d0b263cd7c762d7e97f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; value, consisting of five characters, in this case &lt;code&gt;3D000&lt;/code&gt;. These codes are standard to ODBC and ANSI SQL. When MariaDB cannot allocate a standard SQLSTATE code, a generic &lt;code&gt;HY000&lt;/code&gt;, or general error, is used.</source>
          <target state="translated">&lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE의&lt;/a&gt; 값이 경우, 다섯 개 문자로 구성된 &lt;code&gt;3D000&lt;/code&gt; . 이 코드는 ODBC 및 ANSI SQL의 표준입니다. MariaDB가 표준 SQLSTATE 코드를 할당 할 수없는 경우 일반 &lt;code&gt;HY000&lt;/code&gt; 또는 일반 오류가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e1830aaf1fdee7695d00010f8cf3cc3d3fd8165" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;EXPLAIN EXTENDED&lt;/code&gt; will always throw a warning, as it adds extra &lt;em&gt;Message&lt;/em&gt; information to a subsequent &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; statement. This includes what the &lt;code&gt;SELECT&lt;/code&gt; query would look like after optimizing and rewriting rules are applied and how the optimizer qualifies columns and tables.</source>
          <target state="translated">는 &lt;code&gt;EXPLAIN EXTENDED&lt;/code&gt; 은 별도의 추가로 항상 경고가 발생합니다 &lt;em&gt;메시지&lt;/em&gt; 이후에 정보를 &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 문. 여기에는 최적화 및 재 작성 규칙이 적용된 후 &lt;code&gt;SELECT&lt;/code&gt; 쿼리의 모양과 옵티마이 저가 열과 테이블을 규정하는 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5fab3a1a912201ea320c6fad3ebbbd207943a0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IN&lt;/code&gt; parameter passes a value into a procedure. The procedure might modify the value, but the modification is not visible to the caller when the procedure returns. An &lt;code&gt;OUT&lt;/code&gt; parameter passes a value from the procedure back to the caller. Its initial value is NULL within the procedure, and its value is visible to the caller when the procedure returns. An &lt;code&gt;INOUT&lt;/code&gt; parameter is initialized by the caller, can be modified by the procedure, and any change made by the procedure is visible to the caller when the procedure returns.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 의 매개 변수는 절차에 값을 전달합니다. 프로시 저는 값을 수정할 수 있지만 프로 시저가 리턴되면 호출자에게 수정 사항이 표시되지 않습니다. &lt;code&gt;OUT&lt;/code&gt; 의 파라미터는 호출자에게 다시 절차에서 값을 전달한다. 프로 시저 내에서 초기 값은 NULL이며 프로 시저가 리턴되면 호출자에게 값이 표시됩니다. &lt;code&gt;INOUT&lt;/code&gt; 의 파라미터는 호출자에 의해 초기화 절차에 의해 수정하고, 절차에 의해 이루어진 모든 변경 사항은 호출 프로 시저 리턴에 표시 할 수있다.</target>
        </trans-unit>
        <trans-unit id="f1352bd35c23a33aa59c04ebaf4eb6fca00ea389" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ON SCHEDULE&lt;/code&gt; clause, which determines when and how often the event executes.</source>
          <target state="translated">&lt;code&gt;ON SCHEDULE&lt;/code&gt; 결정시기와 빈도 이벤트가 실행 절.</target>
        </trans-unit>
        <trans-unit id="e9a08356327bccefbeb253de82ef72860faf5c01" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;is_default()&lt;/code&gt; method returns 1 if this particular suite should be run by default, when the &lt;code&gt;mysql-test-run.pl&lt;/code&gt; script is run without explicitly specified test suites or test cases.</source>
          <target state="translated">&lt;code&gt;is_default()&lt;/code&gt; 이 특정 제품군은 기본적으로 실행해야하는지 방법은 1을 반환 &lt;code&gt;mysql-test-run.pl&lt;/code&gt; 스크립트가 명시 적으로 지정된 테스트 스위트 또는 테스트 케이스없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2402f49e712a6291f05ba85d7a17159d4058d7da" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;intention exclusive lock&lt;/em&gt;(IX) indicates that a transaction intends to set an exclusive lock.</source>
          <target state="translated">&lt;em&gt;의도 배타 잠금&lt;/em&gt; (IX)는 트랜잭션이 배타적 잠금을 설정하려는 의도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b49025e75e5ea5512735d4cd5e97e902fa951d23" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;intention shared lock&lt;/em&gt;(IS) indicates that a transaction intends to set a shared lock.</source>
          <target state="translated">&lt;em&gt;의도 공유 잠금&lt;/em&gt; (IS) 트랜잭션이 공유 잠금을 설정할 수 있다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3126fe2dc03b8226c1b4cc3fce629a8f251c0296" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;unsafe&lt;/em&gt; workaround is to disable &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt;. &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; can be disabled by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;안전하지 않은&lt;/em&gt; 해결 방법은 비활성화하는 것입니다 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;이노 엄격 모드&lt;/a&gt; . &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;OFF&lt;/code&gt; 로 설정하여 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB 엄격 모드&lt;/a&gt; 를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58e5c382691a020140573fc24f79965c1168e50b" translate="yes" xml:space="preserve">
          <source>An AUTO_INCREMENT column normally has missing values. This happens because if a row is deleted, or an AUTO_INCREMENT value is explicitly updated, old values are never re-used. The REPLACE statement also deletes a row, and its value is wasted. With InnoDB, values can be reserved by a transaction; but if the transaction fails (for example, because of a ROLLBACK) the reserved value will be lost.</source>
          <target state="translated">AUTO_INCREMENT 열에는 일반적으로 결 측값이 있습니다. 행이 삭제되거나 AUTO_INCREMENT 값이 명시 적으로 업데이트 된 경우 이전 값이 다시 사용되지 않기 때문에 이러한 문제가 발생합니다. REPLACE 문은 또한 행을 삭제하고 해당 값이 낭비됩니다. InnoDB를 사용하면 트랜잭션에서 값을 예약 할 수 있습니다. 그러나 트랜잭션이 실패하면 (예 : ROLLBACK으로 인해) 예약 된 값이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="38ac4e774ae1f864356fabe77c90146bb2b310e4" translate="yes" xml:space="preserve">
          <source>An Aria table consists of 3 files:</source>
          <target state="translated">Aria 테이블은 3 개의 파일로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f59bc9648cc34ca20ad36ad4b2f505b084456aba" translate="yes" xml:space="preserve">
          <source>An ENUM can also contain NULL and empty values. If the ENUM column is declared to permit NULL values, NULL becomes a valid value, as well as the default value (see below). If &lt;a href=&quot;../sql_mode/index&quot;&gt;strict SQL Mode&lt;/a&gt; is not enabled, and an invalid value is inserted into an ENUM, a special empty string, with an index value of zero (see Numeric index, below), is inserted, with a warning. This may be confusing, because the empty string is also a possible value, and the only difference if that in this case its index is not 0. Inserting will fail with an error if strict mode is active.</source>
          <target state="translated">ENUM은 NULL 및 빈 값도 포함 할 수 있습니다. ENUM 열이 NULL 값을 허용하도록 선언 된 경우 NULL은 기본값뿐만 아니라 유효한 값이됩니다 (아래 참조). 경우 &lt;a href=&quot;../sql_mode/index&quot;&gt;엄격한 SQL 모드&lt;/a&gt; 를 사용할 수 없습니다, 그리고 잘못된 값이 열거에 삽입 제로의 인덱스 값과 특별한 빈 문자열은 경고와 함께, 삽입, (아래 숫자 인덱스를 참조). 빈 문자열도 가능한 값이므로이 경우 색인이 0이 아닌 유일한 차이점이므로 혼동 될 수 있습니다. 엄격 모드가 활성화 된 경우 오류가 발생하여 삽입이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="df32365935293592edc5b4b58cd4fa83731672c8" translate="yes" xml:space="preserve">
          <source>An ENUM defined as ENUM('apple','orange','pear') would have the following index values:</source>
          <target state="translated">ENUM ( 'apple', 'orange', 'pear')으로 정의 된 ENUM은 다음 색인 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="322a090ab99bfa5b954eab2b2e648d90d713e79d" translate="yes" xml:space="preserve">
          <source>An Efficient Way to Give Someone Else Access to a Read Only Table</source>
          <target state="translated">다른 사람에게 읽기 전용 테이블에 대한 액세스 권한을 부여하는 효율적인 방법</target>
        </trans-unit>
        <trans-unit id="e6d1d6809b9ff41d4e83dda8143a458db2d986df" translate="yes" xml:space="preserve">
          <source>An IN predicate may produce a NULL result if there is a NULL value in either of its arguments. Depending on its location in a query, a NULL predicate value is equivalent to FALSE. These are the cases when substituting NULL with FALSE would reject exactly the same result rows. A NULL result of IN is indistinguishable from a FALSE if the IN predicate is:</source>
          <target state="translated">IN 술어는 인수 중 하나에 NULL 값이 있으면 NULL 결과를 생성 할 수 있습니다. 쿼리에서의 위치에 따라 NULL 술어 값은 FALSE와 같습니다. NULL을 FALSE로 대체하면 정확히 동일한 결과 행이 거부되는 경우가 있습니다. IN 술어가 다음과 같은 경우 IN의 NULL 결과는 FALSE와 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85089faaa7b8d29c50a5349890d549700b0ba98d" translate="yes" xml:space="preserve">
          <source>An IN subquery cannot be flattened into a semi-join in the following cases. The examples below use the &lt;em&gt;World&lt;/em&gt; database from the MariaDB regression test suite.</source>
          <target state="translated">다음과 같은 경우 IN 하위 쿼리를 세미 조인으로 병합 할 수 없습니다. 아래 예제 는 MariaDB 회귀 테스트 스위트 의 &lt;em&gt;World&lt;/em&gt; 데이터베이스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="55e9b10fbc4d99211b85f2fa21600b91af551b2d" translate="yes" xml:space="preserve">
          <source>An IS lock is not granted if an X lock is held. It is granted if an S, IX or IS lock is held.</source>
          <target state="translated">X 잠금이 유지되면 IS 잠금이 부여되지 않습니다. S, IX 또는 IS 잠금이 유지되면 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="98970add29c4095a7e5011d3d758b28b2500ea18" translate="yes" xml:space="preserve">
          <source>An IX lock is not granted if in X or S lock is held. It is granted if an IX or IS lock is held.</source>
          <target state="translated">X 또는 S 잠금이 유지되면 IX 잠금이 부여되지 않습니다. IX 또는 IS 잠금이 유지되면 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="94caa22801cd1f8693eec5d01055457039538771" translate="yes" xml:space="preserve">
          <source>An InnoDB table that uses the &lt;code&gt;COMPRESSED&lt;/code&gt; row format can be created by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;COMPRESSED&lt;/code&gt; and by setting the &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; table option to one of the following values in a &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, where the units are in &lt;code&gt;KB&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;COMPRESSED&lt;/code&gt; 행 형식 을 사용하는 InnoDB 테이블 은 &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;COMPRESSED&lt;/code&gt; 로 설정하고 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 에서 &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 다음 값 중 하나로 설정하여 작성할 수 있습니다 ( 단위는 &lt;code&gt;KB&lt;/code&gt; 임) .</target>
        </trans-unit>
        <trans-unit id="76355769df8ad53d34803172d3fc28b919ce3e76" translate="yes" xml:space="preserve">
          <source>An InnoDB table's clustered index has three hidden system columns that are automatically generated. These hidden system columns are:</source>
          <target state="translated">InnoDB 테이블의 클러스터형 인덱스에는 자동으로 생성되는 3 개의 숨겨진 시스템 열이 있습니다. 이 숨겨진 시스템 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3cf25762882310e2941e21ec8000546ed8e5c22" translate="yes" xml:space="preserve">
          <source>An MPP Query Engine for MariaDB and MySQL</source>
          <target state="translated">MariaDB 및 MySQL 용 MPP 쿼리 엔진</target>
        </trans-unit>
        <trans-unit id="9fded0251be6b2a7a44fce36cf0f5dab39bc6c39" translate="yes" xml:space="preserve">
          <source>An OEM Table Example</source>
          <target state="translated">OEM 테이블 예</target>
        </trans-unit>
        <trans-unit id="2738f8bb0fe3589e509eec486f43f91bd0eaf3d4" translate="yes" xml:space="preserve">
          <source>An S lock is not granted if an X or IX lock is held. It is granted if an S or IS lock is held.</source>
          <target state="translated">X 또는 IX 잠금이 유지되면 S 잠금이 부여되지 않습니다. S 또는 IS 잠금이 유지되면 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="2226f07237c6a0e1c3594695263c61a44288e742" translate="yes" xml:space="preserve">
          <source>An SST failure generally renders the joiner node unusable. Therefore, when an SST failure is detected, the joiner node will abort.</source>
          <target state="translated">SST 실패는 일반적으로 결합 자 노드를 사용할 수 없게합니다. 따라서 SST 실패가 감지되면 결합 자 노드가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="63aa785fea99ca9d0d23891fe8d1acb066df68fe" translate="yes" xml:space="preserve">
          <source>An X lock is not granted if any other lock (X, S, IX, IS) is held.</source>
          <target state="translated">다른 잠금 (X, S, IX, IS)이 있으면 X 잠금이 부여되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cc6649443bc99a8a21d1add7a2bf8d13e3c4d82" translate="yes" xml:space="preserve">
          <source>An additional source of speedup is this property: if there are multiple records in &lt;code&gt;t1&lt;/code&gt; that have the same value of &lt;code&gt;t1.col1&lt;/code&gt;, then regular Nested-Loops join will make multiple index lookups for the same value of &lt;code&gt;t2.key1=t1.col1&lt;/code&gt;. The lookups may or may not hit the cache, depending on how big the join is. With Batched Key Access and Multi-Range Read, no duplicate index lookups will be made.</source>
          <target state="translated">&lt;code&gt;t1.col1&lt;/code&gt; 값이 동일한 여러 레코드가 &lt;code&gt;t1&lt;/code&gt; 에있는 경우 일반 중첩 중첩 조인은 동일한 값 &lt;code&gt;t2.key1=t1.col1&lt;/code&gt; 에 대해 여러 인덱스 조회를 수행합니다 . 조인의 크기에 따라 조회가 캐시에 충돌 할 수도 있고 그렇지 않을 수도 있습니다. 배치 키 액세스 및 다중 범위 읽기를 사용하면 중복 인덱스 조회가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="939bef838978282888623c685c6c5141bb782daa" translate="yes" xml:space="preserve">
          <source>An advantage of &quot;Batched Normalization&quot; is that you can summarize directly from the Staging table. Two approaches:</source>
          <target state="translated">&quot;일괄 정규화&quot;의 이점은 준비 테이블에서 직접 요약 할 수 있다는 것입니다. 두 가지 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="58fff696a73ca1e8d4137d66e60af854590059c6" translate="yes" xml:space="preserve">
          <source>An aggregate function, such as &lt;a href=&quot;../max/index&quot;&gt;MAX()&lt;/a&gt;, &lt;a href=&quot;../min/index&quot;&gt;MIN()&lt;/a&gt;, &lt;a href=&quot;../sum/index&quot;&gt;SUM()&lt;/a&gt; or &lt;a href=&quot;../count/index&quot;&gt;COUNT()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../max/index&quot;&gt;MAX ()&lt;/a&gt; , &lt;a href=&quot;../min/index&quot;&gt;MIN ()&lt;/a&gt; , &lt;a href=&quot;../sum/index&quot;&gt;SUM ()&lt;/a&gt; 또는 &lt;a href=&quot;../count/index&quot;&gt;COUNT ()&lt;/a&gt; 와 같은 집계 함수</target>
        </trans-unit>
        <trans-unit id="9e6165772668023fdd950cb58f9037e0193f1b83" translate="yes" xml:space="preserve">
          <source>An alternate format, which is the format of exported MongoDB files, is a file where each row is physically stored in one file record. For instance:</source>
          <target state="translated">내 보낸 MongoDB 파일의 형식 인 대체 형식은 각 행이 실제로 하나의 파일 레코드에 저장되는 파일입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5ae69122e2c9156298783be82e439ec019540d81" translate="yes" xml:space="preserve">
          <source>An alternative approach to synchronous replication that uses Group Communication and transaction ordering techniques was suggested by a number of researchers. For example:</source>
          <target state="translated">그룹 통신 및 트랜잭션 순서 지정 기술을 사용하는 동기식 복제에 대한 다른 접근 방식이 여러 연구원에 의해 제안되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a21aca2a4c7ca453f064b3c359d18945c6d52bf" translate="yes" xml:space="preserve">
          <source>An alternative definition with MAXVALUE as a catchall:</source>
          <target state="translated">MAXVALUE를 포괄으로 사용하는 대체 정의 :</target>
        </trans-unit>
        <trans-unit id="4cb3a5b1cc8ce52b7058dd4b32d90644e03eac26" translate="yes" xml:space="preserve">
          <source>An alternative solution is to set the soft and hard limits for the user account that runs Mariabackup by adding new limits to &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/limits.conf&quot;&gt;/etc/security/limits.conf&lt;/a&gt;&lt;/code&gt;. For example, if Mariabackup is run by the &lt;code&gt;mysql&lt;/code&gt; user, then you could add lines like the following:</source>
          <target state="translated">다른 해결책은 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/limits.conf&quot;&gt;/etc/security/limits.conf&lt;/a&gt;&lt;/code&gt; 에 새 제한을 추가하여 Mariabackup을 실행하는 사용자 계정에 대한 소프트 및 하드 제한을 설정하는 것 입니다. 예를 들어, &lt;code&gt;mysql&lt;/code&gt; 사용자 가 Mariabackup을 실행하는 경우 다음과 같은 행을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f58a5ee3acf27b73288421be8d17241cbaff0d7" translate="yes" xml:space="preserve">
          <source>An alternative to specify the hexadecimal value of a character. For example, the following syntax works on any platform:</source>
          <target state="translated">문자의 16 진 값을 지정하는 대안. 예를 들어 다음 구문은 모든 플랫폼에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54a6f48f038b5b967644191fead387b46a5ee2ac" translate="yes" xml:space="preserve">
          <source>An array of Array. Like this one.</source>
          <target state="translated">Array의 배열입니다. 이 같은.</target>
        </trans-unit>
        <trans-unit id="a17bddd3fea6499c0be789d92f4e353504386fec" translate="yes" xml:space="preserve">
          <source>An array of objects. This is the default.</source>
          <target state="translated">객체의 배열. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b04af0019103076b4d7469f967d548aa57575ece" translate="yes" xml:space="preserve">
          <source>An array of values.</source>
          <target state="translated">값의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7ff0b437eaf52edc283226c0fc3daf6baf81f9bb" translate="yes" xml:space="preserve">
          <source>An assertion specifies a certain condition that must match at a particular point, but without consuming characters from the subject string. In addition to the standard POSIX simple assertions &lt;code&gt;^&lt;/code&gt; (that matches at the beginning of a line) and &lt;code&gt;$&lt;/code&gt; (that matches at the end of a line), PCRE supports a number of other assertions:</source>
          <target state="translated">어설 션은 특정 지점에서 일치해야하지만 제목 문자열에서 문자를 소비하지 않는 특정 조건을 지정합니다. PCRE는 표준 POSIX 단순 어설 션 &lt;code&gt;^&lt;/code&gt; (줄의 시작 부분과 일치) 및 &lt;code&gt;$&lt;/code&gt; (줄의 끝과 일치) 외에도 여러 가지 다른 어설 션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="10d250fc6d457bb7841d160b7f5bc36967acc91d" translate="yes" xml:space="preserve">
          <source>An associated status variable, &lt;code&gt;&lt;a href=&quot;../server-status-variables/index#max_statement_time_exceeded&quot;&gt;max_statement_time_exceeded&lt;/a&gt;&lt;/code&gt;, stores the number of queries that have exceeded the execution time specified by &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time&lt;/a&gt;&lt;/code&gt;, and a &lt;code&gt;MAX_STATEMENT_TIME_EXCEEDED&lt;/code&gt; column was added to the &lt;code&gt;&lt;a href=&quot;../information-schema-client_statistics-table/index&quot;&gt;CLIENT_STATISTICS&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../information-schema-user_statistics-table/index&quot;&gt;USER STATISTICS&lt;/a&gt;&lt;/code&gt; Information Schema tables.</source>
          <target state="translated">연관된 상태 변수, &lt;code&gt;&lt;a href=&quot;../server-status-variables/index#max_statement_time_exceeded&quot;&gt;max_statement_time_exceeded&lt;/a&gt;&lt;/code&gt; 는 , 점포에 의해 특정 실행 시간 초과 쿼리 수 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time&lt;/a&gt;&lt;/code&gt; 을 하고 &lt;code&gt;MAX_STATEMENT_TIME_EXCEEDED&lt;/code&gt; 열에 가하고 &lt;code&gt;&lt;a href=&quot;../information-schema-client_statistics-table/index&quot;&gt;CLIENT_STATISTICS&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../information-schema-user_statistics-table/index&quot;&gt;USER STATISTICS&lt;/a&gt;&lt;/code&gt; 정보 스키마 테이블.</target>
        </trans-unit>
        <trans-unit id="75a2c0099e26a0822bc6630bda2b2133b7302c3e" translate="yes" xml:space="preserve">
          <source>An atomic group which ends with a quantifier can be rewritten using a so called &quot;possessive quantifier&quot; syntax by putting an additional &lt;code&gt;+&lt;/code&gt; sign following the quantifier.</source>
          <target state="translated">양자화기로 끝나는 원자 그룹 은 양자화 기 뒤에 추가 &lt;code&gt;+&lt;/code&gt; 부호를 넣어 소위 &quot;포지 셔 티브 양자화&quot;구문을 사용하여 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef40019f718f639f0df60690df649d9d057328e0" translate="yes" xml:space="preserve">
          <source>An attacker gains access to the system and copies the database files to avoid the MariaDB authorization check.</source>
          <target state="translated">공격자는 시스템에 액세스하여 MariaDB 권한 검사를 피하기 위해 데이터베이스 파일을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="733d688926b7f175e9e7d6f0e87adb7c97fecc29" translate="yes" xml:space="preserve">
          <source>An attempt was made to binlog GTID %u-%u-%llu which would create an out-of-order sequence number with existing GTID %u-%u-%llu, and gtid strict mode is enabled.</source>
          <target state="translated">기존 GTID % u- % u- % llu로 순서가 잘못된 순서 번호를 생성하는 GTID % u- % u- % llu를 binlog하려고 시도했으며 gtid 엄격 모드가 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="31c719ec0b7f2eda456eb2b344a8e07bda4d8984" translate="yes" xml:space="preserve">
          <source>An attribute list to be added to the header row node.</source>
          <target state="translated">헤더 행 노드에 추가 할 속성 목록.</target>
        </trans-unit>
        <trans-unit id="0935cbd50cd3aa115281574b91c728f9643c057f" translate="yes" xml:space="preserve">
          <source>An easy way to avoid this is by increasing the value of the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_time&quot;&gt;innodb_old_blocks_time&lt;/a&gt; system variable. It represents the number of milliseconds that must pass before a recently accessed page can be put into the &quot;new&quot; sublist in the buffer pool. Data which is accessed only once should remain in the &quot;old&quot; sublist. This means that they will soon be evicted from the buffer pool. Since during the backup process the &quot;old&quot; sublist is likely to store data that is not useful, one could also consider resizing it by changing the value of the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_pct&quot;&gt;innodb_old_blocks_pct&lt;/a&gt; system variable.</source>
          <target state="translated">이를 피하는 쉬운 방법은 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_time&quot;&gt;innodb_old_blocks_time&lt;/a&gt; 시스템 변수 의 값을 늘리는 것 입니다. 최근에 액세스 한 페이지를 버퍼 풀의 &quot;새&quot;서브리스트에 넣기 전에 경과해야하는 시간 (밀리 초)을 나타냅니다. 한 번만 액세스되는 데이터는 &quot;이전&quot;하위 목록에 남아 있어야합니다. 이는 곧 버퍼 풀에서 제거 될 것임을 의미합니다. 백업 프로세스 중에 &quot;이전&quot;서브리스트는 유용하지 않은 데이터를 저장할 가능성이 있으므로 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_pct&quot;&gt;innodb_old_blocks_pct&lt;/a&gt; 시스템 변수 의 값을 변경하여 크기를 조정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3bfbd594a6509a5cd579d50f5154cbc05c734ee" translate="yes" xml:space="preserve">
          <source>An engine has a new storage format</source>
          <target state="translated">엔진에 새로운 저장 형식이 있습니다</target>
        </trans-unit>
        <trans-unit id="2aa47882e87067e17623e9439e356732ed956b07" translate="yes" xml:space="preserve">
          <source>An enumeration. A string object that can have only one value, chosen from the list of values 'value1', 'value2', ..., NULL or the special '' error value. In theory, an &lt;code&gt;ENUM&lt;/code&gt; column can have a maximum of 65,535 distinct values; in practice, the real maximum depends on many factors. &lt;code&gt;ENUM&lt;/code&gt; values are represented internally as integers.</source>
          <target state="translated">열거. 값 목록 'value1', 'value2', ..., NULL 또는 특수 ''오류 값에서 선택한 값이 하나만있는 문자열 객체입니다. 이론적으로 &lt;code&gt;ENUM&lt;/code&gt; 열은 최대 65,535 개의 고유 값을 가질 수 있습니다. 실제로 실제 최대 값은 여러 요인에 따라 다릅니다. &lt;code&gt;ENUM&lt;/code&gt; 값은 내부적으로 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cbb99cb4efa5ddbaae4f25da735b5794f4ffa431" translate="yes" xml:space="preserve">
          <source>An equal sign.</source>
          <target state="translated">등호.</target>
        </trans-unit>
        <trans-unit id="5fcff7f487280733d9ce31407386624984ba37cb" translate="yes" xml:space="preserve">
          <source>An error occurs if any of the arguments are not valid JSON documents.</source>
          <target state="translated">인수 중 하나가 유효한 JSON 문서가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d00cbd4f90252c940aec799a7b92f3fc9ba4081" translate="yes" xml:space="preserve">
          <source>An error that is handled by a &lt;code&gt;DECLARE HANDLER&lt;/code&gt; construct can be issued again using the &lt;a href=&quot;../resignal/index&quot;&gt;RESIGNAL&lt;/a&gt; statement.</source>
          <target state="translated">&lt;code&gt;DECLARE HANDLER&lt;/code&gt; 구문에 의해 처리되는 오류 는 &lt;a href=&quot;../resignal/index&quot;&gt;RESIGNAL&lt;/a&gt; 문을 사용하여 다시 발행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a14e83b22762497ea77ffd696eb5322181ba94f9" translate="yes" xml:space="preserve">
          <source>An error will occur if JSON document is invalid, the path is invalid or if the path contains a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; wildcard.</source>
          <target state="translated">JSON 문서가 유효하지 않거나 경로가 유효하지 않거나 경로에 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;**&lt;/code&gt; 와일드 카드 가 포함되어 있으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4d7857a94a95358ff4d6a32af2228bd1e9329e77" translate="yes" xml:space="preserve">
          <source>An error will occur if any path argument is not a valid path, or if the json_doc argument is not a valid JSON document.</source>
          <target state="translated">경로 인수가 유효한 경로가 아니거나 json_doc 인수가 유효한 JSON 문서가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b038b0be56dc516ee8ff6d3bacc788e9e5ba9ec" translate="yes" xml:space="preserve">
          <source>An error will occur if the JSON document is invalid, the path is invalid or if the path contains a * or &lt;strong&gt; wildcard.&lt;/strong&gt;</source>
          <target state="translated">JSON 문서가 유효하지 않거나 경로가 유효하지 않거나 경로에 * 또는 &lt;strong&gt;와일드 카드&lt;/strong&gt; 가 포함되어 있으면 오류가 발생합니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fed894caad99163d66e6464cd11b26e73c8ea606" translate="yes" xml:space="preserve">
          <source>An error will occur if the JSON document is invalid, the path is invalid or if the path contains a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; wildcard.</source>
          <target state="translated">JSON 문서가 유효하지 않거나 경로가 유효하지 않거나 경로에 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;**&lt;/code&gt; 와일드 카드 가 포함되어 있으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a45c532992480c3ab1e780fecccd20563acddc17" translate="yes" xml:space="preserve">
          <source>An error will occur if the JSON document is not invalid, or if any of the paths are invalid or contain a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; wildcard.</source>
          <target state="translated">JSON 문서가 유효하지 않거나 경로가 유효하지 않거나 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;**&lt;/code&gt; 와일드 카드를 포함하는 경우 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="feb24e728f17c06458c52e995c9e884e7c2b7914" translate="yes" xml:space="preserve">
          <source>An error will occur if the argument is an invalid JSON value.</source>
          <target state="translated">인수가 유효하지 않은 JSON 값인 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32a279cbc66fbcb624a51f671c62c2f92e904ade" translate="yes" xml:space="preserve">
          <source>An error will occur if the given value begins and ends with double quotes and is an invalid JSON string literal.</source>
          <target state="translated">주어진 값이 큰 따옴표로 시작하고 끝나고 유효하지 않은 JSON 문자열 리터럴 인 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52285437cc88b0ab92e2463d83ffe4eb83ff1af4" translate="yes" xml:space="preserve">
          <source>An error will occur if there are an odd number of arguments, or any key name is NULL.</source>
          <target state="translated">홀수 개의 인수가 있거나 키 이름이 NULL이면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6bf7cd6a2d16b053fd3bf1221a4489efd5d4db1c" translate="yes" xml:space="preserve">
          <source>An estimate of how many rows we will find in the table for each key lookup.</source>
          <target state="translated">각 키 조회에 대해 표에서 찾을 행 수의 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="cde6a6e90e5a7bc27bf86115335b6099ed14c5c0" translate="yes" xml:space="preserve">
          <source>An event can be changed with the &lt;a href=&quot;../alter-event/index&quot;&gt;ALTER EVENT&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../alter-event/index&quot;&gt;ALTER EVENT&lt;/a&gt; 문으로 이벤트를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0adc0a80fd5ad3bfd99ae674839576c524def71f" translate="yes" xml:space="preserve">
          <source>An event has been read from the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;, and is now being sent to the slave.</source>
          <target state="translated">&lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 에서 이벤트를 읽었으며 이제 슬레이브로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="68fb72e0808b1235d84eb63675abd4f54a204ffa" translate="yes" xml:space="preserve">
          <source>An event that will be triggered tomorrow at a certain time:</source>
          <target state="translated">내일 특정 시간에 트리거되는 이벤트 :</target>
        </trans-unit>
        <trans-unit id="4919a5f4569f0a47569f79983f60bf2c0d456a47" translate="yes" xml:space="preserve">
          <source>An eventual &amp;lsquo;*&amp;rsquo; indicating this is column correspond to an aggregate function.</source>
          <target state="translated">이것을 나타내는 열 '*'는 집계 함수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b02d33ec722284e9fc32b208e6acad9c85a925d0" translate="yes" xml:space="preserve">
          <source>An eventual description of what is met after the column value (not valid is &lt;code&gt;%m&lt;/code&gt; was used).</source>
          <target state="translated">열 값 이후에 충족되는 사항에 대한 최종 설명입니다 (유효하지 않은 &lt;code&gt;%m&lt;/code&gt; 이 사용되었습니다).</target>
        </trans-unit>
        <trans-unit id="905d93af8c031280f0b593b9d5c34a8ca84d5e2c" translate="yes" xml:space="preserve">
          <source>An eventual description of what is met and ignored before the column value.</source>
          <target state="translated">열 값 전에 충족되고 무시되는 사항에 대한 최종 설명입니다.</target>
        </trans-unit>
        <trans-unit id="cf9c30a2e1ba8612281f4183b1d03672c81b6f17" translate="yes" xml:space="preserve">
          <source>An example for &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; using &lt;code&gt;cursor%ROWTYPE&lt;/code&gt; variables as &lt;code&gt;SELECT..INTO&lt;/code&gt; targets:</source>
          <target state="translated">&lt;code&gt;cursor%ROWTYPE&lt;/code&gt; 변수를 &lt;code&gt;SELECT..INTO&lt;/code&gt; 로 사용 하는 &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; 의 예 대상 :</target>
        </trans-unit>
        <trans-unit id="2d19e4d79e153d05a1365be9df123b312360583f" translate="yes" xml:space="preserve">
          <source>An example for &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; using &lt;code&gt;table%ROWTYPE&lt;/code&gt; variables as &lt;code&gt;SELECT..INTO&lt;/code&gt; targets:</source>
          <target state="translated">&lt;code&gt;SELECT..INTO&lt;/code&gt; 대상 으로 &lt;code&gt;table%ROWTYPE&lt;/code&gt; 변수를 사용 하는 &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="be6ed4fc3804eb3577cb3298f80e2354d89d3610" translate="yes" xml:space="preserve">
          <source>An example group by query using aggregate functions is:</source>
          <target state="translated">집계 함수를 사용하는 쿼리 별 그룹 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d86786828ee896c5cf85671b616a2335dbf27913" translate="yes" xml:space="preserve">
          <source>An example of a connect string specifying all the connection parameters would be:</source>
          <target state="translated">모든 연결 매개 변수를 지정하는 연결 문자열의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ed699f29c1ad2d5c1a02e525e7112cb980e60fd" translate="yes" xml:space="preserve">
          <source>An example of a generic table definition, which contains some of the most common table_options used in CONNECT Table_Type=CSV Engine when dealing with Zipped File Tables, would be as follows:</source>
          <target state="translated">압축 파일 테이블을 처리 할 때 CONNECT Table_Type = CSV 엔진에서 사용되는 가장 일반적인 table_options를 포함하는 일반 테이블 정의의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18a9fdc0c2ed9ca6f8c4473cb4baea780aa1787a" translate="yes" xml:space="preserve">
          <source>An example of an ORDER BY that does not quite work: Assume there are multiple rows for each 'date':</source>
          <target state="translated">제대로 작동하지 않는 ORDER BY의 예 : 각 '날짜'에 대해 여러 행이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f28ded98b87174c21b08fc8b28e43bfba8efaa63" translate="yes" xml:space="preserve">
          <source>An example of an error code is as follows:</source>
          <target state="translated">오류 코드의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cd49c9fd8558c4f1d79de1ccb3c9686fc0b04d0" translate="yes" xml:space="preserve">
          <source>An example of how extended keys could be employed for a query built over a &lt;a href=&quot;http://www.tpc.org/tpch/specs.asp&quot;&gt;DBT-3/TPC-H database&lt;/a&gt; with one added index defined on &lt;code&gt;p_retailprice&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;p_retailprice&lt;/code&gt; 에 정의 된 하나의 추가 색인 이있는 &lt;a href=&quot;http://www.tpc.org/tpch/specs.asp&quot;&gt;DBT-3 / TPC-H 데이터베이스에&lt;/a&gt; 빌드 된 쿼리에 확장 키를 사용하는 방법의 예 .</target>
        </trans-unit>
        <trans-unit id="51419155b944c37b8589c7341a8161721421c008" translate="yes" xml:space="preserve">
          <source>An example of the Algorithm being 'wrong':</source>
          <target state="translated">알고리즘이 '잘못된'예 :</target>
        </trans-unit>
        <trans-unit id="70230ee6fe432c0b4408bb92c03dea3f5c3a916d" translate="yes" xml:space="preserve">
          <source>An example to add two Performance Modules with defaulted instance names, type the following:</source>
          <target state="translated">기본 인스턴스 이름으로 두 개의 성능 모듈을 추가하는 예제는 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="518f315aa83a6a3646902f091b4f19eeb312408e" translate="yes" xml:space="preserve">
          <source>An example to add two Performance Modules with instance names id-1234890 and id-9876598</source>
          <target state="translated">인스턴스 이름이 id-1234890 및 id-9876598 인 두 개의 성능 모듈을 추가하는 예</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e7225a959a609f631d77973ee0ae6ac1b71ee30b" translate="yes" xml:space="preserve">
          <source>An exclusive lock is obtained to write to a row, and stops other transactions from locking the same row. It's specific behavior depends on the &lt;a href=&quot;../set-transaction-isolation-level/index#isolation-level&quot;&gt;isolation level&lt;/a&gt;; the default (REPEATABLE READ), allow other transactions to read from the exclusively locked row.</source>
          <target state="translated">독점 잠금은 행에 쓰려고하며 다른 트랜잭션이 동일한 행을 잠그지 못하게합니다. 특정 동작은 &lt;a href=&quot;../set-transaction-isolation-level/index#isolation-level&quot;&gt;격리 수준&lt;/a&gt; 에 따라 다릅니다. . 기본값 (REPEATABLE READ)을 사용하면 다른 트랜잭션이 배타적으로 잠긴 행에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb82fa696cf4664bba3ade1103ecb371eeb34c" translate="yes" xml:space="preserve">
          <source>An existing MariaDB ColumnStore system can be scaled out by adding addition User Modules. More Details can be found here on adding addition modules to a system:</source>
          <target state="translated">사용자 모듈을 추가하여 기존 MariaDB ColumnStore 시스템을 확장 할 수 있습니다. 시스템에 추가 모듈을 추가하는 방법에 대한 자세한 내용은 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7323b0c164445acfbb6e04a84cc7f68e20d79c0c" translate="yes" xml:space="preserve">
          <source>An existing table can be &lt;a href=&quot;../alter-table/index&quot;&gt;altered&lt;/a&gt; to enable system versioning for it.</source>
          <target state="translated">시스템 버전 관리를 위해 기존 테이블을 &lt;a href=&quot;../alter-table/index&quot;&gt;변경할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c0fdbedcdfc634748bd2f8afdcc6efad3e6e4f9" translate="yes" xml:space="preserve">
          <source>An expression may be a constant, column, and non window function expressions.</source>
          <target state="translated">표현식은 상수, 열 및 비 창문 함수 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e62850e42d655da62f9df8eee43ad73f9cb364d" translate="yes" xml:space="preserve">
          <source>An extract of the books can be found here:</source>
          <target state="translated">책의 발췌 내용은 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d3bb7caca8b64fa1e9c846d3c54140c2e4c8d2" translate="yes" xml:space="preserve">
          <source>An identifier is fully-qualified if it contains all possible qualifiers, for example, the following column is fully qualified: &lt;code&gt;db_name.tbl_name.col_name&lt;/code&gt;.</source>
          <target state="translated">가능한 모든 한정자가 포함 된 경우 식별자는 정규화됩니다 (예 : &lt;code&gt;db_name.tbl_name.col_name&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="bae0887805ff31292020c24f85f66bd80c92e929" translate="yes" xml:space="preserve">
          <source>An identifier starting with a numeral, followed by an 'e', may be parsed as a floating point number, and needs to be quoted.</source>
          <target state="translated">숫자로 시작하고 그 뒤에 'e'가 오는 식별자는 부동 소수점 숫자로 구문 분석 될 수 있으며 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="e9678eefe606175cc80e583ff6a9e6fe3059c970" translate="yes" xml:space="preserve">
          <source>An image is not a running process; it is just the software needed to be launched. To run it, we must create a container first. The command needed to create a container can usually be found in the image documentation. For example, to create a container for the official MariaDB image:</source>
          <target state="translated">이미지는 실행중인 프로세스가 아닙니다. 그것은 단지 시작될 필요가있는 소프트웨어 일뿐입니다. 컨테이너를 실행하려면 먼저 컨테이너를 만들어야합니다. 컨테이너를 만드는 데 필요한 명령은 일반적으로 이미지 설명서에서 찾을 수 있습니다. 예를 들어 공식 MariaDB 이미지의 컨테이너를 만들려면</target>
        </trans-unit>
        <trans-unit id="e0f4c0fa4a2254eb5c5948d5db9beaa7fa900ccf" translate="yes" xml:space="preserve">
          <source>An important feature of JSON is that strings should in UNICODE. As a matter of facts, all examples we have found on the Internet seemed to be just ASCII. This because UNICODE is generally encoded in JSON files using UTF8 or UTF16 or UTF32.</source>
          <target state="translated">JSON의 중요한 기능은 문자열이 UNICODE로되어 있어야한다는 것입니다. 사실 인터넷에서 찾은 모든 예제는 ASCII 일뿐이었습니다. UNICODE는 일반적으로 UTF8 또는 UTF16 또는 UTF32를 사용하여 JSON 파일로 인코딩되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="43310f4c62914af7dde9c272caef3b72ab30c732" translate="yes" xml:space="preserve">
          <source>An important note is that setting &lt;code&gt;LimitNOFILE=infinity&lt;/code&gt; doesn't actually set the open file limit to &lt;em&gt;infinite&lt;/em&gt;.</source>
          <target state="translated">중요한 점은 설정이다 &lt;code&gt;LimitNOFILE=infinity&lt;/code&gt; 실제로 할 수있는 열린 파일 제한을 설정하지 않는 &lt;em&gt;무한&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34250c50caf5cd1341435bd3c2e0401b9d9cfe4f" translate="yes" xml:space="preserve">
          <source>An important point is that the operation works at Partition granularity, so a minimal data set is 64M rows in a a table for this to run.</source>
          <target state="translated">중요한 점은 작업이 Partition granularity에서 작동하므로 최소 데이터 세트는 테이블에서 64M 행이며이를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="813bdec48cfb4b61596faf1ed5dfb8ac99d62c2a" translate="yes" xml:space="preserve">
          <source>An index type used for geometric columns.</source>
          <target state="translated">기하 열에 사용되는 인덱스 유형입니다.</target>
        </trans-unit>
        <trans-unit id="59d831f9e2ba8c6e4231447bc6ed21a251588c3e" translate="yes" xml:space="preserve">
          <source>An indexed created as &amp;ldquo;dynamic&amp;rdquo; is a standard index which, in some cases, can be reconstructed for a specific query. This happens in particular for some queries where two tables are joined by an indexed key column. If the &amp;ldquo;from&amp;rdquo; table is big and the &amp;ldquo;to&amp;rdquo; big table reduced in size because of a where clause, it can be worthwhile to reconstruct the index on this reduced table.</source>
          <target state="translated">&quot;동적&quot;으로 생성 된 인덱스는 경우에 따라 특정 쿼리에 대해 재구성 할 수있는 표준 인덱스입니다. 이는 특히 인덱스 된 키 열에 의해 두 개의 테이블이 조인되는 일부 쿼리에서 발생합니다. where 절로 인해&amp;ldquo;from&amp;rdquo;테이블이 크고&amp;ldquo;to&amp;rdquo;큰 테이블의 크기가 줄어든 경우이 축소 된 테이블에서 인덱스를 재구성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="912b325fc561d448ac0b6ba0ec070399db51fa85" translate="yes" xml:space="preserve">
          <source>An integer value that uniquely identifies each Spatial Reference System within a database.</source>
          <target state="translated">데이터베이스 내의 각 공간 참조 시스템을 고유하게 식별하는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="50663d6212cbf92020029996180884d8179c4a89" translate="yes" xml:space="preserve">
          <source>An integer value whose meaning depends on the table type.</source>
          <target state="translated">의미는 테이블 유형에 따라 달라지는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="3136e978791512a0283728c590b2d28dd12485e7" translate="yes" xml:space="preserve">
          <source>An interesting case is when the query to run on remote machines is the same for all of them. It is then possible to avoid declaring all sub-tables. In this case, the table list option will be used to specify the list of servers the &lt;code&gt;SRCDEF&lt;/code&gt; query must be sent. This will be a list of URL&amp;rsquo;s and/or Federated server names.</source>
          <target state="translated">흥미로운 것은 원격 시스템에서 실행되는 쿼리가 모든 시스템에서 동일 할 때입니다. 그런 다음 모든 서브 테이블을 선언하지 않아도됩니다. 이 경우 테이블 목록 옵션을 사용하여 &lt;code&gt;SRCDEF&lt;/code&gt; 쿼리를 보내야 하는 서버 목록을 지정합니다 . 이것은 URL 및 / 또는 페더 레이 티드 서버 이름의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d9191442877d0ac29f0c4382c42e3bab49c208ad" translate="yes" xml:space="preserve">
          <source>An interesting use of virtual tables, which often cannot be achieved with a table of any other type, is to generate a table containing constant values. This is easily done with a virtual table. Let us define the table FILLER as:</source>
          <target state="translated">다른 유형의 테이블로는 달성 할 수없는 가상 테이블의 흥미로운 용도는 상수 값을 포함하는 테이블을 생성하는 것입니다. 이것은 가상 테이블로 쉽게 수행 할 수 있습니다. FILLER 테이블을 다음과 같이 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="063b9803f7eaa2d6601fd1a59702e38fd39c4235" translate="yes" xml:space="preserve">
          <source>An internal alarm system is used to keep track of internal notable events as a convenience or reference point. It is recommended to use a dedicated system monitoring tool for more proactive alerting of critical CPU, memory, or disk utilization issues for each of the servers.</source>
          <target state="translated">내부 경보 시스템은 편의상 또는 기준점으로 내부 주목할만한 이벤트를 추적하는 데 사용됩니다. 각 서버의 중요한 CPU, 메모리 또는 디스크 사용률 문제를보다 적극적으로 경고하려면 전용 시스템 모니터링 도구를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="271d2d38cbe6839135c4a20f9a08bb5e547492f1" translate="yes" xml:space="preserve">
          <source>An introductory tutorial on using the JOIN clause.</source>
          <target state="translated">JOIN 절 사용에 대한 입문서입니다.</target>
        </trans-unit>
        <trans-unit id="1b72a19f76373b9f77cf5c67c2e3451e8d974c75" translate="yes" xml:space="preserve">
          <source>An invalid password is initially set for both of these user accounts. This means that before a password can be used to authenticate as either of these user accounts, the accounts must first be given a valid password by executing the &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">초기에이 두 사용자 계정 모두에 유효하지 않은 비밀번호가 설정되었습니다. 이는 비밀번호를 사용하여 이러한 사용자 계정 중 하나로 인증하기 전에 먼저 &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; 문 을 실행하여 계정에 올바른 비밀번호를 부여해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75b9ebfee57df3b3842384c6be7bcf0914c1360b" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.</source>
          <target state="translated">연속 분포 모형을 가정하는 역 분포 함수. 숫자 또는 날짜 시간 값을 가져 와서 값이 정렬되면 중간 값이 될 중간 값 또는 보간 된 값을 반환합니다. 계산에서 널은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad1151209e072783bf8f3e96d233eef5c99f8fc" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation.&lt;strong&gt; Not available in MariaDB Columnstore 1.1 &lt;/strong&gt;</source>
          <target state="translated">연속 분포 모형을 가정하는 역 분포 함수. 숫자 또는 날짜 시간 값을 가져 와서 값이 정렬되면 중간 값이 될 중간 값 또는 보간 된 값을 반환합니다. 계산에서 널은 무시됩니다. &lt;strong&gt;MariaDB Columnstore 1.1에서는 사용할 수 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f3cb1708a2c6ecae888f2745f93354668ea8f3dc" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation.</source>
          <target state="translated">연속 분포 모형을 가정하는 역 분포 함수. 백분위 수 값과 정렬 스펙을 취하고 정렬 스펙과 관련하여 백분위 수 값에 해당하는 보간 된 값을 리턴합니다. 계산에서 널은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="71780eff52f3fe0911c1122345ae9ca8fde13277" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation. &lt;strong&gt; Not available in MariaDB Columnstore 1.1 &lt;/strong&gt;</source>
          <target state="translated">연속 분포 모형을 가정하는 역 분포 함수. 백분위 수 값과 정렬 스펙을 취하고 정렬 스펙과 관련하여 해당 백분위 수 값에 해당하는 보간 된 값을 리턴합니다. 계산에서 널은 무시됩니다. &lt;strong&gt;MariaDB Columnstore 1.1에서는 사용할 수 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97d8a3aa17706a6ccf7d05cd130227c404cb31dc" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation.</source>
          <target state="translated">이산 분포 모델을 가정하는 역 분포 함수. 백분위 수 값과 정렬 스펙을 사용하여 세트에서 요소를 리턴합니다. 계산에서 널은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c6713b4beeb315fd90aff5e08840ab825c8d891a" translate="yes" xml:space="preserve">
          <source>An inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation. &lt;strong&gt; Not available in MariaDB Columnstore 1.1 &lt;/strong&gt;</source>
          <target state="translated">이산 분포 모델을 가정하는 역 분포 함수. 백분위 수 값과 정렬 스펙을 사용하여 세트에서 요소를 리턴합니다. 계산에서 널은 무시됩니다. &lt;strong&gt;MariaDB Columnstore 1.1에서는 사용할 수 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc74f936f07f779fc95cfec2b2ca8edf71ad9240" translate="yes" xml:space="preserve">
          <source>An issue with libxml2 is that some files can declare a default name space in their root node. Because Xpath only searches in that name space, the nodes will not be found if they are not prefixed. If this happens, specify the tabname option as an Xpath ignoring the current name space:</source>
          <target state="translated">libxml2의 문제점은 일부 파일이 루트 노드에서 기본 네임 스페이스를 선언 할 수 있다는 것입니다. Xpath는 해당 네임 스페이스에서만 검색하므로 접두사가없는 노드는 찾을 수 없습니다. 이 경우 현재 네임 스페이스를 무시하고 tabname 옵션을 Xpath로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="d4f2fb4f6a7cefac94e6ca173e5a99830e01db45" translate="yes" xml:space="preserve">
          <source>An issue, when creating a WMI table, is to make its column definition. Indeed, even when you know the namespace and the class for the wanted information, it is not easy to find what are the names and types of its properties. However, because CONNECT can retrieve this information from the WMI provider, you can simply omit defining columns and CONNECT will do the job.</source>
          <target state="translated">WMI 테이블을 만들 때 문제는 열을 정의하는 것입니다. 실제로 원하는 정보의 네임 스페이스와 클래스를 알고 있더라도 해당 속성의 이름과 유형이 무엇인지 찾기가 쉽지 않습니다. 그러나 CONNECT는 WMI 제공자에서이 정보를 검색 할 수 있으므로 열 정의를 생략하면 CONNECT가 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3111211fd57a10e8f9f4194590320750a0a2f721" translate="yes" xml:space="preserve">
          <source>An offset from &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;Coordinated Universal Time (UTC)&lt;/a&gt;, such as &lt;code&gt;+5:00&lt;/code&gt; or &lt;code&gt;-9:00&lt;/code&gt;, can also be used.</source>
          <target state="translated">&lt;code&gt;+5:00&lt;/code&gt; 또는 &lt;code&gt;-9:00&lt;/code&gt; 와 같은 &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC (협정 세계시)&lt;/a&gt; 로부터의 오프셋 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de47b48d4233a73d85b144eb7b1b15891c0cbb1" translate="yes" xml:space="preserve">
          <source>An old table created before MySQL 5.1.6, with the old encoding:</source>
          <target state="translated">이전 인코딩으로 MySQL 5.1.6 이전에 작성된 이전 테이블 :</target>
        </trans-unit>
        <trans-unit id="f08637f4e51b1c7105d6e972b7761fd97ccb3d5d" translate="yes" xml:space="preserve">
          <source>An old version of &lt;code&gt;mysqlbinlog&lt;/code&gt; can read binlog files produced by a new server version &lt;strong&gt;if&lt;/strong&gt; checksums were disabled when the log was produced. Old versions of &lt;code&gt;mysqlbinlog&lt;/code&gt; reading a new binlog file containing checksums will be confused, and output will be garbled, with the added checksums being interpreted as extra garbage at the end of query strings and similar entries. No error will be reported in this case, just wrong output.</source>
          <target state="translated">이전 버전의 &lt;code&gt;mysqlbinlog&lt;/code&gt; 는 로그가 생성 될 때 체크섬이 비활성화 된 &lt;strong&gt;경우&lt;/strong&gt; 새 서버 버전에서 생성 된 binlog 파일을 읽을 수 있습니다 . 체크섬을 포함하는 새로운 binlog 파일을 읽는 이전 버전의 &lt;code&gt;mysqlbinlog&lt;/code&gt; 는 혼란스러워지고 추가 된 체크섬이 쿼리 문자열 및 유사한 항목 끝에 추가 가비지로 해석되어 출력이 왜곡됩니다. 이 경우 오류가보고되지 않고 잘못된 출력 만보고됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c59cf35a17112bb0fb200e520265814f5f5e8a" translate="yes" xml:space="preserve">
          <source>An older format has the latch field as a SMALLINT rather than a VARCHAR. In &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB 10.0.7&lt;/a&gt; with OQGRAPH v3, the format is still valid, but gives an error by default:</source>
          <target state="translated">이전 형식의 래치 필드는 VARCHAR이 아니라 SMALLINT로 사용됩니다. OQGRAPH v3 이 포함 된 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB&lt;/a&gt; 10.0.7에서 형식은 여전히 ​​유효하지만 기본적으로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f7f88c5742aeea7aa4d7971d6297be6bcd2c63a" translate="yes" xml:space="preserve">
          <source>An optimization for improving performance of IO-bound queries which scan many rows.</source>
          <target state="translated">많은 행을 스캔하는 IO 바운드 쿼리의 성능 향상을위한 최적화</target>
        </trans-unit>
        <trans-unit id="28a4b0c6aab2de5b8542f15dd285b4a796b47781" translate="yes" xml:space="preserve">
          <source>An option name may start with a hash sign &lt;code&gt;#&lt;/code&gt;. In the resulting &lt;code&gt;my.cnf&lt;/code&gt; it will look like a comment, but it still can be referred to. For example:</source>
          <target state="translated">옵션 이름은 해시 기호 &lt;code&gt;#&lt;/code&gt; 로 시작할 수 있습니다 . 결과적으로 &lt;code&gt;my.cnf&lt;/code&gt; 주석처럼 보이지만 여전히 참조 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe47d83fd09e50569752d66b1146149c6edd499e" translate="yes" xml:space="preserve">
          <source>An optional display width may be added to the BIGINT, INTEGER/INT, SMALLINT &amp;amp; TINYINT columns. As with core MariaDB tables, this value does not affect the internal storage requirements of the column nor does it affect the valid value ranges.</source>
          <target state="translated">BIGINT, INTEGER / INT, SMALLINT 및 TINYINT 열에 선택적 디스플레이 너비를 추가 할 수 있습니다. 코어 MariaDB 테이블과 마찬가지로이 값은 열의 내부 스토리지 요구 사항에 영향을 미치지 않으며 유효한 값 범위에도 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5d5424ccf5da09aaec72941697e5d427f16b0fd" translate="yes" xml:space="preserve">
          <source>An optional length &lt;code&gt;M&lt;/code&gt; can be given for this type. If this is done, MariaDB creates the column as the smallest &lt;code&gt;BLOB&lt;/code&gt; type large enough to hold values &lt;em&gt;&lt;code&gt;M&lt;/code&gt;&lt;/em&gt; bytes long.</source>
          <target state="translated">이 유형에 대해 선택적 길이 &lt;code&gt;M&lt;/code&gt; 을 지정할 수 있습니다. 이것이 완료되면, MariaDB는 최소로 열 생성 &lt;code&gt;BLOB&lt;/code&gt; 의 보류 값을 입력 충분히 큰 &lt;em&gt; &lt;code&gt;M&lt;/code&gt; 을&lt;/em&gt; 바이트 길이 .</target>
        </trans-unit>
        <trans-unit id="b63028dd2c6f2b68aaee3d74886fe0190ec64e3a" translate="yes" xml:space="preserve">
          <source>An optional length &lt;code&gt;M&lt;/code&gt; can be given for this type. If this is done, MariaDB creates the column as the smallest &lt;code&gt;TEXT&lt;/code&gt; type large enough to hold values &lt;code&gt;M&lt;/code&gt; characters long.</source>
          <target state="translated">이 유형에 대해 선택적 길이 &lt;code&gt;M&lt;/code&gt; 을 지정할 수 있습니다. 이 작업이 완료되면 MariaDB는 &lt;code&gt;M&lt;/code&gt; 문자 길이의 값을 보유 할만큼 큰 가장 작은 &lt;code&gt;TEXT&lt;/code&gt; 유형 으로 열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="13f8b1dda41a3e73162604402df8b194090ed5b9" translate="yes" xml:space="preserve">
          <source>An optional second argument gives a timeout in seconds. If the timeout expires before the specified GTID position is reached, then the function returns -1. Passing NULL or a negative number for the timeout means no timeout, and the function will wait indefinitely.</source>
          <target state="translated">선택적 두 번째 인수는 초 단위의 시간 초과를 제공합니다. 지정된 GTID 위치에 도달하기 전에 시간 종료가 만료되면 함수는 -1을 리턴합니다. 시간 종료에 NULL 또는 음수를 전달하면 시간 종료가 없으며 함수는 무기한 대기합니다.</target>
        </trans-unit>
        <trans-unit id="bac638278c66f4742dfccf52ccd2dda15e121166" translate="yes" xml:space="preserve">
          <source>An optional user password.</source>
          <target state="translated">선택적 사용자 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="d23d054ffc16e51f1537bffbe55cb542aa3e9ec2" translate="yes" xml:space="preserve">
          <source>An orphan intermediate table may prevent you from dropping the tablespace even if it is otherwise empty, and generally takes up unnecessary space.</source>
          <target state="translated">고아 중간 테이블은 테이블 공간이 비어 있어도 테이블 공간을 h 제하지 못하게하고 일반적으로 불필요한 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="2e24e06dc6d77bdc167dc372085e9fa31b63f599" translate="yes" xml:space="preserve">
          <source>An overlay can replace almost any file in the overlaid suite, or add new files. For example, if some overlay of the main suite contains a &lt;code&gt;include/have_innodb.inc&lt;/code&gt; file, then all tests that include it will see and use the overlaid version. Or, an overlay can create a &lt;code&gt;t/create.opt&lt;/code&gt; file (even though the main suite does not have such a file), and &lt;code&gt;create.test&lt;/code&gt; will be executed with the specified additional options.</source>
          <target state="translated">오버레이는 오버레이 제품군의 거의 모든 파일을 대체하거나 새 파일을 추가 할 수 있습니다. 예를 들어, 메인 스위트의 일부 오버레이에 &lt;code&gt;include/have_innodb.inc&lt;/code&gt; 파일이 포함되어 있으면이를 포함하는 모든 테스트에서 오버레이 버전을보고 사용합니다. 또는 오버레이는 &lt;code&gt;t/create.opt&lt;/code&gt; 파일을 만들 수 있으며 (메인 스위트에는 이러한 파일이 &lt;code&gt;create.test&lt;/code&gt; ) 지정된 추가 옵션을 사용하여 create.test 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="62ad174115532bf9b1a8952c0e8c82be58af29c3" translate="yes" xml:space="preserve">
          <source>An overlay is like a second transparent layer in a graphics editor. It can obscure, extend, or modify the background image. Also, one may notice that an overlay is very close to a &lt;em&gt;UnionFS&lt;/em&gt;, but implemented in perl inside mtr.</source>
          <target state="translated">오버레이는 그래픽 편집기의 두 번째 투명 레이어와 같습니다. 배경 이미지를 가리거나 확장하거나 수정할 수 있습니다. 또한 오버레이가 &lt;em&gt;UnionFS&lt;/em&gt; 와 매우 유사 하지만 mtr 내부의 perl로 구현 되었음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6693f9ae68168c9303b3e8793f57d0e63950c35" translate="yes" xml:space="preserve">
          <source>Analysis of individual queries</source>
          <target state="translated">개별 쿼리 분석</target>
        </trans-unit>
        <trans-unit id="fe7b75e2612ce4d7e27ad6857ec8c1f89de3be4e" translate="yes" xml:space="preserve">
          <source>Analytical queries</source>
          <target state="translated">분석 쿼리</target>
        </trans-unit>
        <trans-unit id="b817266a3539edf9220739dc3e7c3300a4120f73" translate="yes" xml:space="preserve">
          <source>Analytical workloads (OLAP); and</source>
          <target state="translated">분석 워크로드 (OLAP); 과</target>
        </trans-unit>
        <trans-unit id="f7d7020ff703c3d93205f79d8b3ac33835d36f64" translate="yes" xml:space="preserve">
          <source>Analyze distribution of keys. Will make some joins faster as the join optimizer can better choose the order in which to join the tables and which indexes to use. You can check the calculated distribution by using '--description --verbose table_name' or &lt;a href=&quot;../show-index/index&quot;&gt;SHOW INDEX FROM table_name&lt;/a&gt;.</source>
          <target state="translated">키 분포를 분석합니다. 조인 최적화 프로그램이 테이블을 조인하는 순서와 사용할 인덱스를 더 잘 선택할 수 있으므로 조인이 더 빨라집니다. '--description --verbose table_name'또는 &lt;a href=&quot;../show-index/index&quot;&gt;SHOW INDEX FROM table_name&lt;/a&gt; 을 사용하여 계산 된 분포를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5392ebc4645d2eba328d51deb8bb179375668e35" translate="yes" xml:space="preserve">
          <source>Analyze distribution of keys. Will make some joins in MariaDB faster. You can check the calculated distribution by using '&lt;code&gt;--description --verbose table_name&lt;/code&gt;'.</source>
          <target state="translated">키 분포를 분석합니다. MariaDB에 더 빨리 참여할 수 있습니다. ' &lt;code&gt;--description --verbose table_name&lt;/code&gt; ' 을 사용하여 계산 된 분포를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea94f9bd97f6d011239c5dc66ec8a16660c44a1c" translate="yes" xml:space="preserve">
          <source>Analyze given tables.</source>
          <target state="translated">주어진 테이블을 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="696002c43e9fbd3ed7a6b6ef84794f6d08e1425e" translate="yes" xml:space="preserve">
          <source>Analyzing</source>
          <target state="translated">Analyzing</target>
        </trans-unit>
        <trans-unit id="e1466871be56377be92a94858de79e115c99c32d" translate="yes" xml:space="preserve">
          <source>Analyzing Queries in ColumnStore</source>
          <target state="translated">ColumnStore에서 쿼리 분석</target>
        </trans-unit>
        <trans-unit id="43110741474ae52658cf7ff2b7d02754c643ae89" translate="yes" xml:space="preserve">
          <source>Anchored data types allow a data type to be defined based on another object, such as a table row, rather than specifically set in the declaration. If the anchor object changes, so will the anchored data type. This can lead to routines being easier to maintain, so that if the data type in the table is changed, it will automatically be changed in the routine as well.</source>
          <target state="translated">고정 된 데이터 형식을 사용하면 선언에서 구체적으로 설정하지 않고 테이블 행과 같은 다른 개체를 기반으로 데이터 형식을 정의 할 수 있습니다. 앵커 객체가 변경되면 앵커 된 데이터 유형도 변경됩니다. 이로 인해 루틴을보다 쉽게 ​​유지 보수 할 수 있으므로 테이블의 데이터 유형이 변경되면 루틴에서도 자동으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="c14e637e09e9813a09fb6cbbc955e2c30d5ed4d1" translate="yes" xml:space="preserve">
          <source>And adjusting file permissions, if necessary:</source>
          <target state="translated">필요한 경우 파일 권한 조정</target>
        </trans-unit>
        <trans-unit id="dba1497375ffc6014c84125bc3fd1e16c157edfe" translate="yes" xml:space="preserve">
          <source>And all tests where this combinations file applies will be run three times: once for the combination called &quot;row&quot;, and &lt;code&gt;--binlog-format=row&lt;/code&gt; on the server command line, once for the &quot;stmt&quot; combination, and once for the &quot;mix&quot; combination.</source>
          <target state="translated">이 조합 파일이 적용되는 모든 테스트는 &quot;row&quot;라는 조합에 대해 한 번 , 서버 명령 &lt;code&gt;--binlog-format=row&lt;/code&gt; 에서 --binlog-format = row 에 대해 한 번, &quot;stmt&quot;조합에 대해 한 번, &quot; 믹스 &quot;조합.</target>
        </trans-unit>
        <trans-unit id="283f2bddde04052f1001a7f20d5a7b3270fc5b10" translate="yes" xml:space="preserve">
          <source>And almost (without 2, the only even prime number) the same result with joins:</source>
          <target state="translated">그리고 조인과 거의 같은 결과 (2없이, 소수조차도 소수) :</target>
        </trans-unit>
        <trans-unit id="22ae8a943c1f9247e1c8f792c2debfc4e46c2b5e" translate="yes" xml:space="preserve">
          <source>And as an extra safety measure:</source>
          <target state="translated">그리고 추가적인 안전 조치로 :</target>
        </trans-unit>
        <trans-unit id="9186828108609f6c117cbe6a1d46ce398ff85104" translate="yes" xml:space="preserve">
          <source>And check the performance metrics. Remove specific Spider metrics to have a more global view.</source>
          <target state="translated">성능 지표를 확인하십시오. 보다 전체적인 시야를 확보하기 위해 특정 Spider 지표를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="38aa4f9ad429be1cfff3cc146bd99d7219a8aed8" translate="yes" xml:space="preserve">
          <source>And for connecting to MariaDB:</source>
          <target state="translated">MariaDB에 연결하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3de305c30f832a303cd3dee0b6b2226c14de25ad" translate="yes" xml:space="preserve">
          <source>And fourth, a user might want to retrieve a list of tables in a specific database. With &lt;code&gt;SHOW TABLES&lt;/code&gt; or by quering &lt;code&gt;INFORMATION_SCHEMA&lt;/code&gt; tables. The user expects to see all tables, but the server cannot discover them one by one, because it doesnt know table names. In this case, the server uses a special discovery technique. It is &lt;strong&gt;find_files()&lt;/strong&gt; method in the handlerton, defines as</source>
          <target state="translated">넷째, 사용자는 특정 데이터베이스에서 테이블 목록을 검색하려고 할 수 있습니다. 와 &lt;code&gt;SHOW TABLES&lt;/code&gt; 또는 quering에 의해 &lt;code&gt;INFORMATION_SCHEMA&lt;/code&gt; 의 테이블을. 사용자는 모든 테이블을 볼 것으로 예상하지만 서버는 테이블 이름을 모르기 때문에 테이블을 하나씩 검색 할 수 없습니다. 이 경우 서버는 특수한 검색 기술을 사용합니다. 그것은 인 &lt;strong&gt;find_files ()&lt;/strong&gt; handlerton 메소드로서 정의</target>
        </trans-unit>
        <trans-unit id="4ee9f9f4fa1e9411d7a19f4f3bed9b3a107a24c2" translate="yes" xml:space="preserve">
          <source>And if &lt;code&gt;/etc/security/user_map.conf&lt;/code&gt; contained the following:</source>
          <target state="translated">&lt;code&gt;/etc/security/user_map.conf&lt;/code&gt; 에 다음이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="acb7be8d9accf89e2742dcde454e1f56c1c755ff" translate="yes" xml:space="preserve">
          <source>And if the table were using the &lt;code&gt;DYNAMIC&lt;/code&gt; or &lt;code&gt;COMPRESSED&lt;/code&gt; row formats, then the error or warning would be the following:</source>
          <target state="translated">테이블이 &lt;code&gt;DYNAMIC&lt;/code&gt; 또는 &lt;code&gt;COMPRESSED&lt;/code&gt; 행 형식을 사용하는 경우 오류 또는 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8eee803c8d92f530624fd598911810154d0b325" translate="yes" xml:space="preserve">
          <source>And if we ask:</source>
          <target state="translated">그리고 우리가 묻는다면 :</target>
        </trans-unit>
        <trans-unit id="cce4f8f3d64e0d3ff45286c0599a92b4b71173e4" translate="yes" xml:space="preserve">
          <source>And in Red Hat, CentOS, and Fedora, change the &lt;code&gt;baseurl&lt;/code&gt; line from something that looks like this:</source>
          <target state="translated">Red Hat, CentOS 및 Fedora에서 &lt;code&gt;baseurl&lt;/code&gt; 을 변경하십시오. 행을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="d5807f30929f1b69ffc286a85115ef3052505971" translate="yes" xml:space="preserve">
          <source>And is displayed as:</source>
          <target state="translated">그리고 다음과 같이 표시됩니다 :</target>
        </trans-unit>
        <trans-unit id="5045a8ec722d9553a6a9616ed518a23652ea668b" translate="yes" xml:space="preserve">
          <source>And it describes these attributes to MySQL by creating an array of &lt;code&gt;HA_TOPTION_*
&lt;/code&gt; macros. Note a detail: these macros expect a structure called &lt;code&gt;ha_table_option_struct
&lt;/code&gt;, if the structure is called differently, a &lt;code&gt;#define
&lt;/code&gt; will be needed.</source>
          <target state="translated">또한 &lt;code&gt;HA_TOPTION_* &lt;/code&gt; 매크로 배열을 만들어 MySQL에 대한 이러한 특성을 설명 합니다. 세부 사항을 참고하십시오.이 매크로는 &lt;code&gt;ha_table_option_struct &lt;/code&gt; 라는 구조를 예상 합니다. 구조가 다르게 호출되면 &lt;code&gt;#define &lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1458c5352cdd115515dcf3fad9538af436f886c7" translate="yes" xml:space="preserve">
          <source>And later you can just remove the &lt;code&gt;LOCK TABLES&lt;/code&gt; and &lt;code&gt;UNLOCK TABLES&lt;/code&gt; statements.</source>
          <target state="translated">나중에 &lt;code&gt;LOCK TABLES&lt;/code&gt; 및 &lt;code&gt;UNLOCK TABLES&lt;/code&gt; 문을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="732a2ce9ef178566dfb79272f6df8b8385a12963" translate="yes" xml:space="preserve">
          <source>And let's also map this user to &lt;code&gt;dba&lt;/code&gt;:</source>
          <target state="translated">그리고이 사용자를 &lt;code&gt;dba&lt;/code&gt; 에 매핑 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="fa4e9345bd19a600dd375c7e3b5b58bdac502dfc" translate="yes" xml:space="preserve">
          <source>And more...</source>
          <target state="translated">그리고 더...</target>
        </trans-unit>
        <trans-unit id="3df188eba98c95bea96702454354b1960d7bdc2d" translate="yes" xml:space="preserve">
          <source>And now the identical procedure, but with a MyISAM table.</source>
          <target state="translated">이제 동일한 절차이지만 MyISAM 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b0d8402ce01b4d8ebcfc2545a266064c38b520" translate="yes" xml:space="preserve">
          <source>And of course, some JDBC drivers exist to be used with the matching DBMS.</source>
          <target state="translated">물론 일부 JDBC 드라이버는 일치하는 DBMS와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f495b9cc4716e38a052041979ea795f69b62955" translate="yes" xml:space="preserve">
          <source>And on Debian, Ubuntu, and other similar Linux distributions, &lt;code&gt;INSTALL_SYSCONF2DIR&lt;/code&gt; is defined as &lt;code&gt;/etc/mysql/conf.d//&lt;/code&gt;, so it will look for an option file that matches the format:</source>
          <target state="translated">그리고 데비안, 우분투 및 기타 유사한 Linux 배포판에서 &lt;code&gt;INSTALL_SYSCONF2DIR&lt;/code&gt; 은 &lt;code&gt;/etc/mysql/conf.d//&lt;/code&gt; 로 정의됩니다. 되므로 형식과 일치하는 옵션 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d8519e1e9e03b02b095b6cb34a49af5fe2e52800" translate="yes" xml:space="preserve">
          <source>And on Debian, Ubuntu, and other similar Linux distributions, &lt;code&gt;INSTALL_SYSTEMD_UNITDIR&lt;/code&gt; is defined as &lt;code&gt;/lib/systemd/system/&lt;/code&gt;, so it will be installed to:</source>
          <target state="translated">그리고 Debian, Ubuntu 및 기타 유사한 Linux 배포판에서 &lt;code&gt;INSTALL_SYSTEMD_UNITDIR&lt;/code&gt; 은 &lt;code&gt;/lib/systemd/system/&lt;/code&gt; 으로 정의 되므로 다음 위치에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="56a5a8dbcdda1cdc457bb095cfbc42d8afd30464" translate="yes" xml:space="preserve">
          <source>And on Ubuntu Raring the line would be:</source>
          <target state="translated">그리고 우분투에서 Raring은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ceb1b412405c12fc0c2a570507e330e136ca9c6" translate="yes" xml:space="preserve">
          <source>And one of the following conditions is also met:</source>
          <target state="translated">그리고 다음 조건 중 하나도 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="f4602db1d1e4b4635514e7ff62c7edd22e739a05" translate="yes" xml:space="preserve">
          <source>And see the result:</source>
          <target state="translated">그리고 결과를보십시오 :</target>
        </trans-unit>
        <trans-unit id="a4b6f181a104ffd96766de3b9cfb22b5ae2e1db0" translate="yes" xml:space="preserve">
          <source>And so will this user account:</source>
          <target state="translated">이 사용자 계정도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="50a314cf8806ca88da7e695f84a34c209558125c" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt; syntax is:</source>
          <target state="translated">그리고 &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt; 구문은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="cd6385b9b79e7893bf3eed11366483c210e4e0cd" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; syntax is:</source>
          <target state="translated">그리고는 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 구문은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="4d2485c15502b7ca5a0533ca94b532119b10eb3b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; configuration files for individual services are located in the following directory:</source>
          <target state="translated">그리고 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 에 개별 서비스에 대한 구성 파일은 다음 디렉토리에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="245daecffae4b0570d83056940eb501298318865" translate="yes" xml:space="preserve">
          <source>And the SELinux &lt;code&gt;audit.log&lt;/code&gt; will contain errors like the following:</source>
          <target state="translated">그리고 SELinux &lt;code&gt;audit.log&lt;/code&gt; 에는 다음과 같은 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0363ea12bc26c1f2cadcf600529d4c00a840ff36" translate="yes" xml:space="preserve">
          <source>And the following example fails because the granter does have the &lt;code&gt;PROXY&lt;/code&gt; privilege for that specific user account, but it is not defined &lt;code&gt;WITH GRANT OPTION&lt;/code&gt;:</source>
          <target state="translated">부 여자 에게 해당 특정 사용자 계정에 대한 &lt;code&gt;PROXY&lt;/code&gt; 권한이 있지만 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 으로 정의되어 있지 않기 때문에 다음 예제는 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="586e2fbce4fa09fd29eed2258e87e722c2ec623e" translate="yes" xml:space="preserve">
          <source>And the following second snapshot:</source>
          <target state="translated">그리고 다음 두 번째 스냅 샷 :</target>
        </trans-unit>
        <trans-unit id="0dd9bf1cf8dff2f653f27be0f0895aa9dcd8966a" translate="yes" xml:space="preserve">
          <source>And the third option; one can use a variant of the &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; statement to prune the history:</source>
          <target state="translated">그리고 세 번째 옵션; &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 문의 변형을 사용 하여 히스토리를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd3c5af8eca67e489175757129d5e6769c51559" translate="yes" xml:space="preserve">
          <source>And the way it's used by Percona XtraBackup 2.3 is described by the &lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.3/advanced/lockless_bin-log.html&quot;&gt;Percona XtraBackup 2.3 documentation&lt;/a&gt;:</source>
          <target state="translated">그리고 Percona XtraBackup 2.3에서 사용되는 방식은 &lt;a href=&quot;https://www.percona.com/doc/percona-xtrabackup/2.3/advanced/lockless_bin-log.html&quot;&gt;Percona XtraBackup 2.3 문서에&lt;/a&gt; 설명되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="91f5e8d433aba1d6e2f8401071aaa225de0558a3" translate="yes" xml:space="preserve">
          <source>And then :</source>
          <target state="translated">그리고 :</target>
        </trans-unit>
        <trans-unit id="825852f032b2d327c4a0c5771f89d357b6a10517" translate="yes" xml:space="preserve">
          <source>And then &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restart the server&lt;/a&gt; to make the changes persistent.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;서버&lt;/a&gt; 를 다시 시작하여 변경 사항을 영구적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="ec3f155d77ffb746122b81fe7cbe4792cbcd2d94" translate="yes" xml:space="preserve">
          <source>And then &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restart&lt;/a&gt; MariaDB server and any clients or applications that use the library.</source>
          <target state="translated">그런 다음 MariaDB 서버와 라이브러리를 사용하는 클라이언트 또는 응용 프로그램 을 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;다시 시작&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b4583834766f3051e4579620d877e4eff7fa88" translate="yes" xml:space="preserve">
          <source>And then change the &lt;a href=&quot;#configuring-the-pam-service&quot;&gt;PAM service configuration&lt;/a&gt; to execute the script using the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_exec&quot;&gt;pam_exec&lt;/a&gt;&lt;/code&gt; PAM module. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_exec&quot;&gt;pam_exec&lt;/a&gt;&lt;/code&gt; PAM 모듈을 사용하여 스크립트를 실행 &lt;a href=&quot;#configuring-the-pam-service&quot;&gt;하도록 PAM 서비스 구성&lt;/a&gt; 을 변경하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca17906a254b91ed163e219513367298f4a756f8" translate="yes" xml:space="preserve">
          <source>And then let's add our two users to it:</source>
          <target state="translated">그런 다음 두 명의 사용자를 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6187233af19ad284b85daeabd14591b3831b5fef" translate="yes" xml:space="preserve">
          <source>And then let's create our &lt;code&gt;dba&lt;/code&gt; group</source>
          <target state="translated">그리고 &lt;code&gt;dba&lt;/code&gt; 그룹을 만들어 봅시다</target>
        </trans-unit>
        <trans-unit id="ffbb42441389a2d02fb7533a653fda181c8c6f3c" translate="yes" xml:space="preserve">
          <source>And then let's create our &lt;code&gt;dba&lt;/code&gt; group and add our two users to it:</source>
          <target state="translated">그런 다음 &lt;code&gt;dba&lt;/code&gt; 그룹을 만들고 두 명의 사용자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="062c37f0a6ace805868cbd9480652f81cfe85cf3" translate="yes" xml:space="preserve">
          <source>And then let's create the MariaDB user for the group mapping: &lt;code&gt;@dba: dba&lt;/code&gt;</source>
          <target state="translated">그리고 그룹 매핑을위한 MariaDB 사용자를 생성 해 봅시다 : &lt;code&gt;@dba: dba&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="662606db3f906b260eb03a847c39ce6f6d287e19" translate="yes" xml:space="preserve">
          <source>And then let's create the anonymous proxy user:</source>
          <target state="translated">그리고 익명 프록시 사용자를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="087d6c276170276431aab53691f08c375b5861b5" translate="yes" xml:space="preserve">
          <source>And then let's test out our &lt;code&gt;bob&lt;/code&gt; user in the &lt;code&gt;dba&lt;/code&gt; group:</source>
          <target state="translated">그런 다음 &lt;code&gt;dba&lt;/code&gt; 그룹 의 &lt;code&gt;bob&lt;/code&gt; 사용자를 테스트 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="59050c3995ddfc35c84ca7d0de306cf8740868b6" translate="yes" xml:space="preserve">
          <source>And then let's test out our &lt;code&gt;bstillman&lt;/code&gt; user in the &lt;code&gt;dba&lt;/code&gt; group:</source>
          <target state="translated">그런 다음 &lt;code&gt;dba&lt;/code&gt; 그룹 에서 &lt;code&gt;bstillman&lt;/code&gt; 사용자를 테스트 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5d44bbb88635f93ad084ec298d82ab0ce96f5bba" translate="yes" xml:space="preserve">
          <source>And then run</source>
          <target state="translated">그런 다음 실행</target>
        </trans-unit>
        <trans-unit id="774eaf9a44cfb8fc6e6b857b7d1b9ac638dd8770" translate="yes" xml:space="preserve">
          <source>And then the account can be created:</source>
          <target state="translated">그런 다음 계정을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9f2b9f57daf8a6db5108f0eb8ea509bd3832207" translate="yes" xml:space="preserve">
          <source>And then to allow for the user and group mapping, we need to &lt;a href=&quot;../user-and-group-mapping-with-pam/index#creating-users&quot;&gt;create an anonymous user that authenticates with the &lt;code&gt;pam&lt;/code&gt; authentication plugin&lt;/a&gt; that is also able to &lt;code&gt;PROXY&lt;/code&gt; as the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;dba&lt;/code&gt; users. Before we can create the proxy user, we might need to &lt;a href=&quot;../create-user/index#fixing-a-legacy-default-anonymous-account&quot;&gt;clean up some defaults&lt;/a&gt;:</source>
          <target state="translated">그런 다음 사용자 및 그룹 맵핑을 허용 하려면 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;dba&lt;/code&gt; 사용자 로 도 &lt;code&gt;PROXY&lt;/code&gt; 할 수 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#creating-users&quot;&gt;있는 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인으로 인증하는 익명 사용자&lt;/a&gt; 를 작성 해야 합니다. 프록시 사용자를 만들려면 &lt;a href=&quot;../create-user/index#fixing-a-legacy-default-anonymous-account&quot;&gt;몇 가지 기본값&lt;/a&gt; 을 정리 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb24561a29d96bde5749e0fad57809ccbd6c0b0" translate="yes" xml:space="preserve">
          <source>And then to configure &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_auth&quot;&gt;wsrep_sst_auth&lt;/a&gt;&lt;/code&gt;, you could set the following in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up a node:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_auth&quot;&gt;wsrep_sst_auth&lt;/a&gt;&lt;/code&gt; 를 구성 하기 위해 노드를 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 다음을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c73151aa30fa8aaf5c2b38b3aa5ec6f150873fa3" translate="yes" xml:space="preserve">
          <source>And then update the package by executing the following command:</source>
          <target state="translated">그런 다음 다음 명령을 실행하여 패키지를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="199d12c3b412fccd7711daf6fd4a9a92f14a25b1" translate="yes" xml:space="preserve">
          <source>And then we can build and install the library with the following:</source>
          <target state="translated">그런 다음 다음을 사용하여 라이브러리를 빌드하고 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ee164f6121ecf16a4237c25313354e24b730e5" translate="yes" xml:space="preserve">
          <source>And then we can create a user with the hash:</source>
          <target state="translated">그리고 해시로 사용자를 만들 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="827183edd1a3b047556c22a29b012abcb792dba4" translate="yes" xml:space="preserve">
          <source>And then we can set an account's password with the hash:</source>
          <target state="translated">그리고 해시로 계정 비밀번호를 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="84173da650d4114c55a46e024f27785582d5e1bd" translate="yes" xml:space="preserve">
          <source>And then we would prepare the backup as you normally would. For example:</source>
          <target state="translated">그런 다음 평소처럼 백업을 준비합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62e39ffe14879988de5e09cfdf8546431a0bc0f2" translate="yes" xml:space="preserve">
          <source>And then we would set &lt;code&gt;MASTER_USE_GTID=slave_pos&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 명령 에서 &lt;code&gt;MASTER_USE_GTID=slave_pos&lt;/code&gt; 를 설정 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b97554c26a5d768439653d63daffe51d27b95f1" translate="yes" xml:space="preserve">
          <source>And then you would have to &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restart the server&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;서버&lt;/a&gt; 를 다시 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92782ca94055217eba163c9f2c68e9cc5e6a0b22" translate="yes" xml:space="preserve">
          <source>And then you would have to update the package cache by executing the following command:</source>
          <target state="translated">그리고 다음 명령을 실행하여 패키지 캐시를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b67fba8fe85b6bd6fe152ce994872b4b9b5afb1b" translate="yes" xml:space="preserve">
          <source>And then you would prepare the backup as you normally would. For example:</source>
          <target state="translated">그런 다음 평소처럼 백업을 준비합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1912d469fa3485c7f73fa8821bb11e96a98b2a15" translate="yes" xml:space="preserve">
          <source>And then, you can remove the repository for the old version by executing the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command and providing the &lt;code&gt;--remove&lt;/code&gt; option. For example, if you wanted to remove a &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; repository, then you could do so by executing something like the following:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; 명령을 실행하고 &lt;code&gt;--remove&lt;/code&gt; 옵션을 제공하여 이전 버전의 저장소를 제거 할 수 있습니다 . 예를 들어 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 리포지토리 를 제거 하려면 다음과 같이 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b48ba581699d4ee97225cfa1f80aa5557383b330" translate="yes" xml:space="preserve">
          <source>And they are &lt;strong&gt;not&lt;/strong&gt; supported in the following TLS libraries:</source>
          <target state="translated">또한 다음 TLS 라이브러리에서 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="df7f832f3d2c73d5850a64b00496ddaca77f4539" translate="yes" xml:space="preserve">
          <source>And this fails:</source>
          <target state="translated">그리고 이것은 실패합니다 :</target>
        </trans-unit>
        <trans-unit id="48bade84a76fe3a42af277cdbcb0bb9ee6216ac9" translate="yes" xml:space="preserve">
          <source>And this is where table elimination will be needed.</source>
          <target state="translated">그리고 이것은 테이블 제거가 필요한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="7d86ced7767df8377489d30515b3b0c09102211d" translate="yes" xml:space="preserve">
          <source>And this succeeds in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; and later:</source>
          <target state="translated">그리고 이것은 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4 이상&lt;/a&gt; 에서 성공합니다 :</target>
        </trans-unit>
        <trans-unit id="acd3ce8474db8b33cc156b2bfc27d841896b9fb1" translate="yes" xml:space="preserve">
          <source>And this succeeds in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; and later because the table has &lt;code&gt;ROW_FORMAT=COMPRESSED&lt;/code&gt; and the column's original length is 127 bytes or less:</source>
          <target state="translated">그리고 테이블에 &lt;code&gt;ROW_FORMAT=COMPRESSED&lt;/code&gt; 가 있고 열의 원래 길이가 127 바이트 이하 이므로 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3 이상&lt;/a&gt; 에서 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8305ffca4a096356c889409d0e55302b13083f" translate="yes" xml:space="preserve">
          <source>And this succeeds in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; and later because the table has &lt;code&gt;ROW_FORMAT=DYNAMIC&lt;/code&gt; and the column's original length is 127 bytes or less:</source>
          <target state="translated">그리고 테이블에 &lt;code&gt;ROW_FORMAT=DYNAMIC&lt;/code&gt; 이 있고 열의 원래 길이가 127 바이트 이하 이므로 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3 이상&lt;/a&gt; 에서 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="25633f2fc6cbd915c4f214315c02b2f4afc19f63" translate="yes" xml:space="preserve">
          <source>And this succeeds in the same way as above:</source>
          <target state="translated">그리고 이것은 위와 같은 방식으로 성공합니다 :</target>
        </trans-unit>
        <trans-unit id="95023e26cceab73abe8fd5c4560f19c07986d567" translate="yes" xml:space="preserve">
          <source>And this succeeds, and the second command does not require the table to be rebuilt:</source>
          <target state="translated">그리고 이것은 성공하고 두 번째 명령은 테이블을 다시 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="553b20815179fae2fc7c564b8fd6e63a0f2704ca" translate="yes" xml:space="preserve">
          <source>And this succeeds, but the table is not rebuilt:</source>
          <target state="translated">그리고 이것은 성공하지만 테이블은 다시 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49372b623b7bca8619d4655b85e8f977fd249d0a" translate="yes" xml:space="preserve">
          <source>And this succeeds:</source>
          <target state="translated">그리고 이것은 성공합니다 :</target>
        </trans-unit>
        <trans-unit id="262234af6436cadd6c0935d5697fd86632ed9f79" translate="yes" xml:space="preserve">
          <source>And this third command fails, because a table cannot be rebuilt when it has more than one &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 가 둘 이상인 경우 테이블을 다시 작성할 수 없으므로이 세 번째 명령은 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="33031b1611fc22b82c2abe6eac61a1f246f59ac3" translate="yes" xml:space="preserve">
          <source>And to find all nodes from which a path can be found to &lt;code&gt;destid&lt;/code&gt; that only have outgoing edges:</source>
          <target state="translated">그리고 경로를 발견 할 수있는 모든 노드를 찾을 &lt;code&gt;destid&lt;/code&gt; 만 나가는 가장자리가 :</target>
        </trans-unit>
        <trans-unit id="9888537e71d87470a3890864b2f7e1a31b5ed643" translate="yes" xml:space="preserve">
          <source>And to install Percona XtraBackup 2.4:</source>
          <target state="translated">그리고 Percona XtraBackup 2.4를 설치하려면 :</target>
        </trans-unit>
        <trans-unit id="99f61bf74ca9fa8cbccb0a29afd2eeae5fa1c11b" translate="yes" xml:space="preserve">
          <source>And to see how many InnoDB tablespaces are currently being decrypted or encrypted by background encryption threads, while comparing that to the total number of InnoDB tablespaces and the total number of encrypted InnoDB tablespaces, you can join the table with the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tablespaces-table/index&quot;&gt;INNODB_SYS_TABLESPACES&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; database:</source>
          <target state="translated">그리고 백그라운드 암호화 스레드에 의해 현재 해독되거나 암호화되는 InnoDB 테이블 스페이스 수를 확인하려면이를 총 InnoDB 테이블 스페이스 수와 암호화 된 InnoDB 테이블 스페이스 수와 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tablespaces-table/index&quot;&gt;INNODB_SYS_TABLESPACES&lt;/a&gt;&lt;/code&gt; 하면 &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; 데이터베이스 의 INNODB_SYS_TABLESPACES 테이블 과 테이블을 결합 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5e5c2ebf993b42036ad2aba365ead0ae6e446d92" translate="yes" xml:space="preserve">
          <source>And to see how many InnoDB tablespaces are currently being decrypted or encrypted by background encryption threads, you can call the &lt;code&gt;&lt;a href=&quot;../count/index&quot;&gt;COUNT()&lt;/a&gt;&lt;/code&gt; aggregate function.</source>
          <target state="translated">그리고 백그라운드 암호화 스레드에 의해 현재 해독되거나 암호화되는 InnoDB 테이블 스페이스 수를 확인하려면 &lt;code&gt;&lt;a href=&quot;../count/index&quot;&gt;COUNT()&lt;/a&gt;&lt;/code&gt; 집계 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3d2f5059a170b79ee8c50e069aa8b025af2b733" translate="yes" xml:space="preserve">
          <source>And wait until you have the same position on the slave: (The following should be excepted on the slave)</source>
          <target state="translated">그리고 슬레이브에서 같은 위치에 올 때까지 기다리십시오. (다음은 슬레이브에서 제외되어야 함)</target>
        </trans-unit>
        <trans-unit id="95d35a18b8012b0ccb1a615868bc6162b4f3ad7c" translate="yes" xml:space="preserve">
          <source>And we know that the existing anonymous user already has the &lt;code&gt;PROXY&lt;/code&gt; privilege granted to the &lt;code&gt;dba&lt;/code&gt; user, so this should just work without any other configuration. Let's test it out:</source>
          <target state="translated">또한 기존 익명 사용자 에게는 이미 &lt;code&gt;dba&lt;/code&gt; 사용자 에게 &lt;code&gt;PROXY&lt;/code&gt; 권한이 부여되어 있으므로 다른 구성없이 작동해야합니다. 테스트 해보자.</target>
        </trans-unit>
        <trans-unit id="c42c63460e6a8a34b5782ac0af0063973e35d36a" translate="yes" xml:space="preserve">
          <source>And when asking:</source>
          <target state="translated">그리고 물어볼 때 :</target>
        </trans-unit>
        <trans-unit id="2a648680fcf4bb331a3b102b7132c7ed52bc63a3" translate="yes" xml:space="preserve">
          <source>And when using InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; row format and a default character set of &lt;code&gt;&lt;a href=&quot;../unicode/index&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; (which requires up to 3 bytes per character), the 256 byte limit means that a &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; column will only be stored on overflow pages if it is at least as large as a &lt;code&gt;varchar(86)&lt;/code&gt;:</source>
          <target state="translated">또한 InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 행 형식과 기본 문자 세트 &lt;code&gt;&lt;a href=&quot;../unicode/index&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; (문자 당 최대 3 바이트 필요)을 사용할 때 256 바이트 제한은 &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; 열이 오버 플로우 페이지에 최소한 최대 크기 인 경우 오버 플로우 페이지에만 저장 됨을 의미합니다 . &lt;code&gt;varchar(86)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a0bae4cb8d1e785bd0f6ccfc9e03a3188171af1a" translate="yes" xml:space="preserve">
          <source>And when using InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; row format and a default character set of &lt;code&gt;&lt;a href=&quot;../unicode/index&quot;&gt;utf8mb4&lt;/a&gt;&lt;/code&gt; (which requires up to 4 bytes per character), the 256 byte limit means that a &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; column will only be stored on overflow pages if it is at least as large as a &lt;code&gt;varchar(64)&lt;/code&gt;:</source>
          <target state="translated">또한 InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 행 형식과 기본 문자 세트 &lt;code&gt;&lt;a href=&quot;../unicode/index&quot;&gt;utf8mb4&lt;/a&gt;&lt;/code&gt; (문자 당 최대 4 바이트 필요)를 사용할 때 256 바이트 제한은 &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; 열이 오버 플로우 페이지에 최소한 최대 크기 인 경우 오버 플로우 페이지에만 저장 됨을 의미합니다 . &lt;code&gt;varchar(64)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8affbb4b66981915569aef1669532094144184ab" translate="yes" xml:space="preserve">
          <source>And you should see the rows. You can test the same with sqldeveloper, open XE connection and run select i from t1; in Worksheet.</source>
          <target state="translated">그리고 당신은 행을 볼 수 있습니다. sqldeveloper로 동일하게 테스트하고 XE 연결을 열고 t1에서 select i를 실행할 수 있습니다. 워크 시트에서.</target>
        </trans-unit>
        <trans-unit id="f55024645be46c4da836165ce769ba9336df349e" translate="yes" xml:space="preserve">
          <source>Android SQL client</source>
          <target state="translated">안드로이드 SQL 클라이언트</target>
        </trans-unit>
        <trans-unit id="978eacb6c43edfc0c645272e66ae0c40dafcab14" translate="yes" xml:space="preserve">
          <source>Annotate_rows events accompany row events and describe the query which caused the row event</source>
          <target state="translated">Annotate_rows 이벤트는 행 이벤트와 함께 제공되며 행 이벤트를 일으킨 쿼리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad564d48697d25783bc0ea130ce73bd9e4d45db1" translate="yes" xml:space="preserve">
          <source>Annotate_rows_log_event</source>
          <target state="translated">Annotate_rows_log_event</target>
        </trans-unit>
        <trans-unit id="b28d9d255bb441ee6deaf0e8f0039822c99cbcc2" translate="yes" xml:space="preserve">
          <source>Annotation of row-based replication events with the original SQL statement</source>
          <target state="translated">원래 SQL 문으로 행 기반 복제 이벤트에 주석</target>
        </trans-unit>
        <trans-unit id="ed25e20a61d684a8573b8ddbdbbaae5ef0ba0021" translate="yes" xml:space="preserve">
          <source>Anonymous Accounts</source>
          <target state="translated">익명 계정</target>
        </trans-unit>
        <trans-unit id="861cc031042e799a5287d21fc9e025585c65baef" translate="yes" xml:space="preserve">
          <source>Anonymous accounts are accounts where the user name portion of the account name is empty. These accounts act as special catch-all accounts. If a user attempts to log into the system from a host, and an anonymous account exists with a host name portion that matches the user's host, then the user will log in as the anonymous account if there is no more specific account match for the user name that the user entered.</source>
          <target state="translated">익명 계정은 계정 이름의 사용자 이름 부분이 비어있는 계정입니다. 이 계정은 특별 포괄 계정 역할을합니다. 사용자가 호스트에서 시스템에 로그인하려고 시도하고 사용자의 호스트와 일치하는 호스트 이름 부분을 가진 익명 계정이 존재하는 경우 사용자와 더 이상 일치하는 계정이 없으면 사용자는 익명 계정으로 로그인합니다. 사용자가 입력 한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="de2818ab2e826f3e1577fedbe4a1cfd2f73be117" translate="yes" xml:space="preserve">
          <source>Another Algorithm</source>
          <target state="translated">다른 알고리즘</target>
        </trans-unit>
        <trans-unit id="037bea4ddb123e758e564aee99dacae9c54e4a7f" translate="yes" xml:space="preserve">
          <source>Another MariaDB extension allows to version only a subset of columns in a table. This is useful, for example, if you have a table with user information that should be versioned, but one column is, let's say, a login counter that is incremented often and is not interesting to version. Such a column can be excluded from versioning by declaring it &lt;code&gt;WITHOUT VERSIONING&lt;/code&gt;</source>
          <target state="translated">다른 MariaDB 확장은 테이블에서 열의 서브 세트 만 버전화할 수 있습니다. 예를 들어, 버전 정보를 제공해야하는 사용자 정보가있는 테이블이 있지만 하나의 열이 자주 증가하고 버전에 흥미가없는 로그인 카운터 인 경우에 유용합니다. 이러한 열은 &lt;code&gt;WITHOUT VERSIONING&lt;/code&gt; 선언하여 버전 관리에서 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a8dfec7967e89a61a4de0d4c993592b1aefaab9" translate="yes" xml:space="preserve">
          <source>Another approach</source>
          <target state="translated">다른 접근법</target>
        </trans-unit>
        <trans-unit id="665001afa690876d5b5a8053c842f95a503baaa5" translate="yes" xml:space="preserve">
          <source>Another common opportunity for out-of-order parallel replication comes in connection with multi-source replication. Suppose we have two different masters M1 and M2, and we are using multi-source replication to have S1 as a slave of both M1 and M2. S1 will apply events received from M1 in parallel with events received from M2. If we now have a third-level slave S2 that replicates from S1 as master, we want S2 to also be able to apply events that originated on M1 in parallel with events that originated on M2. This can be achieved with out-of-order parallel replication, by setting &lt;code&gt;gtid_domain_id&lt;/code&gt; different on M1 and M2.</source>
          <target state="translated">비 순차 병렬 복제의 또 다른 일반적인 기회는 다중 소스 복제와 관련이 있습니다. 두 개의 서로 다른 마스터 M1과 M2가 있고 다중 소스 복제를 사용하여 S1을 M1과 M2의 슬레이브로 사용한다고 가정합니다. S1은 M1에서받은 이벤트를 M2에서받은 이벤트와 동시에 적용합니다. 이제 S1에서 마스터로 복제되는 3 단계 슬레이브 S2가있는 경우 S2가 M2에서 시작된 이벤트와 동시에 M1에서 시작된 이벤트를 적용 할 수 있기를 원합니다. 이는 M1 및 M2에서 &lt;code&gt;gtid_domain_id&lt;/code&gt; 를 다르게 설정하여 비 순차 병렬 복제로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d4085cc07681e337e65818042bfecd803034e8" translate="yes" xml:space="preserve">
          <source>Another common use is to include a counter in a query:</source>
          <target state="translated">또 다른 일반적인 용도는 쿼리에 카운터를 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eff43b2ef976efc6d2edf0ef1533b37f74370afa" translate="yes" xml:space="preserve">
          <source>Another example, WMI table</source>
          <target state="translated">다른 예, WMI 테이블</target>
        </trans-unit>
        <trans-unit id="9ec4307bdd773fb8a405cdb810cedfecebcf471b" translate="yes" xml:space="preserve">
          <source>Another format exists, noted by Pretty=1, which is similar to this one but has some additions to represent a JSON array. A header and a trailer records are added containing the opening and closing square bracket, and all records but the last are followed by a comma. It has the same advantages for reading and updating, but inserting and deleting are executed in the pretty=2 way.</source>
          <target state="translated">Pretty = 1로 표시되는 다른 형식이 있는데이 형식과 비슷하지만 JSON 배열을 나타내는 추가 기능이 있습니다. 여는 대괄호와 닫는 대괄호를 포함하는 머리글과 트레일러 레코드가 추가되고 마지막 레코드를 제외한 모든 레코드 뒤에 쉼표가옵니다. 읽기 및 업데이트와 동일한 이점이 있지만 삽입 및 삭제는 pretty = 2 방식으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cc60838af187558c280e85e023a493b4dcab80ec" translate="yes" xml:space="preserve">
          <source>Another good workaround is to replace within the correlated sub-query the ODBC table by a local copy of it because MariaDB is often able to optimize the query and to provide a very fast execution.</source>
          <target state="translated">MariaDB는 종종 쿼리를 최적화하고 매우 빠른 실행을 제공 할 수 있기 때문에 상관 된 하위 쿼리 내에서 ODBC 테이블을 로컬 복사본으로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6f657cbfa37882d4359519e6022d85541115b51" translate="yes" xml:space="preserve">
          <source>Another issue when dealing with ODBC tables is the way table and column names are handled regarding of the case.</source>
          <target state="translated">ODBC 테이블을 처리 할 때의 또 다른 문제는 경우와 관련하여 테이블 및 열 이름이 처리되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="bd5661114744e4af64cd41fcc13f337e530fefb9" translate="yes" xml:space="preserve">
          <source>Another kind of file to consider when troubleshooting is &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option files&lt;/a&gt;. The default option file is called &lt;code&gt;my.cnf&lt;/code&gt;. Option files contain configuration options, such as the location of the data directory mentioned above. If you're unsure where the option file is located, see &lt;a href=&quot;../configuring-mariadb-with-option-files/index#default-option-file-locations&quot;&gt;Configuring MariaDB with Option Files: Default Option File Locations&lt;/a&gt; for information on the default locations.</source>
          <target state="translated">문제 해결시 고려해야 할 또 다른 종류의 파일은 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 입니다. 기본 옵션 파일은 &lt;code&gt;my.cnf&lt;/code&gt; 입니다. 옵션 파일에는 위에서 언급 한 데이터 디렉토리의 위치와 같은 구성 옵션이 있습니다. 옵션 파일의 위치가 확실하지 않은 경우 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#default-option-file-locations&quot;&gt;기본 위치에&lt;/a&gt; 대한 정보는 옵션 파일을 사용하여 MariaDB 구성 : 기본 옵션 파일 위치 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05c74c36058c0b887e94da4d55028b78193b36c7" translate="yes" xml:space="preserve">
          <source>Another major benefit of using &lt;code&gt;INSERT DELAYED&lt;/code&gt; is that inserts from many clients are bundled together and written in one block. This is much faster than performing many separate inserts.</source>
          <target state="translated">&lt;code&gt;INSERT DELAYED&lt;/code&gt; 를 사용하면 얻을 수있는 또 다른 주요 이점은 여러 클라이언트의 인서트가 함께 묶여 하나의 블록으로 작성된다는 것입니다. 이것은 많은 개별 인서트를 수행하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c427c2ae32fa76a736bfe7fa3a4f8a71711057ad" translate="yes" xml:space="preserve">
          <source>Another major limitation of FEDERATED is to access only one table. By combining TBL and MYSQL tables, CONNECT enables to access a collection of local or remote tables as one table. Of course the sub-tables can be on different servers. With one SELECT statement, a company manager will be able to interrogate results coming from all of his subsidiary computers. This is great for distribution, banking, and many other industries.</source>
          <target state="translated">FEDERATED의 또 다른 주요 제한 사항은 하나의 테이블에만 액세스하는 것입니다. CONNECT는 TBL과 MYSQL 테이블을 결합하여 로컬 또는 원격 테이블의 콜렉션을 하나의 테이블로 액세스 할 수있게합니다. 물론 서브 테이블은 다른 서버에있을 수 있습니다. 하나의 SELECT 문으로 회사 관리자는 모든 자회사 컴퓨터에서 얻은 결과를 조사 할 수 있습니다. 이는 유통, 은행 및 기타 여러 산업에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="0ff2df2a4a5f32d89a4554847a368904fd7e2903" translate="yes" xml:space="preserve">
          <source>Another option exists, phpos, enabling to specify what place holders are present and in what order. To be specified as &amp;ldquo;W&amp;rdquo;, &amp;ldquo;WH&amp;rdquo;, &amp;ldquo;H&amp;rdquo;, or &amp;ldquo;HW&amp;rdquo;. It is rarely used because by default CONNECT can set it from the srcdef content. The only cases it is needed is when the srcdef contains only a having place holder or when the having place holder occurs before the where place holder, which can occur on queries containing joins. CONNECT cannot handle more than one place holder of each type.</source>
          <target state="translated">또 다른 옵션 인 phpos는 존재하는 자리 표시 자와 순서를 지정할 수 있도록합니다. &quot;W&quot;, &quot;WH&quot;, &quot;H&quot;또는 &quot;HW&quot;로 지정됩니다. 기본적으로 CONNECT는 srcdef 컨텐츠에서 설정할 수 있기 때문에 거의 사용되지 않습니다. srcdef에 포함 자리 표시 자만 포함 된 경우 또는 자리 표시 자 앞에 자리 표시자가있는 경우 (조인이 포함 된 쿼리에서 발생할 수 있음)에만 필요합니다. CONNECT는 각 유형의 둘 이상의 자리 표시자를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="54fa5bb6081423c66fed26c2b8adf53affa302d9" translate="yes" xml:space="preserve">
          <source>Another option is to point &lt;code&gt;mysqld&lt;/code&gt; to the storage engine directory:</source>
          <target state="translated">또 다른 옵션은 &lt;code&gt;mysqld&lt;/code&gt; 가 스토리지 엔진 디렉토리 를 가리 키 도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ffe0221dec5cb7a31a18fa2a25388ece06bc94ea" translate="yes" xml:space="preserve">
          <source>Another option would be to use partitioning and drop some of historical partitions:</source>
          <target state="translated">또 다른 옵션은 파티셔닝을 사용하고 일부 히스토리 파티션을 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92ff33c4719c14c201b52b2a9018fcdb874256f0" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the API to disable access to the master key and enable it only when a trusted administrator knows that the MariaDB service needs to be started. A specialized tool on a separate host could be used to enable the key for a very short period of time while the service starts and then quickly disable the key.</source>
          <target state="translated">또 다른 가능성은 API를 사용하여 마스터 키에 대한 액세스를 비활성화하고 신뢰할 수있는 관리자가 MariaDB 서비스를 시작해야한다는 것을 알고있는 경우에만 활성화하는 것입니다. 별도의 호스트에있는 특수 도구를 사용하여 서비스가 시작되는 동안 매우 짧은 시간 동안 키를 활성화 한 다음 키를 빠르게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e435e99f2bf4efa2535c745fed3741aff292287" translate="yes" xml:space="preserve">
          <source>Another possible solution is to use the &lt;code&gt;defaults-file&lt;/code&gt; option, so that you can specify your own &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">다른 가능한 해결책은 &lt;code&gt;defaults-file&lt;/code&gt; 옵션을 사용하여 자신의 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일을&lt;/a&gt; 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2494e2812d092f14dbb538a382c77d8c54f2620e" translate="yes" xml:space="preserve">
          <source>Another possible solution: Turn numa off (if the OS has a way of doing that)</source>
          <target state="translated">또 다른 가능한 해결책 : numa를 끄십시오 (OS에 그렇게하는 방법이 있다면)</target>
        </trans-unit>
        <trans-unit id="bb0374cec933be10276292ff00e44923386e5ed1" translate="yes" xml:space="preserve">
          <source>Another potential reason for a startup failure is that an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; contains an invalid option or an invalid option value. In those cases, the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; should contain an error similar to this:</source>
          <target state="translated">시작 실패의 또 다른 잠재적 이유는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 에 유효하지 않은 옵션 또는 유효하지 않은 옵션 값이 포함되어 있기 때문입니다 . 이러한 경우 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 에는 다음과 유사한 오류가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07d4fe820e0883cec6e119f9539b4be6d399f066" translate="yes" xml:space="preserve">
          <source>Another shortcut, &lt;a href=&quot;../drop-index/index&quot;&gt;DROP INDEX&lt;/a&gt;, allows the removal of an index.</source>
          <target state="translated">또 다른 바로 가기 인 &lt;a href=&quot;../drop-index/index&quot;&gt;DROP INDEX&lt;/a&gt; 는 인덱스를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cace8d7069ee1ee21120c838bafa326c492d2e4" translate="yes" xml:space="preserve">
          <source>Another shortcut, &lt;code&gt;&lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX&lt;/a&gt;&lt;/code&gt;, allows the creation of an index.</source>
          <target state="translated">또 다른 바로 가기 인 &lt;code&gt;&lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX&lt;/a&gt;&lt;/code&gt; 는 인덱스를 생성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="b14ff7ab602cf29abadbea713a5c02e40dc2b425" translate="yes" xml:space="preserve">
          <source>Another suggestion... If you are rolling up over a big span of time (eg hourly -&amp;gt; monthly), the bit strings must all be the same length, and the monthly string must be big enough to handle the expected count. This is likely to lead to very sparse hourly bit strings. Hence, it may be prudent to compress the hourly stings.</source>
          <target state="translated">또 다른 제안 ... 시간이 큰 기간 (예 : 시간별-&amp;gt; 월간)으로 롤업하는 경우 비트 문자열의 길이는 모두 같아야하며 월 문자열은 예상 카운트를 처리 할 수있을만큼 커야합니다. 이것은 매우 드문 시간별 비트 문자열로 이어질 수 있습니다. 따라서 시간별 찌르기를 압축하는 것이 신중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02b0e9c9f5f912ef161593142fba0464ec195b4" translate="yes" xml:space="preserve">
          <source>Another thing to look for is 'show variables' to show you that you have support for FederatedX handler support:</source>
          <target state="translated">찾아야 할 또 다른 사항은 FederatedX 처리기 지원을 지원한다는 것을 보여주는 'show variables'입니다.</target>
        </trans-unit>
        <trans-unit id="aa1294d7706be6aaf189751960c681d612b3e382" translate="yes" xml:space="preserve">
          <source>Another use for these enhancements is to obtain a binary log position that is consistent with a particular transactional state of the storage engine(s) in the database. This is done with two status variables for the binary log: &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_file&quot;&gt;binlog_snapshot_file&lt;/a&gt; and &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_position&quot;&gt;binlog_snapshot_position&lt;/a&gt;</source>
          <target state="translated">이러한 향상된 기능의 또 다른 용도는 데이터베이스에서 스토리지 엔진의 특정 트랜잭션 상태와 일치하는 이진 로그 위치를 얻는 것입니다. 이진 로그에 대한 두 가지 상태 변수 인 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_file&quot;&gt;binlog_snapshot_file&lt;/a&gt; 및 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#binlog_snapshot_position&quot;&gt;binlog_snapshot_position으로 수행됩니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d40afaca984bae53b97fc5547d784e3f5683ace5" translate="yes" xml:space="preserve">
          <source>Another use is to compare individuals against their group. Below is an example of how this might be executed:</source>
          <target state="translated">다른 용도는 개인을 그룹과 비교하는 것입니다. 아래는 이것이 어떻게 실행될 수 있는지에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="76c1758b60429833d5fd84f1160acf6f19349e3d" translate="yes" xml:space="preserve">
          <source>Another variant</source>
          <target state="translated">다른 변형</target>
        </trans-unit>
        <trans-unit id="28d8ab014eda1b02da1a676abcbfd23a61a1f775" translate="yes" xml:space="preserve">
          <source>Another warning message while installing Galera package is as shown below:</source>
          <target state="translated">Galera 패키지를 설치하는 동안 다른 경고 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0c8aac6a19a682a3c5a51583aa0e5a03fe05506" translate="yes" xml:space="preserve">
          <source>Another way is to detect the error is check the error log. When option parsing fails, it will contain messages like so:</source>
          <target state="translated">오류를 감지하는 또 다른 방법은 오류 로그를 확인하는 것입니다. 옵션 구문 분석이 실패하면 다음과 같은 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6be78e2902808782f3816b917567f31eb217b8" translate="yes" xml:space="preserve">
          <source>Another way to add an &lt;code&gt;apt&lt;/code&gt; repository is by creating a &lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man5/sources.list.5.html&quot;&gt;source list&lt;/a&gt; file in &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apt&lt;/code&gt; 저장소 를 추가하는 또 다른 방법 은 &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt; 에&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man5/sources.list.5.html&quot;&gt;소스 목록&lt;/a&gt; 파일을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="047a430646c00882c09925e75bbdbb78391b9d53" translate="yes" xml:space="preserve">
          <source>Another way to add an &lt;code&gt;apt&lt;/code&gt; repository is by using &lt;a href=&quot;https://help.ubuntu.com/community/SynapticHowto&quot;&gt;Synaptic Package Manager&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;apt&lt;/code&gt; 저장소 를 추가하는 또 다른 방법 은 &lt;a href=&quot;https://help.ubuntu.com/community/SynapticHowto&quot;&gt;Synaptic Package Manager를 사용하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f64e74f7f64abab454938c6a74e2bd7ac3f35763" translate="yes" xml:space="preserve">
          <source>Another way to add an &lt;code&gt;apt&lt;/code&gt; repository is by using &lt;a href=&quot;https://help.ubuntu.com/community/UbuntuSoftwareCenter&quot;&gt;Ubuntu Software Center&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;apt&lt;/code&gt; 저장소 를 추가하는 또 다른 방법 은 &lt;a href=&quot;https://help.ubuntu.com/community/UbuntuSoftwareCenter&quot;&gt;Ubuntu Software Center를 사용하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc5235d9018cb0422bf0d797cb16455c020f7df6" translate="yes" xml:space="preserve">
          <source>Another way to configure the error log file name is to set the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; option, which configures MariaDB to use a common prefix for all log files (e.g. &lt;a href=&quot;../general-query-log/index&quot;&gt;general query log&lt;/a&gt;, &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt;, error log, &lt;a href=&quot;../binary-log/index&quot;&gt;binary logs&lt;/a&gt;, etc.). The error log file name will be built by adding a &lt;code&gt;.err&lt;/code&gt; extension to this prefix. For example, if you configured the following, then the error log would still be written to &lt;code&gt;mariadb.err&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; directory:</source>
          <target state="translated">오류 로그 파일 이름을 구성하는 또 다른 방법 은 모든 로그 파일 (예 : &lt;a href=&quot;../general-query-log/index&quot;&gt;일반 쿼리 로그&lt;/a&gt; , &lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그&lt;/a&gt; , 오류 로그, &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 등)에 대해 공통 접두사를 사용하도록 MariaDB를 구성 하는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; 옵션 을 설정하는 것 입니다. 이 접두사에 &lt;code&gt;.err&lt;/code&gt; 확장자를 추가하여 오류 로그 파일 이름이 작성됩니다 . 예를 들어, 다음을 구성한 경우 오류 로그는 여전히 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 디렉토리의 &lt;code&gt;mariadb.err&lt;/code&gt; 에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb87317f2973e678fe2e9284c1da802bed59d045" translate="yes" xml:space="preserve">
          <source>Another way to configure the general query log filename is to set the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; option, which configures MariaDB to use a common prefix for all log files (e.g. general query log, &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt;, &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt;, &lt;a href=&quot;../binary-log/index&quot;&gt;binary logs&lt;/a&gt;, etc.). The general query log filename will be built by adding a &lt;code&gt;.log&lt;/code&gt; extension to this prefix. This option cannot be set dynamically. It can be set in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">일반 쿼리 로그 파일 이름을 구성하는 다른 방법 은 모든 로그 파일 (예 : 일반 쿼리 로그, &lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그&lt;/a&gt; , &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; , &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 등)에 대해 공통 접두사를 사용하도록 MariaDB를 구성 하는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; 옵션 을 설정하는 것 입니다. 일반 쿼리 로그 파일 이름은 이 접두사에 &lt;code&gt;.log&lt;/code&gt; 확장자를 추가하여 작성됩니다 . 이 옵션은 동적으로 설정할 수 없습니다. 서버 를 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bc1cb240d90530b50717ec72714fce79092c0e8" translate="yes" xml:space="preserve">
          <source>Another way to configure the slow query log filename is to set the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; option, which configures MariaDB to use a common prefix for all log files (e.g. slow query log, &lt;a href=&quot;../general-query-log/index&quot;&gt;general query log&lt;/a&gt;, &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt;, &lt;a href=&quot;../binary-log/index&quot;&gt;binary logs&lt;/a&gt;, etc.). The slow query log filename will be built by adding &lt;code&gt;-slow.log&lt;/code&gt; to this prefix. This option cannot be set dynamically. It can be set in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">느린 쿼리 로그 파일 이름을 구성하는 또 다른 방법은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-basename&quot;&gt;log-basename&lt;/a&gt;&lt;/code&gt; 옵션 을 설정하는 것입니다.이 옵션은 MariaDB가 모든 로그 파일에 공통 접두사를 사용하도록 구성합니다 (예 : 느린 쿼리 로그, &lt;a href=&quot;../general-query-log/index&quot;&gt;일반 쿼리 로그&lt;/a&gt; , &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; , &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 등). 느린 접두사 로그 파일 이름은 이 접두사에 &lt;code&gt;-slow.log&lt;/code&gt; 를 추가하여 작성됩니다 . 이 옵션은 동적으로 설정할 수 없습니다. 서버 를 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ac94a43914d66231c5e152addabf703921a3db3" translate="yes" xml:space="preserve">
          <source>Another way to do this is to create a table describing the file format we want before the &lt;code&gt;biblio3.json&lt;/code&gt; file existed:</source>
          <target state="translated">이를 수행하는 다른 방법은 &lt;code&gt;biblio3.json&lt;/code&gt; 파일이 존재 하기 전에 원하는 파일 형식을 설명하는 테이블을 작성하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7923fc76f389090b863f394a17366ffbbd2bb5c7" translate="yes" xml:space="preserve">
          <source>Another way to escape the quoting character is repeating it twice:</source>
          <target state="translated">인용 문자를 피하는 또 다른 방법은 두 번 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a08dcbaa740ee7d9fa898d82026bf7b3788e62ed" translate="yes" xml:space="preserve">
          <source>Another way to have the result set in memory is to use the memory option. This option can be set to the following values:</source>
          <target state="translated">결과를 메모리에 설정하는 또 다른 방법은 메모리 옵션을 사용하는 것입니다. 이 옵션은 다음 값으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0c13c22012aa9e5fa7be90c789794c727b1ae7" translate="yes" xml:space="preserve">
          <source>Another way to make the check is to look into &lt;code&gt;#rocksdb/LOG&lt;/code&gt; file in the data directory. It should have lines like:</source>
          <target state="translated">확인하는 또 다른 방법 은 데이터 디렉토리의 &lt;code&gt;#rocksdb/LOG&lt;/code&gt; 파일 을 보는 것 입니다. 다음과 같은 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="41829e4ed9296365ad570213722db4189eb71213" translate="yes" xml:space="preserve">
          <source>Another way to see JSON table column specifications is to use a catalogue table. For instance:</source>
          <target state="translated">JSON 테이블 열 스펙을 보는 다른 방법은 카탈로그 테이블을 사용하는 것입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="843bccd1e4db20a42f766372cbdb1f3c5517e82b" translate="yes" xml:space="preserve">
          <source>Another way to see multiple values is to ask CONNECT to make a comma separated list of the multiple node values. This time, it can only be done if the &quot;multiple&quot; node is not intermediate. For example, we can modify the &lt;em&gt;xsamp2&lt;/em&gt; table definition by:</source>
          <target state="translated">여러 값을 보는 또 다른 방법은 CONNECT에게 여러 노드 값의 쉼표로 구분 된 목록을 작성하도록 요청하는 것입니다. 이번에는 &quot;다중&quot;노드가 중간이 아닌 경우에만 수행 할 수 있습니다. 예를 들어 다음과 같이 &lt;em&gt;xsamp2&lt;/em&gt; 테이블 정의를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fc3ba707a736d4322d47ed8e36f7ca53e7820c" translate="yes" xml:space="preserve">
          <source>Another way to set a variable's value is the &lt;a href=&quot;../set-variable/index&quot;&gt;SET&lt;/a&gt; statement.</source>
          <target state="translated">변수 값을 설정하는 다른 방법은 &lt;a href=&quot;../set-variable/index&quot;&gt;SET&lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="484230069bab14a3804493b744bc82be0127659a" translate="yes" xml:space="preserve">
          <source>Another way to set the default database is specifying its name at &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt; command line client startup.</source>
          <target state="translated">기본 데이터베이스를 설정하는 또 다른 방법은 &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt; 명령 행 클라이언트 시작시 이름을 지정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a16a4eda7cb2c8e91d7edd25e809ae9d392c7498" translate="yes" xml:space="preserve">
          <source>Answer</source>
          <target state="translated">Answer</target>
        </trans-unit>
        <trans-unit id="8ee775bf993a6072eff2f1284e1818a75e193428" translate="yes" xml:space="preserve">
          <source>Answer &quot;Enter&quot; to all questions, except:</source>
          <target state="translated">다음을 제외한 모든 질문에 &quot;Enter&quot;라고 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="f072c69948329b717b85ba5f7eb7dfed49e18bf5" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-1029&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/1029&quot;&gt;Elena Stepanova&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_344&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-1029&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/1029&quot;&gt;엘레나 Stepanova&lt;/a&gt;&lt;/span&gt; 에서 &lt;a href=&quot;#comment_344&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-1029&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="606300365ae64661ab7be7ab2fd8e50d4a8ee62f" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-1085&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/1085&quot;&gt;Daniel Black&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_1412&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-1085&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/1085&quot;&gt;다니엘 블랙&lt;/a&gt;&lt;/span&gt; 에 &lt;a href=&quot;#comment_1412&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-1085&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="51441547059301f50d50f43c00bcb9edb183c46e" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-1368&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/1368&quot;&gt;Ian Gilfillan&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_3892&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-1368&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/1368&quot;&gt;이안 길 필란&lt;/a&gt;&lt;/span&gt; 에서 &lt;a href=&quot;#comment_3892&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-1368&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a3361182b635da7ffc715207c44653779b58e33f" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-27&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/27&quot;&gt;Sergei Golubchik&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_1124&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-27&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/27&quot;&gt;세르게이 Golubchik&lt;/a&gt;&lt;/span&gt; 에서 &lt;a href=&quot;#comment_1124&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-27&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="2959ff40b7db778187835cdfa8af32881add5836" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-982&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/982&quot;&gt;Federico Razzoli&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_1013&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-982&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/982&quot;&gt;페데리코 Razzoli&lt;/a&gt;&lt;/span&gt; 에서 &lt;a href=&quot;#comment_1013&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-982&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="99b851ee16c3afaaf599e92310ea9e9694d130e5" translate="yes" xml:space="preserve">
          <source>Answer Answered by &lt;span id=&quot;user-982&quot;&gt; &lt;a href=&quot;https://mariadb.com/kb/user/id/982&quot;&gt;Federico Razzoli&lt;/a&gt; &lt;/span&gt; in &lt;a href=&quot;#comment_705&quot;&gt;this comment&lt;/a&gt;.</source>
          <target state="translated">응답 답변 &lt;span id=&quot;user-982&quot;&gt;&lt;a href=&quot;https://mariadb.com/kb/user/id/982&quot;&gt;페데리코 Razzoli&lt;/a&gt;&lt;/span&gt; 에서 &lt;a href=&quot;#comment_705&quot;&gt;이 댓글&lt;/a&gt; .&lt;span id=&quot;user-982&quot;&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="ef99c61d925be50e1c69022b6d7c523f13ad905f" translate="yes" xml:space="preserve">
          <source>Antelope</source>
          <target state="translated">Antelope</target>
        </trans-unit>
        <trans-unit id="2900c0c23574cb672ccdcb6ed54cc45ba21ed24f" translate="yes" xml:space="preserve">
          <source>Antony</source>
          <target state="translated">Antony</target>
        </trans-unit>
        <trans-unit id="ba7c3f7e803f09bbfd52188cc77229d8ff3b920d" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;NULL&lt;/code&gt; values indicate that that particular timer is not available on your platform, Any timer names with a non-NULL value can be used in the &lt;a href=&quot;../performance-schema-setup_timers-table/index&quot;&gt;setup_timers&lt;/a&gt; table.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 값은 플랫폼에서 특정 타이머를 사용할 수 없음을 나타냅니다. NULL 이 아닌 값을 가진 모든 타이머 이름은 &lt;a href=&quot;../performance-schema-setup_timers-table/index&quot;&gt;setup_timers&lt;/a&gt; 테이블 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2601426007cc21b29e6491d2b7da9b333266b935" translate="yes" xml:space="preserve">
          <source>Any LDAP user in the LDAP group &lt;code&gt;dba&lt;/code&gt; should be mapped to the MariaDB user &lt;code&gt;dba&lt;/code&gt;. (&lt;code&gt;@dba: dba&lt;/code&gt;)</source>
          <target state="translated">LDAP 그룹 &lt;code&gt;dba&lt;/code&gt; 의 모든 LDAP 사용자 는 MariaDB 사용자 &lt;code&gt;dba&lt;/code&gt; 에 맵핑되어야합니다 . ( &lt;code&gt;@dba: dba&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ed6b34c5cb1234b76e7862a04fdc047360c32c2a" translate="yes" xml:space="preserve">
          <source>Any UPDATE, DELETE, etc with LIMIT that is replicated to slaves (via &lt;a href=&quot;../binary-log-formats/index&quot;&gt;Statement Based Replication&lt;/a&gt;) &lt;em&gt;may&lt;/em&gt; cause inconsistencies between the Master and Slaves. This is because the actual order of the records discovered for updating/deleting may be different on the slave, thereby leading to a different subset being modified. To be safe, add ORDER BY to such statements. Moreover, be sure the ORDER BY is deterministic -- that is, the fields/expressions in the ORDER BY are unique.</source>
          <target state="translated">DELETE 모든 UPDATE, 등 (을 통해 노예로 복제 LIMIT와 &lt;a href=&quot;../binary-log-formats/index&quot;&gt;문 기반 복제&lt;/a&gt; ) &lt;em&gt;할 수&lt;/em&gt; 마스터와 슬레이브 사이의 불일치가 발생할. 업데이트 / 삭제를 위해 검색된 레코드의 실제 순서가 슬레이브에서 다를 수 있기 때문에 다른 하위 집합이 수정 될 수 있기 때문입니다. 안전을 위해 해당 명령문에 ORDER BY를 추가하십시오. 또한 ORDER BY가 결정 론적이어야합니다. 즉, ORDER BY의 필드 / 표현식이 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="79ed21040aed65d113174dfbbada39caecc50f6c" translate="yes" xml:space="preserve">
          <source>Any Unix user in the Unix group &lt;code&gt;dba&lt;/code&gt; should be mapped to the MariaDB user &lt;code&gt;dba&lt;/code&gt;. (&lt;code&gt;@dba: dba&lt;/code&gt;)</source>
          <target state="translated">Unix 그룹 &lt;code&gt;dba&lt;/code&gt; 의 모든 Unix 사용자 는 MariaDB 사용자 &lt;code&gt;dba&lt;/code&gt; 에 맵핑되어야합니다 . ( &lt;code&gt;@dba: dba&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f52766ecdb621fa92cbf88c68cb57434fdf034dc" translate="yes" xml:space="preserve">
          <source>Any change to a query (even adding a space) leads (potentially) to a different entry in the QC.</source>
          <target state="translated">공백을 추가하더라도 쿼리가 변경되면 QC의 다른 항목으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6271137cf72a9563745f2d09cfc4933ec5f83ab3" translate="yes" xml:space="preserve">
          <source>Any command, for instance &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;, can be executed from the &lt;em&gt;crlite&lt;/em&gt; table:</source>
          <target state="translated">&lt;em&gt;crlite&lt;/em&gt; 테이블 에서 모든 명령 (예 : &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; )을 실행할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="074dcdf21adbe4cebe40ed7f862c357927594d5a" translate="yes" xml:space="preserve">
          <source>Any expression using &lt;a href=&quot;../functions-and-operators/index&quot;&gt;functions and operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../functions-and-operators/index&quot;&gt;함수와 연산자를&lt;/a&gt; 사용한 표현 .</target>
        </trans-unit>
        <trans-unit id="65943ff1ff135fca27bd142cf3856b391fce0160" translate="yes" xml:space="preserve">
          <source>Any field value of a flexible length type is not padded by 0 up to the maximal field size anymore.</source>
          <target state="translated">가변 길이 유형의 필드 값은 더 이상 최대 필드 크기까지 0으로 채워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da1930030535f55cbc82052da2a0b9f7e0a71e5b" translate="yes" xml:space="preserve">
          <source>Any of SQL expression that can be calculated from a single row fields is allowed. Subqueries are allowed. The AS keyword is allowed, so it is possible to use aliases.</source>
          <target state="translated">단일 행 필드에서 계산할 수있는 모든 SQL 표현식이 허용됩니다. 하위 쿼리가 허용됩니다. AS 키워드가 허용되므로 별명을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0d13b34d87e8ad39aaa1152ce005ed5881c35d" translate="yes" xml:space="preserve">
          <source>Any page from a file can be placed into a buffer of only one segment. The number of the segment is calculated from the file number and the position of the page in the file, and it's always the same for the page. Pages are evenly distributed among segments.</source>
          <target state="translated">파일의 모든 페이지는 한 세그먼트의 버퍼에만 배치 할 수 있습니다. 세그먼트 번호는 파일 번호와 파일의 페이지 위치에서 계산되며 페이지와 항상 동일합니다. 페이지는 세그먼트간에 고르게 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="95330bf100bc8635e4c53bb04cd6fe0eca5a52f0" translate="yes" xml:space="preserve">
          <source>Any statement trying to update any table</source>
          <target state="translated">테이블을 업데이트하려는 모든 명령문</target>
        </trans-unit>
        <trans-unit id="a584c1c07753462b979b0fc7cc8296a15806b41f" translate="yes" xml:space="preserve">
          <source>Any statements that return a result set are not permitted. For example, a regular &lt;a href=&quot;../select/index&quot;&gt;SELECTs&lt;/a&gt; is not permitted, but a &lt;a href=&quot;../select-into/index&quot;&gt;SELECT INTO&lt;/a&gt; is. A cursor and &lt;a href=&quot;../fetch/index&quot;&gt;FETCH&lt;/a&gt; statement is permitted.</source>
          <target state="translated">결과 집합을 반환하는 문장은 허용되지 않습니다. 예를 들어, 일반 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 는 허용되지 않지만 &lt;a href=&quot;../select-into/index&quot;&gt;SELECT INTO&lt;/a&gt; 는 허용됩니다 . 커서 및 &lt;a href=&quot;../fetch/index&quot;&gt;FETCH&lt;/a&gt; 문이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="85a6987e43a8f5ceedb792ce9ba73c1e6cb9e807" translate="yes" xml:space="preserve">
          <source>Any suggestions on how to speed this up?</source>
          <target state="translated">속도를 높이는 방법에 대한 제안 사항이 있습니까?</target>
        </trans-unit>
        <trans-unit id="90f649f46f4561acf197357caaeafc940717c5b1" translate="yes" xml:space="preserve">
          <source>Any table or view referred to in the definition must exist. However, after a view has been created, it is possible to drop a table or view that the definition refers to. In this case, use of the view results in an error. To check a view definition for problems of this kind, use the CHECK TABLE statement.</source>
          <target state="translated">정의에 언급 된 모든 테이블 또는 뷰가 존재해야합니다. 그러나보기가 작성된 후 정의가 참조하는 테이블이나보기를 h 제할 수 있습니다. 이 경우보기를 사용하면 오류가 발생합니다. 이러한 종류의 문제점에 대한보기 정의를 점검하려면 CHECK TABLE 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a145e4858801d5181d05b2d14550682c2e551869" translate="yes" xml:space="preserve">
          <source>Any tables containing UTF-8 data must have the default character set specified as 'utf8', for example:</source>
          <target state="translated">UTF-8 데이터를 포함하는 모든 테이블에는 'utf8'으로 지정된 기본 문자 세트가 있어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9a395c9491539c84b3f8bacaade59c1e7606b" translate="yes" xml:space="preserve">
          <source>Any tables named in the view definition must exist at definition time.</source>
          <target state="translated">뷰 정의에 이름이 지정된 테이블은 정의시 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="660224ac5d1a11a78219e4931b8afe5843b563a2" translate="yes" xml:space="preserve">
          <source>Any trailing spaces from &lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; values are discarded.</source>
          <target state="translated">&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; 값의 후행 공백 은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0f074fb51a226dec566adfaa3e27f5606c1ae484" translate="yes" xml:space="preserve">
          <source>Any transactional DML (INSERT/UPDATE/DELETE) is allowed to run in parallel, up to the limit of &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_domain_parallel_threads&quot;&gt;@@slave_domain_parallel_threads&lt;/a&gt;. This may cause conflicts on the slave, eg. if two transactions try to modify the same row. Any such conflict is detected, and the latter of the two transactions is rolled back, allowing the former to proceed. The latter transaction is then re-tried once the former has completed.</source>
          <target state="translated">모든 트랜잭션 DML (INSERT / UPDATE / DELETE)은 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_domain_parallel_threads&quot;&gt;@@ slave_domain_parallel_threads&lt;/a&gt; 한도까지 병렬로 실행할 수 있습니다. 예를 들어 슬레이브에 충돌이 발생할 수 있습니다. 두 트랜잭션이 동일한 행을 수정하려고하는 경우 이러한 충돌이 감지되면 두 트랜잭션 중 후자가 롤백되어 전자가 진행될 수 있습니다. 후자의 트랜잭션은 전자가 완료되면 다시 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="520d8b6d03e9ef9d7f1c21a7bf6d4cd828ba25a3" translate="yes" xml:space="preserve">
          <source>Any valid JSON value that is not one of the other types.</source>
          <target state="translated">다른 유형 중 하나가 아닌 유효한 JSON 값</target>
        </trans-unit>
        <trans-unit id="29e5b104221a5057fb3fc7610545e6869ca8f790" translate="yes" xml:space="preserve">
          <source>Anyone can vote for this to be fixed at &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10112&quot;&gt;https://jira.mariadb.org/browse/MDEV-10112&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10112&quot;&gt;https://jira.mariadb.org/browse/MDEV-10112&lt;/a&gt; 에서이 문제를 해결하기 위해 누구나 투표 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b943226915edc9570cdd2a55464811d2ec9d4225" translate="yes" xml:space="preserve">
          <source>Anything enclosed in the double quotes is taken as a whole (so you can match phrases, for example).</source>
          <target state="translated">큰 따옴표로 묶은 것은 전체로 간주되므로 구문과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9c93b10a558edc4c540ebb34b7fd9fae3d0232" translate="yes" xml:space="preserve">
          <source>Apache Spark (&lt;a href=&quot;http://spark.apache.org/&quot;&gt;http://spark.apache.org/&lt;/a&gt;) is a popular open source data processing engine. It can be integrated with MariaDB ColumnStore utilizing the Spark SQL feature.</source>
          <target state="translated">Apache Spark ( &lt;a href=&quot;http://spark.apache.org/&quot;&gt;http://spark.apache.org/&lt;/a&gt; )는 널리 사용되는 오픈 소스 데이터 처리 엔진입니다. Spark SQL 기능을 사용하여 MariaDB ColumnStore와 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d4ea699501e720d89370c741f4d5c5d7738afd" translate="yes" xml:space="preserve">
          <source>ApacheInterface</source>
          <target state="translated">ApacheInterface</target>
        </trans-unit>
        <trans-unit id="a254e3ea4440fa1ecc7940232f924fe7304a086b" translate="yes" xml:space="preserve">
          <source>Apart from testing, an example where this feature can be useful is a development scenario, where users want to run a 64 bit server and develop both 32 and 64 bit client components. In this case the full 64 bit package can be installed, including a database instance plus development-related features (headers and libraries) from the 32 bit package.</source>
          <target state="translated">테스트 외에도이 기능이 유용한 예는 사용자가 64 비트 서버를 실행하고 32 비트 및 64 비트 클라이언트 구성 요소를 모두 개발하려는 개발 시나리오입니다. 이 경우 데이터베이스 인스턴스와 32 비트 패키지의 개발 관련 기능 (헤더 및 라이브러리)을 포함하여 전체 64 비트 패키지를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169106d32c980bc99176d6c3bf294cf7c03a0cea" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;../rand/index&quot;&gt;RAND()&lt;/a&gt; to the rows</source>
          <target state="translated">&lt;a href=&quot;../rand/index&quot;&gt;RAND ()&lt;/a&gt; 를 행에 추가</target>
        </trans-unit>
        <trans-unit id="5827e3afa8d0e5ea51e415d117e8f4f3586d236f" translate="yes" xml:space="preserve">
          <source>Append everything into outfile. See interactive help (\h) also. Does not work in batch mode. Disable with &lt;code&gt;--disable-tee&lt;/code&gt;. This option is disabled by default.</source>
          <target state="translated">모든 것을 아웃 파일에 추가하십시오. 대화 형 도움말 (\ h)도 참조하십시오. 배치 모드에서는 작동하지 않습니다. &lt;code&gt;--disable-tee&lt;/code&gt; 로 비활성화하십시오 . 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1cc7939af1b1e58d2ad144e2536a52918889e4e" translate="yes" xml:space="preserve">
          <source>Append the &quot;Alias&quot; value you copied above to &lt;code&gt;alias/&lt;/code&gt; to use as the value for the &lt;code&gt;aws-key-management-master-key-id&lt;/code&gt; option.</source>
          <target state="translated">위에서 복사 한 &quot;별칭&quot;값을 &lt;code&gt;alias/&lt;/code&gt; 에 추가하여 &lt;code&gt;aws-key-management-master-key-id&lt;/code&gt; 옵션 의 값으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="511f1e885932b7584269d1c927807d9c6fff0f75" translate="yes" xml:space="preserve">
          <source>Appends values to the end of the given arrays within a JSON document</source>
          <target state="translated">JSON 문서 내에서 주어진 배열의 끝에 값을 추가합니다</target>
        </trans-unit>
        <trans-unit id="1b4f9caa8e9c5e37fc5745c1abd6f51c71eb4849" translate="yes" xml:space="preserve">
          <source>Appends values to the end of the given arrays within a JSON document.</source>
          <target state="translated">JSON 문서 내에서 주어진 배열의 끝에 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b82ae2a1a66c6a5e5326e9fd373b8536bdd56530" translate="yes" xml:space="preserve">
          <source>Appends values to the end of the specified arrays within a JSON document, returning the result, or NULL if any of the arguments are NULL.</source>
          <target state="translated">JSON 문서에서 지정된 배열의 끝에 값을 추가하여 결과를 반환하거나 인수가 NULL 인 경우 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="118fa88c9518652f34f9427f42c4f686b21d138c" translate="yes" xml:space="preserve">
          <source>Application log files are written to &lt;em&gt; /var/log/mariadb/columnstore&lt;/em&gt; on each server and log rotation / archiving is configured to manage these automatically.</source>
          <target state="translated">응용 프로그램 로그 파일은 각 서버의 &lt;em&gt;/ var / log / mariadb / columnstore&lt;/em&gt; 에 기록되며 로그 회전 / 아카이빙은 자동으로 관리하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bddb2eee9ae216d7fd4c6ef97343c18becb9b164" translate="yes" xml:space="preserve">
          <source>Application-time Periods</source>
          <target state="translated">신청 기간</target>
        </trans-unit>
        <trans-unit id="11df5dcfd6cc952bcbf87339bf4152ea59bfcbc6" translate="yes" xml:space="preserve">
          <source>Applies to &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt;, &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt;, and HTML files. Its meaning depends on the table type.</source>
          <target state="translated">&lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt; , &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; 및 HTML 파일에 적용됩니다 . 그 의미는 테이블 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9b2820e7832ade7a541e5d0124772d747c374886" translate="yes" xml:space="preserve">
          <source>Applies to table types:</source>
          <target state="translated">테이블 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7f66dcabcbbad8aa138fda6c5fe96f93c9616ef" translate="yes" xml:space="preserve">
          <source>Apply UNDO records to tables. (disable with --disable-undo) (Defaults to on; use --skip-undo to disable.)</source>
          <target state="translated">UNDO 레코드를 테이블에 적용하십시오. (--disable-undo로 비활성화) (기본값은 on; 비활성화하려면 --skip-undo를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="572f7086cc288d8ccf545e369b332cd5defe91fa" translate="yes" xml:space="preserve">
          <source>Apply log event</source>
          <target state="translated">로그 이벤트 적용</target>
        </trans-unit>
        <trans-unit id="f9719aea97963cda4fb7438365b6918e0109be34" translate="yes" xml:space="preserve">
          <source>Apply log to tables: modifies tables! you should make a backup first! Displays a lot of information if not run with --silent.</source>
          <target state="translated">테이블에 로그 적용 : 테이블을 수정합니다! 먼저 백업해야합니다! --silent로 실행하지 않으면 많은 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7961f135643d25c2f43412f83af8eabea3414cb6" translate="yes" xml:space="preserve">
          <source>Applying the fix</source>
          <target state="translated">수정 사항 적용</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="eb0e0e4ee9f2a883c639141d35c2dcd336b2d5cb" translate="yes" xml:space="preserve">
          <source>Arabic, Armenian, Avestan, Balinese, Bamum, Batak, Bengali, Bopomofo, Brahmi, Braille, Buginese, Buhid, Canadian_Aboriginal, Carian, Chakma, Cham, Cherokee, Common, Coptic, Cuneiform, Cypriot, Cyrillic, Deseret, Devanagari, Egyptian_Hieroglyphs, Ethiopic, Georgian, Glagolitic, Gothic, Greek, Gujarati, Gurmukhi, Han, Hangul, Hanunoo, Hebrew, Hiragana, Imperial_Aramaic, Inherited, Inscriptional_Pahlavi, Inscriptional_Parthian, Javanese, Kaithi, Kannada, Katakana, Kayah_Li, Kharoshthi, Khmer, Lao, Latin, Lepcha, Limbu, Linear_B, Lisu, Lycian, Lydian, Malayalam, Mandaic, Meetei_Mayek, Meroitic_Cursive, Meroitic_Hieroglyphs, Miao, Mongolian, Myanmar, New_Tai_Lue, Nko, Ogham, Old_Italic, Old_Persian, Old_South_Arabian, Old_Turkic, Ol_Chiki, Oriya, Osmanya, Phags_Pa, Phoenician, Rejang, Runic, Samaritan, Saurashtra, Sharada, Shavian, Sinhala, Sora_Sompeng, Sundanese, Syloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tai_Tham, Tai_Viet, Takri, Tamil, Telugu, Thaana, Thai, Tibetan, Tifinagh, Ugaritic, Vai, Yi.</source>
          <target state="translated">아랍어, 아르메니아어, Avestan, 발리 식, Bamum, 바 탁어, 벵골어, Bopomofo, Brahmi, 점자, Buginese, Buhid, Canadian_Aboriginal, Carian, Chakma, Cham, Cherokee, Common, Coptic, Cuneiform, 키프로스, 키릴 자모, Deseret, Devanagari, Egyptian_Hieroglyphs 에티오피아, 그루지야 어, Glagolitic, 고딕, 그리스어, 구자라트 어, Gurmukhi, 한, 한글, Hanunoo, 히브리어, 히라가나, Imperial_Aramaic, 상 속됨, Inscriptional_Pahlavi, 비문 _ 파르티아 어, 자바어, Kaithi, 칸나다어, 카타카나, 카야 리, Kharoshthi, 크메르어, 라오 어, 라오 어 Lepcha, Limbu, Linear_B, Lisu, Lycian, Lydian, Malayalam, Mandaic, Meetei_Mayek, Meroitic_Cursive, Meroitic_Hieroglyphs, Miao, Mongolian, Myanmar, New_Tai_Lue, Nko, Ogham, Old_Italic, Old_Persya, Old_Pasic, Old_South_Pa_A_ 오키 아 _ 오키 아 _ 오키 아 _ 오키나와 페니키아, 레장, 룬문자, 사마리아인, 소라 슈트라, 샤라 다, 샤 비안, 스리랑카,Sora_Sompeng, 순 다어, Syloti_Nagri, 시리아 어, 타갈로그어, Tagbanwa, Tai_Le, Tai_Tham, Tai_Viet, Takri, 타밀어, 텔루구 어, Thaana, 태국어, 티베트어, Tifinagh, 우가 리트 어, Vai, Yi.</target>
        </trans-unit>
        <trans-unit id="5ffe772c6bdf441b006c018b84cfd6551222a4b3" translate="yes" xml:space="preserve">
          <source>Archibald</source>
          <target state="translated">Archibald</target>
        </trans-unit>
        <trans-unit id="2621c6fd51a58e1d1d5c491aac71488647b20224" translate="yes" xml:space="preserve">
          <source>Archive</source>
          <target state="translated">Archive</target>
        </trans-unit>
        <trans-unit id="4690633b5d8da96614b721cb8fab6438a6d2ddda" translate="yes" xml:space="preserve">
          <source>Are index statistics predictable?</source>
          <target state="translated">인덱스 통계는 예측 가능합니까?</target>
        </trans-unit>
        <trans-unit id="cf4f46b84b2828a0b52b7f5f80133e332a29572e" translate="yes" xml:space="preserve">
          <source>Are storage engines designed for MySQL compatible with MariaDB?</source>
          <target state="translated">MySQL 용으로 설계된 스토리지 엔진은 MariaDB와 호환됩니까?</target>
        </trans-unit>
        <trans-unit id="b12488e12a01d15cc08465ceebb82fefb428971b" translate="yes" xml:space="preserve">
          <source>Are storage engines designed for MySQL compatible with MariaDB? In most cas...</source>
          <target state="translated">MySQL 용으로 설계된 스토리지 엔진은 MariaDB와 호환됩니까? 대부분의 경우 ...</target>
        </trans-unit>
        <trans-unit id="e40fc7460f73ff21f084cceaa5659a419592b6ca" translate="yes" xml:space="preserve">
          <source>Are there minimum Spider settings?</source>
          <target state="translated">최소 스파이더 설정이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2745debaa64a20eedb49d9f14a0b807c87aa2d2a" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="translated">Area</target>
        </trans-unit>
        <trans-unit id="2307e9ee6aeddbde6ab372c969806e69a282cbe4" translate="yes" xml:space="preserve">
          <source>Area of a Polygon</source>
          <target state="translated">다각형의 면적</target>
        </trans-unit>
        <trans-unit id="1620c142cc85012ee1ad185407920d821366d6d0" translate="yes" xml:space="preserve">
          <source>Area of a Polygon.</source>
          <target state="translated">다각형의 면적.</target>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="37fd3cd873c71dcbb4eb5b5f5ce567631898d130" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALTER SEQUENCE&lt;/code&gt; 을위한 인수</target>
        </trans-unit>
        <trans-unit id="3de5522edf9e3ec5d7cf0c11e8e669ebd8e43ee9" translate="yes" xml:space="preserve">
          <source>Arguments to Create</source>
          <target state="translated">만들 인수</target>
        </trans-unit>
        <trans-unit id="eac677dd94c442abffeabc554e52b2a31856b934" translate="yes" xml:space="preserve">
          <source>Aria</source>
          <target state="translated">Aria</target>
        </trans-unit>
        <trans-unit id="78a9c12d5527e486a382e0dc04bb8f6f4ec0e5e6" translate="yes" xml:space="preserve">
          <source>Aria 1.0 was basically a crash-safe non-transactional version of MyISAM. Aria 1.5 added more concurrency (multiple inserter) and some optimizations.</source>
          <target state="translated">Aria 1.0은 기본적으로 충돌에 안전한 비 트랜잭션 버전의 MyISAM입니다. Aria 1.5는 더 많은 동시성 (다중 삽입 기)과 일부 최적화를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c14140e9286ba4988d818c55b894c303e4452fb9" translate="yes" xml:space="preserve">
          <source>Aria Clients and Utilities</source>
          <target state="translated">아리아 클라이언트 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="570c927653941f84d0d0d36918f6cd2abb30c39a" translate="yes" xml:space="preserve">
          <source>Aria Disabling Encryption</source>
          <target state="translated">Aria 비활성화 암호화</target>
        </trans-unit>
        <trans-unit id="598c95736d320fd73e1b1db2e3b45c9e81928341" translate="yes" xml:space="preserve">
          <source>Aria Enabling Encryption</source>
          <target state="translated">Aria 지원 암호화</target>
        </trans-unit>
        <trans-unit id="c2bbacea3665ed42337c4ddd8fc3f50c5778cd0a" translate="yes" xml:space="preserve">
          <source>Aria Encryption</source>
          <target state="translated">아리아 암호화</target>
        </trans-unit>
        <trans-unit id="c317c176fc803358acc993645edbb3c777369935" translate="yes" xml:space="preserve">
          <source>Aria Encryption Keys</source>
          <target state="translated">아리아 암호화 키</target>
        </trans-unit>
        <trans-unit id="705356b38c47052ed3d549119221ee32a5edbe8e" translate="yes" xml:space="preserve">
          <source>Aria Encryption Overview</source>
          <target state="translated">Aria 암호화 개요</target>
        </trans-unit>
        <trans-unit id="9f77a8823b29e8ae696f42be19ccf5085c1031ba" translate="yes" xml:space="preserve">
          <source>Aria FAQ</source>
          <target state="translated">아리아 FAQ</target>
        </trans-unit>
        <trans-unit id="d0f3db0a1c12613164925412f53f80bb1bd478c3" translate="yes" xml:space="preserve">
          <source>Aria Group Commit</source>
          <target state="translated">아리아 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="e0251c358e0f5d2ef585f527bcac9758309dc56e" translate="yes" xml:space="preserve">
          <source>Aria Spatial Indexes</source>
          <target state="translated">아리아 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="89e88830c0020788136fcb3d00b0e1acdfe83525" translate="yes" xml:space="preserve">
          <source>Aria Status Variables</source>
          <target state="translated">아리아 상태 변수</target>
        </trans-unit>
        <trans-unit id="087704a2fe3edc12c0ba51d86c7a07074bc2dd55" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine</source>
          <target state="translated">아리아 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="1862622e3a65f62918a72983e7b275883b01752b" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine Options</source>
          <target state="translated">아리아 스토리지 엔진 옵션</target>
        </trans-unit>
        <trans-unit id="fdecb941c1641d8d57d50f0aa467f6ce8943c826" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine Options and System Variables</source>
          <target state="translated">Aria 스토리지 엔진 옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="153aeaeb86ca6c80ccb8afc95f2d49b2971def19" translate="yes" xml:space="preserve">
          <source>Aria Storage Formats</source>
          <target state="translated">아리아 스토리지 형식</target>
        </trans-unit>
        <trans-unit id="0f1d82a64f4a3635de204fac99b2095a3d9c3299" translate="yes" xml:space="preserve">
          <source>Aria System Variables</source>
          <target state="translated">아리아 시스템 변수</target>
        </trans-unit>
        <trans-unit id="e482a118b83fe064c7ac36aec236a818a2a72679" translate="yes" xml:space="preserve">
          <source>Aria Two-step Deadlock Detection</source>
          <target state="translated">아리아 2 단계 교착 상태 탐지</target>
        </trans-unit>
        <trans-unit id="21ff6a27d4ae930a834f96e56dbb7f7dba2969d4" translate="yes" xml:space="preserve">
          <source>Aria benchmarks</source>
          <target state="translated">아리아 벤치 마크</target>
        </trans-unit>
        <trans-unit id="82b275d94da27fbfee110579992cf4e3c5693922" translate="yes" xml:space="preserve">
          <source>Aria can replay almost everything from the log. (Including &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt; tables). Therefore, you make a backup of Aria by just copying the log. The things that can't be replayed (yet) are:</source>
          <target state="translated">Aria는 로그에서 거의 모든 것을 재생할 수 있습니다. ( &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;DROP&lt;/code&gt; , &lt;code&gt;RENAME&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; 테이블 포함). 따라서 로그를 복사하여 Aria를 백업하십시오. 재생할 수없는 것 (아직)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2809b2e93a78030248d3ea3dfffe7a2917cded5" translate="yes" xml:space="preserve">
          <source>Aria data pages in block format have an overhead of 10 bytes/page and 5 bytes/row. Transaction and multiple concurrent-writer support will use an extra overhead of 7 bytes for new rows, 14 bytes for deleted rows and 0 bytes for old compacted rows.</source>
          <target state="translated">블록 형식의 Aria 데이터 페이지는 10 바이트 / 페이지 및 5 바이트 / 행의 오버 헤드를 갖습니다. 트랜잭션 및 다중 동시 작성기 지원은 새 행의 경우 7 바이트, 삭제 된 행의 경우 14 바이트, 오래된 압축 행의 경우 0 바이트의 추가 오버 헤드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="90d6f1d2cc0a3efafa248b67cc86781b6f63ce88" translate="yes" xml:space="preserve">
          <source>Aria does not currently support the &lt;code&gt;ENCRYPTED&lt;/code&gt; table option. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049&lt;/a&gt; about that.</source>
          <target state="translated">Aria는 현재 &lt;code&gt;ENCRYPTED&lt;/code&gt; 테이블 옵션을 지원하지 않습니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f08d171742ee5d81095f143fa327159458b62f5" translate="yes" xml:space="preserve">
          <source>Aria does not currently support the &lt;code&gt;ENCRYPTION_KEY_ID&lt;/code&gt; table option. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049&lt;/a&gt; about that.</source>
          <target state="translated">Aria는 현재 &lt;code&gt;ENCRYPTION_KEY_ID&lt;/code&gt; 테이블 옵션을 지원하지 않습니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a818f6820a1b0b346af4213d5e073dede7e89be" translate="yes" xml:space="preserve">
          <source>Aria does not support multiple key caches.</source>
          <target state="translated">Aria는 여러 키 캐시를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff8cdd216d80b943a797ffad28af356f0a9540bc" translate="yes" xml:space="preserve">
          <source>Aria doesn't support &lt;code&gt;INSERT DELAYED&lt;/code&gt;.</source>
          <target state="translated">Aria는 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bf96ecdf4fa80c8e0d6ffa9a6fd99453039d4ee" translate="yes" xml:space="preserve">
          <source>Aria doesn't support MySQL internal RAID (disabled in MyISAM too, it's a deprecated feature).</source>
          <target state="translated">Aria는 MySQL 내부 RAID를 지원하지 않습니다 (MyISAM에서도 비활성화되어 더 이상 사용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="84b88241ce94dfb642a71a2ca1233ad7cadd1b4c" translate="yes" xml:space="preserve">
          <source>Aria doesn't support indexes on virtual fields.</source>
          <target state="translated">Aria는 가상 필드의 인덱스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72acd7640ecf3cf66e17447f2f7f679edb749d40" translate="yes" xml:space="preserve">
          <source>Aria follows the same &lt;a href=&quot;../release-criteria/index&quot;&gt;release criteria&lt;/a&gt; as for &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt;. Some clarifications, unique for the Aria storage engine:</source>
          <target state="translated">Aria 는 &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 와 동일한 &lt;a href=&quot;../release-criteria/index&quot;&gt;릴리스 기준&lt;/a&gt; 을 따릅니다 . Aria 스토리지 엔진에 고유 한 몇 가지 설명 :</target>
        </trans-unit>
        <trans-unit id="4094f5ede256f52158ea9ed0e4059dbcc9f42e07" translate="yes" xml:space="preserve">
          <source>Aria group commits for speeding up multi-user inserts</source>
          <target state="translated">다중 사용자 삽입 속도를 높이기위한 Aria 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="e3a9fc0e278ba0fc6c5d89420b1b85fbf40e2d8f" translate="yes" xml:space="preserve">
          <source>Aria has a log control file (&lt;code&gt;aria_log_control&lt;/code&gt;) and log files (&lt;code&gt;aria_log.%&lt;/code&gt;). The log files can be automatically purged when not needed or purged on demand (after backup).</source>
          <target state="translated">Aria에는 로그 제어 파일 ( &lt;code&gt;aria_log_control&lt;/code&gt; )과 로그 파일 ( &lt;code&gt;aria_log.%&lt;/code&gt; )이 있습니다. 로그 파일은 필요하지 않거나 필요에 따라 (백업 후) 제거 할 때 자동으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1531544b5981032325f5ea6c2c51bef7d4eafe68" translate="yes" xml:space="preserve">
          <source>Aria has one page size for both index and data (defined when Aria is used the first time). MyISAM supports different page sizes per index.</source>
          <target state="translated">Aria는 인덱스와 데이터 모두에 대해 하나의 페이지 크기를 갖습니다 (Aria를 처음 사용할 때 정의). MyISAM은 인덱스마다 다른 페이지 크기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d529a4a0c64df33c5268e83052b2eada09202ff7" translate="yes" xml:space="preserve">
          <source>Aria has unit tests of most parts.</source>
          <target state="translated">Aria는 대부분의 부품에 대한 단위 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="86e0fb1fcb51b848cdfdb970c6e5ed2e15513712" translate="yes" xml:space="preserve">
          <source>Aria index and data file formats should be backwards and forwards compatible to ensure easy upgrades and downgrades.</source>
          <target state="translated">Aria 인덱스 및 데이터 파일 형식은 쉽게 업그레이드 및 다운 그레이드 할 수 있도록 이전 버전과 이전 버전과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="229aa38bcc94584b5fe2340d122a304a75c24708" translate="yes" xml:space="preserve">
          <source>Aria is a crash safe MyISAM and more.</source>
          <target state="translated">Aria는 응급 안전 MyISAM 등입니다.</target>
        </trans-unit>
        <trans-unit id="2bc0e98fd10728be0e2dfdea51184c0d4cb20a2e" translate="yes" xml:space="preserve">
          <source>Aria is a storage engine for MySQL&amp;reg; and MariaDB. It was originally developed with the goal of becoming the default transactional &lt;strong&gt;and&lt;/strong&gt; non-transactional storage engine for MariaDB and MySQL.</source>
          <target state="translated">Aria는 MySQL&amp;reg; 및 MariaDB 용 스토리지 엔진입니다. 원래 MariaDB 및 MySQL 의 기본 트랜잭션 &lt;strong&gt;및&lt;/strong&gt; 트랜잭션이 아닌 스토리지 엔진 이 될 목적으로 개발되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ad750142814efbc8dc7032e5769b2a6f4698ef8a" translate="yes" xml:space="preserve">
          <source>Aria is now feature complete according to specification.</source>
          <target state="translated">Aria는 이제 사양에 따라 완성 된 기능입니다.</target>
        </trans-unit>
        <trans-unit id="483b7570c855ad4214b53f784c1f242d4188d1f3" translate="yes" xml:space="preserve">
          <source>Aria storage engine</source>
          <target state="translated">아리아 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="9d1bb64b5d20695228f2b209543c9a86ea62cab3" translate="yes" xml:space="preserve">
          <source>Aria supports all aspects of MyISAM, except as noted below. This includes external and internal check/repair/compressing of rows, different row formats, different index compress formats, &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk&lt;/a&gt;&lt;/code&gt; etc. After a normal shutdown you can copy Aria files between servers.</source>
          <target state="translated">Aria는 아래 언급 된 것을 제외하고 MyISAM의 모든 측면을 지원합니다. 여기에는 행의 외부 및 내부 검사 / 복구 / 압축, 다른 행 형식, 다른 인덱스 압축 형식, &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk&lt;/a&gt;&lt;/code&gt; 등이 포함됩니다. 정상적인 종료 후 서버간에 Aria 파일을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad2a49517bc90ab1960801c2d05a793e37e1af6" translate="yes" xml:space="preserve">
          <source>Aria table information is stored in 2 files: the &lt;code&gt;.MAI&lt;/code&gt; file contains base table information and the index and the &lt;code&gt;.MAD&lt;/code&gt; file contains the data. &lt;code&gt;aria_chk&lt;/code&gt; takes one or more &lt;code&gt;.MAI&lt;/code&gt; files as arguments.</source>
          <target state="translated">Aria 테이블 정보는 2 개의 파일로 저장됩니다. &lt;code&gt;.MAI&lt;/code&gt; 파일은 기본 테이블 정보를 포함하고 인덱스 및 &lt;code&gt;.MAD&lt;/code&gt; 파일은 데이터를 포함합니다. &lt;code&gt;aria_chk&lt;/code&gt; 는 하나 이상의 &lt;code&gt;.MAI&lt;/code&gt; 파일을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf50d6b60ac46faab0e14dcfbf8146c7dcd3ad14" translate="yes" xml:space="preserve">
          <source>Aria uses 8K pages by default (MyISAM uses 1K). This makes Aria a bit faster when using keys of fixed size, but slower when using variable-length packed keys (until we add a directory to index pages).</source>
          <target state="translated">Aria는 기본적으로 8K 페이지를 사용합니다 (MyISAM은 1K 사용). 이렇게하면 고정 크기의 키를 사용할 때 Aria가 약간 빨라지지만 가변 길이 팩 키를 사용할 때는 속도가 느려집니다 (인덱스 페이지에 디렉토리를 추가 할 때까지).</target>
        </trans-unit>
        <trans-unit id="aeccfa0ed52ae84bae8e9d8a67d255d8ad5832ea" translate="yes" xml:space="preserve">
          <source>Aria uses BIG (1G by default) log files.</source>
          <target state="translated">Aria는 BIG (기본적으로 1G) 로그 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f661604d8c0d7185172fc95f20e0a047f734b0a2" translate="yes" xml:space="preserve">
          <source>Aria will automatically notice if you have copied a table from another system and do 'zerofill' for the first access of the table if it was not marked as 'movable'. The reason for using &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk --zerofill&lt;/a&gt;&lt;/code&gt; is that you avoid a delay in the MariaDB server for the first access of the table.</source>
          <target state="translated">Aria는 다른 시스템에서 테이블을 복사했는지 자동으로 확인하고 테이블이 '이동 가능'으로 표시되지 않은 경우 테이블의 첫 번째 액세스에 대해 'zerofill'을 수행합니다. &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk --zerofill&lt;/a&gt;&lt;/code&gt; 을 사용하는 이유 는 MariaDB 서버에서 테이블에 처음 액세스 할 때 지연이 발생하지 않기 때문입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
