<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="a2e57a1ae65a922826eaf670ff96699c999ec68c" translate="yes" xml:space="preserve">
          <source>User-Defined Functions</source>
          <target state="translated">사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="6a1e597e463b3f50297bfce3124ee20b9191c796" translate="yes" xml:space="preserve">
          <source>User-Defined Functions Calling Sequences</source>
          <target state="translated">사용자 정의 함수 호출 시퀀스</target>
        </trans-unit>
        <trans-unit id="d8e88e5b3ebbbbd5bddbaa90964c4d0ce09f048f" translate="yes" xml:space="preserve">
          <source>User-Defined Functions Security</source>
          <target state="translated">사용자 정의 함수 보안</target>
        </trans-unit>
        <trans-unit id="f439a2255bfd675c7ace5475050ff9826b49352e" translate="yes" xml:space="preserve">
          <source>User-Defined Variables</source>
          <target state="translated">사용자 정의 변수</target>
        </trans-unit>
        <trans-unit id="3e428aaf56bce831485428acd7d7d12c858fd641" translate="yes" xml:space="preserve">
          <source>User-Defined variables</source>
          <target state="translated">사용자 정의 변수</target>
        </trans-unit>
        <trans-unit id="e6e78b09aea12b67182a2ef1258d9414ffe5d719" translate="yes" xml:space="preserve">
          <source>User-defined Functions Calling Sequences</source>
          <target state="translated">사용자 정의 함수 호출 시퀀스</target>
        </trans-unit>
        <trans-unit id="81a87659a11030a831b199f405f4684301735cab" translate="yes" xml:space="preserve">
          <source>User-defined function information</source>
          <target state="translated">사용자 정의 함수 정보</target>
        </trans-unit>
        <trans-unit id="acd2cfda419df68ac16d60a9b1ae9e3f3ddbaf87" translate="yes" xml:space="preserve">
          <source>User-defined functions available with the Spider storage engine.</source>
          <target state="translated">Spider 스토리지 엔진에서 사용 가능한 사용자 정의 기능.</target>
        </trans-unit>
        <trans-unit id="13bdd1aeacf2b0abd3264de64e17621da0ecfcdf" translate="yes" xml:space="preserve">
          <source>User-defined variable information.</source>
          <target state="translated">사용자 정의 변수 정보.</target>
        </trans-unit>
        <trans-unit id="57c977e407b99da4b5041b7886eae070050673cc" translate="yes" xml:space="preserve">
          <source>User-defined variables are variables which can be created by the user and exist in the session. This means that no one can access user-defined variables that have been set by another user, and when the session is closed these variables expire. However, these variables can be shared between several queries and &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;stored programs&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 변수는 사용자가 만들 수 있고 세션에 존재하는 변수입니다. 즉, 다른 사용자가 설정 한 사용자 정의 변수에 아무도 액세스 할 수 없으며 세션이 닫히면 이러한 변수가 만료됩니다. 그러나 이러한 변수는 여러 쿼리와 &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;저장된 프로그램&lt;/a&gt; 간에 공유 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd0486d2696e50f6a33df5481bd02ec17c2cce67" translate="yes" xml:space="preserve">
          <source>User-defined variables can be used in most MariaDB's statements and clauses which accept an SQL expression. However there are some exceptions, like the &lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT&lt;/a&gt; clause.</source>
          <target state="translated">사용자 정의 변수는 SQL 표현식을 허용하는 대부분의 MariaDB 명령문 및 절에서 사용할 수 있습니다. 그러나 &lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT&lt;/a&gt; 절 과 같은 일부 예외가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac6041bab2aebc0ce0cbfe160f287209e266c064" translate="yes" xml:space="preserve">
          <source>User-defined variables cannot be declared. They can be read even if no value has been set yet; in that case, they are NULL. To set a value for a user-defined variable you can use:</source>
          <target state="translated">사용자 정의 변수를 선언 할 수 없습니다. 아직 값을 설정하지 않은 경우에도 읽을 수 있습니다. 이 경우에는 NULL입니다. 사용자 정의 변수의 값을 설정하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18061895b40cbe57739f969751d8c53f23a14f1" translate="yes" xml:space="preserve">
          <source>User-defined variables names must be preceded by a single &lt;em&gt;at&lt;/em&gt; character (&lt;code&gt;@&lt;/code&gt;). While it is safe to use a reserved word as a user-variable name, the only allowed characters are ASCII letters, digits, dollar sign (&lt;code&gt;$&lt;/code&gt;), underscore (&lt;code&gt;_&lt;/code&gt;) and dot (&lt;code&gt;.&lt;/code&gt;). If other characters are used, the name can be quoted in one of the following ways:</source>
          <target state="translated">사용자 정의 변수 이름 앞에는 단일 &lt;em&gt;at&lt;/em&gt; 문자 ( &lt;code&gt;@&lt;/code&gt; ) 가 와야합니다 . 예약어를 사용자 변수 이름으로 사용하는 것이 안전하지만 ASCII 문자, 숫자, 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ), 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 및 점 ( &lt;code&gt;.&lt;/code&gt; ) 만 허용됩니다. 다른 문자를 사용하는 경우 다음 방법 중 하나로 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c087c598743ec874445a29683b814a6cfd87de83" translate="yes" xml:space="preserve">
          <source>User-variables names are case insensitive, though they were case sensitive in MySQL 4.1 and older versions.</source>
          <target state="translated">사용자 변수 이름은 대소 문자를 구분하지 않지만 MySQL 4.1 및 이전 버전에서는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="32d46315969c8d6acb93be0ddaa0e32a205b0aab" translate="yes" xml:space="preserve">
          <source>User. Used together with &lt;code&gt;EVENT_NAME&lt;/code&gt; for grouping events.</source>
          <target state="translated">사용자. 이벤트를 그룹화하기 위해 &lt;code&gt;EVENT_NAME&lt;/code&gt; 과 함께 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="6fcb2ff98033bdca1c55ef6a3a4dc775a45ac7b2" translate="yes" xml:space="preserve">
          <source>User. Used together with &lt;code&gt;HOST&lt;/code&gt; and &lt;code&gt;EVENT_NAME&lt;/code&gt; for grouping events.</source>
          <target state="translated">사용자. 이벤트를 그룹화하기 위해 &lt;code&gt;HOST&lt;/code&gt; 및 &lt;code&gt;EVENT_NAME&lt;/code&gt; 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="79cc0aaceb16e643fbc843251935b70200e0d9b8" translate="yes" xml:space="preserve">
          <source>Username for logging in to the db.</source>
          <target state="translated">db에 로그인하기위한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="87491c9d490da1437121474180493fb83d1e49bc" translate="yes" xml:space="preserve">
          <source>Username.</source>
          <target state="translated">Username.</target>
        </trans-unit>
        <trans-unit id="742dd1ddd4733507bebd055ec38a83f4c89dd18d" translate="yes" xml:space="preserve">
          <source>Username/host that authenicated the current client</source>
          <target state="translated">현재 클라이언트를 인증 한 사용자 이름 / 호스트</target>
        </trans-unit>
        <trans-unit id="a59a5ebca2b0dce27bc55382c983ef94ca706507" translate="yes" xml:space="preserve">
          <source>Username/host that authenicated the current client.</source>
          <target state="translated">현재 클라이언트를 인증 한 사용자 이름 / 호스트입니다.</target>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="1c511ceffb0d14bed34babd214cb8944eecf6c15" translate="yes" xml:space="preserve">
          <source>Users and Groups Created</source>
          <target state="translated">생성 된 사용자 및 그룹</target>
        </trans-unit>
        <trans-unit id="78f07e76e514e92fda20c99b19f149d0a5ab6c3d" translate="yes" xml:space="preserve">
          <source>Users can instruct the &lt;code&gt;pam&lt;/code&gt; authentication plugin to use the &lt;code&gt;mysql_clear_password&lt;/code&gt; client authentication plugin instead of the &lt;code&gt;&lt;a href=&quot;#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; client authentication plugin by configuring the &lt;code&gt;&lt;a href=&quot;#pam_use_cleartext_plugin&quot;&gt;pam_use_cleartext_plugin&lt;/a&gt;&lt;/code&gt; system variable on the server. It can be set in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">사용자는 서버 에서 &lt;code&gt;&lt;a href=&quot;#pam_use_cleartext_plugin&quot;&gt;pam_use_cleartext_plugin&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 &lt;code&gt;&lt;a href=&quot;#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; 클라이언트 인증 플러그인 대신 &lt;code&gt;mysql_clear_password&lt;/code&gt; 클라이언트 인증 플러그인을 사용 하도록 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인에 지시 할 수 있습니다 . &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f1ece22c30c5d65530ffc957a717898e73293bf" translate="yes" xml:space="preserve">
          <source>Users can view the query statistics by selecting the rows from the query stats table in the infinidb_querystats schema. Examples listed below:</source>
          <target state="translated">사용자는 infinidb_querystats 스키마의 query stats 테이블에서 행을 선택하여 쿼리 통계를 볼 수 있습니다. 아래에 열거 된 예 :</target>
        </trans-unit>
        <trans-unit id="607c414d04348c264535d458f15f6fa320dd1140" translate="yes" xml:space="preserve">
          <source>Users have a maximum length of 80 characters.</source>
          <target state="translated">사용자는 최대 80 자입니다.</target>
        </trans-unit>
        <trans-unit id="1b047d582fe969d9e89416281bda6af8e463757f" translate="yes" xml:space="preserve">
          <source>Users of &quot;big&quot; database systems are used to using &lt;code&gt;FROM&lt;/code&gt; subqueries as a way to structure their queries. For example, if one's first thought was to select cities with population greater than 10,000 people, and then that from these cities to select those that are located in Germany, one could write this SQL:</source>
          <target state="translated">&quot;큰&quot;데이터베이스 시스템 사용자는 쿼리를 구성하는 방법으로 &lt;code&gt;FROM&lt;/code&gt; 서브 쿼리 를 사용하는 데 익숙 합니다. 예를 들어, 인구가 10,000 명 이상인 도시를 처음으로 선택한 다음이 도시에서 독일에있는 도시를 선택하는 것이 처음이라면 다음 SQL을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca5de2c3c3ecfb0b9567f729aec2409a90b6dc98" translate="yes" xml:space="preserve">
          <source>Users of data-at-rest encryption will also need to have a &lt;a href=&quot;../encryption-key-management/index&quot;&gt;key management and encryption plugin&lt;/a&gt; configured. Some examples are &lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;File Key Management Plugin&lt;/a&gt; and &lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;AWS Key Management Plugin&lt;/a&gt;.</source>
          <target state="translated">미사용 데이터 암호화 사용자는 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;키 관리 및 암호화 플러그인을&lt;/a&gt; 구성해야합니다. 몇 가지 예는 &lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;File Key Management Plugin&lt;/a&gt; 및 &lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;AWS Key Management Plugin&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca9dc9a74891fe1e812091ca73de872ef2fe47eb" translate="yes" xml:space="preserve">
          <source>Uses Groonga's normalizer to normalize text.</source>
          <target state="translated">Groonga의 노멀 라이저를 사용하여 텍스트를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="57ccf4ff320df1dc241ffe88ac61963e1578a428" translate="yes" xml:space="preserve">
          <source>Uses IP addresses rather than host names when creating grant table entries. This option can be useful if your DNS does not work.</source>
          <target state="translated">권한 부여 테이블 항목을 작성할 때 호스트 이름 대신 IP 주소를 사용합니다. 이 옵션은 DNS가 작동하지 않는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f746d279f50de317b98270cf5e5882a47f8d3dad" translate="yes" xml:space="preserve">
          <source>Uses a massively parallel architecture, ideal for systems that scale to petabytes of data.</source>
          <target state="translated">페타 바이트 규모의 데이터로 확장되는 시스템에 이상적인 대규모 병렬 아키텍처를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad99ed3dfcab18af1de6eea489962f7fe604832f" translate="yes" xml:space="preserve">
          <source>Uses for partitioning</source>
          <target state="translated">파티셔닝 용도</target>
        </trans-unit>
        <trans-unit id="7f5afc99ec01d26e90bb40869a6c94ff2f099925" translate="yes" xml:space="preserve">
          <source>Uses for this function could include creating for example a new geometry representing a buffer zone around an island.</source>
          <target state="translated">이 기능의 사용에는 섬 주변의 버퍼 영역을 나타내는 새 형상을 작성하는 것이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb269599382ce92bfe5a729d4efd94949955659" translate="yes" xml:space="preserve">
          <source>Uses old recovery method; Slower than '-r' but can handle a couple of cases where '-r' reports that it can't fix the data file.</source>
          <target state="translated">오래된 복구 방법을 사용합니다. '-r'보다 느리지 만 '-r'이 데이터 파일을 수정할 수 없다고보고하는 몇 가지 경우를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5dde2e1eca5172aba62eb6034a51dbb93a8280b7" translate="yes" xml:space="preserve">
          <source>Uses old recovery method; Slower than '-r' but uses less disk space and can handle a couple of cases where '-r' reports that it can't fix the data file. Increase &lt;em&gt;key_buffer_size&lt;/em&gt; for better performance.</source>
          <target state="translated">오래된 복구 방법을 사용합니다. '-r'보다 느리지 만 디스크 공간을 적게 사용하며 '-r'이 데이터 파일을 수정할 수 없다고보고하는 몇 가지 경우를 처리 할 수 ​​있습니다. 성능 향상을 위해 &lt;em&gt;key_buffer_size&lt;/em&gt; 를 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="72b0efbd5e43a1c2d9498dec192817678ba381f8" translate="yes" xml:space="preserve">
          <source>Uses the Elliptic Curve Digital Signature Algorithm to securely store users' passwords.</source>
          <target state="translated">타원 곡선 디지털 서명 알고리즘을 사용하여 사용자 암호를 안전하게 저장합니다.</target>
        </trans-unit>
        <trans-unit id="01b1fd314ff96dc65945c83759b8265e62548e7c" translate="yes" xml:space="preserve">
          <source>Uses the Pluggable Authentication Module (PAM) framework to authenticate MariaDB users.</source>
          <target state="translated">PAM (Pluggable Authentication Module) 프레임 워크를 사용하여 MariaDB 사용자를 인증하십시오.</target>
        </trans-unit>
        <trans-unit id="bf7d6ad11af503f5b73df70be62676211e6efc5a" translate="yes" xml:space="preserve">
          <source>Uses the QuickLZ compression algorithm</source>
          <target state="translated">QuickLZ 압축 알고리즘을 사용합니다</target>
        </trans-unit>
        <trans-unit id="17eb7c9b80499e2d8cfca28f9dc3c9d7ea55996e" translate="yes" xml:space="preserve">
          <source>Uses the password hashing algorithm introduced in MySQL 4.1.</source>
          <target state="translated">MySQL 4.1에 도입 된 패스워드 해싱 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="255157aec3d6f619ae675aed967ea20ed14ad9bc" translate="yes" xml:space="preserve">
          <source>Uses the same technique as '-r' and '-n', but creates all the keys in parallel, in different threads.</source>
          <target state="translated">'-r'및 '-n'과 동일한 기술을 사용하지만 다른 스레드에서 모든 키를 병렬로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e8486d073e3dd213aef3e0fd9cf80adf9090173a" translate="yes" xml:space="preserve">
          <source>Uses the user name that owns the process connected to MariaDB's named pipe on Windows.</source>
          <target state="translated">Windows에서 MariaDB의 명명 된 파이프에 연결된 프로세스를 소유 한 사용자 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b10b060dc6256cd385133e14f74e2986fdc82d8c" translate="yes" xml:space="preserve">
          <source>Uses the user name that owns the process connected to MariaDB's unix socket file.</source>
          <target state="translated">MariaDB의 유닉스 소켓 파일에 연결된 프로세스를 소유 한 사용자 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cbc905e2aa1fa7d5dc0f04aa93f117a70650e9ac" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;Jbin&amp;rdquo; to control what the query execution does</source>
          <target state="translated">&quot;Jbin&quot;을 사용하여 쿼리 실행 수행 제어</target>
        </trans-unit>
        <trans-unit id="cb0c2f76d17c880ca56200b273ba349bc71b33fb" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; to sort as a &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; instead:</source>
          <target state="translated">대신 &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; 를 사용 하여 &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; 로 정렬 :</target>
        </trans-unit>
        <trans-unit id="0e91cb3c1916ede6c19ec32a925716085cb8bbe8" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;ColumnStore Bulk Write SDK&lt;/a&gt; or &lt;a href=&quot;../columnstore-streaming-data-adapters/index&quot;&gt;ColumnStore Streaming Data Adapters&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;ColumnStore 대량 쓰기 SDK&lt;/a&gt; 또는 &lt;a href=&quot;../columnstore-streaming-data-adapters/index&quot;&gt;ColumnStore 스트리밍 데이터 어댑터&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88a5ab727d36f24f2134fb03a24346bac1539ff1" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; or &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; in a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; query that uses temporary tables for storing intermediate results will force the temporary table to be disk based (using the &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria storage engine&lt;/a&gt; instead of the &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;memory storage engine&lt;/a&gt;, which is a bit slower. This is not that bad as the &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria storage engine&lt;/a&gt; caches the rows in memory. To get the benefit of this, one should ensure that the &lt;a href=&quot;../aria-system-variables/index#aria_pagecache_buffer_size&quot;&gt;aria_pagecache_buffer_size&lt;/a&gt; variable is big enough to hold most of the row and index data for temporary tables.</source>
          <target state="translated">사용 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 또는 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; A의 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 은 USING (디스크를 기초로 임시 테이블 강제 중간 결과를 저장하는 임시 테이블을 사용하여 쿼리 &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;아리아 스토리지 엔진&lt;/a&gt; 대신의 &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;메모리 스토리지 엔진&lt;/a&gt; 약간 느리다.이 같은 나쁜 아니다 &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;아리아 스토리지 엔진은&lt;/a&gt; 메모리에 행을 캐시합니다.이의 혜택을 얻으려면 하나가 있는지 확인해야합니다 &lt;a href=&quot;../aria-system-variables/index#aria_pagecache_buffer_size&quot;&gt;aria_pagecache_buffer_size의&lt;/a&gt; 변수는 임시 테이블에 대한 행과 인덱스 데이터의 대부분을 보유 할 충분히 큰입니다.</target>
        </trans-unit>
        <trans-unit id="ea7b4b35e3c4382515299dab40c6fe27c34ecc6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;255.255.255.255&lt;/code&gt; is equivalent to not using a netmask at all.</source>
          <target state="translated">사용 &lt;code&gt;255.255.255.255&lt;/code&gt; 것은 전혀 넷 마스크를 사용하지 동일합니다.</target>
        </trans-unit>
        <trans-unit id="12ff2e25e370f871b5f59dd67683b51b84b9208b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../mysqlimport/index&quot;&gt;mysqlimport&lt;/a&gt;&lt;/code&gt; you can compress the file using the &lt;code&gt;--compress&lt;/code&gt; option, to get better performance over slow networks, providing both the client and server support the compressed protocol. Use the &lt;code&gt;--local&lt;/code&gt; option to load from the local file system.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../mysqlimport/index&quot;&gt;mysqlimport&lt;/a&gt;&lt;/code&gt; 사용하면 사용하여 파일을 압축 할 수 있습니다 &lt;code&gt;--compress&lt;/code&gt; 클라이언트와 서버 모두 지원을 압축 프로토콜을 제공하고, 속도가 느린 네트워크를 통해 더 나은 성능을 얻기 위해 옵션을 선택합니다. &lt;code&gt;--local&lt;/code&gt; 옵션을 사용하여 로컬 파일 시스템에서로드하십시오.</target>
        </trans-unit>
        <trans-unit id="7b35aec2376b0d5218dee4abfd24509392e7435c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; does not grant the special &lt;code&gt;GRANT OPTION&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;code&gt;ALL PRIVILEGES&lt;/code&gt; 를 사용 하면 특별한 &lt;code&gt;GRANT OPTION&lt;/code&gt; 권한이 부여되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7af3fb8885163e5ccc9d510e05476aa670bff392" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BACKUP STAGE&lt;/code&gt; Commands with Backup Tools</source>
          <target state="translated">백업 도구와 함께 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 명령 사용</target>
        </trans-unit>
        <trans-unit id="4aab67dca34b08a1bf89b41d8a6992e497b1b6db" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BACKUP STAGE&lt;/code&gt; Commands with Mariabackup</source>
          <target state="translated">Mariabackup과 함께 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 명령 사용</target>
        </trans-unit>
        <trans-unit id="bc3fc08d3d16fe8622456c13953a92e583bcd127" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;BACKUP STAGE&lt;/code&gt; Commands with Storage Snapshots</source>
          <target state="translated">스토리지 스냅 샷과 함께 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 명령 사용</target>
        </trans-unit>
        <trans-unit id="b24a5cd1a94eef0ee3596c280121506b0c59cfec" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;CAST()&lt;/code&gt; to order an &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; field as a &lt;code&gt;&lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt;&lt;/code&gt; rather than the internal numerical value:</source>
          <target state="translated">&lt;code&gt;CAST()&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 필드를 내부 숫자 값이 아닌 &lt;code&gt;&lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt;&lt;/code&gt; 로 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="fac220d680b55de1f68fd2ad2633bbddfa60ea94" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;CONCAT_WS()&lt;/code&gt; to handle &lt;code&gt;NULL&lt;/code&gt;s:</source>
          <target state="translated">사용 &lt;code&gt;CONCAT_WS()&lt;/code&gt; 핸들 &lt;code&gt;NULL&lt;/code&gt; 들 :</target>
        </trans-unit>
        <trans-unit id="ef68e189c8994aacbeacbd2f2a21022381c6104f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;IFNULL()&lt;/code&gt; to handle NULLs:</source>
          <target state="translated">&lt;code&gt;IFNULL()&lt;/code&gt; 을 사용하여 NULL 처리</target>
        </trans-unit>
        <trans-unit id="ba6c9a4bca9a0d8b17b033df3963b2249582a693" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PERSISTENT&lt;/code&gt; generated columns as part of a &lt;a href=&quot;../foreign-keys/index&quot;&gt;foreign key&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;../foreign-keys/index&quot;&gt;외부 키의&lt;/a&gt; 일부로 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열을 사용 하는 것이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="257e3c1d1acf0f9d69e77e02136a136ee292d5b0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ROW&lt;/code&gt; variables with a different column count than in the &lt;code&gt;SELECT..INTO&lt;/code&gt; list will report an error.</source>
          <target state="translated">&lt;code&gt;SELECT..INTO&lt;/code&gt; 목록 과 다른 열 개수의 &lt;code&gt;ROW&lt;/code&gt; 변수를 사용 하면 오류 가보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4534cb390864bcd4e94df7e8779147eb3df18d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;current_pos&lt;/code&gt; vs. &lt;code&gt;slave_pos&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;current_pos&lt;/code&gt; 대 &lt;code&gt;slave_pos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52c9351f88fab1d2771df7ad317c2125452aa931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mysqlimport&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mysqlimport&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3ed365f137d960ea6406094d1ab2cb7ddb6f778d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;xtstat&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xtstat&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="bf0611d7d38c4a393a627af9b49d24dc81e80e8f" translate="yes" xml:space="preserve">
          <source>Using @variables</source>
          <target state="translated">@variables 사용</target>
        </trans-unit>
        <trans-unit id="078de92a3a8b5a9a9320c3a1f20ff0eb3f670270" translate="yes" xml:space="preserve">
          <source>Using BUILD Scripts</source>
          <target state="translated">BUILD 스크립트 사용</target>
        </trans-unit>
        <trans-unit id="626705a2207b3de15a62744417b01540e7e9cf34" translate="yes" xml:space="preserve">
          <source>Using Bitemporal Tables</source>
          <target state="translated">이 시간 테이블 사용</target>
        </trans-unit>
        <trans-unit id="0fccb0d243a9c0237f44e5172151330470f65e1b" translate="yes" xml:space="preserve">
          <source>Using Buffer UPDATE Algorithm</source>
          <target state="translated">버퍼 업데이트 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="5ac4ed2480d6d29c1e343b875cf3135e40a7a249" translate="yes" xml:space="preserve">
          <source>Using CONNECT</source>
          <target state="translated">CONNECT 사용</target>
        </trans-unit>
        <trans-unit id="a3046f5f8f0bc99d261bf5fa440dffd1f430fca3" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Condition Pushdown</source>
          <target state="translated">CONNECT 사용-조건 푸시 다운</target>
        </trans-unit>
        <trans-unit id="ef9a0e939594af284e26f2878c6a01cb87d075bf" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Exporting Data From MariaDB</source>
          <target state="translated">CONNECT 사용-MariaDB에서 데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="7b86e36798d1d674604539c3bc580592f63d251f" translate="yes" xml:space="preserve">
          <source>Using CONNECT - General Information</source>
          <target state="translated">CONNECT 사용-일반 정보</target>
        </trans-unit>
        <trans-unit id="9739e8429e6a91f5be21b78652d0606138da8931" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Importing File Data Into MariaDB Tables</source>
          <target state="translated">CONNECT 사용-MariaDB 테이블로 파일 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="2df1c832c033b72dcccc7121536d2a4f51a8a3bb" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Indexing</source>
          <target state="translated">CONNECT 사용-인덱싱</target>
        </trans-unit>
        <trans-unit id="e0101420aa02eca5fbf1f3588100bbed61c4ac23" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Partitioning and Sharding</source>
          <target state="translated">CONNECT 사용-파티셔닝 및 샤딩</target>
        </trans-unit>
        <trans-unit id="b223d660ca2439d82aed62455cfc4ffc94dcd883" translate="yes" xml:space="preserve">
          <source>Using CONNECT - Virtual and Special Columns</source>
          <target state="translated">CONNECT 사용-가상 및 특수 열</target>
        </trans-unit>
        <trans-unit id="ccf17f502b9ec10fad76fb65737c8673fa44ff91" translate="yes" xml:space="preserve">
          <source>Using Compound Statements Outside of Stored Programs</source>
          <target state="translated">저장된 프로그램 외부에서 복합 명령문 사용</target>
        </trans-unit>
        <trans-unit id="8859371dc9d9b40d4b95e5197062ef02eec0f9e8" translate="yes" xml:space="preserve">
          <source>Using DISTINCT or GROUP BY to counteract the explosion</source>
          <target state="translated">DISTINCT 또는 GROUP BY를 사용하여 폭발에 대응</target>
        </trans-unit>
        <trans-unit id="8ce53d196ae72d42b348e743261b59c52638a824" translate="yes" xml:space="preserve">
          <source>Using DirectAdmin when installing MariaDB with YUM</source>
          <target state="translated">YUM과 함께 MariaDB를 설치할 때 DirectAdmin 사용</target>
        </trans-unit>
        <trans-unit id="16b3145a5b70b54116d8a04bad80988690c8a8a4" translate="yes" xml:space="preserve">
          <source>Using Encryption and Compression Tools With Mariabackup</source>
          <target state="translated">Mariabackup과 함께 암호화 및 압축 도구 사용</target>
        </trans-unit>
        <trans-unit id="773e4db6d999c1711e3b643772552911db00e677" translate="yes" xml:space="preserve">
          <source>Using Extended Keys, the query could be executed by the following execution plan:</source>
          <target state="translated">확장 키를 사용하면 다음 실행 계획에 따라 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4a9f303742e142151538008c28f952b6ea2e8e" translate="yes" xml:space="preserve">
          <source>Using FLOAT might give you some unexpected problems because all calculations in MariaDB are done with double precision. See &lt;a href=&quot;../floating-point-accuracy/index&quot;&gt;Floating Point Accuracy&lt;/a&gt;.</source>
          <target state="translated">MariaDB의 모든 계산이 배정도로 수행되므로 FLOAT를 사용하면 예기치 않은 문제가 발생할 수 있습니다. &lt;a href=&quot;../floating-point-accuracy/index&quot;&gt;부동 소수점 정확도를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="331a4213f0fce95c832e2656c735e87f37087dcd" translate="yes" xml:space="preserve">
          <source>Using GTIDs with MariaDB Galera Cluster</source>
          <target state="translated">MariaDB Galera Cluster에서 GTID 사용</target>
        </trans-unit>
        <trans-unit id="1a8b8db33aac86c2692ff2522ae9ce9d33a1c888" translate="yes" xml:space="preserve">
          <source>Using GTIDs with Parallel Replication</source>
          <target state="translated">병렬 복제와 함께 GTID 사용</target>
        </trans-unit>
        <trans-unit id="38b732ff66c78cb4a846ca4eec0a019d92734957" translate="yes" xml:space="preserve">
          <source>Using Global Transaction IDs</source>
          <target state="translated">글로벌 트랜잭션 ID 사용</target>
        </trans-unit>
        <trans-unit id="724dc57c853b6b27f2d11c0ed47b51dd8eebd531" translate="yes" xml:space="preserve">
          <source>Using HANDLER commands efficiently with MEMORY/HEAP tables</source>
          <target state="translated">MEMORY / HEAP 테이블에서 HANDLER 명령을 효율적으로 사용</target>
        </trans-unit>
        <trans-unit id="0823fbc06642ff1059d5bcaa35afc1a4f77a7fae" translate="yes" xml:space="preserve">
          <source>Using Homebrew</source>
          <target state="translated">Homebrew 사용</target>
        </trans-unit>
        <trans-unit id="a995c237d3cc644523a648d9462b0e63276b3168" translate="yes" xml:space="preserve">
          <source>Using IN BOOLEAN MODE to overcome the 50% limitation:</source>
          <target state="translated">IN BOOLEAN MODE를 사용하여 50 % 한계를 극복하십시오.</target>
        </trans-unit>
        <trans-unit id="e1578bdbfe16ae8b4c1d8702432198170eb57d99" translate="yes" xml:space="preserve">
          <source>Using InnoDB Instead of XtraDB</source>
          <target state="translated">XtraDB 대신 InnoDB 사용</target>
        </trans-unit>
        <trans-unit id="4b828b40e6b35bd547b826b5250b7f77e304b0a9" translate="yes" xml:space="preserve">
          <source>Using JDBC</source>
          <target state="translated">JDBC 사용</target>
        </trans-unit>
        <trans-unit id="10fcd09dea71a8149081b34e8d213598e52b9df9" translate="yes" xml:space="preserve">
          <source>Using JDBC to access other tables.</source>
          <target state="translated">JDBC를 사용하여 다른 테이블에 액세스</target>
        </trans-unit>
        <trans-unit id="0278071020cccc8494fe8eb931827c461efe50ff" translate="yes" xml:space="preserve">
          <source>Using JSON</source>
          <target state="translated">JSON 사용</target>
        </trans-unit>
        <trans-unit id="a0db5976a2f544dc2b58bde51d83c74acc6cc299" translate="yes" xml:space="preserve">
          <source>Using JSON as Dynamic Columns</source>
          <target state="translated">JSON을 동적 열로 사용</target>
        </trans-unit>
        <trans-unit id="f3c2432e3aeb453548c5e2abcd0ef91cf8c25a6d" translate="yes" xml:space="preserve">
          <source>Using Join Buffers for Simple Outer Joins and Semi-joins</source>
          <target state="translated">단순 외부 조인 및 세미 조인에 조인 버퍼 사용</target>
        </trans-unit>
        <trans-unit id="3a75b307a48cf2ac2433a52464b957a89e706062" translate="yes" xml:space="preserve">
          <source>Using MacPorts</source>
          <target state="translated">MacPorts 사용</target>
        </trans-unit>
        <trans-unit id="0283f43da3a8c88bcede18fed89514dae890ffc3" translate="yes" xml:space="preserve">
          <source>Using MariaDB ColumnStore</source>
          <target state="translated">MariaDB ColumnStore 사용</target>
        </trans-unit>
        <trans-unit id="b4bf3cf1e66a092202db3537e8497ed613201110" translate="yes" xml:space="preserve">
          <source>Using MariaDB GTIDs with MariaDB Galera Cluster</source>
          <target state="translated">MariaDB Galera Cluster와 함께 MariaDB GTID 사용</target>
        </trans-unit>
        <trans-unit id="8ddbc424b8bb71cdb3185f79689b23a77c76f69a" translate="yes" xml:space="preserve">
          <source>Using MariaDB Images</source>
          <target state="translated">MariaDB 이미지 사용</target>
        </trans-unit>
        <trans-unit id="35ad940d31257c72a112cf112a9bd87dd14bb5f8" translate="yes" xml:space="preserve">
          <source>Using MariaDB Replication with MariaDB Galera Cluster</source>
          <target state="translated">MariaDB Galera Cluster와 함께 MariaDB 복제 사용</target>
        </trans-unit>
        <trans-unit id="3d48fed0952408c5f6ebba44ad2b83ab42a5effb" translate="yes" xml:space="preserve">
          <source>Using Mariabackup</source>
          <target state="translated">Mariabackup 사용</target>
        </trans-unit>
        <trans-unit id="ff0474ad6bc8f13008db66f72023ecda364769c5" translate="yes" xml:space="preserve">
          <source>Using Mariabackup for Galera SSTs</source>
          <target state="translated">Galera SST에 Mariabackup 사용</target>
        </trans-unit>
        <trans-unit id="a097f0f752120ecb175095bec2bd6508dbe3097f" translate="yes" xml:space="preserve">
          <source>Using Mariabackup with Data-at-Rest Encryption</source>
          <target state="translated">미사용 데이터 암호화와 함께 Mariabackup 사용</target>
        </trans-unit>
        <trans-unit id="19e6ca1d1a1e341bf71ba321dbc478d3faea94e5" translate="yes" xml:space="preserve">
          <source>Using Multiple Encryption Keys</source>
          <target state="translated">다중 암호화 키 사용</target>
        </trans-unit>
        <trans-unit id="5ed3dd128ac19c10c8427a0d3f0255ffcece9a8e" translate="yes" xml:space="preserve">
          <source>Using ODBC Tables inside correlated sub-queries</source>
          <target state="translated">상관 된 하위 쿼리 내에서 ODBC 테이블 사용</target>
        </trans-unit>
        <trans-unit id="94c7ab97965507c87cc700753fad0194fa99b06e" translate="yes" xml:space="preserve">
          <source>Using Percona XtraBackup</source>
          <target state="translated">Percona XtraBackup 사용</target>
        </trans-unit>
        <trans-unit id="cd57486e1657a61f192d1b8895c1ce092d987e3d" translate="yes" xml:space="preserve">
          <source>Using Percona XtraBackup for Galera SSTs</source>
          <target state="translated">Galera SST에 Percona XtraBackup 사용</target>
        </trans-unit>
        <trans-unit id="490fd69ee361e585bca0206713fc64227a5313ae" translate="yes" xml:space="preserve">
          <source>Using Ports</source>
          <target state="translated">포트 사용</target>
        </trans-unit>
        <trans-unit id="b41d93aea3f80ecc1d9e382dcd19a445c64e200b" translate="yes" xml:space="preserve">
          <source>Using Poudriere</source>
          <target state="translated">Poudriere 사용</target>
        </trans-unit>
        <trans-unit id="2a7eb5f48b900b809b215a50435265db90bae863" translate="yes" xml:space="preserve">
          <source>Using Poudriere Repositories</source>
          <target state="translated">Poudriere 리포지토리 사용</target>
        </trans-unit>
        <trans-unit id="c1cdcdeafdd766b6b1f74e4ea0859991237f3522" translate="yes" xml:space="preserve">
          <source>Using R with MariaDB</source>
          <target state="translated">MariaDB와 함께 R 사용</target>
        </trans-unit>
        <trans-unit id="d735dd65a8ff05cc19e50baccc0c898abd29b46b" translate="yes" xml:space="preserve">
          <source>Using Raw Disk Partitions</source>
          <target state="translated">원시 디스크 파티션 사용</target>
        </trans-unit>
        <trans-unit id="2264bee827af5963ffc7379455a20e20c0049a5d" translate="yes" xml:space="preserve">
          <source>Using SQL/PL</source>
          <target state="translated">SQL / PL 사용</target>
        </trans-unit>
        <trans-unit id="761cd87ad42453e0339182ec40683db3c6e4e477" translate="yes" xml:space="preserve">
          <source>Using SQLConnect and a Data Source Name (DSN)</source>
          <target state="translated">SQLConnect 및 데이터 소스 이름 (DSN) 사용</target>
        </trans-unit>
        <trans-unit id="4702fa390eb3b545853217856688b6da05112b00" translate="yes" xml:space="preserve">
          <source>Using SQLDriverConnect and a Connection String</source>
          <target state="translated">SQLDriverConnect 및 연결 문자열 사용</target>
        </trans-unit>
        <trans-unit id="634c3e18b1dc0de1723d7b5634e0be8846ace648" translate="yes" xml:space="preserve">
          <source>Using Sequence Objects</source>
          <target state="translated">시퀀스 객체 사용</target>
        </trans-unit>
        <trans-unit id="3a82fc97bb31a2a451a631f2b4af7e0f7f2bb7f3" translate="yes" xml:space="preserve">
          <source>Using Sequences in DEFAULT</source>
          <target state="translated">DEFAULT에서 시퀀스 사용</target>
        </trans-unit>
        <trans-unit id="dc6ada6204ad7a80047ceb9743ef469bb9a0ff99" translate="yes" xml:space="preserve">
          <source>Using Special Columns with XCOL</source>
          <target state="translated">XCOL과 함께 특수 열 사용</target>
        </trans-unit>
        <trans-unit id="c225e2c352b67929d6adfc2b2a32f1de1754c396" translate="yes" xml:space="preserve">
          <source>Using SphinxSE</source>
          <target state="translated">스핑크스 SE 사용</target>
        </trans-unit>
        <trans-unit id="44fe30dc08e6ad1a3947e6462fa1f180c2b995bf" translate="yes" xml:space="preserve">
          <source>Using SrcDef also permits to use expressions and/or scalar functions. For instance:</source>
          <target state="translated">SrcDef를 사용하면 표현식 및 / 또는 스칼라 함수를 사용할 수도 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="3c650e6b7ba0018951e5fda63c6233e2c2700ad9" translate="yes" xml:space="preserve">
          <source>Using Streaming replication, the node breaks huge transactions up into smaller and more manageable fragments, it then replicates these fragments to the cluster as it works instead of waiting for the commit. Once certified, the fragment can no longer be aborted by conflicting transactions. As this can have performance consequences both during execution and in the event of rollback, it is recommended that you only use it with large transactions that are unlikely to experience conflict.</source>
          <target state="translated">스트리밍 복제를 사용하면 노드는 큰 트랜잭션을 더 작고 관리하기 쉬운 조각으로 나눈 다음 커밋을 기다리는 대신 작동함에 따라 이러한 조각을 클러스터에 복제합니다. 인증 된 후에는 충돌하는 트랜잭션으로 인해 조각을 더 이상 중단 할 수 없습니다. 이는 실행 중이나 롤백시 모두 성능에 영향을 줄 수 있으므로 충돌이 발생하지 않는 큰 트랜잭션에만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f3e4b49ffc1edbe46d836edb39661b4d60209de1" translate="yes" xml:space="preserve">
          <source>Using Subqueries instead of JOINS</source>
          <target state="translated">JOINS 대신 서브 쿼리 사용</target>
        </trans-unit>
        <trans-unit id="63c57d9f64a15ce4148cc52bbe94ae1143332017" translate="yes" xml:space="preserve">
          <source>Using Synaptic Package Manager</source>
          <target state="translated">시냅틱 패키지 관리자 사용</target>
        </trans-unit>
        <trans-unit id="46719e8e0cd3c725a58dbb7a9d83517caba5573e" translate="yes" xml:space="preserve">
          <source>Using TEXT or &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; in a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; query that uses temporary tables for storing intermediate results will force the temporary table to be disk based (using the &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria storage engine&lt;/a&gt; instead of the &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;memory storage engine&lt;/a&gt;, which is a bit slower. This is not that bad as the &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria storage engine&lt;/a&gt; caches the rows in memory. To get the benefit of this, one should ensure that the &lt;a href=&quot;../aria-system-variables/index#aria_pagecache_buffer_size&quot;&gt;aria_pagecache_buffer_size&lt;/a&gt; variable is big enough to hold most of the row and index data for temporary tables.</source>
          <target state="translated">중간 결과를 저장하기 위해 임시 테이블을 사용 하는 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 쿼리 에서 TEXT 또는 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 를 사용하면 임시 테이블을 디스크 기반으로 &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;만들어야&lt;/a&gt; 합니다 ( &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;메모리 스토리지 엔진&lt;/a&gt; 대신 Aria 스토리지 엔진을 사용함) . &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;아리아 스토리지 엔진은&lt;/a&gt; 메모리에 행을 캐시합니다.이의 혜택을 얻으려면 하나가 있는지 확인해야합니다 &lt;a href=&quot;../aria-system-variables/index#aria_pagecache_buffer_size&quot;&gt;aria_pagecache_buffer_size의&lt;/a&gt; 변수는 임시 테이블에 대한 행과 인덱스 데이터의 대부분을 보유 할 충분히 큰입니다.</target>
        </trans-unit>
        <trans-unit id="e53565dcebcb7f0652962b6ba4407e984885eca2" translate="yes" xml:space="preserve">
          <source>Using TLSv1.3</source>
          <target state="translated">TLSv1.3 사용</target>
        </trans-unit>
        <trans-unit id="09ef80fb28150caca80e9029bd96d8e37373faa0" translate="yes" xml:space="preserve">
          <source>Using TVC with &lt;code&gt;&lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; 절 과 함께 TVC 사용 :</target>
        </trans-unit>
        <trans-unit id="26d7713a5593fbf9a6015027ea1425593690ef36" translate="yes" xml:space="preserve">
          <source>Using TVC with an &lt;code&gt;&lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt;&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt;&lt;/code&gt; 절 과 함께 TVC 사용</target>
        </trans-unit>
        <trans-unit id="b45498122bb10214d677069b350b62905f990a43" translate="yes" xml:space="preserve">
          <source>Using TVC's with &lt;code&gt;&lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;&lt;/code&gt; 조작으로 TVC 사용하기 :</target>
        </trans-unit>
        <trans-unit id="08e8a560650bb582a0f5c6eb1c98f4c14ba91f08" translate="yes" xml:space="preserve">
          <source>Using TVC's with a &lt;code&gt;&lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt;&lt;/code&gt; 문과 함께 TVC 사용</target>
        </trans-unit>
        <trans-unit id="b0550275b84627b03be7ffd1782615dda2337979" translate="yes" xml:space="preserve">
          <source>Using Ubuntu Software Center</source>
          <target state="translated">우분투 소프트웨어 센터 사용하기</target>
        </trans-unit>
        <trans-unit id="b22ffe23fe59a2fe559e0ae484713c829aa1d172" translate="yes" xml:space="preserve">
          <source>Using Windows</source>
          <target state="translated">Windows 사용</target>
        </trans-unit>
        <trans-unit id="74c5665247ccd5a151da89d0375132ef5bb9171a" translate="yes" xml:space="preserve">
          <source>Using Xpath with XML tables</source>
          <target state="translated">XML 테이블과 함께 Xpath 사용</target>
        </trans-unit>
        <trans-unit id="bbffb626722a1e64de6b275f0405b981422df95b" translate="yes" xml:space="preserve">
          <source>Using a 64-bit number provides ample range that there should be no risk of it overflowing in the foreseeable future. However, one should not artificially (by setting &lt;code&gt;gtid_seq_no&lt;/code&gt;) inject a GTID with a very high sequence number close to the limit of 64-bit.</source>
          <target state="translated">64 비트 숫자를 사용하면 가까운 장래에 넘칠 위험이 없어야하는 충분한 범위가 제공됩니다. 그러나 인위적으로 ( &lt;code&gt;gtid_seq_no&lt;/code&gt; 를 설정 하여 ) 64 비트 한계에 가까운 시퀀스 번호가 매우 높은 GTID를 주입 해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0940fd1148a1882933e1e0820f4b01f88d9a137d" translate="yes" xml:space="preserve">
          <source>Using a Federated Server</source>
          <target state="translated">페더 레이 티드 서버 사용</target>
        </trans-unit>
        <trans-unit id="043243575aba647303295d49c2138d98cc54eb7d" translate="yes" xml:space="preserve">
          <source>Using a Multi-Factor Authentication (MFA) device</source>
          <target state="translated">MFA (Multi-Factor Authentication) 장치 사용</target>
        </trans-unit>
        <trans-unit id="83f9818e672c3f324cce070e9fcbbdef2f3b7b78" translate="yes" xml:space="preserve">
          <source>Using a PROXY Table as a View</source>
          <target state="translated">PROXY 테이블을 뷰로 사용</target>
        </trans-unit>
        <trans-unit id="b6c6013f0b64b0a37d09e88a896a97bbf62aa336" translate="yes" xml:space="preserve">
          <source>Using a Predefined DSN</source>
          <target state="translated">사전 정의 된 DSN 사용</target>
        </trans-unit>
        <trans-unit id="f5ef0d5a1c0366034bbc8874505b9a54c088f8ac" translate="yes" xml:space="preserve">
          <source>Using a Server Compiled With --disable-grant-options</source>
          <target state="translated">--disable-grant-options로 컴파일 된 서버 사용</target>
        </trans-unit>
        <trans-unit id="72c5b10ae41fbf33733eb42f1e7ffeea48273946" translate="yes" xml:space="preserve">
          <source>Using a Storage Engine Plugin</source>
          <target state="translated">스토리지 엔진 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="548da5ad687201cede3cdceae4838c8b0ecb5979" translate="yes" xml:space="preserve">
          <source>Using a file as json UDF first argument</source>
          <target state="translated">파일을 json UDF 첫 번째 인수로 사용</target>
        </trans-unit>
        <trans-unit id="5fd2558633bc49120aa01a834512ddd4c4662cc0" translate="yes" xml:space="preserve">
          <source>Using a generated column as a table's primary key is &lt;strong&gt;not&lt;/strong&gt; supported. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-5590&quot;&gt;MDEV-5590&lt;/a&gt; for more information. If you try to use one as a primary key, then you will see an error similar to the following:</source>
          <target state="translated">생성 된 컬럼을 테이블의 기본 키로 사용하는 &lt;strong&gt;것은&lt;/strong&gt; 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-5590&quot;&gt;MDEV-5590&lt;/a&gt; 을 참조하십시오. 하나를 기본 키로 사용하려고하면 다음과 유사한 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb376904e2f38b0d0eebbf3385552e06860e0e3" translate="yes" xml:space="preserve">
          <source>Using a scrollable cursor.</source>
          <target state="translated">스크롤 가능한 커서 사용</target>
        </trans-unit>
        <trans-unit id="20018894d1156d39d1d2dac853d4a028e9631285" translate="yes" xml:space="preserve">
          <source>Using a shortened prefix for the &lt;code&gt;version&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; 명령에 단축 접두사 사용 :</target>
        </trans-unit>
        <trans-unit id="1f6f8c89581670513e4fcef6335dc0b523f8fe10" translate="yes" xml:space="preserve">
          <source>Using an editor, the actual file will look as follows</source>
          <target state="translated">편집기를 사용하면 실제 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba63b8f262612246eb65780b5f97ec0b4a12b80c" translate="yes" xml:space="preserve">
          <source>Using an expression that exceeds 255 characters in length is &lt;strong&gt;not&lt;/strong&gt; supported in expressions for generated columns.</source>
          <target state="translated">생성 된 열의 표현식 에서는 길이가 255자를 초과하는 표현식을 사용할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="df62786e55ae11e0078927a7aefdddd70a574d4d" translate="yes" xml:space="preserve">
          <source>Using an expression that exceeds 255 characters in length is supported in expressions for generated columns. The new limit for the entire table definition, including all expressions for generated columns, is 65,535 bytes.</source>
          <target state="translated">생성 된 열의 표현식에서 길이가 255자를 초과하는 표현식을 사용할 수 있습니다. 생성 된 컬럼의 모든 표현식을 포함하여 전체 테이블 정의에 대한 새로운 한계는 65,535 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="4c499f2d368cc3237148acd97c8c255aca801986" translate="yes" xml:space="preserve">
          <source>Using an identifier quote as part of an identifier name:</source>
          <target state="translated">식별자 이름의 일부로 식별자 인용 사용 :</target>
        </trans-unit>
        <trans-unit id="f039a77a6bab31b8fee0a6168e70c3202adea4df" translate="yes" xml:space="preserve">
          <source>Using an in-memory table (as described above) is usually the fastest option for &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; if the result set is small. It is not optimal if the result set is very big. You can tell the optimizer this by using &lt;code&gt;SELECT SQL_SMALL_RESULT&lt;/code&gt; or &lt;code&gt;SELECT SQL_BIG_RESULT&lt;/code&gt;.</source>
          <target state="translated">결과 집합이 작은 경우 일반적으로 메모리 내 테이블 (위에서 설명)을 사용하는 것이 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY에&lt;/a&gt; 가장 빠른 옵션입니다 . 결과 집합이 매우 큰 경우에는 최적이 아닙니다. &lt;code&gt;SELECT SQL_SMALL_RESULT&lt;/code&gt; 또는 &lt;code&gt;SELECT SQL_BIG_RESULT&lt;/code&gt; 를 사용하여 옵티 마이저에게이를 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abc261be95d6120ea5985c3db85808840909df0f" translate="yes" xml:space="preserve">
          <source>Using an uncorrelated subquery</source>
          <target state="translated">상관되지 않은 하위 쿼리 사용</target>
        </trans-unit>
        <trans-unit id="03c9a084643c49b67c2d56c92df92bc704d40797" translate="yes" xml:space="preserve">
          <source>Using and Maintaining the Binary Log</source>
          <target state="translated">이진 로그 사용 및 유지 관리</target>
        </trans-unit>
        <trans-unit id="8b3df2c08c3e9d61f078526c4eabf30380e2d635" translate="yes" xml:space="preserve">
          <source>Using and maintaining the binary log.</source>
          <target state="translated">이진 로그 사용 및 유지 관리</target>
        </trans-unit>
        <trans-unit id="2a142f44a952fbd7d7633bc3dc6206a509eeff77" translate="yes" xml:space="preserve">
          <source>Using anything that depends on data outside the row is &lt;strong&gt;not&lt;/strong&gt; supported in expressions for generated columns.</source>
          <target state="translated">행 외부의 데이터에 의존하는 것을 사용하는 것은 생성 된 열의 표현식에서 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f2765e3d7b9765518695ca19938237e44b0d9aa0" translate="yes" xml:space="preserve">
          <source>Using aria_s3_copy to Test the Connection</source>
          <target state="translated">aria_s3_copy를 사용하여 연결 테스트</target>
        </trans-unit>
        <trans-unit id="1a473a84d3d5b843e4258c98f2b8d710112fa134" translate="yes" xml:space="preserve">
          <source>Using big transactions</source>
          <target state="translated">큰 거래 사용</target>
        </trans-unit>
        <trans-unit id="8dadfff206f3d739d2cb81f940cabe24a5b08617" translate="yes" xml:space="preserve">
          <source>Using boolean operators</source>
          <target state="translated">부울 연산자 사용</target>
        </trans-unit>
        <trans-unit id="9c8891a68298ac6434d4f824a99a3928c80412db" translate="yes" xml:space="preserve">
          <source>Using cmake</source>
          <target state="translated">cmake 사용</target>
        </trans-unit>
        <trans-unit id="1989800cbd9c58c51535016d4d5eca070330551e" translate="yes" xml:space="preserve">
          <source>Using compound statements outside of stored programs</source>
          <target state="translated">저장된 프로그램 외부에서 복합 명령문 사용</target>
        </trans-unit>
        <trans-unit id="b236fb23f8e4efdb7cb35b96cf56e4adcdc83f36" translate="yes" xml:space="preserve">
          <source>Using constant expressions is &lt;strong&gt;not&lt;/strong&gt; supported in expressions for generated columns. Otherwise, it would generate errors like this:</source>
          <target state="translated">생성 된 열의 표현식에서는 상수 표현식 사용이 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 그렇지 않으면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="359a5cae87c240562f900278d7a2442b7655818c" translate="yes" xml:space="preserve">
          <source>Using constant expressions is supported in expressions for generated columns. For example:</source>
          <target state="translated">생성 된 컬럼의 표현식에서 상수 표현식 사용이 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="787e6d7785a3214c873b2288fc69073665eef3dc" translate="yes" xml:space="preserve">
          <source>Using data-at-rest encryption requires that you first configure an &lt;a href=&quot;../encryption-key-management/index&quot;&gt;Encryption Key Management&lt;/a&gt; plugin, such as the &lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; plugins. MariaDB uses this plugin to store, retrieve and manage the various keys it uses when encrypting data to and decrypting data from the file system.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; 데이터 암호화를 사용하려면 먼저 file_key_management 또는 &lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; 플러그인 과 같은 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;암호화 키 관리&lt;/a&gt; 플러그인을 구성해야합니다 . MariaDB는이 플러그인을 사용하여 파일 시스템에서 데이터를 암호화하고 파일 시스템에서 데이터를 해독 할 때 사용하는 다양한 키를 저장, 검색 및 관리합니다.</target>
        </trans-unit>
        <trans-unit id="48cc522cf59e86bf673500c21339d461aad29ca3" translate="yes" xml:space="preserve">
          <source>Using data-at-rest encryption with InnoDB, the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable only encrypts the InnoDB tablespaces. In order to also encrypt the InnoDB Redo Logs, you also need to set the &lt;code&gt;&lt;a href=&quot;innodb-server-system-variables#innodb_encrypt_logs&quot;&gt;innodb_encrypt_logs&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 데이터 암호화를 사용하면 innodb_encrypt_tables 시스템 변수는 InnoDB 테이블 스페이스 만 암호화합니다. InnoDB Redo Logs를 암호화하려면 &lt;code&gt;&lt;a href=&quot;innodb-server-system-variables#innodb_encrypt_logs&quot;&gt;innodb_encrypt_logs&lt;/a&gt;&lt;/code&gt; 시스템 변수도 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0f2f6c033b71f9c28170591b5c7dd31c15880842" translate="yes" xml:space="preserve">
          <source>Using discovery is available. This table could have been created by:</source>
          <target state="translated">감지 사용이 가능합니다. 이 테이블은 다음에 의해 작성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e335d9a4aebc7631f3f028aeb38a07baed4a0998" translate="yes" xml:space="preserve">
          <source>Using double quotes as a quoting character:</source>
          <target state="translated">큰 따옴표를 인용 문자로 사용 :</target>
        </trans-unit>
        <trans-unit id="ba41b1546dda0c40d82d399ba7f17c3a5251e0de" translate="yes" xml:space="preserve">
          <source>Using encryption has an overhead of roughly &lt;em&gt;3-5%&lt;/em&gt;.</source>
          <target state="translated">암호화를 사용하면 약 &lt;em&gt;3-5 %&lt;/em&gt; 의 오버 헤드가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0d67d80f4c992778a1bcfc5ee1a86b01359ae85d" translate="yes" xml:space="preserve">
          <source>Using files to store the create and query SQL. Each file can contain multiple statements separated by the specified delimiter.</source>
          <target state="translated">파일을 사용하여 작성 및 조회 SQL 저장 각 파일은 지정된 구분 기호로 구분 된 여러 명령문을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5ccb9caa5eda6a5d737849b8ead044423ad39b" translate="yes" xml:space="preserve">
          <source>Using filesort</source>
          <target state="translated">filesort 사용하기</target>
        </trans-unit>
        <trans-unit id="baf8fcf2bded52d004d3946e0d7fc3ae539f2365" translate="yes" xml:space="preserve">
          <source>Using global transaction ID provides two main benefits:</source>
          <target state="translated">글로벌 트랜잭션 ID를 사용하면 두 가지 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="065c0b6b96eb9763493741b4776742d211fbbbfe" translate="yes" xml:space="preserve">
          <source>Using high-speed bulk load utility cpimport</source>
          <target state="translated">고속 벌크로드 유틸리티 cpimport 사용</target>
        </trans-unit>
        <trans-unit id="a82b2af4804905061ed9cd73ceccb387d1409ef0" translate="yes" xml:space="preserve">
          <source>Using hints to get the optimizer to use another query plan.</source>
          <target state="translated">힌트를 사용하여 옵티마이 저가 다른 쿼리 계획을 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="c2bcffdb24968b22e7d3a78edf50a4f085955255" translate="yes" xml:space="preserve">
          <source>Using index; Using temporary</source>
          <target state="translated">색인 사용; 임시 사용</target>
        </trans-unit>
        <trans-unit id="d3a8937125ea3a3df15278374b2ae68cf4044c02" translate="yes" xml:space="preserve">
          <source>Using indexes to improve query performance</source>
          <target state="translated">인덱스를 사용하여 쿼리 성능 향상</target>
        </trans-unit>
        <trans-unit id="a1d1a838ec94440e885901dd30da9466437801f9" translate="yes" xml:space="preserve">
          <source>Using indexes, writing better queries and adjusting variables for better performance.</source>
          <target state="translated">인덱스 사용, 더 나은 쿼리 작성 및 더 나은 성능을 위해 변수 조정</target>
        </trans-unit>
        <trans-unit id="06f32185f612b99b492f02b538f52075ede724bc" translate="yes" xml:space="preserve">
          <source>Using last_value() to return data of used rows</source>
          <target state="translated">last_value ()를 사용하여 사용 된 행의 데이터를 리턴</target>
        </trans-unit>
        <trans-unit id="01ba530a6f00b3097571d81a20b8a2cd97579d2d" translate="yes" xml:space="preserve">
          <source>Using more RAM slots on the motherboard increases the bus frequency, and there will be more latency between the RAM and the CPU. So, using the highest RAM size per slot is preferable.</source>
          <target state="translated">마더 보드에 더 많은 RAM 슬롯을 사용하면 버스 주파수가 증가하고 RAM과 CPU 사이에 대기 시간이 늘어납니다. 따라서 슬롯 당 최대 RAM 크기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0baab28fa06aef22455eede9f9de3199632f8e0" translate="yes" xml:space="preserve">
          <source>Using multi-source with &lt;a href=&quot;../global-transaction-id/index#use-with-multi-source-replication-and-other-multi-master-setups&quot;&gt;global transaction id&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global-transaction-id/index#use-with-multi-source-replication-and-other-multi-master-setups&quot;&gt;글로벌 트랜잭션 ID&lt;/a&gt; 와 함께 다중 소스 사용</target>
        </trans-unit>
        <trans-unit id="d8e5c9f9ff37388f66e30ca91c1d8bde000e69d2" translate="yes" xml:space="preserve">
          <source>Using multiple &lt;code&gt;ROW&lt;/code&gt; variables in the &lt;code&gt;SELECT..INTO&lt;/code&gt; list will report an error.</source>
          <target state="translated">&lt;code&gt;SELECT..INTO&lt;/code&gt; 목록 에서 여러 &lt;code&gt;ROW&lt;/code&gt; 변수를 사용 하면 오류 가보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2d8c6504a07b19e8074db88dbf76e90c682cae" translate="yes" xml:space="preserve">
          <source>Using mysql</source>
          <target state="translated">mysql 사용</target>
        </trans-unit>
        <trans-unit id="6f064c4dfcf4f237ab67900299a6407e95461391" translate="yes" xml:space="preserve">
          <source>Using mysql is very easy. Invoke it from the prompt of your command interpreter as follows:</source>
          <target state="translated">mysql을 사용하는 것은 매우 쉽다. 다음과 같이 명령 인터프리터의 프롬프트에서이를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="614e03f393a5942aac58e3aa82ad475c3a680695" translate="yes" xml:space="preserve">
          <source>Using mysql-test-run to Test the Connection and the S3 Storage Engine</source>
          <target state="translated">mysql-test-run을 사용하여 연결 및 S3 스토리지 엔진 테스트</target>
        </trans-unit>
        <trans-unit id="20f56c4d895a16375bebbfe009fb879462a4ca3f" translate="yes" xml:space="preserve">
          <source>Using mysql.server</source>
          <target state="translated">mysql.server 사용</target>
        </trans-unit>
        <trans-unit id="d2573e5411cb15a911295c2bfc60e5b8de85bc55" translate="yes" xml:space="preserve">
          <source>Using mysql_embedded and mysqld --bootstrap to tinker with privilege tables</source>
          <target state="translated">권한 테이블로 땜질하기 위해 mysql_embedded 및 mysqld --bootstrap 사용</target>
        </trans-unit>
        <trans-unit id="7623b88984531fc13ff68a6fbea7e065b6951d20" translate="yes" xml:space="preserve">
          <source>Using mysql_install_db to create the system tables in the 'mysql' database directory</source>
          <target state="translated">mysql_install_db를 사용하여 'mysql'데이터베이스 디렉토리에 시스템 테이블 작성</target>
        </trans-unit>
        <trans-unit id="a859e0f700fadf636ec01facfcbad308369d583f" translate="yes" xml:space="preserve">
          <source>Using mysql_upgrade</source>
          <target state="translated">mysql_upgrade 사용</target>
        </trans-unit>
        <trans-unit id="0d759b744d2f24773b711cedaefcd0913ad776e3" translate="yes" xml:space="preserve">
          <source>Using mysqladmin</source>
          <target state="translated">mysqladmin 사용</target>
        </trans-unit>
        <trans-unit id="e16a03c44ca9a3b23f07a8f6d63bcc02637b5c7a" translate="yes" xml:space="preserve">
          <source>Using mysqlbinlog</source>
          <target state="translated">mysqlbinlog 사용</target>
        </trans-unit>
        <trans-unit id="29771762cf2243de905401a3caec5c8995964098" translate="yes" xml:space="preserve">
          <source>Using mysqlcheck</source>
          <target state="translated">mysqlcheck 사용</target>
        </trans-unit>
        <trans-unit id="2b87ec5bb3323041edda6ea7438c63d7254d038b" translate="yes" xml:space="preserve">
          <source>Using mysqld_install_db</source>
          <target state="translated">mysqld_install_db 사용</target>
        </trans-unit>
        <trans-unit id="4a056f9ebbff598e316fff67633232859b5d1290" translate="yes" xml:space="preserve">
          <source>Using mysqld_multi</source>
          <target state="translated">mysqld_multi 사용</target>
        </trans-unit>
        <trans-unit id="cbf56f717f9e2f0c7133f99cdcac185637cad3a2" translate="yes" xml:space="preserve">
          <source>Using mysqld_safe</source>
          <target state="translated">mysqld_safe 사용</target>
        </trans-unit>
        <trans-unit id="07384722cb6ad6a24b66e6938973f25c09be4be6" translate="yes" xml:space="preserve">
          <source>Using mysqldump</source>
          <target state="translated">mysqldump 사용</target>
        </trans-unit>
        <trans-unit id="b79a30989dd86b3b44b7c65eb985ad5883390259" translate="yes" xml:space="preserve">
          <source>Using mysqlimport</source>
          <target state="translated">mysqlimport 사용</target>
        </trans-unit>
        <trans-unit id="02558db62cab44a65c557b16e2367d110ed4159b" translate="yes" xml:space="preserve">
          <source>Using mysqlshow</source>
          <target state="translated">mysqlshow 사용</target>
        </trans-unit>
        <trans-unit id="b45f5c33b7f871af6188b31f8aeb97cb674c5c00" translate="yes" xml:space="preserve">
          <source>Using mysqlslap</source>
          <target state="translated">mysqlslap 사용</target>
        </trans-unit>
        <trans-unit id="f82f5466608407fbdfe414838d350be73d1ae5be" translate="yes" xml:space="preserve">
          <source>Using named time zones (with the time zone tables loaded):</source>
          <target state="translated">명명 된 표준 시간대 사용 (표준 시간대 테이블이로드 된 상태) :</target>
        </trans-unit>
        <trans-unit id="919ec921a9b15214de915a2743842d8d8f3875a5" translate="yes" xml:space="preserve">
          <source>Using numeric backreferences for capturing groups can be hard to track in a complicated regular expression. Also, the numbers can change if an expression is modified. To overcome these difficulties, PCRE supports named subpatterns.</source>
          <target state="translated">그룹을 캡처하기 위해 숫자 역 참조를 사용하는 것은 복잡한 정규식에서 추적하기 어려울 수 있습니다. 또한 표현식이 수정되면 숫자가 변경 될 수 있습니다. 이러한 어려움을 극복하기 위해 PCRE는 명명 된 하위 패턴을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f1b40fd824abaab68011b2a1cf9ebbfc7f67cec7" translate="yes" xml:space="preserve">
          <source>Using one &lt;code&gt;--verbose&lt;/code&gt; option will give you more information about what mysqlcheck is doing.</source>
          <target state="translated">하나의 &lt;code&gt;--verbose&lt;/code&gt; 옵션을 사용하면 mysqlcheck가 수행하는 작업에 대한 자세한 정보가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="afcb02976954bb3bd01114d915ac7da8a1ab258a" translate="yes" xml:space="preserve">
          <source>Using only one insert statement to make the whole table. This is possible only for small tables and is principally useful when making tests.</source>
          <target state="translated">하나의 insert 문만 사용하여 전체 테이블을 만듭니다. 이것은 작은 테이블에서만 가능하며 주로 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccb595a5c1f93bd9c3af2d36cbc0df11a7e16ed3" translate="yes" xml:space="preserve">
          <source>Using parentheses in your SQL allows you to control the order of execution for &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statements and &lt;a href=&quot;../table-value-constructors/index&quot;&gt;Table Value Constructor&lt;/a&gt;, including &lt;code&gt;&lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../except/index&quot;&gt;EXCEPT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../intersect/index&quot;&gt;INTERSECT&lt;/a&gt;&lt;/code&gt; operations. MariaDB executes the parenthetical expression before the rest of the statement. You can then use &lt;code&gt;&lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; clauses the further organize the result-set.</source>
          <target state="translated">SQL에서 괄호를 사용하면 &lt;code&gt;&lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../except/index&quot;&gt;EXCEPT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../intersect/index&quot;&gt;INTERSECT&lt;/a&gt;&lt;/code&gt; 조작을 포함하여 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문 및 &lt;a href=&quot;../table-value-constructors/index&quot;&gt;테이블 값 생성자&lt;/a&gt; 의 실행 순서를 제어 할 수 있습니다 . MariaDB는 나머지 명령문보다 먼저 괄호 표현식을 실행합니다. 그런 다음 &lt;code&gt;&lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; 절 을 사용 하여 결과 세트를 추가로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2374a3542ee3aab27312c2bc2972b5c485c1c2" translate="yes" xml:space="preserve">
          <source>Using partitions sometimes requires creating the tables in an unnatural way to avoid some error due to several partition engine bugs:</source>
          <target state="translated">파티션을 사용하려면 여러 파티션 엔진 버그로 인한 오류를 피하기 위해 부 자연스러운 방법으로 테이블을 작성해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7ed5e7a5e6d2ca867e27544eed3c3efb8ce23c" translate="yes" xml:space="preserve">
          <source>Using question mark placeholders for out-parameters in the PREPARE statement</source>
          <target state="translated">PREPARE 문에서 외부 매개 변수에 물음표 자리 표시 자 사용</target>
        </trans-unit>
        <trans-unit id="b374eb9d014a5ab357975b21bbb80a288c60675f" translate="yes" xml:space="preserve">
          <source>Using replication with many masters.</source>
          <target state="translated">많은 마스터와 함께 복제 사용</target>
        </trans-unit>
        <trans-unit id="82789954bee5c917621f66d9cab7a37afed254d3" translate="yes" xml:space="preserve">
          <source>Using statement-based replication, the same example may work, even though the columns are not in the same order.</source>
          <target state="translated">명령문 기반 복제를 사용하면 열의 순서가 다르더라도 동일한 예제가 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0ce2287936bcebf135324bafe145f8781bd4bb" translate="yes" xml:space="preserve">
          <source>Using statistics doesn't help either:</source>
          <target state="translated">통계를 사용해도 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f488327b10696eb94f8e1683b0ac9ec4e01153c" translate="yes" xml:space="preserve">
          <source>Using storage engine %s for table '%s'</source>
          <target state="translated">테이블 '% s'에 스토리지 엔진 % s 사용</target>
        </trans-unit>
        <trans-unit id="da4a39342d05d8b7a713397edc7f65a27c272838" translate="yes" xml:space="preserve">
          <source>Using stored functions in RETURNING</source>
          <target state="translated">RETURNING에서 저장된 기능 사용</target>
        </trans-unit>
        <trans-unit id="fb95535dee424e5bc6fb3919284db8e63b9d72e8" translate="yes" xml:space="preserve">
          <source>Using systemd</source>
          <target state="translated">systemd 사용</target>
        </trans-unit>
        <trans-unit id="70664d3854033756a3b460cedd8adf113ebb2cb1" translate="yes" xml:space="preserve">
          <source>Using table partitioning can have one more advantage. Because the sub-tables can address a table located on another server, it is possible to shard a table on separate servers and hardware machines. This may be required to access as one table data already located on several remote machines, such as servers of a company branches. Or it can be just used to split a huge table for performance reason. For instance, supposing we have created the following tables:</source>
          <target state="translated">테이블 파티셔닝을 사용하면 한 가지 이점이 더 있습니다. 서브 테이블은 다른 서버에있는 테이블을 처리 할 수 ​​있으므로 별도의 서버와 하드웨어 머신에서 테이블을 분할 할 수 있습니다. 회사 지점의 서버와 같은 여러 원격 시스템에 이미있는 하나의 테이블 데이터로 액세스해야 할 수도 있습니다. 또는 성능상의 이유로 큰 테이블을 분할하는 데 사용할 수 있습니다. 예를 들어, 다음 테이블을 작성했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d60e18bdca208662abc7e33dbdeeb1c2e9778bef" translate="yes" xml:space="preserve">
          <source>Using temporary; Using filesort</source>
          <target state="translated">임시 사용; filesort 사용하기</target>
        </trans-unit>
        <trans-unit id="533e08a8ffd7a24330f82def09bf51f0e28addd0" translate="yes" xml:space="preserve">
          <source>Using the --safe-updates Option</source>
          <target state="translated">--safe-updates 옵션 사용</target>
        </trans-unit>
        <trans-unit id="b27508e186e34964bdd738006eac9645ba5e7b41" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; table type seems natural. However, in this current version, the issue is that PROXY (and &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt;) tables are not indexable. This is why, if you want the table to be indexed, you must use the &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; table type. The CREATE TABLE statement will be almost the same:</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; 테이블 유형을 사용하는 것이 자연 스러워 보입니다. 그러나이 현재 버전에서 문제는 PROXY 및 &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; 테이블을 인덱싱 할 수 없다는 것입니다. 그렇기 때문에 테이블을 인덱싱하려면 &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; 테이블 유형을 사용해야합니다 . CREATE TABLE 문은 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e1637806de47834c5fefc9aa7d0c4d4a1a19069c" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt; statement on your queries can help you decide which columns need indexing.</source>
          <target state="translated">쿼리 에서 &lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt; 문을 사용하면 인덱싱이 필요한 열을 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="95328246bc92c2ffa120575e3df1c6a37a6595a8" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../group_concat/index&quot;&gt;GROUP_CONCAT&lt;/a&gt; function can produce more readable results, for example:</source>
          <target state="translated">&lt;a href=&quot;../group_concat/index&quot;&gt;GROUP_CONCAT&lt;/a&gt; 함수를 사용하면 다음과 같이 더 읽기 쉬운 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e0a701ad1e66d63aac9e945ee390c10faaad4c" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt; system variable, you can configure the size in bytes for InnoDB pages. Pages default to 16KB. There are certain limitations on how you use this variable.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt; 시스템 변수를 사용하여 InnoDB 페이지의 크기를 바이트 단위로 구성 할 수 있습니다. 페이지는 기본적으로 16KB입니다. 이 변수를 사용하는 방법에는 특정 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f461111415fd129d53f574800d6609c31d596b47" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; column option is &lt;strong&gt;not&lt;/strong&gt; supported when defining generated columns. Previously, it was supported, but this support was removed, because it would not work correctly. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-11117&quot;&gt;MDEV-11117&lt;/a&gt;.</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 의 열 옵션 것은 &lt;strong&gt;하지&lt;/strong&gt; 생성 된 열을 정의 할 때 지원. 이전에는 지원되었지만이 지원은 제대로 작동하지 않으므로 제거되었습니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-11117&quot;&gt;MDEV-11117을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4366dd277770be16671042891f1b14b9bfcb81e6" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../create-table/index#zerofill-column-option&quot;&gt;ZEROFILL&lt;/a&gt;&lt;/code&gt; column option is supported when defining generated columns.</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;../create-table/index#zerofill-column-option&quot;&gt;ZEROFILL&lt;/a&gt;&lt;/code&gt; 의 생성 된 열을 정의 할 때 열 옵션은 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf7dca6a93ed4405a5fe11258071a755fded27b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;LOW_PRIORITY&lt;/a&gt;&lt;/code&gt; keyword, MariaDB delays insertions until no other clients are reading from the table. Alternatively, you can use the &lt;code&gt;&lt;a href=&quot;../concurrent-inserts/index&quot;&gt;CONCURRENT&lt;/a&gt;&lt;/code&gt; keyword to perform concurrent insertion.</source>
          <target state="translated">MariaDB 는 &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;LOW_PRIORITY&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 다른 클라이언트가 테이블에서 읽을 때까지 삽입을 지연시킵니다. 또는 &lt;code&gt;&lt;a href=&quot;../concurrent-inserts/index&quot;&gt;CONCURRENT&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 동시 삽입을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53a7c6f20e9004dda637799d7cb43225b664d4a5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;COMPACT&lt;/code&gt; Row Format</source>
          <target state="translated">은 Using &lt;code&gt;COMPACT&lt;/code&gt; 행 형식을</target>
        </trans-unit>
        <trans-unit id="2838858fd612c598ce3c88b53e63ee4dc53cee62" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;COMPRESSED&lt;/code&gt; Row Format</source>
          <target state="translated">은 Using &lt;code&gt;COMPRESSED&lt;/code&gt; 행 형식을</target>
        </trans-unit>
        <trans-unit id="3012a6a8b0419c71f4f238fbe7b787f6a5f7e657" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;COPY&lt;/code&gt; Algorithm with InnoDB</source>
          <target state="translated">InnoDB와 함께 &lt;code&gt;COPY&lt;/code&gt; 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="500ca186a776d600399ad391efafbf37cfaa4b1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;DYNAMIC&lt;/code&gt; Row Format</source>
          <target state="translated">은 Using &lt;code&gt;DYNAMIC&lt;/code&gt; 행 형식을</target>
        </trans-unit>
        <trans-unit id="229a7fc1d0515224673ff6857af720e5fed3abc2" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;INPLACE&lt;/code&gt; Algorithm with InnoDB</source>
          <target state="translated">InnoDB와 함께 &lt;code&gt;INPLACE&lt;/code&gt; 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="4be14550156a6aacf0f16bcef9c090b72be5f8e0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;LIMIT&lt;/code&gt; clause is highly recommended because the &lt;code&gt;SHOW RELAYLOG EVENTS&lt;/code&gt; command returns the complete contents of the relay log, which can be quite large.</source>
          <target state="translated">&lt;code&gt;SHOW RELAYLOG EVENTS&lt;/code&gt; 명령은 릴레이 로그의 전체 내용을 반환 하므로 매우 큰 &lt;code&gt;LIMIT&lt;/code&gt; 절을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="950b638ec7b2d315f94b1ec9fef0280222c14e8c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;REDUNDANT&lt;/code&gt; Row Format</source>
          <target state="translated">은 Using &lt;code&gt;REDUNDANT&lt;/code&gt; 행 형식을</target>
        </trans-unit>
        <trans-unit id="d515ae2488ab2e83a95d92500a40a35e2cdbd751" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;SET&lt;/code&gt; clause:</source>
          <target state="translated">은 Using &lt;code&gt;SET&lt;/code&gt; 의 절을 :</target>
        </trans-unit>
        <trans-unit id="98760d0bc4767bc809f2ef9793abd4892432a44b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; clause is equivalent to listing &lt;code&gt;GRANT OPTION&lt;/code&gt; as a privilege.</source>
          <target state="translated">&lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 절을 사용하는 것은 &lt;code&gt;GRANT OPTION&lt;/code&gt; 을 특권으로 나열하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="681a286e38ac4e363d66a406c91115f778dbd4d1" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;mk-build-deb&lt;/code&gt; and &lt;code&gt;apt-get&lt;/code&gt;, install the remaining build dependencies</source>
          <target state="translated">은 Using &lt;code&gt;mk-build-deb&lt;/code&gt; 과 &lt;code&gt;apt-get&lt;/code&gt; 을하면 , 나머지 빌드 의존성을 설치</target>
        </trans-unit>
        <trans-unit id="89b62988fc5484946cf6f129acf1e6e8ae55cbaa" translate="yes" xml:space="preserve">
          <source>Using the AWS Key Management Plugin</source>
          <target state="translated">AWS Key Management 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="cb9ba4b9eefc42a5cf16944f3495fb861344452d" translate="yes" xml:space="preserve">
          <source>Using the Analyzer</source>
          <target state="translated">분석기 사용</target>
        </trans-unit>
        <trans-unit id="ec01f7433a5b272bd217ff53ce0d5946f22f7d7c" translate="yes" xml:space="preserve">
          <source>Using the BLACKHOLE Storage Engine</source>
          <target state="translated">BLACKHOLE 스토리지 엔진 사용</target>
        </trans-unit>
        <trans-unit id="830bbb715f8b612ec92b3c62e6dfe282415aa6dc" translate="yes" xml:space="preserve">
          <source>Using the Date struct below</source>
          <target state="translated">아래의 날짜 구조체 사용</target>
        </trans-unit>
        <trans-unit id="30c0be3c2a6ee202c046e7f31799de752e56291f" translate="yes" xml:space="preserve">
          <source>Using the DateTime struct below</source>
          <target state="translated">아래의 DateTime 구조체 사용</target>
        </trans-unit>
        <trans-unit id="6343f3943f1b07aea2634726fb830acbd624876d" translate="yes" xml:space="preserve">
          <source>Using the Debian repository you just created</source>
          <target state="translated">방금 만든 데비안 리포지토리 사용</target>
        </trans-unit>
        <trans-unit id="cb8bf7c7474b575fe9e1e3a77750bce997538f0d" translate="yes" xml:space="preserve">
          <source>Using the Eperi Key Management Plugin</source>
          <target state="translated">Eperi 키 관리 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="6551eed27bb2fb5637669124d5877a82ccee47b4" translate="yes" xml:space="preserve">
          <source>Using the Extent Map, ColumnStore can perform logical range partitioning and only retrieve the blocks needed to satisfy the query. This is done through Extent Elimination, the process of eliminating Extents from the results that don't meet the given join and filter conditions of the query, which reduces the overall I/O operations.</source>
          <target state="translated">Extent Map을 사용하여 ColumnStore는 논리적 범위 파티셔닝을 수행하고 쿼리를 충족시키는 데 필요한 블록 만 검색 할 수 있습니다. 이는 쿼리의 지정된 조인 및 필터 조건을 충족하지 않는 결과에서 Extent를 제거하는 프로세스 인 Extent Elimination을 통해 수행되므로 전체 I / O 작업이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="e6170f4e94042b5563433925ea672e458c24901b" translate="yes" xml:space="preserve">
          <source>Using the File Key Management Plugin</source>
          <target state="translated">파일 키 관리 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="9e8530ab964cf2dc68c91f3db55198462328af75" translate="yes" xml:space="preserve">
          <source>Using the IF EXISTS clause:</source>
          <target state="translated">IF EXISTS 절 사용 :</target>
        </trans-unit>
        <trans-unit id="5a66f57e98d1b0822aeac9d69038ff860d57fd59" translate="yes" xml:space="preserve">
          <source>Using the Information Schema Table</source>
          <target state="translated">정보 스키마 테이블 사용</target>
        </trans-unit>
        <trans-unit id="cac13fa0dcae71fd0be390fe1c808cee8737461f" translate="yes" xml:space="preserve">
          <source>Using the InnoDB plugin instead of XtraDB</source>
          <target state="translated">XtraDB 대신 InnoDB 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="ef428a3399031b1d3eba865a26192b839b4f0529" translate="yes" xml:space="preserve">
          <source>Using the LOAD DATA INFILE statement for bulk data loading</source>
          <target state="translated">대량 데이터로드에 LOAD DATA INFILE 문 사용</target>
        </trans-unit>
        <trans-unit id="5d9b432f0181cf5887362f834bc7c08de457d2a3" translate="yes" xml:space="preserve">
          <source>Using the MariaDB ColumnStore Admin console</source>
          <target state="translated">MariaDB ColumnStore 관리 콘솔 사용</target>
        </trans-unit>
        <trans-unit id="bcb83d903163c04b532319dfd926ce5a2221cb0d" translate="yes" xml:space="preserve">
          <source>Using the MariaDB Package Repository Setup Script</source>
          <target state="translated">MariaDB 패키지 리포지토리 설정 스크립트 사용</target>
        </trans-unit>
        <trans-unit id="78dea51e10d68224790e1a530f1561b9b4289783" translate="yes" xml:space="preserve">
          <source>Using the MariaDB Repository Configuration Tool</source>
          <target state="translated">MariaDB 리포지토리 구성 도구 사용</target>
        </trans-unit>
        <trans-unit id="e6a98adae7a99544e1c9408961b1f157743ed1da" translate="yes" xml:space="preserve">
          <source>Using the MariaDB storage engine interface, ColumnStore converts the server table object into ColumnStore objects. These objects are then sent to the User Module processes.</source>
          <target state="translated">ColumnStore는 MariaDB 스토리지 엔진 인터페이스를 사용하여 서버 테이블 오브젝트를 ColumnStore 오브젝트로 변환합니다. 그런 다음 이러한 객체는 사용자 모듈 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="490784dd3955e12746eb2deba72bcb198de1f08d" translate="yes" xml:space="preserve">
          <source>Using the Mongo Java Driver</source>
          <target state="translated">Mongo Java 드라이버 사용</target>
        </trans-unit>
        <trans-unit id="39962d454158bf791a5ba05784826a90ab3ee3b3" translate="yes" xml:space="preserve">
          <source>Using the MongoDB C Driver</source>
          <target state="translated">MongoDB C 드라이버 사용</target>
        </trans-unit>
        <trans-unit id="1aa19eba0da705fdc1346da1880c16d7dc1ef670" translate="yes" xml:space="preserve">
          <source>Using the PIVOT Tables Type</source>
          <target state="translated">PIVOT 테이블 유형 사용</target>
        </trans-unit>
        <trans-unit id="9c60bb2492214a60ea9336ef148d4b5a5fffd5f2" translate="yes" xml:space="preserve">
          <source>Using the Plugin</source>
          <target state="translated">플러그인 사용</target>
        </trans-unit>
        <trans-unit id="f2aff83bcff23ac45acdf9c1a74167660d420833" translate="yes" xml:space="preserve">
          <source>Using the Plugin with MariaDB Connector/C</source>
          <target state="translated">MariaDB 커넥터 / C와 함께 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="b45c75b102f53261cfc0347b99b3b23c21159f0e" translate="yes" xml:space="preserve">
          <source>Using the Plugin with MariaDB Connector/J</source>
          <target state="translated">MariaDB 커넥터 / J와 함께 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="ae4f153d943c40c1d04a2bc4353ea4b237a3df7e" translate="yes" xml:space="preserve">
          <source>Using the Plugin with MariaDB Connector/Node.js</source>
          <target state="translated">MariaDB 커넥터 /Node.js와 함께 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="3b18270283d6f918b483671998b68a76b994749f" translate="yes" xml:space="preserve">
          <source>Using the Plugin with MariaDB Connector/ODBC</source>
          <target state="translated">MariaDB 커넥터 / ODBC와 함께 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="d2685c16c176781a396b1e7a0207546c2f8c68f2" translate="yes" xml:space="preserve">
          <source>Using the Plugin with MySqlConnector for .NET</source>
          <target state="translated">.NET 용 MySqlConnector와 함께 플러그인 사용</target>
        </trans-unit>
        <trans-unit id="48884255bde4f4ff3e6a25bfec24fa622d9468f8" translate="yes" xml:space="preserve">
          <source>Using the PostgreSQL table testuuid in the text database:</source>
          <target state="translated">텍스트 데이터베이스에서 PostgreSQL 테이블 testuuid 사용 :</target>
        </trans-unit>
        <trans-unit id="12333e7c607983147c6e0cc211df6c39f2e2bc18" translate="yes" xml:space="preserve">
          <source>Using the S3 Storage Engine</source>
          <target state="translated">S3 스토리지 엔진 사용</target>
        </trans-unit>
        <trans-unit id="762a463295f0eff8fcdf1437080767b59688aa86" translate="yes" xml:space="preserve">
          <source>Using the S3 storage engine</source>
          <target state="translated">S3 스토리지 엔진 사용</target>
        </trans-unit>
        <trans-unit id="035716def65306d2104e07f24f0fe2f44a2dc7cb" translate="yes" xml:space="preserve">
          <source>Using the S3 storage engine.</source>
          <target state="translated">S3 스토리지 엔진 사용</target>
        </trans-unit>
        <trans-unit id="96e39b0ec0c3a325140761a9cf973f46e0cf65fa" translate="yes" xml:space="preserve">
          <source>Using the SHOW Statement</source>
          <target state="translated">SHOW 문 사용</target>
        </trans-unit>
        <trans-unit id="d545103bfef10b3c6ea63db5bc62142d7c92fe19" translate="yes" xml:space="preserve">
          <source>Using the SHOW Statements</source>
          <target state="translated">SHOW 문 사용</target>
        </trans-unit>
        <trans-unit id="a8538fe8ebc3a3bc4923093c1c8f21120a798ae1" translate="yes" xml:space="preserve">
          <source>Using the TABID special column</source>
          <target state="translated">TABID 특수 열 사용</target>
        </trans-unit>
        <trans-unit id="b7364ff02095d31aedad2b5d0df518aeb2f40c8f" translate="yes" xml:space="preserve">
          <source>Using the TBL and MYSQL types together</source>
          <target state="translated">TBL과 MYSQL 유형을 함께 사용</target>
        </trans-unit>
        <trans-unit id="8931c9c7f597a0575b937266da0ba6a96ad302cd" translate="yes" xml:space="preserve">
          <source>Using the analyzer is very simple.</source>
          <target state="translated">분석기 사용은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1460122feb2d9e1821483e317223131673a9769a" translate="yes" xml:space="preserve">
          <source>Using the awsctl Python Tool to Examine Data</source>
          <target state="translated">awsctl Python 도구를 사용하여 데이터 검사</target>
        </trans-unit>
        <trans-unit id="835f6fd91a111bca115d117b7c36c459fdc57e45" translate="yes" xml:space="preserve">
          <source>Using the awsctl Tool</source>
          <target state="translated">awsctl 도구 사용</target>
        </trans-unit>
        <trans-unit id="df09fb6037c8532195153ab8f9399d4ce7e6ad72" translate="yes" xml:space="preserve">
          <source>Using the first way, the connection string must be specified. This is sometimes the most difficult task when creating ODBC tables because, depending on the operating system and the data source, this string can widely differ.</source>
          <target state="translated">첫 번째 방법을 사용하여 연결 문자열을 지정해야합니다. 운영 체제 및 데이터 소스에 따라이 문자열이 크게 다를 수 있기 때문에 ODBC 테이블을 작성할 때 때로는 가장 어려운 작업입니다.</target>
        </trans-unit>
        <trans-unit id="4b1d11d51a64056e4feb873fef3ea0ca0c17b4da" translate="yes" xml:space="preserve">
          <source>Using the inplace syntax:</source>
          <target state="translated">인플레 이스 구문 사용 :</target>
        </trans-unit>
        <trans-unit id="e3760da0d3012ba78633b1fbb057d4b69da2fc37" translate="yes" xml:space="preserve">
          <source>Using the logging messages from the CDC Data Adapter, you can watch the binary events for this operation stream through MaxScale:</source>
          <target state="translated">CDC 데이터 어댑터의 로깅 메시지를 사용하여 MaxScale을 통해이 작업 스트림에 대한 이진 이벤트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="147e19b58574fcfb6a60be180b24a34ec0099e3a" translate="yes" xml:space="preserve">
          <source>Using the period to separate identifiers:</source>
          <target state="translated">마침표를 사용하여 식별자 분리 :</target>
        </trans-unit>
        <trans-unit id="c6030f9ba3a65691bd02c67ad7dfaaa692e145fb" translate="yes" xml:space="preserve">
          <source>Using the same sample data as the previous example:</source>
          <target state="translated">이전 예제와 동일한 샘플 데이터 사용</target>
        </trans-unit>
        <trans-unit id="0ead84ebf816c68cfe890ef215f83ea24b03a1a3" translate="yes" xml:space="preserve">
          <source>Using the same seed, the same sequence will be returned:</source>
          <target state="translated">동일한 시드를 사용하면 동일한 순서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="378feb456b10cdd3531c0711d85cb7d45a4be97f" translate="yes" xml:space="preserve">
          <source>Using the same string to format a date:</source>
          <target state="translated">동일한 문자열을 사용하여 날짜 형식을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7fe5a391bd6d42b46f35ecb6eaca0e82fc4bf18f" translate="yes" xml:space="preserve">
          <source>Using the table &lt;code&gt;oq2_graph&lt;/code&gt;, the shortest path is different:</source>
          <target state="translated">&lt;code&gt;oq2_graph&lt;/code&gt; 테이블을 사용하면 최단 경로가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cd32d060d679f013018e4f10059cb32cfa70801b" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;current_pos&lt;/code&gt; causes the slave to set its position based on the &lt;code&gt;&lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt;&lt;/code&gt; system variable, which is a union of &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt;. Using the value &lt;code&gt;slave_pos&lt;/code&gt; causes the slave to instead set its position based on the &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">값 사용 &lt;code&gt;current_pos&lt;/code&gt; 슬레이브 발생하면에 기초하여 그 위치를 설정 &lt;code&gt;&lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt;&lt;/code&gt; 용 의 조합 인 시스템 변수 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;slave_pos&lt;/code&gt; 값을 사용하면 슬레이브가 대신 &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수 에 따라 위치를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="e1be3651ffec5318bf36115ab4cfdaa7c1474d0b" translate="yes" xml:space="preserve">
          <source>Using this argument, MariaDB prints the argument list to stdout and then exits. You may find this useful in debugging to see how the options are set for the utility.</source>
          <target state="translated">이 인수를 사용하여 MariaDB는 인수 목록을 stdout에 인쇄 한 다음 종료합니다. 유틸리티에서 옵션이 설정되는 방법을 확인하기 위해 디버깅에이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f2c905c61ef5dedf93f8fdcdffc30b1a639c15" translate="yes" xml:space="preserve">
          <source>Using this command option, Mariabackup performs a backup operation on your database or databases. The backups are written to the target directory, as set by the &lt;code&gt;&lt;a href=&quot;#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">Mariabackup은이 명령 옵션을 사용하여 데이터베이스에서 백업 작업을 수행합니다. &lt;code&gt;&lt;a href=&quot;#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; 옵션 으로 설정 한대로 백업은 대상 디렉토리에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1c2e25f8b1e3372b17049e5508b63a4f93b63dc" translate="yes" xml:space="preserve">
          <source>Using this command option, you can set Mariabackup to stream the backup files to stdout in the given format. Currently, the supported format is &lt;code&gt;xbstream&lt;/code&gt;.</source>
          <target state="translated">이 명령 옵션을 사용하면 Mariabackup이 지정된 형식으로 백업 파일을 stdout으로 스트리밍하도록 설정할 수 있습니다. 현재 지원되는 형식은 &lt;code&gt;xbstream&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e791227dafd87ec5d6557817a6844eca9b0df8ba" translate="yes" xml:space="preserve">
          <source>Using this command, Mariabackup copies the backup from the target directory to the data directory, as defined by the &lt;code&gt;&lt;a href=&quot;#-h-datadir&quot;&gt;--datadir&lt;/a&gt;&lt;/code&gt; option. You must stop the MariaDB Server before running this command. The data directory must be empty. If you want to overwrite the data directory with the backup, use the &lt;code&gt;&lt;a href=&quot;#-force-non-empty-directories&quot;&gt;--force-non-empty-directories&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 명령을 사용하여 Mariabackup은 &lt;code&gt;&lt;a href=&quot;#-h-datadir&quot;&gt;--datadir&lt;/a&gt;&lt;/code&gt; 옵션 으로 정의 된대로 백업을 대상 디렉토리에서 데이터 디렉토리로 복사합니다 . 이 명령을 실행하기 전에 MariaDB 서버를 중지해야합니다. 데이터 디렉토리는 비어 있어야합니다. 백업으로 데이터 디렉토리를 덮어 &lt;code&gt;&lt;a href=&quot;#-force-non-empty-directories&quot;&gt;--force-non-empty-directories&lt;/a&gt;&lt;/code&gt; 려면 --force-non-empty-directories 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ac855d415eb2246f029c9258ddc865059c3e950" translate="yes" xml:space="preserve">
          <source>Using this command, Mariabackup moves the backup from the target directory to the data directory, as defined by the &lt;code&gt;&lt;a href=&quot;#-h-datadir&quot;&gt;--datadir&lt;/a&gt;&lt;/code&gt; option. You must stop the MariaDB Server before running this command. The data directory must be empty. If you want to overwrite the data directory with the backup, use the &lt;code&gt;&lt;a href=&quot;#-force-non-empty-directories&quot;&gt;--force-non-empty-directories&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 명령을 사용하면 Mariabackup은 &lt;code&gt;&lt;a href=&quot;#-h-datadir&quot;&gt;--datadir&lt;/a&gt;&lt;/code&gt; 옵션 으로 정의 된대로 백업을 대상 디렉토리에서 데이터 디렉토리로 이동합니다 . 이 명령을 실행하기 전에 MariaDB 서버를 중지해야합니다. 데이터 디렉토리는 비어 있어야합니다. 백업으로 데이터 디렉토리를 덮어 &lt;code&gt;&lt;a href=&quot;#-force-non-empty-directories&quot;&gt;--force-non-empty-directories&lt;/a&gt;&lt;/code&gt; 려면 --force-non-empty-directories 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6f6f3ee23ef2aba1af339b94c5e7153a7f21df5" translate="yes" xml:space="preserve">
          <source>Using this format makes for a more readable SQL than a nested &lt;code&gt;FROM(SELECT ...)&lt;/code&gt; clause. Below is an example of this:</source>
          <target state="translated">이 형식을 사용하면 중첩 된 &lt;code&gt;FROM(SELECT ...)&lt;/code&gt; 절 보다 더 읽기 쉬운 SQL이 됩니다. 아래는 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="9721ffb7d26db9ec7166b93cf73e17e746e1c08d" translate="yes" xml:space="preserve">
          <source>Using this function a GUI application can pop up a dialog window, a network application can send the question over the network, as required. If no &lt;code&gt;mysql_authentication_dialog_ask&lt;/code&gt; function is provided by the application, the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; client authentication plugin falls back to &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/3/fputs&quot;&gt;fputs()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/3/fgets&quot;&gt;fgets()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하면 GUI 응용 프로그램이 대화 상자 창을 띄울 수 있으며, 네트워크 응용 프로그램은 필요에 따라 네트워크를 통해 질문을 보낼 수 있습니다. 응용 프로그램에서 &lt;code&gt;mysql_authentication_dialog_ask&lt;/code&gt; 함수를 제공 하지 않으면 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; 클라이언트 인증 플러그인이 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/3/fputs&quot;&gt;fputs()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/3/fgets&quot;&gt;fgets()&lt;/a&gt;&lt;/code&gt; 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="701d4b7e5e3279d01ab091b33dfa7e2161ddcb29" translate="yes" xml:space="preserve">
          <source>Using this option causes Mariabackup to disable table locks with the &lt;code&gt;FLUSH TABLE WITH READ LOCK&lt;/code&gt; statement. Only use this option if:</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 &lt;code&gt;FLUSH TABLE WITH READ LOCK&lt;/code&gt; 문으로 테이블 잠금을 비활성화합니다 . 다음과 같은 경우에만이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0dc4024b6be37c4b8df6a9262fa66b88a167f6ac" translate="yes" xml:space="preserve">
          <source>Using this option has no effect. It is available to provide compatibility with the MariaDB Server.</source>
          <target state="translated">이 옵션을 사용해도 효과가 없습니다. MariaDB 서버와의 호환성을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3307e236e5b903cb63c994105920203c36eb15db" translate="yes" xml:space="preserve">
          <source>Using this option with &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; command option makes the operation incremental rather than a complete overwrite. Mariabackup will apply &lt;code&gt;.delta&lt;/code&gt; files and log files into the target directory.</source>
          <target state="translated">이 옵션을 &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 명령 옵션과 함께 사용하면 전체 덮어 쓰기가 아니라 증분 작업이 수행됩니다. Mariabackup이 적용됩니다 &lt;code&gt;.delta&lt;/code&gt; 대상 디렉토리에 파일과 로그 파일을.</target>
        </trans-unit>
        <trans-unit id="dc8527ca3ab4d4607518e7dc775827498f295b98" translate="yes" xml:space="preserve">
          <source>Using this option with the &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; command option makes the operation incremental rather than a complete overwrite. Mariabackup will only copy pages from &lt;code&gt;.ibd&lt;/code&gt; files if they are newer than the backup in the specified directory.</source>
          <target state="translated">이 옵션을 &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 명령 옵션과 함께 사용하면 전체 덮어 쓰기가 아니라 증분 작업이 수행됩니다. Mariabackup은 &lt;code&gt;.ibd&lt;/code&gt; 파일의 페이지 가 지정된 디렉토리의 백업보다 최신 인 경우 에만 페이지를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="cb23f556985ff07167b3f55e96e0a71959b0861a" translate="yes" xml:space="preserve">
          <source>Using this option with the &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; command option makes the operation incremental rather than a complete overwrite. When this option is specified, either the &lt;code&gt;&lt;a href=&quot;#-incremental-lsn&quot;&gt;--incremental-lsn&lt;/a&gt; or &lt;/code&gt;&lt;a href=&quot;#-incremental-basedir&quot;&gt;--incremental-basedir&lt;/a&gt;&lt;code&gt; options can also be given. If neither option is given, option &lt;/code&gt;&lt;a href=&quot;#-incremental-basedir&quot;&gt;--incremental-basedir&lt;/a&gt;&lt;code&gt; is used by default, set to the first timestamped backup directory in the backup base directory.&lt;/code&gt;</source>
          <target state="translated">이 옵션을 &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 명령 옵션과 함께 사용하면 전체 덮어 쓰기가 아니라 증분 작업이 수행됩니다. 이 옵션을 지정하면 &lt;code&gt;&lt;a href=&quot;#-incremental-lsn&quot;&gt;--incremental-lsn&lt;/a&gt; or &lt;/code&gt; &lt;a href=&quot;#-incremental-basedir&quot;&gt;--incremental-basedir &lt;/a&gt; &lt;code&gt; options can also be given. If neither option is given, option &lt;/code&gt; &lt;code&gt; is used by default, set to the first timestamped backup directory in the backup base directory.&lt;/code&gt; &lt;a href=&quot;#-incremental-basedir&quot;&gt;--incremental-basedir &lt;/a&gt;옵션 이 사용되며 백업 기본 디렉토리에서 타임 스탬프가 지정된 첫 번째 백업 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="036edc319e6aee64a01e7e834b8bfd46716bda6b" translate="yes" xml:space="preserve">
          <source>Using this option you can define the destination directory for the backup. Mariabackup writes all backup files to this directory. Mariabackup will create the directory, if it does not exist (but it will not create the full path recursively, i.e. at least parent directory if the --target-dir must exist=</source>
          <target state="translated">이 옵션을 사용하면 백업 대상 디렉토리를 정의 할 수 있습니다. Mariabackup은 모든 백업 파일을이 디렉토리에 씁니다. Mariabackup은 디렉토리가 존재하지 않는 경우 디렉토리를 작성합니다 (하지만 --target-dir이 존재해야하는 경우 적어도 상위 디렉토리).</target>
        </trans-unit>
        <trans-unit id="f161ba6e8bd126b66a292b382d0e98cc3e3e4624" translate="yes" xml:space="preserve">
          <source>Using this option you, you can set the base name for Mariabackup to use in log sequences.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 로그 순서에 사용할 기본 이름을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ad9f999972635485a855e0ebfc5ea8a2bd5d8b" translate="yes" xml:space="preserve">
          <source>Using this option, Mariabackup prints to stdout the MariaDB Server options that the utility requires to run the &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; command option.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup은 유틸리티가 &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; 명령 옵션 을 실행하는 데 필요한 MariaDB 서버 옵션을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="068e46ec5fa0f8c0ab622a8fc4f4e9b13358ead5" translate="yes" xml:space="preserve">
          <source>Using this option, you can configure Mariabackup to dump its core to file in the event that it encounters fatal signals. You may find this useful for review and debugging purposes.</source>
          <target state="translated">이 옵션을 사용하면 치명적인 신호가 발생할 경우 Mariabackup이 코어를 파일로 덤프하도록 구성 할 수 있습니다. 검토 및 디버깅 목적으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df7c1b1dc88e1b94789a723972219ff34b9a2d64" translate="yes" xml:space="preserve">
          <source>Using this option, you can control how Mariabackup retrieves the server's binary log coordinates corresponding to the backup.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 백업에 해당하는 서버의 이진 로그 좌표를 검색하는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a2d145ecdc56df2bc59258364400c550e78b30" translate="yes" xml:space="preserve">
          <source>Using this option, you can define a default &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; for Mariabackup. Unlike the &lt;code&gt;&lt;a href=&quot;#-defaults-extra-file&quot;&gt;--defaults-extra-file&lt;/a&gt;&lt;/code&gt; option, when this option is provided, it completely replaces all default &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option files&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup 의 기본 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 을 정의 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#-defaults-extra-file&quot;&gt;--defaults-extra-file&lt;/a&gt;&lt;/code&gt; 옵션 과 달리이 옵션이 제공되면 모든 기본 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일을&lt;/a&gt; 완전히 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="2e9fc92ce1a8c592a79f6e0fb66901acb908d05f" translate="yes" xml:space="preserve">
          <source>Using this option, you can define an extra default &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; for Mariabackup. Unlike &lt;code&gt;&lt;a href=&quot;#-defaults-file&quot;&gt;--defaults-file&lt;/a&gt;&lt;/code&gt;, this file is read after the default &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option files&lt;/a&gt; are read, allowing you to only overwrite the existing defaults.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup에 대한 추가 기본 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 을 정의 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#-defaults-file&quot;&gt;--defaults-file&lt;/a&gt;&lt;/code&gt; 과 달리이 파일은 기본 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일을&lt;/a&gt; 읽은 후에 읽으므로 기존 기본값 만 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1074c244deea1f54f484bf260779f1991362879b" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the UNIX domain socket you want to use when connecting to a local database server. The option accepts a string argument. For more information, see the &lt;code&gt;mysql --help&lt;/code&gt; command.</source>
          <target state="translated">이 옵션을 사용하면 로컬 데이터베이스 서버에 연결할 때 사용하려는 UNIX 도메인 소켓을 정의 할 수 있습니다. 이 옵션은 문자열 인수를 허용합니다. 자세한 내용은 &lt;code&gt;mysql --help&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08b58fcfbec0ea6d942d956152916f4f1e630ea1" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the buffer pool size for Mariabackup. Use it instead of &lt;code&gt;buffer_pool_size&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup의 버퍼 풀 크기를 정의 할 수 있습니다. &lt;code&gt;buffer_pool_size&lt;/code&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a2322ec90b891211adf18f318f059ee7d070726" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the copy interval Mariabackup uses between checks done by the log copying thread. The given value is in milliseconds.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 로그 복사 스레드가 수행 한 검사 사이에 사용하는 복사 간격을 정의 할 수 있습니다. 주어진 값은 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c7dfc8271278570bbf4e9d901d2ebe7cdd9a4fbc" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the encryption plugin you want to load. It is only used during the &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; phase to load the encryption plugin. It defaults to the server &lt;code&gt;--plugin-load&lt;/code&gt; option.</source>
          <target state="translated">이 옵션을 사용하여로드하려는 암호화 플러그인을 정의 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 단계 에서만 암호화 플러그인을로드하는 데 사용됩니다 . 기본값은 server &lt;code&gt;--plugin-load&lt;/code&gt; 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="8a7e8e4d9ab02fbdc311453ca2b68b95e875a1d8" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the host to use when connecting to a MariaDB Server over TCP/IP. By default, Mariabackup attempts to connect to the local host.</source>
          <target state="translated">이 옵션을 사용하면 TCP / IP를 통해 MariaDB 서버에 연결할 때 사용할 호스트를 정의 할 수 있습니다. 기본적으로 Mariabackup은 로컬 호스트에 연결을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="772010699222a76c98c4efdd771e5a44825b1950" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the maximum number of file descriptors Mariabackup reserves with &lt;code&gt;setrlimit()&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;setrlimit()&lt;/code&gt; Mariabackup이 예약하는 최대 파일 디스크립터 수를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4996151c56b56eb69d2f1a1dac05604987ef37c" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the path Mariabackup reads for MariaDB Server plugins. It only uses it during the &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; phase to load the encryption plugin. It defaults to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; server system variable.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 MariaDB 서버 플러그인에 대해 읽는 경로를 정의 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 단계 중에 만 사용 하여 암호화 플러그인을로드합니다. 기본값은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수입니다.</target>
        </trans-unit>
        <trans-unit id="a2338afc081c96684a5fce12609c90dae86ff022" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the path to a directory Mariabackup uses in writing temporary files. If you want to use more than one, separate the values by a semicolon (that is, &lt;code&gt;;&lt;/code&gt;). When passing multiple temporary directories, it cycles through them using round-robin.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 임시 파일을 작성할 때 사용하는 디렉토리의 경로를 정의 할 수 있습니다. 둘 이상을 사용하려면 값을 세미콜론 (즉, &lt;code&gt;;&lt;/code&gt; ) 으로 구분하십시오 . 여러 임시 디렉토리를 전달할 때 라운드 로빈을 사용하여 순환합니다.</target>
        </trans-unit>
        <trans-unit id="cf94d8885ff2fa663b7a0c52ec4f70ef580982e0" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the path to the source directory. This is the directory that Mariabackup reads for the data it backs up. It should be the same as the MariaDB Server &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">이 옵션을 사용하면 소스 디렉토리의 경로를 정의 할 수 있습니다. 이것은 Mariabackup이 백업하는 데이터를 읽는 디렉토리입니다. MariaDB 서버 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 시스템 변수 와 동일해야 합니다.</target>
        </trans-unit>
        <trans-unit id="23c599e83810daa16022cc0ec632b816366019c7" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the sequence number (LSN) value for &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; operations. During backups, Mariabackup only copies &lt;code&gt;.ibd&lt;/code&gt; pages newer than the specified values.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 작업 의 시퀀스 번호 (LSN) 값을 정의 할 수 있습니다 . 백업 중에 Mariabackup 은 지정된 값보다 최신의 &lt;code&gt;.ibd&lt;/code&gt; 페이지 만 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="20077f250fb069fec73684a0146d4244f88d1618" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the specific database or databases you want to back up. In cases where you have a particularly large database or otherwise only want to back up a portion of it, you can optionally also define the tables on the database.</source>
          <target state="translated">이 옵션을 사용하여 백업하려는 특정 데이터베이스를 정의 할 수 있습니다. 특히 큰 데이터베이스가 있거나 데이터베이스의 일부만 백업하려는 경우 데이터베이스에서 테이블을 선택적으로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e7fef24c7676f8fc5232fd9bfa016d986f7226" translate="yes" xml:space="preserve">
          <source>Using this option, you can define the specific database or databases you want to exclude from the backup process. You may find it useful when you want to back up most databases on the server or tables on a database, but would like to exclude a few from the process.</source>
          <target state="translated">이 옵션을 사용하면 백업 프로세스에서 제외 할 특정 데이터베이스를 정의 할 수 있습니다. 서버의 대부분의 데이터베이스 나 데이터베이스의 테이블을 백업하려고하지만 프로세스에서 일부를 제외하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd13ad0c56b93a60ac298788cd3ebcc6b1302886" translate="yes" xml:space="preserve">
          <source>Using this option, you can define what tables you want Mariabackup to back up from the database. The table values are defined using Regular Expressions. To define the tables you want to exclude from the backup, see the &lt;code&gt;&lt;a href=&quot;#-tables-exclude&quot;&gt;--tables-exclude&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션을 사용하면 데이터베이스에서 Mariabackup이 백업 할 테이블을 정의 할 수 있습니다. 테이블 값은 정규식을 사용하여 정의됩니다. 백업에서 제외하려는 테이블을 정의하려면 &lt;code&gt;&lt;a href=&quot;#-tables-exclude&quot;&gt;--tables-exclude&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="218ec12faebd80c0157617269b90bd8f4e970c2b" translate="yes" xml:space="preserve">
          <source>Using this option, you can define what tables you want Mariabackup to exclude from the backup. The table values are defined using Regular Expressions. To define the tables you want to include from the backup, see the &lt;code&gt;&lt;a href=&quot;#-tables&quot;&gt;--tables&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup에서 백업에서 제외 할 테이블을 정의 할 수 있습니다. 테이블 값은 정규식을 사용하여 정의됩니다. 백업에서 포함 할 테이블을 정의하려면 &lt;code&gt;&lt;a href=&quot;#-tables&quot;&gt;--tables&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="745b86051b943df171a16fb82d3ab7095f9660f5" translate="yes" xml:space="preserve">
          <source>Using this option, you can disable Mariabackup version check. If you would like to enable the version check, use the &lt;code&gt;&lt;a href=&quot;#-version-check&quot;&gt;--version-check&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup 버전 확인을 비활성화 할 수 있습니다. 버전 확인을 활성화하려면 &lt;code&gt;&lt;a href=&quot;#-version-check&quot;&gt;--version-check&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="422cb6b6ecbb47c8fd006db0217f1219e266324d" translate="yes" xml:space="preserve">
          <source>Using this option, you can enable Mariabackup version check. If you would like to disable the version check, use the &lt;code&gt;&lt;a href=&quot;#-no-version-check&quot;&gt;--no-version-check&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup 버전 확인을 활성화 할 수 있습니다. 버전 확인을 비활성화하려면 &lt;code&gt;&lt;a href=&quot;#-no-version-check&quot;&gt;--no-version-check&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="abce6bfdf02de4113e16e70f2cf1ff123f21523e" translate="yes" xml:space="preserve">
          <source>Using this option, you can print the Mariabackup version information to stdout.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup 버전 정보를 stdout에 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe2b2c32b2b32e644891b3c11e32e220bda3ec6" translate="yes" xml:space="preserve">
          <source>Using this option, you can set a limit on the I/O operations Mariabackup performs per second in IOS values. It is only used during the &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; command option.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 IOS 값에서 초당 수행하는 I / O 작업에 대한 제한을 설정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 명령 옵션 중에 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e479f102e4ea7ee4f06a57973a5508b32d10724" translate="yes" xml:space="preserve">
          <source>Using this option, you can set a path to a file listing the tables you want to back up. Mariabackup iterates over each line in the file. The format is &lt;code&gt;database.table&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하여 백업하려는 테이블을 나열하는 파일의 경로를 설정할 수 있습니다. Mariabackup은 파일의 각 줄을 반복합니다. 형식은 &lt;code&gt;database.table&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="90c9846f8d50fbb5dda69cdc4027b2a549f828fb" translate="yes" xml:space="preserve">
          <source>Using this option, you can set it accept client connections to the server when using the older protocol, from before 4.1.1. By default, it refuses these connections. Use the &lt;code&gt;&lt;a href=&quot;#-secure-auth&quot;&gt;--secure-auth&lt;/a&gt;&lt;/code&gt; option to explicitly enable it.</source>
          <target state="translated">이 옵션을 사용하면 4.1.1 이전의 이전 프로토콜을 사용할 때 서버에 대한 클라이언트 연결을 허용하도록 설정할 수 있습니다. 기본적으로 이러한 연결은 거부됩니다. 사용 &lt;code&gt;&lt;a href=&quot;#-secure-auth&quot;&gt;--secure-auth&lt;/a&gt;&lt;/code&gt; 명시 적으로 활성화하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3cb227916210de43da63adb88f924d21726dab50" translate="yes" xml:space="preserve">
          <source>Using this option, you can set it explicitly to refuse client connections to the server when using the older protocol, from before 4.1.1. This feature is enabled by default. Use the &lt;code&gt;&lt;a href=&quot;#-skip-secure-auth&quot;&gt;--skip-secure-auth&lt;/a&gt;&lt;/code&gt; option to disable it.</source>
          <target state="translated">이 옵션을 사용하면 4.1.1 이전의 이전 프로토콜을 사용할 때 서버에 대한 클라이언트 연결을 거부하도록 명시 적으로 설정할 수 있습니다. 이 기능은 기본적으로 활성화되어 있습니다. 사용 &lt;code&gt;&lt;a href=&quot;#-skip-secure-auth&quot;&gt;--skip-secure-auth&lt;/a&gt;&lt;/code&gt; 사용하지 않도록 설정하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="633abff7207cbdd21d3263961096a7427d8924cb" translate="yes" xml:space="preserve">
          <source>Using this option, you can set the number of threads Mariabackup uses for parallel data file transfers. By default, it is set to 1.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 병렬 데이터 파일 전송에 사용하는 스레드 수를 설정할 수 있습니다. 기본적으로 1로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f3aba53be9684bb6117535ef23dedf29548b7ee" translate="yes" xml:space="preserve">
          <source>Using this option, you can tell Mariabackup that you want to close file handles. Without this option, Mariabackup keeps files open in order to manage DDL operations. When working with particularly large tablespaces, closing the file can make the backup more manageable. However, it can also lead to inconsistent backups. Use at your own risk.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup에 파일 핸들을 닫으라고 알릴 수 있습니다. 이 옵션이 없으면 Mariabackup은 DDL 작업을 관리하기 위해 파일을 열어 둡니다. 특히 큰 테이블 스페이스로 작업 할 때 파일을 닫으면 백업을보다 쉽게 ​​관리 할 수 ​​있습니다. 그러나 일관성이없는 백업으로 이어질 수도 있습니다. 자신의 책임하에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0c198e4db94cc061fb9fbb7fe19b1023b6f32528" translate="yes" xml:space="preserve">
          <source>Using this option, you can tell Mariabackup to compress its backup files before writing them to disk. You may find this useful when backing up particularly large databases.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup이 백업 파일을 디스크에 쓰기 전에 압축하도록 지시 할 수 있습니다. 특히 큰 데이터베이스를 백업 할 때이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="490137d0d7fa0ac2d6a5b9e20f1dd86cc885bb98" translate="yes" xml:space="preserve">
          <source>Using this variant the first (#0) csv source column is mapped to the target ColumnStore column with the name &lt;em&gt;id&lt;/em&gt;, and the fifth source csv column (#4) is mapped to the target ColumnStore column with the name &lt;em&gt;salary&lt;/em&gt;. It further defines that the target ColumnStore column timestamp uses a default value of &lt;em&gt;2018-09-13 12:00:00&lt;/em&gt; for the injection.</source>
          <target state="translated">이 변형을 사용하면 첫 번째 (# 0) csv 소스 열이 이름이 &lt;em&gt;id&lt;/em&gt; 인 대상 ColumnStore 열에 매핑되고 다섯 번째 소스 csv 열 (# 4)이 이름이 &lt;em&gt;salary 인&lt;/em&gt; 대상 ColumnStore 열에 매핑됩니다 . 또한 대상 ColumnStore 열 타임 스탬프가 주입에 기본값 &lt;em&gt;2018-09-13 12:00:00&lt;/em&gt; 을 사용하도록 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f02ea1024d7763e8485ddc2bee895a72f08d20ef" translate="yes" xml:space="preserve">
          <source>Using time periods implicitly defines the two columns as &lt;code&gt;NOT NULL&lt;/code&gt;. It also adds a constraint to check whether the first value is less than the second value. The constraint is invisible to &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; statements. The name of this constraint is prefixed by the time period name, to avoid conflict with other constraints.</source>
          <target state="translated">기간을 사용하면 두 열이 암시 적으로 &lt;code&gt;NOT NULL&lt;/code&gt; 로 정의 됩니다 . 또한 첫 번째 값이 두 번째 값보다 작은 지 여부를 확인하는 제약 조건을 추가합니다. &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; 문 에는 제약 조건이 보이지 않습니다 . 다른 제약 조건과의 충돌을 피하기 위해이 제약 조건의 이름 앞에 기간 이름이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="1d8d44bc942083e21426edde2cc43ca08b4c7acd" translate="yes" xml:space="preserve">
          <source>Using two &lt;code&gt;--verbose&lt;/code&gt; options will also give you connection information.</source>
          <target state="translated">두 가지 &lt;code&gt;--verbose&lt;/code&gt; 옵션을 사용 하면 연결 정보도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bb8ee833c05c8f5b6ae685c94db8a13d8bf607" translate="yes" xml:space="preserve">
          <source>Using unix_socket means that if you are the system root user, you can login as root@locahost without a password. This technique was pioneered by Otto Kek&amp;auml;l&amp;auml;inen in Debian MariaDB packages and has been successfully &lt;a href=&quot;../differences-in-mariadb-in-debian-and-ubuntu/index&quot;&gt;used in Debian&lt;/a&gt; since as early as &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;.</source>
          <target state="translated">unix_socket을 사용하면 시스템 루트 사용자 인 경우 비밀번호없이 root @ locahost로 로그인 할 수 있습니다. 이 기술은 데비안 MariaDB 패키지의 오토 켈리 넨 (Otto Kek&amp;auml;l&amp;auml;inen)에 의해 개척되었으며 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 부터 &lt;a href=&quot;../differences-in-mariadb-in-debian-and-ubuntu/index&quot;&gt;데비안에서&lt;/a&gt; 성공적으로 사용 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="39c504062d5fd75db22c25a0b3253f134345383f" translate="yes" xml:space="preserve">
          <source>Using user defined aggregate functions</source>
          <target state="translated">사용자 정의 집계 함수 사용</target>
        </trans-unit>
        <trans-unit id="473d660cb43e8e4e31d63aa0895e961a5d0bdb87" translate="yes" xml:space="preserve">
          <source>Using wget to retrieve packages</source>
          <target state="translated">wget을 사용하여 패키지 검색</target>
        </trans-unit>
        <trans-unit id="19adc553880b640094b80424121d22a6aafd82e8" translate="yes" xml:space="preserve">
          <source>Using where</source>
          <target state="translated">어디에 사용</target>
        </trans-unit>
        <trans-unit id="cdcaa47f48df189acda12f022a16e3e5b5c1de85" translate="yes" xml:space="preserve">
          <source>Using where; Using join buffer (flat, BNL join)</source>
          <target state="translated">어디에 사용; 결합 버퍼 사용 (플랫, BNL 결합)</target>
        </trans-unit>
        <trans-unit id="bfed6dd36e0bee8ba253593bd0f13a2be0c464e5" translate="yes" xml:space="preserve">
          <source>Using with AUTO_INCREMENT</source>
          <target state="translated">AUTO_INCREMENT와 함께 사용</target>
        </trans-unit>
        <trans-unit id="791c5d0b0e4b2b0ca27a51fd388c76aa829dd286" translate="yes" xml:space="preserve">
          <source>Using with DML</source>
          <target state="translated">DML과 함께 사용</target>
        </trans-unit>
        <trans-unit id="9f38bc5dc5afe3d5d01d8359de5d02fe18a01640" translate="yes" xml:space="preserve">
          <source>Using with Foreign Keys</source>
          <target state="translated">외래 키와 함께 사용</target>
        </trans-unit>
        <trans-unit id="574ec0b39fa4be85e688d25d447a8de9c26e7e94" translate="yes" xml:space="preserve">
          <source>Using with Replication</source>
          <target state="translated">복제와 함께 사용</target>
        </trans-unit>
        <trans-unit id="c72c54b37563730bba7573cb5f4af7f134f58e0e" translate="yes" xml:space="preserve">
          <source>Using with Triggers</source>
          <target state="translated">트리거와 함께 사용</target>
        </trans-unit>
        <trans-unit id="64240a9641007dfeb9d2d0f0ed6a1de48bc4b809" translate="yes" xml:space="preserve">
          <source>Using with Virtual Columns</source>
          <target state="translated">가상 열과 함께 사용</target>
        </trans-unit>
        <trans-unit id="fdd302dbe04026c34e243a492989803ac86eb6a6" translate="yes" xml:space="preserve">
          <source>Using_Gtid</source>
          <target state="translated">Using_Gtid</target>
        </trans-unit>
        <trans-unit id="6c6171181ed9aa851be1368967d656c88470cc89" translate="yes" xml:space="preserve">
          <source>Usually a file in the data directory, but some distributions may move this to other locations.</source>
          <target state="translated">일반적으로 데이터 디렉토리에있는 파일이지만 일부 배포판에서는이 파일을 다른 위치로 옮길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd656956b406bf2d9ab4096fc7e058349948337" translate="yes" xml:space="preserve">
          <source>Usually the &lt;code&gt;pam&lt;/code&gt; authentication plugin uses the &lt;code&gt;dialog&lt;/code&gt; client authentication plugin to communicate with the user. This client authentication plugin allows MariaDB to support arbitrarily complex PAM configurations with regular or one-time passwords, challenge-response, multiple questions, or just about anything else. When using a MariaDB client library, there is no need to install or enable anything &amp;mdash; the &lt;code&gt;dialog&lt;/code&gt; client authentication plugin is loaded by the client library completely automatically and transparently for the application.</source>
          <target state="translated">일반적으로 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인은 &lt;code&gt;dialog&lt;/code&gt; 클라이언트 인증 플러그인을 사용하여 사용자와 통신합니다. 이 클라이언트 인증 플러그인을 사용하면 MariaDB는 일반 또는 일회성 비밀번호, 챌린지 응답, 여러 질문 또는 기타 다른 방법으로 임의의 복잡한 PAM 구성을 지원할 수 있습니다. MariaDB 클라이언트 라이브러리를 사용하는 경우 아무 것도 설치하거나 활성화 할 필요가 없습니다. &lt;code&gt;dialog&lt;/code&gt; 클라이언트 클라이언트 인증 플러그인은 클라이언트 라이브러리에 의해 애플리케이션에 대해 완전히 자동으로 투명하게로드됩니다.</target>
        </trans-unit>
        <trans-unit id="a024e22143f8e9473807797ded3833b39962c0af" translate="yes" xml:space="preserve">
          <source>Usually, the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_threads&quot;&gt;slave_parallel_threads&lt;/a&gt;&lt;/code&gt; system variable should be set large enough that the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL thread&lt;/a&gt; is able to read far enough ahead in the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; to exploit all possible parallelism. In normal operation, the slave will hopefully not be too far behind, so there will not be a need to queue much data in-memory. The &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; system variable could be set fairly high (eg. a few hundred kilobytes) to not limit throughtput. It should just be set low enough that total allocation of the parallel slave queue will not cause the server to run out of memory.</source>
          <target state="translated">일반적으로 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_threads&quot;&gt;slave_parallel_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수는 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL 스레드&lt;/a&gt; 가 모든 가능한 병렬 처리를 이용할 수 있도록 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 에서 충분히 미리 읽을 수 있도록 충분히 크게 설정해야합니다 . 정상적인 작동에서 슬레이브는 그리 멀지 않기 때문에 많은 데이터를 메모리에 대기시킬 필요가 없습니다. &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; 시스템 변수는 상당히 높게 설정 될 수있다 (예. 몇 백 킬로바이트) throughtput 제한하지에. 병렬 슬레이브 큐의 총 할당으로 인해 서버의 메모리가 부족하지 않도록 충분히 낮게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8d899450c6db0865af6b302b24e9fe87c47d6e5" translate="yes" xml:space="preserve">
          <source>Utilities and commands to monitor queries and their performance</source>
          <target state="translated">쿼리 및 성능을 모니터링하기위한 유틸리티 및 명령</target>
        </trans-unit>
        <trans-unit id="d529cb46308b7a7b2b49fc7226de3a98fb6a1782" translate="yes" xml:space="preserve">
          <source>Utility Functions (sp.{cc,h})</source>
          <target state="translated">유틸리티 기능 (sp. {cc, h})</target>
        </trans-unit>
        <trans-unit id="8a7369317803196378a5bf7f02a5a2a12718870b" translate="yes" xml:space="preserve">
          <source>Utility for checking, repairing and optimizing MyISAM tables</source>
          <target state="translated">MyISAM 테이블 확인, 복구 및 최적화를위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="879e37cb3efa4f1eab2fa6864e09de15831b4dde" translate="yes" xml:space="preserve">
          <source>Utility functions: sp.h</source>
          <target state="translated">유틸리티 기능 : sp.h</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="a233c97c0e0d408aa16514aa47612c141d792c93" translate="yes" xml:space="preserve">
          <source>VALUES / VALUE</source>
          <target state="translated">가치 / 가치</target>
        </trans-unit>
        <trans-unit id="6413f6e990cc130b6c6fd1a2a9fd846cfaaabee7" translate="yes" xml:space="preserve">
          <source>VALUES LESS THAN value must be strictly increasing for each partition</source>
          <target state="translated">VALUES LESS THAN 값은 각 파티션마다 엄격하게 증가해야합니다.</target>
        </trans-unit>
        <trans-unit id="18e886407c85d1d56aef70c5357b5821dfd7e78a" translate="yes" xml:space="preserve">
          <source>VALUES or VALUE</source>
          <target state="translated">VALUES 또는 VALUE</target>
        </trans-unit>
        <trans-unit id="e5c3c25f58f19ec83323980db28ea255a19b1de1" translate="yes" xml:space="preserve">
          <source>VALUES value for partition '%s' must have type INT</source>
          <target state="translated">파티션 '% s'의 VALUES 값은 INT 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e8e3112df2d11aaddf57985f7bbc20479f704ee" translate="yes" xml:space="preserve">
          <source>VALUES value must be of same type as partition function</source>
          <target state="translated">VALUES 값은 파티션 함수와 동일한 유형이어야합니다</target>
        </trans-unit>
        <trans-unit id="078b20ab7f25e62fb4bd887f3e59d2cece1801e6" translate="yes" xml:space="preserve">
          <source>VALUES()</source>
          <target state="translated">VALUES()</target>
        </trans-unit>
        <trans-unit id="6b6e786e223d9b954b802ff638e926c4159d2a1f" translate="yes" xml:space="preserve">
          <source>VARBINARY</source>
          <target state="translated">VARBINARY</target>
        </trans-unit>
        <trans-unit id="9e87e268750621f0ace4fef3481ab52235890e65" translate="yes" xml:space="preserve">
          <source>VARBINARY(n)</source>
          <target state="translated">VARBINARY(n)</target>
        </trans-unit>
        <trans-unit id="1c8cb63784765ee96870738d11438df61db7ccf7" translate="yes" xml:space="preserve">
          <source>VARCHAR</source>
          <target state="translated">VARCHAR</target>
        </trans-unit>
        <trans-unit id="30096322fa924ef6cbb53c0d1db52925730426c3" translate="yes" xml:space="preserve">
          <source>VARCHAR columns can be fully indexed. &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; columns can only be indexed over a specified length.</source>
          <target state="translated">VARCHAR 컬럼은 완전히 색인화 될 수 있습니다. &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 열은 지정된 길이에 대해서만 색인을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20cadca35df2d5958ff661d2098bd5fae6d2ee84" translate="yes" xml:space="preserve">
          <source>VARCHAR is shorthand for CHARACTER VARYING. NATIONAL VARCHAR is the standard SQL way to define that a VARCHAR column should use some predefined character set. MariaDB uses utf8 as this predefined character set, as does MySQL 4.1 and up. NVARCHAR is shorthand for NATIONAL VARCHAR.</source>
          <target state="translated">VARCHAR은 CHARACTER VARYING의 약어입니다. NATIONAL VARCHAR은 VARCHAR 열이 사전 정의 된 문자 세트를 사용해야 함을 정의하는 표준 SQL 방법입니다. MariaDB는 MySQL 4.1 이상과 같이 utf8을이 사전 정의 된 문자 세트로 사용합니다. NVARCHAR은 NATIONAL VARCHAR의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="e81843f0b8cedeee1c06abb88e6769e49d9b69ec" translate="yes" xml:space="preserve">
          <source>VARCHAR vs BLOB</source>
          <target state="translated">바차 vs BLOB</target>
        </trans-unit>
        <trans-unit id="06b6391da9f316576edbd82dafb6d09a9b7bb5db" translate="yes" xml:space="preserve">
          <source>VARCHAR(0) columns can contain 2 values: an empty string or NULL. Such columns cannot be part of an index. The &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; storage engine does not support VARCHAR(0).</source>
          <target state="translated">VARCHAR (0) 컬럼은 2 개의 값 (빈 문자열 또는 NULL)을 포함 할 수 있습니다. 이러한 열은 인덱스의 일부가 될 수 없습니다. &lt;a href=&quot;../connect/index&quot;&gt;CONNECT의&lt;/a&gt; 스토리지 엔진은 VARCHAR (0)를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f84465ab95f1c1f8badc3689b5a198f3b8f70f26" translate="yes" xml:space="preserve">
          <source>VARCHAR(2)</source>
          <target state="translated">VARCHAR(2)</target>
        </trans-unit>
        <trans-unit id="fa941f226ac377f7f4f3a7d2bcf748956ab2dbbf" translate="yes" xml:space="preserve">
          <source>VARCHAR(255) can be a problem in 5.6 with utf8mb4; see workarounds below.</source>
          <target state="translated">VARCHAR (255)는 utf8mb4에서 5.6에서 문제가 될 수 있습니다. 아래의 해결 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b9d7e1b6250415e69130c0b7427a73623fbbc0" translate="yes" xml:space="preserve">
          <source>VARCHAR(5)</source>
          <target state="translated">VARCHAR(5)</target>
        </trans-unit>
        <trans-unit id="39036484b8343fa5a0586cb6cc947037c68a43c6" translate="yes" xml:space="preserve">
          <source>VARCHAR(512)</source>
          <target state="translated">VARCHAR(512)</target>
        </trans-unit>
        <trans-unit id="d712296f71e4923364557e95b21118aa120b299d" translate="yes" xml:space="preserve">
          <source>VARCHAR(64)</source>
          <target state="translated">VARCHAR(64)</target>
        </trans-unit>
        <trans-unit id="3775e59fc840cfed8d3fdde7b541979775e2e485" translate="yes" xml:space="preserve">
          <source>VARCHARACTER</source>
          <target state="translated">VARCHARACTER</target>
        </trans-unit>
        <trans-unit id="a7394ac4e6488404f1bd1e632009589a2e23e1c3" translate="yes" xml:space="preserve">
          <source>VARIANCE</source>
          <target state="translated">VARIANCE</target>
        </trans-unit>
        <trans-unit id="1dd7c8f747a2bea0b710d7ee05dfb1cb68a2d3fe" translate="yes" xml:space="preserve">
          <source>VARIANCE() VAR_POP()</source>
          <target state="translated">VARIANCE () VAR_POP ()</target>
        </trans-unit>
        <trans-unit id="1f07faee9baf396654cb7b25157630efb6ea134b" translate="yes" xml:space="preserve">
          <source>VARIANCE() returns &lt;code&gt;NULL&lt;/code&gt; if there were no matching rows.</source>
          <target state="translated">일치하는 행이 없으면 VARIANCE ()는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="1b9dd83a5b62324f5e9205484ad35490d7c1accd" translate="yes" xml:space="preserve">
          <source>VARIANCE(), VAR_POP()</source>
          <target state="translated">VARIANCE (), VAR_POP ()</target>
        </trans-unit>
        <trans-unit id="e64630a4b88ff18b1894f4319142c61a4762ce24" translate="yes" xml:space="preserve">
          <source>VARYING</source>
          <target state="translated">VARYING</target>
        </trans-unit>
        <trans-unit id="209c9e19cb7b4725311bf02d8554b422a02963e6" translate="yes" xml:space="preserve">
          <source>VAR_POP</source>
          <target state="translated">VAR_POP</target>
        </trans-unit>
        <trans-unit id="5698063a61db048f0d324c12652cf042f8057000" translate="yes" xml:space="preserve">
          <source>VAR_POP() returns &lt;code&gt;NULL&lt;/code&gt; if there were no matching rows.</source>
          <target state="translated">일치하는 행이 없으면 VAR_POP ()는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d1c167a08f71c270f1a4c1f1db7054bf6355fdf4" translate="yes" xml:space="preserve">
          <source>VAR_SAMP</source>
          <target state="translated">VAR_SAMP</target>
        </trans-unit>
        <trans-unit id="dc46c873ec1e2d68f268428fd09ff0ed5ef78ace" translate="yes" xml:space="preserve">
          <source>VAR_SAMP()</source>
          <target state="translated">VAR_SAMP()</target>
        </trans-unit>
        <trans-unit id="6da9dcb59d7da043920f66a23af7dca7cf4640c5" translate="yes" xml:space="preserve">
          <source>VAR_SAMP() returns &lt;code&gt;NULL&lt;/code&gt; if there were no matching rows.</source>
          <target state="translated">일치하는 행이 없으면 VAR_SAMP ()는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="af268e6d13ae15d306c05fa1b0a6d9bcdcb52dd5" translate="yes" xml:space="preserve">
          <source>VATS</source>
          <target state="translated">VATS</target>
        </trans-unit>
        <trans-unit id="610ff81048c48bc536e95d4d96577d341fd2e350" translate="yes" xml:space="preserve">
          <source>VEC</source>
          <target state="translated">VEC</target>
        </trans-unit>
        <trans-unit id="35593aefed33d7524e349e1df36e15c45e59dcfa" translate="yes" xml:space="preserve">
          <source>VEC Table Type</source>
          <target state="translated">VEC 테이블 타입</target>
        </trans-unit>
        <trans-unit id="faaf00af56a05ecfcbb50922ae5b397930537a82" translate="yes" xml:space="preserve">
          <source>VENDEUR</source>
          <target state="translated">VENDEUR</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="3c202c26e1a222305f95200db61360c12fcd9dc1" translate="yes" xml:space="preserve">
          <source>VERSIONING</source>
          <target state="translated">VERSIONING</target>
        </trans-unit>
        <trans-unit id="5d55463aea827074f26359c7821aed0d3d9a0b4b" translate="yes" xml:space="preserve">
          <source>VIR Type</source>
          <target state="translated">VIR 유형</target>
        </trans-unit>
        <trans-unit id="f767446fec078fbe0e38aa71d73307144e4e6460" translate="yes" xml:space="preserve">
          <source>VIR tables vs. SEQUENCE tables</source>
          <target state="translated">VIR 테이블과 SEQUENCE 테이블</target>
        </trans-unit>
        <trans-unit id="813bbae7abb21ed6a3312e192392fa2b522ac7de" translate="yes" xml:space="preserve">
          <source>VIR virtual type for CONNECT</source>
          <target state="translated">CONNECT 용 VIR 가상 유형</target>
        </trans-unit>
        <trans-unit id="b11fc4ebbb1eb2f1622f8e67f85c18fe76e8d15a" translate="yes" xml:space="preserve">
          <source>VIR*</source>
          <target state="translated">VIR*</target>
        </trans-unit>
        <trans-unit id="b9fc23bc304fee2c99b8610aefd1b7d6263e9ce1" translate="yes" xml:space="preserve">
          <source>VIR, WMI and MAC special table types</source>
          <target state="translated">VIR, WMI 및 MAC 특수 테이블 유형</target>
        </trans-unit>
        <trans-unit id="95af86c74e7f7ef853b5b34a0d1159830ddc5694" translate="yes" xml:space="preserve">
          <source>VOITURIN</source>
          <target state="translated">VOITURIN</target>
        </trans-unit>
        <trans-unit id="6f518ef995be643a2a8601fda5c6cbbe8d6435f3" translate="yes" xml:space="preserve">
          <source>VT</source>
          <target state="translated">VT</target>
        </trans-unit>
        <trans-unit id="bc56f974b576f93f84de328c288398929828bec8" translate="yes" xml:space="preserve">
          <source>Vagrant</source>
          <target state="translated">Vagrant</target>
        </trans-unit>
        <trans-unit id="68f92b0dd425b559cc848cdf0655319f5dda6dc1" translate="yes" xml:space="preserve">
          <source>Valeur</source>
          <target state="translated">Valeur</target>
        </trans-unit>
        <trans-unit id="54ab4d2b0820b79cad074569faeb8edd50fa89ef" translate="yes" xml:space="preserve">
          <source>Valid values are:</source>
          <target state="translated">유효한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f7e3bc69f291e6fe97f93899c2c4117e580616d" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;PAGE_COMPRESSION_LEVEL&lt;/code&gt; are 1 (the best speed) through 9 (the best compression), .</source>
          <target state="translated">&lt;code&gt;PAGE_COMPRESSION_LEVEL&lt;/code&gt; 의 유효한 값 은 1 (최고 속도)에서 9 (최고 압축)입니다.</target>
        </trans-unit>
        <trans-unit id="50e9877ea51ed902e786f8146bee428773a36a8c" translate="yes" xml:space="preserve">
          <source>Validating Pre-Requisites are Complete</source>
          <target state="translated">전제 조건 검증 완료</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="30d18004044f3b59fa6d7a9d438add675124bd09" translate="yes" xml:space="preserve">
          <source>Value (after reading options)</source>
          <target state="translated">값 (옵션을 읽은 후)</target>
        </trans-unit>
        <trans-unit id="de0563368c733a06101534c51d43492ef0066a3e" translate="yes" xml:space="preserve">
          <source>Value = Name of Instance, which is systemName-pm1. I.E. columnstore-1-pm1</source>
          <target state="translated">값 = 인스턴스 이름 (systemName-pm1) IE columnstore-1-pm1</target>
        </trans-unit>
        <trans-unit id="c515bcd46940ea1f59b309fc3be68bb74885a662" translate="yes" xml:space="preserve">
          <source>Value Groups</source>
          <target state="translated">가치 그룹</target>
        </trans-unit>
        <trans-unit id="6ae88edf146c217b3a09bcf9bed5398068608feb" translate="yes" xml:space="preserve">
          <source>Value distribution mode</source>
          <target state="translated">가치 분배 모드</target>
        </trans-unit>
        <trans-unit id="ccb171aa5a48b0d099cd6436d9b90b4f6fc74b1c" translate="yes" xml:space="preserve">
          <source>Value in picoseconds of the event's duration or &lt;code&gt;NULL&lt;/code&gt; if the event has not ended or timing is not collected.</source>
          <target state="translated">이벤트 지속 시간의 피코 초 단위 값이거나 이벤트가 종료되지 않았거나 타이밍이 수집되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03c829399eadbe602d87c5cfea7d45697f4eae11" translate="yes" xml:space="preserve">
          <source>Value in picoseconds of the event's duration or &lt;code&gt;NULL&lt;/code&gt; if timing is not collected.</source>
          <target state="translated">이벤트 지속 시간의 피코 초 단위 값이거나 타이밍이 수집되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9ee6f75d7cff97488fa9ca1c1e925d3f0dbee8d" translate="yes" xml:space="preserve">
          <source>Value in picoseconds of the event's duration or NULL if timing is not collected.</source>
          <target state="translated">이벤트 지속 시간의 피코 초 단위 값이거나 타이밍이 수집되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="a5b6e6faa8b3f5d21880e07c41b40e682bf3d36a" translate="yes" xml:space="preserve">
          <source>Value in picoseconds when the event timing ended, or &lt;code&gt;NULL&lt;/code&gt; if the event has not ended or timing is not collected.</source>
          <target state="translated">이벤트 타이밍이 종료되면 피코 초 단위의 값이거나 , 이벤트가 종료되지 않았거나 타이밍이 수집되지 않으면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6e280e6e7499d21b8ae29ffaf0af493f17b0bfc" translate="yes" xml:space="preserve">
          <source>Value in picoseconds when the event timing ended, or &lt;code&gt;NULL&lt;/code&gt; if timing is not collected.</source>
          <target state="translated">이벤트 타이밍이 종료되면 피코 초 단위의 값, 또는 타이밍이 수집되지 않으면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c95d6079a68c237c9244fa9c0d4a10292dacf2d5" translate="yes" xml:space="preserve">
          <source>Value in picoseconds when the event timing ended, or NULL if timing is not collected.</source>
          <target state="translated">이벤트 타이밍이 종료되면 피코 초 단위의 값, 또는 타이밍이 수집되지 않으면 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="8713630c5ed63654df30b3cd6d5531fbcbaaa2e2" translate="yes" xml:space="preserve">
          <source>Value in picoseconds when the event timing started or &lt;code&gt;NULL&lt;/code&gt; if timing is not collected.</source>
          <target state="translated">이벤트 타이밍이 시작된 시간 (피코 초) 또는 타이밍이 수집되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aac97d87d6852cc5dc6665d29a4f946bf120f2d0" translate="yes" xml:space="preserve">
          <source>Value in picoseconds when the event timing started or NULL if timing is not collected.</source>
          <target state="translated">이벤트 타이밍이 시작된 시간 (피코 초) 또는 타이밍이 수집되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="140493730e51536b3501793e6421e2a92e3b776a" translate="yes" xml:space="preserve">
          <source>Value of the column</source>
          <target state="translated">열의 가치</target>
        </trans-unit>
        <trans-unit id="c85f48c851a6c3eeea39132f23073a47574c8900" translate="yes" xml:space="preserve">
          <source>Value ranges</source>
          <target state="translated">가치 범위</target>
        </trans-unit>
        <trans-unit id="42111b6c9244a7fce9a3cca5ee267b6825334c14" translate="yes" xml:space="preserve">
          <source>Value specified by &lt;code&gt;MASTER_DELAY&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; (or 0 if none).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;MASTER_DELAY&lt;/code&gt; 에 의해 지정된 값 (없는 경우 0).</target>
        </trans-unit>
        <trans-unit id="1e962903946b38e35d79512cacc0e4a67f3602e8" translate="yes" xml:space="preserve">
          <source>Value using a COLLATE clause</source>
          <target state="translated">COLLATE 절을 사용한 값</target>
        </trans-unit>
        <trans-unit id="50600a45c0e76496cc1dcf5da57b936cbb5aed7e" translate="yes" xml:space="preserve">
          <source>Values can also be specified in the form of a SQL expression or subquery. However, the subquery cannot access the same table that is named in the &lt;code&gt;INTO&lt;/code&gt; clause.</source>
          <target state="translated">값은 SQL 표현식 또는 서브 쿼리 형식으로 지정할 수도 있습니다. 그러나 부속 조회는 &lt;code&gt;INTO&lt;/code&gt; 절에 명명 된 동일한 테이블에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e8570704005d6d89297c40943e882f7a9b0c4b25" translate="yes" xml:space="preserve">
          <source>Values can refer to each other using the syntax &lt;code&gt;@groupname.optionname&lt;/code&gt;&amp;mdash; these references be expanded as needed. For example</source>
          <target state="translated">&lt;code&gt;@groupname.optionname&lt;/code&gt; 구문을 사용하여 값을 서로 참조 할 수 있습니다. 이러한 참조는 필요에 따라 확장됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f344fe48feeabab927749d456e0cf557346baecb" translate="yes" xml:space="preserve">
          <source>Values displayed by &lt;code&gt;xtstat&lt;/code&gt; are either a time in milliseconds, a value in bytes, or a counter. If these values are too large to be displayed then the value is rounded and a size indicator is added.</source>
          <target state="translated">&lt;code&gt;xtstat&lt;/code&gt; 에 의해 표시되는 값 은 밀리 초 단위의 시간, 바이트 단위의 값 또는 카운터입니다. 이 값이 너무 커서 표시 할 수 없으면 값이 반올림되고 크기 표시기가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b9d756c1f698188beb3f2ab603ab1b864c8614" translate="yes" xml:space="preserve">
          <source>Values for &lt;code&gt;PERSISTENT&lt;/code&gt; generated columns are generated whenever a &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML queries&lt;/a&gt; inserts or updates the row with the special &lt;code&gt;DEFAULT&lt;/code&gt; value. This generates the columns value, and it is stored in the table like the other &quot;real&quot; columns. This value can be read by other &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML queries&lt;/a&gt; just like the other &quot;real&quot; columns.</source>
          <target state="translated">&lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열의 값 은 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML 쿼리&lt;/a&gt; 가 특수 &lt;code&gt;DEFAULT&lt;/code&gt; 값으로 행을 삽입하거나 업데이트 할 때마다 생성됩니다 . 그러면 열 값이 생성되고 다른 &quot;실제&quot;열과 같이 테이블에 저장됩니다. 이 값은 다른 &quot;실제&quot;열과 마찬가지로 다른 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML 쿼리에서&lt;/a&gt; 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96edd68f3d9c7f1662702ac4663f5c6f87002bd6" translate="yes" xml:space="preserve">
          <source>Values for &lt;code&gt;VIRTUAL&lt;/code&gt; generated columns are not stored in the table. Instead, the value is generated dynamically whenever the column is queried. If other columns in a row are queried, but the &lt;code&gt;VIRTUAL&lt;/code&gt; generated column is not one of the queried columns, then the column's value is not generated.</source>
          <target state="translated">&lt;code&gt;VIRTUAL&lt;/code&gt; 생성 열의 값 은 테이블에 저장되지 않습니다. 대신, 열이 쿼리 될 때마다 값이 동적으로 생성됩니다. 행의 다른 열이 쿼리되지만 &lt;code&gt;VIRTUAL&lt;/code&gt; 생성 열이 쿼리 된 열 중 하나가 아닌 경우 열 값이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e35b72ab28f802984051d50f46dc745d32ee94" translate="yes" xml:space="preserve">
          <source>Values for all columns are taken from the values specified in the &lt;code&gt;REPLACE&lt;/code&gt; statement. Any missing columns are set to their default values, just as happens for &lt;code&gt;INSERT&lt;/code&gt;. You cannot refer to values from the current row and use them in the new row. If you use an assignment such as &lt;code&gt;'SET col = col + 1'&lt;/code&gt;, the reference to the column name on the right hand side is treated as &lt;code&gt;DEFAULT(col)&lt;/code&gt;, so the assignment is equivalent to &lt;code&gt;'SET col = DEFAULT(col) + 1'&lt;/code&gt;.</source>
          <target state="translated">모든 열의 값은 &lt;code&gt;REPLACE&lt;/code&gt; 문에 지정된 값에서 가져옵니다 . 누락 된 컬럼은 &lt;code&gt;INSERT&lt;/code&gt; 에서 와 같이 기본값으로 설정됩니다 . 현재 행의 값을 참조하여 새 행에서 사용할 수 없습니다. &lt;code&gt;'SET col = col + 1'&lt;/code&gt; 과 같은 대입을 사용하는 경우 오른쪽 열 이름에 대한 참조는 &lt;code&gt;DEFAULT(col)&lt;/code&gt; 로 취급 되므로 대입은 &lt;code&gt;'SET col = DEFAULT(col) + 1'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898ac9fcdbeaee6e54989bd40e2c278bad5cf1db" translate="yes" xml:space="preserve">
          <source>Values missing from 'searchable fields' would need to be NULL (or whatever), and the code would need to deal with such.</source>
          <target state="translated">'검색 가능한 필드'에서 누락 된 값은 NULL (또는 무엇이든)이어야하며 코드는이를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="729869d8c9d3967e348cc5924f3681254bb6d9a7" translate="yes" xml:space="preserve">
          <source>Values of the columns array (should be free by caller)</source>
          <target state="translated">열 배열의 값 (호출자가 무료로 제공해야 함)</target>
        </trans-unit>
        <trans-unit id="73d4f1671cae4febd1e82a8aba8ef082bd7b3b35" translate="yes" xml:space="preserve">
          <source>Values with type &lt;code&gt;DYN_COL_NULL&lt;/code&gt; do not ever occur in dynamic columns blobs.</source>
          <target state="translated">유형이 &lt;code&gt;DYN_COL_NULL&lt;/code&gt; 인 값 은 동적 열 Blob에서 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c74318e3c4fbb285ea91e240192fb5c4c02b82b9" translate="yes" xml:space="preserve">
          <source>Vandamme Anna</source>
          <target state="translated">반담 메 안나</target>
        </trans-unit>
        <trans-unit id="d0b978718f155055645bb1e4073ae25df0876b80" translate="yes" xml:space="preserve">
          <source>Varchar(256)</source>
          <target state="translated">Varchar(256)</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="d0cf779b66d8266f05f4f40e9262b1f9b4ff911e" translate="yes" xml:space="preserve">
          <source>Variable '%s' can only be set, not read</source>
          <target state="translated">변수 '% s'은 (는) 읽을 수없고 설정 만 가능합니다</target>
        </trans-unit>
        <trans-unit id="982ee42a11db0f910e7e0248466f38866316dc5e" translate="yes" xml:space="preserve">
          <source>Variable '%s' can't be set to the value of '%s'</source>
          <target state="translated">변수 '% s'을 (를) '% s'값으로 설정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="6f623c73d2c69bf86e50974e475f65daa1c95c5e" translate="yes" xml:space="preserve">
          <source>Variable '%s' doesn't have a default value</source>
          <target state="translated">변수 '% s'에 기본값이 없습니다</target>
        </trans-unit>
        <trans-unit id="ec31aa1cada5ccf53fb1d858866478faa11cdf80" translate="yes" xml:space="preserve">
          <source>Variable '%s' is a %s variable</source>
          <target state="translated">변수 '% s'은 (는) % s 변수입니다</target>
        </trans-unit>
        <trans-unit id="c87f4462b165f15414bd9cc235da3b45aaf06d54" translate="yes" xml:space="preserve">
          <source>Variable '%s' is a GLOBAL variable and should be set with SET GLOBAL</source>
          <target state="translated">변수 '% s'은 (는) GLOBAL 변수이며 SET GLOBAL로 설정해야합니다</target>
        </trans-unit>
        <trans-unit id="ebedb9df3601a18f8a39634244eb12fb925b05ff" translate="yes" xml:space="preserve">
          <source>Variable '%s' is a SESSION variable and can't be used with SET GLOBAL</source>
          <target state="translated">변수 '% s'은 (는) SESSION 변수이며 SET GLOBAL과 함께 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="58b391c3550e3efd0e1fa9deee6e31079c340b3e" translate="yes" xml:space="preserve">
          <source>Variable '%s' is not a variable component (can't be used as XXXX.variable_name)</source>
          <target state="translated">변수 '% s'은 (는) 변수 구성 요소가 아닙니다 (XXXX.variable_name으로 사용할 수 없음)</target>
        </trans-unit>
        <trans-unit id="1a398c704f2ddf429a01e2d3116b602c741995c0" translate="yes" xml:space="preserve">
          <source>Variable '%s' must be quoted with `...`, or renamed</source>
          <target state="translated">변수 '% s'은 (는)`...`로 인용하거나 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="cb3bdd831deda8a1f17edb017f13b7aea5606b9f" translate="yes" xml:space="preserve">
          <source>Variable &lt;a href=&quot;../data-types/index&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">변수 &lt;a href=&quot;../data-types/index&quot;&gt;유형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6048fa7030b4c23bbb2a103a30e6eb4c0c10911" translate="yes" xml:space="preserve">
          <source>Variable &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_ddl_exec_mode&quot;&gt;slave-ddl-exec-mode&lt;/a&gt;.</source>
          <target state="translated">변수 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_ddl_exec_mode&quot;&gt;slave-ddl-exec-mode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c685803d99b9385cacd3def29e20113b5634f75f" translate="yes" xml:space="preserve">
          <source>Variable Name</source>
          <target state="translated">변수 이름</target>
        </trans-unit>
        <trans-unit id="9b0d4552f17ba077734b5f71ac9aacfec9baacb0" translate="yes" xml:space="preserve">
          <source>Variable length CONNECT data files</source>
          <target state="translated">가변 길이 CONNECT 데이터 파일</target>
        </trans-unit>
        <trans-unit id="67d7a810c29f17a3be3bff843bc3e71ef24fa8f6" translate="yes" xml:space="preserve">
          <source>Variable memory</source>
          <target state="translated">가변 메모리</target>
        </trans-unit>
        <trans-unit id="39179cd35bae6acb4335b9b9e003594af804dab0" translate="yes" xml:space="preserve">
          <source>Variable name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66091c2f5a648f0c372811ab148bd71631287d1d" translate="yes" xml:space="preserve">
          <source>Variable name.</source>
          <target state="translated">변수 이름.</target>
        </trans-unit>
        <trans-unit id="308679b9951c659e1e046c7035b548c67b82567b" translate="yes" xml:space="preserve">
          <source>Variable or condition declaration after cursor or handler declaration</source>
          <target state="translated">커서 또는 핸들러 선언 후 변수 또는 조건 선언</target>
        </trans-unit>
        <trans-unit id="ae3a02a0dc1609fead7df34cfb3f36bb9bff6e18" translate="yes" xml:space="preserve">
          <source>Variable value.</source>
          <target state="translated">변수 값.</target>
        </trans-unit>
        <trans-unit id="c97596fd608881ce2590d406adc335bd6bd9ba82" translate="yes" xml:space="preserve">
          <source>Variable-length binary byte string.</source>
          <target state="translated">가변 길이 이진 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="e221b855196fe6db411945b3edac2cab0f333369" translate="yes" xml:space="preserve">
          <source>Variable-length string.</source>
          <target state="translated">가변 길이 문자열.</target>
        </trans-unit>
        <trans-unit id="18c07040a4d4e3f0f2b7f04b6d6c015bad82882e" translate="yes" xml:space="preserve">
          <source>Variable-length types like &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; can be used in MEMORY tables. &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; columns are not supported for MEMORY tables.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; 과 같은 가변 길이 유형 은 MEMORY 테이블에서 사용할 수 있습니다. MEMORY 테이블에는 &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 열이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d81a4f17b8b0537a039cf4ae581ee0632f3759d" translate="yes" xml:space="preserve">
          <source>Variable_name</source>
          <target state="translated">Variable_name</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="b39b255282ee1d237af15c666b440dc9ed01d837" translate="yes" xml:space="preserve">
          <source>Variables (&lt;code&gt;&lt;code&gt;--&lt;/code&gt;variable-name=value&lt;/code&gt;) and boolean options &lt;code&gt;{FALSE&lt;code&gt;|&lt;/code&gt;TRUE}&lt;/code&gt;</source>
          <target state="translated">변수 ( &lt;code&gt;&lt;code&gt;--&lt;/code&gt;variable-name=value&lt;/code&gt; )과 부울 옵션 &lt;code&gt;{FALSE&lt;code&gt;|&lt;/code&gt;TRUE}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ebdd64e264e0bb8329c69d8419cd60e7534af9a" translate="yes" xml:space="preserve">
          <source>Variables Related to the Slow Query Log</source>
          <target state="translated">느린 쿼리 로그 관련 변수</target>
        </trans-unit>
        <trans-unit id="c702ae6ce7716297aafbad126fac77338d644e04" translate="yes" xml:space="preserve">
          <source>Variables and Modes</source>
          <target state="translated">변수와 모드</target>
        </trans-unit>
        <trans-unit id="c851d106b84aaf23b1d201ca0ca10eb0be872747" translate="yes" xml:space="preserve">
          <source>Variables and boolean options</source>
          <target state="translated">변수 및 부울 옵션</target>
        </trans-unit>
        <trans-unit id="39b990bf9135e59e0012892cefe5b08a65395f8c" translate="yes" xml:space="preserve">
          <source>Variables can be set with &lt;code&gt;--variable-name=value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--variable-name=value&lt;/code&gt; 로 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd46fb3a481b95b25ef7befdb34bd5674759e52f" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;ROW TYPE OF&lt;/code&gt; will have the same features as implicit &lt;a href=&quot;../row/index&quot;&gt;ROW&lt;/a&gt; variables. It is not possible to use &lt;code&gt;ROW TYPE OF&lt;/code&gt; variables in a &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; clause.</source>
          <target state="translated">&lt;code&gt;ROW TYPE OF&lt;/code&gt; 로 선언 된 변수는 암시 적 &lt;a href=&quot;../row/index&quot;&gt;ROW&lt;/a&gt; 변수 와 동일한 기능을 갖습니다 . &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; 절 에서 &lt;code&gt;ROW TYPE OF&lt;/code&gt; 변수 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22c22adcb7ed3c84cdead8bf42577cfa37931904" translate="yes" xml:space="preserve">
          <source>Variables out of ranges are replaced with the maximum/minimum value.</source>
          <target state="translated">범위를 벗어난 변수는 최대 / 최소 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2ebe6cca44b9d0dd710f73e9095862d30f3b64" translate="yes" xml:space="preserve">
          <source>Variables that may need to be different</source>
          <target state="translated">다를 수있는 변수</target>
        </trans-unit>
        <trans-unit id="3f6c60c96e82bf253c6f8fc4fafb50b0f0563637" translate="yes" xml:space="preserve">
          <source>Variables that specify a number of bytes may include a unit indication after the value. For example: 100KB, 64MB, etc. There should be no space between the number and the unit. Units are case insensitive (KB = Kb = kb). If no unit is specified then bytes is assumed. The recognized units are:</source>
          <target state="translated">바이트 수를 지정하는 변수에는 값 뒤에 단위 표시가 포함될 수 있습니다. 예 : 100KB, 64MB 등. 숫자와 단위 사이에 공백이 없어야합니다. 단위는 대소 문자를 구분하지 않습니다 (KB = Kb = kb). 단위를 지정하지 않으면 바이트가 가정됩니다. 인식되는 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec7d6bea04dc4298be2f15d1d900697cd01580c6" translate="yes" xml:space="preserve">
          <source>Variables that take a numeric size can either be specified in full, or with a suffix for easier readability. Valid suffixes are:</source>
          <target state="translated">숫자 크기를 갖는 변수는 전체를 지정하거나 쉽게 읽을 수 있도록 접미사로 지정할 수 있습니다. 유효한 접미사 :</target>
        </trans-unit>
        <trans-unit id="f444916d1deec7e02d0f87ef08a2671775c35935" translate="yes" xml:space="preserve">
          <source>Variables which exist within a session.</source>
          <target state="translated">세션 내에 존재하는 변수.</target>
        </trans-unit>
        <trans-unit id="4f783783f7e4cef85ac316df90ece34a51de3ba9" translate="yes" xml:space="preserve">
          <source>Variables which use this type of value are: &lt;code&gt;pbxt_index_cache_size&lt;/code&gt;, &lt;code&gt;pbxt_record_cache_size&lt;/code&gt;, &lt;code&gt;pbxt_log_cache_size&lt;/code&gt;, &lt;code&gt;pbxt_log_file_threshold&lt;/code&gt;, &lt;code&gt;pbxt_checkpoint_frequency&lt;/code&gt;, &lt;code&gt;pbxt_data_log_threshold&lt;/code&gt;, &lt;code&gt;pbxt_log_buffer_size&lt;/code&gt;, &lt;code&gt;pbxt_data_file_grow_size&lt;/code&gt;, and &lt;code&gt;pbxt_row_file_grow_size&lt;/code&gt;.</source>
          <target state="translated">값이 유형을 사용하는 변수는 다음과 같습니다 &lt;code&gt;pbxt_index_cache_size&lt;/code&gt; , &lt;code&gt;pbxt_record_cache_size&lt;/code&gt; , &lt;code&gt;pbxt_log_cache_size&lt;/code&gt; , &lt;code&gt;pbxt_log_file_threshold&lt;/code&gt; , &lt;code&gt;pbxt_checkpoint_frequency&lt;/code&gt; , &lt;code&gt;pbxt_data_log_threshold&lt;/code&gt; , &lt;code&gt;pbxt_log_buffer_size&lt;/code&gt; , &lt;code&gt;pbxt_data_file_grow_size&lt;/code&gt; 및 &lt;code&gt;pbxt_row_file_grow_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="034e2e0179d3ddae53d1b7b0d76a77485462e479" translate="yes" xml:space="preserve">
          <source>Variables whose name starts with &lt;em&gt;aria&lt;/em&gt; and with a valued of greater than 8192:</source>
          <target state="translated">이름이 &lt;em&gt;aria로&lt;/em&gt; 시작 하고 값이 8192보다 큰 변수 :</target>
        </trans-unit>
        <trans-unit id="9e30503b242701df6871e96a7e13f228374f092d" translate="yes" xml:space="preserve">
          <source>Variance is calculated by</source>
          <target state="translated">분산은 다음에 의해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="112bf833d768d00ff423204f08a466fb16d5673f" translate="yes" xml:space="preserve">
          <source>Variant of EXPLAIN that produces output in JSON form</source>
          <target state="translated">JSON 형식으로 출력을 생성하는 변형의 변형</target>
        </trans-unit>
        <trans-unit id="1bc3d368f8ad61e91648458829240a7efefcd2c1" translate="yes" xml:space="preserve">
          <source>Variants</source>
          <target state="translated">Variants</target>
        </trans-unit>
        <trans-unit id="c083ea9131a2116924f006b534b88b9a75617de8" translate="yes" xml:space="preserve">
          <source>Variants on &quot;10&quot; - there is nothing sacred about &quot;10&quot; in this discussion.</source>
          <target state="translated">&quot;10&quot;의 변형-이 토론에서 &quot;10&quot;에 대한 신성한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f011ae3d769713aef6ec90b726bba19be3a49e3c" translate="yes" xml:space="preserve">
          <source>Variants on &quot;latest&quot;</source>
          <target state="translated">&quot;최신&quot;의 변형</target>
        </trans-unit>
        <trans-unit id="eb1bd73f46edd81c8c88656c495cb74d0dde4d4e" translate="yes" xml:space="preserve">
          <source>Variants on &quot;news article&quot;</source>
          <target state="translated">&quot;뉴스 기사&quot;의 변형</target>
        </trans-unit>
        <trans-unit id="2ec69621f0d439afa5af1dc5d23048528b3e3ef9" translate="yes" xml:space="preserve">
          <source>Variants on &quot;topic&quot;:</source>
          <target state="translated">&quot;주제&quot;의 변형 :</target>
        </trans-unit>
        <trans-unit id="940a179c898f0fb60bc19c94688970dea1985749" translate="yes" xml:space="preserve">
          <source>Varies</source>
          <target state="translated">Varies</target>
        </trans-unit>
        <trans-unit id="23a142b921fc06a0a97b581539fae521a59e88db" translate="yes" xml:space="preserve">
          <source>Various benchmark results for MariaDB.</source>
          <target state="translated">MariaDB에 대한 다양한 벤치 마크 결과.</target>
        </trans-unit>
        <trans-unit id="62c38e1f00458b3384354517515dc286ee2ecb0e" translate="yes" xml:space="preserve">
          <source>Various bugs fixed (need to look at opened bugs for Federated)</source>
          <target state="translated">다양한 버그 수정 (페더레이션에 대해 열린 버그 확인 필요)</target>
        </trans-unit>
        <trans-unit id="cf589d93f36e0e9a30424996f186cf5f5421d345" translate="yes" xml:space="preserve">
          <source>Various bugs that needed to be fixed from MySQL 5.0</source>
          <target state="translated">MySQL 5.0에서 수정해야하는 다양한 버그</target>
        </trans-unit>
        <trans-unit id="d54767e3463af6efb37e0410b98db942c5264c01" translate="yes" xml:space="preserve">
          <source>Various events will result in different audit records. Some events will not return a value for some fields (e.g., when the active database is not set when connecting to the server).</source>
          <target state="translated">다양한 이벤트는 다른 감사 레코드를 초래합니다. 일부 이벤트는 일부 필드의 값을 반환하지 않습니다 (예 : 서버에 연결할 때 활성 데이터베이스가 설정되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="44447a396be07c3f680e9051bf18d846797ef771" translate="yes" xml:space="preserve">
          <source>Various optimization strategies used by &lt;a href=&quot;../the-query-optimizer/index&quot;&gt;the query optimizer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../the-query-optimizer/index&quot;&gt;쿼리 옵티마이&lt;/a&gt; 저가 사용하는 다양한 최적화 전략 .</target>
        </trans-unit>
        <trans-unit id="474771ecf9045aa1f735b94ddc7865789cb6808e" translate="yes" xml:space="preserve">
          <source>Various optimization strategies used by the query optimizer.</source>
          <target state="translated">쿼리 최적화 프로그램에서 사용하는 다양한 최적화 전략.</target>
        </trans-unit>
        <trans-unit id="7d31de8ab7443fea05139205680bdd7640963a8c" translate="yes" xml:space="preserve">
          <source>Various options for automatic mapping</source>
          <target state="translated">자동 매핑을위한 다양한 옵션</target>
        </trans-unit>
        <trans-unit id="926b8de9648dbc73590fbc4e7432472922b56d56" translate="yes" xml:space="preserve">
          <source>Various storage engines available for MariaDB.</source>
          <target state="translated">MariaDB에 사용 가능한 다양한 스토리지 엔진.</target>
        </trans-unit>
        <trans-unit id="d96159ff30af16ea68b338c53fab54027ad859e4" translate="yes" xml:space="preserve">
          <source>Vendor</source>
          <target state="translated">Vendor</target>
        </trans-unit>
        <trans-unit id="9d4ac43d5e24e3d01e448ce01a277ba5971e60f6" translate="yes" xml:space="preserve">
          <source>Venezuela</source>
          <target state="translated">Venezuela</target>
        </trans-unit>
        <trans-unit id="6b3e7ae8261cc005b67c4fb2f499a2d07b26ae41" translate="yes" xml:space="preserve">
          <source>Verbose mode.</source>
          <target state="translated">상세 모드.</target>
        </trans-unit>
        <trans-unit id="374ea5b11b278bcc8877c93fa5e6d56216f3adfb" translate="yes" xml:space="preserve">
          <source>Verbose mode. Print more information about what the program does</source>
          <target state="translated">상세 모드. 프로그램의 기능에 대한 자세한 정보를 인쇄하십시오</target>
        </trans-unit>
        <trans-unit id="7acefa4bfd1ce0775923b4389733b797ca642f32" translate="yes" xml:space="preserve">
          <source>Verbose mode. Print more information about what the program does.</source>
          <target state="translated">상세 모드. 프로그램의 기능에 대한 자세한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="143831d5c858e15dafe7e9b44206f3aa7984c605" translate="yes" xml:space="preserve">
          <source>Verbose mode. Print more information about what the program is doing during various stages.</source>
          <target state="translated">상세 모드. 다양한 단계에서 프로그램이 수행하는 작업에 대한 자세한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="394a09dbf750e3e2bfa6d443b45267032300fc4c" translate="yes" xml:space="preserve">
          <source>Verbose mode. Print more output about what the program does. This option can be given multiple times (&lt;em&gt;-vv&lt;/em&gt;, &lt;em&gt;-vvv&lt;/em&gt;) to produce more and more output.</source>
          <target state="translated">상세 모드. 프로그램의 기능에 대한 추가 출력을 인쇄하십시오. 이 옵션은 더 많은 출력을 생성하기 위해 여러 번 ( &lt;em&gt;-vv&lt;/em&gt; , &lt;em&gt;-vvv&lt;/em&gt; ) 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="152a70f599026b2564e889b681a511baa86f6b21" translate="yes" xml:space="preserve">
          <source>Verbose mode; print a progress indicator every five seconds.</source>
          <target state="translated">상세 모드; 5 초마다 진행 표시기를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6cb02d636fb57a4e3d811ce65e83ce7ce2de2997" translate="yes" xml:space="preserve">
          <source>Verbosity Level 0</source>
          <target state="translated">상세 레벨 0</target>
        </trans-unit>
        <trans-unit id="0cce560ce0f6f80f252ce728030a2672002d0047" translate="yes" xml:space="preserve">
          <source>Verbosity Level 1</source>
          <target state="translated">상세 레벨 1</target>
        </trans-unit>
        <trans-unit id="98edf77b7c00b10e579a2b0a8cd39de1b196afed" translate="yes" xml:space="preserve">
          <source>Verbosity Level 2</source>
          <target state="translated">상세 레벨 2</target>
        </trans-unit>
        <trans-unit id="63bab50d2f6e8c4702ef7a1f513ba9d8f91db57d" translate="yes" xml:space="preserve">
          <source>Verbosity Level 3</source>
          <target state="translated">상세 레벨 3</target>
        </trans-unit>
        <trans-unit id="e0f87b9ebd14b8c6019229da72dbd38b750bb46e" translate="yes" xml:space="preserve">
          <source>Verbosity Level 4</source>
          <target state="translated">상세 레벨 4</target>
        </trans-unit>
        <trans-unit id="94c1164df469e4672debaa09acff8b026a892bde" translate="yes" xml:space="preserve">
          <source>Verbosity Level 9</source>
          <target state="translated">상세 레벨 9</target>
        </trans-unit>
        <trans-unit id="c7277d3a739e197795e936737de34a740091d737" translate="yes" xml:space="preserve">
          <source>Verify &lt;a href=&quot;../binlog-event-checksums/index&quot;&gt;binlog event checksums&lt;/a&gt; when reading a binlog file.</source>
          <target state="translated">binlog 파일을 읽을 때 &lt;a href=&quot;../binlog-event-checksums/index&quot;&gt;binlog 이벤트 체크섬을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a201d3a9150af972fa08bb9e7956043cedfaa5c" translate="yes" xml:space="preserve">
          <source>Verify data streaming</source>
          <target state="translated">데이터 스트리밍 확인</target>
        </trans-unit>
        <trans-unit id="1d736a0b7db21b42344b48d22ca9a41dfed4f928" translate="yes" xml:space="preserve">
          <source>Verify that bison.exe, bzr.exe or git.exe, cmake.exe and perl.exe can be found in the PATH environment variable with &quot;&lt;code&gt;where bison&lt;/code&gt;&quot;, &quot;&lt;code&gt;where git&lt;/code&gt;&quot;, &quot;&lt;code&gt;where perl&lt;/code&gt;&quot; etc. from the command line prompt.</source>
          <target state="translated">명령 줄에서 bison.exe, bzr.exe 또는 git.exe, cmake.exe 및 perl.exe가 PATH 환경 변수에서 &quot; &lt;code&gt;where bison&lt;/code&gt; &quot;, &quot; &lt;code&gt;where git&lt;/code&gt; &quot;, &quot; &lt;code&gt;where perl&lt;/code&gt; &quot;등 으로 찾을 수 있는지 확인하십시오 . 신속한.</target>
        </trans-unit>
        <trans-unit id="71d5708829dfca0313126de371454adae4cc9c94" translate="yes" xml:space="preserve">
          <source>Verify that mysqld was built with Cassandra SE:</source>
          <target state="translated">mysqld가 Cassandra SE로 빌드되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="721489aef0e8213af43cb6fb0ef727b7400ecc59" translate="yes" xml:space="preserve">
          <source>Verify that the MariaDB Server process is stopped on the joiner node. This will depend on your &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;service manager&lt;/a&gt;.</source>
          <target state="translated">결합 자 노드에서 MariaDB 서버 프로세스가 중지되었는지 확인하십시오. &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;서비스 관리자&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6a5ffc67fb3d2d2a2606718f5a13954b27506adb" translate="yes" xml:space="preserve">
          <source>Verify the /etc/default/columnstore directory does not exist.</source>
          <target state="translated">/ etc / default / columnstore 디렉토리가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d78b73ffe8775145ee2fb2e67dbbb65ad5d06fde" translate="yes" xml:space="preserve">
          <source>Verify the /etc/fstab entries are correct for the new installation.</source>
          <target state="translated">/ etc / fstab 항목이 새 설치에 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="94ff51bc34e9394e9032170efc4d3d4c6616290e" translate="yes" xml:space="preserve">
          <source>Verify the /tmp/StopColumnstore file does not exist.</source>
          <target state="translated">/ tmp / StopColumnstore 파일이 존재하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a4fc0bdf5af807ddd4bd33cbecc9163850e93789" translate="yes" xml:space="preserve">
          <source>Verify the /var/lock/subsys/mysql-Columnstore file does not exist.</source>
          <target state="translated">/ var / lock / subsys / mysql-Columnstore 파일이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bac4d002e0fa7dd20c148309550263562b5c24d2" translate="yes" xml:space="preserve">
          <source>Verify the MariaDB Columnstore installation directory does not exist:</source>
          <target state="translated">MariaDB Columnstore 설치 디렉토리가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e906d05f6d015ee6341d3c8c631d7701c5e399e7" translate="yes" xml:space="preserve">
          <source>Verify the argument types, or to force arguments to be of a particular type after the function is called.</source>
          <target state="translated">함수가 호출 된 후 인수 유형을 확인하거나 인수가 특정 유형이되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="52db13575527c6f362ec4d96ee7e41d04697de2b" translate="yes" xml:space="preserve">
          <source>Verifying Whether SELinix Is Enabled</source>
          <target state="translated">SELinix의 활성화 여부 확인</target>
        </trans-unit>
        <trans-unit id="a5c3bcc9d76ae2117803a1c1efb4d0baffd677e0" translate="yes" xml:space="preserve">
          <source>Verifying that Mapping is Occurring</source>
          <target state="translated">매핑이 발생하는지 확인</target>
        </trans-unit>
        <trans-unit id="6a824fa919052a67c6ae15bb84da70209032021b" translate="yes" xml:space="preserve">
          <source>Verifying that a Connection is Using TLS</source>
          <target state="translated">연결이 TLS를 사용하고 있는지 확인</target>
        </trans-unit>
        <trans-unit id="254879acda81403a2f65e923ed8f1513486cd671" translate="yes" xml:space="preserve">
          <source>Verifying the Installation</source>
          <target state="translated">설치 확인</target>
        </trans-unit>
        <trans-unit id="7ea26a708ae91ce9d5341c8c9f88732eadc9bf4f" translate="yes" xml:space="preserve">
          <source>Verifying the Plugin's Status</source>
          <target state="translated">플러그인 상태 확인</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="24ddefbe7a5248997e74c9dc69e344a76cd10a66" translate="yes" xml:space="preserve">
          <source>Version 1.2.4 had a bug which caused bad metadata to be stored with dictionary columns. After an upgrade from 1.2.4 tables with dictionary columns (CHAR &amp;gt; 8 bytes, VARCHAR &amp;gt; 7, TEXT &amp;amp; BLOB) tables should be recreated and data cloned. This could be done using CREATE TABLE ... LIKE and using INSERT...SELECT.</source>
          <target state="translated">버전 1.2.4에는 잘못된 메타 데이터가 사전 열과 함께 저장되는 버그가있었습니다. 사전 열 (CHAR&amp;gt; 8 바이트, VARCHAR&amp;gt; 7, TEXT &amp;amp; BLOB)이있는 1.2.4 테이블에서 업그레이드 한 후 테이블을 다시 작성하고 데이터를 복제해야합니다. CREATE TABLE ... LIKE를 사용하고 INSERT ... SELECT를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0ee24cd49fbad97aa861d24b266179dda2d0ce" translate="yes" xml:space="preserve">
          <source>Version Buffer</source>
          <target state="translated">버전 버퍼</target>
        </trans-unit>
        <trans-unit id="a3a5316513dcdf07d423d72a6e21b86266c40bb8" translate="yes" xml:space="preserve">
          <source>Version Mismatch Between MariaDB and Ubuntu/Debian Repositories</source>
          <target state="translated">MariaDB와 Ubuntu / Debian 리포지토리의 버전 불일치</target>
        </trans-unit>
        <trans-unit id="442be516bf7eb7aa2b4e44ceed5642199eabb21b" translate="yes" xml:space="preserve">
          <source>Version buffer file management</source>
          <target state="translated">버전 버퍼 파일 관리</target>
        </trans-unit>
        <trans-unit id="33bbb1a2a536cec1f2c7a8f34ddf5045e885c932" translate="yes" xml:space="preserve">
          <source>Version control integration.</source>
          <target state="translated">버전 관리 통합.</target>
        </trans-unit>
        <trans-unit id="53f2611ab6ee25554a3616c31e8abd0f87b0a39f" translate="yes" xml:space="preserve">
          <source>Version from the plugin's API interface.</source>
          <target state="translated">플러그인 API 인터페이스의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="43916dcfed1b6f52eaf5b84910fe85fa837f754e" translate="yes" xml:space="preserve">
          <source>Version from the plugin's general type descriptor.</source>
          <target state="translated">플러그인의 일반 유형 설명 자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="478bbe75f9bc015da4232cbaff50411cb11607fd" translate="yes" xml:space="preserve">
          <source>Version from the plugin's type-specific descriptor.</source>
          <target state="translated">플러그인의 유형별 설명 자의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="e1eb76fdf3dd0aafc2d88eca48b2018272fcab4c" translate="yes" xml:space="preserve">
          <source>Version number from the table's .frm file</source>
          <target state="translated">테이블의 .frm 파일의 버전 번호</target>
        </trans-unit>
        <trans-unit id="73d526e95636100c7aa3193aff46ebb222dbbccd" translate="yes" xml:space="preserve">
          <source>Version number from the table's .frm file.</source>
          <target state="translated">테이블의 .frm 파일의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a3126b111f497f1ea0352dd35ce9ac597f6ab08d" translate="yes" xml:space="preserve">
          <source>Version of the TokuDB plugin included on MariaDB</source>
          <target state="translated">MariaDB에 포함 된 TokuDB 플러그인 버전</target>
        </trans-unit>
        <trans-unit id="239098522010bf811d2746dce75993d102f7e4bf" translate="yes" xml:space="preserve">
          <source>Versioning clauses can not be applied to &lt;a href=&quot;../generated-columns/index&quot;&gt;generated (virtual and persistent) columns&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generated-columns/index&quot;&gt;생성 된 (가상 및 영구) 열에&lt;/a&gt; 는 버전 관리 절을 적용 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a239107ef28f6efe13d8ea83e502da9aa8c43fbb" translate="yes" xml:space="preserve">
          <source>Versions</source>
          <target state="translated">Versions</target>
        </trans-unit>
        <trans-unit id="5b93eac0be8d61f57496ebd7ce20fd73967a49fc" translate="yes" xml:space="preserve">
          <source>Versions in MariaDB</source>
          <target state="translated">MariaDB 버전</target>
        </trans-unit>
        <trans-unit id="116116868e03682616e36b4e5668afdd5debe94d" translate="yes" xml:space="preserve">
          <source>Versions of MySQL and MariaDB which do not have support for this optimization will execute subqueries even when running &lt;code&gt;EXPLAIN&lt;/code&gt;. This can result in a well-known problem (see e.g. &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=44802&quot;&gt;MySQL Bug #44802&lt;/a&gt;) of &lt;code&gt;EXPLAIN&lt;/code&gt; statements taking a very long time. Starting from &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;+ and MySQL 5.6+ &lt;code&gt;EXPLAIN&lt;/code&gt; commands execute instantly, regardless of the &lt;code&gt;derived_merge&lt;/code&gt; setting.</source>
          <target state="translated">이 최적화를 지원하지 않는 MySQL 및 MariaDB 버전은 &lt;code&gt;EXPLAIN&lt;/code&gt; 을 실행할 때도 하위 쿼리를 실행 합니다. 이로 인해 &lt;code&gt;EXPLAIN&lt;/code&gt; 문의 잘 알려진 문제 (예 : &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=44802&quot;&gt;MySQL 버그 # 44802 참조&lt;/a&gt; )가 오래 걸릴 수 있습니다. &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; + 및 MySQL 5.6+ &lt;code&gt;EXPLAIN&lt;/code&gt; 명령 부터 시작 하여 &lt;code&gt;derived_merge&lt;/code&gt; 설정에 관계없이 즉시 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="a47299c9e3da6e3fcbdcb1ae884f7e9b0a9bf9b5" translate="yes" xml:space="preserve">
          <source>Versions of SphinxSE in MariaDB</source>
          <target state="translated">MariaDB의 SphinxSE 버전</target>
        </trans-unit>
        <trans-unit id="4f822167d5d613f0a28936130010c0bbc68c34c1" translate="yes" xml:space="preserve">
          <source>Versions of Spider in MariaDB</source>
          <target state="translated">MariaDB의 스파이더 버전</target>
        </trans-unit>
        <trans-unit id="b66ba7c9779c533a8f78aedb24fcdf7bbfd022c5" translate="yes" xml:space="preserve">
          <source>Versions of the TokuDB plugin included in MariaDB</source>
          <target state="translated">MariaDB에 포함 된 TokuDB 플러그인 버전</target>
        </trans-unit>
        <trans-unit id="f129bbc1b27f9179aa1c790a9ce4199c1c0deecb" translate="yes" xml:space="preserve">
          <source>Versions prior to 1.1.3 need to manually load the system library:</source>
          <target state="translated">1.1.3 이전 버전에서는 시스템 라이브러리를 수동으로로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="f146a7867f7e978f9b0f0ce939df287cd868a078" translate="yes" xml:space="preserve">
          <source>Vertical partitioning storage engine VP is not implemented in MariaDB</source>
          <target state="translated">수직 파티셔닝 스토리지 엔진 VP는 MariaDB에서 구현되지 않습니다</target>
        </trans-unit>
        <trans-unit id="b246267cc03b17d613c8c41e48fa9211bc6e52ce" translate="yes" xml:space="preserve">
          <source>Very big tables and indexes can be slow even with optimized queries. But if the target table is partitioned, queries that read a small number of partitions can be much faster.</source>
          <target state="translated">최적화 된 쿼리를 사용하더라도 매우 큰 테이블과 인덱스가 느려질 수 있습니다. 그러나 목표 테이블이 파티션 된 경우 적은 수의 파티션을 읽는 쿼리가 훨씬 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39ad8b21fc2afa141bd7ca1f7410e4430aa64ae" translate="yes" xml:space="preserve">
          <source>Very efficient -- it does all the work in the index:</source>
          <target state="translated">매우 효율적-인덱스의 모든 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8de42ca1a11ed1a0744ff64d036fb9d314098a69" translate="yes" xml:space="preserve">
          <source>Vidal SA (Groupe UBM)</source>
          <target state="translated">Vidal SA (그룹 UBM)</target>
        </trans-unit>
        <trans-unit id="53cd19bd85b05f2ff6addcc980a9f32c53ce3398" translate="yes" xml:space="preserve">
          <source>Viet Nam</source>
          <target state="translated">베트남</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="4d6c00ff9e8bcaf060b4f41b1f7cd0130fb79125" translate="yes" xml:space="preserve">
          <source>View '%-.192s'.'%-.192s' ORDER BY clause ignored because there is other ORDER BY clause already.</source>
          <target state="translated">다른 ORDER BY 절이 이미 있으므로 '%-. 192s'. '%-. 192s'ORDER BY 절을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="9b09e892d22df489f76fefc2c9533d6d6e5c57c8" translate="yes" xml:space="preserve">
          <source>View '%s' doesn't exist for '%s'</source>
          <target state="translated">'% s'에 대한 '% s'보기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc8e84510474e79cd7ec54da449731f150fab0a1" translate="yes" xml:space="preserve">
          <source>View '%s'.'%s' has no definer information (old table format). Current user is used as definer. Please recreate the view!</source>
          <target state="translated">뷰 '% s'. '% s'에 정의 자 정보가 없습니다 (이전 테이블 형식). 현재 사용자가 정의 자로 사용됩니다. 보기를 다시 만드십시오!</target>
        </trans-unit>
        <trans-unit id="d79eadfba08ffdd0d9cef4677c6143deee2a10b3" translate="yes" xml:space="preserve">
          <source>View '%s.%s' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them</source>
          <target state="translated">뷰 '% s. % s'은 (는) 잘못된 테이블 또는 열 또는 함수 또는 뷰의 정의 자 / 호출자가이를 사용할 수있는 권한이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e6a6fc4f87e3403346040402551f781853c09c6" translate="yes" xml:space="preserve">
          <source>View Algorithms</source>
          <target state="translated">알고리즘보기</target>
        </trans-unit>
        <trans-unit id="62949ffe01eb5fc3836adb20409cfb933cf80840" translate="yes" xml:space="preserve">
          <source>View GRANT statements.</source>
          <target state="translated">GRANT 문을보십시오.</target>
        </trans-unit>
        <trans-unit id="eb176de7eb1d4cb3006b18a900eebed50158634a" translate="yes" xml:space="preserve">
          <source>View Tables in Order of Size</source>
          <target state="translated">크기 순서대로 테이블보기</target>
        </trans-unit>
        <trans-unit id="bf7aaacc94d0a610ad9f29ec74cbfcde400d7e35" translate="yes" xml:space="preserve">
          <source>View `%s`.`%s` has no creation context</source>
          <target state="translated">`% s`를 봅니다 .` % s`에는 생성 컨텍스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c02e83fabcdf1732a93a4c98bef1c4506453f20" translate="yes" xml:space="preserve">
          <source>View being updated does not have complete key of underlying table in it</source>
          <target state="translated">업데이트되는 뷰에 기본 테이블의 완전한 키가 없습니다.</target>
        </trans-unit>
        <trans-unit id="26552dfa6767f0dda20a5d6a568df4edfc24191c" translate="yes" xml:space="preserve">
          <source>View locales information</source>
          <target state="translated">로케일 정보보기</target>
        </trans-unit>
        <trans-unit id="67e0c333ed605f459f44340c47ed107b2e58ccda" translate="yes" xml:space="preserve">
          <source>View merge algorithm can't be used here for now (assumed undefined algorithm)</source>
          <target state="translated">현재 뷰 병합 알고리즘을 사용할 수 없습니다 (정의되지 않은 알고리즘으로 가정)</target>
        </trans-unit>
        <trans-unit id="63c58d6c6fa94d38da2717a099b4a087a18948dc" translate="yes" xml:space="preserve">
          <source>View object dependencies in the Database Explorer tree.</source>
          <target state="translated">데이터베이스 탐색기 트리에서 오브젝트 종속성을보십시오.</target>
        </trans-unit>
        <trans-unit id="1edc5a2deccf561dd63acd46c6b007a75db48d5b" translate="yes" xml:space="preserve">
          <source>View privileges are checked like this:</source>
          <target state="translated">보기 권한은 다음과 같이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="661378032d613dc030c6984bcba6e8ad7b27f1ef" translate="yes" xml:space="preserve">
          <source>View table name.</source>
          <target state="translated">테이블 이름을 봅니다.</target>
        </trans-unit>
        <trans-unit id="2bedf997f0f52ebc901116ed8b1c1e2f130ef237" translate="yes" xml:space="preserve">
          <source>View text checksum failed</source>
          <target state="translated">텍스트 체크섬보기 실패</target>
        </trans-unit>
        <trans-unit id="57056764062c7b16c4d3ea8f5bb08a03a424148b" translate="yes" xml:space="preserve">
          <source>View the Information Schema &lt;a href=&quot;../information-schema-global_variables-and-session_variables-tables/index&quot;&gt;GLOBAL_VARIABLES&lt;/a&gt;, &lt;a href=&quot;../information-schema-global_variables-and-session_variables-tables/index&quot;&gt;SESSION_VARIABLES&lt;/a&gt;, and &lt;a href=&quot;../information-schema-system_variables-table/index&quot;&gt;SYSTEM_VARIABLES&lt;/a&gt; tables.</source>
          <target state="translated">정보 스키마 &lt;a href=&quot;../information-schema-global_variables-and-session_variables-tables/index&quot;&gt;GLOBAL_VARIABLES&lt;/a&gt; , &lt;a href=&quot;../information-schema-global_variables-and-session_variables-tables/index&quot;&gt;SESSION_VARIABLES&lt;/a&gt; 및 &lt;a href=&quot;../information-schema-system_variables-table/index&quot;&gt;SYSTEM_VARIABLES&lt;/a&gt; 테이블을보십시오.</target>
        </trans-unit>
        <trans-unit id="4f7ad0ae040aa02a6ab43d0790627ec096d2b68e" translate="yes" xml:space="preserve">
          <source>View the contents of the query cache</source>
          <target state="translated">쿼리 캐시의 내용을 봅니다.</target>
        </trans-unit>
        <trans-unit id="83253c8177510652b31ff0edf7e27f9a8077a7c7" translate="yes" xml:space="preserve">
          <source>View's SELECT and view's field list have different column counts</source>
          <target state="translated">뷰의 SELECT와 뷰의 필드 목록은 다른 열 개수를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="de7b166ad7587fcad4e02af14dc9c2235aea193c" translate="yes" xml:space="preserve">
          <source>View's SELECT contains a '%s' clause</source>
          <target state="translated">뷰의 SELECT에 '% s'절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be3fc45d6ea972ba81709faefe47857ff9b5ac33" translate="yes" xml:space="preserve">
          <source>View's SELECT contains a subquery in the FROM clause</source>
          <target state="translated">뷰의 SELECT는 FROM 절에 하위 쿼리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1c70eac31e594352b71721a5bb0c5440b2980c36" translate="yes" xml:space="preserve">
          <source>View's SELECT contains a variable or parameter</source>
          <target state="translated">뷰의 SELECT에 변수 또는 매개 변수가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="d866c73e93acddcc6e54cec1ff8ae4d784b9dffb" translate="yes" xml:space="preserve">
          <source>View's SELECT refers to a temporary table '%s'</source>
          <target state="translated">뷰의 SELECT는 임시 테이블 '% s'을 (를) 참조합니다</target>
        </trans-unit>
        <trans-unit id="08c2fc6de3c35e0e50309d6a71f7179447225b81" translate="yes" xml:space="preserve">
          <source>Viewing Character Sets and Collations</source>
          <target state="translated">문자 집합 및 데이터 정렬보기</target>
        </trans-unit>
        <trans-unit id="3ff198e52eb1813a72098518465754c9291e1c42" translate="yes" xml:space="preserve">
          <source>Viewing CrackLib Errors</source>
          <target state="translated">CrackLib 오류보기</target>
        </trans-unit>
        <trans-unit id="7cca970c308d074fa6de33fabcc2769e9d4240e2" translate="yes" xml:space="preserve">
          <source>Viewing Galera Cluster Status variables</source>
          <target state="translated">Galera Cluster 상태 변수보기</target>
        </trans-unit>
        <trans-unit id="7e4ac9ea8f39e934855f5a24a3aebea141d0b07d" translate="yes" xml:space="preserve">
          <source>Viewing Indexes</source>
          <target state="translated">인덱스보기</target>
        </trans-unit>
        <trans-unit id="12b914dd06ec50cccb7a3d351179a982fdb82135" translate="yes" xml:space="preserve">
          <source>Viewing all Metadata Locks</source>
          <target state="translated">모든 메타 데이터 잠금보기</target>
        </trans-unit>
        <trans-unit id="73e5c1435811b5ff8f678930c14269a859a87b34" translate="yes" xml:space="preserve">
          <source>Viewing current events</source>
          <target state="translated">현재 이벤트보기</target>
        </trans-unit>
        <trans-unit id="e5566b5b15f94ed54e77939b2c8e0b1103df074d" translate="yes" xml:space="preserve">
          <source>Viewing extent map information</source>
          <target state="translated">익스텐트 맵 정보보기</target>
        </trans-unit>
        <trans-unit id="34eda80efe794e5f115ca75b88d51835b7ee0e63" translate="yes" xml:space="preserve">
          <source>Viewing in a text editor:</source>
          <target state="translated">텍스트 편집기에서보기 :</target>
        </trans-unit>
        <trans-unit id="b17ef2d85a86ad291db7198b1f8b6cb70d62d1aa" translate="yes" xml:space="preserve">
          <source>Viewing module configuration</source>
          <target state="translated">모듈 구성보기</target>
        </trans-unit>
        <trans-unit id="35c7f23d1cb7a8531acc370f9343942d812b4fc7" translate="yes" xml:space="preserve">
          <source>Viewing network configuration</source>
          <target state="translated">네트워크 구성보기</target>
        </trans-unit>
        <trans-unit id="38c4d1471db345c975616a22b699843cea4453a2" translate="yes" xml:space="preserve">
          <source>Viewing process status</source>
          <target state="translated">공정 상태보기</target>
        </trans-unit>
        <trans-unit id="d6dbce1c97c9e6d6ca5475ebd6effb88ae2bdc5c" translate="yes" xml:space="preserve">
          <source>Viewing relay logs</source>
          <target state="translated">릴레이 로그보기</target>
        </trans-unit>
        <trans-unit id="33f1eaf002c92557332cd4651ceabfa30e56da55" translate="yes" xml:space="preserve">
          <source>Viewing storage configuration</source>
          <target state="translated">스토리지 구성보기</target>
        </trans-unit>
        <trans-unit id="34f1ac713db3d390604df72633b17c465f38050b" translate="yes" xml:space="preserve">
          <source>Viewing system status</source>
          <target state="translated">시스템 상태보기</target>
        </trans-unit>
        <trans-unit id="345f0761583e84df6f81a9786817fade0cb79fff" translate="yes" xml:space="preserve">
          <source>Viewing the ColumnStore query plan</source>
          <target state="translated">ColumnStore 쿼리 계획보기</target>
        </trans-unit>
        <trans-unit id="38fb8b9b1472da4f7c9d7fce847926aa901ac384" translate="yes" xml:space="preserve">
          <source>Viewing the Slow Query Log</source>
          <target state="translated">느린 쿼리 로그보기</target>
        </trans-unit>
        <trans-unit id="576249ca08175917cfca8bbf675ef2a3037c47be" translate="yes" xml:space="preserve">
          <source>Viewing the binary log with mysqlbinlog.</source>
          <target state="translated">mysqlbinlog로 바이너리 로그보기</target>
        </trans-unit>
        <trans-unit id="d2d0182a66d926b32d32514f21d4e7b200f32afe" translate="yes" xml:space="preserve">
          <source>Viewing this table requires the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;PROCESS&lt;/a&gt;&lt;/code&gt; privilege.</source>
          <target state="translated">이 테이블을 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;PROCESS&lt;/a&gt;&lt;/code&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="1f03a47054f4fd5c6abcd2d1978c60b5bc5dd1c8" translate="yes" xml:space="preserve">
          <source>Views and Subqueries</source>
          <target state="translated">뷰와 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="1a7e52d6e226d759f13f9e724cd39269f20f0dab" translate="yes" xml:space="preserve">
          <source>Views are stored queries that act as a virtual table.</source>
          <target state="translated">뷰는 가상 테이블 역할을하는 저장된 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="9971a2a567b904f0d2e6267e0e382a67605ad3af" translate="yes" xml:space="preserve">
          <source>Views can be used for inserting or updating with certain limitations.</source>
          <target state="translated">뷰는 특정 제한 사항을 삽입하거나 업데이트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ded08d31cc8c90aa98f8c4797a25348f0bd2c23" translate="yes" xml:space="preserve">
          <source>Views must have unique column names with no duplicates, just like base tables. By default, the names of the columns retrieved by the SELECT statement are used for the view column names. To define explicit names for the view columns, the optional column_list clause can be given as a list of comma-separated identifiers. The number of names in column_list must be the same as the number of columns retrieved by the SELECT statement.</source>
          <target state="translated">뷰는 기본 테이블과 마찬가지로 중복이없는 고유 한 열 이름을 가져야합니다. 기본적으로 SELECT 문으로 검색 한 열 이름은보기 열 이름에 사용됩니다. 뷰 열의 명시 적 이름을 정의하기 위해 선택적 column_list 절을 쉼표로 구분 된 식별자 목록으로 제공 할 수 있습니다. column_list의 이름 수는 SELECT 문에서 검색 한 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5ce381f96953dd0d695ffbe968d2aad7262967ff" translate="yes" xml:space="preserve">
          <source>Views with definition &lt;code&gt;ALGORITHM=MERGE&lt;/code&gt; or &lt;code&gt;ALGORITHM=TEMPTABLE&lt;/code&gt; got accidentally swapped between MariaDB and MySQL. You have to re-create views created with either of these definitions (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6916&quot;&gt;MDEV-6916&lt;/a&gt;).</source>
          <target state="translated">정의 &lt;code&gt;ALGORITHM=MERGE&lt;/code&gt; 또는 &lt;code&gt;ALGORITHM=TEMPTABLE&lt;/code&gt; 을 가진 뷰 가 실수로 MariaDB와 MySQL간에 교환되었습니다. 이러한 정의 중 하나를 사용하여 작성된보기를 다시 작성해야합니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6916&quot;&gt;MDEV-6916&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cdbae7e47b8626e4b126321cdfc2bfa1ad1aefea" translate="yes" xml:space="preserve">
          <source>Views with definition ALGORITHM=MERGE or ALGORITHM=TEMPTABLE got accidentally swapped between MariaDB and MySQL. When upgrading, you have to re-create views created with either of these definitions (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6916&quot;&gt;MDEV-6916&lt;/a&gt;).</source>
          <target state="translated">정의 ALGORITHM = MERGE 또는 ALGORITHM = TEMPTABLE을 가진 뷰가 실수로 MariaDB와 MySQL간에 교환되었습니다. 업그레이드 할 때 이러한 정의 중 하나로 작성된보기를 다시 작성해야합니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6916&quot;&gt;MDEV-6916&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d90e8f9b0423fe184b5598dd2fbc7ab609561617" translate="yes" xml:space="preserve">
          <source>Virtual Indexing</source>
          <target state="translated">가상 인덱싱</target>
        </trans-unit>
        <trans-unit id="67ddc26e7b57b868c0dc12606692adfa7a3f28c6" translate="yes" xml:space="preserve">
          <source>Virtual Machine to Test the Cassandra Storage Engine</source>
          <target state="translated">Cassandra 스토리지 엔진을 테스트하는 가상 머신</target>
        </trans-unit>
        <trans-unit id="48215d546a3ab472e0c0843fc0979a0cff0e30b0" translate="yes" xml:space="preserve">
          <source>Virtual and special columns example usage</source>
          <target state="translated">가상 및 특수 열 예제 사용법</target>
        </trans-unit>
        <trans-unit id="04ea17dc5bbbe67ccfe50e0ea0e98c073ea95bc5" translate="yes" xml:space="preserve">
          <source>Virtual package to satisfy external depends</source>
          <target state="translated">외부 의존성을 만족시키는 가상 패키지</target>
        </trans-unit>
        <trans-unit id="687655bf06b03c50609d2648e3f7aa48a55e6033" translate="yes" xml:space="preserve">
          <source>Virtual table containing only special and virtual columns.</source>
          <target state="translated">특수 및 가상 열만 포함하는 가상 테이블.</target>
        </trans-unit>
        <trans-unit id="d8a62213e1c79c9c430f953333de69beb47a45cf" translate="yes" xml:space="preserve">
          <source>Virtual table returning information about the machine and network cards (Windows only).</source>
          <target state="translated">머신 및 네트워크 카드에 대한 정보를 리턴하는 가상 테이블 (Windows 만 해당).</target>
        </trans-unit>
        <trans-unit id="7de2a83b6e01e0ac850fcd10782bd1547977b97c" translate="yes" xml:space="preserve">
          <source>Virtual table that returns a file list like the Unix &lt;code&gt;ls&lt;/code&gt; or DOS &lt;code&gt;dir&lt;/code&gt; command.</source>
          <target state="translated">Unix &lt;code&gt;ls&lt;/code&gt; 또는 DOS &lt;code&gt;dir&lt;/code&gt; 명령 과 같은 파일 목록을 리턴하는 가상 테이블 .</target>
        </trans-unit>
        <trans-unit id="71792f8618a341280aa294d912a9958e0783867e" translate="yes" xml:space="preserve">
          <source>Virtually all INDEXes in MySQL are structured as BTrees BTrees allow very efficient for</source>
          <target state="translated">MySQL의 거의 모든 INDEX는 BTrees BTrees가</target>
        </trans-unit>
        <trans-unit id="5659ec4742d62b4463d24abc36256704cb9d66a4" translate="yes" xml:space="preserve">
          <source>Virtually all published algorithms involve a table scan. The previously published version of this blog had, embarrassingly, several algorithms that had table scans.</source>
          <target state="translated">실제로 게시 된 모든 알고리즘에는 테이블 스캔이 포함됩니다. 이 블로그의 이전에 출판 된 버전에는 당황스럽게도 테이블 스캔 기능이있는 몇 가지 알고리즘이있었습니다.</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="f54261a5ecf0c8810f65b590ba926060479dbe32" translate="yes" xml:space="preserve">
          <source>Visible columns picking dialog box</source>
          <target state="translated">보이는 열 선택 대화 상자</target>
        </trans-unit>
        <trans-unit id="0f27e56c648881d5fde9abf9396534facd5dc9d3" translate="yes" xml:space="preserve">
          <source>Visit &lt;a href=&quot;http://mysqlsandbox.net/&quot;&gt;http://mysqlsandbox.net/&lt;/a&gt; for details on how to install and use it.</source>
          <target state="translated">설치 및 사용 방법에 대한 자세한 내용은 &lt;a href=&quot;http://mysqlsandbox.net/&quot;&gt;http://mysqlsandbox.net/&lt;/a&gt; 을 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e027f2e40d6e185ac8d6b163f3dc82159be151da" translate="yes" xml:space="preserve">
          <source>Visit &lt;a href=&quot;http://ocelot.ca/&quot;&gt;ocelot.ca&lt;/a&gt; for more information and to download.</source>
          <target state="translated">자세한 정보 및 다운로드는 &lt;a href=&quot;http://ocelot.ca/&quot;&gt;ocelot.ca&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dd4a2d5281695e038386aeeb7fcd4715522cad8" translate="yes" xml:space="preserve">
          <source>Visit &lt;a href=&quot;https://www.dbdeployer.com&quot;&gt;https://www.dbdeployer.com&lt;/a&gt; for details on how to install and use it.</source>
          <target state="translated">설치 및 사용 방법에 대한 자세한 내용은 &lt;a href=&quot;https://www.dbdeployer.com&quot;&gt;https://www.dbdeployer.com&lt;/a&gt; 을 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="be3cac3d44d7a956727a69d0a2f2a422e6906a6e" translate="yes" xml:space="preserve">
          <source>Visual Query Builder (Visually create queries without knowing SQL);</source>
          <target state="translated">Visual Query Builder (SQL을 몰라도 시각적으로 쿼리 작성);</target>
        </trans-unit>
        <trans-unit id="7d5ff8a78053e527eded014255cd521acc58a964" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 cmake generator will create 32 bit projects by default. For 64 bit, you must pass CMake the &quot;generator&quot; parameter using -G in the configuration step, e.g.:</source>
          <target state="translated">Visual Studio 2017 cmake 생성기는 기본적으로 32 비트 프로젝트를 만듭니다. 64 비트의 경우 구성 단계에서 -G를 사용하여 CMake &quot;generator&quot;매개 변수를 전달해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="149edde3fd0e4e9ee03e92f286594c6abe293338" translate="yes" xml:space="preserve">
          <source>Visual Studio 2019 cmake generator will use host architecture by default, that is, with the steps above, cmake will build x64 binaries on x64 machine.</source>
          <target state="translated">Visual Studio 2019 cmake 생성기는 기본적으로 호스트 아키텍처를 사용합니다. 즉, 위 단계에서 cmake는 x64 컴퓨터에 x64 바이너리를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="fbad158b424354472563c4ae3fda02897ad93500" translate="yes" xml:space="preserve">
          <source>Visual Studio configuration used to create executables (default: MTR_VS_CONFIG environment variable).</source>
          <target state="translated">실행 파일을 만드는 데 사용되는 Visual Studio 구성 (기본값 : MTR_VS_CONFIG 환경 변수)</target>
        </trans-unit>
        <trans-unit id="cfa91db1a32cc5c7cbae240995469ce6630fae88" translate="yes" xml:space="preserve">
          <source>Visual Studio plugin designed to simplify database development and management.</source>
          <target state="translated">데이터베이스 개발 및 관리를 단순화하도록 설계된 Visual Studio 플러그인</target>
        </trans-unit>
        <trans-unit id="c07f6277aca09201d5aec6d61108b625208132a1" translate="yes" xml:space="preserve">
          <source>Visual addition of sub-queries to any part of the main query</source>
          <target state="translated">기본 쿼리의 모든 부분에 하위 쿼리를 시각적으로 추가</target>
        </trans-unit>
        <trans-unit id="f1a739312d66155f796ab33eb537cd79823f1ccf" translate="yes" xml:space="preserve">
          <source>Visual building of INSERT, UPDATE, and DELETE statements</source>
          <target state="translated">INSERT, UPDATE 및 DELETE 문의 시각적 빌드</target>
        </trans-unit>
        <trans-unit id="e45854230d93ae53628fbcf7945ef1f5f93de9b6" translate="yes" xml:space="preserve">
          <source>Visual editing of sub-queries</source>
          <target state="translated">하위 쿼리의 시각적 편집</target>
        </trans-unit>
        <trans-unit id="76f3673255499edfc851e7e7ee98fdf9fd72ac89" translate="yes" xml:space="preserve">
          <source>Visual editor for tables</source>
          <target state="translated">테이블 용 비주얼 편집기</target>
        </trans-unit>
        <trans-unit id="1b4cdf0d3f2e4b26aec4c972963694de47c6543e" translate="yes" xml:space="preserve">
          <source>Visual editors for columns, indexes, and views</source>
          <target state="translated">열, 색인 및보기를위한 시각적 편집기</target>
        </trans-unit>
        <trans-unit id="dc6f04c77fea057f44a587f7a47f0b34c66a307a" translate="yes" xml:space="preserve">
          <source>Visual editors for triggers, events, and user-defined functions</source>
          <target state="translated">트리거, 이벤트 및 사용자 정의 함수를위한 비주얼 편집기</target>
        </trans-unit>
        <trans-unit id="05a0cb8759f6c35aefe672eb86ee8e014d66d6d9" translate="yes" xml:space="preserve">
          <source>Visual query builder for SELECT, INSERT, UPDATE, and DELETE statements</source>
          <target state="translated">SELECT, INSERT, UPDATE 및 DELETE 문에 대한 시각적 쿼리 빌더</target>
        </trans-unit>
        <trans-unit id="25e93922fc11d954b916e3947c81a534ce98bb08" translate="yes" xml:space="preserve">
          <source>Visual query profiling</source>
          <target state="translated">시각적 쿼리 프로파일 링</target>
        </trans-unit>
        <trans-unit id="20909a1f2e2a6795d4471b415eebd0e6246c47a9" translate="yes" xml:space="preserve">
          <source>Visualization of JSON structures and nested types</source>
          <target state="translated">JSON 구조 및 중첩 유형의 시각화</target>
        </trans-unit>
        <trans-unit id="288a7434bcc12ae5f4ded6a5fe816d819d055531" translate="yes" xml:space="preserve">
          <source>Visualization of tables, views, and stored routines</source>
          <target state="translated">테이블, 뷰 및 저장 루틴의 시각화</target>
        </trans-unit>
        <trans-unit id="587bf2d7314da0ae33623bed16d872620b2768be" translate="yes" xml:space="preserve">
          <source>Vivian</source>
          <target state="translated">Vivian</target>
        </trans-unit>
        <trans-unit id="0bc2570224ce7abaa57129dcfeec51a73344651a" translate="yes" xml:space="preserve">
          <source>Vivian, Antony</source>
          <target state="translated">비비안, 안토니</target>
        </trans-unit>
        <trans-unit id="4680d1e35b7f63d1c6331fd3c6b5cbddd21f38c0" translate="yes" xml:space="preserve">
          <source>Voil&amp;agrave; !</source>
          <target state="translated">oil!</target>
        </trans-unit>
        <trans-unit id="a05451be6a13ba9281f274d24a86991cc7a96209" translate="yes" xml:space="preserve">
          <source>WAIT FOR ALL SLAVES</source>
          <target state="translated">모든 노예에 대한 대기</target>
        </trans-unit>
        <trans-unit id="c89bdb7cd5e392561768aebd13ba6d0bcdaebed2" translate="yes" xml:space="preserve">
          <source>WAIT and NOWAIT</source>
          <target state="translated">대기 및 NOWAIT</target>
        </trans-unit>
        <trans-unit id="0ef0cc21c826eea4c3454ab2ab11c8305736ee0d" translate="yes" xml:space="preserve">
          <source>WAIT/NOWAIT</source>
          <target state="translated">WAIT/NOWAIT</target>
        </trans-unit>
        <trans-unit id="e799b48fb589fbaf69da81b606a34622c69a9cb2" translate="yes" xml:space="preserve">
          <source>WAITERS_FLAG</source>
          <target state="translated">WAITERS_FLAG</target>
        </trans-unit>
        <trans-unit id="5d8dbf4f128b28466ecaf90fefbcc349e389e797" translate="yes" xml:space="preserve">
          <source>WAIT_OBJECT</source>
          <target state="translated">WAIT_OBJECT</target>
        </trans-unit>
        <trans-unit id="9e90d6b7d9d7babd580f6d80e728f7d978f457f6" translate="yes" xml:space="preserve">
          <source>WAIT_TIME</source>
          <target state="translated">WAIT_TIME</target>
        </trans-unit>
        <trans-unit id="e6c6d4249a826a251dc86d7df70c72a8067b7f3c" translate="yes" xml:space="preserve">
          <source>WAIT_TYPE</source>
          <target state="translated">WAIT_TYPE</target>
        </trans-unit>
        <trans-unit id="7d350c59640c961ac62b527481d13dd0effbfe00" translate="yes" xml:space="preserve">
          <source>WALTER</source>
          <target state="translated">WALTER</target>
        </trans-unit>
        <trans-unit id="9f51c87d0032b4e25a1161c6aacbe59c7b7ee02d" translate="yes" xml:space="preserve">
          <source>WAN Clustering</source>
          <target state="translated">WAN 클러스터링</target>
        </trans-unit>
        <trans-unit id="2e262e4a424eabde01dc01e37f8683936d3771f1" translate="yes" xml:space="preserve">
          <source>WAN: May need to increase (from the defaults) wsrep_provider_options = evs...</source>
          <target state="translated">WAN : 기본값에서 wsrep_provider_options = evs를 늘려야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf64ebcd7f48b02c816e8ccb19712f77f32b005" translate="yes" xml:space="preserve">
          <source>WARN_COND_ITEM_TRUNCATED</source>
          <target state="translated">WARN_COND_ITEM_TRUNCATED</target>
        </trans-unit>
        <trans-unit id="d974b196671f37afbb38b81227395aed1cfbf411" translate="yes" xml:space="preserve">
          <source>WARN_DATA_TRUNCATED</source>
          <target state="translated">WARN_DATA_TRUNCATED</target>
        </trans-unit>
        <trans-unit id="aba39ee9c4002de1797b1b59e5e2f0b8bbe0f155" translate="yes" xml:space="preserve">
          <source>WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED</source>
          <target state="translated">WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="72cd2a219664b1db719d7482fa79bd93fccba0c9" translate="yes" xml:space="preserve">
          <source>WARN_NO_MASTER_INF</source>
          <target state="translated">WARN_NO_MASTER_INF</target>
        </trans-unit>
        <trans-unit id="9b8de9bab78b2bd70c0c26fc41f2fc354bbb7d94" translate="yes" xml:space="preserve">
          <source>WARN_ON_BLOCKHOLE_IN_RBR</source>
          <target state="translated">WARN_ON_BLOCKHOLE_IN_RBR</target>
        </trans-unit>
        <trans-unit id="9b89a16942fd71c917100b661c26420df3cfd493" translate="yes" xml:space="preserve">
          <source>WARN_OPTION_BELOW_LIMIT</source>
          <target state="translated">WARN_OPTION_BELOW_LIMIT</target>
        </trans-unit>
        <trans-unit id="4acb99a9870e90d41fef24a9aa7ed7e8ed4e2893" translate="yes" xml:space="preserve">
          <source>WARN_OPTION_IGNORED</source>
          <target state="translated">WARN_OPTION_IGNORED</target>
        </trans-unit>
        <trans-unit id="ae8dbed2887066b5945787ed0f56d09ca1de23bc" translate="yes" xml:space="preserve">
          <source>WARN_PLUGIN_BUSY</source>
          <target state="translated">WARN_PLUGIN_BUSY</target>
        </trans-unit>
        <trans-unit id="d0396e0b3e190187730e350868c7173df8e24857" translate="yes" xml:space="preserve">
          <source>WARN_PLUGIN_DELETE_BUILTIN</source>
          <target state="translated">WARN_PLUGIN_DELETE_BUILTIN</target>
        </trans-unit>
        <trans-unit id="3a79bc501d57def9496e5202d36e046c8802bccd" translate="yes" xml:space="preserve">
          <source>WEEK</source>
          <target state="translated">WEEK</target>
        </trans-unit>
        <trans-unit id="612e4cd58829c2cefb2e14b552f9d3848b20706c" translate="yes" xml:space="preserve">
          <source>WEEK()</source>
          <target state="translated">WEEK()</target>
        </trans-unit>
        <trans-unit id="ef441399199836900f2959d6dfbd18cdd30467ce" translate="yes" xml:space="preserve">
          <source>WEEKDAY</source>
          <target state="translated">WEEKDAY</target>
        </trans-unit>
        <trans-unit id="60ff5aa918a4946e7b371b890e4720f4e0a92b98" translate="yes" xml:space="preserve">
          <source>WEEKDAY()</source>
          <target state="translated">WEEKDAY()</target>
        </trans-unit>
        <trans-unit id="41e00ed8dd77df5eb3f82b06a1f8636dff5735dd" translate="yes" xml:space="preserve">
          <source>WEEKOFYEAR</source>
          <target state="translated">WEEKOFYEAR</target>
        </trans-unit>
        <trans-unit id="6f71a8452d76b69e4d094ec5eaac97e6069b9deb" translate="yes" xml:space="preserve">
          <source>WEEKOFYEAR()</source>
          <target state="translated">WEEKOFYEAR()</target>
        </trans-unit>
        <trans-unit id="269ec4fae923a139b94c8dd206cdddcb59b23aa6" translate="yes" xml:space="preserve">
          <source>WEEKS</source>
          <target state="translated">WEEKS</target>
        </trans-unit>
        <trans-unit id="b3a9eb8cd8eddf317f8a810eb98dc8a0efa85e25" translate="yes" xml:space="preserve">
          <source>WEIGHT_STRING</source>
          <target state="translated">WEIGHT_STRING</target>
        </trans-unit>
        <trans-unit id="791724422d111e80612315eca7802c7b8c57af0c" translate="yes" xml:space="preserve">
          <source>WEIGHT_STRING() is particularly useful when adding new collations, for testing purposes.</source>
          <target state="translated">WEIGHT_STRING ()은 테스트 목적으로 새 데이터 정렬을 추가 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="01e1b2aa9aedfbd96aa9e5fafeb7e42fbb4e2a17" translate="yes" xml:space="preserve">
          <source>WEIGHT_STRING() returns NULL if given a NULL input.</source>
          <target state="translated">WEIGHT_STRING ()은 NULL 입력이 주어지면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f40d1e6692c90947dfa183e725d0fa67af34d767" translate="yes" xml:space="preserve">
          <source>WEL</source>
          <target state="translated">WEL</target>
        </trans-unit>
        <trans-unit id="792983ea3eace39c0fa2028a250b01739054b5f1" translate="yes" xml:space="preserve">
          <source>WERTHER</source>
          <target state="translated">WERTHER</target>
        </trans-unit>
        <trans-unit id="943f25cc8d7abfb9400129c428f47471a4e77ccc" translate="yes" xml:space="preserve">
          <source>WHAT</source>
          <target state="translated">WHAT</target>
        </trans-unit>
        <trans-unit id="fc97685ae6af136d283829a4218fd08a7fc69a9f" translate="yes" xml:space="preserve">
          <source>WHEELFOR</source>
          <target state="translated">WHEELFOR</target>
        </trans-unit>
        <trans-unit id="e3eafa40a094c805daed78cdb48c723e5b81b9a1" translate="yes" xml:space="preserve">
          <source>WHEN</source>
          <target state="translated">WHEN</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="be8e17bc925e98c8d48065d5387ce0ea9c9e75b1" translate="yes" xml:space="preserve">
          <source>WHERE &lt;a href=&quot;../sqrt/index&quot;&gt;SQRT(...)&lt;/a&gt;&amp;lt; ... -- No chance of using any index.</source>
          <target state="translated">어디서 &lt;a href=&quot;../sqrt/index&quot;&gt;SQRT (...)&lt;/a&gt; &amp;lt;...-인덱스를 사용할 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8aeb3c5c3eb02ab6a051311bcff74b4f3a9a8f8" translate="yes" xml:space="preserve">
          <source>WHERE lat BETWEEN ... AND lng BETWEEN... -- This has some chance of using such indexes.</source>
          <target state="translated">어디에서 ...와 lng 사이에 ...-이것은 그러한 인덱스를 사용할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99162382942a8c1fc3af61c4cffd45d3dfca60dc" translate="yes" xml:space="preserve">
          <source>WHILE</source>
          <target state="translated">WHILE</target>
        </trans-unit>
        <trans-unit id="66be473b782f7d2832b04240665f03714195e5fe" translate="yes" xml:space="preserve">
          <source>WHO</source>
          <target state="translated">WHO</target>
        </trans-unit>
        <trans-unit id="5e3d4c8c3394dc083bfb67877dcd60949f705f5f" translate="yes" xml:space="preserve">
          <source>WIDTH</source>
          <target state="translated">WIDTH</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="7913945997a369e8ea6004dfc36b2844dceea418" translate="yes" xml:space="preserve">
          <source>WITH</source>
          <target state="translated">WITH</target>
        </trans-unit>
        <trans-unit id="8d9b30aead58989c5f169313224d2a27e615fe81" translate="yes" xml:space="preserve">
          <source>WITH ADMIN</source>
          <target state="translated">ADMIN으로</target>
        </trans-unit>
        <trans-unit id="3e2c6b7e7f2abff28ee44fefa3d92b26084e96cb" translate="yes" xml:space="preserve">
          <source>WITH CHECK OPTION</source>
          <target state="translated">점검 옵션</target>
        </trans-unit>
        <trans-unit id="52bd34ab1cc45f922f381ef8bd9b1130cceb6174" translate="yes" xml:space="preserve">
          <source>WITH CONSISTENT SNAPSHOT</source>
          <target state="translated">일관된 스냅 샷</target>
        </trans-unit>
        <trans-unit id="1d2eb4c4eef37d387787e5483649f9862760db84" translate="yes" xml:space="preserve">
          <source>WITH QUERY EXPANSION</source>
          <target state="translated">검색어 확장</target>
        </trans-unit>
        <trans-unit id="60ab9d2ee698371bf55307667af5a2a110830255" translate="yes" xml:space="preserve">
          <source>WITH QUERY EXPANSION. In the following example, 'MariaDB' is always associated with the word 'database', so it is returned when query expansion is used, even though not explicitly requested.</source>
          <target state="translated">QUERY EXPANSION. 다음 예에서 'MariaDB'는 항상 'database'라는 단어와 연결되어 있으므로 명시 적으로 요청하지 않더라도 쿼리 확장이 사용될 때 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b964c839a8032c38371152557a0533e194eb916c" translate="yes" xml:space="preserve">
          <source>WITH ROLLUP</source>
          <target state="translated">롤업</target>
        </trans-unit>
        <trans-unit id="b5b3a0ed7e3ba9e802a8495977189b4b2987aeca" translate="yes" xml:space="preserve">
          <source>WITHIN</source>
          <target state="translated">WITHIN</target>
        </trans-unit>
        <trans-unit id="bf5664e97272edd76d76a99e4e3df3bb9e1762a4" translate="yes" xml:space="preserve">
          <source>WITHIN() is based on the original MySQL implementation, and uses object bounding rectangles, while &lt;a href=&quot;../st_within/index&quot;&gt;ST_WITHIN()&lt;/a&gt; uses object shapes.</source>
          <target state="translated">WITHIN ()은 원래 MySQL 구현을 기반으로하며 객체 경계 사각형을 사용하고 &lt;a href=&quot;../st_within/index&quot;&gt;ST_WITHIN ()&lt;/a&gt; 은 객체 모양을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56fbadc8d9764a70500cf87f645a8260e6c6c396" translate="yes" xml:space="preserve">
          <source>WITHOUT</source>
          <target state="translated">WITHOUT</target>
        </trans-unit>
        <trans-unit id="d89c031f115e61160783673dbcae38b696fc2f1d" translate="yes" xml:space="preserve">
          <source>WKB</source>
          <target state="translated">WKB</target>
        </trans-unit>
        <trans-unit id="7cc8704b7ba8d4fc1cd1fef31cc23a39a3c34de6" translate="yes" xml:space="preserve">
          <source>WKB stands for Well-Known Binary, a format for representing geographical and geometrical data.</source>
          <target state="translated">WKB는 Well-Known Binary의 약자이며 지리적 및 기하학적 데이터를 나타내는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="6db896b4622e443c61f51d6797ca8f16c0db518f" translate="yes" xml:space="preserve">
          <source>WKB stands for Well-Known Binary, a standard representation for geometric values.</source>
          <target state="translated">WKB는 기하 값의 표준 표현 인 Well-Known Binary의 약자입니다.</target>
        </trans-unit>
        <trans-unit id="5648e3bce2f1b8fbc0695e1a66da2933dbf6cb5d" translate="yes" xml:space="preserve">
          <source>WKB uses 1-byte unsigned integers, 4-byte unsigned integers, and 8-byte double-precision numbers.</source>
          <target state="translated">WKB는 1 바이트 부호없는 정수, 4 바이트 부호없는 정수 및 8 바이트 배정 밀도 숫자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a7b41f364c86fbbc79ea267329cc23eea4f59299" translate="yes" xml:space="preserve">
          <source>WKT</source>
          <target state="translated">WKT</target>
        </trans-unit>
        <trans-unit id="782fabf8e632a52f9d4ab031530a2b79e61fef1a" translate="yes" xml:space="preserve">
          <source>WKT Definition</source>
          <target state="translated">WKT 정의</target>
        </trans-unit>
        <trans-unit id="0405f95269ffdeace56911b208aee541ee2a5a68" translate="yes" xml:space="preserve">
          <source>WL#3750: initial specification for FirstMatch</source>
          <target state="translated">WL # 3750 : FirstMatch의 초기 사양</target>
        </trans-unit>
        <trans-unit id="160dff3e7476ab1286cc44de6ef17a12aec15df8" translate="yes" xml:space="preserve">
          <source>WMI provides an operating system interface through which instrumented components provide information. Some Microsoft tools to retrieve information through WMI are the WMIC console command and the WMI CMI Studio application.</source>
          <target state="translated">WMI는 계측 된 구성 요소가 정보를 제공 할 수있는 운영 체제 인터페이스를 제공합니다. WMI를 통해 정보를 검색하는 일부 Microsoft 도구는 WMIC 콘솔 명령 및 WMI CMI Studio 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="bba0da39f31c754ce2c6c2f242794e84fe882a98" translate="yes" xml:space="preserve">
          <source>WMI tables returns one row for each instance of the related information. The above example is handy to get the class equivalent of the alias of the WMIC command and also to have a list of many classes commonly used.</source>
          <target state="translated">WMI 테이블은 관련 정보의 각 인스턴스에 대해 하나의 행을 반환합니다. 위의 예제는 WMIC 명령의 별명에 해당하는 클래스를 가져오고 일반적으로 사용되는 많은 클래스 목록을 갖는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="27ad330619a7bfbee351115b167c5a6593f2530a" translate="yes" xml:space="preserve">
          <source>WRITE</source>
          <target state="translated">WRITE</target>
        </trans-unit>
        <trans-unit id="805b23664d5d530514d6f71d764ef3e347a1ea5b" translate="yes" xml:space="preserve">
          <source>WRITE CONCURRENT</source>
          <target state="translated">쓰기 동시</target>
        </trans-unit>
        <trans-unit id="0f5142a33595a58426f81919e0566e08417396ff" translate="yes" xml:space="preserve">
          <source>WRITER_THREAD</source>
          <target state="translated">WRITER_THREAD</target>
        </trans-unit>
        <trans-unit id="4b5085e9f95e7d44ebf33519c62a17ab54a54280" translate="yes" xml:space="preserve">
          <source>WSAStartup Failed</source>
          <target state="translated">WSAStartup 실패</target>
        </trans-unit>
        <trans-unit id="aa8762ad94728890df4d3a53975af1abd5158461" translate="yes" xml:space="preserve">
          <source>WSREP_INFO</source>
          <target state="translated">WSREP_INFO</target>
        </trans-unit>
        <trans-unit id="3d6d8635a4da819d008914b1b3e70fd132febc14" translate="yes" xml:space="preserve">
          <source>WSREP_INFO Plugin</source>
          <target state="translated">WSREP_INFO 플러그인</target>
        </trans-unit>
        <trans-unit id="b4b4c84c12b866be62877fe008590b2ef6cc8ed9" translate="yes" xml:space="preserve">
          <source>Wait and retry if table is in use.</source>
          <target state="translated">테이블이 사용중인 경우 기다렸다가 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb486d3fad507ebe8b98f3668496a5d72846829" translate="yes" xml:space="preserve">
          <source>Wait events summarized by account and event name</source>
          <target state="translated">계정 및 이벤트 이름으로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="98ba76ddc251c529adf84a1a8e1140ed35a380c7" translate="yes" xml:space="preserve">
          <source>Wait events summarized by event name</source>
          <target state="translated">이벤트 이름으로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="7575e22382e5efdd27965f2367df4ff3c76ebfc4" translate="yes" xml:space="preserve">
          <source>Wait events summarized by host and event name</source>
          <target state="translated">호스트 및 이벤트 이름으로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="fd008ace2102345125da42b177c86b9a0bdc6dec" translate="yes" xml:space="preserve">
          <source>Wait events summarized by instance</source>
          <target state="translated">인스턴스별로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="d9a6890801ccd1cd938f94ccc40ee0a009d7a648" translate="yes" xml:space="preserve">
          <source>Wait events summarized by thread and event name</source>
          <target state="translated">스레드 및 이벤트 이름으로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="f47c0974e902e45dbe75e74df79871a17b431028" translate="yes" xml:space="preserve">
          <source>Wait events summarized by user and event name</source>
          <target state="translated">사용자 및 이벤트 이름으로 요약 된 대기 이벤트</target>
        </trans-unit>
        <trans-unit id="38f21805f8890ad1d981d69e842dd5c6812ca8b1" translate="yes" xml:space="preserve">
          <source>Wait for Xact Count</source>
          <target state="translated">Xact 카운트를 기다립니다</target>
        </trans-unit>
        <trans-unit id="a4f006c2aca29074d6152cb5cbc632f28663ac30" translate="yes" xml:space="preserve">
          <source>Wait for a signal</source>
          <target state="translated">신호를 기다립니다</target>
        </trans-unit>
        <trans-unit id="7758b6064501d205d554e57a29653c2f8691922c" translate="yes" xml:space="preserve">
          <source>Wait for all statements using write locked non-transactional tables to end.</source>
          <target state="translated">쓰기 잠금 비 트랜잭션 테이블을 사용하는 모든 명령문이 종료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="b594ad4f1a6c9c4a49e6a44fa3610a68c14da066" translate="yes" xml:space="preserve">
          <source>Wait for more data from the server instead of stopping at the end of the last log. Implies &lt;code&gt;--to-last-log&lt;/code&gt;.</source>
          <target state="translated">마지막 로그 끝에서 중지하는 대신 서버에서 더 많은 데이터를 기다립니다. --to &lt;code&gt;--to-last-log&lt;/code&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="628b40b61ccd340431c6bd57d112735e0e5b1b26" translate="yes" xml:space="preserve">
          <source>Wait for the confirmation email to show up and follow the instructions.</source>
          <target state="translated">확인 이메일이 표시 될 때까지 기다렸다가 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="eed99cb49427a0daf5eb8e50cfffe1e27bf79f7b" translate="yes" xml:space="preserve">
          <source>Wait for the last binlog event to be sent to all connected slaves before shutting down. This option is off by default.</source>
          <target state="translated">종료하기 전에 마지막 binlog 이벤트가 연결된 모든 슬레이브로 전송 될 때까지 기다리십시오. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af2aeb5d9f9bd11dabcae43a9bccf4674c6cbfd" translate="yes" xml:space="preserve">
          <source>Wait if table is locked.</source>
          <target state="translated">테이블이 잠겨 있으면 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="1e694bd1d7c1816a78e18483346c680ed55c7fb2" translate="yes" xml:space="preserve">
          <source>Wait on a lock was aborted due to a pending exclusive lock</source>
          <target state="translated">보류중인 독점 잠금으로 인해 잠금 대기가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b302994d29a567331c3108d02357edc15c83e21" translate="yes" xml:space="preserve">
          <source>Wait until all SELECT's are done before starting the statement. Used with storage engines that uses table locking (MyISAM, Aria etc). See &lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;HIGH_PRIORITY and LOW_PRIORITY clauses&lt;/a&gt; for details.</source>
          <target state="translated">명령문을 시작하기 전에 모든 SELECT가 완료 될 때까지 기다리십시오. 테이블 잠금 (MyISAM, Aria 등)을 사용하는 스토리지 엔진과 함께 사용됩니다. 자세한 내용은 &lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;HIGH_PRIORITY 및 LOW_PRIORITY 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c9ac3657426ffb4427fc6371b65459663c90fc0" translate="yes" xml:space="preserve">
          <source>Wait until slave reaches the GTID position</source>
          <target state="translated">슬레이브가 GTID 위치에 도달 할 때까지 기다립니다</target>
        </trans-unit>
        <trans-unit id="7173c9f522c94ae1846a58bc2ccd66e01242e560" translate="yes" xml:space="preserve">
          <source>Wait until slave reaches the GTID position.</source>
          <target state="translated">슬레이브가 GTID 위치에 도달 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="82eef2fbe38038d379b8360826e1ef187703baa4" translate="yes" xml:space="preserve">
          <source>Waiting due to global read lock</source>
          <target state="translated">글로벌 읽기 잠금으로 인해 대기 중</target>
        </trans-unit>
        <trans-unit id="336c591ffc06b6400495fab4b0f53f29778a623e" translate="yes" xml:space="preserve">
          <source>Waiting for &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events to arrive after successfully connecting. If there are no new events on the master, this state can persist for as many seconds as specified by the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; system variable, after which the thread will reconnect.</source>
          <target state="translated">연결 후 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트가 도착하기를 기다리는 중입니다 . 마스터에 새로운 이벤트가없는 경우이 상태는 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; 시스템 변수에 지정된 수초 동안 지속될 수 있으며 그 후에 스레드가 다시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d4e676edc55efa053b4989151e149831ccf875" translate="yes" xml:space="preserve">
          <source>Waiting for &lt;em&gt;xx&lt;/em&gt; lock</source>
          <target state="translated">&lt;em&gt;xx&lt;/em&gt; 잠금 대기 중</target>
        </trans-unit>
        <trans-unit id="8075360fdba603f4185a8e1736056855ac098953" translate="yes" xml:space="preserve">
          <source>Waiting for INSERT</source>
          <target state="translated">INSERT를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="76845b24ac2b4d30b385142f03acd4610d81b894" translate="yes" xml:space="preserve">
          <source>Waiting for a global read lock.</source>
          <target state="translated">글로벌 읽기 잠금을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="939d0b80c56075f79f5f1272b6dfbfb59b4da916" translate="yes" xml:space="preserve">
          <source>Waiting for an unspecified condition to occur.</source>
          <target state="translated">지정되지 않은 조건이 발생하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="617edd838311f080a5de21002cf5fb58a9ca1a96" translate="yes" xml:space="preserve">
          <source>Waiting for commit lock</source>
          <target state="translated">커밋 잠금 대기 중</target>
        </trans-unit>
        <trans-unit id="1127980c90588e8f7811ac2a9724de90df535e61" translate="yes" xml:space="preserve">
          <source>Waiting for delayed insert-handler lock to access the delayed-insert handler thread.</source>
          <target state="translated">지연된 삽입 핸들러 스레드가 액세스하기 위해 지연된 삽입 핸들러 잠금을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="f783921322b8a44b43be350ce6636f7709dec660" translate="yes" xml:space="preserve">
          <source>Waiting for global read lock</source>
          <target state="translated">글로벌 읽기 잠금 대기 중</target>
        </trans-unit>
        <trans-unit id="f13dfc97bb27ac6735d4424d47338d16c52e820c" translate="yes" xml:space="preserve">
          <source>Waiting for master to send event</source>
          <target state="translated">마스터가 이벤트를 보내기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="65bcedd7629f225890ceb31add741b3739725797" translate="yes" xml:space="preserve">
          <source>Waiting for master update</source>
          <target state="translated">마스터 업데이트를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="0e9528cfb22a904368b99db58fff877a3d07ed3b" translate="yes" xml:space="preserve">
          <source>Waiting for new inserts, as all inserts have been processed.</source>
          <target state="translated">모든 인서트가 처리되었으므로 새 인서트를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9deddfdb2ba6f959015fac94f7544de034ee8b7f" translate="yes" xml:space="preserve">
          <source>Waiting for next activation</source>
          <target state="translated">다음 활성화를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="9738329f68ce87c84a76f7484c9ee438753e742b" translate="yes" xml:space="preserve">
          <source>Waiting for other master connection to process GTID received on multiple master connections</source>
          <target state="translated">여러 마스터 연결에서 수신 한 GTID를 처리하기 위해 다른 마스터 연결을 기다리는 중</target>
        </trans-unit>
        <trans-unit id="56e33212e981f5f0a3918d5eb241d5fe959bc395" translate="yes" xml:space="preserve">
          <source>Waiting for prior transaction to start commit before starting next transaction</source>
          <target state="translated">다음 트랜잭션을 시작하기 전에 이전 트랜잭션이 커밋을 시작하기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="461d90054bb8306be252cf4fde47d057414103f1" translate="yes" xml:space="preserve">
          <source>Waiting for query cache lock</source>
          <target state="translated">쿼리 캐시 잠금 대기</target>
        </trans-unit>
        <trans-unit id="88d55b5fb17264bceaec464232a32d76dd07c231" translate="yes" xml:space="preserve">
          <source>Waiting for scheduler to stop</source>
          <target state="translated">스케줄러가 중지되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="b0c93570bbf4ac2267117d6f4ef74feee92685f0" translate="yes" xml:space="preserve">
          <source>Waiting for slave mutex on exit</source>
          <target state="translated">종료시 슬레이브 뮤텍스 대기</target>
        </trans-unit>
        <trans-unit id="4396f17ccf4f199dee98586c6802ef6e1502f506" translate="yes" xml:space="preserve">
          <source>Waiting for slave mutex while the thread is stopping. Only occurs very briefly.</source>
          <target state="translated">스레드가 중지되는 동안 슬레이브 뮤텍스를 기다리는 중입니다. 아주 간단히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff601084fd18f3060a9d4a5e4bbf221af7654170" translate="yes" xml:space="preserve">
          <source>Waiting for table level lock</source>
          <target state="translated">테이블 레벨 잠금 대기 중</target>
        </trans-unit>
        <trans-unit id="c133a34ed8835c40b454ae634180fb9e2bcb9e0e" translate="yes" xml:space="preserve">
          <source>Waiting for the client to send a new statement.</source>
          <target state="translated">클라이언트가 새 문장을 보내기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="028f4b236c4702413c113e277bb95a9a10b80b70" translate="yes" xml:space="preserve">
          <source>Waiting for the delayed-insert connection thread to add rows to the queue.</source>
          <target state="translated">지연 삽입 연결 스레드가 큐에 행을 추가하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5311bed3b2c06000bb2eab49610c200f97349e2c" translate="yes" xml:space="preserve">
          <source>Waiting for the delayed-insert handler thread to initialize. Follows from the &lt;code&gt;Creating delayed handler&lt;/code&gt; state and before the &lt;code&gt;got old table&lt;/code&gt; state.</source>
          <target state="translated">지연 삽입 핸들러 스레드가 초기화되기를 기다리는 중입니다. 으로부터 다음 &lt;code&gt;Creating delayed handler&lt;/code&gt; 상태와 이전에 &lt;code&gt;got old table&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="8b9a056a9c09d06bb7067d13c93106f35bc088a8" translate="yes" xml:space="preserve">
          <source>Waiting for the event scheduler to stop after issuing &lt;code&gt;SET GLOBAL event_scheduler=OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET GLOBAL event_scheduler=OFF&lt;/code&gt; 를 발행 한 후 이벤트 스케줄러가 중지 되기를 기다리는 중입니다 .</target>
        </trans-unit>
        <trans-unit id="79650756a341aac27d9b88cd5c977abf1c8f76f8" translate="yes" xml:space="preserve">
          <source>Waiting for the next event in relay log</source>
          <target state="translated">릴레이 로그에서 다음 이벤트를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="54094ee2eec0cef94b5a806825a843fdbf9259dc" translate="yes" xml:space="preserve">
          <source>Waiting for the slave SQL thread to free enough relay log space.</source>
          <target state="translated">슬레이브 SQL 스레드가 충분한 릴레이 로그 공간을 확보하기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="7e1ae2aa3f1864978cd16e0f8b9be705739b0aae" translate="yes" xml:space="preserve">
          <source>Waiting for work from SQL thread</source>
          <target state="translated">SQL 스레드에서 작업 대기 중</target>
        </trans-unit>
        <trans-unit id="b2a5b27225133de2fe43a2ed2579f4276f937865" translate="yes" xml:space="preserve">
          <source>Waiting for worker threads to be idle</source>
          <target state="translated">작업자 스레드가 유휴 상태가되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="5f0df6c37b62e9dc783881b4450c0e4aa24ce7a1" translate="yes" xml:space="preserve">
          <source>Waiting for worker threads to pause for global read lock</source>
          <target state="translated">글로벌 읽기 잠금을 위해 작업자 스레드가 일시 중지되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="0d043205aa3a50287c2ffc7dd5de4e3bdeb692db" translate="yes" xml:space="preserve">
          <source>Waiting on cond</source>
          <target state="translated">조건을 기다리는 중</target>
        </trans-unit>
        <trans-unit id="a92f0f0e8554fa56d94bcb55821929aab2fe7a10" translate="yes" xml:space="preserve">
          <source>Waiting on empty queue</source>
          <target state="translated">빈 대기열에서 대기 중</target>
        </trans-unit>
        <trans-unit id="0fe0dd4bccec59a379fb24e0bb4b7cf3b01fe7bb" translate="yes" xml:space="preserve">
          <source>Waiting to finalize termination</source>
          <target state="translated">종료를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="74534ab17cd9bf9c3720a57f2bbc69b6738e722d" translate="yes" xml:space="preserve">
          <source>Waiting to obtain a lock of type &lt;code&gt;xx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xx&lt;/code&gt; 유형의 잠금을 얻기 위해 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="35ff6c7728f0d8887d8b34f2cc311c842c4164f6" translate="yes" xml:space="preserve">
          <source>Waiting to reconnect after a binary log dump request has failed due to disconnection. The length of time in this state is determined by the &lt;code&gt;MASTER_CONNECT_RETRY&lt;/code&gt; clause of the &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt; statement.</source>
          <target state="translated">연결 끊김으로 인해 이진 로그 덤프 요청이 실패한 후 다시 연결 대기 중입니다. 이 상태의 시간 길이 는 &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt; 문의 &lt;code&gt;MASTER_CONNECT_RETRY&lt;/code&gt; 절에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef216b4eeb7596db454def9f19d8416d83b273f9" translate="yes" xml:space="preserve">
          <source>Waiting to reconnect after a failed binlog dump request</source>
          <target state="translated">실패한 binlog 덤프 요청 후 다시 연결 대기</target>
        </trans-unit>
        <trans-unit id="7bd9cf88a4b8dc11228d18d2f4df2ac6864bdd86" translate="yes" xml:space="preserve">
          <source>Waiting to reconnect after a failed master event read</source>
          <target state="translated">마스터 이벤트 읽기 실패 후 다시 연결 대기 중</target>
        </trans-unit>
        <trans-unit id="4652f6a7385c69ab94ba19f75aaf58848ef092a9" translate="yes" xml:space="preserve">
          <source>Waiting to take a query cache lock.</source>
          <target state="translated">쿼리 캐시 잠금을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="231678524097b9beeca2c35fb4a5fbc4498db5d3" translate="yes" xml:space="preserve">
          <source>Waiting while replication worker thread pool is busy</source>
          <target state="translated">복제 작업자 스레드 풀이 사용중인 동안 대기</target>
        </trans-unit>
        <trans-unit id="696e73db557bc2081057066bbdb3d497ffd646ab" translate="yes" xml:space="preserve">
          <source>Waits for acknowledgement from the slave.</source>
          <target state="translated">슬레이브로부터의 승인을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="999b009499b9b4ecf36ca5bf0a702b81895ee344" translate="yes" xml:space="preserve">
          <source>Waits until &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statements complete before issuing the global lock</source>
          <target state="translated">글로벌 잠금을 발행하기 전에 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문이 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e80316060e22dec658add18c31893ad79a687810" translate="yes" xml:space="preserve">
          <source>Waits until &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statements complete before issuing the global lock</source>
          <target state="translated">글로벌 잠금을 발행하기 전에 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문이 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="48b52f1cf25540a332970722ac6fa730beee7545" translate="yes" xml:space="preserve">
          <source>Waits until all queries complete before issuing the global lock</source>
          <target state="translated">글로벌 잠금을 발행하기 전에 모든 쿼리가 완료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="a96ac326df6cb3c701db62e31983f83a28f6f9fb" translate="yes" xml:space="preserve">
          <source>Walk through the partition, in order, until finding the the first row with &lt;a href=&quot;../cume_dist/index&quot;&gt;CUME_DIST()&lt;/a&gt; &amp;gt; function_argument.</source>
          <target state="translated">&lt;a href=&quot;../cume_dist/index&quot;&gt;CUME_DIST ()&lt;/a&gt; &amp;gt; function_argument를 사용하여 첫 번째 행을 찾을 때까지 파티션을 순서대로 진행하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa85c07f265adff33e9c8cc672e23e0ed6bfda03" translate="yes" xml:space="preserve">
          <source>Walking backward from the end does not know the page numbers.</source>
          <target state="translated">끝에서 뒤로 걷는 것은 페이지 번호를 모릅니다.</target>
        </trans-unit>
        <trans-unit id="ff04ba5922c9a53aceb985ef8a0cd379d96390df" translate="yes" xml:space="preserve">
          <source>Walkthrough configuration of PAM authentication and user mapping with Unix authentication.</source>
          <target state="translated">PAM 인증 및 Unix 인증을 통한 사용자 매핑의 연습 구성</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="fb0fc445d054cbf906f79854b5120e41988f7da3" translate="yes" xml:space="preserve">
          <source>Warning: Avoid using this table type in production applications. This file format is specific to CONNECT and may not be supported in future versions.</source>
          <target state="translated">경고 : 프로덕션 애플리케이션에서이 테이블 유형을 사용하지 마십시오. 이 파일 형식은 CONNECT에만 적용되며 이후 버전에서는 지원되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd2744444d1eb32a494823316f382e2892e852e4" translate="yes" xml:space="preserve">
          <source>Warnings on possible data losses or errors during synchronization</source>
          <target state="translated">동기화 중 발생할 수있는 데이터 손실 또는 오류에 대한 경고</target>
        </trans-unit>
        <trans-unit id="698276d7d836d7b9905bc4a5b443d9f8df4f63bb" translate="yes" xml:space="preserve">
          <source>Warnings on possible problems prior to synchronization</source>
          <target state="translated">동기화 전 가능한 문제에 대한 경고</target>
        </trans-unit>
        <trans-unit id="9cb3f49812144aecc3d5abc8337c5e60e6fcf53c" translate="yes" xml:space="preserve">
          <source>Was the certificate signed by a trusted Certificate Authority (CA)?</source>
          <target state="translated">인증서가 신뢰할 수있는 인증 기관 (CA)에 의해 서명 되었습니까?</target>
        </trans-unit>
        <trans-unit id="27046ec50177474e2a486f6d98e6cacf2c42cc3e" translate="yes" xml:space="preserve">
          <source>Watch the MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; on the joiner node and verify that the node does not need to perform a &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;normal SSTs&lt;/a&gt; due to the manual SST.</source>
          <target state="translated">결합 자 노드 에서 MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 를보고 수동 ​​SST로 인해 노드가 &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;정상적인 SST&lt;/a&gt; 를 수행 할 필요가 없는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6805ab5030d29037860e977802a3d95ac771b4c1" translate="yes" xml:space="preserve">
          <source>Watch these status variables:</source>
          <target state="translated">다음 상태 변수를보십시오.</target>
        </trans-unit>
        <trans-unit id="d084b8f0b97d275506d50fe6052774eb85ba4245" translate="yes" xml:space="preserve">
          <source>Watches window for variable evaluation</source>
          <target state="translated">변수 평가를위한 조사 식 창</target>
        </trans-unit>
        <trans-unit id="fb880c125f0fe47d8f0f9d229058a911dee7b8be" translate="yes" xml:space="preserve">
          <source>Ways to add simple code to SQL statements, or create your own functions or stored procedures.</source>
          <target state="translated">SQL 문에 간단한 코드를 추가하거나 고유 한 함수 또는 저장 프로 시저를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="0834b04058f8ad6ce05dc821349af5e394075ed9" translate="yes" xml:space="preserve">
          <source>Ways to fix this issue:</source>
          <target state="translated">이 문제를 해결하는 방법 :</target>
        </trans-unit>
        <trans-unit id="99806d5c55abdc3c38eb413a83fefb879ffc10fe" translate="yes" xml:space="preserve">
          <source>We also need to create LDAP users with the same name as the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;dba&lt;/code&gt; MariaDB users. See &lt;a href=&quot;../user-and-group-mapping-with-pam/index#pam-user-with-same-name-as-mapped-mariadb-user-must-exist&quot;&gt;here&lt;/a&gt; to read more about why. No one will be logging in as these users, so they do not need passwords. Instead of the &lt;code&gt;People&lt;/code&gt;&lt;code&gt;organizationalUnit&lt;/code&gt;, we will create them in the &lt;code&gt;System Users&lt;/code&gt;&lt;code&gt;organizationalUnit&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;dba&lt;/code&gt; MariaDB 사용자 와 동일한 이름의 LDAP 사용자를 작성해야 합니다. 이유에 대한 자세한 내용은 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#pam-user-with-same-name-as-mapped-mariadb-user-must-exist&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . 아무도이 사용자로 로그인하지 않으므로 비밀번호가 필요하지 않습니다. &lt;code&gt;People&lt;/code&gt; &lt;code&gt;organizationalUnit&lt;/code&gt; 대신 &lt;code&gt;System Users&lt;/code&gt; &lt;code&gt;organizationalUnit&lt;/code&gt; 에서 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="11ae38feea5b0c8962c150975494d5737952fa07" translate="yes" xml:space="preserve">
          <source>We also need to create Unix users with the same name as the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;dba&lt;/code&gt; MariaDB users. See &lt;a href=&quot;../user-and-group-mapping-with-pam/index#pam-user-with-same-name-as-mapped-mariadb-user-must-exist&quot;&gt;here&lt;/a&gt; to read more about why. No one will be logging in as these users, so they do not need passwords.</source>
          <target state="translated">또한 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;dba&lt;/code&gt; MariaDB 사용자 와 동일한 이름으로 Unix 사용자를 작성해야 합니다. 이유에 대한 자세한 내용은 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#pam-user-with-same-name-as-mapped-mariadb-user-must-exist&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 . 아무도이 사용자로 로그인하지 않으므로 비밀번호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7e8f67387a800da1fece8230a6862d957040aea" translate="yes" xml:space="preserve">
          <source>We also specified &lt;code&gt;ON UPDATE RESTRICT&lt;/code&gt;. This should prevent us from modifying an author's &lt;code&gt;id&lt;/code&gt; (the column referenced by the foreign key) if a child row exists:</source>
          <target state="translated">&lt;code&gt;ON UPDATE RESTRICT&lt;/code&gt; 도 지정했습니다 . 자식 행이 존재하는 경우 저자 &lt;code&gt;id&lt;/code&gt; (외래 키가 참조하는 열) 를 수정하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="8f2c34a862cf2b962713e1ec6efff4ce8db31b3d" translate="yes" xml:space="preserve">
          <source>We also utilize the log rotate tool and by default we are configured to keep 7 days of log files. They are stored in /var/log/mariadb/columnstore/archive.</source>
          <target state="translated">또한 로그 회전 도구를 사용하며 기본적으로 7 일 동안 로그 파일을 유지하도록 구성되어 있습니다. 그것들은 / var / log / mariadb / columnstore / archive에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f90ab49aea2c4cb3a28f52ebb62f386ff03a743e" translate="yes" xml:space="preserve">
          <source>We are grateful to these companies for their support of MariaDB!</source>
          <target state="translated">우리는 이들 회사가 MariaDB를 지원해 주셔서 감사합니다!</target>
        </trans-unit>
        <trans-unit id="9a77102415cfad85e1b028da3eb7495591ebbb24" translate="yes" xml:space="preserve">
          <source>We are working with Tokutek to improve this feature before adding it to MariaDB.</source>
          <target state="translated">이 기능을 MariaDB에 추가하기 전에 Tokutek과 협력하여이 기능을 개선하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e252c30c0ef34bb1f7f8ed55dd24aa428c93f4" translate="yes" xml:space="preserve">
          <source>We can alternatively define specifically the table columns but what happens if the Pivot column contains values that is not matching a &amp;ldquo;data&amp;rdquo; column? There are three cases depending on the specified options and flags.</source>
          <target state="translated">테이블 열을 구체적으로 정의 할 수도 있지만 피벗 열에 &quot;데이터&quot;열과 일치하지 않는 값이 포함되어 있으면 어떻게됩니까? 지정된 옵션 및 플래그에 따라 세 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a51991be8cd1a18ffe4e2bfb1b6cfe3ea1cffeff" translate="yes" xml:space="preserve">
          <source>We can check that this was done correctly by:</source>
          <target state="translated">다음을 통해 올바르게 수행되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201df792925b35ae197a0918d2a9bb1aef4cc2bf" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; configuration file for MariaDB with the following command:</source>
          <target state="translated">우리는 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 에의 다음 명령을 MariaDB에 대한 구성 파일 :</target>
        </trans-unit>
        <trans-unit id="54bebb11597f82e51b1912d459fd500abebeda37" translate="yes" xml:space="preserve">
          <source>We can create an occur table by:</source>
          <target state="translated">다음과 같은 방법으로 발생 테이블을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31810bdd761121d7da6bec0b160c6ceeb5ae720a" translate="yes" xml:space="preserve">
          <source>We can decompress and unpack the backup as follows:</source>
          <target state="translated">다음과 같이 백업을 압축 해제하고 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="0e1e771a61da1d41449d49cd354eef2579b8f3a5" translate="yes" xml:space="preserve">
          <source>We can decrypt, decompress and unpack the backup as follow (note &lt;code&gt;gzip -d&lt;/code&gt; in the pipeline):</source>
          <target state="translated">다음과 같이 백업을 해독, 압축 풀기 및 압축 해제 할 수 있습니다 ( 파이프 라인에서 &lt;code&gt;gzip -d&lt;/code&gt; 참고 ).</target>
        </trans-unit>
        <trans-unit id="e71236582c319a414696dbbd8811da03bed414b7" translate="yes" xml:space="preserve">
          <source>We can do this:</source>
          <target state="translated">우리는 할 수있어:</target>
        </trans-unit>
        <trans-unit id="c3a9f62f2b2ceb6b1d3593f800e24c38b78ce08b" translate="yes" xml:space="preserve">
          <source>We can for instance create a partition table using these tables as physical partitions by:</source>
          <target state="translated">예를 들어 다음과 같은 방법으로 이러한 테이블을 물리적 파티션으로 사용하여 파티션 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a763327d1b3d5a6256ffb977c3a2dd1f74133fe" translate="yes" xml:space="preserve">
          <source>We can generate separate sequences based on account type, using the PARTITION BY clause:</source>
          <target state="translated">PARTITION BY 절을 사용하여 계정 유형에 따라 별도의 시퀀스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ea7fa94a6cfd816992447f10887c00890ba92b" translate="yes" xml:space="preserve">
          <source>We can have a different view on these data, where each child will be associated with his/her mother by creating an &lt;code&gt;XCOL&lt;/code&gt; table by:</source>
          <target state="translated">다음과 같은 방법으로 &lt;code&gt;XCOL&lt;/code&gt; 테이블을 작성하여 각 어린이가 어머니와 연관 될 수있는 데이터에 대해 다른 견해를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6c735287b587bf8c3895bba0d0f0f7326a15ee2" translate="yes" xml:space="preserve">
          <source>We can install them with &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt; 로 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="88af064755b6224f5423b5afe43a16965df67372" translate="yes" xml:space="preserve">
          <source>We can populate it by:</source>
          <target state="translated">우리는 다음과 같이 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a591df737e32f3febe94acb8a02081861596f0" translate="yes" xml:space="preserve">
          <source>We can populate it directly using the supported &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statement:</source>
          <target state="translated">지원되는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문을 사용하여 직접 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a368040dbcffc5532d99801c6e34ae36acc17f9" translate="yes" xml:space="preserve">
          <source>We can repair this, but all rows from the corrupt row onwards will be lost:</source>
          <target state="translated">이를 복구 할 수 있지만 손상된 행의 모든 ​​행은 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="76fa6e08089d2d1626997ca7e237dcb75aacdc73" translate="yes" xml:space="preserve">
          <source>We can test log rotation by executing the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; utility with the &lt;code&gt;--force&lt;/code&gt; option. For example:</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 옵션 과 함께 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 유틸리티를 실행하여 로그 회전을 테스트 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6271a9af74547b86c8df476e9f80f42a0c73b6a" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;alice&lt;/code&gt; Unix user was properly mapped to the &lt;code&gt;dba&lt;/code&gt; MariaDB user by looking at the return values of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우리는 우리의 &lt;code&gt;alice&lt;/code&gt; Unix 사용자가 &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을보고 &lt;code&gt;dba&lt;/code&gt; MariaDB 사용자에 올바르게 매핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cffe1b5628fb21cdd9ed676611dd2fb557f4ef2" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;alice&lt;/code&gt; and &lt;code&gt;bob&lt;/code&gt; Unix users in the &lt;code&gt;dba&lt;/code&gt; Unix group were properly mapped to the &lt;code&gt;dba&lt;/code&gt; MariaDB user by looking at the return values of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을보고 &lt;code&gt;dba&lt;/code&gt; Unix 그룹 의 &lt;code&gt;alice&lt;/code&gt; 및 &lt;code&gt;bob&lt;/code&gt; Unix 사용자가 &lt;code&gt;dba&lt;/code&gt; MariaDB 사용자에 올바르게 맵핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3a36a629c3767fb2eb82ca336300d1a62e04462" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;foo&lt;/code&gt; LDAP user was properly mapped to the &lt;code&gt;bar&lt;/code&gt; MariaDB user by looking at the return value of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을보고 &lt;code&gt;foo&lt;/code&gt; LDAP 사용자가 &lt;code&gt;bar&lt;/code&gt; MariaDB 사용자에 올바르게 매핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17fae5389ae2b15851c1d6d7effda2aadd12c971" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;foo&lt;/code&gt; PAM user was properly mapped to the &lt;code&gt;bar&lt;/code&gt; MariaDB user by looking at the return value of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을보고 &lt;code&gt;foo&lt;/code&gt; PAM 사용자가 &lt;code&gt;bar&lt;/code&gt; MariaDB 사용자에 올바르게 매핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7241d189193b1b3e9d29fffa418b464a8512029d" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;foo&lt;/code&gt; Unix user was properly mapped to the &lt;code&gt;bar&lt;/code&gt; MariaDB user by looking at the return value of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을보고 &lt;code&gt;foo&lt;/code&gt; Unix 사용자가 &lt;code&gt;bar&lt;/code&gt; MariaDB 사용자에 올바르게 매핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1864b6b4951c34314775a96084c31667e8f83591" translate="yes" xml:space="preserve">
          <source>We can verify that our &lt;code&gt;gmontee&lt;/code&gt; and &lt;code&gt;bstillman&lt;/code&gt; LDAP users in the &lt;code&gt;dba&lt;/code&gt; LDAP group were properly mapped to the &lt;code&gt;dba&lt;/code&gt; MariaDB user by looking at the return values of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을 확인 하여 &lt;code&gt;dba&lt;/code&gt; LDAP 그룹 의 &lt;code&gt;gmontee&lt;/code&gt; 및 &lt;code&gt;bstillman&lt;/code&gt; LDAP 사용자가 &lt;code&gt;dba&lt;/code&gt; MariaDB 사용자에 올바르게 맵핑 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33659d1f5e516b4c9f0162ddd55062dcf04040e5" translate="yes" xml:space="preserve">
          <source>We chose among these columns the ones that were useful for our create statement, using the flag value when we gave them a different name (case insensitive).</source>
          <target state="translated">이 열들 중에서 다른 이름 (대소 문자 구분 안함)을 주었을 때 플래그 값을 사용하여 create 문에 유용한 열을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="7f87c8e200b19fc7b7e9866c2eb5ac65a149077b" translate="yes" xml:space="preserve">
          <source>We could do this without using window functions, as follows:</source>
          <target state="translated">다음과 같이 창 기능을 사용하지 않고도이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea7d267e4cb17c464cf19122321c9490c42bc5e2" translate="yes" xml:space="preserve">
          <source>We could use the new &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;engine-independent-table-statistics&lt;/a&gt; feature to get some data statistics.</source>
          <target state="translated">새로운 &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;엔진 독립 테이블 통계&lt;/a&gt; 기능을 사용하여 일부 데이터 통계를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b530e1c56229cb02879965250c187a772461a9d0" translate="yes" xml:space="preserve">
          <source>We currently have APT repositories for the following Linux distributions:</source>
          <target state="translated">현재 다음 Linux 배포판을위한 APT 리포지토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a37e3a0c73ba117df63eedf91ce6e735cc7708" translate="yes" xml:space="preserve">
          <source>We currently have YUM repositories for the following Linux distributions:</source>
          <target state="translated">현재 다음 Linux 배포판을위한 YUM 리포지토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="52ab917a6fb0e8eff3641544d62cf462fa5a8f2d" translate="yes" xml:space="preserve">
          <source>We currently have ZYpp repositories for the following Linux distributions:</source>
          <target state="translated">현재 다음 Linux 배포판을위한 ZYpp 리포지토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b15ccf50fdb528dfc8b9e382858d83556321c71" translate="yes" xml:space="preserve">
          <source>We do appreciate your effort to produce an efficient product with many engines capabilities, But in your web site communication , it is not obvious that all the soultions exposed ( in particular, ENGINES) are effective, anf it they are : on what OS can they be installed.</source>
          <target state="translated">많은 엔진 기능을 갖춘 효율적인 제품을 생산하려는 귀하의 노력에 감사드립니다. 그러나 귀하의 웹 사이트 통신에서 노출 된 모든 영혼 (특히 엔진)이 효과적이라는 것은 분명하지 않습니다. 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="4c7a380f25766424e6a0db3ad649d9c2a215b6f4" translate="yes" xml:space="preserve">
          <source>We do not want DirectAdmin's custombuild to remove/overwrite our MariaDB installation whenever an update is performed. To rectify this, disable automatic MySQL installation.</source>
          <target state="translated">DirectAdmin의 사용자 정의 빌드가 업데이트가 수행 될 때마다 MariaDB 설치를 제거 / 덮어 쓰기를 원하지 않습니다. 이를 수정하려면 자동 MySQL 설치를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="511d15672295a34847d1cd4195edab91dbe8bddc" translate="yes" xml:space="preserve">
          <source>We don't want to write the joins every time we need to access an actor's properties, so we&amp;rsquo;ll create a view:</source>
          <target state="translated">액터의 속성에 액세스해야 할 때마다 조인을 작성하고 싶지 않으므로 뷰를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d2a2122ecb022da30ec801d53510b0c4ea64f9ba" translate="yes" xml:space="preserve">
          <source>We get the result:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="272bb410ee3f2767270e0a175174364ea9f19a52" translate="yes" xml:space="preserve">
          <source>We got it.</source>
          <target state="translated">우리는 그것을 얻었다.</target>
        </trans-unit>
        <trans-unit id="94da4f629e45e57ab7b98a8f839e15a4ee37650a" translate="yes" xml:space="preserve">
          <source>We have 4 cores per backend and 2 backends .</source>
          <target state="translated">백엔드 당 4 개의 코어와 2 개의 백엔드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a70548a4f00b2dfd6aa6b0a60606795b69a328d" translate="yes" xml:space="preserve">
          <source>We have also provided the following workaround. This workaround is intended for adding columns to a table, one at a time only. Do not attempt to use it for any other purpose. Follow the example below as closely as possible.</source>
          <target state="translated">또한 다음 해결 방법을 제공했습니다. 이 해결 방법은 한 번에 하나씩 테이블에 열을 추가하기위한 것입니다. 다른 목적으로 사용하지 마십시오. 아래 예를 최대한 자세히 따르십시오.</target>
        </trans-unit>
        <trans-unit id="c67f440b6f9745d61bbdd1217c347e743627fd7c" translate="yes" xml:space="preserve">
          <source>We have defined two CONNECT special columns. You can give them any name; it is the field SPECIAL option that specifies the special column functional name.</source>
          <target state="translated">두 개의 CONNECT 특수 열을 정의했습니다. 당신은 그들에게 어떤 이름을 줄 수 있습니다; 특수 열 기능 이름을 지정하는 필드 SPECIAL 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="7a5691dc6549800fd9b0ac09e18beab5f71fd10f" translate="yes" xml:space="preserve">
          <source>We have no background search available in MariaDB. It won't be available before &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, but the next table definition mainly enables improving the performance of a single complex query plan with background search that can be found via the upstream spiral binaries MariaDB branch.</source>
          <target state="translated">MariaDB에는 백그라운드 검색이 없습니다. &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이전에는 사용할 수 없지만 다음 테이블 정의는 주로 업스트림 나선형 이진 MariaDB 분기를 통해 찾을 수있는 백그라운드 검색을 통해 단일 복합 쿼리 계획의 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183db040ec91657fe0a47db3e2397708c1d283a9" translate="yes" xml:space="preserve">
          <source>We have now figured out how to do the rollup, but have created another problem -- the counts are too low.</source>
          <target state="translated">이제 롤업을 수행하는 방법을 알아 냈지만 카운트가 너무 낮은 또 다른 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3cf99e5b9209054764fbac81061c0aa391c87221" translate="yes" xml:space="preserve">
          <source>We have now, by merely adding a few more conditions, eliminated all of the irrelevant information; Helmholtz was late to work on the 9th and the 12th of August.</source>
          <target state="translated">우리는 이제 몇 가지 조건을 추가함으로써 관련없는 정보를 모두 제거했습니다. 헬름홀츠는 8 월 9 일과 12 일 늦게까지 일했다.</target>
        </trans-unit>
        <trans-unit id="f57a9d23e85610ba5dd074080b037f9fc1ce4d9e" translate="yes" xml:space="preserve">
          <source>We have seen that json files can be formatted differently depending on the pretty option. In particular, big data files should be formatted with pretty equal to 0 when used by a CONNECT json table. The best and simplest way to convert a file from one format to another is to use the &lt;em&gt;Jfile_Make&lt;/em&gt; function. Indeed this function makes a file of specified format using the syntax:</source>
          <target state="translated">우리는 json 파일이 pretty 옵션에 따라 다르게 포맷 될 수 있음을 보았습니다. 특히, 빅 데이터 파일은 CONNECT json 테이블에서 사용될 때 0과 같은 형식으로 지정되어야합니다. 파일을 한 형식에서 다른 형식으로 변환하는 가장 &lt;em&gt;쉽고&lt;/em&gt; 간단한 방법은 &lt;em&gt;Jfile_Make&lt;/em&gt; 함수 를 사용하는 &lt;em&gt;것&lt;/em&gt; 입니다. 실제로이 함수는 다음 구문을 사용하여 지정된 형식의 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="985658f6e68c65764b04235e734e5b7a85db316a" translate="yes" xml:space="preserve">
          <source>We have seen that many json UDFs can have an additional argument not yet described. This is in the case where the json item argument was referring to a file. Then the additional integer argument is the pretty value of the json file. It matters only when the first argument is just a file name (to make the UDF understand this argument is a file name, it should be aliased with a name beginning with jfile_) or if the function modifies the file, in which case it will be rewritten with this pretty format.</source>
          <target state="translated">우리는 많은 json UDF가 아직 설명되지 않은 추가 인수를 가질 수 있음을 보았습니다. 이것은 json item 인수가 파일을 참조하는 경우입니다. 그런 다음 추가 정수 인수는 json 파일의 예쁜 값입니다. 첫 번째 인수가 파일 이름 일 때만 (UDF가이 인수가 파일 이름임을 이해하도록하기 위해, jfile_로 시작하는 이름으로 별명을 지정해야 함) 또는 함수가 파일을 수정하는 경우에만 중요합니다. 이 예쁜 형식으로 다시 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="e23e81e841f484e92e09b812a5dfafd577551ac6" translate="yes" xml:space="preserve">
          <source>We have seen that the most natural way to represent a table in a JSON file is to make it on an array of objects. However, other possibilities exist. A table can be an array of arrays, a one column table can be an array of values, or a one row table can be just one object or one value. One row tables are internally handled by adding a one value array around them.</source>
          <target state="translated">JSON 파일에서 테이블을 표현하는 가장 자연스러운 방법은 객체 배열에서 테이블을 만드는 것입니다. 그러나 다른 가능성이 존재합니다. 테이블은 배열의 배열이거나 하나의 열 테이블은 값의 배열이거나 하나의 행 테이블은 하나의 객체 또는 하나의 값일 수 있습니다. 하나의 행 테이블은 그 주위에 하나의 값 배열을 추가하여 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8cac3a0e0d27b4e51b582733949bcb8c714ac670" translate="yes" xml:space="preserve">
          <source>We install the binary with a symlink to the original name. This is done so that you can easily change MariaDB versions just by moving the symlink to point to another directory.</source>
          <target state="translated">바이너리를 원래 이름에 대한 심볼릭 링크로 설치합니다. 이는 symlink를 다른 디렉토리를 가리 키도록 이동하여 MariaDB 버전을 쉽게 변경할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7eeca466fa20e56950cf06ae4c329ad8be16be6" translate="yes" xml:space="preserve">
          <source>We know of three scenarios when dependencies were broken. The steps to fix each of them are pretty much the same, only the list of broken dependencies and hence the list of packages to take care of them differs. The basic idea is to downgrade those certain packages to 5.5.32 temporarily before upgrading them to 5.5.33a.</source>
          <target state="translated">의존성이 깨지는 세 가지 시나리오를 알고 있습니다. 각각을 수정하는 단계는 거의 동일하며, 깨진 종속성 목록 만 처리하므로이를 처리 할 패키지 목록이 다릅니다. 기본 아이디어는 특정 패키지를 5.5.33a로 업그레이드하기 전에 해당 패키지를 일시적으로 5.5.32로 다운 그레이드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40e7ff159238c94821db10cd630e0413aadc6ec8" translate="yes" xml:space="preserve">
          <source>We need to increase the concurrency to get better throughput.</source>
          <target state="translated">더 나은 처리량을 얻으려면 동시성을 증가시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="b0c1e610e5f50021c5058619ae1fb0b998b0914b" translate="yes" xml:space="preserve">
          <source>We now have a Customer Master Key and an IAM user that has privileges to access it using access credentials. This is enough to begin using the AWS KMS plugin.</source>
          <target state="translated">이제 액세스 자격 증명을 사용하여 액세스 할 수있는 권한이있는 고객 마스터 키와 IAM 사용자가 있습니다. 이것은 AWS KMS 플러그인 사용을 시작하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="7b403eabe6095eac8c4db346e4dd417116d0c967" translate="yes" xml:space="preserve">
          <source>We observe a common issue with partitioning is a non uniform distribution of data between the backends. based on the partition key hashing algorithm.</source>
          <target state="translated">파티셔닝의 일반적인 문제는 백엔드 간의 비 균일 한 데이터 분배입니다. 파티션 키 해싱 알고리즘을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="45c9c32f7c21259caf8312521fc9191926294658" translate="yes" xml:space="preserve">
          <source>We only write information about relay log positions for recovery if &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_recovery_update_relay_log&quot;&gt;innodb-recovery-update-relay-log&lt;/a&gt; is set.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_recovery_update_relay_log&quot;&gt;innodb-recovery-update-relay-log&lt;/a&gt; 가 설정된 경우 복구를위한 릴레이 로그 위치에 대한 정보 만 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="64d3621e3f5cb48f4a08ae12174827812006bc6b" translate="yes" xml:space="preserve">
          <source>We plan to also add CACHE INDEX for Aria tables if there is a need for this.</source>
          <target state="translated">필요한 경우 Aria 테이블에 CACHE INDEX를 추가 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="10f644979837cdc8da24701dc8d3195831658e4d" translate="yes" xml:space="preserve">
          <source>We should be done setting up the slave now, so we should check its status with &lt;code&gt;&lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">이제 슬레이브 설정을 완료 했으므로 &lt;code&gt;&lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt;&lt;/code&gt; 로 상태를 확인해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3bf188c2469f7cb536ee023a125045b388610fa" translate="yes" xml:space="preserve">
          <source>We should get an output similar to this one:</source>
          <target state="translated">다음과 비슷한 출력을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="9accd836701cd110dd541507c24f44ede9dc26fd" translate="yes" xml:space="preserve">
          <source>We store previous row combinations in a row buffer to be able to match each row against all of the rows combinations in the join buffer at one go.</source>
          <target state="translated">이전 행 조합을 행 버퍼에 저장하여 각 행을 조인 버퍼의 모든 행 조합에 대해 한 번에 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f3f43746741f661f9cbd04865a62760e3046cf" translate="yes" xml:space="preserve">
          <source>We strongly recommend you use either &lt;a href=&quot;../mysqld-options-full-list/index#-log-basename&quot;&gt;--log-basename&lt;/a&gt; or specify a filename to ensure that &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; doesn't stop if the hostname of the computer changes.</source>
          <target state="translated">컴퓨터의 호스트 이름이 변경 될 때 &lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; 가 중지되지 않도록 &lt;a href=&quot;../mysqld-options-full-list/index#-log-basename&quot;&gt;--log-basename&lt;/a&gt; 을 사용하거나 파일 이름을 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce0b59e645a155c868571ff8380c852caf567c6" translate="yes" xml:space="preserve">
          <source>We want to increment a counter each time a new animal is added. Here's what the trigger will look like:</source>
          <target state="translated">새 동물을 추가 할 때마다 카운터를 늘리고 싶습니다. 트리거는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41c0ef3d0b09a2852d248f8894a081676e9b33a2" translate="yes" xml:space="preserve">
          <source>We will also need to create the relevant directory:</source>
          <target state="translated">또한 관련 디렉토리를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="de3b79b8d5637dd9919082a826c4c4f5c0d2649e" translate="yes" xml:space="preserve">
          <source>We will also set the DN suffix for our backend LDAP database by changing the &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcSuffix:%20%3Cdn%20suffix%3E&quot;&gt;olcSuffix&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcSuffix:%20%3Cdn%20suffix%3E&quot;&gt;olcSuffix&lt;/a&gt;&lt;/code&gt; 지시문 을 변경하여 백엔드 LDAP 데이터베이스의 DN 접미사도 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c5946ee906014d1c6b0e7c69cc51e3b88ab4817" translate="yes" xml:space="preserve">
          <source>We will demonstrate the &lt;code&gt;LooseScan&lt;/code&gt; strategy by example. Suppose, we're looking for countries that have satellites. We can get them using the following query (for the sake of simplicity we ignore satellites that are owned by consortiums of multiple countries):</source>
          <target state="translated">예를 들어 &lt;code&gt;LooseScan&lt;/code&gt; 전략을 시연합니다 . 위성이있는 국가를 찾고 있다고 가정합니다. 우리는 다음 쿼리를 사용하여 그것들을 얻을 수 있습니다 (간단 성을 위해 여러 국가의 컨소시엄이 소유 한 위성을 무시합니다) :</target>
        </trans-unit>
        <trans-unit id="1a379f0368de2bef718eb5afeed01219a5209e81" translate="yes" xml:space="preserve">
          <source>We will get the following result:</source>
          <target state="translated">다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fc4b7eefe7a295e4fd41eaf9f8b6d20660b7dc3d" translate="yes" xml:space="preserve">
          <source>We will get the result:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db12991bfaf5762619e13362cbf9f9d840b88f7f" translate="yes" xml:space="preserve">
          <source>We will need to configure the following:</source>
          <target state="translated">다음을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b31c415198ca751a634361e5ba8a691377fedfac" translate="yes" xml:space="preserve">
          <source>We will now describe these two cases in detail</source>
          <target state="translated">이제이 두 경우를 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="935275cc2bd6c97c8b475521d80409d09c11e13a" translate="yes" xml:space="preserve">
          <source>We will still be able to drop a partition that does not contain the oldest data, but all rows stored in it will disappear.</source>
          <target state="translated">우리는 여전히 가장 오래된 데이터를 포함하지 않는 파티션을 삭제할 수 있지만 그 안에 저장된 모든 행은 사라집니다.</target>
        </trans-unit>
        <trans-unit id="e9aa6b8dbc9fddcda82d28e7cbd2832cd50e4fc8" translate="yes" xml:space="preserve">
          <source>We will use the new directory manager user to make changes to the LDAP directory after this step.</source>
          <target state="translated">이 단계 후에 새 디렉토리 관리자 사용자를 사용하여 LDAP 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b6d1f4a0cd85dfaaab070a162b84af2b6f0a4aa0" translate="yes" xml:space="preserve">
          <source>We've used a wrong datatype. Let's try again:</source>
          <target state="translated">잘못된 데이터 유형을 사용했습니다. 다시 해보자:</target>
        </trans-unit>
        <trans-unit id="19b9aed839fdc0b8e34fa816d1ce96fca21205f7" translate="yes" xml:space="preserve">
          <source>Web Log Articles</source>
          <target state="translated">웹 로그 기사</target>
        </trans-unit>
        <trans-unit id="a030328790b9cb1779d75cf7fba73d3951cfbac3" translate="yes" xml:space="preserve">
          <source>Web Server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a191d0d58c802e1847e1ca3cef6783f3d04cab0" translate="yes" xml:space="preserve">
          <source>Web-based MariaDB administration tool</source>
          <target state="translated">웹 기반 MariaDB 관리 도구</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="d8438ebbd38a31d82c0bafe39962906da2774450" translate="yes" xml:space="preserve">
          <source>Week 1 is the 1st week with</source>
          <target state="translated">1 주차는</target>
        </trans-unit>
        <trans-unit id="cec440d1628f020bb0b8f402c75681c0aa37da2a" translate="yes" xml:space="preserve">
          <source>Week number (00-53), when first day of the week is Monday.</source>
          <target state="translated">주의 첫 번째 요일이 월요일 인 주 번호 (00-53).</target>
        </trans-unit>
        <trans-unit id="58c7af327ff0f953345bb7097e76e9fe7fd52106" translate="yes" xml:space="preserve">
          <source>Week number (00-53), when first day of the week is Sunday.</source>
          <target state="translated">주의 첫 번째 요일이 일요일 인 주 번호 (00-53).</target>
        </trans-unit>
        <trans-unit id="1c559ff8ad68eb489cbdd8ec59bca049d737ab2a" translate="yes" xml:space="preserve">
          <source>Week number (01-53), when first day of the week is Monday. Used with %x.</source>
          <target state="translated">주의 첫 번째 요일이 월요일 인 주 번호 (01-53). % x와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d08c693fe25e28f6d14d683855335de1eaf0560" translate="yes" xml:space="preserve">
          <source>Week number (01-53), when first day of the week is Sunday. Used with %X.</source>
          <target state="translated">주의 첫 번째 요일이 일요일 인 주 번호 (01-53). % X와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="0ecb9501505d249251e2d360725deb31b7e967b6" translate="yes" xml:space="preserve">
          <source>Weight of the input string</source>
          <target state="translated">입력 문자열의 무게</target>
        </trans-unit>
        <trans-unit id="bf1b7e1520f0577a2e34f05cf41d1fe1eaafcc18" translate="yes" xml:space="preserve">
          <source>Weight of the input string.</source>
          <target state="translated">입력 문자열의 무게.</target>
        </trans-unit>
        <trans-unit id="0197fd3e7503f2d2f93daf963bde088a70fc7d34" translate="yes" xml:space="preserve">
          <source>Weighted Lists</source>
          <target state="translated">가중 목록</target>
        </trans-unit>
        <trans-unit id="ca4f9dcf204e2037bfe5884867bead98bd9cbaf8" translate="yes" xml:space="preserve">
          <source>Welcome</source>
          <target state="translated">Welcome</target>
        </trans-unit>
        <trans-unit id="fb68230bd921f3b6ee96c8610dc11eba1a8675f6" translate="yes" xml:space="preserve">
          <source>Well, I am fudging a little here. I have a PRIMARY KEY on `seq`, but that has no advantage on the query we are studying.</source>
          <target state="translated">글쎄, 나는 여기서 조금 헷갈 리고있다. `seq`에 PRIMARY KEY가 있지만 우리가 연구하는 쿼리에는 이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e2df08760137f884334f06be7e310ce3ea9bc57" translate="yes" xml:space="preserve">
          <source>Well-Known Binary (WKB) Format</source>
          <target state="translated">잘 알려진 이진 (WKB) 형식</target>
        </trans-unit>
        <trans-unit id="1bc765cd1ab2d96d94885115e5d83ae729468c9e" translate="yes" xml:space="preserve">
          <source>Well-Known Binary format for geometric data</source>
          <target state="translated">기하학적 데이터를위한 잘 알려진 이진 형식</target>
        </trans-unit>
        <trans-unit id="5568839f6e44b1904151d20e047c067a854aaca9" translate="yes" xml:space="preserve">
          <source>Well-Known Binary format for representing geometric data.</source>
          <target state="translated">기하 데이터를 나타내는 잘 알려진 이진 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5284031a38ef0aef2659c421707a8721622b5736" translate="yes" xml:space="preserve">
          <source>Well-Known Text for exchanging geometry data in ASCII form.</source>
          <target state="translated">ASCII 형식으로 지오메트리 데이터를 교환하기위한 잘 알려진 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="ca36e8a5ebc4aef75b6007293c3fd02c57c024df" translate="yes" xml:space="preserve">
          <source>Well-Known Text geometry representation</source>
          <target state="translated">잘 알려진 텍스트 형상 표현</target>
        </trans-unit>
        <trans-unit id="4b5e9188cdc0e3a1bbf41f1416e8c8f30dd9cc74" translate="yes" xml:space="preserve">
          <source>Wendy'S</source>
          <target state="translated">Wendy'S</target>
        </trans-unit>
        <trans-unit id="1f811c5f33fe4e38d07f2152ecc49a3ab2d119ec" translate="yes" xml:space="preserve">
          <source>West 57 Street</source>
          <target state="translated">웨스트 57 스트리트</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="282a24d712111c438b432d83a619487f52dd9e7b" translate="yes" xml:space="preserve">
          <source>What Are Character Sets and Collations</source>
          <target state="translated">문자 집합 및 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="e7490103d4c3ea51ab2990d30f25922fe22d0a9b" translate="yes" xml:space="preserve">
          <source>What You Need to Know</source>
          <target state="translated">당신이 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="4e5d0d17a463b02a3695151d14d93a05b0491bcb" translate="yes" xml:space="preserve">
          <source>What about CQL?</source>
          <target state="translated">CQL은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="d17ee8c6bed04a6b38f99a2fdc0cb2a9aad6eb10" translate="yes" xml:space="preserve">
          <source>What about Grants on shards?</source>
          <target state="translated">샤드에 대한 보조금은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="9412dab5bdcd87d245ea61e79f013b040733c0d5" translate="yes" xml:space="preserve">
          <source>What about MariaDB Upgrades ?</source>
          <target state="translated">MariaDB 업그레이드는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="ab8808fad5a58f2ad2af117fbaf1ed0fe4e5f747" translate="yes" xml:space="preserve">
          <source>What about autocommit = 1? wsrep_retry_autocommit tells Galera to retry if a single statement that is autocommited N times. So, there is still a chance (very slim) of getting a deadlock on such a statement. The default setting of &quot;1&quot; retry is probably good.</source>
          <target state="translated">자동 커밋 = 1은 어떻습니까? wsrep_retry_autocommit은 Galera에게 N 번 자동 커밋 된 단일 명령문이 있으면 다시 시도하도록 지시합니다. 따라서 그러한 성명서에서 교착 상태에 빠질 가능성은 여전히 ​​있습니다 (매우 슬림합니다). &quot;1&quot;의 기본 설정은 재 시도 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="756183f8d60c0f5b6b91c7ac4a85657546552ebe" translate="yes" xml:space="preserve">
          <source>What about the use of alias.</source>
          <target state="translated">별명 사용은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="0ad1d1cc03624b7244c5cb6ff18584c25186050f" translate="yes" xml:space="preserve">
          <source>What are the advantages/disadvantages of the new &lt;code&gt;PAGE&lt;/code&gt; format compared to the old MyISAM-like row formats (&lt;code&gt;DYNAMIC&lt;/code&gt; and &lt;code&gt;FIXED&lt;/code&gt;)</source>
          <target state="translated">기존 MyISAM 유사 행 형식 ( &lt;code&gt;DYNAMIC&lt;/code&gt; 및 &lt;code&gt;FIXED&lt;/code&gt; ) 과 비교 하여 새 &lt;code&gt;PAGE&lt;/code&gt; 형식 의 장점 / 단점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="c24b5fbf225333e6971057f7da712dd5818621f9" translate="yes" xml:space="preserve">
          <source>What are the design goals in Aria?</source>
          <target state="translated">Aria의 디자인 목표는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="40d3a77aab7cc9f540ed2d331f4a9c02223ada60" translate="yes" xml:space="preserve">
          <source>What are the known problems with the MySQL-5.1-Maria release?</source>
          <target state="translated">MySQL-5.1-Maria 릴리스의 알려진 문제점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8f48047ed9cd72cffb7a9dd79082aa256eb5cc42" translate="yes" xml:space="preserve">
          <source>What are the most used architectures for Spider HA?</source>
          <target state="translated">Spider HA에 가장 많이 사용되는 아키텍처는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="573584fdeefefb3a0a424fe74466035057c19f11" translate="yes" xml:space="preserve">
          <source>What are the most used architectures for Spider Map Reduce?</source>
          <target state="translated">Spider Map Reduce에 가장 많이 사용되는 아키텍처는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="14176a87c1b93d6d16ac548a044f0fa3bef0aa67" translate="yes" xml:space="preserve">
          <source>What are the plans for FederatedX?</source>
          <target state="translated">FederatedX에 대한 계획은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bf292a12941d9eb1188f07521a28d333e82efd25" translate="yes" xml:space="preserve">
          <source>What does &quot;[ERROR] mysqld: Can't find record in 'spider_tables'&quot; mean?</source>
          <target state="translated">&quot;[ERROR] mysqld : 'spider_tables'에서 레코드를 찾을 수 없습니다&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="047d32998785d019db790f2a30b8d23fc985d9ba" translate="yes" xml:space="preserve">
          <source>What does &quot;select spider_ping_table()&quot; in the general log mean?</source>
          <target state="translated">일반 로그에서 &quot;select spider_ping_table ()&quot;은 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="d0e52182c5c640b3acec23251c22d9845409211b" translate="yes" xml:space="preserve">
          <source>What happened here? First of all, unlike Oracle &amp;ldquo;dual&amp;rdquo; tableS that have no columns, a MariaDB table must have at least one column. By default, CONNECT creates VIR tables with one special column. This can be seen with the SHOW CREATE TABLE statement:</source>
          <target state="translated">여기 뭔 일 있었 니? 우선, 열이없는 Oracle &quot;이중&quot;테이블과 달리 MariaDB 테이블에는 하나 이상의 열이 있어야합니다. 기본적으로 CONNECT는 하나의 특수 열이있는 VIR 테이블을 작성합니다. 이것은 SHOW CREATE TABLE 문으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab69e108adaf0b0c5f83e372850364c4ab63d72c" translate="yes" xml:space="preserve">
          <source>What happened here? Simply, because we used the &lt;em&gt;xsamp&lt;/em&gt; table to do the Insert, what has been inserted within the XML file had the structure described for &lt;em&gt;xsamp&lt;/em&gt;:</source>
          <target state="translated">여기 뭔 일 있었 니? 간단히 &lt;em&gt;xsamp&lt;/em&gt; 테이블을 사용하여 Insert를 수행 &lt;em&gt;했으므로&lt;/em&gt; XML 파일에 삽입 된 내용은 &lt;em&gt;xsamp에&lt;/em&gt; 대해 설명 된 구조 &lt;em&gt;를가집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4bed61dc050ab283284efd1b5a067990495988e2" translate="yes" xml:space="preserve">
          <source>What happens if it is not recognized as such? These functions are declared as returning a string and to take care of this, the returned structure begins with a zero-terminated string. For instance:</source>
          <target state="translated">그렇게 인식되지 않으면 어떻게됩니까? 이러한 함수는 문자열을 반환하는 것으로 선언되며이를 처리하기 위해 반환 된 구조는 0으로 끝나는 문자열로 시작합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8727dd551e8075b34136a766441edbc0075c4b64" translate="yes" xml:space="preserve">
          <source>What happens if the &lt;code&gt;RETURN&lt;/code&gt; clause returns a value of a different type? It depends on the &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; in effect at the moment of the function creation.</source>
          <target state="translated">&lt;code&gt;RETURN&lt;/code&gt; 절이 다른 유형의 값을 리턴 하면 어떻게됩니까 ? 함수 작성시 유효한 &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3a4c78f5de84bda1149829a740b171d33036a3b3" translate="yes" xml:space="preserve">
          <source>What happens if we populate it by?</source>
          <target state="translated">우리가 그것을 채우면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="37eb3107bd53c2448690fa6206888bab2fe05eed" translate="yes" xml:space="preserve">
          <source>What he describes is known as MED (Management of External Data) enabling the handling of data not stored in a DBMS database as if it were stored in tables. An ISO standard exists that describes one way to implement and use MED in SQL by defining foreign tables for which an external FDW (Foreign Data Wrapper) has been developed in C.</source>
          <target state="translated">그가 설명하는 것은 MED (Management of External Data)로 알려져 있으며 마치 테이블에 저장된 것처럼 DBMS 데이터베이스에 저장되지 않은 데이터를 처리 할 수 ​​있습니다. C에서 외부 FDW (Foreign Data Wrapper)가 개발 된 외부 테이블을 정의하여 SQL에서 MED를 구현하고 사용하는 한 가지 방법을 설명하는 ISO 표준이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6a34fec94c7babf23ee0d02914268058ea43d19c" translate="yes" xml:space="preserve">
          <source>What if a table contains several multiple nodes</source>
          <target state="translated">테이블에 여러 개의 여러 노드가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="585215004974f2693477d4e575ffd4b31adf40b1" translate="yes" xml:space="preserve">
          <source>What if someone else inserts before I select my id?</source>
          <target state="translated">내 아이디를 선택하기 전에 다른 사람이 삽입하면 어떻게 되나요?</target>
        </trans-unit>
        <trans-unit id="e9d3f991ac0e5e900240e2c4a356811a4d32e4ec" translate="yes" xml:space="preserve">
          <source>What if there are exactly 10 rows left when you display the current page? It would make the UI nice if you grayed out the [Next] button, wouldn't it. (Or you could suppress the button all together.)</source>
          <target state="translated">현재 페이지를 표시 할 때 정확히 10 개의 행이 남아 있으면 어떻게됩니까? [Next] 버튼을 회색으로 표시하면 UI가 좋을 것입니다. (또는 버튼을 함께 억제 할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="33bdf09992e5442e02bdf5c2d03a7ccf06b7fe3b" translate="yes" xml:space="preserve">
          <source>What if there are extra fields on the the end? Answer: Minimal harm; possibly a lot of good (eg, 'covering').</source>
          <target state="translated">끝에 추가 필드가 있으면 어떻게됩니까? 답변 : 최소한의 피해; 아마도 많은 좋은 것 (예를 들어, '피복').</target>
        </trans-unit>
        <trans-unit id="1e64e971b0851c916a43478eee5d33d09a58fa66" translate="yes" xml:space="preserve">
          <source>What if you are looking for Starbucks in a dense city? There would be dozens, maybe hundreds per square mile. If you start the guess at 100 miles, the SELECTs would be hitting lots of blocks -- not efficient. In this case, the &quot;starting distance&quot; should be small, say, 2 miles. Let's say your app wants the closest 10 stores. In this example, you would probably find more than 10 Starbucks within 2 miles in 1 InnoDB block in one partition. Even though there is a second SELECT to finish off the query, it would be hitting the same block. Total: One block hit == cheap.</source>
          <target state="translated">울창한 도시에서 스타 벅스를 찾고 있다면 어떨까요? 평방 마일 당 수십, 아마도 수백이있을 것입니다. 100 마일에서 추측을 시작하면 SELECT가 효율적이지 않은 많은 블록에 도달합니다. 이 경우 &quot;시작 거리&quot;는 2 마일이어야합니다. 앱이 가장 가까운 10 개의 매장을 원한다고 가정 해 보겠습니다. 이 예에서는 한 파티션의 1 InnoDB 블록에서 2 마일 이내에 10 개 이상의 스타벅을 찾을 수 있습니다. 쿼리를 끝내는 두 번째 SELECT가 있어도 동일한 블록에 도달합니다. 전체 : 한 블록 적중 == 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="4305a8216c9aeff1cbe127641009959864157d22" translate="yes" xml:space="preserve">
          <source>What index(es) would be best for that question? More specifically, what would be best for</source>
          <target state="translated">해당 질문에 가장 적합한 인덱스는 무엇입니까? 보다 구체적으로는</target>
        </trans-unit>
        <trans-unit id="3b7bfd0eccdfef86cd6b7e09c6cc916638e43a6b" translate="yes" xml:space="preserve">
          <source>What is Aria?</source>
          <target state="translated">아리아 란?</target>
        </trans-unit>
        <trans-unit id="779da4d54bbe681f81239308a01bc5398ff59ab1" translate="yes" xml:space="preserve">
          <source>What is Lost</source>
          <target state="translated">잃어버린 것</target>
        </trans-unit>
        <trans-unit id="ee638d01e3508b13c2c6757fa796986820e3c06d" translate="yes" xml:space="preserve">
          <source>What is MariaDB 10.1</source>
          <target state="translated">MariaDB 10.1이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="766f93bc9eb3dbf92c49a76499c40a901b975f09" translate="yes" xml:space="preserve">
          <source>What is MariaDB 5.3</source>
          <target state="translated">MariaDB 5.3이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="3ad23e8d4b216685ce4d1bcb6505160bfa7428b9" translate="yes" xml:space="preserve">
          <source>What is MariaDB Galera Cluster?</source>
          <target state="translated">MariaDB Galera Cluster 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cf2c0a9eb678556a134b878b6d2b046d39efaca7" translate="yes" xml:space="preserve">
          <source>What is Table Elimination?</source>
          <target state="translated">테이블 제거 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6c215d90eff7e724cd7d19e0e4b30cb995b54d44" translate="yes" xml:space="preserve">
          <source>What is a semi-join subquery</source>
          <target state="translated">semi-join 하위 쿼리 란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="7ed92122d864eab22c90818649175eb3ce0729f5" translate="yes" xml:space="preserve">
          <source>What is an Index?</source>
          <target state="translated">인덱스 란?</target>
        </trans-unit>
        <trans-unit id="367c60c6088add7e8003f1f3ca575d5a83566137" translate="yes" xml:space="preserve">
          <source>What is going to change in later Aria main releases?</source>
          <target state="translated">이후 Aria 메인 릴리스에서 무엇이 변경됩니까?</target>
        </trans-unit>
        <trans-unit id="005952ada534b6c1118c4b898a141f3e258653bb" translate="yes" xml:space="preserve">
          <source>What is happening if we stop one backend?</source>
          <target state="translated">백엔드 하나를 중지하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="0c76066088facd9001ad281ecb78f8cebb6c887e" translate="yes" xml:space="preserve">
          <source>What is the Buffer Pool?</source>
          <target state="translated">버퍼 풀은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d01be2130b1bea35f228ff9208cfd9f63b31c257" translate="yes" xml:space="preserve">
          <source>What is the FederatedX storage engine?</source>
          <target state="translated">FederatedX 스토리지 엔진은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4b2ff7c4b835207e797b9b306e3e21df4e878828" translate="yes" xml:space="preserve">
          <source>What is the Key Buffer?</source>
          <target state="translated">키 버퍼 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dba73046af6243f1075764847b23a61cb5da668f" translate="yes" xml:space="preserve">
          <source>What is the release policy/schedule of Aria?</source>
          <target state="translated">Aria의 출시 정책 / 일정은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d7b6f5f407fd0a03aadc7f561139e723cbc70ca7" translate="yes" xml:space="preserve">
          <source>What is the ultimate goal of Aria?</source>
          <target state="translated">아리아의 궁극적 인 목표는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d4fc7093d4000ddf9e34d8a33fdab2588dba93c4" translate="yes" xml:space="preserve">
          <source>What it Looks Like</source>
          <target state="translated">모양</target>
        </trans-unit>
        <trans-unit id="8ec8fdb49eb9dc90083aee4948cd5f654d37ef4f" translate="yes" xml:space="preserve">
          <source>What it did is just to replace the local table name with the remote table name and change all the back ticks to blanks or to the data source identifier quoting characters if QUOTED is specified. Then this command will be sent to the data source to be executed by it.</source>
          <target state="translated">QUOTED가 지정된 경우 로컬 테이블 이름을 원격 테이블 이름으로 바꾸고 모든 백틱을 공백 또는 데이터 소스 ID 인용 문자로 변경하면됩니다. 그런 다음이 명령은 데이터 소스로 전송되어 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49eeb15b0d2523b116e27f0e842580f564a494b2" translate="yes" xml:space="preserve">
          <source>What kind of &lt;code&gt;SELECT&lt;/code&gt; the table comes from.</source>
          <target state="translated">테이블은 어떤 종류의 &lt;code&gt;SELECT&lt;/code&gt; 에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d0d7b8d8aee4909a0c80df557e38f925eb13700" translate="yes" xml:space="preserve">
          <source>What kind of interfaces does Shard-Query have</source>
          <target state="translated">샤드 쿼리에는 어떤 종류의 인터페이스가 있습니까?</target>
        </trans-unit>
        <trans-unit id="2160f54fd3d995c4ab50716d7277eacdbc14dfbf" translate="yes" xml:space="preserve">
          <source>What kind of queries are supported?</source>
          <target state="translated">어떤 종류의 쿼리가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="3e3aae5ea0a7088f583bd2e1edf04beb73fa946d" translate="yes" xml:space="preserve">
          <source>What must be understood here is that the Update modifies node values in the XML file, not cell values in the relational table. The first update worked normally. The second update changed the year value of the book and this shows for the two expanded rows because there is only one DATEPUB node for that book. Because the third update applies to a row having a certain date value, both author names were updated.</source>
          <target state="translated">여기서 이해해야 할 것은 업데이트가 관계형 테이블의 셀 값이 아니라 XML 파일의 노드 값을 수정한다는 것입니다. 첫 번째 업데이트는 정상적으로 작동했습니다. 두 번째 업데이트는 책의 연도 값을 변경했으며 해당 책에 대해 하나의 DATEPUB 노드 만 있기 때문에 확장 된 두 행에 대해 표시됩니다. 세 번째 업데이트는 특정 날짜 값을 가진 행에 적용되므로 두 작성자 이름이 모두 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="a82433bc5d56bbac672ea9708c79c663bd729c75" translate="yes" xml:space="preserve">
          <source>What should you do? If you think the &quot;little filtering&quot; is likely, then create an index with the ORDER BY columns in order and hope that the Optimizer uses it when it should.</source>
          <target state="translated">어떻게해야합니까? &quot;작은 필터링&quot;이 가능하다고 생각되면 ORDER BY 열을 순서대로 사용하여 인덱스를 작성하고 Optimizer가 필요할 때이를 사용하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="490ee31a4a79f6c237b1c40156c7890375494419" translate="yes" xml:space="preserve">
          <source>What the routine returns.</source>
          <target state="translated">루틴이 리턴하는 것.</target>
        </trans-unit>
        <trans-unit id="fc8893ec0c1c71ed7442b6484d1c985aaf955d8d" translate="yes" xml:space="preserve">
          <source>What these mean...</source>
          <target state="translated">이것이 의미하는 것은 ...</target>
        </trans-unit>
        <trans-unit id="48fc9c8bd51f1cbc8d1ab066256d6bff4d5ec7fd" translate="yes" xml:space="preserve">
          <source>What to Do Next</source>
          <target state="translated">다음에 무엇을할지</target>
        </trans-unit>
        <trans-unit id="5640688a2d5da4e675b1f12efc633c605f80f6eb" translate="yes" xml:space="preserve">
          <source>What to Do if MariaDB Doesn&amp;#x27;t Start</source>
          <target state="translated">MariaDB가 시작되지 않으면해야 할 일</target>
        </trans-unit>
        <trans-unit id="7d816c2948bd502e78e0741c66fdb7c6f60ddf20" translate="yes" xml:space="preserve">
          <source>What to Do if MariaDB Doesn't Start</source>
          <target state="translated">MariaDB가 시작되지 않으면해야 할 일</target>
        </trans-unit>
        <trans-unit id="49354299cdb3dbf76e2b670c33efe524c8f4fa62" translate="yes" xml:space="preserve">
          <source>What to Do?</source>
          <target state="translated">무엇을해야합니까?</target>
        </trans-unit>
        <trans-unit id="30bb98bf7c73bd5767a2210ee109a693656f123c" translate="yes" xml:space="preserve">
          <source>What to Encrypt?</source>
          <target state="translated">무엇을 암호화해야합니까?</target>
        </trans-unit>
        <trans-unit id="298f4be800457b6be2789c448f0b155ec920044e" translate="yes" xml:space="preserve">
          <source>What to PARTITION on? It seems like latitude or longitude would be a good idea. Note that longitudes vary in width, from 69 miles (111 km) at the equator, to 0 at the poles. So, latitude seems like a better choice.</source>
          <target state="translated">무엇을 참여해야합니까? 위도 또는 경도가 좋은 생각 인 것 같습니다. 경도는 적도에서 69 마일 (111km)에서 극점까지 0까지 다양합니다. 따라서 위도가 더 나은 선택 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="405dfeaed53d58d7b9354776b66d3c4dd2aec9fd" translate="yes" xml:space="preserve">
          <source>What to log and what not to log</source>
          <target state="translated">무엇을 기록하고 기록하지 않을 것</target>
        </trans-unit>
        <trans-unit id="385663660024249a4e20d98a8124bab5205dd47d" translate="yes" xml:space="preserve">
          <source>What to sort by (aa, ae, al, ar, at, a, c, e, l, r, t). &lt;code&gt;at&lt;/code&gt; is default.</source>
          <target state="translated">정렬 기준 (aa, ae, al, ar, at, a, c, e, l, r, t). &lt;code&gt;at&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9f8efd7e144172ffbcb99cebb7965c62b8933c01" translate="yes" xml:space="preserve">
          <source>What would happen if you shuffled the fields in the INDEX? Answer: It may make a huge difference. More in a minute.</source>
          <target state="translated">INDEX의 필드를 섞으면 어떻게됩니까? 답변 : 큰 차이가있을 수 있습니다. 1 분만에 더.</target>
        </trans-unit>
        <trans-unit id="6d39730c1678358642d44b805777e8ded2f22db9" translate="yes" xml:space="preserve">
          <source>What would happen if you shuffled the fields in the WHERE clause? Answer: The order of ANDed things does not matter.</source>
          <target state="translated">WHERE 절의 필드를 섞으면 어떻게됩니까? 답 : AND의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e2ac1c7abf98db3eccac590c71f9afd57a8d019" translate="yes" xml:space="preserve">
          <source>What you need to know</source>
          <target state="translated">당신이 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="e58cf0407b75ec67ea9b2e8262f1ec12b6094466" translate="yes" xml:space="preserve">
          <source>What's the goal for the current version?</source>
          <target state="translated">현재 버전의 목표는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ffdb0196a350e04f026a4f5293134b08cac3a034" translate="yes" xml:space="preserve">
          <source>What's the goal for the next version?</source>
          <target state="translated">다음 버전의 목표는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="85c4be5545d90764e015e2af5de53204fbc4b5c8" translate="yes" xml:space="preserve">
          <source>What's the proper way to copy a Aria table from one place to another?</source>
          <target state="translated">한 곳에서 다른 곳으로 Aria 테이블을 복사하는 올바른 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8dff52906e3d7b90d7240dc7c937777c2a2742d7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#gtid_strict_mode&quot;&gt;GTID strict mode&lt;/a&gt; is enabled (by setting &lt;code&gt;@@GLOBAL.gtid_strict_mode&lt;/code&gt; to 1), it is normally best to use &lt;code&gt;current_pos&lt;/code&gt;. In strict mode, extra transactions on the master are disallowed.</source>
          <target state="translated">때 &lt;a href=&quot;#gtid_strict_mode&quot;&gt;GTID 엄격 모드&lt;/a&gt; (설정하여 사용할 수 있습니다 &lt;code&gt;@@GLOBAL.gtid_strict_mode&lt;/code&gt; 1), 그것은 사용에 일반적으로 가장 좋습니다 &lt;code&gt;current_pos&lt;/code&gt; . 엄격 모드에서는 마스터의 추가 트랜잭션이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c71d47ac9b934538524afcaaa9c98bdeb91271ec" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../aria-encryption/index&quot;&gt;encrypting Aria tables&lt;/a&gt;, the key that is used to encrypt tables &lt;a href=&quot;../aria-encryption-keys/index&quot;&gt;cannot currently be changed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../aria-encryption/index&quot;&gt;Aria 테이블을 암호화&lt;/a&gt; 할 때는 테이블 을 암호화하는 데 사용되는 키를 &lt;a href=&quot;../aria-encryption-keys/index&quot;&gt;현재 변경할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e1f9833617ed6ef9474f25a3878b135ea9da35d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../compiling-mariadb-from-source/index&quot;&gt;compiling MariaDB from source&lt;/a&gt;, the AWS Key Management plugin is not built by default in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, but it is built by default in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and later, on systems that support it.</source>
          <target state="translated">&lt;a href=&quot;../compiling-mariadb-from-source/index&quot;&gt;source&lt;/a&gt; 에서 MariaDB를 컴파일 할 때 AWS Key Management 플러그인은 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 에서 기본적으로 빌드되지 않지만이 를 지원하는 시스템 에서 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2 이상&lt;/a&gt; 에서 기본적으로 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="58a5a88e191877b8f89f7b82a241ba642dcfd4e0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../encryption-key-management/index#key-rotation&quot;&gt;rotating encryption keys&lt;/a&gt;, InnoDB's background encryption threads re-encrypt pages that use key versions older than &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; to the new key version.</source>
          <target state="translated">&lt;a href=&quot;../encryption-key-management/index#key-rotation&quot;&gt;암호화 키를 회전&lt;/a&gt; 할 때 InnoDB의 백그라운드 암호화 스레드는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; 이전의 키 버전을 사용하는 페이지를 새 키 버전으로 다시 암호화합니다 .</target>
        </trans-unit>
        <trans-unit id="fe2f6b8a76d34448ff3aa5e6128e86ea76373e74" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../innodb-encryption/index&quot;&gt;encrypting InnoDB tables&lt;/a&gt;, the key that is used to encrypt tables &lt;a href=&quot;../innodb-xtradb-encryption-keys/index&quot;&gt;can be changed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../innodb-encryption/index&quot;&gt;InnoDB 테이블을 암호화&lt;/a&gt; 할 때 테이블 을 암호화하는 데 사용되는 키를 &lt;a href=&quot;../innodb-xtradb-encryption-keys/index&quot;&gt;변경할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb92596f158dc464f75e466cd6719b25cacc084" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt; is in use, each independent replication connection has its own slave threads of each type.</source>
          <target state="translated">때 &lt;a href=&quot;../multi-source-replication/index&quot;&gt;멀티 소스 복제를&lt;/a&gt; 사용하고, 각각의 독립적 인 복제 연결은 각 유형의 자체 슬레이브 스레드를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="93397e90fcd6eb89a4e824f5b395bba3fb7a87b3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is in use, then the SQL thread hands off the events to its worker threads to apply in parallel.</source>
          <target state="translated">시 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제가&lt;/a&gt; 사용하고, 다음의 작업자 스레드에 이벤트 오프 SQL 쓰레드 손을 병렬로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="996ceff93926db34e2f33d822df504181260be8c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../replication/index&quot;&gt;MariaDB replication&lt;/a&gt; is used with &lt;a href=&quot;../galera/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt;, see &lt;a href=&quot;../using-mariadb-replication-with-mariadb-galera-cluster-using-mariadb-replica/index#setting-server_id-on-cluster-nodes&quot;&gt;Using MariaDB Replication with MariaDB Galera Cluster: Setting server_id on Cluster Nodes&lt;/a&gt; for more information on how to set the &lt;code&gt;server_id&lt;/code&gt; values.</source>
          <target state="translated">때 &lt;a href=&quot;../replication/index&quot;&gt;MariaDB 복제가&lt;/a&gt; 사용됩니다 &lt;a href=&quot;../galera/index&quot;&gt;MariaDB 갈레 클러스터&lt;/a&gt; 를 참조 &lt;a href=&quot;../using-mariadb-replication-with-mariadb-galera-cluster-using-mariadb-replica/index#setting-server_id-on-cluster-nodes&quot;&gt;MariaDB 갈레 클러스터와 MariaDB 복제 사용 : 클러스터 노드에 SERVER_ID 설정&lt;/a&gt; 설정된하는 방법에 대한 자세한 내용은 &lt;code&gt;server_id&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="26cbb555489378184e4e9bfde4c0520a9d941508" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../replication/index&quot;&gt;MariaDB replication&lt;/a&gt; is used with standalone MariaDB Server, each server in the replication topology must have a unique &lt;code&gt;server_id&lt;/code&gt; value.</source>
          <target state="translated">때 &lt;a href=&quot;../replication/index&quot;&gt;MariaDB 복제가&lt;/a&gt; 독립 MariaDB 서버와 함께 사용, 복제 토폴로지의 각 서버는 고유해야합니다 &lt;code&gt;server_id&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="aada4a6fe22d089b6a2ea0130bcd466196099de5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;semisynchronous replication&lt;/a&gt; is enabled, semisynchronous slaves send acknowledgements (ACKs) to their master confirm that they have received some transaction. The master creates an ACK receiver thread to receive these ACKs.</source>
          <target state="translated">반 &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;동기식 복제&lt;/a&gt; 가 활성화되면 반 동기식 슬레이브가 ACK (승인)를 마스터에게 보내 트랜잭션이 수신되었음을 확인합니다. 마스터는 이러한 ACK를 수신하기 위해 ACK 수신자 스레드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ee34a9354bf9cce9b7ad189fe63b953026203ac4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode&lt;/a&gt; is set to &lt;code&gt;0&lt;/code&gt;, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; uses the traditional lock mode.</source>
          <target state="translated">때 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode가&lt;/a&gt; 설정되어 &lt;code&gt;0&lt;/code&gt; , &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB는&lt;/a&gt; 기존의 잠금 모드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf92fb5bdd4b6dc2e42c804ceffa51c058803ea9" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode&lt;/a&gt; is set to &lt;code&gt;1&lt;/code&gt;, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; uses the consecutive lock mode.</source>
          <target state="translated">때 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode가&lt;/a&gt; 설정되어 &lt;code&gt;1&lt;/code&gt; , &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB는&lt;/a&gt; 연속 잠금 모드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0537ad31287fb34382911aef4ebf52e3fa9b4ec1" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode&lt;/a&gt; is set to &lt;code&gt;2&lt;/code&gt;, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; uses the interleaved lock mode.</source>
          <target state="translated">경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_autoinc_lock_mode&quot;&gt;innodb_autoinc_lock_mode가&lt;/a&gt; 설정되어 &lt;code&gt;2&lt;/code&gt; , &lt;a href=&quot;../innodb/index&quot;&gt;이노가&lt;/a&gt; 인터리빙 잠금 모드를 사용한다.</target>
        </trans-unit>
        <trans-unit id="227c1e9324bd771ef45a6c4cae7f070e043c3844" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; is set, the &lt;code&gt;#sql-*.ibd&lt;/code&gt; file will also be visible in the database directory.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; 이 설정 되면 # sql- &lt;code&gt;#sql-*.ibd&lt;/code&gt; 파일도 데이터베이스 디렉토리에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e64dd1b65dafe9e1e8eeaca262b335de6c074d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_mode&quot;&gt;wsrep_gtid_mode&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, &lt;code&gt;wsrep_gtid_domain_id&lt;/code&gt; is simply ignored to allow for backward compatibility.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_mode&quot;&gt;wsrep_gtid_mode&lt;/a&gt;&lt;/code&gt; 가 설정되어 &lt;code&gt;OFF&lt;/code&gt; , &lt;code&gt;wsrep_gtid_domain_id&lt;/code&gt; 는 단순히 이전 버전과의 호환성을 위해 수 있도록 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f823d7a8d5b8d0ad0894602fe3189c5ea68e7d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_mode&quot;&gt;wsrep_gtid_mode&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt;, &lt;code&gt;wsrep_gtid_domain_id&lt;/code&gt; is used in place of &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; for all Galera Cluster write sets.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_mode&quot;&gt;wsrep_gtid_mode&lt;/a&gt;&lt;/code&gt; 가 설정되어 &lt;code&gt;ON&lt;/code&gt; , &lt;code&gt;wsrep_gtid_domain_id&lt;/code&gt; 는 대신에 사용되는 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 모든 갈레 클러스터 쓰기 세트.</target>
        </trans-unit>
        <trans-unit id="311470e7fd5d9e6c9bbcfb409feff74ab9a680b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;FORCE&lt;/code&gt;, InnoDB tables are automatically encrypted by default, and unencrypted InnoDB tables can &lt;strong&gt;not&lt;/strong&gt; be created. In this scenario, if you set the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;NO&lt;/code&gt; for a table, then you will encounter an error. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;FORCE&lt;/code&gt; 로 설정 되면 기본적으로 InnoDB 테이블이 자동으로 암호화되며 암호화되지 않은 InnoDB 테이블을 작성할 수 &lt;strong&gt;없습니다&lt;/strong&gt; . 이 시나리오에서 테이블에 대해 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;NO&lt;/code&gt; 로 설정 하면 오류가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89ceb705397797727cf9b2af1ac5658052a6fb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;FORCE&lt;/code&gt;, then you must ensure that &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; is set to a non-zero value, so that InnoDB can perform any necessary encryption operations in the background. See &lt;a href=&quot;../innodb-background-encryption-threads/index#background-operations&quot;&gt;background operations&lt;/a&gt; for more information about that. &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; must also be set to a non-zero value for the initial encryption operations to happen in the background. See &lt;a href=&quot;../innodb-background-encryption-threads/index#disabling-background-key-rotation-operations&quot;&gt;disabling key rotations&lt;/a&gt; for more information about that.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 가 설정되어 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;FORCE&lt;/code&gt; , 당신은 있는지 확인해야합니다 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 이 InnoDB의 백그라운드에서 필요한 암호화 작업을 수행 할 수 있습니다 그래서, 0이 아닌 값으로 설정됩니다. 이에 대한 자세한 정보는 &lt;a href=&quot;../innodb-background-encryption-threads/index#background-operations&quot;&gt;백그라운드 조작&lt;/a&gt; 을 참조하십시오 . 초기 암호화 작업이 백그라운드에서 발생하도록 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; 도 0이 아닌 값으로 설정해야합니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../innodb-background-encryption-threads/index#disabling-background-key-rotation-operations&quot;&gt;키 회전 비활성화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd3c906f504c183f68a2828f7a7df91a975df847" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt;, InnoDB tables are automatically encrypted by default. For example, the following statements create an encrypted table and confirm that it is encrypted:</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 가 설정되어 &lt;code&gt;ON&lt;/code&gt; , InnoDB의 테이블은 기본적으로 자동 암호화됩니다. 예를 들어, 다음 명령문은 암호화 된 테이블을 작성하고 암호화 된 테이블임을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="815db540b467fb38f6b2cee26d05f648a0213234" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt;, an unencrypted InnoDB table can be created by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;NO&lt;/code&gt; for the table. For example, the following statements create an unencrypted table and confirm that it is not encrypted:</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 가 설정되어 &lt;code&gt;ON&lt;/code&gt; , 암호화되지 않은 InnoDB의 테이블은 설정하여 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 의 표 옵션 &lt;code&gt;NO&lt;/code&gt; 테이블에 대한합니다. 예를 들어, 다음 명령문은 암호화되지 않은 테이블을 작성하고 암호화되지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9a7ad23881148204958adc24946c2ecc71b73623" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=ON&lt;/a&gt;&lt;/code&gt; is set, InnoDB uses one tablespace file per InnoDB table. These tablespace files have the &lt;code&gt;.ibd&lt;/code&gt; extension. When &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=OFF&lt;/a&gt;&lt;/code&gt; is set, InnoDB stores all tables in the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB system tablespace&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=ON&lt;/a&gt;&lt;/code&gt; 으로 설정되어, InnoDB는 InnoDB의 테이블 당 하나 개의 테이블 스페이스 파일을 사용합니다. 이 테이블 스페이스 파일의 확장자 는 &lt;code&gt;.ibd&lt;/code&gt; 입니다. 되면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=OFF&lt;/a&gt;&lt;/code&gt; 설정되고, 이노은 모든 테이블 기억 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;이노 시스템을 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5a84dc727950882520594affd38bf213b4bcf51" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; is set, MariaDB essentially does the following operations:</source>
          <target state="translated">때 &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; 가 설정되어, MariaDB는 기본적으로 다음과 같은 작업을 수행합니다</target>
        </trans-unit>
        <trans-unit id="f7493093a13580e0df76d7b0c4bc92721f2ab96a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALGORITHM=INPLACE&lt;/code&gt; is set, the underlying storage engine uses optimizations to perform the operation while avoiding the table copy and rebuild. However, &lt;code&gt;INPLACE&lt;/code&gt; is a bit of a misnomer, since some operations may still require the table to be rebuilt for some storage engines. Regardless, several operations can be performed without a full copy of the table for some storage engines.</source>
          <target state="translated">경우 &lt;code&gt;ALGORITHM=INPLACE&lt;/code&gt; 가 설정되고, 기본 스토리지 엔진 용도 최적화 테이블 복사를 방지하면서 작업을 수행하고 재 구축한다. 그러나 일부 작업에서는 일부 스토리지 엔진에 대해 테이블을 다시 작성해야 할 수도 있기 때문에 &lt;code&gt;INPLACE&lt;/code&gt; 는 약간 잘못된 것입니다. 그럼에도 불구하고 일부 스토리지 엔진에 대한 전체 테이블 사본없이 여러 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="621cb14657c237228ee1d990c2910044372449e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;EXTRACTVALUE()&lt;/code&gt; returns multiple matches, it returns the content of the first child text node of each matching element, in the matched order, as a single, space-delimited string.</source>
          <target state="translated">경우 &lt;code&gt;EXTRACTVALUE()&lt;/code&gt; 멀티 매치를 반환, 단일 공간으로 구분 된 문자열로 검색된 순서대로 각 매칭 소자의 제 자식 텍스트 노드의 콘텐츠를 반환한다.</target>
        </trans-unit>
        <trans-unit id="d4f2ca9cd87d1a3a8ad5314e6ab603278977d45d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;IF EXISTS&lt;/code&gt; and &lt;code&gt;IF NOT EXISTS&lt;/code&gt; are used in clauses, queries will not report errors when the condition is triggered for that clause. A warning with the same message text will be issued and the ALTER will move on to the next clause in the statement (or end if finished).</source>
          <target state="translated">때 &lt;code&gt;IF EXISTS&lt;/code&gt; 하고 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 조항에서 사용되는 조건이이 절에 대한 트리거 될 때, 쿼리가 오류를보고하지 않습니다. 동일한 메시지 텍스트가있는 경고가 발행되고 ALTER는 명령문의 다음 절로 넘어갑니다 (또는 완료되면 종료).</target>
        </trans-unit>
        <trans-unit id="69c56efdfa586187782b437edd9b8f63fcd61340" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; is specified in a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statement, MariaDB will wait until all transactions that have modified the rows are committed. Then, a write lock is acquired. All transactions can read the rows, but if they want to modify them, they have to wait until your transaction is committed.</source>
          <target state="translated">때 &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; 는 A의 지정된 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문 행을 수정 한 모든 트랜잭션이 커밋 될 때까지, MariaDB는 기다립니다. 그리고, 쓰기 잠금이 획득된다. 모든 트랜잭션은 행을 읽을 수 있지만 행을 수정하려면 트랜잭션이 커밋 될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="63485168bf73c9db939c6ce46671e365a31bbf39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;conn1&lt;/code&gt; runs through the &lt;code&gt;INSERT&lt;/code&gt; statement, it hits the sync point &lt;code&gt;'after_open_tables'&lt;/code&gt;. It notices that it is active and executes its action. It emits the signal &lt;code&gt;'opened'&lt;/code&gt; and waits for another thread to emit the signal &lt;code&gt;'flushed'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;conn1&lt;/code&gt; 이 &lt;code&gt;INSERT&lt;/code&gt; 문을 통해 실행될 때 동기 점 &lt;code&gt;'after_open_tables'&lt;/code&gt; 에 도달 합니다. 활성 상태임을 확인하고 해당 작업을 실행합니다. 그것은 &lt;code&gt;'opened'&lt;/code&gt; 신호를 방출하고 다른 thread가 &lt;code&gt;'flushed'&lt;/code&gt; 신호를 방출하기를 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="2d83a0df38838a518a8d28113af2900940fb87c7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;conn2&lt;/code&gt; reaches &lt;code&gt;'after_abort_locks'&lt;/code&gt;, it signals &lt;code&gt;'flushed'&lt;/code&gt;, which lets &lt;code&gt;conn1&lt;/code&gt; awake.</source>
          <target state="translated">경우 &lt;code&gt;conn2&lt;/code&gt; 도달 &lt;code&gt;'after_abort_locks'&lt;/code&gt; 는 ,이 신호를 &lt;code&gt;'flushed'&lt;/code&gt; 수있는 &lt;code&gt;conn1&lt;/code&gt; 이라는 웨이크.</target>
        </trans-unit>
        <trans-unit id="9e726e647d571515d4f28f36f1c3ffd3dc4a8f00" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;log_bin_trust_function_creators&lt;/code&gt; is &lt;code&gt;OFF&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#log_bin&quot;&gt;log_bin&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;ON&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../alter-function/index&quot;&gt;ALTER FUNCTION&lt;/a&gt;&lt;/code&gt; statements will trigger an error if the function is defined with any of the &lt;code&gt;NOT DETERMINISTIC&lt;/code&gt;, &lt;code&gt;CONTAINS SQL&lt;/code&gt; or &lt;code&gt;MODIFIES SQL DATA&lt;/code&gt; characteristics.</source>
          <target state="translated">때 &lt;code&gt;log_bin_trust_function_creators&lt;/code&gt; 있다 &lt;code&gt;OFF&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#log_bin&quot;&gt;log_bin&lt;/a&gt;&lt;/code&gt; 가 있다 &lt;code&gt;ON&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../alter-function/index&quot;&gt;ALTER FUNCTION&lt;/a&gt;&lt;/code&gt; 함수가 어떤 정의 된 경우 문이 오류를 트리거 &lt;code&gt;NOT DETERMINISTIC&lt;/code&gt; , &lt;code&gt;CONTAINS SQL&lt;/code&gt; 또는 &lt;code&gt;MODIFIES SQL DATA&lt;/code&gt; 특성을.</target>
        </trans-unit>
        <trans-unit id="3e704154c27ea5ca209f409576ff33befbdf7136" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;log_bin_trust_function_creators&lt;/code&gt; is &lt;code&gt;OFF&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#log_bin&quot;&gt;log_bin&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;ON&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege is also required to execute the following statements:</source>
          <target state="translated">때 &lt;code&gt;log_bin_trust_function_creators&lt;/code&gt; 있다 &lt;code&gt;OFF&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#log_bin&quot;&gt;log_bin&lt;/a&gt;&lt;/code&gt; 가 있다 &lt;code&gt;ON&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 의 권한은 또한 다음 문을 실행하는 데 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="fbcf2075e463af3eae47c4add0bbaf63f8c41f23" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mysqld_safe&lt;/code&gt; starts &lt;code&gt;mysqld&lt;/code&gt;, it also uses this option to set the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#open_files_limit&quot;&gt;open_files_limit&lt;/a&gt;&lt;/code&gt; system variable for &lt;code&gt;mysqld&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;mysqld_safe&lt;/code&gt; 시작 &lt;code&gt;mysqld&lt;/code&gt; 를을 , 또한 값으로 설정하려면이 옵션을 사용 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#open_files_limit&quot;&gt;open_files_limit&lt;/a&gt;&lt;/code&gt; 에 대한 시스템 변수 &lt;code&gt;mysqld&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="4aad156bb8f8379e4eff61a3593dd2cae9bdb45f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wsrep_gtid_mode&lt;/code&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_domain_id&quot;&gt;wsrep_gtid_domain_id&lt;/a&gt;&lt;/code&gt; is simply ignored to allow for backward compatibility.</source>
          <target state="translated">때 &lt;code&gt;wsrep_gtid_mode&lt;/code&gt; 가 설정되어 &lt;code&gt;OFF&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_domain_id&quot;&gt;wsrep_gtid_domain_id&lt;/a&gt;&lt;/code&gt; 는 단순히 이전 버전과의 호환성을 위해 수 있도록 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="63a9fabdcc9fe359413ca9774efae5e2c309842e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wsrep_gtid_mode&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_domain_id&quot;&gt;wsrep_gtid_domain_id&lt;/a&gt;&lt;/code&gt; is used in place of &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; for all Galera Cluster write sets.</source>
          <target state="translated">때 &lt;code&gt;wsrep_gtid_mode&lt;/code&gt; 가 설정되어 &lt;code&gt;ON&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#wsrep_gtid_domain_id&quot;&gt;wsrep_gtid_domain_id&lt;/a&gt;&lt;/code&gt; 는 대신에 사용되는 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 모든 갈레 클러스터 쓰기 세트.</target>
        </trans-unit>
        <trans-unit id="76dbade0cf5eebb82d20c015ff639d854b7077b6" translate="yes" xml:space="preserve">
          <source>When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, the statements CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can be executed in a non-transactional context only, and require that AUTOCOMMIT = 1.</source>
          <target state="translated">@@ GLOBAL.ENFORCE_GTID_CONSISTENCY = 1 인 경우 CREATE TEMPORARY TABLE 및 DROP TEMPORARY TABLE 문은 비 트랜잭션 컨텍스트에서만 실행될 수 있으며 AUTOCOMMIT = 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="89978c41d74520cc464cd2aedc169ec3f88941a9" translate="yes" xml:space="preserve">
          <source>When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.</source>
          <target state="translated">@@ GLOBAL.ENFORCE_GTID_CONSISTENCY = 1 인 경우 비 트랜잭션 테이블에 대한 업데이트는 자동 커미트 된 명령문 또는 단일 명령문 트랜잭션에서만 수행 할 수 있으며 트랜잭션 테이블에 대한 업데이트와 동일한 명령문에서는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52964febad7944dece018c7344897169f294d450" translate="yes" xml:space="preserve">
          <source>When @@SESSION.GTID_NEXT is set to a GTID, you must explicitly set it to a different value after a COMMIT or ROLLBACK. Please check GTID_NEXT variable manual page for detailed explanation. Current @@SESSION.GTID_NEXT is '%s'.</source>
          <target state="translated">@@ SESSION.GTID_NEXT가 GTID로 설정되면 COMMIT 또는 ROLLBACK 후에 명시 적으로 다른 값으로 설정해야합니다. 자세한 설명은 GTID_NEXT 변수 매뉴얼 페이지를 확인하십시오. 현재 @@ SESSION.GTID_NEXT는 '% s'입니다.</target>
        </trans-unit>
        <trans-unit id="9d55107c904c91f3e5eb582e4ad3e993d0ef05fd" translate="yes" xml:space="preserve">
          <source>When CALLing a procedure</source>
          <target state="translated">절차를 호출 할 때</target>
        </trans-unit>
        <trans-unit id="acfcae8c4ed90419817c4910b94ace5dc062e16f" translate="yes" xml:space="preserve">
          <source>When CMake runs through the tests again, it should now find the packages it needs, instead of the cache telling it they're unavailable.</source>
          <target state="translated">CMake가 테스트를 다시 실행하면 캐시에서 사용할 수 없음을 알리는 대신 필요한 패키지를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="20573c7c21ce31ceba240bbbd92f149a17578a07" translate="yes" xml:space="preserve">
          <source>When Does Encryption Help to Protect Your Data?</source>
          <target state="translated">암호화는 언제 데이터를 보호하는 데 도움이됩니까?</target>
        </trans-unit>
        <trans-unit id="a7ca74ec244d540573f5f671747981e02de1f124" translate="yes" xml:space="preserve">
          <source>When FETCH is issued and there are no more rows to extract, the following error is produced:</source>
          <target state="translated">FETCH가 발행되고 추출 할 행이 더 이상 없으면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03228d36c1d51462a8f7d3c3206e6b86d37bd60f" translate="yes" xml:space="preserve">
          <source>When GTID strict mode is enabled, some additional errors are enabled for situations that could otherwise cause differences between binlogs on different servers in a replication hierarchy:</source>
          <target state="translated">GTID 엄격 모드가 사용 가능한 경우 복제 계층 구조에서 다른 서버의 binlog간에 차이가 발생할 수있는 상황에서 일부 추가 오류가 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7f3393f6e21aa9e03cefd4b1161d2062ec142164" translate="yes" xml:space="preserve">
          <source>When GTID strict mode is enabled, the slave will stop with an error when a problem is encountered. This allows the DBA to become aware of the problem and take corrective actions to avoid similar issues in the future. One way to recover from such an error is to temporarily disable GTID strict mode on the offending slave, to be able to replicate past the problem point (perhaps using &lt;code&gt;START SLAVE UNTIL master_gtid_pos=XXX&lt;/code&gt;).</source>
          <target state="translated">GTID 엄격 모드가 활성화되면 문제가 발생하면 슬레이브가 오류와 함께 중지됩니다. 이를 통해 DBA는 문제점을 인식하고 향후 유사한 문제점을 피하기 위해 정정 조치를 취할 수 있습니다. 이러한 오류를 복구하는 한 가지 방법은 문제가있는 슬레이브에서 GTID 엄격 모드를 일시적으로 비활성화하고 문제 지점을지나 복제 할 수있는 것입니다 (아마도 &lt;code&gt;START SLAVE UNTIL master_gtid_pos=XXX&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="556b869757cfce33a6cf28b982cb746a236b46b2" translate="yes" xml:space="preserve">
          <source>When Galera is enabled, MariaDB's &lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; service automatically runs the &lt;code&gt;galera_recovery&lt;/code&gt; script prior to starting MariaDB, so that MariaDB starts with the proper Galera position.</source>
          <target state="translated">Galera가 활성화되면 MariaDB의 &lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; 서비스는 MariaDB를 시작하기 전에 &lt;code&gt;galera_recovery&lt;/code&gt; 스크립트를 자동으로 실행하여 MariaDB가 적절한 Galera 위치로 시작되도록합니다.</target>
        </trans-unit>
        <trans-unit id="36af333ea912fd8c180dc68905dc9aaf2a889306" translate="yes" xml:space="preserve">
          <source>When HWM is 0 the DATA_SIZE will show 0 instead of 8192 to avoid confusion when there is multiple segments in an extent file</source>
          <target state="translated">HWM이 0 인 경우 익스텐트 파일에 여러 세그먼트가있을 때 혼동을 피하기 위해 DATA_SIZE는 8192 대신 0을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7407a5c2339d92045c8dc743f8a246b58d7fd634" translate="yes" xml:space="preserve">
          <source>When Index Condition Pushdown is used, EXPLAIN will show &quot;Using index condition&quot;:</source>
          <target state="translated">인덱스 조건 푸시 다운을 사용하면 EXPLAIN에 &quot;인덱스 조건 사용&quot;이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c02af5b751b86dc704c0a3585ebc6ae097dfeca" translate="yes" xml:space="preserve">
          <source>When InnoDB needs to store general information relating to the system as a whole, rather than a specific table, the specific file it writes to is the system tablespace. By default, this is the &lt;code&gt;ibdata1&lt;/code&gt; file located in the data directory, (as defined by either the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_home_dir&quot;&gt;innodb_data_home_dir&lt;/a&gt;&lt;/code&gt; system variables). InnoDB uses the system tablespace to store the data dictionary, change buffer, and undo logs.</source>
          <target state="translated">InnoDB가 시스템과 관련된 일반 정보를 특정 테이블이 아닌 전체로 저장해야하는 경우, 파일에 기록하는 특정 파일은 시스템 테이블 스페이스입니다. 기본적 &lt;code&gt;ibdata1&lt;/code&gt; 파일은 데이터 디렉토리에 있는 ibdata1 파일입니다 ( &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_home_dir&quot;&gt;innodb_data_home_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수 로 정의 됨 ). InnoDB는 시스템 테이블 스페이스를 사용하여 데이터 사전, 변경 버퍼 및 실행 취소 로그를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="266765b4be2f4db0bda560023353a7d097e85c30" translate="yes" xml:space="preserve">
          <source>When InnoDB page compression is used, InnoDB may still write the compressed page to the tablespace file with the original size of the uncompressed page, which would be equivalent to the value of the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; system variable. This is done by design, because when InnoDB's I/O code needs to read the page from disk, it can only read the full page size. However, this is obviously not optimal.</source>
          <target state="translated">InnoDB 페이지 압축을 사용하는 경우 InnoDB는 압축되지 않은 페이지의 원래 크기로 압축 된 페이지를 테이블 스페이스 파일에 쓸 수 있으며 이는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값과 같습니다 . 이는 InnoDB의 I / O 코드가 디스크에서 페이지를 읽어야 할 때 전체 페이지 크기 만 읽을 수 있기 때문에 의도적으로 설계된 것입니다. 그러나 이것은 분명히 최적이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ead8de61221b872e66544d85737ce74508c82c6" translate="yes" xml:space="preserve">
          <source>When InnoDB performs a checkpoint, it writes the LSN of the oldest dirty page in the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;InnoDB buffer pool&lt;/a&gt; to the InnoDB redo log. If a page is the oldest dirty page in the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;InnoDB buffer pool&lt;/a&gt;, then that means that all pages with lower LSNs have been flushed to the physical InnoDB tablespace files. If the server were to crash, then InnoDB would perform crash recovery by only applying log records with LSNs that are greater than or equal to the LSN of the oldest dirty page written in the last checkpoint.</source>
          <target state="translated">InnoDB는 검사 점을 수행 할 때 InnoDB &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;버퍼 풀&lt;/a&gt; 에서 가장 오래된 더티 페이지의 LSN을 InnoDB 리두 로그에 기록합니다. 페이지가 &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;InnoDB 버퍼 풀&lt;/a&gt; 에서 가장 오래된 더티 페이지 인 경우 LSN이 낮은 모든 페이지가 실제 InnoDB 테이블 스페이스 파일로 플러시되었음을 의미합니다. 서버가 중단되면 InnoDB는 마지막 검사 점에 기록 된 가장 오래된 더티 페이지의 LSN보다 크거나 같은 LSN이있는 로그 레코드 만 적용하여 응급 복구를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="429b21d20f17254008e8194ee3a889fa9be4dbbf" translate="yes" xml:space="preserve">
          <source>When Innodb writes to the filesystem, there is generally no guarantee that a given write operation will be complete (not partial) in cases of a poweroff event, or if the operating system crashes at the exact moment a write is being done.</source>
          <target state="translated">Innodb가 파일 시스템에 쓸 때, 일반적으로 전원이 꺼진 상황에서 또는 쓰기가 수행되는 순간 운영 체제가 충돌하는 경우 주어진 쓰기 작업이 부분적으로 수행되지 않는다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="866021f185f04287d80f6e8cac979dfd3c67d624" translate="yes" xml:space="preserve">
          <source>When MRR is used for &lt;code&gt;range&lt;/code&gt; access, the size of its buffer is controlled by the &lt;a href=&quot;../server-system-variables/index#mrr_buffer_size&quot;&gt;mrr_buffer_size&lt;/a&gt; system variable. Its value specifies how much space can be used for each table. For example, if there is a query which is a 10-way join and MRR is used for each table, &lt;code&gt;10*@@mrr_buffer_size&lt;/code&gt; bytes may be used.</source>
          <target state="translated">MRR이 &lt;code&gt;range&lt;/code&gt; 액세스에 사용될 때 , 버퍼 크기는 &lt;a href=&quot;../server-system-variables/index#mrr_buffer_size&quot;&gt;mrr_buffer_size&lt;/a&gt; 시스템 변수에 의해 제어됩니다 . 이 값은 각 테이블에 사용할 수있는 공간을 지정합니다. 예를 들어, 10-way 조인 인 쿼리가 있고 각 테이블에 MRR이 사용되는 경우 &lt;code&gt;10*@@mrr_buffer_size&lt;/code&gt; 바이트가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4995037f4b59c3d6153d6fed92015e358875b106" translate="yes" xml:space="preserve">
          <source>When MariaDB Platform X3 is deployed for HTAP, web and mobile services send queries to MariaDB MaxScale. In turn, MaxScale distributes these queries according to their purpose, transactional queries are sent to MariaDB Servers for OLTP workloads, and analytical queries are sent to MariaDB ColumnStore for OLAP operations.</source>
          <target state="translated">MariaDB 플랫폼 X3이 HTAP 용으로 배포되면 웹 및 모바일 서비스가 MariaDB MaxScale에 쿼리를 보냅니다. 또한 MaxScale은 목적에 따라 이러한 쿼리를 배포하고 OLTP 작업을 위해 트랜잭션 쿼리를 MariaDB 서버로 보내고 OLAP 작업을 위해 분석 쿼리를 MariaDB ColumnStore로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c8ccb306f73586a91f245af26a1ed3d954b881d9" translate="yes" xml:space="preserve">
          <source>When MariaDB Server creates a new instance, it prints a message like the following to the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt;:</source>
          <target state="translated">MariaDB 서버는 새 인스턴스를 만들 때 다음과 같은 메시지를 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="68c919628375955660b6ac80db6af86eecfbf75e" translate="yes" xml:space="preserve">
          <source>When MariaDB Server is compiled with TLS and cryptography support, it is usually either statically linked with MariaDB's bundled TLS and cryptography library or dynamically linked with the system's &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; library. MariaDB's bundled TLS library is either &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; or &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt;, depending on the server version.</source>
          <target state="translated">MariaDB 서버가 TLS 및 암호화 지원으로 컴파일되면 일반적으로 MariaDB의 번들 TLS 및 암호화 라이브러리와 정적으로 연결되거나 시스템의 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 라이브러리 와 동적으로 연결됩니다 . MariaDB의 번들 TLS 라이브러리는 서버 버전에 따라 &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; 또는 &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9459823c32087e282b271c8260aee31f08e6eb7a" translate="yes" xml:space="preserve">
          <source>When MariaDB Servers run as replication slaves, they replicate data through client connections with the master server. In order for these servers to establish client connections, create a replication user on the master server, &lt;code&gt;Server-1&lt;/code&gt;, and grant the user the relevant privileges to retrieve the data.</source>
          <target state="translated">MariaDB 서버가 복제 슬레이브로 실행될 때 마스터 서버와의 클라이언트 연결을 통해 데이터를 복제합니다. 이러한 서버가 클라이언트 연결을 설정하려면 마스터 서버 &lt;code&gt;Server-1&lt;/code&gt; 에서 복제 사용자를 작성하고 사용자 에게 데이터를 검색 할 관련 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="b0838681a68937337bf32fe563e11e8aa75feb80" translate="yes" xml:space="preserve">
          <source>When MariaDB executes a &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; statement, it removes the row:</source>
          <target state="translated">MariaDB가 &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; 문을 실행할 때 행을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="92390a65b2473cfc5b3f59385e839bc172fce56b" translate="yes" xml:space="preserve">
          <source>When MariaDB executes the &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, it converts the data from the older temporal format to the newer one.</source>
          <target state="translated">MariaDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문을 실행할 때 데이터를 이전 시간 형식에서 최신 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c5a0dc78fd8c06290c1861dfba0e9e526baa6aa7" translate="yes" xml:space="preserve">
          <source>When MariaDB is compiled with TLS and cryptography support, it is usually either statically linked with MariaDB's bundled TLS and cryptography library, which might be &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; or &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt;, or dynamically linked with the system's TLS and cryptography library, which might be &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt;, &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;GnuTLS&lt;/a&gt;, or &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/secauthn/secure-channel&quot;&gt;Schannel&lt;/a&gt;.</source>
          <target state="translated">MariaDB가 TLS 및 암호화 지원으로 컴파일되면 일반적으로 MariaDB의 번들 TLS 및 암호화 라이브러리 ( &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; 또는 &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt; 일 수 있음)와 정적으로 연결 되거나 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; , &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;GnuTLS&lt;/a&gt; 또는 시스템의 TLS 및 암호화 라이브러리와 동적으로 연결됩니다. &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/secauthn/secure-channel&quot;&gt;Schannel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80fb5ee94a17eacc8d11a3646e460013d57123aa" translate="yes" xml:space="preserve">
          <source>When MariaDB is started with the &lt;code&gt;systemd&lt;/code&gt; unit file, it directly starts the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; process as the &lt;code&gt;mysql&lt;/code&gt; user. Unlike with &lt;code&gt;&lt;a href=&quot;../sysvinit/index&quot;&gt;sysVinit&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; process is not started with &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt;&lt;/code&gt;. As a consequence, options will not be read from the &lt;code&gt;[mysqld_safe]&lt;/code&gt;&lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; from &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option files&lt;/a&gt;.</source>
          <target state="translated">MariaDB가 시작되면 &lt;code&gt;systemd&lt;/code&gt; 유닛 파일, 그것은 바로 시작 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 는 AS 처리 &lt;code&gt;mysql&lt;/code&gt; 사용자. 와 달리 &lt;code&gt;&lt;a href=&quot;../sysvinit/index&quot;&gt;sysVinit&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 프로세스가 시작되지 &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt;&lt;/code&gt; 에 . 결과적으로 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 &lt;code&gt;[mysqld_safe]&lt;/code&gt; &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 옵션을 읽을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="944da663bf1a71d40cba6eb74c342eebf2c40179" translate="yes" xml:space="preserve">
          <source>When Mariabackup encounters a query that sets a global lock, it can kill the query in order to free up MariaDB Server for the backup. Using this option, you can choose the types of query it kills: &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt;, or both set with &lt;code&gt;ALL&lt;/code&gt;. The default is &lt;code&gt;ALL&lt;/code&gt;.</source>
          <target state="translated">Mariabackup에서 전역 잠금을 설정하는 쿼리가 발생하면 MariaDB 서버를 백업용으로 확보하기 위해 쿼리를 종료 할 수 있습니다. :이 옵션을 사용하여, 당신은 그것을 죽이고 쿼리의 유형을 선택할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; , 또는으로 두 세트 &lt;code&gt;ALL&lt;/code&gt; . 기본값은 &lt;code&gt;ALL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c7ed3f8de3260dab3852a1b051d04071041417a" translate="yes" xml:space="preserve">
          <source>When Mariabackup restores a database, it preserves the file and directory privileges of the backup. However, it writes the files to disk as the user and group restoring the database. As such, after restoring a backup, you may need to adjust the owner of the data directory to match the user and group for the MariaDB Server, typically &lt;code&gt;mysql&lt;/code&gt; for both. For example, to recursively change ownership of the files to the &lt;code&gt;mysql&lt;/code&gt; user and group, you could execute:</source>
          <target state="translated">Mariabackup은 데이터베이스를 복원 할 때 백업의 파일 및 디렉토리 권한을 유지합니다. 그러나 데이터베이스를 복원하는 사용자 및 그룹으로 파일을 디스크에 씁니다. 따라서 백업을 복원 한 후 MariaDB 서버의 사용자 및 그룹 (일반적으로 둘 다의 &lt;code&gt;mysql&lt;/code&gt; ) 과 일치하도록 데이터 디렉토리의 소유자를 조정해야 할 수도 있습니다 . 예를 들어, 파일 소유권을 &lt;code&gt;mysql&lt;/code&gt; 사용자 및 그룹 으로 재귀 적으로 변경하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08dc8727f255092a70078178a0f2506beb62fde" translate="yes" xml:space="preserve">
          <source>When Mariabackup runs it connects to the specified MariaDB Server to get its backups. Using this option, you can define the database user uses for authentication.</source>
          <target state="translated">Mariabackup이 실행될 때 지정된 MariaDB 서버에 연결하여 백업을 가져옵니다. 이 옵션을 사용하면 인증에 사용하는 데이터베이스 사용자를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f8ff63456d9a12faba3a2e35c4dc85edc35ade" translate="yes" xml:space="preserve">
          <source>When Mariabackup runs, it issues a &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; statement. It then identifies blocking queries. Using this option you can set a timeout in seconds for these blocking queries. When the time runs out, Mariabackup kills the queries.</source>
          <target state="translated">Mariabackup이 실행될 때 &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 문을 발행합니다 . 그런 다음 차단 쿼리를 식별합니다. 이 옵션을 사용하면 이러한 차단 쿼리에 대한 시간 초과를 초 단위로 설정할 수 있습니다. 시간이 지나면 Mariabackup이 쿼리를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="cb974706bd14febe8d14398ff91ed94c8fd28200" translate="yes" xml:space="preserve">
          <source>When Mariabackup runs, it issues a global lock to prevent data from changing during the backup process and ensure a consistent record. If it encounters statements still in the process of executing, it waits until they complete before setting the lock. Using this option, you can set the number of seconds it waits, to prevent long-running queries from blocking the backup process. The default value is 0, which indicates that Mariabackup does not wait for queries to complete.</source>
          <target state="translated">Mariabackup이 실행되면 백업 프로세스 중에 데이터가 변경되는 것을 방지하고 일관된 레코드를 보장하기 위해 전역 잠금을 발행합니다. 실행 프로세스에서 여전히 명령문이 발생하면 잠금을 설정하기 전에 명령문이 완료 될 때까지 기다립니다. 이 옵션을 사용하면 오래 실행되는 쿼리가 백업 프로세스를 차단하지 않도록 대기하는 시간 (초)을 설정할 수 있습니다. 기본값은 0이며, 이는 Mariabackup이 쿼리가 완료되기를 기다리지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bd865ecb72bc6528e8a323fe93bc55257b897aa" translate="yes" xml:space="preserve">
          <source>When Mariabackup runs, it issues a global lock to prevent data from changing during the backup process and ensure a consistent record. If it encounters statements still in the process of executing, it waits until they complete before setting the lock. Using this option, you can set the threshold at which Mariabackup engages FTWRL. When it &lt;code&gt;&lt;a href=&quot;#-ftwrl-wait-timeout&quot;&gt;--ftwrl-wait-timeout&lt;/a&gt;&lt;/code&gt; is not 0 and a statement has run for at least the amount of time given this argument, Mariabackup waits until the statement completes or until the &lt;code&gt;&lt;a href=&quot;#-ftwrl-wait-timeout&quot;&gt;--ftwrl-wait-timeout&lt;/a&gt;&lt;/code&gt; expires before setting the global lock and starting the backup.</source>
          <target state="translated">Mariabackup이 실행되면 백업 프로세스 중에 데이터가 변경되는 것을 방지하고 일관된 레코드를 보장하기 위해 전역 잠금을 발행합니다. 실행 프로세스에서 여전히 명령문이 발생하면 잠금을 설정하기 전에 명령문이 완료 될 때까지 기다립니다. 이 옵션을 사용하면 Mariabackup이 FTWRL을 사용하는 임계 값을 설정할 수 있습니다. 이 때 &lt;code&gt;&lt;a href=&quot;#-ftwrl-wait-timeout&quot;&gt;--ftwrl-wait-timeout&lt;/a&gt;&lt;/code&gt; 0이와 성명이 인수를 주어진 시간의 최소 금액 동안 실행, Mariabackup은 문이 완료 될 때까지 대기하거나 때까지 &lt;code&gt;&lt;a href=&quot;#-ftwrl-wait-timeout&quot;&gt;--ftwrl-wait-timeout&lt;/a&gt;&lt;/code&gt; 글로벌 잠금을 설정하기 전에 만료 백업을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="16350843df5bb6e6010f1e4096beeb46566fd471" translate="yes" xml:space="preserve">
          <source>When Mariabackup runs, it issues a global lock to prevent data from changing during the backup process. When it encounters a statement in the process of executing, it waits until the statement is finished before issuing the global lock. Using this option, you can modify this default behavior to ensure that it waits only for certain query types, such as for &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">Mariabackup이 실행될 때 백업 프로세스 중에 데이터가 변경되지 않도록 전역 잠금을 발행합니다. 실행 프로세스에서 명령문이 발견되면 글로벌 잠금을 발행하기 전에 명령문이 완료 될 때까지 대기합니다. 이 옵션을 사용하면 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문과 같은 특정 쿼리 유형 만 대기하도록이 기본 동작을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e8b492d9a0cab12fbd565824da3fb9d90c83d76" translate="yes" xml:space="preserve">
          <source>When Multi Range Read is used by Batched Key Access, then buffer space is managed by BKA code, which will automatically provide a part of its buffer space to MRR. You can control the amount of space used by BKA by setting</source>
          <target state="translated">배치 키 액세스에서 다중 범위 읽기를 사용하는 경우 버퍼 공간은 BKA 코드로 관리되며 버퍼 공간의 일부를 MRR에 자동으로 제공합니다. BKA가 사용하는 공간을 설정하여 제어 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="094b2c89362359afa4f3eeadb9ab2995586dc867" translate="yes" xml:space="preserve">
          <source>When MySQL 5.1 became the production release of MySQL, Federated had more features and enhancements added to it, namely:</source>
          <target state="translated">MySQL 5.1이 MySQL의 프로덕션 릴리스가되었을 때 Federated는 더 많은 기능과 향상된 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="24527ae09ae4ddf0c6157418874d162be08d35e4" translate="yes" xml:space="preserve">
          <source>When PREPARE is used with a statement which is not supported, the following error is produced:</source>
          <target state="translated">지원되지 않는 명령문과 함께 PREPARE를 사용하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c869d29eda692ef7141b9ce1c8f753a84ba4f44" translate="yes" xml:space="preserve">
          <source>When QueryStats is enabled, the query statistics history is collected in the querystats table in the infinidb_querystats schema.</source>
          <target state="translated">QueryStats를 사용하면 infinidb_querystats 스키마의 querystats 테이블에서 쿼리 통계 히스토리가 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="d1725a8008a754bfcad6e7b7c26938cf50cb3acc" translate="yes" xml:space="preserve">
          <source>When SELECTing, UNCOMPRESS the blob. Decode the string into a hash. You are now ready to interrogate/display any of the extra fields.</source>
          <target state="translated">선택할 때 Blob을 압축 해제하십시오. 문자열을 해시로 디코딩하십시오. 이제 추가 필드를 조사 / 표시 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2527b0e00ddb19b16a25e35247969798e8cd009" translate="yes" xml:space="preserve">
          <source>When SETing a variable</source>
          <target state="translated">변수를 설정할 때</target>
        </trans-unit>
        <trans-unit id="946ca53166e32231fd95a0c3dcecad3ff1d15784" translate="yes" xml:space="preserve">
          <source>When TLS is supported, check the &lt;code&gt;&lt;a href=&quot;#have_openssl&quot;&gt;have_openssl&lt;/a&gt;&lt;/code&gt; system variable to determine whether the server is using OpenSSL or MariaDB's bundled TLS library. See &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;TLS and Cryptography Libraries Used by MariaDB&lt;/a&gt; for more information about which libraries are used on which platforms.</source>
          <target state="translated">TLS가 지원되면 &lt;code&gt;&lt;a href=&quot;#have_openssl&quot;&gt;have_openssl&lt;/a&gt;&lt;/code&gt; 시스템 변수를 확인하여 서버가 OpenSSL을 사용하는지 또는 MariaDB의 번들 TLS 라이브러리를 사용하는지 판별하십시오. 어떤 플랫폼에서 어떤 라이브러리가 사용되는지에 대한 자세한 정보는 &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 가 사용하는 TLS 및 암호화 라이브러리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f14e1630254992dee11dc297371d0843be4d3cb" translate="yes" xml:space="preserve">
          <source>When _any_ write happens on a table, _all_ entries in the QC for _that_ table are removed.</source>
          <target state="translated">_any_ 쓰기가 테이블에서 발생하면 _that_ 테이블에 대한 QC의 _all_ 항목이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b8cf99ca8265e1ed486b784152248be433d4ebcc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt; (including implicit commits) or a ROLLBACK statement (with no TO clause) is performed, they act on the whole transaction, and all savepoints are removed.</source>
          <target state="translated">A는 때 &lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt; (암시 적 커밋을 포함) 또는 ROLLBACK 문이 (NO TO 절을) 수행, 그들은 전체 거래에 따라 행동, 모든 세이브 포인트는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2b4877510e86d5f47e1a05eeed150255f2e9effb" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; or &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; command is issued, MariaDB will silently change a column specification in the following cases:</source>
          <target state="translated">때 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER 표에&lt;/a&gt; 명령이 실행되어, MariaDB는 자동으로 다음과 같은 경우의 열 사양을 변경합니다 :</target>
        </trans-unit>
        <trans-unit id="e5c4780fae1d5538bd9ef649380a99da928136f2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../encrypting-data-for-innodb-xtradb/index#background-encryption-threads&quot;&gt;background encryption thread&lt;/a&gt; starts rotating a tablespace, the field contains its current size. If key rotation is not enabled, then the value will be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../encrypting-data-for-innodb-xtradb/index#background-encryption-threads&quot;&gt;배경 암호화 스레드가&lt;/a&gt; 테이블 스페이스를 회전 시작, 필드는 현재 크기가 포함되어 있습니다. 키 회전을 사용하지 않으면 값은 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26fb28c084e702df795e72a11647e13ca1497b84" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../password-validation-plugins/index&quot;&gt;password validation plugin&lt;/a&gt; is enabled, MariaDB won't allow an account to be created if the password validation plugin says that the account's password is too weak. This creates a problem for accounts that authenticate with the &lt;code&gt;pam&lt;/code&gt; authentication plugin, since MariaDB has no knowledge of the user's password. When a user tries to create an account that authenticates with the &lt;code&gt;pam&lt;/code&gt; authentication plugin, the password validation plugin would throw an error, even with &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#strict_password_validation&quot;&gt;strict_password_validation=OFF&lt;/a&gt;&lt;/code&gt; set.</source>
          <target state="translated">때 &lt;a href=&quot;../password-validation-plugins/index&quot;&gt;암호 유효성 검사 플러그인이&lt;/a&gt; 활성화되어, MariaDB는 암호 검증 플러그인이 계정의 암호가 너무 약하다는 말한다면 계정이 생성 될 수 없습니다. MariaDB는 사용자의 비밀번호를 모르기 때문에 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인으로 인증하는 계정에 문제가 발생 합니다. 사용자가 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인으로 인증하는 계정을 만들려고하면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#strict_password_validation&quot;&gt;strict_password_validation=OFF&lt;/a&gt;&lt;/code&gt; 가 설정되어 있어도 비밀번호 유효성 검사 플러그인에서 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5f4849be5a16b4d9c3459f097d2dcc7bd3f514ee" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../transactions/index&quot;&gt;transaction&lt;/a&gt; writes data, it always inserts them in the table indexes or data (in the buffer pool or in physical files). No private copies are created. The old versions of data being modified by active &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB/InnoDB&lt;/a&gt; transactions are stored in the undo log. The original data can then be restored, or viewed by a consistent read.</source>
          <target state="translated">&lt;a href=&quot;../transactions/index&quot;&gt;트랜잭션&lt;/a&gt; 은 데이터를 쓸 때 항상 테이블 인덱스 나 데이터 (버퍼 풀 또는 실제 파일)에 삽입합니다. 개인 사본이 작성되지 않습니다. 활성 &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB / InnoDB&lt;/a&gt; 트랜잭션에 의해 수정되는 이전 버전의 데이터 는 실행 취소 로그에 저장됩니다. 그런 다음 원본 데이터를 복원하거나 일관된 읽기로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69218849b29aa784164644f9e531cf9ad87f5246" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;innodb-file-per-table-tablspaces&quot;&gt;file-per-table&lt;/a&gt; tablespaces and using &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; to manually set the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;YES&lt;/code&gt;, InnoDB does &lt;strong&gt;not&lt;/strong&gt; use background threads to encrypt the tablespaces.</source>
          <target state="translated">때 &lt;a href=&quot;innodb-file-per-table-tablspaces&quot;&gt;파일 당 테이블&lt;/a&gt; 테이블 및 사용 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 가 수동으로 설정 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 에 테이블 옵션 &lt;code&gt;YES&lt;/code&gt; 를 , InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 테이블 스페이스를 암호화하는 백그라운드 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f4881bd3c167cbab57d5bb6447636f11e53818be" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DECLARE HANDLER&lt;/code&gt; block can handle more than one error condition, it may be useful to know which errors occurred. To do so, you can use the &lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt; statement.</source>
          <target state="translated">때 &lt;code&gt;DECLARE HANDLER&lt;/code&gt; 블록이 하나 개 이상의 오류 조건을 처리 할 수 있습니다, 오류가 발생한 알고하는 것이 유용 할 수 있습니다. 이를 위해 &lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt; 문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a553cb80f38990e2972ddad9102d02178faea2d0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;TIME&lt;/code&gt; value is casted to a &lt;code&gt;DATETIME&lt;/code&gt;, the date part will be &lt;code&gt;0000-00-00&lt;/code&gt;, not &lt;code&gt;CURRENT_DATE&lt;/code&gt; (as dictated by the SQL standard)</source>
          <target state="translated">때 &lt;code&gt;TIME&lt;/code&gt; 의 값은으로 주조되어 &lt;code&gt;DATETIME&lt;/code&gt; , 날짜 부분이 될 것 &lt;code&gt;0000-00-00&lt;/code&gt; ,하지 &lt;code&gt;CURRENT_DATE&lt;/code&gt; 을 (SQL 표준에 의해 결정으로)</target>
        </trans-unit>
        <trans-unit id="023a0d4677fa5014380fb3056f84768005517619" translate="yes" xml:space="preserve">
          <source>When a MariaDB Root user password is configured, do the following to access the MariaDB console:</source>
          <target state="translated">MariaDB 루트 사용자 비밀번호가 구성되면 다음을 수행하여 MariaDB 콘솔에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="e2a2318f935dba845ee2c54bf4443604bbd266f1" translate="yes" xml:space="preserve">
          <source>When a MariaDB client or client library is compiled with TLS and cryptography support, it is usually either statically linked with MariaDB's bundled TLS and cryptography library or dynamically linked with the system's TLS and cryptography library, which might be &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt;, &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;GnuTLS&lt;/a&gt;, or &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/secauthn/secure-channel&quot;&gt;Schannel&lt;/a&gt;.</source>
          <target state="translated">MariaDB 클라이언트 또는 클라이언트 라이브러리가 TLS 및 암호화 지원으로 컴파일되면 일반적으로 MariaDB의 번들 TLS 및 암호화 라이브러리와 정적으로 연결되거나 시스템의 TLS 및 암호화 라이브러리 (동적 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; , &lt;a href=&quot;https://www.gnutls.org/&quot;&gt;GnuTLS&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/secauthn/secure-channel&quot;&gt;Schannel&lt;/a&gt; 일 수 있음)와 동적으로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bef411ae2b3881b53e4db22ea451dd1ce682f42" translate="yes" xml:space="preserve">
          <source>When a Multi Range Read scan makes an index lookup (or some other &quot;basic&quot; operation), the counter of the &quot;basic&quot; operation, e.g. &lt;a href=&quot;../server-status-variables/index#handler_read_key&quot;&gt;Handler_read_key&lt;/a&gt;, will also be incremented. This way, you can still see total number of index accesses, including those made by MRR. &lt;a href=&quot;../user-statistics/index&quot;&gt;Per-user/table/index statistics&lt;/a&gt; counters also include the row reads made by Multi Range Read scans.</source>
          <target state="translated">다중 범위 읽기 스캔이 인덱스 조회 (또는 다른 &quot;기본&quot;조작)를 작성하면 &quot;기본&quot;조작의 카운터 (예 : &lt;a href=&quot;../server-status-variables/index#handler_read_key&quot;&gt;Handler_read_key&lt;/a&gt; )도 증가합니다. 이런 식으로 MRR에 의한 액세스를 포함하여 총 인덱스 액세스 수를 계속 볼 수 있습니다. &lt;a href=&quot;../user-statistics/index&quot;&gt;사용자 별 / 테이블 / 인덱스 통계&lt;/a&gt; 카운터에는 다중 범위 읽기 스캔으로 작성된 행 읽기도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fc91b73113b4f2d4b60c3ecc3e0d4a7f1fe8b7" translate="yes" xml:space="preserve">
          <source>When a MySQL installation is upgraded to MySQL 5.1 or later from an older version,the server displays a name such as a-b-c (which is in the old format) as #mysql50#a-b-c, and you must refer to the name using the #mysql50# prefix. Use &lt;code&gt;UPGRADE DATA DIRECTORY NAME&lt;/code&gt; in this case to explicitly tell the server to re-encode the database directory name to the current encoding format:</source>
          <target state="translated">MySQL 설치가 이전 버전에서 MySQL 5.1 이상으로 업그레이드되면 서버는 abc와 같은 이름 (예 : 이전 형식)을 # mysql50 # abc로 표시하며 # mysql50 #을 사용하여 이름을 참조해야합니다. 접두사. 사용 &lt;code&gt;UPGRADE DATA DIRECTORY NAME&lt;/code&gt; 명시 적으로 현재 인코딩 형식으로 데이터베이스 디렉토리 이름을 다시 인코딩하여 서버에게이 경우 :</target>
        </trans-unit>
        <trans-unit id="e8114a3c19bf6eeda32b78431a0538dad9d2053e" translate="yes" xml:space="preserve">
          <source>When a WHERE clause is related to the partitioning expression, the optimizer knows which partitions are relevant for the query. Other partitions will not be read. This optimization is called &lt;em&gt;partition pruning&lt;/em&gt;.</source>
          <target state="translated">WHERE 절이 파티셔닝 표현식과 관련되면, 옵티마이 저는 쿼리와 관련된 파티션을 알고 있습니다. 다른 파티션은 읽을 수 없습니다. 이 최적화를 &lt;em&gt;파티션 정리&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39a1b3106129baa3549d562ab52ca2948f46eeec" translate="yes" xml:space="preserve">
          <source>When a client uses &lt;code&gt;INSERT DELAYED&lt;/code&gt;, it gets an okay from the server at once, and the row is queued to be inserted when the table is not in use by any other thread.</source>
          <target state="translated">클라이언트가 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 를 사용 하면 서버에서 한 번에 괜찮아지고 다른 스레드에서 테이블을 사용하지 않을 때 행이 삽입되도록 큐에 대기됩니다.</target>
        </trans-unit>
        <trans-unit id="3bea572bc4ee611abe324badaf2ac8bfe08688c3" translate="yes" xml:space="preserve">
          <source>When a cluster node's state, as seen by &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_comment&quot;&gt;wsrep_local_state_comment&lt;/a&gt;&lt;/code&gt;, is &lt;code&gt;JOINED&lt;/code&gt;, then increasing the number of slave threads may help the cluster node catch up with the cluster more quickly. In this case, it may be useful to set the number of threads to twice the number of CPUs on the system.</source>
          <target state="translated">에서 볼 수 있듯이 클러스터 노드의 상태, 때 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_comment&quot;&gt;wsrep_local_state_comment&lt;/a&gt;&lt;/code&gt; 가 ,되어 &lt;code&gt;JOINED&lt;/code&gt; 다음 더 빨리 클러스터와 클러스터 노드 캐치를 도움이 될 수 slave 쓰레드의 수를 증가. 이 경우 스레드 수를 시스템의 CPU 수의 두 배로 설정하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62e299ce474618690ebc27cb3e7ed034aa277d5" translate="yes" xml:space="preserve">
          <source>When a deadlock is detected the system uses a weighting algorithm to determine which thread in the deadlock should be killed and then kills it.</source>
          <target state="translated">교착 상태가 감지되면 시스템은 가중치 알고리즘을 사용하여 교착 상태의 어떤 스레드를 종료해야하는지 결정한 후 종료합니다.</target>
        </trans-unit>
        <trans-unit id="8d48a0a23ae10212de1615fd16ab6e9c6028ec70" translate="yes" xml:space="preserve">
          <source>When a generated column is &lt;code&gt;PERSISTENT&lt;/code&gt; or indexed, the value of the expression needs to be consistent regardless of the &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL Mode&lt;/a&gt;&lt;/code&gt; flags in the current session. If it is not, then the table will be seen as corrupted when the value that should actually be returned by the computed expression and the value that was previously stored and/or indexed using a different &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt; setting disagree.</source>
          <target state="translated">생성 된 컬럼이 &lt;code&gt;PERSISTENT&lt;/code&gt; 이거나 색인화 된 경우, 현재 세션 의 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL Mode&lt;/a&gt;&lt;/code&gt; 플래그에 관계없이 표현식 값이 일관되어야 합니다. 그렇지 않은 경우 계산 된 표현식에 의해 실제로 리턴되어야하는 값 및 이전에 다른 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt; 설정을 사용하여 이전에 저장 및 / 또는 인덱싱 된 값이 일치하지 않으면 테이블이 손상된 것으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1a399c44aa7ab499b7fe763748b89537724952a" translate="yes" xml:space="preserve">
          <source>When a join is very large and exceeds the &lt;em&gt;PmMaxMemorySmallSide&lt;/em&gt; setting it is performed in memory in the UM server. For very large joins this could exceed the available memory in which case this is detected and a query error reported. A number of configuration parameters are available to enable and configure usage of disk overflow should this occur:</source>
          <target state="translated">조인이 너무 커서 &lt;em&gt;PmMaxMemorySmallSide&lt;/em&gt; 설정을 초과 하면 UM 서버의 메모리에서 수행됩니다. 매우 큰 조인의 경우 사용 가능한 메모리를 초과 할 수 있으며이 경우이 오류가 감지되고 쿼리 오류가보고됩니다. 이 경우 디스크 오버 플로우 사용을 활성화하고 구성하기 위해 여러 구성 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10f777d480e77bb3f0ad1ce10f861141c30f8895" translate="yes" xml:space="preserve">
          <source>When a master server is shutdown and it goes through the normal shutdown process, the master kills client threads in random order. By default, the master also considers its binary log dump threads to be regular client threads. As a consequence, the binary log dump threads can be killed while client threads still exist, and this means that data can be written on the master during a normal shutdown that won't be replicated. This is true even if &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;semi-synchronous replication&lt;/a&gt; is being used.</source>
          <target state="translated">마스터 서버가 종료되고 정상적인 종료 프로세스가 진행되면 마스터는 클라이언트 스레드를 임의의 순서로 종료합니다. 기본적으로 마스터는 이진 로그 덤프 스레드를 일반 클라이언트 스레드로 간주합니다. 결과적으로 클라이언트 스레드가 여전히 존재하는 동안 이진 로그 덤프 스레드가 종료 될 수 있으며 이는 정상적인 종료 중에 복제되지 않는 마스터에 데이터를 쓸 수 있음을 의미합니다. &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;반 동기식 복제&lt;/a&gt; 를 사용하는 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="c6c7d46b518767cf231a34093fe0691800bd069f" translate="yes" xml:space="preserve">
          <source>When a new client connection is created, its thread group is determined using the following calculation:</source>
          <target state="translated">새 클라이언트 연결이 작성되면 다음 계산을 사용하여 스레드 그룹이 판별됩니다.</target>
        </trans-unit>
        <trans-unit id="b92900741652b2a96e25421219c65737f30d2a04" translate="yes" xml:space="preserve">
          <source>When a node rejoins the cluster after being upgraded, it may have to perform a state transfer, such as an &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#incremental-state-transfers-ists&quot;&gt;Incremental State Transfer (IST)&lt;/a&gt; or a &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;State Snapshot Transfer(SST)&lt;/a&gt;. It is recommended to ensure that the node's state transfer is complete before upgrading the next node in the cluster.</source>
          <target state="translated">업그레이드 후 노드가 클러스터에 다시 참여하면 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#incremental-state-transfers-ists&quot;&gt;IST (Incremental State Transfer)&lt;/a&gt; 또는 &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;SST (State Snapshot Transfer &lt;/a&gt;) 와 같은 상태 전송을 수행해야 할 수 있습니다 . 클러스터에서 다음 노드를 업그레이드하기 전에 노드의 상태 전송이 완료되었는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3ab697e4c56a2ebc082905262730b058e2852f4f" translate="yes" xml:space="preserve">
          <source>When a plugin is being installed, the server compares the plugin's maturity level against the server's minimum allowed plugin maturity. This can help prevent users from using unstable plugins on production servers. This minimum plugin maturity is configured by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_maturity&quot;&gt;plugin_maturity&lt;/a&gt;&lt;/code&gt; system variable. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">플러그인이 설치되면 서버는 플러그인의 성숙도를 서버의 최소 허용 플러그인 성숙도와 비교합니다. 이를 통해 사용자가 프로덕션 서버에서 불안정한 플러그인을 사용하지 못하게 할 수 있습니다. 이 최소 플러그인 성숙도는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_maturity&quot;&gt;plugin_maturity&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5eebae9a04c611d28d6250ba88150772e6f17db" translate="yes" xml:space="preserve">
          <source>When a plugin is being installed, the server looks for the plugin's library in the server's plugin directory. This directory is configured by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; system variable. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">플러그인이 설치되면 서버는 서버의 플러그인 디렉토리에서 플러그인의 라이브러리를 찾습니다. 이 디렉토리는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bf7f1df7f00745ebfd33e3f841c8a274f356881" translate="yes" xml:space="preserve">
          <source>When a row in the parent table is deleted and at least one child row exists, MariaDB performs an action which depends on the &lt;code&gt;ON DELETE&lt;/code&gt; clause of the foreign key.</source>
          <target state="translated">부모 테이블의 행이 삭제되고 하나 이상의 자식 행이 존재하면 MariaDB 는 외래 키 의 &lt;code&gt;ON DELETE&lt;/code&gt; 절에 따라 동작을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="73e9829516af9fb1cb0c866dd1412bbe48b09803" translate="yes" xml:space="preserve">
          <source>When a scrubbing starts rotating a table space, the field contains its current size. &lt;code&gt;NULL&lt;/code&gt; if not enabled.</source>
          <target state="translated">스크러빙이 테이블 스페이스 회전을 시작하면 필드에 현재 크기가 포함됩니다. 사용하지 않으면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="21bb6ea604ce0436dac5c7eef563423da90f0af7" translate="yes" xml:space="preserve">
          <source>When a slave connects to a master using old-style binlog positions, and the master supports GTID (ie. is &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; or later), then the slave automatically downloads the GTID position at connect and updates it during replication. Thus, once a slave has connected to the GTID-aware master at least once, it can be switched to using GTID without any other actions needed;</source>
          <target state="translated">슬레이브가 구식 binlog 위치를 사용하여 마스터에 연결하고 마스터가 GTID를 지원하면 (즉 , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 이상), 슬레이브는 연결시 GTID 위치를 자동으로 다운로드하여 복제 중에 업데이트합니다. 따라서 슬레이브가 GTID 인식 마스터에 한 번 이상 연결되면 다른 조치없이 GTID를 사용하도록 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b424f07d28edfee8053b192bee482d6145bd0015" translate="yes" xml:space="preserve">
          <source>When a slave connects to a master, it can use either global transaction ID or old-style filename/offset to decide where in the master binlogs to start replicating from. To use global transaction ID, use the &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;em&gt;master_use_gtid&lt;/em&gt; option:</source>
          <target state="translated">슬레이브가 마스터에 연결되면 글로벌 트랜잭션 ID 또는 이전 스타일 파일 이름 / 오프셋을 사용하여 마스터 binlog에서 복제를 시작할 위치를 결정할 수 있습니다. 글로벌 트랜잭션 ID를 사용하려면 &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER &lt;/a&gt;&lt;em&gt;master_use_gtid&lt;/em&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb550d7b26f6c8abd9a6116bba6a8c8985256ee" translate="yes" xml:space="preserve">
          <source>When a slave starts after being stopped for some time, or a new slave starts that was created from a backup from some time back, a lot of old binlog events may need to be downloaded from the master. If this happens from many slaves simultaneously, it can put a lot of load on the master.</source>
          <target state="translated">슬레이브가 일정 시간 동안 정지 된 후 시작되거나 백업에서 생성 된 새 슬레이브가 시작되면 많은 오래된 binlog 이벤트를 마스터에서 다운로드해야 할 수 있습니다. 여러 슬레이브에서 동시에 발생하는 경우 마스터에 많은 부하를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b598e3f43085bc840a00617bff2c03ff8a8ffd5e" translate="yes" xml:space="preserve">
          <source>When a statement produces one or more error conditions (errors, warnings, notes) the conditions are inserted into the diagnostics area, and the statement information area is updated with that statement&amp;rsquo;s information. Usually, this also clears all the old conditions from the diagnostics area, but there is an exception: if the new statement is a correctly parsed RESIGNAL or GET DIAGNOSTICS, the old contents will remain in the diagnostics area. SIGNAL clears the old conditions.</source>
          <target state="translated">명령문이 하나 이상의 오류 조건 (오류, 경고, 참고)을 생성하면 조건이 진단 영역에 삽입되고 명령문 정보 영역이 해당 명령문 정보로 업데이트됩니다. 일반적으로 이렇게하면 진단 영역에서 모든 이전 조건이 지워지지 만 예외가 있습니다. 새 명령문이 올바르게 구문 분석 된 RESIGNAL 또는 GET DIAGNOSTICS 인 경우 이전 컨텐츠는 진단 영역에 남아 있습니다. SIGNAL은 이전 조건을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="f4a2395725ee42483dd2fd867015dd7374fb0a1e" translate="yes" xml:space="preserve">
          <source>When a stored procedure has been created, you invoke it by using the &lt;code&gt;CALL&lt;/code&gt; statement (see &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">스토어드 프로 시저가 작성되면 &lt;code&gt;CALL&lt;/code&gt; 문 을 사용하여 호출 합니다 ( &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0b99fda5e40a17d2d94c2d225371b7f0bf1abf34" translate="yes" xml:space="preserve">
          <source>When a system-versioned tables is used in a view or in a subquery in the from clause, &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; can be used directly in the view or subquery body, or (non-standard) applied to the whole view when it's being used in a &lt;code&gt;SELECT&lt;/code&gt;:</source>
          <target state="translated">시스템 버전 테이블이 from 절의 뷰 또는 서브 쿼리에서 사용되는 경우 &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; 은 뷰 또는 서브 쿼리 본문에서 직접 사용되거나 (표준이 아닌) 뷰에서 사용될 때 전체 뷰에 적용될 수 있습니다. &lt;code&gt;SELECT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7a4aef69392c390338c7b8fc1d31e20237aff65" translate="yes" xml:space="preserve">
          <source>When a table has an &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; column and a &lt;a href=&quot;../triggers/index&quot;&gt;trigger&lt;/a&gt; or &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;stored procedure&lt;/a&gt; executes an &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; statement against the table. Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-553-release-notes/&quot;&gt;MariaDB 5.5.3&lt;/a&gt;, all updates on tables with an AUTO_INCREMENT column were considered unsafe, as the order that the rows were updated could differ across servers.</source>
          <target state="translated">테이블에 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 컬럼이 있고 &lt;a href=&quot;../triggers/index&quot;&gt;트리거&lt;/a&gt; 또는 &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;스토어드 프로 시저&lt;/a&gt; 가 테이블에 대해 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 문을 실행하는 경우 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-553-release-notes/&quot;&gt;MariaDB 5.5.3&lt;/a&gt; 이전 에는 행이 업데이트 된 순서가 서버마다 다를 수 있으므로 AUTO_INCREMENT 열이있는 테이블의 모든 업데이트는 안전하지 않은 것으로 간주되었습니다.</target>
        </trans-unit>
        <trans-unit id="82ae9ac2aab41b729997710a45fd29c7c3b3559a" translate="yes" xml:space="preserve">
          <source>When a table is &lt;a href=&quot;../create-table/index&quot;&gt;created&lt;/a&gt; or the format &lt;a href=&quot;../alter-table/index&quot;&gt;altered&lt;/a&gt;, columns can be specified as accepting NULL values, or not accepting them, with the &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; clauses respectively.</source>
          <target state="translated">테이블이 &lt;a href=&quot;../create-table/index&quot;&gt;작성&lt;/a&gt; 되거나 형식이 &lt;a href=&quot;../alter-table/index&quot;&gt;변경&lt;/a&gt; 되면 &lt;code&gt;NULL&lt;/code&gt; 및 &lt;code&gt;NOT NULL&lt;/code&gt; 절을 각각 사용하여 NULL 값을 수락하거나 수락하지 않는 열을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e634f3f6dd44f99ff66c7448d32574958891ad93" translate="yes" xml:space="preserve">
          <source>When a table is created with the Spider storage engine, the table links to the table on a remote server. The remote table can be of any storage engine. The table link is concretely achieved by the establishment of the connection from a local MariaDB server to a remote MariaDB server. The link is shared for all tables that are part of a the same transaction.</source>
          <target state="translated">Spider 스토리지 엔진으로 테이블을 생성하면 테이블이 원격 서버의 테이블에 연결됩니다. 원격 테이블은 모든 스토리지 엔진 일 수 있습니다. 테이블 링크는 로컬 MariaDB 서버에서 원격 MariaDB 서버로의 연결을 설정함으로써 구체적으로 달성됩니다. 링크는 동일한 트랜잭션의 일부인 모든 테이블에 대해 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="c57156d235db5117882e641c473902b00f89a02c" translate="yes" xml:space="preserve">
          <source>When a table-based statement (like INSERT) is executed, the old data in the diagnostics area is cleared even if the statement doesn't produce any condition. However, statements which don't access any table (like SET, or a SELECT with no FROM clause) is executed and produces no warnings, the diagnostics area remains unchanged.</source>
          <target state="translated">INSERT와 같은 테이블 기반 명령문을 실행하면 명령문이 조건을 생성하지 않더라도 진단 영역의 이전 데이터가 지워집니다. 그러나 SET 또는 FROM 절이없는 SELECT와 같은 테이블에 액세스하지 않는 명령문은 실행되고 경고를 생성하지 않으며 진단 영역은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb85916a27882f7ab18e3f2b144d921dd6b35484" translate="yes" xml:space="preserve">
          <source>When a timeout occurs, the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; status variable will also be switched to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">시간 초과가 발생하면 &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; 상태 변수도 &lt;code&gt;OFF&lt;/code&gt; 로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="99868d9415d874651fc1724b1a72473d3f9bfd26" translate="yes" xml:space="preserve">
          <source>When a transaction updates a row in an InnoDB table, InnoDB's MVCC impleme...</source>
          <target state="translated">트랜잭션이 InnoDB 테이블의 행을 업데이트하면 InnoDB의 MVCC 구현은 ...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
