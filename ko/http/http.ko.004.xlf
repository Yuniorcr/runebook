<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP 프레임은 이제 웹 개발자에게 투명합니다. 이것은 HTTP / 1.1 메시지와 기본 전송 프로토콜 사이의 HTTP / 2의 추가 단계입니다. 웹 개발자가 HTTP 프레임을 사용하는 데 사용하는 API에는 변경이 필요 없습니다. 브라우저와 서버 모두에서 사용 가능한 경우 HTTP / 2가 켜져 서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTP는 &lt;em&gt;조건부 요청&lt;/em&gt; 개념을 가지고 있으며 , 영향을받는 자원을 &lt;em&gt;유효성 검증기&lt;/em&gt; 의 값과 비교하여 결과 및 요청의 성공 여부를 변경할 수 있습니다 . 이러한 요청은 캐시 컨텐츠의 유효성을 검사하고 쓸모없는 컨트롤을 절약하여 다운로드를 다시 시작할 때와 같이 또는 서버에서 문서를 업로드하거나 수정할 때 업데이트가 손실되지 않도록하는 등 문서의 무결성을 확인하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTP는 1990 년부터 사용되어 왔습니다. 나중에 HTTP / 0.9라고하는 첫 번째 버전은 메타 데이터없이 단일 요청 방법 (GET) 만 사용하여 인터넷을 통한 하이퍼 텍스트 데이터 전송을위한 간단한 프로토콜이었습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945에서&lt;/a&gt; 정의한 HTTP / 1.0], 다양한 요청 방법 및 MIME 유사 메시징을 추가하여 메타 데이터를 전송하고 수정자가 요청 / 응답 시맨틱에 배치되도록했습니다. 그러나 HTTP / 1.0은 계층 적 프록시, 캐싱, 지속적인 연결 필요성 또는 이름 기반 가상 호스트의 영향을 충분히 고려하지 않았습니다. &quot;HTTP / 1.0&quot;이라고 부르는 불완전하게 구현 된 응용 프로그램의 확산으로 인해 두 통신 응용 프로그램이 서로의 실제 기능을 결정하기 위해 프로토콜 버전 변경이 더 필요했습니다. HTTP / 1.1은 안정적인 구현을 가능하게하는보다 엄격한 요구 사항을 포함하여 HTTP / 1.0과 호환되는 상태를 유지하며 HTTP / 1에서 안전하게 무시할 수있는 기능 만 추가합니다.수신자는 0 명이거나 HTTP / 1.1로 당사자 광고 준수와 통신 할 때만 전송됩니다. HTTP / 1.1은 이전 버전을 쉽게 지원하도록 설계되었습니다. 범용 HTTP / 1.1 서버는 HTTP / 1.0 형식의 유효한 요청을 이해할 수 있어야하며 HTTP / 1.0 클라이언트가 이해하거나 안전하게 무시하는 기능 만 사용하는 HTTP / 1.1 메시지로 적절하게 응답해야합니다. 마찬가지로, HTTP / 1.1 클라이언트는 유효한 HTTP / 1.0 응답을 이해해야합니다. HTTP / 0.9는 요청에서 헤더 필드를 지원하지 않기 때문에 이름 기반 가상 호스트를 지원하는 메커니즘이 없습니다 (호스트 헤더 필드를 검사하여 리소스 선택). 이름 기반 가상 호스트를 구현하는 모든 서버는 HTTP / 0.9 지원을 비활성화해야합니다. HTTP / 0 인 것으로 보이는 대부분의 요청.실제로,도 9는 클라이언트가 요청 타겟을 적절히 인코딩하지 못함으로써 야기 된 잘못 구성된 HTTP / 1.x 요청이다.</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP는 클라이언트 시스템에서 실행되는 프로그램을 호스팅 할 수 있습니다. 이러한 프로그램은 웹 스크립트, 실행 파일, 플러그인 모듈 및 문서의 매크로를 포함하여 많은 형태를 취할 수 있습니다. WebDAV는 이러한 프로그램과 관련된 보안 문제를 변경하지 않지만 WebDAV는 종종 광범위한 사용자가 서버에 문서를 게시 할 수있는 상황에서 사용됩니다. 서버가 문서를 게시하는 작성자와 밀접한 신뢰 관계를 가지고 있지 않을 수 있습니다. 클라이언트가 임의의 컨텐츠를 공개 할 수있는 서버는 서버에 공개 된 컨텐츠가 다른 클라이언트에 유해하지 않은지 확인하기위한 예방 조치를 유용하게 구현할 수 있습니다. 서버는 게시 할 수있는 콘텐츠 유형을 제한하고 게시 된 콘텐츠에서 바이러스 및 맬웨어 탐지 소프트웨어를 실행하는 등의 기술로이를 수행 할 수 있습니다.서버는 콘텐츠를 서버에 게시 할 수있는 사용자에 대한 적절한 액세스 제한 및 인증을 통해 위험을 완화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">HTTP 헤더 필드는 [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]에 정의 된대로 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt; 에있는 &quot;Message Headers&quot;레지스트리에 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + ------------------- + ---------- + ---------- + ------- -------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- -------- + | 연결 | http | 표준 | &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; | | 콘텐츠 길이 | http | 표준 | &lt;a href=&quot;#section-3.3.2&quot;&gt;섹션 3.3.2&lt;/a&gt; | | 호스트 | http | 표준 | &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; | | TE | http | 표준 | &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; | | 트레일러 | http | 표준 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; | | 전송 인코딩 | http | 표준 | &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 3.3.1&lt;/a&gt; | | 업그레이드 | http | 표준 | &lt;a href=&quot;#section-6.7&quot;&gt;섹션 6.7&lt;/a&gt; | | 경유 | http | 표준 | &lt;a href=&quot;#section-5.7.1&quot;&gt;섹션 5.7.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- + 또한 헤더 필드 이름 &quot;Close&quot;는 해당 이름을 HTTP 헤더 필드로 사용하면 Connection 헤더 필드의 &quot;close&quot;연결 옵션과 충돌 할 수 있으므로 &quot;예약 됨&quot;으로 등록되었습니다. ( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 항&lt;/a&gt;). + ------------------- + ---------- + ---------- + ------- ------ + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 닫기 | http | 예약 됨 | &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + --------------------- + ---------- + ---------- + ----- -------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + --------------------- + ---------- + ---------- + ----- -------- + | 인증 | http | 표준 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | | 프록시 인증 | http | 표준 | &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; | | 프록시 인증 | http | 표준 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt;| | WWW 인증 | http | 표준 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 관련 레지스트리 항목이 아래 영구 등록에 따라 업데이트되었습니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ) : + ------------------- + ---------- + ---------- + ------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 수락 범위 | http | 표준 | &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; | | 컨텐츠 범위 | http | 표준 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | | 범위 | http | 표준 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt;| | 범위 | http | 표준 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 관련 레지스트리 항목이 아래 영구 등록에 따라 업데이트되었습니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ) : + ------------------- -+ ---------- + ---------- + ------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http | 표준 | &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; | | 일치하는 경우 | http | 표준 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | | 수정 된 이후 | http | 표준 | &lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3&lt;/a&gt;| | 일치하지 않는 경우 | http | 표준 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; | | 수정되지 않은 경우 | http | 표준 | &lt;a href=&quot;#section-3.4&quot;&gt;섹션 3.4&lt;/a&gt; | | 마지막 수정 | http | 표준 | &lt;a href=&quot;#section-2.2&quot;&gt;섹션 2.2&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + ------------------- + ---------- + ---------- + ------- ------ + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 나이 | http | 표준 | &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; | | 캐시 제어 | http | 표준 | &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; | | 만료 | http | 표준 | &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;| | 프라 그마 | http | 표준 | &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; | | 경고 | http | 표준 | &lt;a href=&quot;#section-5.5&quot;&gt;섹션 5.5&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">청크 된 메시지의 트레일러 부분에 표시되는 HTTP 헤더 필드입니다. 이 헤더 필드는 &lt;strong&gt;허용되지 않습니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">HTTP (일반 헤더를 포함하는 헤더 필드, &lt;a href=&quot;#section-4.5&quot;&gt;섹션 4.5&lt;/a&gt; ), 요청 헤더 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ), 응답 헤더 ( &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; ), 및 실체 헤더 ( &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 즉에 따른다) 필드는 동일한 일반 포맷을 따라 &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;절 RFC 822 3.1&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. 각 헤더 필드는 이름과 콜론 ( &quot;:&quot;) 및 필드 값으로 구성됩니다. 필드 이름은 대소 문자를 구분하지 않습니다. 단일 SP가 선호 되더라도 필드 값 앞에 LWS가있을 수 있습니다. 헤더 필드는 하나 이상의 SP 또는 HT로 각 추가 줄 앞에 추가하여 여러 줄로 확장 할 수 있습니다. 애플리케이션은 HTTP 구문을 생성 할 때 공통 형식 이외의 항목을 허용하지 않는 일부 구현이 존재할 수 있으므로 &quot;공통 형식&quot;을 사용해야합니다. 메시지 헤더 = field-name &quot;:&quot;[field-value] field-name = 토큰 field-value = * (field-content | LWS) field-content = &amp;lt;필드 값을 구성하고 * TEXT 또는 토큰, 구분 기호 및 따옴표로 묶은 문자열로 구성된 OCTET&amp;gt; 필드 내용에는 선행 또는 후행 LWS가 포함되지 않습니다. 공백이 아닌 첫 문자 앞에 나타나는 선형 공백 필드 값 또는 필드 값의 마지막 비 공백 문자 뒤. 이러한 선행 또는 후행 LWS는 필드 값의 의미를 변경하지 않고 제거 될 수 있습니다. 필드 컨텐트 사이에서 발생하는 LWS는 필드 값을 해석하거나 메시지 다운 스트림으로 전달하기 전에 단일 SP로 교체 될 수 있습니다. 필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 일반 헤더 필드를 먼저 보내는 것이 &quot;우수 사례&quot;입니다.그 뒤에 request-header 또는 response-header 필드가 있고 entity-header 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).엔티티 헤더 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).엔티티 헤더 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">HTTP 헤더를 사용하면 클라이언트와 서버가 요청 또는 응답과 함께 추가 정보를 전달할 수 있습니다. HTTP 헤더는 대소 문자를 구분하지 않는 이름 뒤에 콜론 ' &lt;code&gt;:&lt;/code&gt; ', 그 뒤에 값 (줄 바꿈 없음)이 있습니다. 값 앞의 선행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP 헤더, 메타 요소 및 언어 정보</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ] 구현 과 코드를 공유하는 HTTP 구현 은 MIME 라인 길이 제한을 알고 있어야합니다. HTTP에는이 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP로 전송되는 MHTML 메시지는 HTTP가 메시지 본문을 페이로드로 전송하고 &quot;멀티 파트 / &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;바이트 범위&lt;/a&gt; &quot;유형 ([ RFC7233의 부록 A) 외에 라인 길이 제한 및 폴딩, 정식화 등 MHTML의 모든 규칙을 따릅니다 . )에 포함되어있을 수있는 내용 또는 MIME 헤더 행을 해석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ] 구현 과 코드를 공유하는 HTTP 구현 은 MIME 라인 길이 제한을 알고 있어야합니다. HTTP에는이 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP로 전송되는 MHTML 메시지는 라인 길이 제한 및 접기, 정규화 등 MHTML의 모든 규칙을 따릅니다. HTTP는 모든 메시지 본문을 페이로드 ( &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; 참조)로 전송 하고 내용 또는 MIME 헤더를 해석하지 않기 때문에 그 안에 포함될 수있는 라인.</target>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTP 는 브라우저가 선호하는 형식, 언어 또는 인코딩을 알리는 방법 으로 &lt;code&gt;Accept-&lt;/code&gt; 로 시작하는 헤더 세트를 소개 합니다. 이 기사에서는이 알림이 발생하는 방식, 서버의 반응 방식 및 가장 적합한 응답을 선택하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP는 클라이언트-서버 프로토콜입니다. 요청은 하나의 엔티티, 사용자 에이전트 (또는 그 대신 프록시)에 의해 전송됩니다. 대부분의 사용자 에이전트는 웹 브라우저이지만 검색 엔진 색인을 채우고 유지하기 위해 웹을 크롤링하는 로봇과 같은 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP는 꽤 확장 가능한 프로토콜입니다. 리소스 및 URI 개념, 간단한 메시지 구조 및 통신 흐름을위한 클라이언트-서버 구조와 같은 몇 가지 기본 개념에 의존합니다. 이러한 기본 개념 외에도 새로운 HTTP 메소드 또는 헤더를 작성하여 새로운 기능과 새로운 의미를 추가하면서 수년 동안 수많은 확장이 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTP 메시지 (교환함으로써 작동하는 무 요청 / 응답 프로토콜 &lt;a href=&quot;#section-3&quot;&gt;부 (3)&lt;/a&gt; (a 신뢰성 transport- 또는 세션 층 &quot;연결&quot;)간에 &lt;a href=&quot;#section-6&quot;&gt;제 6&lt;/a&gt;). HTTP &quot;클라이언트&quot;는 하나 이상의 HTTP 요청을 전송하기 위해 서버에 연결하는 프로그램입니다. HTTP &quot;서버&quot;는 HTTP 응답을 전송하여 HTTP 요청을 처리하기 위해 연결을 수락하는 프로그램입니다. &quot;클라이언트&quot;및 &quot;서버&quot;라는 용어는 이러한 프로그램이 특정 연결에 대해 수행하는 역할 만 나타냅니다. 동일한 프로그램이 일부 연결에서는 클라이언트로 작동하고 다른 연결에서는 서버로 작동 할 수 있습니다. &quot;사용자 에이전트&quot;라는 용어는 브라우저, 스파이더 (웹 기반 로봇), 명령 줄 도구, 사용자 지정 응용 프로그램 및 모바일 앱을 포함하여 요청을 시작하는 다양한 클라이언트 프로그램을 나타냅니다. &quot;원본 서버&quot;라는 용어주어진 대상 자원에 대한 권한있는 응답을 시작할 수있는 프로그램을 나타냅니다. &quot;발송 인&quot;및 &quot;수신인&quot;이라는 용어는 각각 주어진 메시지를 보내거나받는 모든 구현을 의미합니다. HTTP는 URI (Uniform Resource Identifier) ​​표준에 의존합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]을 사용하여 대상 자원 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; ) 및 자원 간의 관계 를 나타냅니다 . 메시지는 인터넷 메일 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 및 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에서 사용되는 것과 유사한 형식으로 전달됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;[RFC7231]의 부록 A&lt;/a&gt; 참조) .HTTP와 MIME 메시지의 차이점에 대해서는 대부분의 HTTP 통신은 URI로 식별 된 일부 자원을 표시하기위한 검색 요청 (GET)으로 구성됩니다. 가장 간단한 경우, 이는 사용자 에이전트 (UA)와 오리진 서버 (O) 간의 단일 양방향 연결 (===)을 통해 수행 될 수 있습니다. 요청&amp;gt; UA ======================================= O &amp;lt;응답 클라이언트가 HTTP를 보냅니다. 메소드, URI 및 프로토콜 버전을 포함하는 요청 라인 ( &lt;a href=&quot;#section-3.1.1&quot;&gt;섹션 3.1.1&lt;/a&gt; )으로 시작하여 요청 메시지 양식으로 서버에 요청한 다음 요청 수정 자, 클라이언트 정보 및 표시 메타 데이터 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt;), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문을 포함하는 메시지 본문 ( &lt;a href=&quot;#section-3.3&quot;&gt;섹션&lt;/a&gt; 이있는 경우 섹션 3.3 ). 서버는 하나 이상의 HTTP 응답 메시지를 전송하여 클라이언트의 요청에 응답합니다. 각 메시지는 프로토콜 버전, 성공 또는 오류 코드 및 텍스트 이유 문구 ( &lt;a href=&quot;#section-3.1.2&quot;&gt;섹션 3.1.2&lt;/a&gt; ) 가 포함 된 상태 줄로 시작 하고 헤더 필드가 뒤 따릅니다. 서버 정보, 리소스 메타 데이터 및 표현 메타 데이터 ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; ), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문을 포함하는 메시지 본문 (있는 경우 &lt;a href=&quot;#section-3.3&quot;&gt;3.3 절)&lt;/a&gt;). &lt;a href=&quot;#section-6.3&quot;&gt;섹션 6.3에&lt;/a&gt; 정의 된대로 여러 요청 / 응답 교환에 연결이 사용될 수 있습니다 . 다음 예 는 URI &quot;http://www.example.com/hello.txt&quot; 에서 GET 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]의 4.3.1 섹션&lt;/a&gt; )에 대한 일반적인 메시지 교환을 보여줍니다. 클라이언트 요청 : GET /hello.txt HTTP /1.1 사용자 에이전트 : curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3 호스트 : www.example.com 수락 언어 : en, mi 서버 응답 : HTTP / 1.1 200 확인 날짜 : 2009 년 7 월 27 일 월요일 12:28:53 GMT 서버 : Apache 최종 수정 : 2009 년 7 월 22 일 수요일 19:15:56 GMT ETag : &quot;34aa387-d-1568eb00&quot;수락 범위 : 바이트 내용 길이 : 51 가변 : 수락 인코딩 내용 유형 : text / plain Hello World!내 페이로드에는 후행 CRLF가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP는 사용하기 쉬운 확장 가능한 프로토콜입니다. 간단하게 헤더를 추가 할 수있는 기능과 결합 된 클라이언트-서버 구조를 통해 HTTP는 웹의 확장 된 기능과 함께 발전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP는 확장 가능</target>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTP는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 출처 정책 인&lt;/a&gt; 웹의 보안 모델과 무관합니다 . 사실, 현재 웹 보안 모델은 HTTP를 만든 후에 개발되었습니다! 수년에 걸쳐, 특정 제약 하에서이 정책의 제한 중 일부를 해제함으로써 좀 더 관대해질 수있는 것이 유용한 것으로 판명되었습니다. 이러한 제한이 해제되는 양과시기는 새로운 HTTP 헤더를 사용하여 서버에서 클라이언트로 전송됩니다. 이들은 CORS ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; ) 또는 CSP ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; ) 와 같은 사양으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 메시지에는 메시지를 구성하는 데 사용 된 MIME 프로토콜 버전을 나타내는 단일 MIME 버전 헤더 필드가 포함될 수 있습니다. MIME-Version 헤더 필드를 사용하면 메시지가 MIME 프로토콜을 완전히 준수 함을 나타냅니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에 정의 된대로 ). 발신자는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 (가능한 경우) 완벽하게 준수 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 HTTP / 1.1 메시지는 단일 MIME 버전 일반 헤더 필드를 포함하여 메시지를 구성하는 데 사용 된 MIME 프로토콜 버전을 나타냅니다. MIME-Version 헤더 필드를 사용하면 메시지가 MIME 프로토콜 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]에 정의 된 대로 )을 완전히 준수 함을 나타냅니다 . 프록시 / 게이트웨이는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 (가능한 경우) 완전한 준수를 보장 할 책임이 있습니다. MIME-Version = &quot;MIME-Version&quot; &quot;:&quot;1 * DIGIT &quot;.&quot; 1 * DIGIT MIME 버전 &quot;1.0&quot;이 HTTP / 1.1에서 사용되는 기본값입니다. 그러나 HTTP / 1.1 메시지 구문 분석 및 의미는 MIME 사양이 아닌이 문서에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTP는 간단하다</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP는 상태 비 저장이지만 세션 비 저장</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP는 상태 비 저장입니다. 동일한 연결에서 두 요청이 연속적으로 수행되는 링크는 없습니다. 이는 전자 상거래 쇼핑 바구니를 사용하는 것과 같이 특정 페이지와 일관되게 상호 작용하려는 사용자에게 문제가 될 수 있습니다. 그러나 HTTP 자체의 핵심은 상태 비 저장 인 반면, HTTP 쿠키는 상태 저장 세션을 사용할 수 있도록합니다. 헤더 확장 성을 사용하여 HTTP 쿠키가 워크 플로우에 추가되어 각 HTTP 요청에서 세션 작성이 동일한 컨텍스트 또는 동일한 상태를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTP는 일반적으로 분산 캐시 시스템에 사용되며 응답 캐시를 사용하여 성능을 향상시킬 수 있습니다. 이 문서는 응답 메시지 캐싱 및 재사용과 관련된 HTTP / 1.1의 측면을 정의합니다. HTTP 캐시는 응답 메시지의 로컬 저장소이며 메시지의 저장소, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 캐시 가능한 응답을 저장하여 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트 나 서버는 캐시를 사용할 수 있지만, 터널 역할을하는 서버는 캐시를 사용할 수 없습니다. 공유 캐시는 둘 이상의 사용자가 재사용 할 응답을 저장하는 캐시입니다. 공유 캐시는 일반적으로 중개자의 일부로 배포되지만 항상 그런 것은 아닙니다. 대조적으로 개인 캐시단일 사용자 전용 종종 사용자 에이전트의 구성 요소로 배포됩니다. HTTP / 1.1에서 캐싱의 목표는 현재 요청을 충족시키기 위해 이전 응답 메시지를 재사용하여 성능을 크게 향상시키는 것입니다. 저장된 응답은에 정의 된대로 &quot;신선한&quot;것으로 간주됩니다. &lt;a href=&quot;#section-4.2&quot;&gt;&lt;/a&gt;&quot;유효성 검증&quot;없이 응답을 재사용 할 수있는 경우 4.2 절 (캐시 된 응답이이 요청에 유효한지 확인하기 위해 오리진 서버를 점검) 따라서 새로운 응답은 재사용 될 때마다 대기 시간과 네트워크 오버 헤드를 모두 줄일 수 있습니다. 캐시 된 응답이 최신 상태가 아닌 경우 유효성 검사 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; )를 통해 새로 고칠 수 있거나 원본을 사용할 수없는 경우 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt; ) 여전히 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTP는 일반적으로 분산 캐시 시스템에 사용되며 응답 캐시를 사용하여 성능을 향상시킬 수 있습니다. HTTP / 1.1 프로토콜에는 캐싱 작업뿐만 아니라 가능한 많은 요소가 포함되어 있습니다. 이러한 요소는 프로토콜의 다른 측면과 비교할 수 없으며 서로 상호 작용하기 때문에 메소드, 헤더, 응답 코드 등의 자세한 설명과 별도로 HTTP의 기본 캐싱 설계를 설명하는 것이 유용합니다. 캐싱은 쓸모가 없습니다. 성능이 크게 향상되지 않은 경우 HTTP / 1.1에서 캐싱의 목표는 많은 경우 요청을 보낼 필요를 없애고 다른 많은 경우에는 전체 응답을 보낼 필요를 없애는 것입니다. 전자는 많은 작업에 필요한 네트워크 왕복 수를 줄입니다.이 목적을 위해 &quot;만료&quot;메커니즘을 사용합니다 (참조&lt;a href=&quot;#section-13.2&quot;&gt;섹션 13.2&lt;/a&gt; ). 후자는 네트워크 대역폭 요구 사항을 줄입니다. 이 목적을 위해 &quot;유효성 검증&quot;메커니즘을 사용합니다 ( &lt;a href=&quot;#section-13.3&quot;&gt;섹션 13.3&lt;/a&gt; 참조)). 성능, 가용성 및 연결이 끊긴 작업에 대한 요구 사항으로 인해 의미 투명성의 목표를 완화 할 수 있어야합니다. HTTP / 1.1 프로토콜을 사용하면 원본 서버, 캐시 및 클라이언트가 필요한 경우 투명성을 명시 적으로 줄일 수 있습니다. 그러나 투명하지 않은 작업은 전문가가 아닌 사용자를 혼동하고 특정 서버 응용 프로그램 (예 : 상품 주문 용)과 호환되지 않을 수 있으므로 프로토콜은 투명성을 완화해야합니다. 클라이언트 또는 오리진 서버-캐시 또는 클라이언트에 의해 완화 될 때 최종 사용자에게 명시적인 경고 만 표시하므로 HTTP / 1.1 프로토콜은 다음과 같은 중요한 요소를 제공합니다.모든 당사자가 필요할 때 완전한 의미 투명성을 제공하는 프로토콜 기능. 2. 오리진 서버 또는 사용자 에이전트가 투명하지 않은 조작을 명시 적으로 요청하고 제어 할 수있게하는 프로토콜 기능. 3. 요청 된 의미 투명성의 근사값을 유지하지 않는 응답에 캐시가 경고를 첨부 할 수있게하는 프로토콜 기능. 기본 원칙은 클라이언트가 의미 투명성의 이완 가능성을 감지 할 수 있어야한다는 것입니다. 참고 : 서버, 캐시 또는 클라이언트 구현자는이 사양에서 명시 적으로 논의되지 않은 설계 결정에 직면 할 수 있습니다. 결정이 의미 투명성에 영향을 줄 수있는 경우신중하고 완전한 분석이 투명성을 깨는 데 큰 이점을 나타내지 않는 한 구현자는 투명성을 유지하는 측면에서 실수를해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTP는 범용 컴퓨터에서 가전 제품에 이르기까지 다양한 응용 프로그램에서 사용됩니다. 경우에 따라 통신 옵션은 클라이언트 구성에서 하드 코딩됩니다. 그러나 대부분의 HTTP 클라이언트는 범용 웹 브라우저와 동일한 리소스 식별 메커니즘 및 구성 기술을 사용합니다. HTTP 통신은 어떤 목적으로 사용자 에이전트에 의해 시작됩니다. 목적은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에 정의 된 요청 의미론 과 해당 의미론을 적용 할 대상 자원 의 조합입니다 . URI 참조 ( &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt;)는 일반적으로 &quot;대상 자원&quot;에 대한 식별자로 사용되며, 사용자 에이전트는 &quot;대상 URI&quot;를 얻기 위해 절대 형식으로 해석합니다. 프래그먼트 식별자는 클라이언트 측 처리를 위해 예약되어 있기 때문에 타겟 URI는 참조의 프래그먼트 컴포넌트를 제외합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], 섹션 3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">HTTP 메시지 헤더는 자원 또는 서버 또는 클라이언트의 동작을 설명하는 데 사용됩니다. &lt;code&gt;X-&lt;/code&gt; 접두사를 사용하여 사용자 지정 독점 헤더를 추가 할 수 있습니다 . 원본 콘텐츠가 &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt; 에 정의 되어있는 &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA 레지스트리의&lt;/a&gt; 다른 것 . IANA는 또한 &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;제안 된 새로운 HTTP 메시지 헤더&lt;/a&gt; 의 레지스트리를 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">HTTP 메시지는 ASCII로 인코딩 된 텍스트 정보로 구성되며 여러 줄에 걸쳐 있습니다. HTTP / 1.1 및 이전 버전의 프로토콜에서는 이러한 메시지가 연결을 통해 공개적으로 전송되었습니다. HTTP / 2에서 한 번 사람이 읽을 수있는 메시지는 이제 HTTP 프레임으로 분할되어 최적화 및 성능 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">HTTP 메시지는 서버와 클라이언트간에 데이터가 교환되는 방식입니다. 두 가지 유형의 메시지가 있습니다. 클라이언트가 서버에서 조치를 트리거하기 위해 보낸 &lt;em&gt;요청&lt;/em&gt; 과 &lt;em&gt;response&lt;/em&gt; , 서버의 응답이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP 메시지는 HTTP 사용의 핵심입니다. 그들의 구조는 간단하고 확장 성이 뛰어납니다. HTTP / 2 프레이밍 메커니즘은 근본적으로 수정하지 않고 HTTP / 1.x 구문과 기본 전송 프로토콜 사이에 새로운 중간 계층을 추가합니다. 입증 된 메커니즘을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">HTTP 메시지는 클라이언트에서 서버로의 요청과 서버에서 클라이언트로의 응답으로 구성됩니다. HTTP 메시지 = 요청 | 응답; HTTP / 1.1 메시지 요청 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ) 및 응답 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 메시지는 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] 엔티티 전송 (메시지의 페이로드). 두 가지 유형의 메시지는 시작 행, 0 개 이상의 헤더 필드 ( &quot;헤더&quot;라고도 함), 빈 행 (예 : CRLF 앞에 아무것도없는 행), 헤더 필드의 끝을 나타냅니다. 메시지 본문. generic-message = start-line * (메시지 헤더 CRLF) CRLF [message-body] start-line = 요청 라인 | 상태 라인 견고성을 위해 서버는 요청 라인이 예상되는 빈 라인을 무시해야합니다. 즉, 서버가 메시지 시작시 프로토콜 스트림을 읽고 CRLF를 먼저 수신하는 경우 CRLF를 무시해야합니다. 특정 버그가있는 HTTP / 1.0 개의 클라이언트 구현은 POST 요청 후 추가 CRLF를 생성합니다. BNF가 명시 적으로 금지 한 사항을 다시 설명하기 위해 HTTP / 1.1 클라이언트는 추가 CRLF로 요청을 시작하거나 따라 가지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">HTTP 메시징은 기본 전송 계층 또는 세션 계층 연결 프로토콜과 독립적입니다. HTTP는 요청을 순서대로 전달하고 해당 순서대로 응답을 전달하는 안정적인 전송 만 가정합니다. 기본 전송 프로토콜의 데이터 단위에 대한 HTTP 요청 및 응답 구조의 맵핑은이 스펙의 범위를 벗어납니다. &lt;a href=&quot;#section-5.2&quot;&gt;5.2 절&lt;/a&gt; 에서 설명한 것처럼 HTTP 상호 작용에 사용되는 특정 연결 프로토콜은 클라이언트 구성 및 대상 URI에 의해 결정됩니다. 예를 들어 &quot;http&quot;URI 체계 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1)&lt;/a&gt;)은 기본 TCP 포트가 80 인 IP를 통한 TCP의 기본 연결을 나타내지 만 클라이언트는 다른 연결, 포트 또는 프로토콜을 통해 프록시를 사용하도록 구성 될 수 있습니다. HTTP 구현은 현재 연결 상태 유지, 새 연결 설정 또는 기존 연결 재사용, 연결에서 수신 된 메시지 처리, 연결 실패 감지 및 각 연결 종료를 포함하여 연결 관리에 관여 할 것으로 예상됩니다. 대부분의 클라이언트는 서버 엔드 포인트 당 둘 이상의 연결을 포함하여 여러 연결을 병렬로 유지 관리합니다. 대부분의 서버는 수천 개의 동시 연결을 유지하면서 요청 대기열을 제어하여 공정한 사용을 가능하게하고 서비스 거부 공격을 탐지합니다.</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 메소드 등록이 다음 필드를 포함해야한다 : 메소드 이름 (을)를합니다 ( &lt;a href=&quot;#section-4&quot;&gt;4 절&lt;/a&gt; 안전 오 ( &quot;예&quot;또는 &quot;아니오&quot;참조) &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1 절&lt;/a&gt; ) 멱등 원 (冪等元) O ( &quot;예&quot;또는 &quot;아니오&quot;를 참조 &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ) o 사양 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( [RFC5226], 섹션 4.1 참조 ).</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTP 메소드</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP는 주로 전송 프로토콜을 위해 TCP를 사용하여 클라이언트와 서버 간의 연결을 제공합니다. 초기 단계에서 HTTP는 단일 모델을 사용하여 이러한 연결을 처리했습니다. 이러한 연결은 수명이 짧았습니다. 요청이 전송 될 때마다 새 연결이 작성되고 응답이 수신되면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP 파이프 라이닝</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">최신 브라우저에서는 HTTP 파이프 라이닝이 기본적으로 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 대해 이의를 제기하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 확장 가능한 인증 요청 응답 인증 체계를 통해 액세스 제어 및 인증을위한 일반적인 프레임 워크를 제공합니다. 이 문서는 이전에 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;에 설명 된 일반 프레임 워크를 포함하여 &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처와 관련하여 HTTP / 1.1 인증을 정의합니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ] 및 &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 에서 이전에 정의 된 관련 필드 및 상태 코드 .IANA 인증 체계 레지스트리 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;)에는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617에서&lt;/a&gt; 미리 정의한 &quot;기본&quot;및 &quot;다이제스트&quot;인증 체계를 포함하여 등록 된 인증 체계 및 해당 사양이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP는 액세스 제어 및 인증을위한 일반적인 프레임 워크를 제공합니다. 가장 일반적인 HTTP 인증은 &quot;기본&quot;스키마를 기반으로합니다. 이 페이지는 인증을위한 HTTP 프레임 워크를 소개하고 HTTP &quot;기본&quot;스키마를 사용하여 서버에 대한 액세스를 제한하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 간단한 시도 응답 인증 프레임 워크를 제공합니다. 인증 체계를 식별하는 수단으로 대소 문자를 구분하지 않는 토큰을 사용하고 해당 체계를 통한 인증을 달성하는 데 필요한 추가 정보가 이어집니다. 후자는 쉼표로 구분 된 매개 변수 목록이거나 base64로 인코딩 된 정보를 보유 할 수있는 단일 문자 시퀀스 일 수 있습니다. 인증 매개 변수는 이름 = 값 쌍이며 이름 토큰은 대소 문자를 구분하지 않으며 각 매개 변수 이름은 시도당 한 번만 발생해야합니다. auth-scheme = 토큰 auth-param = 토큰 BWS &quot;=&quot;BWS (token / quoted-string) token68 = 1 * (ALPHA / DIGIT / &quot;-&quot;/ &quot;.&quot;/ &quot;_&quot;/ &quot;~&quot;/ &quot;+&quot;/ &quot;/&quot;) * &quot;=&quot;token68 구문은 66 개의 예약되지 않은 URI 문자 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ), 플러스 몇 가지 다른, 그래서 그것은 base64로, base64url (URL 및 파일 이름 안전 알파벳), base32 또는 base16 (16 진수) 공백 또는 패딩하지 않고 인코딩 만 제외를 보유 할 수 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]). 요청 된 자원에 적용 가능한 하나 이상의 시도를 포함하는 WWW-Authenticate 헤더 필드를 포함하여 사용자 에이전트의 권한 부여에 도전하기 위해 오리진 서버가 401 (무단) 응답 메시지를 사용합니다. 407 (프록시 인증 필요) 응답 메시지는 프록시가 요청 된 자원의 프록시에 적용 할 수있는 하나 이상의 시도를 포함하는 프록시 인증 헤더 필드를 포함하여 클라이언트의 권한 부여에 도전하는 데 사용됩니다. challenge = auth-scheme [1 * SP (token68 / # auth-param)] 참고 : 많은 클라이언트가 알 수없는 체계가 포함 된 시도를 구문 분석하지 못합니다. 이 문제의 해결 방법은 잘 지원되는 체계 (예 : &quot;기본&quot;)를 먼저 나열하는 것입니다. 오리진 서버로 인증하려는 사용자 에이전트-일반적으로401 (권한 없음)을받은 후 요청에 Authorization 헤더 필드를 포함하면됩니다. 프록시로 자신을 인증하려는 클라이언트 (보통 407 (프록시 인증 필요)를 수신 한 후 반드시 그렇지는 않음)는 요청에 프록시 인증 헤더 필드를 포함하여 인증 할 수 있습니다. Authorization 필드 값과 Proxy-Authorization 필드 값은 모두 응답에서 수신 된 챌린지 (이전의 어느 시점에서)에 따라 요청되는 자원 영역에 대한 클라이언트의 자격 증명을 포함합니다. 값을 생성 할 때 사용자 에이전트는 이해하는 가장 안전한 인증 체계로 간주되는 도전 과제를 선택하여 사용자로부터 자격 증명을 가져와야합니다.헤더 필드 값 내에서 자격 증명을 전송하면 기본 연결의 기밀성에 관한 중요한 보안 고려 사항이&lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt;. 자격 증명 = auth-scheme [1 * SP (token68 / # auth-param)] 자격 증명을 생략하고 잘못된 자격 증명 (예 : 잘못된 암호) 또는 부분 자격 증명 (예 : 인증시)을 포함하는 보호 된 리소스에 대한 요청을 수신하면 스킴에는 둘 이상의 왕복이 필요합니다), 오리진 서버는 요청 된 자원에 적용 할 수있는 하나 이상의 도전 과제가있는 WWW 인증 헤더 필드를 포함하는 401 (권한 없음) 응답을 보내야합니다. 마찬가지로, 프록시 자격 증명을 생략하거나 유효하지 않거나 부분적인 프록시 자격 증명을 포함하는 요청을 수신하면 인증이 필요한 프록시는 최소한 하나의 프록시 인증 헤더 필드를 포함하는 407 (프록시 인증 필요) 응답을 생성해야합니다. 프록시에 적용 할 수 있습니다.액세스하기에 적합하지 않은 유효한 자격 증명을 수신 한 서버는 403 (금지 된) 상태 코드 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;[RFC7231]의 섹션 6.5.3&lt;/a&gt; ). HTTP는 애플리케이션을 액세스 인증을위한이 간단한 시도-응답 프레임 워크로 제한하지 않습니다. 전송 수준 또는 메시지 캡슐화를 통한 인증 및 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘을 사용할 수 있습니다. 그러나 이러한 추가 메커니즘은이 사양에서 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 대해 이의를 제기하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 몇 가지 선택적인 이의 제기-응답 인증 메커니즘을 제공합니다. 액세스 인증을위한 일반적인 프레임 워크 및 &quot;기본&quot;및 &quot;다이제스트&quot;인증 사양은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 지정되어 있습니다. 이 사양은 해당 사양에서 &quot;도전&quot;및 &quot;자격 증명&quot;의 정의를 채택합니다.</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">HTTP 범위 요청을 사용하면 서버에서 클라이언트로 HTTP 메시지의 일부만 보낼 수 있습니다. 예를 들어, 부분 요청은 큰 미디어 나 일시 중지 및 다시 시작 기능이있는 파일을 다운로드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">HTTP 리디렉션은 항상 페이지가 전송되지 않고 물론 읽지도 않을 때 항상 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">HTTP 리디렉션은 리디렉션을 만드는 데 선호되는 방법이지만 웹 개발자가 서버를 제어하지 않거나 구성 할 수없는 경우가 있습니다. 이러한 특정 경우에 웹 개발자는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소와 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 속성 이 페이지 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;refresh&lt;/code&gt; 으로 설정된 HTML 페이지를 만들 수 있습니다 . 페이지를 표시 할 때 브라우저는이 요소를 찾아 표시된 페이지로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">HTTP 리디렉션이 리디렉션을 정의하는 유일한 방법은 아닙니다. 다른 방법으로는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하는 HTML 리디렉션 과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM을&lt;/a&gt; 사용하는 JavaScript 리디렉션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">Wikipedia의 HTTP 참조 자</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTP는 신뢰할 수있는 응답의 개념에 의존합니다. 대상 URI 내에서 식별 된 권한에 의해 당시 대상 자원의 상태가 주어진 경우 해당 요청에 가장 적합한 응답으로 결정된 응답 응답 메시지 발신 공유 캐시와 같이 권한이없는 소스에서 응답을 제공하면 성능과 가용성을 향상시키는 데 유용하지만 소스를 신뢰할 수 있거나 신뢰할 수없는 응답을 안전하게 사용할 수있는 경우에만 유용합니다. 불행히도 권위를 확립하는 것은 어려울 수 있습니다. 예를 들어 피싱은 사용자의 권위 인식에 대한 공격이며, 하이퍼 텍스트에 유사한 브랜딩을 제공함으로써 인식이 잘못 될 수 있습니다.권한 구성 요소를 난독 처리하는 userinfo가 도움을 줄 수 있음 (참조&lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ). 사용자 에이전트는 사용자가 조치를 취하기 전에 대상 URI를 쉽게 검사 할 수있게하고, 존재하는 경우 사용자 정보를 눈에 띄게 구별 (또는 거부)하고 참조 문서가 제공되는 경우 저장된 자격 증명 및 쿠키를 보내지 않음으로써 피싱 공격의 영향을 줄일 수 있습니다. 알 수 없거나 신뢰할 수없는 출처. 권한 구성 요소에 등록 된 이름이 사용되는 경우 &quot;http&quot;URI 체계 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1)&lt;/a&gt;)는 사용자의 로컬 이름 확인 서비스를 사용하여 신뢰할 수있는 응답을 찾을 수있는 위치를 결정합니다. 이는 사용자의 네트워크 호스트 테이블, 캐시 된 이름 또는 이름 확인 라이브러리에 대한 공격이 권한 설정에 대한 공격의 수단이됨을 의미합니다. 마찬가지로 DNS (Domain Name Service)를위한 사용자의 서버 선택 및 해결 결과를 얻는 서버 계층은 주소 매핑의 신뢰성에 영향을 줄 수 있습니다. DNS 보안 확장 (DNSSEC, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ])은 진위를 향상시키는 한 가지 방법입니다. 또한 IP 주소를 얻은 후에 &quot;http&quot;URI에 대한 권한을 설정하면 인터넷 프로토콜 라우팅 공격에 취약합니다. &quot;https&quot;체계 ( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt;)는 협상 된 TLS 연결이 보호되고 클라이언트가 통신 서버의 ID가 대상 URI의 권한 구성 요소와 일치하는지 올바르게 확인한 경우 권한 설정에 대한 이러한 많은 잠재적 인 공격을 방지 (또는 적어도 공개)하기위한 것입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; 참조 ). . 이러한 확인을 올바르게 구현하는 것은 어려울 수 있습니다 ([ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt; ] 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTP는 기본 전송 프로토콜을 사용하여 원하는 경우 메시지 기밀성을 제공합니다. HTTP는 전송 프로토콜과 독립적으로 특별히 설계되어, 다양한 형식의 암호화 된 연결을 통해 사용될 수 있으며, 이러한 전송의 선택은 URI 체계의 선택 또는 사용자 에이전트 구성 내에서 식별됩니다. &quot;https&quot;체계는 &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2에&lt;/a&gt; 설명 된 것처럼 기밀 연결이 필요한 자원을 식별하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTP 요청 메시지 라우팅은 대상 리소스, 클라이언트의 프록시 구성 및 인바운드 연결 설정 또는 재사용을 기반으로 각 클라이언트에 의해 결정됩니다. 해당 응답 라우팅은 동일한 연결 체인을 따라 클라이언트로 다시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTP 요청 방법</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP 요청은 서버에서 작업을 시작하기 위해 클라이언트가 보낸 메시지입니다. 그들의 &lt;em&gt;시작 줄&lt;/em&gt; 세 가지 요소를 포함 :</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP 요청 및 응답은 유사한 구조를 공유하며 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP 응답 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 여부를 나타냅니다. 응답은 정보 응답, 성공적인 응답, 리디렉션, 클라이언트 오류 및 서버 오류의 5 가지 클래스로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP 응답 헤더 필드는 사용자 에이전트가 오리진에 대한보고 엔드 포인트를 저장하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP 응답 상태 코드</target>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP 응답 상태 코드는 특정 &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; 요청이 성공적으로 완료 되었는지 여부를 나타냅니다 . 응답은 정보 응답, 성공적인 응답, 리디렉션, 클라이언트 오류 및 서버 오류의 5 가지 클래스로 그룹화됩니다. 상태 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;RFC 2616의 섹션 10에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">조건부 또는 무조건 GET 메소드를 사용한 HTTP 검색 요청은 범위 요청 헤더를 사용하여 전체 엔티티 대신 엔티티의 하나 이상의 하위 범위를 요청할 수 있습니다 (범위 결과 헤더 : 요청의 결과로 리턴 된 엔티티에 적용됨). &quot;&quot;: &quot;ranges-specifier 서버는 Range 헤더를 무시할 수있다. 그러나 HTTP / 1.1 오리진 서버 및 중간 캐시는 가능한 경우 바이트 범위를 지원해야합니다. 범위는 부분적으로 실패한 전송에서 효율적인 복구를 지원하고 큰 엔티티의 효율적인 부분 검색을 지원하기 때문입니다. 서버가 Range 헤더를 지원하고 지정된 범위가 엔티티에 적합한 경우 :-무조건 GET에 Range 헤더가 있으면 GET이 성공한 경우 리턴되는 항목이 수정됩니다.즉, 응답에는 200 (OK) 대신 상태 코드 206 (Partial Content)이 있습니다. -조건부 GET에 Range 헤더가 있으면 (If-Modified-Since 및 If-None-Match 중 하나 또는 둘 다를 사용하거나 If-Unmodified-Since 및 If-Match 중 하나 또는 둘 다를 사용하는 요청) 반환되는 항목을 수정합니다. 그렇지 않으면 GET이 성공하고 조건이 true 인 경우 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조또는 If-Unmodified-Since 및 If-Match) 중 하나 또는 둘다는 GET이 성공하고 조건이 true 인 경우 반환되는 내용을 수정합니다. 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조또는 If-Unmodified-Since 및 If-Match) 중 하나 또는 둘다는 GET이 성공하고 조건이 true 인 경우 반환되는 내용을 수정합니다. 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조&lt;a href=&quot;#section-14.27&quot;&gt;14.14&lt;/a&gt; )를 Range 헤더와 함께 추가하십시오. 범위를 지원하는 프록시가 범위 요청을 수신하고 요청을 인바운드 서버로 전달하고 전체 엔티티를 응답으로 수신하는 경우 요청 된 범위 만 클라이언트에게 리턴해야합니다. 캐시 할당 정책과 일치하는 경우 수신 된 전체 응답을 캐시에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTP 상태 : &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP 터널링</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTP는 개방형 및 확장 가능한 데이터 타이핑 및 유형 협상을 제공하기 위해 Content-Type ( &lt;a href=&quot;#section-14.17&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; ) 및 Accept ( &lt;a href=&quot;#section-14.1&quot;&gt;섹션 14.1&lt;/a&gt; ) 헤더 필드에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]을 사용합니다 . media-type = type &quot;/&quot;subtype * ( &quot;;&quot;parameter) type = token subtype = token 매개 변수 &lt;a href=&quot;#section-3.6&quot;&gt;(3.6 절에&lt;/a&gt; 정의 된 속성 / 값 쌍의 형태로 유형 / 하위 유형을 따를 수 있음)). 유형, 하위 유형 및 매개 변수 속성 이름은 대소 문자를 구분하지 않습니다. 매개 변수 이름의 의미에 따라 매개 변수 값은 대소 문자를 구분하거나 구분하지 않을 수 있습니다. 선형 공백 (LWS)은 유형과 하위 유형 사이 또는 속성과 값 사이에 사용해서는 안됩니다. 매개 변수의 유무는 매체 유형 레지스트리에서의 정의에 따라 매체 유형의 처리에 중요 할 수 있습니다. 일부 오래된 HTTP 응용 프로그램은 미디어 유형 매개 변수를 인식하지 못합니다. 이전 HTTP 응용 프로그램으로 데이터를 보낼 때 구현시 해당 유형 / 하위 유형 정의에 필요한 미디어 유형 매개 변수 만 사용해야합니다. 미디어 유형 값은 IANA (Internet Assigned Number Authority)에 등록됩니다 [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). 미디어 유형 등록 프로세스는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]에 요약되어 있습니다. 등록되지 않은 용지 종류는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTP는 콘텐츠 유형 ( &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5&lt;/a&gt; ) 및 인터넷 &lt;a href=&quot;#section-5.3.2&quot;&gt;섹션 (5.3.2&lt;/a&gt; ) 에서 인터넷 미디어 유형 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]을 사용합니다.) 헤더 필드를 사용하여 확장 가능한 개방형 데이터 입력 및 유형 협상을 제공합니다. 미디어 유형은 데이터 형식과 다양한 처리 모델, 즉 데이터가 수신되는 각 컨텍스트에 따라 해당 데이터를 처리하는 방법을 정의합니다. media-type = type &quot;/&quot;subtype * (OWS &quot;;&quot;OWS parameter) type = token subtype = token type / subtype 뒤에 name = value 쌍 형식의 매개 변수가 올 수 있습니다. parameter = token &quot;=&quot;(token / quoted-string) 유형, 하위 유형 및 매개 변수 이름 토큰은 대소 문자를 구분하지 않습니다. 매개 변수 이름의 의미에 따라 매개 변수 값은 대소 문자를 구분하거나 구분하지 않을 수 있습니다. 매개 변수의 유무는 매체 유형 처리에 중요 할 수 있습니다.미디어 유형 레지스트리 내의 정의에 따라 토큰 생성과 일치하는 매개 변수 값은 토큰으로 또는 인용 문자열로 전송 될 수 있습니다. 인용 및 인용되지 않은 값은 동일합니다. 예를 들어, 다음 예제는 모두 동일하지만 첫 번째는 일관성을 위해 선호됩니다. text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html ; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다그러나 첫 번째는 일관성을 위해 선호됩니다 : text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다그러나 첫 번째는 일관성을 위해 선호됩니다 : text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]. 참고 : 다른 헤더 필드의 유사한 구성과 달리 미디어 유형 매개 변수는 &quot;=&quot;문자 주위에 공백 ( &quot;나쁜&quot;공백)을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTP는 &quot;&amp;lt;major&amp;gt;. &amp;lt;minor&amp;gt;&quot;번호 체계를 사용하여 프로토콜 버전을 나타냅니다. 이 사양은 버전 &quot;1.1&quot;을 정의합니다. 프로토콜 버전 전체는 발신자가 해당 버전의 해당 HTTP 사양에 명시된 요구 사항을 준수 함을 나타냅니다. HTTP 메시지의 버전은 메시지의 첫 번째 행에 HTTP 버전 필드로 표시됩니다. HTTP 버전은 대소 문자를 구분합니다. HTTP-version = HTTP- 이름 &quot;/&quot;DIGIT &quot;.&quot; DIGIT HTTP- 이름 = % x48.54.54.50; 대소 문자를 구분하는 &quot;HTTP&quot;HTTP 버전 번호는 &quot;.&quot;으로 구분 된 두 개의 10 진수로 구성됩니다. (마침표 또는 소수점). 첫 번째 숫자 ( &quot;주 버전&quot;)는 HTTP 메시징 구문을 나타냅니다.반면 두 번째 숫자 ( &quot;부 버전&quot;)는 발신자가 준수하고 향후 통신을 위해 이해할 수있는 주 버전 내에서 가장 높은 부 버전을 나타냅니다. 부 버전은 보낸 사람이 이전 버전과 호환되는 프로토콜 하위 집합 만 사용하는 경우에도 보낸 사람의 통신 기능을 알리므로 응답자 (서버) 또는 향후 요청 (클라이언트)에 고급 기능을 사용할 수 있음을 수신자에게 알립니다. . HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [송신자가 이전 버전과 호환되는 프로토콜 하위 집합 만 사용하는 경우에도 통신 기능을 통해 응답자 (서버) 또는 향후 요청 (클라이언트)에보다 고급 기능을 사용할 수 있음을 수신자에게 알릴 수 있습니다. HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [송신자가 이전 버전과 호환되는 프로토콜 하위 집합 만 사용하는 경우에도 통신 기능을 통해 응답자 (서버) 또는 향후 요청 (클라이언트)에보다 고급 기능을 사용할 수 있음을 수신자에게 알릴 수 있습니다. HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;] 또는 버전을 알 수없는 수신자 인 경우 HTTP / 1.1 메시지는 모든 최신 기능이 무시되는 경우 유효한 HTTP / 1.0 메시지로 해석 될 수 있도록 구성됩니다. 이 사양에서는 일부 새로운 기능에 대해 수신자 버전 요구 사항을 적용하므로 구성 또는 메시지 수신을 통해 수신자가 HTTP / 1.1을 지원한다고 결정할 때까지 호환되는 발신자는 호환되는 기능 만 사용합니다. 헤더 필드의 해석은 동일한 주 HTTP 버전의 마이너 버전간에 변경되지 않지만 해당 필드가없는 수신자의 기본 동작은 변경 될 수 있습니다. 달리 지정하지 않는 한, HTTP / 1.1에 정의 된 헤더 필드는 모든 버전의 HTTP / 1.x에 대해 정의됩니다. 특히,호스트 및 연결 헤더 필드는 HTTP / 1.1 준수 여부에 관계없이 모든 HTTP / 1.x 구현에서 구현해야합니다. 정의 된 시맨틱으로 인해이를 인식하지 못하는 수신자가 안전하게 무시할 수있는 경우 프로토콜 버전을 변경하지 않고 새 헤더 필드를 도입 할 수 있습니다. 헤더 필드 확장 성은&lt;a href=&quot;#section-3.2.1&quot;&gt;섹션 3.2.1&lt;/a&gt;. HTTP 메시지를 처리하는 중개자 (즉, 터널 역할을하는 중개자 이외의 모든 중개자)는 자신의 HTTP 버전을 전달 된 메시지로 보내야합니다. 다시 말해, 메시지의 프로토콜 버전이 메시지의 수신 및 전송 모두에 해당 중개자가 일치하는 버전과 일치하는지 확인하지 않고 HTTP 메시지의 첫 번째 행을 맹목적으로 전달할 수 없습니다. HTTP 버전을 다시 쓰지 않고 HTTP 메시지를 전달하면 다운 스트림 수신자가 메시지 발신자 버전을 사용하여 나중에 해당 발신자와 통신하는 데 안전한 기능을 결정할 때 통신 오류가 발생할 수 있습니다.클라이언트는 클라이언트가 준수하는 최상위 버전과 동일한 버전의 요청 버전을 보내야하며, 주 버전이 서버에서 지원하는 최고 버전보다 높지 않은 경우이를 알려야합니다. 클라이언트는 준수하지 않는 버전을 보내서는 안됩니다. 클라이언트가 서버가 HTTP 사양을 잘못 구현 한 것으로 알려져 있지만 클라이언트가 하나 이상의 일반 요청을 시도하고 응답 상태 코드 또는 헤더 필드 (예 : 서버)에서 결정한 후에 만 ​​하위 요청 버전을 보낼 수 있습니다. 서버가 더 높은 요청 버전을 부적절하게 처리합니다. 서버는 요청에서 수신 한 메이저 버전보다 작거나 같은 메이저 버전을 가진 서버가 가장 적합한 버전의 응답 버전을 보내야한다.서버는 준수하지 않는 버전을 보내서는 안됩니다. 어떤 이유로 든 클라이언트의 주요 프로토콜 버전에 대한 서비스 거부를 원하는 경우 서버는 505 (HTTP 버전 지원되지 않음) 응답을 보낼 수 있습니다. 클라이언트가 HTTP 사양을 잘못 구현하고 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하는 경우 나 이후 버전 응답을 올바르게 처리 할 수없는 것으로 알려진 경우 서버는 요청에 HTTP / 1.0 응답을 보낼 수 있습니다. 중개자는 주어진 부 버전의 프로토콜을 준수하지 않더라도 HTTP 버전을 맹목적으로 전달하는 것으로 알려져 있습니다. 이러한 프로토콜 다운 그레이드는 하나 이상의 요청 헤더 필드와 같은 특정 클라이언트 속성에 의해 트리거되지 않는 한 수행되지 않아야합니다 (예 :User-Agent)는 오류가있는 것으로 알려진 클라이언트가 보낸 값과 고유하게 일치합니다. HTTP 버전 관리 설계의 목적은 호환되지 않는 메시지 구문이 도입 된 경우에만 주 번호가 증가하고, 프로토콜 변경으로 인해 메시지 시맨틱에 추가되거나 추가로 암시되는 경우에만 부 번호가 증가한다는 것입니다. 발신자의 기능. 그러나 마이너 버전은 [프로토콜에 대한 변경이 메시지 의미에 추가하거나 발신자의 추가 기능을 암시하는 효과가있는 경우에만 부 번호가 증가합니다. 그러나 마이너 버전은 [프로토콜에 대한 변경이 메시지 의미에 추가하거나 발신자의 추가 기능을 암시하는 효과가있는 경우에만 부 번호가 증가합니다. 그러나 마이너 버전은 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및이 개정은 프로토콜에 대한 이러한 변경을 구체적으로 피했습니다. 수신자가 구현하는 메이저 버전 번호가 있지만 수신자가 구현 한 것보다 부 버전 번호가 높은 HTTP 메시지가 수신되면 수신자는 메시지가 해당 메이저 버전 내에서 최상위 부 버전 인 것처럼 메시지를 처리해야합니다. 수신자가 적합합니다. 수신자는 상위 버전이 높은 메시지가 상위 버전에 대한 지원을 아직 표시하지 않은 수신자에게 전송 된 경우 동일한 주 버전을 구현하여 안전하게 처리 할 수 ​​있도록 이전 버전과 충분히 호환된다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTP는 &quot;&amp;lt;major&amp;gt;. &amp;lt;minor&amp;gt;&quot;번호 체계를 사용하여 프로토콜 버전을 나타냅니다. 프로토콜 버전 관리 정책은 발신자가 해당 통신을 통해 얻은 기능이 아니라 메시지의 형식과 추가 HTTP 통신을 이해할 수있는 용량을 표시 할 수 있도록하기위한 것입니다. 통신 동작에 영향을 미치지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소를 추가하기 위해 버전 번호가 변경되지 않습니다. &amp;lt;minor&amp;gt; 번호는 프로토콜에 대한 변경 사항이 일반 메시지 구문 분석 알고리즘을 변경하지 않지만 메시지 의미를 추가하고 발신자의 추가 기능을 암시하는 기능을 추가 할 때 증가합니다. &amp;lt;주요&amp;gt;프로토콜 내에서 메시지 형식이 변경되면 번호가 증가합니다. 보다&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]에 대한 자세한 설명은 HTTP 메시지의 버전은 메시지의 첫 번째 행에 HTTP-Version 필드로 표시됩니다. HTTP-Version = &quot;HTTP&quot; &quot;/&quot;1 * DIGIT &quot;.&quot; 1 * DIGIT 주 및 부 숫자는 별도의 정수로 취급해야하며 각 숫자는 한 자리보다 높아질 수 있습니다. 따라서 HTTP / 2.4는 HTTP / 2.13보다 낮은 버전으로, HTTP / 12.3보다 낮습니다. 선행 0은 수신자가 무시해야하며 전송해서는 안됩니다. &quot;HTTP / 1.1&quot;의 HTTP 버전을 포함하는 요청 또는 응답 메시지를 보내는 응용 프로그램은 최소한이 사양을 조건부로 준수해야합니다. 이 사양을 조건부로 최소한 준수하는 응용 프로그램은 &quot;HTTP / 1.1&quot;의 HTTP 버전을 사용해야합니다.메시지에 포함되어야하며 HTTP / 1.0과 호환되지 않는 모든 메시지에 대해 그렇게해야합니다. 특정 HTTP 버전 값을 보내는시기에 대한 자세한 내용은&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]. 응용 프로그램의 HTTP 버전은 응용 프로그램이 최소한 조건부 호환되는 가장 높은 HTTP 버전입니다. 프록시 및 게이트웨이 애플리케이션은 애플리케이션과 다른 프로토콜 버전으로 메시지를 전달할 때주의해야합니다. 프로토콜 버전은 발신자의 프로토콜 기능을 나타내므로 프록시 / 게이트웨이는 실제 버전보다 큰 버전 표시기와 함께 메시지를 보내서는 안됩니다. 더 높은 버전의 요청이 수신되면 프록시 / 게이트웨이는 요청 버전을 다운 그레이드하거나 오류로 응답하거나 터널 동작으로 전환해야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 발행 이후 발견 된 HTTP / 1.0 프록시와의 상호 운용성 문제로 인해 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], 프록시를 캐싱해야하며, 게이트웨이가 필요할 수 있으며, 터널은 요청을 지원하는 최고 버전으로 업그레이드해서는 안됩니다. 해당 요청에 대한 프록시 / 게이트웨이의 응답은 요청과 동일한 주 버전이어야합니다. 참고 : HTTP 버전 간 변환에는 관련 버전에서 필요하거나 금지 된 헤더 필드를 수정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP는 문자 세트 이름을 사용하여 텍스트 표현의 문자 인코딩 체계를 표시하거나 협상합니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]. 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. charset = token 문자 세트 이름 은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]에 정의 된 절차에 따라 IANA &quot;문자 세트&quot;레지스트리 (&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;)에 등록되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTP는 MIME에 대해 설명 된 것과 동일한 &quot;문자 세트&quot;라는 용어의 정의를 사용합니다. &quot;문자 세트&quot;라는 용어는이 문서에서 하나 이상의 테이블에서 옥텟 시퀀스를 일련의 시퀀스로 변환하는 데 사용되는 방법을 나타냅니다 문자. 주어진 문자 세트에서 모든 문자를 사용할 수있는 것은 아니며 문자 세트가 특정 문자를 나타 내기 위해 둘 이상의 8 진수 시퀀스를 제공 할 수 있다는 점에서 다른 방향으로의 무조건 변환은 필요하지 않습니다. 이 정의는 US-ASCII와 같은 간단한 단일 테이블 매핑에서 ISO-2022의 기술을 사용하는 복잡한 테이블 전환 방법에 이르기까지 다양한 종류의 문자 인코딩을 허용하기위한 것입니다. 하나,MIME 문자 세트 이름과 관련된 정의는 반드시 옥텟에서 문자로 수행 될 맵핑을 명시해야한다. 특히, 정확한 매핑을 결정하기 위해 외부 프로파일 링 정보를 사용하는 것은 허용되지 않습니다. 참고 : 이러한 &quot;문자 세트&quot;라는 용어를보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]. charset = token HTTP가 임의의 토큰을 문자 세트 값으로 사용하도록 허용하지만 IANA 문자 세트 레지스트리 [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 내에 사전 정의 된 값을 가진 토큰은 해당 레지스트리에 의해 정의 된 문자 세트를 나타내야합니다. 응용 프로그램은 문자 집합 사용을 IANA 레지스트리에서 정의한 문자 집합으로 제한해야합니다. 구현자는 IETF 문자 세트 요구 사항을 알고 있어야합니다 [ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP는 WWW (World Wide Web) 아키텍처 용으로 만들어졌으며 전 세계 하이퍼 텍스트 시스템의 확장 성 요구를 지원하기 위해 시간이 지남에 따라 발전했습니다. 이러한 아키텍처의 대부분은 HTTP를 정의하는 데 사용되는 용어 및 구문 제작에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP는 1990 년대 초에 만들어졌으며 여러 번 확장되었습니다. 이 기사는 그 역사를 거슬러 올라가며 HTTP / 0.9, HTTP / 1.0, HTTP / 1.1, 최신 HTTP / 2 및 몇 년에 걸쳐 소개 된 작은 참신함을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP는 1990 년대 초에 처음 지정되었습니다. 확장 성을 염두에두고 설계된이 솔루션은 수년 동안 수많은 추가 사항을 보았습니다. 이로 인해 많은 사양 문서 (실험적 포기 확장 중)에 사양이 흩어졌습니다. 이 페이지에는 HTTP에 대한 관련 리소스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">오류 처리에 대한 HTTP의 접근 방식이 설명되었습니다. ( &lt;a href=&quot;#section-2.5&quot;&gt;섹션 2.5&lt;/a&gt; ) HTTP 버전 ABNF 프로덕션은 대소 문자를 구분하는 것으로 명확 해졌습니다. 또한 구현에서 여러 자리 버전 번호를 잘못 처리하는 것으로 알려져 있기 때문에 버전 번호가 한 자리로 제한되었습니다. ( &lt;a href=&quot;#section-2.6&quot;&gt;2.6 절&lt;/a&gt; ) 유선에서의 전송과 관련된 보안 문제로 인해 사용자 정보 (예 : 사용자 이름 및 비밀번호)가 HTTP 및 HTTPS URI에서 허용되지 않습니다. ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ) HTTPS URI 스킴은 이제이 사양에 의해 정의됩니다. 이전 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;에는 [RFC2818]의 2.4 절&lt;/a&gt; 에서 수행되었다 . 또한 엔드-투-엔드 보안을 의미합니다. ( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt;) HTTP 메시지는 구현에 의해 버퍼링 될 수 있으며 종종 버퍼링 될 수 있습니다. 때때로 스트림으로 사용 가능하지만 HTTP는 기본적으로 메시지 지향 프로토콜입니다. 상호 운용성을 향상시키기 위해 다양한 프로토콜 요소에 대해 지원되는 최소 크기가 제안되었습니다. ( &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; ) 필드 이름 주위의 유효하지 않은 공백은 이제 보안 취약성을 나타내므로 거부해야합니다. 헤더 필드를 정의하는 ABNF 프로덕션은 이제 필드 값만 나열합니다. ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; ) 특정 문법 생성 사이의 암시 적 선형 공백에 대한 규칙이 제거되었습니다. 이제 공백은 ABNF에 구체적으로 정의 된 경우에만 허용됩니다. ( &lt;a href=&quot;#section-3.2.3&quot;&gt;섹션 3.2.3&lt;/a&gt;) 여러 줄에 걸쳐있는 헤더 필드 ( &quot;줄 접기&quot;)는 더 이상 사용되지 않습니다. ( &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4 절&lt;/a&gt; ) 더 이상 주석 및 따옴표로 묶인 문자열 텍스트에서 NUL 옥텟을 사용할 수 없으며 백 슬래시 이스케이프 처리가 명확 해졌습니다. 인용 쌍 규칙은 더 이상 HTAB 이외의 제어 문자를 이스케이프 할 수 없습니다. 헤더 필드의 US-ASCII가 아닌 컨텐츠 및 이유 문구가 더 이상 사용되지 않고 불투명하게되었습니다 (TEXT 규칙이 제거됨). ( &lt;a href=&quot;#section-3.2.6&quot;&gt;섹션 3.2.6&lt;/a&gt; ) 이제 Bogus Content-Length 헤더 필드를 수신자가 오류로 처리해야합니다. ( &lt;a href=&quot;#section-3.3.2&quot;&gt;섹션 3.3.2&lt;/a&gt;) 메시지 본문 길이를 결정하는 알고리즘은 메시지 본문에 영향을 미치는 모든 특수 사례 (예 : 방법 또는 상태 코드로 구동)를 나타 내기 위해 명확 해졌으며 새로운 프로토콜 요소는 이러한 특수 사례를 정의 할 수 없습니다. CONNECT는 메시지 본문 길이를 결정할 때 새롭고 특별한 경우입니다. &quot;멀티 파트 / 바이트 범위&quot;는 더 이상 메시지 본문 길이 감지를 결정하는 방법이 아닙니다. ( &lt;a href=&quot;#section-3.3.3&quot;&gt;섹션 3.3.3&lt;/a&gt; ) &quot;identity&quot;전송 코딩 토큰이 제거되었습니다. (섹션 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 및 4) 청크 길이에는 청크 헤더 및 트레일러의 옥텟 수가 포함되지 않습니다. 청크 확장명에서 줄을 접는 것은 허용되지 않습니다. ( &lt;a href=&quot;#section-4.1&quot;&gt;4.1 절&lt;/a&gt; ) &quot;delate&quot;컨텐츠 코딩의 의미가 명확 해졌다. (&lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ) &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; 의 abs_path 대신 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; 의 세그먼트 + 쿼리 구성 요소가 요청 대상을 정의하는 데 사용되었습니다 . request-target의 별표 형식은 OPTIONS 메소드에서만 허용됩니다. ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3 절&lt;/a&gt; ) &quot;유효 요청 URI&quot;라는 용어가 도입되었습니다. ( &lt;a href=&quot;#section-5.5&quot;&gt;5.5 절&lt;/a&gt; ) 게이트웨이는 더 이상 Via 헤더 필드를 생성 할 필요가 없습니다. ( &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1 항&lt;/a&gt; ) &quot;닫기&quot;연결 옵션을 보내야하는 정확한 시점이 명확 해졌습니다. 또한 연결 헤더 필드에 &quot;hop-by-hop&quot;헤더 필드가 나타나야합니다. 이 사양에서 홉 바이 홉으로 정의 되었기 때문에 면제되지 않습니다.( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 항&lt;/a&gt;) 서버 당 두 개의 연결 제한이 제거되었습니다. dem 등원 인 요청 시퀀스는 더 이상 재 시도 할 필요가 없습니다. 서버가 연결을 조기에 닫을 때 특정 상황에서 요청을 재 시도해야하는 요구 사항이 제거되었습니다. 또한 서버에서 연결을 조기에 닫을 수있는시기에 대한 일부 관련 요구 사항이 제거되었습니다. ( &lt;a href=&quot;#section-6.3&quot;&gt;6.3 절&lt;/a&gt; ) Upgrade 헤더 필드의 의미는 이제 101 이외의 응답으로 정의됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] 에서 통합됨 ). 또한 필드 값의 순서가 중요합니다. ( &lt;a href=&quot;#section-6.7&quot;&gt;6.7 절&lt;/a&gt; ) 목록 제작에서 비어있는 목록 요소 (예 : &quot;,,&quot;를 포함하는 목록 헤더 필드)는 사용되지 않습니다. (&lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ) 전송 코딩을 등록하려면 이제 IETF 검토가 필요합니다 ( &lt;a href=&quot;#section-8.4&quot;&gt;섹션 8.4&lt;/a&gt; ).이 사양은 이제 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817] 7.2 절&lt;/a&gt; 에서 정의 된 업그레이드 토큰 레지스트리를 정의합니다 . ( &lt;a href=&quot;#section-8.6&quot;&gt;섹션 8.6&lt;/a&gt; ) HTTP / 0.9 요청 지원에 대한 기대가 제거되었습니다. (부록 A) 요청의 Keep-Alive 및 Proxy-Connection 헤더 필드 관련 문제는 지적 되었으나 후자는 사용하지 않는 것이 좋습니다. (부록 A.1.2)</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">크로스 사이트 스크립팅 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ) 에 대한 공격을 완화하기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; 속성, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; API를 통해 JavaScript를 통해 HTTP 전용 쿠키에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash; 단선 프로토콜</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP / 0.9는 매우 제한적이며 브라우저와 서버 모두보다 다양한 기능으로 빠르게 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash; 확장 성 구축</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">HTTP / 1.0 연결은 기본적으로 영구적이지 않습니다. &lt;code&gt;close&lt;/code&gt; 이외의 다른 것에 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 을 설정하면 ( 보통 &lt;code&gt;retry-after&lt;/code&gt; 영구적으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0은 두 가지 주요 결함을 도입, 각 요청 / 응답 교환을위한 TCP 연결을 열었다는 : 연결을 여는 때문에 느린 여러 메시지의 왕복 및 필요하지만 여러 메시지가 전송 될 때 더 효율적으로, 정기적으로 발송됩니다 : &lt;em&gt;따뜻한&lt;/em&gt; 연결이 &lt;em&gt;차가운&lt;/em&gt; 것 보다 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash; 표준화 된 프로토콜</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1은 클라이언트가 응답 엔티티의 일부 (범위) 만 응답 내에 포함하도록 요청할 수 있습니다. HTTP / 1.1은 Range ( &lt;a href=&quot;#section-14.35&quot;&gt;섹션 14.35&lt;/a&gt; ) 및 Content-Range ( &lt;a href=&quot;#section-14.16&quot;&gt;섹션 14.16&lt;/a&gt; ) 헤더 필드 에서 범위 단위를 사용 합니다. 엔티티는 다양한 구조 단위에 따라 하위 범위로 나눌 수 있습니다. range-unit = 바이트 단위 | other-range-unit bytes-unit = &quot;bytes&quot;other-range-unit = token HTTP / 1.1에서 정의한 유일한 범위 단위는 &quot;bytes&quot;입니다. HTTP / 1.1 구현은 다른 단위를 사용하여 지정된 범위를 무시할 수 있습니다. HTTP / 1.1은 범위 지식에 의존하지 않는 응용 프로그램을 구현할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP / 1.1 및 이전 HTTP 메시지는 사람이 읽을 수 있습니다. HTTP / 2에서는 이러한 메시지가 새로운 이진 구조 인 프레임에 포함되어 헤더 압축 및 멀티플렉싱과 같은 최적화가 가능합니다. 이 버전의 HTTP에서 원래 HTTP 메시지의 일부만 전송 되더라도 각 메시지의 의미는 변경되지 않으며 클라이언트는 원래 HTTP / 1.1 요청을 (가상으로) 재구성합니다. 따라서 HTTP / 2 메시지를 HTTP / 1.1 형식으로 이해하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP / 1.1은 모호성을 명확하게하고 수많은 개선을 도입했습니다 :</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1은 기본적으로 &quot;지속적인 연결&quot;을 사용하므로 단일 연결을 통해 여러 요청 및 응답을 전달할 수 있습니다. &quot;닫기&quot;연결 옵션은 현재 요청 / 응답 후에 연결이 지속되지 않음을 알리는 데 사용됩니다. HTTP 구현은 지속적인 연결을 지원해야합니다. 받는 사람은 가장 최근에받은 메시지의 프로토콜 버전 및 연결 헤더 필드 (있는 경우)를 기반으로 연결이 지속되는지 여부를 결정합니다. o &quot;닫기&quot;연결 옵션이 있으면 현재 응답 후 연결이 유지되지 않습니다. 그렇지 않으면, o 수신 된 프로토콜이 HTTP / 1.1 이상이면 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 수신 된 프로토콜이 HTTP / 1.0 인 경우 &quot;keep-alive &quot;연결 옵션이 존재하고 수신자가 프록시가 아니며 수신자가 HTTP / 1.0&quot;keep-alive &quot;메커니즘을 준수하려고하면 현재 응답 후에도 연결이 유지됩니다. 그렇지 않으면 o 연결이 종료됩니다. 클라이언트는 &quot;close&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적 연결에서 추가 요청을 보낼 수 있습니다. 연결에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫음으로 정의되지 않은 길이)를 가져야합니다.메커니즘, 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 현재 응답 후 연결이 닫힙니다. 클라이언트는 &quot;닫기&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적인 연결에서 추가 요청을 보낼 수 있습니다. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.메커니즘, 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 현재 응답 후 연결이 닫힙니다. 클라이언트는 &quot;닫기&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적인 연결에서 추가 요청을 보낼 수 있습니다. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&quot;keep-alive&quot;연결 옵션이없는 0 응답. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&quot;keep-alive&quot;연결 옵션이없는 0 응답. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3&lt;/a&gt; . 서버는 응답을 보낸 후 전체 요청 메시지 본문을 읽거나 연결을 닫아야합니다. 그렇지 않으면 영구 연결의 나머지 데이터가 다음 요청으로 잘못 해석되기 때문입니다. 마찬가지로, 후속 요청에 동일한 연결을 재사용하려면 클라이언트가 전체 응답 메시지 본문을 읽어야합니다. 프록시 서버는 HTTP / 1.0 클라이언트와의 지속적인 연결을 유지해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;안됩니다&lt;/a&gt; ( 많은 HTTP / 1.0 클라이언트가 구현 한 Keep-Alive 헤더 필드의 문제점에 대한 정보 및 논의는 [RFC2068]의 19.7.1 절 참조 ). HTTP / 1.0 클라이언트와의 하위 호환성에 대한 자세한 내용 은 &lt;a href=&quot;#appendix-A.1.2&quot;&gt;부록 A.1.2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1은 Transfer-Encoding 헤더 필드를 소개합니다 ( &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; ). MIME 호환 프로토콜을 통해 HTTP 메시지를 전달하기 전에 전송 코딩을 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1에는 Transfer-Encoding 헤더 필드 ( &lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;절&lt;/a&gt; )가 도입되었습니다 . 프록시 / 게이트웨이는 MIME 호환 프로토콜을 통해 메시지를 전달하기 전에 전송 코딩을 제거해야합니다. &quot;청크 된&quot;전송 코딩을 디코딩하는 프로세스 ( &lt;a href=&quot;#section-3.6&quot;&gt;섹션 3.6&lt;/a&gt;)는 다음과 같이 의사 코드로 표현할 수 있습니다. length : = 0 청크 크기 읽기, 청크 확장명 (있는 경우) 및 CRLF 반면 (청크 크기&amp;gt; 0) {청크 데이터 읽기 및 CRLF 청크 데이터를 엔터티에 추가 본문 길이 : = 길이 + 청크 크기 읽기 청크 크기 및 CRLF} 엔터티 헤더를 읽는 동안 (엔티티 헤더는 비어 있지 않음) {엔터티 헤더를 기존 헤더 필드에 추가합니다 엔터티 헤더를 읽습니다.} Content-Length : = length &quot;제거 전송 인코딩에서 청크 분할 됨</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP / 1.1 서버는 클라이언트가 재 시도 할 것으로 예상되는 연결을 종료하지 않고 지속적인 연결을 유지하고 TCP의 흐름 제어 메커니즘을 사용하여 임시 과부하를 해결해야합니다. 후자의 기술은 네트워크 혼잡을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1은 제한된 날짜 형식 세트 ( &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; )를 사용하여 날짜 비교 프로세스를 단순화합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에있는 날짜 헤더 필드가 HTTP / 1.1 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1은 제한된 날짜 형식 세트 ( &lt;a href=&quot;#section-7.1.1.1&quot;&gt;7.1.1.1 절&lt;/a&gt; )를 사용하여 날짜 비교 프로세스를 단순화합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에있는 날짜 헤더 필드가 HTTP / 1.1 형식 중 하나를 준수하고 필요한 경우 날짜를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1은 인터넷 메일 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]) 및 다목적 인터넷 메일 확장 (MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ])에 대해 정의 된 많은 구성 을 사용하여 엔티티를 다양한 표현으로 확장 가능한 메커니즘으로 전송할 수 있습니다. 그러나, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; 에 나와있는 메일 및 HTTP에 기술 된 것과 상이한 기능이 몇몇있다 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045를&lt;/a&gt; . 이러한 차이는 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 자유롭게 사용할 수있게하고, 날짜 비교를보다 쉽게하고, 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다. 이 부록에서는 HTTP와 다른 특정 영역에 대해 설명합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; . 엄격한 MIME 환경으로의 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야합니다. MIME 환경에서 HTTP 로의 프록시 및 게이트웨이도 일부 변환이 필요할 수 있으므로 차이점을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1은 인터넷 메시지 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 및 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에 대해 정의 된 많은 구성 을 사용하여 메시지 본문을 다양한 표현으로 확장 가능한 헤더 필드와 함께 전송할 수 있습니다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;이메일에만 집중합니다. HTTP 애플리케이션에는 이메일과 다른 많은 특성이 있습니다. 따라서 HTTP에는 MIME과 다른 기능이 있습니다. 이러한 차이는 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 자유롭게 사용할 수있게하고, 날짜 비교를보다 쉽게하고, 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다. 이 부록에서는 HTTP가 MIME과 다른 특정 영역에 대해 설명합니다. 엄격한 MIME 환경과의 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1은 1997 년 1 월에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 로 처음 출판되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP / 1.1은 지속적인 연결 및 파이프 라이닝을 지원하는 최초의 HTTP 버전입니다. 이 기사에서는 이러한 두 가지 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP / 1.1 : 인증</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP / 1.1 : 의미론 및 내용</target>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP / 1.x 메시지에는 성능에 대한 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash; 성능 향상을위한 프로토콜</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP / 2 프레임</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP / 2는 연결 관리를위한 추가 모델을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP / 2는 연결이 생성되고 유지되는 방법을 완전히 재검토했습니다.이 기사에서는 HTTP 프레임이 멀티플렉싱을 허용하고 이전 HTTP 버전의 'head-of-line'차단 문제를 해결하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP / 2는 HTTP / 1.x 메시지를 이진 프레임으로 캡슐화하고 나타냅니다. 이 기사에서는 프레임 구조, 목적 및 인코딩 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2는 추가 단계를 도입합니다. HTTP / 1.x 메시지를 스트림에 포함 된 프레임으로 나눕니다. 데이터와 헤더 프레임이 분리되어 헤더 압축이 가능합니다. &lt;em&gt;멀티플렉싱 (multiplexing&lt;/em&gt; ) 이라는 여러 스트림을 결합 하여보다 효율적인 기본 TCP 연결을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP / 3-QUIC를 통한 HTTP</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">서버에서 CORS 처리 (Java 예)</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">헤더 필드 이름 : SLUG 적용 가능한 프로토콜 : http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 상태 : 표준. 작성자 / 변경 컨트롤러 : IETF (iesg@ietf.org) 인터넷 엔지니어링 태스크 포스 사양 문서 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . 관련 정보 : 없음</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : DAV 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.1&quot;&gt;10.1 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 깊이 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.2&quot;&gt;섹션 10.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 대상 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.3&quot;&gt;섹션 10.3&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 해당되는 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.4&quot;&gt;섹션 10.4&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 잠금 토큰 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.5&quot;&gt;10.5 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 덮어 쓰기 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.6&quot;&gt;섹션 10.6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 타임 아웃 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.7&quot;&gt;10.7 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">헤더 필드는 완전히 확장 가능합니다. 새로운 필드 이름의 도입, 각각 새로운 의미론을 정의 할 가능성이 있거나 주어진 메시지에 사용 된 헤더 필드의 수에는 제한이 없습니다. 기존 필드는이 사양의 각 부분과이 문서 집합 이외의 다른 많은 사양에 정의되어 있습니다. 새로운 헤더 필드는 수신자가 이해할 때 이전에 정의 된 헤더 필드의 해석을 무시하거나 향상 시키거나 요청 평가시 전제 조건을 정의하거나 응답의 의미를 세분화 할 수 있도록 정의 할 수 있습니다. 필드 이름이 연결 헤더 필드에 나열되어 있지 않으면 프록시는 인식 할 수없는 헤더 필드를 전달해야합니다 ( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 절).&lt;/a&gt;) 또는 프록시는 이러한 필드를 차단하거나 달리 변환하도록 구체적으로 구성됩니다. 다른 수신자는 인식 할 수없는 헤더 필드를 무시해야합니다. 이러한 요구 사항을 통해 배포 된 중개자의 사전 업데이트없이 HTTP 기능을 향상시킬 수 있습니다. 정의 된 모든 헤더 필드 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;는 [RFC7231] 8.3 단원에&lt;/a&gt; 설명 된대로 &quot;메시지 헤더&quot;레지스트리에서 IANA에 등록되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">헤더 필드는 메시지, 페이로드, 대상 리소스 또는 연결 (예 : 제어 데이터)에 대한 데이터를 통신하는 데 사용할 수있는 키 : 값 쌍입니다. HTTP 메시지의 헤더 필드 구문에 대한 일반적인 정의 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;는 [RFC7230]의 3.2 절을&lt;/a&gt; 참조하십시오 . 헤더 필드 이름에 대한 요구 사항은 [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]. 새 필드를 정의하는 사양 작성자는 이름을 최대한 짧게 유지하고 인터넷에서 헤더 필드를 사용하지 않는 한 이름 앞에 &quot;X-&quot;를 붙이지 않는 것이 좋습니다. ( &quot;X-&quot;접두사 관용구는 실제로 광범위하게 잘못 사용되었습니다.이 접두사는 개인 이름이 새로 등록 된 이름과 충돌하지 않도록하기 때문에 독점 소프트웨어 또는 인트라넷 처리 내에서 이름 충돌을 피하기위한 메커니즘으로 만 사용되었습니다. 인터넷 이름, 자세한 내용은 [ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ] 참조 ). 새로운 헤더 필드 값은 일반적으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 확장을 사용 하여 ABNF ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ])를 사용하여 정의 된 구문을 갖습니다.필요에 따라 일반적으로 US-ASCII 문자 범위로 제한됩니다. 더 넓은 범위의 문자가 필요한 헤더 필드는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]에 정의 된 것과 같은 인코딩을 사용할 수 있습니다 . 원시 필드 값의 선행 및 후행 공백은 필드 구문 분석시 제거됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]의 섹션 3.2.4&lt;/a&gt; ). 값에서 선행 또는 후행 공백이 중요한 필드 정의는 인용 문자열 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]의 섹션 3.2.6)&lt;/a&gt; 과 같은 컨테이너 구문을 사용해야합니다 .). 쉼표 ( &quot;,&quot;)는 필드 값 사이의 일반 구분 기호로 사용되므로 필드 값에 허용되는 경우주의해서 처리해야합니다. 일반적으로 쉼표를 포함 할 수있는 구성 요소는 인용 문자열 ABNF 생산을 사용하여 큰 따옴표로 보호됩니다. 예를 들어 텍스트 날짜와 URI (쉼표를 포함 할 수 있음)는 다음과 같은 필드 값으로 안전하게 전달할 수 있습니다. Example-URI-Field : &quot;http://example.com/a.html,foo&quot; , &quot;http://without-a-comma.example.com/&quot;Example-Date-Field : &quot;1996 년 5 월 4 일 토요일&quot;, &quot;2005 년 9 월 14 일 수요일&quot;큰 따옴표 구분 기호는 거의 항상 인용 문자열 생산; 큰 따옴표 안에 다른 구문을 사용하면 불필요한 혼란이 발생할 수 있습니다.많은 헤더 필드는 대소 문자를 구분하지 않고 명명 된 매개 변수 (예 : Content-Type,&lt;a href=&quot;#section-3.1.1.5&quot;&gt;섹션 3.1.1.5&lt;/a&gt; ). 매개 변수 값에 따옴표가없는 (토큰) 구문과 따옴표가있는 (따옴표가 붙은 문자열) 구문을 모두 허용하면 수신자가 기존 파서 구성 요소를 사용할 수 있습니다. 두 가지 형식을 모두 허용하는 경우 매개 변수 값의 의미는 사용 된 구문과 독립적이어야합니다 (예를 들어, &lt;a href=&quot;#section-3.1.1.1&quot;&gt;3.1.1.1 절&lt;/a&gt; 에서 매체 유형에 대한 매개 변수 처리에 대한 참고 사항 참조 ). 새 헤더 필드를 정의하는 사양 작성자는 문서화를 고려해야합니다. o 필드가 단일 값인지 또는 목록이 될 수 있는지 여부 (쉼표로 구분) &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt; 참조). 목록 구문을 사용하지 않는 경우 필드가 여러 번 발생하는 메시지를 처리하는 방법을 문서화하십시오 (기본적으로 필드를 무시하는 것이지만 이것이 항상 올바른 선택은 아닙니다). 목록 구문을 허용하지 않는 필드 정의에도 불구하고 중개자 및 소프트웨어 라이브러리는 여러 헤더 필드 인스턴스를 단일 인스턴스로 결합 할 수 있습니다. 강력한 형식을 사용하면 수신자는 이러한 상황을 알 수 있습니다 (예 : 쉼표는 따옴표로 묶인 문자열에만 나타날 수 있으므로 &quot;Content-Type&quot;; 나쁜 예 : 쉼표는 URI 내에서 발생할 수 있음). o 어떤 조건에서 헤더 필드를 사용할 수 있습니까? 예를 들어, 응답 또는 요청에서만, 모든 메시지에서, 특정 요청 방법에 대한 응답에서만.o PUT 요청시 필드를 이해하는 원본 서버에서 필드를 저장해야하는지 여부 o 필드 시맨틱이 기존 요청 방법 또는 상태 코드와 같은 컨텍스트에 의해 더 세분화되는지 여부 o 연결 헤더 필드에 필드 이름을 나열하는 것이 적절한 지 여부 (즉, 헤더 필드가 홉별인지 여부) &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]의 섹션 6.1&lt;/a&gt; ). o 어떤 조건 하에서 중개자가 필드 값을 삽입, 삭제 또는 수정할 수 있습니다. o Vary 응답 헤더 필드에 필드 이름을 나열하는 것이 적절한 지 여부 (예 : 요청 헤더 필드가 오리진 서버의 컨텐츠 선택 알고리즘에 의해 사용되는 경우; &lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; 참조 ). o 트레일러에서 헤더 필드가 유용한 지 또는 허용 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;가능한지 ([RFC7230]의 4.1 절&lt;/a&gt; 참조 ) o 헤더 필드를 리디렉션에서 유지해야하는지 여부 o 개인 정보 보호 관련 데이터 공개와 같은 추가 보안 고려 사항이 도입되는지 여부.</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">트레일러 사용을 규제하는 헤더 필드 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; (요청) 및 &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; (응답).</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">헤더 유형</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">헤더는 종종 한 메시지에서 다음 메시지와 매우 유사하지만 여전히 연결에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">프록시가 헤더를 처리하는 방식에 따라 헤더를 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">상황에 따라 헤더를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">본문과 달리 헤더는 압축되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">HTTP 이해 및 디버깅을위한 유용한 도구 및 리소스</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">다른 사용자가 유효한 숫자를 포함 할 것이라는 보장이 없으므로 원하는 브라우저에 올바른 토큰을 다시 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">다음은 UA 문자열에 장치 ID가있는 장치를 포함하여 모든 모바일 장치를 감지하는 JavaScript 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">다음은 공통된 확장명으로 정렬 된 문서 유형별로 연관된 MIME 유형 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">다음은 HTTP로 제어 할 수있는 일반적인 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">클라이언트와 서버 간의 샘플 교환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;프리 플라이트 요청&lt;/a&gt; 을 처리하는 PHP의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">다음은 퍼센트 인코딩을 사용하여 유니 코드 문자 U + 00E8 (LATIN SMALL LETTER E WITH GRAVE)을 나타내는 Slug 헤더의 예입니다. POST / myblog / entries HTTP / 1.1 호스트 : example.org Content-Type : image / png 슬러그 : S % C3 % A8te의 해변 인증 : 기본 ZGFmZnk6c2VjZXJldA == 내용 길이 : nnn ... 바이너리 데이터 엔트리 리소스 생성에 적용된 슬러그 헤더의 예는 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">공유 캐시 프록시를 사용한이 프로세스의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">자격 증명 요청을 처리하는 일부 PHP는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">여기서는 &lt;code&gt;Upgrade&lt;/code&gt; 헤더 의 가장 일반적인 사용 사례를 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">다음은 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더의 예입니다. &quot;단순&quot;헤더 외에도 서버에 대한 CORS 요청에 의해 &lt;code&gt;X-Custom-Header&lt;/code&gt; 라는 사용자 정의 헤더 가 지원됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 인증 체계입니다 ( &quot;기본&quot;이 가장 일반적인 체계이며 &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;아래에 소개됨&lt;/a&gt; ). &lt;em&gt;영역은&lt;/em&gt; 보호 지역을 설명하기 위해 또는 보호의 범위를 표시하는 데 사용됩니다. &quot;스테이징 사이트에 액세스&quot;또는 이와 유사한 메시지 일 수 있으므로 사용자는 액세스하려는 공간을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">여기서 &lt;code&gt;base64EncodedSettings&lt;/code&gt; 는 base64url로 인코딩 된 HTTP / 2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; 프레임의 페이로드이며이 텍스트 헤더 형식으로 안전하게 포함하기 위해 모든 후행 &lt;code&gt;&quot;=&quot;&lt;/code&gt; (같음) 문자가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">여기서 &lt;em&gt;xy&lt;/em&gt; 는 Mac OS X의 버전입니다 (예 : Mac OS X 10.6).</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">여기서 기본적으로 컨텐츠는 다음을 제외하고 문서의 출처에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">여기에서는 Cross-Origin Resource Sharing의 작동 방식을 설명하는 세 가지 시나리오를 제시합니다. 이 모든 예제는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 객체를 사용하는데, 이는 지원되는 모든 브라우저에서 사이트 간 호출을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">헤 로쿠의 프록시 라이브러리 Vegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">휴리스틱 만료</target>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; 에서 폐기 된 HTTP 상태 관리 메커니즘의 역사적인 사양</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">히스토리 목록 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">홉별 압축</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">홉별 압축은 엔드-투-엔드 압축과 유사하지만 하나의 기본 요소가 다릅니다. 압축은 서버의 자원에서 발생하지 않고 전송 된 특정 표현을 작성하지만 본문에는 클라이언트와 서버 사이의 경로에있는 두 노드 사이의 메시지 연속적인 중간 노드 사이의 연결은 &lt;em&gt;다른&lt;/em&gt; 압축을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">홉별 헤더</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">호스트 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">역방향 프록시 (로드 밸런서, CDN)의 호스트 이름과 포트는 요청을 처리하는 원본 서버와 다를 수 있습니다.이 경우 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 헤더는 원래 사용 된 호스트를 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">호스트 별 파일 이름</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">HTTPS 마이그레이션을위한 호스팅 된 CSP보고</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">호스트 이름 기반 조건</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">브라우저 작동 방식</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">쿠키 작동 방식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265에&lt;/a&gt; 의해 정의됩니다 . HTTP 요청을 처리 할 때 서버는 응답과 함께 &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP 헤더를 보낼 수 있습니다 . 그런 다음 클라이언트는 모든 요청과 함께 쿠키 요청 값을 &lt;code&gt;Cookie&lt;/code&gt; 요청 헤더 형식으로 동일한 서버에 반환합니다 . 쿠키는 특정 날짜에 만료되거나 특정 도메인 및 경로로 제한되도록 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">HTTP가 문서를 캐시하는 방법을 제어 할 수 있습니다. 서버는 프록시 및 클라이언트, 캐시 대상 및 기간을 지시 할 수 있습니다. 클라이언트는 저장된 캐시 문서를 무시하도록 중간 캐시 프록시에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">브라우저가 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">CORS 프리 플라이트를 피하는 방법</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;Access-Control-Allow-Origin 헤더는 와일드 카드가 아니어야합니다&quot;&lt;/em&gt; 를 수정하는 방법&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">CORS 문제를 해결하는 방법?</target>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">CORS 프록시를 사용하여 &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;를 해결하는 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">요청으로 인해의 존재에 프리 플라이트를 유발 하나 인 경우, &lt;code&gt;Authorization&lt;/code&gt; 요청의 헤더, 당신은 위의 단계를 사용하여 제한을 해결할 수 없습니다. 요청이 수행되는 서버를 제어 할 수 없으면 해결이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">그러나 무결성이없는 스크립트는 더 이상로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">그러나 요소의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; 속성 에 직접 설정된 스타일 속성은 차단되지 않으므로 사용자는 Javascript를 통해 스타일을 안전하게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">그러나 위의 코드는 절대적으로 끔찍하고 잘못 고안되었습니다. Chrome에서이 숨김 기능을 제거하면 어떻게 되나요? 다른 브라우저가 정규 표현식 뒤에 보이는 것을 구현하면 어떻게 되나요? 다른 브라우저가 사용자 에이전트 문자열에서 &lt;em&gt;Chrome&lt;/em&gt; 을 사용하면 어떻게 되나요? 그 목록은 계속 잘못 될 수있는 것들에 관한 것입니다. 따라서 대신 다음과 같은 기능 감지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly 옵션</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">하이퍼 텍스트 커피 포트 제어 프로토콜 (HTCPCP / 1.0)</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">하이퍼 텍스트 커피 포트 제어 프로토콜 (HTCPCP / 1.0) : 의미 및 내용</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (보안)</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">하이퍼 텍스트 마크 업 언어 (HTML)</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 연결 유지 헤더</target>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol) 연결 헤더</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol) 클라이언트는 요청이 취소되거나 연결이 끊어져 데이터 전송이 중단되는 경우가 종종 있습니다. 클라이언트가 부분 표현을 저장 한 경우 전체 표현을 전송하는 대신 후속 요청에서 해당 표현의 나머지를 요청하는 것이 바람직합니다. 마찬가지로, 로컬 저장소가 제한된 장치는 매우 큰 문서의 단일 페이지 또는 포함 된 이미지의 크기와 같이 더 큰 표현의 하위 집합 만 요청할 수 있다는 이점이 있습니다. 이 문서는 HTTP / 1.1 범위 요청, 부분 응답 및 multipart / byteranges 미디어 유형을 정의합니다. 범위 요청은 HTTP의 선택적 기능입니다.이 기능을 구현하지 않거나 대상 자원에 대해 지원하지 않는 수신자는 상호 운용성에 영향을주지 않으면 서 정상적인 GET 요청 인 것처럼 응답 할 수 있도록 설계되었습니다. 기능을 구현하지 않을 수있는 캐시에 의한 전체 응답으로 착각하지 않도록 부분 응답은 고유 한 상태 코드로 표시됩니다. 범위 요청 메커니즘은 확장 가능한 범위 유형을 허용하도록 설계되었지만이 사양에서는 바이트 범위에 대한 요청 만 정의합니다.이 사양은 바이트 범위에 대한 요청 만 정의합니다.이 사양은 바이트 범위에 대한 요청 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 시맨틱 및 컨텐츠</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 컨텍스트</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜-HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 버전 2 (HTTP / 2)</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA 고려 사항 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA 고려 사항 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA 고려 사항 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANA 고려 사항 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA 고려 사항 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA 고려 사항 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANA는 'application / atom + xml'미디어 유형 등록에서이 사양에 대한 참조를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA는 MIME 미디어 유형의 공식 레지스트리 &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;이며 모든 공식 MIME 유형 목록을&lt;/a&gt; 유지 관리합니다 . 이 표에는 웹에 대한 몇 가지 중요한 MIME 유형이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">URI 스킴의 IANA 목록</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; 에서 &quot;HTTP 콘텐츠 코딩 레지스트리&quot;를 유지 관리합니다 . &quot;HTTP 컨텐츠 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ------------ + --------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ------------ + ------------------------------------ -+ --------------- + | 압축 | UNIX &quot;압축&quot;데이터 형식 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | 수축하다 | 압축 된 데이터 &quot;delate&quot;| &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; | | | &quot;zlib&quot;데이터 내부의 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) | | | | 형식 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | GZIP 파일 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | | x- 압축 | 더 이상 사용되지 않음 (압축 별명) | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | x-gzip | 더 이상 사용되지 않음 (gzip의 별명) | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt; 에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 인터넷 메시지 유형 &quot;message / http&quot;및 &quot;application / http&quot;의 사양으로 사용됩니다. 다음은 IANA에 등록되었습니다.</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt; 에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 인터넷 미디어 유형 &quot;multipart / byteranges&quot;의 사양으로 사용됩니다. 다음은 IANA에 등록되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt; 에서 URI 스킴 [ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 다음과 같은 URI 체계를 정의하므로 &quot;영구적 URI 체계&quot;레지스트리가 그에 따라 업데이트되었습니다. + ------------ + ------------------------------------ + --------------- + | URI 체계 | 설명 | 참조 | + ------------ + ------------------------------------ + --------------- + | http | 하이퍼 텍스트 전송 프로토콜 | &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; | | https | 하이퍼 텍스트 전송 프로토콜 보안 | &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">HTTP 상태 코드의 IANA 공식 레지스트리</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">IANA 레지스트리</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">인증 체계의 IANA 레지스트리</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">IETF 초안</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">IETF RFC</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">아이콘 형식</target>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">이상적으로는 하나의 자원에 대해 하나의 위치와 하나의 URL이 있습니다. 그러나 다른 리소스 이름 (www 접두어가 있거나없는 여러 도메인, 짧고 기억하기 쉬운 URL 등)을 원하는 이유가 있습니다. 이 경우 리소스를 복제하는 대신 하나의 실제 (정규) URL로 리디렉션하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">dem 등식 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">클라이언트가 프록시 또는로드 밸런서에 연결하는 데 요청한 원래 호스트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">HTTP 프록시 또는로드 밸런서를 통해 웹 서버에 연결하는 클라이언트의 원래 IP 주소를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">허용 된 요청 방법 식별</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">웹에서 리소스 식별</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">문제 식별</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">경우 &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (참조) 응답이 항상 사용으로 이어질 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 의&lt;/a&gt; 방법, &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; (임시 리디렉션) 및 &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; (영구 리디렉션) 원래 요청에 사용되는 방법을 변경하지 마십시오;</target>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If = &quot;If&quot; &quot;:&quot;(1 * No-tag-list | 1 * Tagged-list) No-tag-list = List Tagged-list = Resource-Tag 1 * List List = &quot;(&quot;1 * Condition &quot;) &quot;Condition = [&quot;Not &quot;] (상태 토큰 |&quot;[ &quot;entity-tag&quot;] &quot;); 엔티티 태그 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]의 3.11 절&lt;/a&gt; 참조 . &quot;[&quot;, entity-tag 및 &quot;]&quot;사이에 LWS가 허용되지 않음 State-token = 코딩 된 URL Resource-Tag = &quot;&amp;lt;&quot;Simple-ref &quot;&amp;gt;&quot;; 단순 참조 : &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ; Resource-Tag에 LWS가 허용되지 않음 구문은 태그가없는 목록 ( &quot;No-tag-list&quot;)과 태그가있는 목록 ( &quot;Tagged-list&quot;)을 구분합니다. 태그가없는 목록은 Request-URI가 식별 한 자원에 적용되는 반면, 태그가없는 목록은 앞의 Resource-Tag가 식별 한 자원에 적용됩니다. Resource-Tag는 다음 Resource-Tag까지 모든 후속 목록에 적용됩니다. 두 목록 유형은 If 헤더 내에서 혼합 될 수 없습니다. No-tag-list 구문은 Request-URI를 참조하는 Resource-Tag를 사용하여 Tagged-list 프로덕션에 대한 간단한 표기법이므로 기능상의 제한은 아닙니다. 각 목록은 하나 이상의 조건으로 구성됩니다. 각 조건은 엔티티 태그 또는 상태 토큰으로 정의되며 &quot;Not&quot;접두사로 잠재적으로 무효화됩니다.If 헤더 구문은 단일 요청에서 If 헤더의 다중 인스턴스를 허용하지 않습니다. 그러나 HTTP 헤더 구문을 사용하면 줄 바꿈과 공백을 삽입하여 여러 줄에 걸쳐 단일 헤더 값을 확장 할 수 있습니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">HTTP 파이프 라이닝이 활성화되면 첫 번째 응답이 완전히 수신되기를 기다리지 않고 여러 요청을 보낼 수 있습니다. HTTP 파이프 라이닝은 기존 소프트웨어가 최신 버전과 공존하는 기존 네트워크에서 구현하기 어려운 것으로 입증되었습니다. HTTP 파이프 라이닝은 프레임 내에서보다 강력한 멀티플렉싱 요청으로 HTTP / 2에서 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">(프록시) 서버가 주어진 리소스에 액세스하기에 적합하지 않은 유효한 자격 증명을 수신하면 서버는 &lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 상태 코드로 응답해야 합니다. &lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 또는 &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 와는 달리이 사용자에게는 인증이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">경우 &lt;code&gt;DELETE&lt;/code&gt; 메소드가 성공적으로 적용되어, 여러 응답 상태 코드 수있다 :</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">경우 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; 헤더가 제공하고,이 헤더의 값을 고려하여 문자열 &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;그것을 연결 키의 값을 취함으로써 계산된다 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; 해시를 연결된 문자열로 인해 20 바이트 값이됩니다. 이 값은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64로&lt;/a&gt; 인코딩 되어이 특성의 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">COPY 요청에 값이 &quot;F&quot;인 덮어 쓰기 헤더가 있고 대상 URL에 리소스가 존재하면 서버는 요청에 실패해야합니다. 서버가 COPY 요청을 실행하고 대상 리소스를 덮어 쓰는 경우 정확한 동작은 WebDAV 확장 기능을 포함하여 많은 요소에 따라 달라질 수 있습니다 (특히 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; 참조).]). 예를 들어 일반 리소스를 덮어 쓰면 서버는 복사하기 전에 대상 리소스를 삭제하거나 라이브 속성을 유지하기 위해 전체 덮어 쓰기를 수행 할 수 있습니다. 컬렉션을 덮어 쓰면 성공적인 COPY 요청 후 대상 컬렉션의 멤버 자격은 COPY 직전에 소스 컬렉션과 동일해야합니다. 따라서 소스 및 대상 컬렉션의 멤버 자격을 대상에서 병합하는 것은 호환되지 않습니다. 일반적으로 클라이언트가 COPY 이전에 도착 URL의 상태를 지워야하는 경우 (예 : 실시간 속성을 강제로 재설정) 클라이언트는 COPY 요청 전에 목적지로 DELETE를 보내이 재설정을 보장 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">캐시가 표현할 수있는 것보다 큰 값을 받거나 후속 계산이 오버플로되면 캐시는 값을 2147483648 (2 ^ 31) 또는 편리하게 나타낼 수있는 가장 큰 양의 정수로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">클라이언트가 표현의 일부 사본을 가지고 있고 전체 표현의 최신 사본을 원할 경우 조건 헤더 GET과 함께 범위 헤더 필드를 사용할 수 있습니다 (If-Unmodified-Since 및 If 중 하나 또는 둘 다 사용). 그러나 표현이 수정되어 전제 조건이 실패하면 클라이언트는 전체 현재 표현을 얻기 위해 두 번째 요청을해야합니다. &quot;If-Range&quot;헤더 필드를 통해 클라이언트는 두 번째 요청을 &quot;단락&quot;할 수 있습니다. 비공식적으로 그 의미는 다음과 같습니다. 표현이 변경되지 않으면 범위에서 요청하는 부분을 보내주십시오. 그렇지 않으면 전체 표현을 보내주십시오.If-Range = entity-tag / HTTP-date 클라이언트는 Range 헤더 필드를 포함하지 않는 요청에서 If-Range 헤더 필드를 생성해서는 안됩니다. 서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]의 섹션 2.2.2&lt;/a&gt; . If-Range 전제 조건을 평가하는 서버는 엔티티 태그를 비교할 때 강력한 비교 함수를 사용해야하고 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]의 섹션 2.3.2&lt;/a&gt; ) HTTP 날짜 유효성 검증 기가 제공되지 않으면 조건을 false로 평가해야합니다 (강력하지 않은 경우). &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]의 섹션 2.2.2에서&lt;/a&gt; 정의한 의미의 검증기. DQUOTE의 처음 두 문자를 검사하여 유효한 엔티티 태그를 유효한 HTTP- 날짜와 구별 할 수 있습니다. If-Range 헤더 필드에 제공된 유효성 검사기가 대상 리소스의 선택된 표현에 대한 현재 유효성 검사기와 일치하면 서버는 요청 된대로 Range 헤더 필드를 처리해야합니다. 유효성 검사기가 일치하지 않으면 서버는 범위 헤더 필드를 무시해야합니다. 유효성 검증 기가 HTTP 날짜 인 경우를 포함하여 정확하게 일치하는 이러한 비교는 If-Unmodified-Since 조건을 평가할 때 사용되는 &quot;이전 또는 이전&quot;비교와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">클라이언트가 캐시에 엔티티의 부분 사본을 가지고 있고 캐시에 전체 엔티티의 최신 사본을 보유하려는 경우 조건부 GET과 함께 범위 요청 헤더를 사용할 수 있습니다 (둘 중 하나 또는 둘 다 사용) 그러나 엔터티가 수정되어 조건이 실패하면 클라이언트는 현재 엔터티 전체를 얻기 위해 두 번째 요청을해야합니다. If-Range 헤더를 사용하면 클라이언트가 두 번째 요청을 &quot;단락&quot;할 수 있습니다. 비공식적으로, 그 의미는 '실체가 변하지 않으면 내가 빠진 부분을 보내주십시오. 그렇지 않으면, 전체 새로운 엔티티를 보내주십시오. If-Range = &quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date) 클라이언트에 엔티티에 대한 엔티티 태그가 없지만 최종 수정 날짜가있는 경우,해당 날짜를 If-Range 헤더에 사용할 수 있습니다. (서버는 2 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).(서버는 2 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).(서버는 2 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).또는 서버가 하위 범위 작업을 지원하지 않는 경우. If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).또는 서버가 하위 범위 작업을 지원하지 않는 경우. If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">동일한 자원에 대한 기존 응답이 캐시되는 동안 자원에서 새로운 캐시 가능 (섹션 &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; , &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; , &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; 및 &lt;a href=&quot;#section-13.8&quot;&gt;13.8 참조&lt;/a&gt; ) 응답이 수신되면 캐시는 새로운 응답을 사용하여 현재에 응답해야합니다 의뢰. 캐시 스토리지에이를 삽입하고 다른 모든 요구 사항을 충족하는 경우이를 사용하여 이전 응답이 리턴되었던 이전 요청에 응답 할 수 있습니다. 새로운 응답을 캐시 스토리지에 삽입하면 &lt;a href=&quot;#section-13.5.3&quot;&gt;섹션 13.5.3&lt;/a&gt; 의 규칙이 적용됩니다. 참고 : 기존 캐시 된 응답보다 오래된 Date 헤더 값을 가진 새 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">요청이 여러 프록시를 통과하면 각 연속 프록시의 IP 주소가 나열됩니다. 즉, 가장 오른쪽 IP 주소는 가장 최근 프록시의 IP 주소이고 가장 왼쪽 IP 주소는 원래 클라이언트의 IP 주소입니다.</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">대상에 리소스가 존재하고 덮어 쓰기 헤더가 &quot;T&quot;인 경우 이동을 수행하기 전에 서버는 대상 리소스에서 &quot;Depth : infinity&quot;를 사용하여 DELETE를 수행해야합니다. 덮어 쓰기 헤더가 &quot;F&quot;로 설정되면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">동일한 사이트 쿠키에이 속성이있는 경우 쿠키를 설정 한 웹 사이트에서 요청이 시작된 경우에만 브라우저가 쿠키를 보냅니다. 요청이 현재 위치의 URL과 다른 URL에서 시작된 경우 &lt;code&gt;strict&lt;/code&gt; 속성으로 태그가 지정된 쿠키 는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">서버가 이러한 오류 상태를 반환하면 메시지 본문에 사용 가능한 리소스 표현 목록이 포함되어 있어야 사용자가 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">단일 서버가 서로를 신뢰하지 않는 여러 조직을 지원하는 경우, 해당 조직의 통제하에 생성 된 응답에서 Location 및 Content-Location 헤더의 값을 확인하여 어떤 서버에서 자원을 무효화하지 않도록해야합니다. 그들은 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">사용자가 웹 사이트 나 서비스에서 로그 아웃하면 로컬에 저장된 데이터를 제거 할 수 있습니다. https://example.com/logout의 응답에 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더를 추가하여이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">웹 사이트가 HTTP를 통한 연결을 수락하고 HTTPS로 리디렉션하는 경우 방문자가 http://www.foo.com/ 또는 다음과 같이 입력하면 리디렉션되기 전에 방문자는 처음에 암호화되지 않은 버전의 사이트와 통신 할 수 있습니다. 그냥 foo.com. 이것은 중간자 공격의 기회를 만듭니다. 원래 사이트의 보안 버전 대신 악의적 인 사이트로 방문자를 안내하기 위해 리디렉션을 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">모든 프록시가 작동 중지되고 DIRECT 옵션이 지정되지 않은 경우 브라우저는 프록시를 일시적으로 무시해야하는지 여부를 묻고 직접 연결을 시도합니다. 20 분 후 브라우저는 프록시를 다시 시도해야하는지 묻고 추가 40 분 후에 다시 묻습니다. 쿼리는 계속 진행되며 쿼리 간 경과 시간에 항상 20 분이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">HTTP / 1.1 클라이언트가 요청 본문을 포함하지만 &quot;100-continue&quot;예상과 함께 Expect 요청 헤더 필드를 포함하지 않는 요청을 전송하고 클라이언트가 HTTP / 1.1 오리진 서버에 직접 연결되지 않은 경우 서버로부터 상태를 수신하기 전에 클라이언트가 연결이 닫히면 클라이언트는 요청을 다시 시도해야합니다. 클라이언트가이 요청을 재 시도하면 다음과 같은 &quot;이진 지수 백 오프&quot;알고리즘을 사용하여 안정적인 응답을 얻을 수 있습니다. 1. 서버에 대한 새로운 연결을 시작합니다. 2. 요청 헤더를 전송합니다. 3. 변수 R을 초기화합니다 서버에 대한 예상 왕복 시간 (예 : 연결을 설정하는 데 걸린 시간을 기준으로)왕복 시간을 사용할 수없는 경우 상수 값을 5 초로 설정하십시오. 4. 계산 T = R * (2 ** N). 여기서 N은이 요청의 이전 재시도 횟수입니다. 5. 서버에서 오류 응답을 기다리거나 T 초 (둘 중 빠른 시간)를 기다립니다. 6. 오류 응답이 수신되지 않으면 T 초 후에 요청 본문을 전송하십시오. 7. 클라이언트가 연결이 너무 일찍 종료 된 것을 확인하면 요청이 수락되거나 오류 응답이 수신되거나 사용자가 조급 해져 재시도 프로세스를 종료 할 때까지 1 단계부터 반복하십시오. 어느 시점에서든 오류 상태가 수신되면 클라이언트는 계속해서는 안되며 요청 메시지 전송이 완료되지 않은 경우 연결을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">다른 프린시 펄이 프린시 펄이 액세스하고자하는 자원을 잠그면, 두 번째 프린시 펄이 첫 번째 프린시 펄이 누구인지 알아내는 것이 유용합니다. 이를 위해 DAV : lockdiscovery 특성이 제공됩니다. 이 속성은 모든 미해결 잠금을 나열하고 유형을 설명하며 잠금 토큰을 제공 할 수도 있습니다. LOCK 메소드를 지원하는 모든 DAV 호환 자원은 DAV : lockdiscovery 특성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">두 경우 &lt;strong&gt;WD1&lt;/strong&gt; 및 &lt;strong&gt;WD1가&lt;/strong&gt; 정의되어 현재 요일이이 둘 사이에있는 경우, 조건은 true입니다 &lt;em&gt;주문&lt;/em&gt; 평일. 바운드는 포함 &lt;em&gt;되지만 바운드는 정렬&lt;/em&gt; 됩니다. &quot;GMT&quot;매개 변수를 지정하면 시간이 GMT로 설정됩니다. 그렇지 않으면 현지 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">둘 다를 경우 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더와 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 같은 응답에 존재하는 두 정책은 영광입니다. &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 정책이 보고서를 생성하지만 시행되지 않는 동안 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더에 지정된 정책 이 시행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">이 지시문과 &lt;code&gt;allowfullscreen&lt;/code&gt; 속성 이 모두 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 요소에 있으면이 지시문이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; 가 지정 되지 않은 경우 기본적으로 컨텐츠는 모든 언어 사용자를 대상으로합니다. 텍스트 &lt;code&gt;Content-Language&lt;/code&gt; 뿐만 아니라 다양한 미디어 유형에 Content-Language 헤더를 적용 할뿐만 아니라 여러 언어 태그도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">포트가 제공되지 않으면 요청 된 서비스의 기본 포트 (예 : HTTP URL의 경우 &quot;80&quot;)가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">단일 범주 (일, 월, 년)에서 하나의 값만 지정하면 함수는 해당 스펙과 일치하는 날짜에 대해서만 참 값을 리턴합니다. 두 값을 모두 지정 &lt;em&gt;하면 경계를&lt;/em&gt; 포함하여 해당 시간 사이에 결과가 적용 &lt;em&gt;되지만 경계가 정렬&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">단일 범주 만 지정하면 (각 범주에서시, 분, 초), 해당 스펙과 일치하는 시간에만 함수가 true를 리턴합니다. 두 값을 모두 지정 &lt;em&gt;하면 경계를&lt;/em&gt; 포함하여 해당 시간 사이에 결과가 적용 &lt;em&gt;되지만 경계가 정렬&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">매개 변수가 하나만 있으면 함수는 해당 매개 변수가 나타내는 요일에 true 값을 반환합니다. 문자열 &quot;GMT&quot;가 두 번째 매개 변수로 지정된 경우 시간은 GMT로 간주됩니다. 그렇지 않으면 현지 시간대로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">여러 범위가 다시 전송되면 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;multipart/byteranges&lt;/code&gt; 로 설정 되고 각 조각은 하나의 범위를 다루며 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 에서&lt;/a&gt; 설명합니다.</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">사이트에서 &lt;code&gt;Accept-Ranges&lt;/code&gt; 헤더를 생략하면 부분 요청을 지원하지 않을 수 있습니다. 일부 사이트는 명시 적으로 &quot; &lt;code&gt;none&lt;/code&gt; &quot;을 값 으로 보내 지원하지 않음을 나타냅니다. 일부 앱에서는 다운로드 관리자가이 경우 일시 중지 버튼을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">&quot;기본&quot;인증 체계를 사용하는 경우 자격 증명은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">는 IF &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; 응답 HTTP에 존재하는 (그 값이 &quot;하지 않습니다 &lt;code&gt;none&lt;/code&gt; &quot;), 서버가 지원 요청을 다양합니다. 예를 들어 &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 및 cURL 을 발행하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">는 IF &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트는&lt;/a&gt; 이 지정된 값 검출 할 수 헤더-에도 헤더가 포함되어 적 반응이 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">CORS 구성이 올바르게 설정되지 않은 경우 브라우저 콘솔은 &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; 수 없습니다 &quot; 와 같은 오류를 표시하여 CORS 보안 위반으로 인해 요청이 차단되었음을 나타냅니다. 규칙. 그러나 이것은 반드시 설정 실수가 아닐 수도 있습니다. 요청이 실제로 사용자의 웹 응용 프로그램 및 원격 외부 서비스에 의해 의도적으로 허용되지 않을 수 있습니다. 그러나 엔드 포인트를 사용할 수있게하려면 일부 디버깅이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">이 속성이 lax로 설정되면 이미지 또는 프레임로드 호출과 같은 교차 도메인 하위 요청에서 동일한 사이트 쿠키가 보류되지만 사용자가 외부 사이트에서 URL로 이동하면 다음과 같이 전송됩니다. 링크.</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">클라이언트가 조건부 GET 요청을 수행하고 액세스가 허용되었지만 문서가 수정되지 않은 경우 서버는이 상태 코드로 응답해야합니다. 304 응답은 메시지 본문을 포함해서는 안되므로 항상 헤더 필드 다음의 첫 번째 빈 줄로 종료됩니다. 응답은 다음 헤더 필드를 포함해야한다 : &lt;a href=&quot;#section-14.18.1&quot;&gt;-14.18.1 절에서&lt;/a&gt; 생략이 요구되지 않는 한, 날짜 시계 없는 오리진 서버가이 규칙을 준수하고 프록시와 클라이언트가 하나의 요청없이 수신 한 응답에 고유 한 날짜를 추가한다 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], 섹션 14.19&lt;/a&gt;) 캐시가 올바르게 작동합니다. -헤더가 동일한 요청에 대해 200 응답으로 전송 된 경우 ETag 및 / 또는 Content-Location-필드 값이 이전 응답에서 전송 된 값과 다를 수있는 경우 만료, 캐시 제어 및 / 또는 가변 동일한 변형의 경우 조건부 GET이 강력한 캐시 검사기를 사용한 경우 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 참조))에 응답에는 다른 엔터티 헤더가 포함되어서는 안됩니다. 그렇지 않으면 (즉, 조건부 GET이 약한 유효성 검사기를 사용) 응답에는 다른 엔터티 헤더가 포함되어서는 안됩니다. 이렇게하면 캐시 된 엔터티 본문과 업데이트 된 헤더 간의 불일치가 방지됩니다. 304 응답이 현재 캐시되지 않은 엔티티를 나타내는 경우, 캐시는 응답을 무시하고 조건없이 요청을 반복해야합니다. 캐시가 수신 된 304 응답을 사용하여 캐시 항목을 업데이트하는 경우 캐시는 응답에 제공된 새로운 필드 값을 반영하도록 항목을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">수신 클라이언트 경우 &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 응답이 TLS로 업그레이드 할 의사와 능력, 그것은 다음 아래 위에 덮여 같은 프로세스 시작해야 &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;TLS에 대한 클라이언트 시작 업그레이드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">데이터가 텍스트 인 경우 텍스트를 포함 할 수 있습니다 (동봉 문서 유형에 따라 적절한 엔티티 또는 이스케이프 사용). 그렇지 않으면 base64로 인코딩 된 이진 데이터를 포함하도록 &lt;code&gt;base64&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">장치가 &quot;Mobi&quot;로 표시되지 않을 정도로 충분히 큰 경우 데스크톱 사이트를 제공해야합니다 (터치 스크린으로 더 많은 데스크톱 컴퓨터가 표시되므로 가장 좋은 방법은 터치 입력을 지원해야 함).</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">해시가 일치하지 않으면 문서가 중간에 편집되었으며 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Precondition Failed&lt;/code&gt; 오류가 발생 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를&lt;/a&gt; 사용하여 요청이 발행되는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하지 않았는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">요청 된 메소드가 지원되지 않으면 서버는 오류로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">지정된 URL의 리소스가 변경되면 새로운 &lt;code&gt;Etag&lt;/code&gt; 값을 생성해야합니다. 따라서 전자 태그는 지문과 유사하며 일부 서버에서 추적 목적으로 사용될 수도 있습니다. 이들을 비교하면 리소스의 두 표현이 동일한 지 여부를 신속하게 확인할 수 있지만 추적 서버에 의해 무기한 지속되도록 설정 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">리소스가 변경된 경우, 서버 는 요청이 조건이없고 클라이언트가이 새 리소스를 사용하고 캐시하는 경우와 같이 새 버전의 리소스와 함께 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 응답을 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">자원이 변경되지 않은 경우 서버는 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 응답을 다시 보냅니다 . 그러면 캐시가 다시 최신 상태가되고 클라이언트는 캐시 된 리소스를 사용합니다. 일부 리소스를 사용하는 응답 / 요청 왕복이 있지만 전체 리소스를 다시 전송하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">문제의 리소스가 GET에 의해 액세스되는 HTTP 리소스와 같이 널리 액세스되도록 의도 된 경우, 리소스에 &lt;a href=&quot;cookies&quot;&gt;쿠키&lt;/a&gt; 및 HTTP 와 같은 자격 증명이 필요한 &lt;strong&gt;경우가 아니면 &lt;/strong&gt;&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; 헤더를 다시 전송 하면됩니다. 인증 정보.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">자원이 보관 제한 요청 도메인을 기반으로해야하는 경우, &lt;strong&gt;또는&lt;/strong&gt; 자원 요구가 자격 증명 (또는 세트 자격 증명)에 액세스 할 경우, 그 요청의 의해 필터링 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 필요가있다 헤더, 또는 적어도 다시 요청자의 메아리 &lt;code&gt;Origin&lt;/code&gt; (예 : &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; ). 또한 &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 헤더를 보내야합니다. 이에 대해서는 &lt;a href=&quot;#Credentialed_Requests&quot;&gt;다음 섹션&lt;/a&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 요청 결과에 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청 후 캐시 된 자원 이 이제 오래 되었다고 표시 되면 &lt;code&gt;GET&lt;/code&gt; 요청이 수행 되지 않은 경우에도 캐시가 무효화 됩니다.</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">응답에 대한 최상의 표현을 선택하는 것이 서버에있는 알고리즘에 의해 수행되는 경우이를 서버 중심 협상이라고합니다. 선택은 응답의 사용 가능한 표현 (예 : 언어, 컨텐츠 코딩 등의 다양한 차원)과 요청 메시지의 특정 헤더 필드 내용 또는 요청과 관련된 기타 정보 (예 : 클라이언트의 네트워크 주소로). 사용 가능한 표현 중에서 선택하기위한 알고리즘이 사용자 에이전트에 설명하기 어렵거나 서버가 첫 번째 응답과 함께 &quot;최상의 추측&quot;을 클라이언트에 보내려고 할 때 서버 중심 협상이 유리합니다. &quot;최상의 추측&quot;인 경우 후속 요청의 왕복 지연사용자에게 충분합니다). 서버의 추측을 향상시키기 위해, 사용자 에이전트는 그러한 응답에 대한 선호도를 기술하는 요청 헤더 필드 (Accept, Accept-Language, Accept-Encoding 등)를 포함 할 수있다. 서버 중심 협상에는 다음과 같은 단점이 있습니다. 1. 사용자 에이전트의 기능과 응답의 의도 된 사용에 대한 완전한 지식이 필요하기 때문에 서버가 특정 사용자에게 &quot;최상의&quot;항목을 정확하게 결정할 수 없습니다. (예 : 사용자가 화면에서 보거나 종이에 인쇄하겠습니까?). 2.사용자 에이전트가 모든 요청에서 해당 기능을 설명하도록하는 것은 매우 비효율적 일 수 있으며 (소수의 응답 만 여러 표현으로 표시됨) 사용자의 개인 정보를 침해 할 가능성이 있습니다. 3. 원 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘을 복잡하게 만듭니다. 4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함됩니다. 수락 (4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함됩니다. 수락 (4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함되어 있습니다. 수락 (&lt;a href=&quot;#section-14.1&quot;&gt;섹션 14.1&lt;/a&gt; ), 수락- 문자셋 ( &lt;a href=&quot;#section-14.2&quot;&gt;섹션 14.2&lt;/a&gt; ), 수락-인코딩 ( &lt;a href=&quot;#section-14.3&quot;&gt;섹션 14.3&lt;/a&gt; ), 수락- 언어 ( &lt;a href=&quot;#section-14.4&quot;&gt;섹션 14.4&lt;/a&gt; ) 및 사용자 에이전트 ( &lt;a href=&quot;#section-14.43&quot;&gt;섹션 14.43&lt;/a&gt; ). 그러나 오리진 서버는 이러한 차원으로 제한되지 않으며 요청 헤더 필드 외부 또는이 사양에서 정의하지 않은 확장 헤더 필드 내의 정보를 포함하여 요청의 모든 측면에 따라 응답을 변경할 수 있습니다. Vary 헤더 필드는 서버가 서버 주도 협상의 대상이되는 표현을 선택하기 위해 서버가 사용하는 매개 변수를 표현하는 데 사용될 수 있습니다. 캐시에 의한 Vary 헤더 필드 사용 및 &lt;a href=&quot;#section-14.44&quot;&gt;섹션 14.44&lt;/a&gt; 는 &lt;a href=&quot;#section-13.6&quot;&gt;섹션 13.6&lt;/a&gt; 을 참조하십시오. 서버에서 Vary 헤더 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">서버 &lt;em&gt;가&lt;/em&gt; TLS 업그레이드를 지원 &lt;em&gt;하지 않거나&lt;/em&gt; 당시 TLS로 업그레이드 할 수없는 경우 다음과 같은 표준 HTTP / 1.1 응답으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">서버 &lt;em&gt;가&lt;/em&gt; TLS 업그레이드를 지원하고 업그레이드를 허용하려는 경우 다음 과 같이 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 응답 코드로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">서버가 CORS 요청이 &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하도록 &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 하는 경우 &lt;code&gt;DELETE&lt;/code&gt; 가 지원하는 다른 메소드와 함께 DELETE 를 나열 하는 Access-Control-Allow-Methods 응답 헤더로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">서버가 지정된 버전의 WebSocket 프로토콜을 사용하여 통신 할 수없는 경우 쉼표로 구분 된 지원되는 목록 이 포함 된 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 헤더를 헤더에 포함하는 오류 (예 : 426 업그레이드 필요)로 응답 합니다. 프로토콜 버전. 서버가 요청한 프로토콜 버전을 지원하는 경우 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 헤더가 응답에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">서버가 일치하는 문자 세트를 제공 할 수없는 경우 이론적으로 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (Not Acceptable) 오류 코드를 다시 보낼 수 있습니다 . 그러나 더 나은 사용자 환경을 위해이 작업은 거의 수행되지 &lt;code&gt;Accept-Charset&lt;/code&gt; 경우 에는 Accept-Charset 헤더 를 무시하는 것이 더 일반적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">서버가 일치하는 언어를 제공 할 수없는 경우 이론적으로 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (Not Acceptable) 오류 코드를 다시 보낼 수 있습니다 . 그러나 더 나은 사용자 환경을 위해이 작업은 거의 수행되지 않으며이 경우 &lt;code&gt;Accept-Language&lt;/code&gt; 헤더 를 무시하는 것이 더 일반적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">서버가 원하는 것을 선택하면 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더를 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">어떤 이유로 든 서버가 HTTP / 2로 전환 할 수없는 경우 요청을 정상적으로 처리 한 후 표준 HTTP / 1 응답으로 응답합니다. 따라서 요청이 실제로 존재하는 웹 페이지를 가져 오려는 경우 나머지 헤더 다음에 웹 페이지에 대한 표준 &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 응답이 표시됩니다. 서버가 HTTP / 2로 전환 할 수있는 경우 &quot; &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 응답이 전송되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">서버가 사용자의 제어하에있는 경우 요청 사이트의 원점을 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 값 에 추가하여 액세스가 허용 된 도메인 세트에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">서버가있는 응답을 보내는 경우 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (오히려 &quot;보다 명시 적 기원 값 &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드), 다음 응답도 포함해야 &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 값과 응답 헤더 &lt;code&gt;Origin&lt;/code&gt; - 브라우저에 표시하기 서버 응답은 &lt;code&gt;Origin&lt;/code&gt; 요청 헤더 의 값에 따라 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">서버가 &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드가 아닌 단일 오리진을 지정하는 경우, 서버 는 서버 응답이 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 요청 헤더 의 값에 따라 다르다는 것을 클라이언트에게 표시하기 위해 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 응답 헤더에 &lt;code&gt;Origin&lt;/code&gt; 을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">서버가 범위 요청을 지원하는 경우 &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더 를 사용하여 해당 요청을 발행 할 수 있습니다 . 서버가 반환해야하는 문서의 일부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">서버가 더 빠른 웹 사이트 또는 응용 프로그램 응답을 원하는 경우 서버가 더 많은 연결을 강제로 열 수 있습니다. 예를 들어, 대신 같은 도메인에 모든 자원을 필요없이 말할 &lt;code&gt;www.example.com&lt;/code&gt; 가 여러 도메인에 걸쳐 분할 수 &lt;code&gt;www1.example.com&lt;/code&gt; , &lt;code&gt;www2.example.com&lt;/code&gt; , &lt;code&gt;www3.example.com&lt;/code&gt; 을 . 이러한 각 도메인은 &lt;em&gt;동일한&lt;/em&gt; 서버로 확인되며 웹 브라우저는 각각 6 개의 연결을 엽니 다 (이 예에서는 연결을 18로 증가). 이 기술을 &lt;em&gt;도메인 샤딩&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">CORS 요청을 사용하여 코드가 액세스하는 서비스가 제어 할 경우, &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더에 오리진 을 포함하도록 구성되어 있고 해당 헤더 중 하나만 응답에 포함되어 있는지 확인하십시오 . 헤더 자체는 쉼표로 구분 된 원점 목록을 허용하므로 새 원점을 추가하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">문자열이 null이면 프록시를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">대상 자원에 현재 표현이 있고 해당 표현이 동봉 된 표현의 상태에 따라 성공적으로 수정 된 경우, 오리진 서버 는 성공적인 완료를 표시하기 위해 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) 또는 &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;No Content&lt;/code&gt; ) 응답을 보내야합니다. 요청.</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">대상 자원에 현재 표시가없고 &lt;code&gt;PUT&lt;/code&gt; 요청이 성공적으로 작성하면, 원 서버는 &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;Created&lt;/code&gt; ) 응답 을 보내 사용자 에이전트에 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">TLS 로의 업그레이드가 성공하면 서버는 이전 섹션에서 설명한대로 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 로 응답 합니다. 업그레이드가 실패하면 HTTP / 1.1 연결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">로컬 도메인에 속하지만 방화벽 외부에 있고 프록시 서버를 통해서만 도달 할 수있는 호스트 (예 : 기본 웹 서버)가있는 경우 &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 함수를 사용하여 이러한 예외를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">세미콜론으로 구분 된 설정이 여러 개인 경우 Firefox가 프록시에 연결하지 못할 때까지 가장 왼쪽에있는 설정이 사용됩니다. 이 경우 다음 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">다른 지시어가 지정되어 있으면 &lt;code&gt;default-src&lt;/code&gt; 는 영향을 미치지 않습니다. 다음 헤더</target>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">응답에 &quot;max-age&quot;또는 &quot;s-maxage&quot;지시문 이있는 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 헤더 가 있으면 &lt;code&gt;Expires&lt;/code&gt; 헤더가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">범위가 하나만있는 경우 전체 응답 의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이 문서 유형으로 설정되고 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">이 지시문이 없으면 사용자 에이전트는 먼저 작업자 실행을 관리 할 때 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾은 다음 &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾은 다음 &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문 ( &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문으로 폴백) 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">이 헤더가 https://example.com/clear-cookies에서 응답과 함께 제공되는 경우 동일한 도메인 https://example.com 및 모든 하위 도메인 (예 : https://stage.example.com 등)의 모든 쿠키 )가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">이 선택적 매개 변수를 지정하면 핀 유효성 검증 실패가 지정된 URL에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">이 선택적 매개 변수를 지정하면이 규칙이 모든 사이트의 하위 도메인에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events를&lt;/a&gt; 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 인지 확인하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API를&lt;/a&gt; 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;&quot;omit&quot;&lt;/code&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">타사 쿠키를 공개하지 않으면 쿠키 사용이 발견되면 소비자 신뢰가 손상 될 수 있습니다. 개인 정보 보호 정책과 같은 명확한 공개는 쿠키 검색의 부정적인 영향을 제거하는 경향이 있습니다. 일부 국가에서는 쿠키에 관한 법률이 있습니다. 예를 들어 Wikimedia Foundation의 &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;쿠키 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">로봇 사용자 에이전트 (예 : 크롤러)를 실행중인 경우 &lt;code&gt;From&lt;/code&gt; 헤더를 보내야하므로 로봇이 과도한 요청, 원하지 않는 요청 또는 잘못된 요청을 보내는 경우와 같이 서버에서 문제가 발생하는 경우 연락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">이 조건이 일시적인지 영구적인지 모를 경우 대신 &lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; 상태 코드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">임시 리디렉션을 설정하지 않으려면 추가 매개 변수 (사용할 HTTP 상태 코드 또는 &lt;code&gt;permanent&lt;/code&gt; 키워드)를 사용하여 다른 리디렉션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">처음부터 WebSocket 연결을 만들어야하는 경우 핸드 셰이 킹 프로세스를 직접 처리해야합니다. 초기 HTTP / 1.1 세션을 작성한 후 다음과 같이 표준 요청에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더 를 추가하여 업그레이드를 요청해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">이 지시문을 사용하여 스크립트 및 스타일에 SRI를 요구하도록 사이트를 설정 한 경우 :</target>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;deny&lt;/code&gt; 를 지정하면 다른 사이트에서로드 할 때 프레임에 페이지를로드하려고 시도 할뿐만 아니라 동일한 사이트에서로드 할 때 실패합니다. 반면에 &lt;code&gt;sameorigin&lt;/code&gt; 을 지정 하면 프레임에 페이지를 포함하는 사이트가 페이지를 제공하는 사이트와 동일한 한 프레임에서 페이지를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">여전히보고를 받고 싶지만 정책을 시행 하려면 &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문 과 함께 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">클라이언트가 다른 헤더에 액세스 할 수있게하려면 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 헤더를 사용하여 나열해야합니다 .</target>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">사용자 에이전트 감지를 사용하지 않으려는 경우 옵션이 있습니다!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램, 서버 또는 프록시가 표준화 된 &lt;code&gt;Forwarded&lt;/code&gt; 헤더를 지원하는 경우 &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; 헤더를 교체 할 수 있습니다. IPv6 주소는 따옴표로 묶어 &lt;code&gt;Forwarded&lt;/code&gt; 대괄호로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">대신 서버의 동작을 조정해야하는 경우 클라이언트가로드 된 원점에 대한 액세스 권한을 부여하기 위해 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 의 값을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">일치하는 경우 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">일치하지 않는 경우 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">일치하지 않는 경우 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">범위 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
        <trans-unit id="bd06e3f28f4c3da6f75241cead3ad85962385407" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 2616)</source>
          <target state="translated">수정되지 않은 경우 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="dc5f0278046c847aae6cb54bbb6bf9f7d5e45609" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since (RFC 7232)</source>
          <target state="translated">수정되지 않은 경우 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ae9940a55ac6950c887c90446b032a2b825302da" translate="yes" xml:space="preserve">
          <source>If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
       [&quot;I am an ETag&quot;])
       ([&quot;I am another ETag&quot;])

   The previous header would require that the resource identified in the
   Request-URI be locked with the specified lock token and be in the
   state identified by the &quot;I am an ETag&quot; ETag or in the state
   identified by the second ETag &quot;I am another ETag&quot;.

   To put the matter more plainly one can think of the previous If
   header as expressing the condition below:

     (
       is-locked-with(urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2) AND
       matches-etag(&quot;I am an ETag&quot;)
     )
     OR
     (
       matches-etag(&quot;I am another ETag&quot;)
     )</source>
          <target state="translated">다음과 같은 경우 : (&amp;lt;urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; [ &quot;나는 ETag입니다&quot;]) ([ &quot;나는 다른 ETag입니다&quot;]) 이전 헤더를 사용하려면 Request- URI는 지정된 잠금 토큰으로 잠겨 있고 &quot;I ETag&quot;ETag로 식별 된 상태이거나 두 번째 ETag &quot;I는 다른 ETag&quot;로 식별 된 상태에 있습니다. 더 명확하게 말하면 이전 If 헤더를 아래 조건을 표현하는 것으로 생각할 수 있습니다. (is-locked-with (urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2) AND matches-etag ( &quot;I am an ETag &quot;)) OR (matches-etag (&quot;나는 다른 ETag &quot;))</target>
        </trans-unit>
        <trans-unit id="e179e2a27f46763d373e2f3b6cb41b4cc29be61b" translate="yes" xml:space="preserve">
          <source>If: (Not &amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;
     &amp;lt;urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;)

   This If header requires that the resource must not be locked with a
   lock having the lock token
   urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 and must be locked by a
   lock with the lock token
   urn:uuid:58f202ac-22cf-11d1-b12d-002035b29092.</source>
          <target state="translated">If : (not &amp;lt;urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt; &amp;lt;urn : uuid : 58f202ac-22cf-11d1-b12d-002035b29092&amp;gt;)이 헤더를 사용하려면 잠금이있는 리소스로 리소스를 잠그지 않아야합니다. 잠금 토큰 urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2이며 잠금 토큰 urn : uuid : 58f202ac-22cf-11d1-b12d-002035b29092를 사용하여 잠금으로 잠 가야합니다.</target>
        </trans-unit>
        <trans-unit id="01602140e2a7c5c326242ee266afd5572f9bb02d" translate="yes" xml:space="preserve">
          <source>Image type</source>
          <target state="translated">이미지 타입</target>
        </trans-unit>
        <trans-unit id="6ae89c7f31fe68afd0052be4204a1384141e4bde" translate="yes" xml:space="preserve">
          <source>Image types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7769fde23e24138d1e8d5303368e943a1ccb83f4" translate="yes" xml:space="preserve">
          <source>Images may load from anywhere (note the &quot;*&quot; wildcard).</source>
          <target state="translated">이미지가 어느 곳에서나로드 될 수 있습니다 ( &quot;*&quot;와일드 카드에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="4c18ce69b9abb0f85c6c4dd561b8fa929e369a90" translate="yes" xml:space="preserve">
          <source>Images/video frames drawn to a canvas using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt;&lt;code&gt;drawImage()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage&quot;&gt; &lt;code&gt;drawImage()&lt;/code&gt; &lt;/a&gt; 사용하여 캔버스에 그린 이미지 / 비디오 프레임 .</target>
        </trans-unit>
        <trans-unit id="f257a0723093d9a811b4ad768559384cb6bd8ec4" translate="yes" xml:space="preserve">
          <source>Implementation notes for applications, vendors, and extensions</source>
          <target state="translated">응용 프로그램, 공급 업체 및 확장에 대한 구현 정보</target>
        </trans-unit>
        <trans-unit id="da02a5e4655c1c65c2babb044e19b5d72a9968f1" translate="yes" xml:space="preserve">
          <source>Implementation-specific header that may have various effects anywhere along the request-response chain. Used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; header is not yet present.</source>
          <target state="translated">요청-응답 체인의 어느 곳에서나 다양한 영향을 미칠 수있는 구현 별 헤더. &lt;code&gt;Cache-Control&lt;/code&gt; 헤더가 아직없는 HTTP / 1.0 캐시와의 하위 호환성을 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1eb8fc6775c68df3e1147c016e8f5a910aa93c4" translate="yes" xml:space="preserve">
          <source>Implementations of HTTP origin servers SHOULD be careful to restrict
   the documents returned by HTTP requests to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs directly into file system calls, the server MUST take
   special care not to serve files that were not intended to be
   delivered to HTTP clients. For example, UNIX, Microsoft Windows, and
   other operating systems use &quot;..&quot; as a path component to indicate a
   directory level above the current one. On such a system, an HTTP
   server MUST disallow any such construct in the Request-URI if it
   would otherwise allow access to a resource outside those intended to
   be accessible via the HTTP server. Similarly, files intended for
   reference only internally to the server (such as access control
   files, configuration files, and script code) MUST be protected from
   inappropriate retrieval, since they might contain sensitive
   information. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security risks.</source>
          <target state="translated">HTTP 오리진 서버의 구현은 HTTP 요청에 의해 리턴 된 문서가 서버 관리자가 의도 한 문서로만 제한하도록주의해야합니다. HTTP 서버가 HTTP URI를 파일 시스템 호출로 직접 변환하는 경우, 서버는 HTTP 클라이언트에 전달되지 않은 파일을 제공하지 않도록 특별히주의해야합니다. 예를 들어, UNIX, Microsoft Windows 및 기타 운영 체제는 &quot;..&quot;를 경로 구성 요소로 사용하여 현재 디렉토리보다 높은 디렉토리 레벨을 나타냅니다. 그러한 시스템에서 HTTP 서버는 HTTP 서버를 통해 액세스 할 수있는 리소스 이외의 리소스에 대한 액세스를 허용하는 경우 Request-URI에서 이러한 구성을 허용하지 않아야합니다. 마찬가지로 서버 내부에서만 참조 할 수있는 파일 (예 : 액세스 제어 파일,구성 파일 및 스크립트 코드)는 민감한 정보를 포함 할 수 있으므로 부적절한 검색으로부터 보호되어야합니다. 경험에 따르면 이러한 HTTP 서버 구현의 사소한 버그가 보안 위험으로 전환 된 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="14daa0dc1eaa5670a20dd5d15e7e163107880fe7" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header in Firefox 4.</source>
          <target state="translated">Firefox 4에서 X-Content-Security-Policy 헤더로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="603ce634b762f92f6e05c3f3e6b9b238a85f5318" translate="yes" xml:space="preserve">
          <source>Implemented as X-Content-Security-Policy header, only supporting 'sandbox' directive.</source>
          <target state="translated">'sandbox'지시문 만 지원하는 X-Content-Security-Policy 헤더로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="3b13dd24d3dc6eaf8faafe83a8f22898c5b86d5d" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Chrome 14.</source>
          <target state="translated">Chrome 14에서 X-Webkit-CSP 헤더로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="b0eba0ad36d67027ac7933274e7042a9d3fc6e6f" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in Safari 6.</source>
          <target state="translated">Safari 6에서 X-Webkit-CSP 헤더로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="cb60fa324f738059434ec9f563fd92bd6eb364fe" translate="yes" xml:space="preserve">
          <source>Implemented as X-Webkit-CSP header in iOS 5.1.</source>
          <target state="translated">iOS 5.1에서 X-Webkit-CSP 헤더로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="60d472d41f188e74df2d9f7da2711afae460cd86" translate="yes" xml:space="preserve">
          <source>Implementers are advised to pay attention to cache controls and to
   make use of the mechanisms available in HTTP when editing Resources,
   in particular, entity-tags as outlined in [&lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;].
   Clients are not assured to receive the most recent representations of
   Collection Members using GET if the server is authorizing
   intermediaries to cache them.</source>
          <target state="translated">구현자는 [ &lt;a href=&quot;#ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ]에 요약 된대로 자원, 특히 엔티티 태그를 편집 할 때 캐시 제어에주의하고 HTTP에서 사용 가능한 메커니즘을 사용하는 것이 좋습니다 . 서버가 중개자에게 캐시를 부여 할 권한이있는 경우 클라이언트는 GET을 사용하여 가장 최근의 콜렉션 멤버 표시를받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3af5ce8ec47b166e13f8ce8cbe13ad9af1cdf60" translate="yes" xml:space="preserve">
          <source>Implementors should be aware that the software represents the user in
   their interactions over the Internet, and should be careful to allow
   the user to be aware of any actions they might take which may have an
   unexpected significance to themselves or others.

   In particular, the convention has been established that the GET and
   HEAD methods SHOULD NOT have the significance of taking an action
   other than retrieval. These methods ought to be considered &quot;safe&quot;.
   This allows user agents to represent other methods, such as POST, PUT
   and DELETE, in a special way, so that the user is made aware of the
   fact that a possibly unsafe action is being requested.

   Naturally, it is not possible to ensure that the server does not
   generate side-effects as a result of performing a GET request; in
   fact, some dynamic resources consider that a feature. The important
   distinction here is that the user did not request the side-effects,
   so therefore cannot be held accountable for them.</source>
          <target state="translated">구현자는 소프트웨어가 인터넷을 통한 상호 작용에서 사용자를 나타내며 사용자가 자신이나 다른 사람에게 예기치 않은 의미를 가질 수있는 조치를 사용자가 인식 할 수 있도록주의해야합니다. 특히, GET 및 HEAD 메소드는 검색 이외의 조치를 취하지 않아야한다는 협약이 확립되었습니다. 이 방법들은 &quot;안전한&quot;것으로 간주되어야합니다. 이를 통해 사용자 에이전트는 POST, PUT 및 DELETE와 같은 다른 방법을 특별한 방식으로 나타낼 수 있으므로 안전하지 않은 조치가 요청되고 있음을 사용자에게 알릴 수 있습니다. 당연히 GET 요청을 수행 한 결과로 서버가 부작용을 일으키지 않도록 보장 할 수는 없습니다. 사실로,일부 동적 자원은 해당 기능을 고려합니다. 여기서 중요한 차이점은 사용자가 부작용을 요청하지 않았으므로 책임을 질 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f5bcb265afe8c10a0333f200168f39077ccb2a2" translate="yes" xml:space="preserve">
          <source>Importance of setting the correct MIME type</source>
          <target state="translated">올바른 MIME 유형 설정의 중요성</target>
        </trans-unit>
        <trans-unit id="50b4adf7a95c03b87b497db3ec73f7756f713782" translate="yes" xml:space="preserve">
          <source>Important MIME types for Web developers</source>
          <target state="translated">웹 개발자를위한 중요한 MIME 유형</target>
        </trans-unit>
        <trans-unit id="a9147f5aaafb06475c8b837fee41cebfad64027d" translate="yes" xml:space="preserve">
          <source>Improved connection management allows considerable boosting of performance in HTTP. With HTTP/1.1 or HTTP/1.0, using a persistent connection &amp;ndash; at least until it becomes idle &amp;ndash; leads to the best performance. However, the failure of pipelining has lead to designing superior connection management models, which have been incorporated into HTTP/2.</source>
          <target state="translated">향상된 연결 관리를 통해 HTTP 성능이 크게 향상됩니다. HTTP / 1.1 또는 HTTP / 1.0에서는 최소한 유휴 상태가 될 때까지 지속적인 연결을 사용하면 최상의 성능을 얻을 수 있습니다. 그러나 파이프 라이닝의 실패로 HTTP / 2에 통합 된 우수한 연결 관리 모델을 설계 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="ed3056eb7dfdbbf414ed2c77758a13ddb4dea4dc" translate="yes" xml:space="preserve">
          <source>In 1989, while he was working at CERN, Tim Berners-Lee wrote a proposal to build a hypertext system over the Internet. Initially calling it the &lt;em&gt;Mesh&lt;/em&gt;, it was later renamed to &lt;em&gt;World Wide Web&lt;/em&gt; during its implementation in 1990. Built over the existing TCP and IP protocols, it consisted of 4 building blocks:</source>
          <target state="translated">1989 년 CERN에서 근무하는 동안 Tim Berners-Lee는 인터넷을 통해 하이퍼 텍스트 시스템을 구축하라는 제안을 작성했습니다. 처음에 그것을 &lt;em&gt;Mesh&lt;/em&gt; 라고 부르고 , 1990 년에 구현하는 동안 나중에 &lt;em&gt;월드 와이드 웹 (World Wide Web)으로&lt;/em&gt; 이름이 변경 되었습니다. 기존 TCP 및 IP 프로토콜을 기반으로 구축되었으며 4 개의 빌딩 블록으로 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc75911a51c61595cb9f9517b6870c9ae4a76b47" translate="yes" xml:space="preserve">
          <source>In 200 (OK) responses to GET or HEAD, an origin server:

   o  SHOULD send an entity-tag validator unless it is not feasible to
      generate one.

   o  MAY send a weak entity-tag instead of a strong entity-tag, if
      performance considerations support the use of weak entity-tags, or
      if it is unfeasible to send a strong entity-tag.

   o  SHOULD send a Last-Modified value if it is feasible to send one.

   In other words, the preferred behavior for an origin server is to
   send both a strong entity-tag and a Last-Modified value in successful
   responses to a retrieval request.

   A client:

   o  MUST send that entity-tag in any cache validation request (using
      If-Match or If-None-Match) if an entity-tag has been provided by
      the origin server. 

   o  SHOULD send the Last-Modified value in non-subrange cache
      validation requests (using If-Modified-Since) if only a
      Last-Modified value has been provided by the origin server.

   o  MAY send the Last-Modified value in subrange cache validation
      requests (using If-Unmodified-Since) if only a Last-Modified value
      has been provided by an HTTP/1.0 origin server.  The user agent
      SHOULD provide a way to disable this, in case of difficulty.

   o  SHOULD send both validators in cache validation requests if both
      an entity-tag and a Last-Modified value have been provided by the
      origin server.  This allows both HTTP/1.0 and HTTP/1.1 caches to
      respond appropriately.</source>
          <target state="translated">GET 또는 HEAD에 대한 200 (OK) 응답에서 오리진 서버 : o 엔티티 태그 검사기를 생성 할 수없는 경우가 아니면 엔티티 태그 검사기를 보내야합니다. o 성능 고려 사항이 취약한 엔티티 태그 사용을 지원하거나 강력한 엔티티 태그를 전송할 수없는 경우 강력한 엔티티 태그 대신 취약한 엔티티 태그를 전송할 수 있습니다. o 가능한 경우 Last-Modified 값을 보내야합니다. 다시 말해, 오리진 서버에 대해 선호되는 동작은 검색 요청에 대한 성공적인 응답으로 강력한 엔티티 태그와 Last-Modified 값을 모두 보내는 것입니다. 클라이언트 : o 오리진 서버가 엔티티 태그를 제공 한 경우 캐시 유효성 검사 요청 (If-Match 또는 If-None-Match 사용)으로 해당 엔티티 태그를 보내야합니다.o 원본 서버에서 Last-Modified 값만 제공 한 경우 하위 범위가 아닌 캐시 유효성 검사 요청 (If-Modified-Since 사용)으로 Last-Modified 값을 보내야합니다. o HTTP / 1.0 오리진 서버에서 Last-Modified 값만 제공 한 경우 하위 범위 캐시 유효성 검사 요청 (If-Unmodified-Since 사용)에서 Last-Modified 값을 보낼 수 있습니다. 사용자 에이전트는 어려움이있을 경우이를 비활성화하는 방법을 제공해야합니다 (SHOULD). o 오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 유효성 검사 요청에서 두 유효성 검사기를 모두 보내야합니다. 이를 통해 HTTP / 1.0 및 HTTP / 1.1 캐시 모두 적절하게 응답 할 수 있습니다.o HTTP / 1.0 오리진 서버에서 Last-Modified 값만 제공 한 경우 하위 범위 캐시 유효성 검사 요청 (If-Unmodified-Since 사용)에서 Last-Modified 값을 보낼 수 있습니다. 사용자 에이전트는 어려움이있을 경우이를 비활성화하는 방법을 제공해야합니다 (SHOULD). o 오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 유효성 검사 요청에서 두 유효성 검사기를 모두 보내야합니다. 이를 통해 HTTP / 1.0 및 HTTP / 1.1 캐시 모두 적절하게 응답 할 수 있습니다.o HTTP / 1.0 오리진 서버에서 Last-Modified 값만 제공 한 경우 하위 범위 캐시 유효성 검사 요청 (If-Unmodified-Since 사용)에서 Last-Modified 값을 보낼 수 있습니다. 사용자 에이전트는 어려움이있을 경우이를 비활성화하는 방법을 제공해야합니다 (SHOULD). o 오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 유효성 검사 요청에서 두 유효성 검사기를 모두 보내야합니다. 이를 통해 HTTP / 1.0 및 HTTP / 1.1 캐시 모두 적절하게 응답 할 수 있습니다.o 오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 유효성 검사 요청에서 두 유효성 검사기를 모두 보내야합니다. 이를 통해 HTTP / 1.0 및 HTTP / 1.1 캐시 모두 적절하게 응답 할 수 있습니다.o 오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 유효성 검사 요청에서 두 유효성 검사기를 모두 보내야합니다. 이를 통해 HTTP / 1.0 및 HTTP / 1.1 캐시 모두 적절하게 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296574e47729d1eae5c728c2cee0ace56802d4ed" translate="yes" xml:space="preserve">
          <source>In 2000, a new pattern for using HTTP was designed: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;representational state transfer&lt;/a&gt; (or REST). The actions induced by the API were no more conveyed by new HTTP methods, but only by accessing specific URIs with basic HTTP/1.1 methods. This allowed any Web application to provide an API to allow retrieval and modification of its data without having to update the browsers or the servers: all what is needed was embedded in the files served by the Web sites through standard HTTP/1.1. The drawback of the REST model resides in the fact that each website defines its own non-standard RESTful API and has total control on it; unlike the *DAV extensions were clients and servers are interoperable. RESTful APIs became very common in the 2010s.</source>
          <target state="translated">2000 년에 HTTP를 사용하기위한 새로운 패턴 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/REST&quot;&gt;표현 상태 전송&lt;/a&gt; (또는 REST) 이 설계되었습니다 . API에 의해 유도 된 조치는 더 이상 새로운 HTTP 메소드로 전달되지 않고 기본 HTTP / 1.1 메소드로 특정 URI에 액세스해야만합니다. 이를 통해 모든 웹 응용 프로그램은 브라우저 나 서버를 업데이트하지 않고도 데이터를 검색하고 수정할 수있는 API를 제공 할 수있었습니다. 필요한 모든 것은 표준 HTTP / 1.1을 통해 웹 사이트에서 제공하는 파일에 포함되었습니다. REST 모델의 단점은 각 웹 사이트가 고유의 비표준 RESTful API를 정의하고 이에 대한 전체 제어 권한이 있다는 사실에 있습니다. * DAV 확장과 달리 클라이언트와 서버는 상호 운용 가능합니다. RESTful API는 2010 년에 매우 일반적이되었습니다.</target>
        </trans-unit>
        <trans-unit id="97be88d1cc954daadbfa1c4539779b9d17810aba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;, a preflight request with the &lt;code&gt;OPTIONS&lt;/code&gt; method is sent, so that the server can respond whether it is acceptable to send the request with these parameters. The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">에서는 &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt; 상기와 플라이트 요청 &lt;code&gt;OPTIONS&lt;/code&gt; 의 방법은 서버가 이러한 매개 변수를 사용하여 요청을 전송 허용 여부 대응할 수 있도록하는 것이, 송신된다. &lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때,은에 전송 될 것이라는 플라이트 요청의 일부로서 서버 &lt;code&gt;POST&lt;/code&gt; 의 요청 방법. &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때, 그것이로 전송됩니다 서버 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 및 &lt;code&gt;Content-Type&lt;/code&gt; 사용자 정의 헤더. 이제 서버는 이러한 상황에서 요청을 수락할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22094d906cb0cb930d1261041451d23d682d9443" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;, &lt;em&gt;&lt;strong&gt;content negotiation&lt;/strong&gt;&lt;/em&gt; is the mechanism that is used for serving different representations of a resource at the same URI, so that the user agent can specify which is best suited for the user (for example, which language of a document, which image format, or which content encoding).</source>
          <target state="translated">에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; , &lt;em&gt;&lt;strong&gt;내용 협상은&lt;/strong&gt;&lt;/em&gt; 사용자 에이전트가 가장 예컨대 사용자 (문서의 언어, 영상 포맷에 적합 지정할 수 그래서 동일한 URI에 자원의 다른 표현을 제공하는 데 사용되는기구이며 또는 어떤 콘텐츠 인코딩).</target>
        </trans-unit>
        <trans-unit id="6df737fe0a6a8b38fe1752df0541af98393864b5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;server-driven content negotiation&lt;/em&gt;, or proactive content negotiation, the browser (or any other kind of user-agent) sends several HTTP headers along with the URL. These headers describe the preferred choice of the user. The server uses them as hints and an internal algorithm chooses the best content to serve to the client. The algorithm is server-specific and not defined in the standard. See, for example, the &lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2 negotiation algorithm&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;em&gt;서버가 주도하는 내용 협상&lt;/em&gt; , 또는 사전 내용 협상 브라우저 (또는 사용자 에이전트의 다른 종류)는 URL과 함께 여러 HTTP 헤더를 보냅니다. 이 헤더는 선호하는 사용자의 선택을 설명합니다. 서버는이 정보를 힌트로 사용하고 내부 알고리즘은 클라이언트에게 제공 할 최상의 콘텐츠를 선택합니다. 이 알고리즘은 서버마다 다르며 표준에 정의되어 있지 않습니다. 예를 들어 &lt;a href=&quot;http://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm&quot;&gt;Apache 2.2 협상 알고리즘을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8513ce94ddf5be70926f38324a0c5067702e67d" translate="yes" xml:space="preserve">
          <source>In Firefox, the preference that disables CORS is &lt;code&gt;content.cors.disable&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; disables CORS, so whenever that's the case, CORS requests will always fail with this error.</source>
          <target state="translated">Firefox에서 CORS를 사용하지 않는 환경 설정은 &lt;code&gt;content.cors.disable&lt;/code&gt; 입니다. 이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 CORS가 비활성화되므로 이러한 경우 CORS 요청은 항상이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="77ae93055516fe4030d75a83ef29b37fe614cda5" translate="yes" xml:space="preserve">
          <source>In HTTP, a redirection is triggered by the server by sending special responses to a request: &lt;em&gt;redirects&lt;/em&gt;. HTTP redirects are responses with a status code of &lt;code&gt;3xx&lt;/code&gt;. A browser, when receiving a redirect response, uses the new URL provided and immediately loads it: most of the time, the redirection is transparent to the user, besides a small performance hit.</source>
          <target state="translated">HTTP에서 리디렉션은 요청에 특별한 응답을 보내어 서버에 의해 트리거됩니다 : &lt;em&gt;redirects&lt;/em&gt; . HTTP 리디렉션은 상태 코드가 &lt;code&gt;3xx&lt;/code&gt; 인 응답입니다 . 브라우저는 리디렉션 응답을받을 때 제공된 새 URL을 사용하여 즉시로드합니다. 대부분의 경우 리디렉션은 약간의 성능 저하 외에 사용자에게 투명합니다.</target>
        </trans-unit>
        <trans-unit id="37f3f173cc83c393621e6b6a49dbe5d27a1b2c33" translate="yes" xml:space="preserve">
          <source>In HTTP/1.0, each connection is established by the client prior to
   the request and closed by the server after sending the response.
   However, some implementations implement the explicitly negotiated
   (&quot;Keep-Alive&quot;) version of persistent connections described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;19.7.1 of [RFC2068]&lt;/a&gt;.

   Some clients and servers might wish to be compatible with these
   previous approaches to persistent connections, by explicitly
   negotiating for them with a &quot;Connection: keep-alive&quot; request header
   field.  However, some experimental implementations of HTTP/1.0
   persistent connections are faulty; for example, if an HTTP/1.0 proxy
   server doesn't understand Connection, it will erroneously forward
   that header field to the next inbound server, which would result in a
   hung connection.

   One attempted solution was the introduction of a Proxy-Connection
   header field, targeted specifically at proxies.  In practice, this
   was also unworkable, because proxies are often deployed in multiple
   layers, bringing about the same problem discussed above.

   As a result, clients are encouraged not to send the Proxy-Connection
   header field in any requests.

   Clients are also encouraged to consider the use of Connection:
   keep-alive in requests carefully; while they can enable persistent
   connections with HTTP/1.0 servers, clients using them will need to
   monitor the connection for &quot;hung&quot; requests (which indicate that the
   client ought stop sending the header field), and this mechanism ought
   not be used by clients at all when a proxy is being used.</source>
          <target state="translated">HTTP / 1.0에서 각 연결은 요청 전에 클라이언트에 의해 설정되고 응답을 보낸 후 서버에 의해 닫힙니다. 그러나 일부 구현 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;은 [RFC2068]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;섹션 &lt;/a&gt;19.7.1에 설명 된 명시 적 협상 ( &quot;Keep-Alive&quot;) 영구 연결 버전을 구현합니다 .. 일부 클라이언트 및 서버는 &quot;연결 : 연결 유지&quot;요청 헤더 필드를 사용하여 명시 적으로 협상하여 이전 연결의 영구 연결 방식과 호환되기를 원할 수 있습니다. 그러나 일부 실험적인 HTTP / 1.0 영구 연결 구현에는 결함이 있습니다. 예를 들어, HTTP / 1.0 프록시 서버가 연결을 이해하지 못하면 해당 헤더 필드를 다음 인바운드 서버로 잘못 전달하여 연결이 정지됩니다. 시도 된 솔루션 중 하나는 프록시를 대상으로하는 프록시 연결 헤더 필드의 도입이었습니다. 실제로 프록시는 종종 여러 계층으로 배포되어 위에서 설명한 동일한 문제가 발생하기 때문에이 또한 실행 불가능했습니다. 결과적으로클라이언트는 요청에 Proxy-Connection 헤더 필드를 보내지 않는 것이 좋습니다. 고객은 또한 Connection의 사용을 고려할 것을 권장합니다. 요청을 신중하게 유지하십시오. HTTP / 1.0 서버와의 지속적인 연결을 활성화 할 수 있지만,이를 사용하는 클라이언트는 &quot;중단 된&quot;요청 (클라이언트가 헤더 필드 전송을 중지해야 함을 나타냄)에 대한 연결을 모니터링해야하며이 메커니즘은 클라이언트에서 사용하지 않아야합니다. 프록시가 사용될 때 모두.요청 (클라이언트가 헤더 필드 전송을 중지해야 함을 나타냄)과 프록시가 사용될 때 클라이언트가이 메커니즘을 전혀 사용하지 않아야합니다.요청 (클라이언트가 헤더 필드 전송을 중지해야 함을 나타냄)과 프록시가 사용될 때 클라이언트가이 메커니즘을 전혀 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="252a80be2932a5745af0ff3008231856ec0831a7" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, method parameter information was exclusively encoded in
   HTTP headers.  Unlike HTTP/1.1, WebDAV encodes method parameter
   information either in an XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) request entity body, or in
   an HTTP header.  The use of XML to encode method parameters was
   motivated by the ability to add extra XML elements to existing
   structures, providing extensibility; and by XML's ability to encode
   information in ISO 10646 character sets, providing
   internationalization support.

   In addition to encoding method parameters, XML is used in WebDAV to
   encode the responses from methods, providing the extensibility and
   internationalization advantages of XML for method output, as well as
   input.

   When XML is used for a request or response body, the Content-Type
   type SHOULD be application/xml.  Implementations MUST accept both
   text/xml and application/xml in request and response bodies.  Use of
   text/xml is deprecated.

   All DAV-compliant clients and resources MUST use XML parsers that are
   compliant with [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] and [&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;].  All XML used in either
   requests or responses MUST be, at minimum, well formed and use
   namespaces correctly.  If a server receives XML that is not well-
   formed, then the server MUST reject the entire request with a 400
   (Bad Request).  If a client receives XML that is not well-formed in a
   response, then the client MUST NOT assume anything about the outcome
   of the executed method and SHOULD treat the server as malfunctioning.

   Note that processing XML submitted by an untrusted source may cause
   risks connected to privacy, security, and service quality (see
   &lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).  Servers MAY reject questionable requests (even though
   they consist of well-formed XML), for instance, with a 400 (Bad
   Request) status code and an optional response body explaining the
   problem.</source>
          <target state="translated">HTTP / 1.1에서는 메소드 매개 변수 정보가 독점적으로 HTTP 헤더로 인코딩되었습니다. HTTP / 1.1과 달리 WebDAV는 메소드 매개 변수 정보를 XML ([ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML)로&lt;/a&gt; 인코딩 합니다.]) 요청 엔터티 본문 또는 HTTP 헤더에서. 메소드 매개 변수를 인코딩하기 위해 XML을 사용하는 것은 기존 구조에 여분의 XML 요소를 추가하여 확장 성을 제공함으로써 가능했습니다. 국제화 지원을 제공하는 ISO 10646 문자 세트로 정보를 인코딩하는 XML의 기능에 의해. 메소드 매개 변수 인코딩 외에도 XML은 WebDAV에서 메소드의 응답을 인코딩하는 데 사용되어 메소드 출력 및 입력에 대한 XML의 확장 성 및 국제화 이점을 제공합니다. 요청 또는 응답 본문에 XML을 사용하는 경우 Content-Type 유형은 application / xml이어야합니다. 구현은 요청 및 응답 본문에서 text / xml 및 application / xml을 모두 수용해야합니다. text / xml 사용은 더 이상 사용되지 않습니다.모든 DAV 호환 클라이언트 및 리소스는 [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ] 및 [ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt; ]. 요청 또는 응답에 사용 된 모든 XML은 최소한 잘 구성되고 네임 스페이스를 올바르게 사용해야합니다. 서버가 제대로 구성되지 않은 XML을 수신하면 서버는 400 (잘못된 요청)으로 전체 요청을 거부해야합니다. 만약 클라이언트가 응답에서 잘 구성되지 않은 XML을 수신한다면, 클라이언트는 실행 된 메소드의 결과에 대해 어떠한 것도 가정해서는 안되며 서버를 오작동으로 취급해야한다. 신뢰할 수없는 출처에서 제출 한 XML을 처리하면 개인 정보 보호, 보안 및 서비스 품질과 관련된 위험이 발생할 수 있습니다 ( &lt;a href=&quot;#section-20&quot;&gt;섹션 20&lt;/a&gt; 참조). ). 서버는 예를 들어 400 (잘못된 요청) 상태 코드와 문제를 설명하는 선택적 응답 본문을 사용하여 문제가있는 요청 (예 : 제대로 구성된 XML로 구성되어 있음)을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04b117019d6e8bc547e56f34a1e382befb6df3b1" translate="yes" xml:space="preserve">
          <source>In HTTP/1.1, persistence is the default, and the header is no longer needed (but it is often added as a defensive measure against cases requiring a fallback to HTTP/1.0).</source>
          <target state="translated">HTTP / 1.1에서는 지속성이 기본값이며 헤더가 더 이상 필요하지 않지만 HTTP / 1.0으로 대체해야하는 경우에 대한 방어 수단으로 추가되는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="7dad8ae742410e88380cfba396cb4fa1d4e9131d" translate="yes" xml:space="preserve">
          <source>In HTTP/2 - the &lt;code&gt;TE&lt;/code&gt; header field is only accepted if the &lt;code&gt;trailers&lt;/code&gt; value is set.</source>
          <target state="translated">HTTP / 2에서 &lt;code&gt;TE&lt;/code&gt; 헤더 필드는 &lt;code&gt;trailers&lt;/code&gt; 값이 설정된 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf70ecd71ae33feef50c75a643497aa1f8c4c6bc" translate="yes" xml:space="preserve">
          <source>In IIS, you use the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; element to configure redirections.</source>
          <target state="translated">IIS에서는 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpredirect&quot;&gt;&amp;lt;httpRedirect&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소를 사용하여 리디렉션을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a73ab14a2ec5bf02be9050f108c718d592c94a24" translate="yes" xml:space="preserve">
          <source>In Nginx, you create a specific server block for the content you want to redirect:</source>
          <target state="translated">Nginx에서 리디렉션하려는 콘텐츠에 대한 특정 서버 블록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="24471cf4aea973802e7f0eb0517d9a17c92a5dcd" translate="yes" xml:space="preserve">
          <source>In PROPFIND responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well.

   200 OK - A property exists and/or its value is successfully returned.

   401 Unauthorized - The property cannot be viewed without appropriate
   authorization.

   403 Forbidden - The property cannot be viewed regardless of
   authentication.

   404 Not Found - The property does not exist.</source>
          <target state="translated">PROPFIND 응답에서 개별 속성에 대한 정보는 'propstat'요소 내에 반환되며 ( &lt;a href=&quot;#section-14.22&quot;&gt;섹션 14.22&lt;/a&gt; 참조 ) 각각에는 속성에 나타나는 속성에 대한 정보가 포함 된 개별 'status'요소가 포함되어 있습니다. 아래 목록은 'propstat'에 사용 된 가장 일반적인 상태 코드를 요약 한 것입니다. 그러나 클라이언트는 다른 2 / 3 / 4 / 5xx 시리즈 상태 코드도 처리 할 수 ​​있도록 준비해야합니다. 200 OK-속성이 존재하거나 값이 성공적으로 반환되었습니다. 401 Unauthorized-권한이 없으면 속성을 볼 수 없습니다. 403 금지-인증에 관계없이 속성을 볼 수 없습니다. 404 찾을 수 없음-속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="86628559f615b8ba5dc79d241d665acce969377c" translate="yes" xml:space="preserve">
          <source>In PROPPATCH responses, information about individual properties is
   returned inside 'propstat' elements (see &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;), each
   containing an individual 'status' element containing information
   about the properties appearing in it.  The list below summarizes the
   most common status codes used inside 'propstat'; however, clients
   should be prepared to handle other 2/3/4/5xx series status codes as
   well. 

   200 (OK) - The property set or change succeeded.  Note that if this
   appears for one property, it appears for every property in the
   response, due to the atomicity of PROPPATCH.

   403 (Forbidden) - The client, for reasons the server chooses not to
   specify, cannot alter one of the properties.

   403 (Forbidden): The client has attempted to set a protected
   property, such as DAV:getetag.  If returning this error, the server
   SHOULD use the precondition code 'cannot-modify-protected-property'
   inside the response body.

   409 (Conflict) - The client has provided a value whose semantics are
   not appropriate for the property.

   424 (Failed Dependency) - The property change could not be made
   because of another property change that failed.

   507 (Insufficient Storage) - The server did not have sufficient space
   to record the property.</source>
          <target state="translated">PROPPATCH 응답에서 개별 속성에 대한 정보는 'propstat'요소 내에 반환됩니다 ( &lt;a href=&quot;#section-14.22&quot;&gt;섹션 14.22&lt;/a&gt; 참조).), 각 속성에는 속성에 대한 정보가 포함 된 개별 'status'요소가 포함되어 있습니다. 아래 목록은 'propstat'에 사용 된 가장 일반적인 상태 코드를 요약 한 것입니다. 그러나 클라이언트는 다른 2 / 3 / 4 / 5xx 시리즈 상태 코드도 처리 할 수 ​​있도록 준비해야합니다. 200 (확인)-속성 설정 또는 변경에 성공했습니다. 이것이 하나의 특성에 대해 나타나는 경우 PROPPATCH의 원 자성으로 인해 응답의 모든 특성에 대해 나타납니다. 403 (Forbidden)-서버가 지정하지 않은 이유로 클라이언트가 속성 중 하나를 변경할 수 없습니다. 403 (Forbidden) : 클라이언트가 DAV : getetag와 같은 보호 된 속성을 설정하려고했습니다. 이 오류를 반환하면 서버는 사전 조건 코드 '수정할 수없는 속성'을 사용해야합니다.응답 본문 내부. 409 (충돌)-클라이언트가 시맨틱이 특성에 적합하지 않은 값을 제공했습니다. 424 (실패 종속성)-실패한 다른 속성 변경으로 인해 속성을 변경할 수 없습니다. 507 (저장소 부족)-서버에 속성을 기록 할 공간이 충분하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4287fa4592630c32398d87b197eab0ac7661318b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request, resulting from an HTML form submission, the &lt;code&gt;Content-Type&lt;/code&gt; of the request is specified by the &lt;code&gt;enctype&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">A의 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청, HTML 양식 제출에서의 결과로, &lt;code&gt;Content-Type&lt;/code&gt; 을 요청이 지정됩니다 &lt;code&gt;enctype&lt;/code&gt; 온 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b96a6a626ade04f611b917e292048082979c2db6" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Request&lt;/a&gt; scenario, the request will be sent with Cookies (e.g. if the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; flag is set on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;). If the server responds with &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; attached to the credentialed response, then the response is accepted by the client and exposed to web content. In a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Request&lt;/a&gt;, the server can respond with &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; to the &lt;code&gt;OPTIONS&lt;/code&gt; request.</source>
          <target state="translated">A의 &lt;a href=&quot;cors#Simple_requests&quot;&gt;단순 요청&lt;/a&gt; 시나리오, 요청이 쿠키로 전송됩니다 (예 경우 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;withCredentials&lt;/a&gt;&lt;/code&gt; 의 플래그가 설정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; ). &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; 응답에 서버가 Access-Control-Allow-Credentials &lt;code&gt;: true&lt;/code&gt; 응답하면 응답이 클라이언트에 의해 수락되어 웹 콘텐츠에 노출됩니다. A의 &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted 요청&lt;/a&gt; , 서버가 응답 할 수 &lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt; 받는 &lt;code&gt;OPTIONS&lt;/code&gt; 요청.</target>
        </trans-unit>
        <trans-unit id="268020b94aef4013d8492a7be59945867c54beea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;multipart/form-data&lt;/code&gt; body, the HTTP &lt;code&gt;Content-Disposition&lt;/code&gt; general header is a header that can be used on the subpart of a multipart body to give information about the field it applies to. The subpart is delimited by the &lt;em&gt;boundary&lt;/em&gt; defined in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header. Used on the body itself, &lt;code&gt;Content-Disposition&lt;/code&gt; has no effect.</source>
          <target state="translated">A의 &lt;code&gt;multipart/form-data&lt;/code&gt; 본체는 HTTP의 &lt;code&gt;Content-Disposition&lt;/code&gt; 일반 헤더는 적용 분야에 대한 정보를 제공하는 다중 체의 서브 파트에 사용될 수있는 헤더이다. 하위 부분은 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더에 정의 된 &lt;em&gt;경계&lt;/em&gt; 로 구분됩니다 . 본문 자체에 사용되는 &lt;code&gt;Content-Disposition&lt;/code&gt; 은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="205c117fa86b98a94b5278af3d27ff4834e8a8cf" translate="yes" xml:space="preserve">
          <source>In a Web page, using JavaScript</source>
          <target state="translated">웹 페이지에서 JavaScript를 사용하여</target>
        </trans-unit>
        <trans-unit id="217ea5cca9699504b57fcecb48b0029845d1abba" translate="yes" xml:space="preserve">
          <source>In a nutshell</source>
          <target state="translated">간단히 말해서</target>
        </trans-unit>
        <trans-unit id="2761e7950da20aac090169d0c4a8c94e9c82afce" translate="yes" xml:space="preserve">
          <source>In a regular HTTP response, the &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; response header is a header indicating if the content is expected to be displayed &lt;em&gt;inline&lt;/em&gt; in the browser, that is, as a Web page or as part of a Web page, or as an &lt;em&gt;attachment&lt;/em&gt;, that is downloaded and saved locally.</source>
          <target state="translated">일반 HTTP 응답에서 &lt;code&gt;&lt;strong&gt;Content-Disposition&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 컨텐츠가 브라우저에 &lt;em&gt;인라인&lt;/em&gt; 으로 표시되는지 , 즉 웹 페이지 또는 웹 페이지의 일부 또는 &lt;em&gt;첨부 파일&lt;/em&gt; 로 표시되는지를 나타내는 헤더 입니다. 다운로드되어 로컬에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="95ef9f1f98a924832244a2938c1f564593efc504" translate="yes" xml:space="preserve">
          <source>In addition to defining the HTTP/1.1 protocol, this document serves
   as the specification for the Internet media type &quot;message/http&quot; and
   &quot;application/http&quot;. The message/http type can be used to enclose a
   single HTTP request or response message, provided that it obeys the
   MIME restrictions for all &quot;message&quot; types regarding line length and
   encodings. The application/http type can be used to enclose a
   pipeline of one or more HTTP request or response messages (not
   intermixed). The following is to be registered with IANA [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;].

       Media Type name:         message
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed message
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none

       Media Type name:         application
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed messages
                 (e.g., &quot;1.1&quot;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &quot;request&quot; or &quot;response&quot;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: HTTP messages enclosed by this type
                 are in &quot;binary&quot; format; use of an appropriate
                 Content-Transfer-Encoding is required when
                 transmitted via E-mail.
       Security considerations: none</source>
          <target state="translated">HTTP / 1.1 프로토콜을 정의하는 것 외에도이 문서는 인터넷 메시지 유형 &quot;message / http&quot;및 &quot;application / http&quot;의 사양으로 사용됩니다. 메시지 / http 유형은 단일 HTTP 요청 또는 응답 메시지를 묶는 데 사용될 수 있습니다. 단, 라인 길이 및 인코딩과 관련된 모든 &quot;메시지&quot;유형에 대한 MIME 제한 사항을 준수해야합니다. application / http 유형을 사용하여 하나 이상의 HTTP 요청 또는 응답 메시지 (혼합되지 않음)의 파이프 라인을 묶을 수 있습니다. 다음은 IANA에 등록됩니다 [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. 미디어 유형 이름 : 메시지 미디어 하위 유형 이름 : http 필수 매개 변수 : 없음 선택 매개 변수 : version, msgtype version : 동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;). 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 줄에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 : &quot;7bit&quot;, &quot;8bit&quot;또는 &quot;binary&quot;만 허용됩니다. 보안 고려 사항 : 없음 미디어 유형 이름 : 응용 프로그램 미디어 하위 유형 이름 : http 필수 매개 변수 :none 선택적 매개 변수 : version, msgtype version : 동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;). 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 줄에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야합니다. 보안 고려 사항 : 없음동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;) 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 줄에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야합니다. 보안 고려 사항 : 없음동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;) 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 줄에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야합니다. 보안 고려 사항 : 없음존재하지 않는 경우, 본문의 첫 번째 행에서 유형을 판별 할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 다음을 통해 전송 될 때 적절한 Content-Transfer-Encoding이 필요합니다. 이메일 보안 고려 사항 : 없음존재하지 않는 경우, 본문의 첫 번째 행에서 유형을 판별 할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 다음을 통해 전송 될 때 적절한 Content-Transfer-Encoding이 필요합니다. 이메일 보안 고려 사항 : 없음</target>
        </trans-unit>
        <trans-unit id="ba23aa0ff8e4e6c04210bb32cbc84ce861b595e8" translate="yes" xml:space="preserve">
          <source>In addition to having &lt;code&gt;Server-Timing&lt;/code&gt; header metrics appear in the developer tools of the browser, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface enables tools to automatically collect and process metrics from JavaScript. This interface is restricted to the same origin, but you can use the &lt;a href=&quot;timing-allow-origin&quot;&gt;&lt;code&gt;Timing-Allow-Origin&lt;/code&gt;&lt;/a&gt; header to specify the domains that are allowed to access the server metrics. The interface is only available in secure contexts (HTTPS) in some browsers.</source>
          <target state="translated">브라우저의 개발자 도구에 &lt;code&gt;Server-Timing&lt;/code&gt; 헤더 메트릭이 표시 될 뿐만 아니라 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 도구가 JavaScript에서 메트릭을 자동으로 수집하고 처리 할 수 ​​있습니다. 이 인터페이스는 동일한 출처로 제한되지만 &lt;a href=&quot;timing-allow-origin&quot;&gt; &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 서버 메트릭에 액세스 할 수있는 도메인을 지정할 수 있습니다. 인터페이스는 일부 브라우저의 보안 컨텍스트 (HTTPS)에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2112dae19cc7c327768fb0823cb8c15ee2b0a2" translate="yes" xml:space="preserve">
          <source>In addition to restricting the domains from which content can be loaded, the server can specify which protocols are allowed to be used; for example (and ideally, from a security standpoint), a server can specify that all content must be loaded using HTTPS. A complete data transmission security strategy includes not only enforcing HTTPS for data transfer, but also marking all &lt;a href=&quot;cookies&quot;&gt;cookies with the secure flag&lt;/a&gt; and providing automatic redirects from HTTP pages to their HTTPS counterparts. Sites may also use the &lt;a href=&quot;headers/strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; HTTP header to ensure that browsers connect to them only over an encrypted channel&lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">컨텐츠를로드 할 수있는 도메인을 제한하는 것 외에도 서버는 사용할 수있는 프로토콜을 지정할 수 있습니다. 예를 들어 (이상적으로는 보안 관점에서) 서버는 모든 컨텐츠가 HTTPS를 사용하여로드되도록 지정할 수 있습니다. 완전한 데이터 전송 보안 전략에는 데이터 전송을 위해 HTTPS를 시행 할뿐만 아니라 모든 &lt;a href=&quot;cookies&quot;&gt;쿠키를 보안 플래그로 표시&lt;/a&gt; 하고 HTTP 페이지에서 HTTPS 상대방으로 자동 리디렉션하는 기능이 포함됩니다. 사이트는 또한 &lt;a href=&quot;headers/strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; HTTP 헤더를 사용하여 브라우저가 암호화 된 채널을 통해서만 브라우저에 연결되도록 할 수 &lt;strong&gt;있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cc3248a0c52202ec569f1b1018d21d9a3d88bcc" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to COPY:

   201 (Created) - The source resource was successfully copied.  The
   COPY operation resulted in the creation of a new resource.

   204 (No Content) - The source resource was successfully copied to a
   preexisting destination resource.

   207 (Multi-Status) - Multiple resources were to be affected by the
   COPY, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a destination resource was locked
   and could not be overwritten, then the destination resource URL
   appears with the 423 (Locked) status.

   403 (Forbidden) - The operation is forbidden.  A special case for
   COPY could be that the source and destination resources are the same
   resource.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   412 (Precondition Failed) - A precondition header check failed, e.g.,
   the Overwrite header is &quot;F&quot; and the destination URL is already mapped
   to a resource. 

   423 (Locked) - The destination resource, or resource within the
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server, repository, or URL namespace.  Either the source namespace
   does not support copying to the destination namespace, or the
   destination namespace refuses to accept the resource.  The client may
   wish to try GET/PUT and PROPFIND/PROPPATCH instead.

   507 (Insufficient Storage) - The destination resource does not have
   sufficient space to record the state of the resource after the
   execution of this method.</source>
          <target state="translated">가능한 일반 상태 코드 외에도 다음 상태 코드는 COPY에 적용 가능합니다. 201 (작성 됨)-소스 자원이 성공적으로 복사되었습니다. COPY 조작으로 새 자원이 작성되었습니다. 204 (No Content)-소스 리소스가 기존 대상 리소스에 성공적으로 복사되었습니다. 207 (Multi-Status)-여러 리소스가 COPY의 영향을 받았지만 일부 리소스의 오류로 인해 작업이 수행되지 못했습니다. 가장 적합한 소스 및 도착 URL과 함께 특정 오류 메시지가 다중 상태 응답 본문에 나타납니다. 예를 들어 대상 리소스가 잠겨있어 덮어 쓸 수없는 경우 대상 리소스 URL이 423 (잠김) 상태로 나타납니다.403 (Forbidden)-작업이 금지되어 있습니다. COPY의 특별한 경우는 소스 및 대상 리소스가 동일한 리소스 일 수 있습니다. 409 (충돌)-하나 이상의 중간 컬렉션을 만들 때까지 대상에서 리소스를 만들 수 없습니다. 서버는 이러한 중간 컬렉션을 자동으로 생성해서는 안됩니다. 412 (사전 조건 실패)-사전 조건 헤더 검사에 실패했습니다. 예를 들어, 덮어 쓰기 헤더가 &quot;F&quot;이고 대상 URL이 이미 리소스에 매핑되어 있습니다. 423 (Locked)-대상 자원 또는 대상 콜렉션 내의 자원이 잠겼습니다. 이 응답은 'lock-token-submitted'전제 조건 요소를 포함해야한다. 502 (Bad Gateway)-대상이 다른 서버, 리포지토리 또는 URL 네임 스페이스에있을 때 발생할 수 있습니다.소스 네임 스페이스가 대상 네임 스페이스에 대한 복사를 지원하지 않거나 대상 네임 스페이스가 리소스 수락을 거부합니다. 클라이언트는 대신 GET / PUT 및 PROPFIND / PROPPATCH를 시도 할 수 있습니다. 507 (저장소 부족)-대상 자원에이 방법을 실행 한 후 자원 상태를 기록하기에 충분한 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee897ff0362cf4245c71fb432f38bd23904179b3" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to LOCK:

   200 (OK) - The LOCK request succeeded and the value of the DAV:
   lockdiscovery property is included in the response body.

   201 (Created) - The LOCK request was to an unmapped URL, the request
   succeeded and resulted in the creation of a new resource, and the
   value of the DAV:lockdiscovery property is included in the response
   body. 

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.

   423 (Locked), potentially with 'no-conflicting-lock' precondition
   code - There is already a lock on the resource that is not compatible
   with the requested lock (see lock compatibility table above).

   412 (Precondition Failed), with 'lock-token-matches-request-uri'
   precondition code - The LOCK request was made with an If header,
   indicating that the client wishes to refresh the given lock.
   However, the Request-URI did not fall within the scope of the lock
   identified by the token.  The lock may have a scope that does not
   include the Request-URI, or the lock could have disappeared, or the
   token may be invalid.</source>
          <target state="translated">가능한 일반 상태 코드 외에도 다음 상태 코드는 LOCK에 적용 가능합니다. 200 (확인)-LOCK 요청이 성공했으며 DAV : lockdiscovery 특성의 값이 응답 본문에 포함되어 있습니다. 201 (작성 됨)-LOCK 요청이 맵핑되지 않은 URL에 대한 것이며 요청이 성공하여 새 자원이 작성되었으며 DAV : lockdiscovery 특성 값이 응답 본문에 포함되었습니다. 409 (충돌)-하나 이상의 중간 컬렉션을 만들 때까지 대상에서 리소스를 만들 수 없습니다. 서버는 이러한 중간 컬렉션을 자동으로 생성해서는 안됩니다. 423 (잠김), 잠재적으로 '충돌 방지'전제 조건 코드-요청 된 잠금과 호환되지 않는 자원에 대한 잠금이 이미 있습니다 (위의 잠금 호환성 표 참조). 412 (사전 조건 실패), 'lock-token-matches-request-uri'사전 조건 코드-잠금 요청은 If 헤더를 사용하여 클라이언트가 지정된 잠금을 새로 고치려고 함을 나타냅니다. 그러나 Request-URI는 토큰으로 식별 된 잠금 범위 내에 있지 않습니다. 잠금에 Request-URI가 포함되지 않은 범위가 있거나 잠금이 사라 졌거나 토큰이 유효하지 않을 수 있습니다.Request-URI는 토큰으로 식별 된 잠금 범위 내에 있지 않습니다. 잠금에 Request-URI가 포함되지 않은 범위가 있거나 잠금이 사라 졌거나 토큰이 유효하지 않을 수 있습니다.Request-URI는 토큰으로 식별 된 잠금 범위 내에 있지 않습니다. 잠금에 Request-URI가 포함되지 않은 범위가 있거나 잠금이 사라 졌거나 토큰이 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26231e92d79838933371916af08188230312c93" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MKCOL:

   201 (Created) - The collection was created.

   403 (Forbidden) - This indicates at least one of two conditions: 1)
   the server does not allow the creation of collections at the given
   location in its URL namespace, or 2) the parent collection of the
   Request-URI exists but cannot accept members.

   405 (Method Not Allowed) - MKCOL can only be executed on an unmapped
   URL.

   409 (Conflict) - A collection cannot be made at the Request-URI until
   one or more intermediate collections have been created.  The server
   MUST NOT create those intermediate collections automatically.

   415 (Unsupported Media Type) - The server does not support the
   request body type (although bodies are legal on MKCOL requests, since
   this specification doesn't define any, the server is likely not to
   support any given body type).

   507 (Insufficient Storage) - The resource does not have sufficient
   space to record the state of the resource after the execution of this
   method.</source>
          <target state="translated">가능한 일반 상태 코드 외에도 다음 상태 코드는 MKCOL에 적용 할 수 있습니다. 201 (만들기)-컬렉션이 만들어졌습니다. 403 (금지됨)-다음 두 조건 중 하나 이상을 나타냅니다. 1) 서버가 URL 네임 스페이스의 지정된 위치에서 모음을 만들 수 없거나 2) Request-URI의 부모 모음이 존재하지만 구성원을 수락 할 수 없음 . 405 (Method Not Allowed)-매핑되지 않은 URL에서만 MKCOL을 실행할 수 있습니다. 409 (충돌)-하나 이상의 중간 콜렉션이 작성 될 때까지 Request-URI에서 콜렉션을 작성할 수 없습니다. 서버는 이러한 중간 컬렉션을 자동으로 생성해서는 안됩니다. 415 (지원되지 않는 미디어 유형)-서버가 요청 본문 유형을 지원하지 않습니다 (본문은 MKCOL 요청에 대해 합법적이지만,이 사양은 어떤 것도 정의하지 않기 때문에 서버는 주어진 신체 유형을 지원하지 않을 것입니다). 507 (Insufficient Storage)-이 방법을 실행 한 후 리소스의 상태를 기록 할 공간이 부족합니다.</target>
        </trans-unit>
        <trans-unit id="abd88f2d1d87ef7a1f30945f9393736f0e9efad8" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to MOVE:

   201 (Created) - The source resource was successfully moved, and a new
   URL mapping was created at the destination.

   204 (No Content) - The source resource was successfully moved to a
   URL that was already mapped.

   207 (Multi-Status) - Multiple resources were to be affected by the
   MOVE, but errors on some of them prevented the operation from taking
   place.  Specific error messages, together with the most appropriate
   of the source and destination URLs, appear in the body of the multi-
   status response.  For example, if a source resource was locked and
   could not be moved, then the source resource URL appears with the 423
   (Locked) status.

   403 (Forbidden) - Among many possible reasons for forbidding a MOVE
   operation, this status code is recommended for use when the source
   and destination resources are the same.

   409 (Conflict) - A resource cannot be created at the destination
   until one or more intermediate collections have been created.  The
   server MUST NOT create those intermediate collections automatically.
   Or, the server was unable to preserve the behavior of the live
   properties and still move the resource to the destination (see
   'preserved-live-properties' postcondition).

   412 (Precondition Failed) - A condition header failed.  Specific to
   MOVE, this could mean that the Overwrite header is &quot;F&quot; and the
   destination URL is already mapped to a resource.

   423 (Locked) - The source or the destination resource, the source or
   destination resource parent, or some resource within the source or
   destination collection, was locked.  This response SHOULD contain the
   'lock-token-submitted' precondition element.

   502 (Bad Gateway) - This may occur when the destination is on another
   server and the destination server refuses to accept the resource.
   This could also occur when the destination is on another sub-section
   of the same server namespace.</source>
          <target state="translated">가능한 일반 상태 코드 외에도 다음 상태 코드는 MOVE에 적용 할 수 있습니다. 201 (작성 됨)-소스 자원이 성공적으로 이동되었으며 대상에서 새 URL 맵핑이 작성되었습니다. 204 (No Content)-소스 자원이 이미 맵핑 된 URL로 이동되었습니다. 207 (Multi-Status)-여러 리소스가 MOVE의 영향을 받았지만 일부 리소스의 오류로 인해 작업이 수행되지 못했습니다. 가장 적합한 소스 및 도착 URL과 함께 특정 오류 메시지가 다중 상태 응답 본문에 나타납니다. 예를 들어 소스 리소스가 잠겨있어 이동할 수없는 경우 소스 리소스 URL은 423 (잠김) 상태로 나타납니다.403 (금지됨)-MOVE 조작을 금지하는 여러 가지 가능한 이유 중 소스 및 대상 자원이 동일한 경우이 상태 코드를 사용하는 것이 좋습니다. 409 (충돌)-하나 이상의 중간 컬렉션을 만들 때까지 대상에서 리소스를 만들 수 없습니다. 서버는 이러한 중간 컬렉션을 자동으로 생성해서는 안됩니다. 또는 서버가 라이브 속성의 동작을 유지하지 못하고 여전히 리소스를 대상으로 옮길 수 없습니다 ( 'preserved-live-properties'사후 조건 참조). 412 (전제 조건 실패)-조건 헤더가 실패했습니다. MOVE와 관련하여 이는 덮어 쓰기 헤더가 &quot;F&quot;이고 대상 URL이 이미 리소스에 매핑되었음을 의미 할 수 있습니다. 423 (Locked)-소스 또는 대상 리소스소스 또는 대상 자원 상위 또는 소스 또는 대상 콜렉션 내의 일부 자원이 잠겼습니다. 이 응답은 'lock-token-submitted'전제 조건 요소를 포함해야한다. 502 (Bad Gateway)-대상이 다른 서버에 있고 대상 서버가 리소스 수락을 거부 할 때 발생할 수 있습니다. 대상이 동일한 서버 네임 스페이스의 다른 하위 섹션에있는 경우에도 발생할 수 있습니다.대상이 동일한 서버 네임 스페이스의 다른 하위 섹션에있는 경우에도 발생할 수 있습니다.대상이 동일한 서버 네임 스페이스의 다른 하위 섹션에있는 경우에도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4629e09c06eba402676b36f28c77b568459e792b" translate="yes" xml:space="preserve">
          <source>In addition to the general status codes possible, the following
   status codes have specific applicability to UNLOCK:

   204 (No Content) - Normal success response (rather than 200 OK, since
   200 OK would imply a response body, and an UNLOCK success response
   does not normally contain a body).

   400 (Bad Request) - No lock token was provided.

   403 (Forbidden) - The currently authenticated principal does not have
   permission to remove the lock.

   409 (Conflict), with 'lock-token-matches-request-uri' precondition -
   The resource was not locked, or the request was made to a Request-URI
   that was not within the scope of the lock.</source>
          <target state="translated">가능한 일반적인 상태 코드 외에도 다음 상태 코드는 UNLOCK에 적용 할 수 있습니다. 204 (콘텐츠 없음)-정상 성공 응답 (200 OK는 200이 아니라 응답 본문을 의미하므로 UNLOCK 성공 응답은 그렇지 않음) 일반적으로 신체를 포함). 400 (잘못된 요청)-잠금 토큰이 제공되지 않았습니다. 403 (Forbidden)-현재 인증 된 보안 주체가 잠금을 제거 할 권한이 없습니다. 409 (충돌), 'lock-token-matches-request-uri'사전 조건-자원이 잠기지 않았거나 잠금 범위 내에 있지 않은 Request-URI에 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e2b59b56283e49cf87a4756ab287a316a572fba" translate="yes" xml:space="preserve">
          <source>In addition to these large extensions, numerous other headers have been added, sometimes experimentally only. Notable headers are Do Not Track (&lt;a href=&quot;../headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt;) header to control privacy, &lt;a href=&quot;../headers/x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt;&lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt;&lt;/a&gt; but many more exist.</source>
          <target state="translated">이러한 큰 확장 외에도 많은 다른 헤더가 추가되었으며 때로는 실험적으로 만 추가되었습니다. 주목할만한 헤더는 프라이버시, &lt;a href=&quot;../headers/x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/upgrade-insecure-requests&quot;&gt; &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; &lt;/a&gt; 를 제어하는 &lt;a href=&quot;../headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt; (Do Not Track ) 헤더 이지만 더 많이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3b131cf2fd0e3eeeeb8387fc020ce526e5bb2a21" translate="yes" xml:space="preserve">
          <source>In addition to these usual redirections, there are two specific redirections. The &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) redirects a page to the locally cached copy (that was stale), and &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choice) is a manual redirection: the body, presented by the browser as a Web page, lists the possible redirections and the user clicks on one to select it.</source>
          <target state="translated">이러한 일반적인 리디렉션 외에도 두 가지 특정 리디렉션이 있습니다. &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; (수정되지 않음) 로컬로 캐시 된 복사본 (즉 오래된이었다)에 페이지를 리디렉션 및 &lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (복수 선택)는 수동 리디렉션입니다 : 몸, 웹 페이지로 브라우저에 의해 제시 목록 가능한 리디렉션 및 사용자 하나를 클릭하여 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="d635ae50b7ab2f51933a439ac178e121013926c5" translate="yes" xml:space="preserve">
          <source>In addition to these, there is an experimental proposal to add more headers to the list of available headers, called &lt;em&gt;client hints&lt;/em&gt;. Client hints advertise what kind of device the user agent runs on (for example, if it is a desktop computer or a mobile device).</source>
          <target state="translated">이외에도 사용 가능한 헤더 목록에 더 많은 헤더 ( &lt;em&gt;클라이언트 힌트)&lt;/em&gt; 를 추가하는 실험적인 제안이 있습니다 . 클라이언트 힌트는 사용자 에이전트가 실행하는 장치의 종류 (예 : 데스크톱 컴퓨터 또는 모바일 장치 인 경우)를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="452c8d06b2f6623a8650c4fa111cc03980282cde" translate="yes" xml:space="preserve">
          <source>In an HTTP URL, the first substring that follows the initial &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt; is called the domain name. This domain name is hosted on a server where the document resides.</source>
          <target state="translated">HTTP URL에서 초기 &lt;code&gt;http://&lt;/code&gt; 또는 &lt;code&gt;https://&lt;/code&gt; 뒤에 오는 첫 번째 하위 문자열을 도메인 이름이라고합니다. 이 도메인 이름은 문서가있는 서버에서 호스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="c6a374d59d054a3737c0b7d32f324c37547cb7c5" translate="yes" xml:space="preserve">
          <source>In both cases it's clear, conditional requests are a fundamental feature behind the Web.</source>
          <target state="translated">두 경우 모두 조건부 요청은 웹의 기본 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b7d3d4c052ce3a72008b8168b5362d9899fce376" translate="yes" xml:space="preserve">
          <source>In both cases, the user can't do much (unless a corruption is happening on their side, like a mismatch of cache or cookies).</source>
          <target state="translated">두 경우 모두 캐시 또는 쿠키의 불일치와 같이 부패가 발생하지 않는 한 사용자는 많은 것을 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="891082881f414bc74764d1a5ea2c1afe84e85946" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">브라우저에서 지원 있다고 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지시어는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="99d503921123b6885340a4372a8a6b0ea5626e01" translate="yes" xml:space="preserve">
          <source>In browsers that support &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive will be ignored.</source>
          <target state="translated">브라우저에서 지원 있다고 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지시어는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2eeb5d5719bfe66a723ed9a7de204a618f713d1f" translate="yes" xml:space="preserve">
          <source>In case of a range request that is out of bounds (range values overlap the extent of the resource), the server responds with a &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; status.</source>
          <target state="translated">범위를 벗어난 범위 ​​요청 (범위 값이 리소스 범위와 겹침) 인 ​​경우 서버는 &lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Requested Range Not Satisfiable&lt;/code&gt; 상태로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="fe1bbb314fd4c01d67a4a1927444c74b1ecc3b84" translate="yes" xml:space="preserve">
          <source>In case of a successful range request, the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">범위 요청이 성공하면 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 상태가 서버에서 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="aedd7950da9e5893c670001b73efaf8f02facdd1" translate="yes" xml:space="preserve">
          <source>In case of no support of range requests, the &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status is sent back from a server.</source>
          <target state="translated">범위 요청을 지원하지 않는 경우 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태가 서버에서 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="73542c18d725b27c3411be51053fdddc86d53fc0" translate="yes" xml:space="preserve">
          <source>In cases of redirection, the HTTP method used to make the new request to fetch the page pointed to by &lt;code&gt;Location&lt;/code&gt; depends of the original method and of the kind of redirection:</source>
          <target state="translated">리디렉션의 경우 &lt;code&gt;Location&lt;/code&gt; 에서 가리키는 페이지를 가져 오기 위해 새 요청을 작성하는 데 사용되는 HTTP 메서드 는 원래 메서드와 리디렉션 종류에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="400b65ba68994eae44783d4597cd6426d0ef1020" translate="yes" xml:space="preserve">
          <source>In cases of resource creation, it indicates the URL to the newly created resource.</source>
          <target state="translated">자원 작성의 경우 새로 작성된 자원의 URL을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="83f79ebc079d3c0c0d4572bcf4378eb80a9d0af2" translate="yes" xml:space="preserve">
          <source>In client-server protocols, it is the client which establishes the connection. Opening a connection in HTTP means initiating a connection in the underlying transport layer, usually this is TCP.</source>
          <target state="translated">클라이언트-서버 프로토콜에서 연결을 설정하는 것은 클라이언트입니다. HTTP에서 연결을 여는 것은 기본 전송 계층에서 연결을 시작하는 것을 의미합니다. 일반적으로 TCP입니다.</target>
        </trans-unit>
        <trans-unit id="8c10db7321992e2a8f17abad3e89745464a5099e" translate="yes" xml:space="preserve">
          <source>In client-server protocols, like HTTP, sessions consist of three phases:</source>
          <target state="translated">HTTP와 같은 클라이언트-서버 프로토콜에서 세션은 세 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9a70e3c7b55315e54b4db55bc22d039b7ec58c" translate="yes" xml:space="preserve">
          <source>In conjunction with a range request with a &lt;a href=&quot;if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; header, it can be used to ensure that the new fragment requested comes from an unmodified document.</source>
          <target state="translated">&lt;a href=&quot;if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; 헤더 가있는 범위 요청과 함께 요청 된 새 조각이 수정되지 않은 문서에서 오는지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ab6733bb319a29784b72221a4697f634e9bdd1" translate="yes" xml:space="preserve">
          <source>In conjunction with non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, it can be used to implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;optimistic concurrency control&lt;/a&gt;, like done by some wikis: editions are rejected if the stored document has been modified since the original has been retrieved.</source>
          <target state="translated">&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전하지&lt;/a&gt; 않은 메소드 와 함께 일부 위키에서와 같이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;낙관적 동시성 제어&lt;/a&gt; 를 구현하는 데 사용할 수 있습니다 . 원본을 검색 한 후 저장된 문서가 수정 된 경우 에디션이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="fbebaf8ae5ad813c6e5579cad204cc0afeb3f2a6" translate="yes" xml:space="preserve">
          <source>In early versions of HTTP/1.1, a default charset (&lt;code&gt;ISO-8859-1&lt;/code&gt;) was defined. This is no more the case and now each content type may have its own default.</source>
          <target state="translated">HTTP / 1.1의 초기 버전에서는 기본 문자 세트 ( &lt;code&gt;ISO-8859-1&lt;/code&gt; )가 정의되었습니다. 이것은 더 이상 사실이 아니며 이제 각 컨텐츠 유형마다 고유 한 기본값이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b87dd4cff176256a7ffd91b11051848e914ccf" translate="yes" xml:space="preserve">
          <source>In general, you don't need to do anything to manage prefetching. However, the user may wish to disable prefetching. On Firefox, this can be done by setting the &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; preference to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">일반적으로 프리 페치를 관리하기 위해 수행 할 작업이 없습니다. 그러나 사용자는 프리 페치를 비활성화 할 수 있습니다. Firefox에서는 &lt;code&gt;network.dns.disablePrefetch&lt;/code&gt; 환경 설정을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="674099d2a81c401b8baaba7396a1a690e7a583af" translate="yes" xml:space="preserve">
          <source>In most cases, the policy-controlled features represent functionality that when used will negatively impact the user experience. To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. Best practices are then enforced by using policies that disable the policy-controlled features. For more details see &quot;Enforcing best practices for good user experiences&quot;.</source>
          <target state="translated">대부분의 경우 정책 제어 기능은 사용시 사용자 경험에 부정적인 영향을주는 기능을 나타냅니다. 기존 웹 컨텐츠를 손상시키지 않으려면 이러한 정책 제어 기능의 기본값은 모든 출처에서 기능을 사용할 수 있도록하는 것입니다. 그런 다음 정책 제어 기능을 비활성화하는 정책을 사용하여 모범 사례를 시행합니다. 자세한 내용은 &quot;좋은 사용자 환경을위한 모범 사례 시행&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5408e40c9a5920880e7570b54ae2fe87a76b064d" translate="yes" xml:space="preserve">
          <source>In opposition to the previous &lt;code&gt;Accept-*&lt;/code&gt; headers which are sent by the client, the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP header is sent by the web server in its response. It indicates the list of headers used by the server during the server-driven content negotiation phase. The header is needed in order to inform the cache of the decision criteria so that it can reproduce it, allowing the cache to be functional while preventing serving erroneous content to the user.</source>
          <target state="translated">클라이언트가 보낸 이전 &lt;code&gt;Accept-*&lt;/code&gt; 헤더와 달리 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP 헤더는 응답으로 웹 서버에서 보냅니다. 서버 구동 컨텐츠 협상 단계에서 서버가 사용하는 헤더 목록을 나타냅니다. 헤더는 결정 기준을 캐시에 통지하여이를 재현 할 수 있도록하기 위해 필요하며, 사용자에게 잘못된 컨텐츠를 제공하는 것을 방지하면서 캐시가 기능 할 수있게한다.</target>
        </trans-unit>
        <trans-unit id="badfc139e7e8ad666da707d60e16523bcd32cfa3" translate="yes" xml:space="preserve">
          <source>In order to decide whether a response is fresh or stale, we need to
   compare its freshness lifetime to its age. The age is calculated as
   described in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;; this section describes how to calculate
   the freshness lifetime, and to determine if a response has expired.
   In the discussion below, the values can be represented in any form
   appropriate for arithmetic operations.

   We use the term &quot;expires_value&quot; to denote the value of the Expires
   header. We use the term &quot;max_age_value&quot; to denote an appropriate
   value of the number of seconds carried by the &quot;max-age&quot; directive of
   the Cache-Control header in a response (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;).

   The max-age directive takes priority over Expires, so if max-age is
   present in a response, the calculation is simply:

      freshness_lifetime = max_age_value

   Otherwise, if Expires is present in the response, the calculation is:

      freshness_lifetime = expires_value - date_value

   Note that neither of these calculations is vulnerable to clock skew,
   since all of the information comes from the origin server.

   If none of Expires, Cache-Control: max-age, or Cache-Control: s-
   maxage (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;) appears in the response, and the response
   does not include other restrictions on caching, the cache MAY compute
   a freshness lifetime using a heuristic. The cache MUST attach Warning
   113 to any response whose age is more than 24 hours if such warning
   has not already been added.

   Also, if the response does have a Last-Modified time, the heuristic
   expiration value SHOULD be no more than some fraction of the interval
   since that time. A typical setting of this fraction might be 10%.

   The calculation to determine if a response has expired is quite
   simple:

      response_is_fresh = (freshness_lifetime &amp;gt; current_age)</source>
          <target state="translated">응답이 신선하거나 오래된 지 여부를 결정하려면 신선도 수명과 연령을 비교해야합니다. 연령은 &lt;a href=&quot;#section-13.2.3&quot;&gt;섹션 13.2.3에&lt;/a&gt; 설명 된대로 계산됩니다 . 이 섹션에서는 신선도 수명을 계산하고 응답이 만료되었는지 확인하는 방법에 대해 설명합니다. 아래의 논의에서, 값은 산술 연산에 적합한 임의의 형태로 표현 될 수있다. &quot;expires_value&quot;라는 용어를 사용하여 Expires 헤더의 값을 나타냅니다. &quot;max_age_value&quot;라는 용어는 응답에서 Cache-Control 헤더의 &quot;max-age&quot;지시어에 의해 전달 된 초 수의 적절한 값을 나타냅니다 ( &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; 참조).). max-age 지시문은 Expires보다 우선하므로 응답에 max-age가 있으면 계산은 간단합니다. freshness_lifetime = max_age_value 그렇지 않으면 Expires가 응답에 있으면 계산은 다음과 같습니다. freshness_lifetime = expires_value-date_value 참고 모든 정보는 원본 서버에서 가져 오기 때문에 이러한 계산 중 어느 것도 클럭 스큐에 취약하지 않습니다. 만료, Cache-Control : max-age 또는 Cache-Control : s-maxage가없는 경우 ( &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; 참조))가 응답에 표시되고 응답에 캐싱에 대한 다른 제한이 포함되지 않은 경우 캐시는 휴리스틱을 사용하여 최신 수명을 계산할 수 있습니다. 캐시는 이러한 경고가 아직 추가되지 않은 경우 연령이 24 시간을 초과하는 응답에 반드시 경고 113을 첨부해야합니다. 또한 응답에 Last-Modified 시간이있는 경우 휴리스틱 만료 값은 해당 시간 이후 간격의 일부를 넘지 않아야합니다 (SHOULD). 이 분수의 일반적인 설정은 10 % 일 수 있습니다. 응답이 만료되었는지 확인하는 계산은 매우 간단합니다. response_is_fresh = (freshness_lifetime&amp;gt; current_age)</target>
        </trans-unit>
        <trans-unit id="d03e66527d9041fe3d196b0602d934ec30eb980d" translate="yes" xml:space="preserve">
          <source>In order to fix this problem, Mozilla changed the behavior of loading resource: URIs in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;bug 863246&lt;/a&gt;, which landed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;Firefox 57 (Quantum)&lt;/a&gt;.</source>
          <target state="translated">이 문제를 해결하기 위해 Mozilla는 리소스 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/57&quot;&gt;57&lt;/a&gt; : &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=863246&quot;&gt;버그 863246의&lt;/a&gt; URI 동작을 변경했습니다. 버그 는 Firefox 57 (Quantum)에 있었습니다.</target>
        </trans-unit>
        <trans-unit id="e3cacbc626f64e05a875aafa03b69d5da76a91ff" translate="yes" xml:space="preserve">
          <source>In order to know if a cached entry is fresh, a cache needs to know if
   its age exceeds its freshness lifetime. We discuss how to calculate
   the latter in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;; this section describes how to calculate
   the age of a response or cache entry.

   In this discussion, we use the term &quot;now&quot; to mean &quot;the current value
   of the clock at the host performing the calculation.&quot; Hosts that use
   HTTP, but especially hosts running origin servers and caches, SHOULD
   use NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;] or some similar protocol to synchronize their clocks to
   a globally accurate time standard. 

   HTTP/1.1 requires origin servers to send a Date header, if possible,
   with every response, giving the time at which the response was
   generated (see &lt;a href=&quot;#section-14.18&quot;&gt;section 14.18&lt;/a&gt;). We use the term &quot;date_value&quot; to denote
   the value of the Date header, in a form appropriate for arithmetic
   operations.

   HTTP/1.1 uses the Age response-header to convey the estimated age of
   the response message when obtained from a cache. The Age field value
   is the cache's estimate of the amount of time since the response was
   generated or revalidated by the origin server.

   In essence, the Age value is the sum of the time that the response
   has been resident in each of the caches along the path from the
   origin server, plus the amount of time it has been in transit along
   network paths.

   We use the term &quot;age_value&quot; to denote the value of the Age header, in
   a form appropriate for arithmetic operations.

   A response's age can be calculated in two entirely independent ways:

      1. now minus date_value, if the local clock is reasonably well
         synchronized to the origin server's clock. If the result is
         negative, the result is replaced by zero.

      2. age_value, if all of the caches along the response path
         implement HTTP/1.1.

   Given that we have two independent ways to compute the age of a
   response when it is received, we can combine these as

       corrected_received_age = max(now - date_value, age_value)

   and as long as we have either nearly synchronized clocks or all-
   HTTP/1.1 paths, one gets a reliable (conservative) result.

   Because of network-imposed delays, some significant interval might
   pass between the time that a server generates a response and the time
   it is received at the next outbound cache or client. If uncorrected,
   this delay could result in improperly low ages.

   Because the request that resulted in the returned Age value must have
   been initiated prior to that Age value's generation, we can correct
   for delays imposed by the network by recording the time at which the
   request was initiated. Then, when an Age value is received, it MUST
   be interpreted relative to the time the request was initiated, not 

   the time that the response was received. This algorithm results in
   conservative behavior no matter how much delay is experienced. So, we
   compute:

      corrected_initial_age = corrected_received_age
                            + (now - request_time)

   where &quot;request_time&quot; is the time (according to the local clock) when
   the request that elicited this response was sent.

   Summary of age calculation algorithm, when a cache receives a
   response:

      /*
       * age_value
       *      is the value of Age: header received by the cache with
       *              this response.
       * date_value
       *      is the value of the origin server's Date: header
       * request_time
       *      is the (local) time when the cache made the request
       *              that resulted in this cached response
       * response_time
       *      is the (local) time when the cache received the
       *              response
       * now
       *      is the current (local) time
       */

      apparent_age = max(0, response_time - date_value);
      corrected_received_age = max(apparent_age, age_value);
      response_delay = response_time - request_time;
      corrected_initial_age = corrected_received_age + response_delay;
      resident_time = now - response_time;
      current_age   = corrected_initial_age + resident_time;

   The current_age of a cache entry is calculated by adding the amount
   of time (in seconds) since the cache entry was last validated by the
   origin server to the corrected_initial_age. When a response is
   generated from a cache entry, the cache MUST include a single Age
   header field in the response with a value equal to the cache entry's
   current_age.

   The presence of an Age header field in a response implies that a
   response is not first-hand. However, the converse is not true, since
   the lack of an Age header field in a response does not imply that the 

   response is first-hand unless all caches along the request path are
   compliant with HTTP/1.1 (i.e., older HTTP caches did not implement
   the Age header field).</source>
          <target state="translated">캐시 된 항목이 최신인지 확인하려면 캐시의 보존 기간이 최신 수명을 초과하는지 알아야합니다. &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4 절&lt;/a&gt; 에서 후자를 계산하는 방법에 대해 논의합니다 . 이 섹션에서는 응답 또는 캐시 항목의 수명을 계산하는 방법에 대해 설명합니다. 여기서는 &quot;지금&quot;이라는 용어를 사용하여 &quot;계산을 수행하는 호스트의 클록 현재 값&quot;을 의미합니다. HTTP를 사용하는 호스트, 특히 오리진 서버 및 캐시를 실행하는 호스트는 NTP [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt; ] 또는 이와 유사한 프로토콜을 사용하여 시계를 세계적으로 정확한 시간 표준에 동기화해야합니다. HTTP / 1.1은 원 서버가 가능한 경우 모든 응답과 함께 응답을 생성 한 시간을 제공하는 Date 헤더를 보내도록 요구합니다 ( &lt;a href=&quot;#section-14.18&quot;&gt;섹션 14.18&lt;/a&gt; 참조).). &quot;date_value&quot;라는 용어를 사용하여 산술 연산에 적합한 형식으로 Date 헤더의 값을 나타냅니다. HTTP / 1.1은 Age 응답 헤더를 사용하여 캐시에서 얻을 때 응답 메시지의 예상 수명을 전달합니다. Age 필드 값은 응답이 오리진 서버에 의해 생성되거나 재확인 된 이후의 캐시 예상 시간입니다. 본질적으로 Age 값은 응답이 원래 서버의 경로를 따라 각 캐시에 상주 한 시간과 네트워크 경로를 따라 전송 된 시간의 합계입니다. &quot;age_value&quot;라는 용어를 사용하여 산술 연산에 적합한 형식으로 Age 헤더의 값을 나타냅니다. 응답 연령은 완전히 독립적 인 두 가지 방법으로 계산할 수 있습니다.로컬 시계가 원래 서버의 시계와 합리적으로 동기화 된 경우 이제 빼기 date_value입니다. 결과가 음수이면 결과는 0으로 대체됩니다. 2. 응답 경로를 따라 모든 캐시가 HTTP / 1.1을 구현하는 경우 age_value. 응답이 수신 될 때 응답 연령을 계산하는 두 가지 독립적 인 방법이 있다고 가정하면, 거의 동기화 된 클럭 또는 모든 HTTP / 1.1이있는 한 corrected_received_age = max (now-date_value, age_value)와 같이 결합 할 수 있습니다. 경로는 신뢰할 수있는 (보수적 인) 결과를 얻습니다. 네트워크 부과 지연으로 인해 서버가 응답을 생성하는 시간과 다음 아웃 바운드 캐시 또는 클라이언트에서 수신하는 시간 사이에 상당한 간격이 지나갈 수 있습니다. 수정하지 않으면이 지연으로 인해 연령이 잘못 될 수 있습니다. 반환 된 Age 값을 초래 한 요청은 해당 Age 값을 생성하기 전에 시작되었으므로 요청이 시작된 시간을 기록하여 네트워크에 의해 발생 된 지연을 수정할 수 있습니다. 그런 다음 Age 값이 수신되면 응답이 수신 된 시간이 아니라 요청이 시작된 시간을 기준으로 해석되어야합니다. 이 알고리즘은 얼마나 많은 지연이 발생하더라도 보수적 인 동작을 낳습니다. 그래서 우리는 다음을 계산합니다. corrected_initial_age = corrected_received_age + (현재-request_time) 여기서 &quot;request_time&quot;은이 응답을 유발 한 요청이 전송 된 시간 (로컬 시계에 따름)입니다. 연령 계산 알고리즘 요약캐시가 응답을받는 경우 : / * * age_value *는이 응답으로 *가 캐시에 수신 한 Age : 헤더의 값입니다. * date_value *는 오리진 서버의 Date 값입니다. header * request_time *는 캐시가 요청을 한 (로컬) 시간입니다. *이 캐시 된 응답을 초래했습니다 * response_time *는 캐시가 *를 수신 한 (로컬) 시간입니다. response * now *는 현재 (현지) 시간입니다. * / 겉보기 = 최대 (0, response_time-date_value); corrected_received_age = max (apparent_age, age_value); response_delay = 응답 시간-요청 시간; corrected_initial_age = corrected_received_age + response_delay;resident_time = 현재-response_time; current_age = corrected_initial_age + 상주 _ 시간; 캐시 엔트리의 current_age는 캐시 서버가 원래 서버에 의해 마지막으로 유효성 검증 된 이후 시간을 초 단위로 추가하여 계산 된 시간을 초 단위로 추가하여 계산됩니다. 캐시 엔트리로부터 응답이 생성되면, 캐시는 캐시 엔트리의 current_age와 동일한 값으로 응답에 단일 Age 헤더 필드를 포함해야합니다. 응답에 Age 헤더 필드가 있다는 것은 응답이 직접적이지 않다는 것을 의미합니다. 그러나 응답에 Age 헤더 필드가 없다고해서 요청 경로를 따라 모든 캐시가 HTTP / 1.1을 준수하지 않는 한 (즉, 이전 HTTP 캐시가 그렇지 않은 경우) 직접 응답한다는 것을 의미하지 않기 때문에 그 반대는 사실이 아닙니다. Age 헤더 필드를 구현하십시오).</target>
        </trans-unit>
        <trans-unit id="93eea119dacd0c2679005705eb05947c3bbce8c5" translate="yes" xml:space="preserve">
          <source>In order to mitigate these flaws, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm, and more efficient.</source>
          <target state="translated">이러한 결함을 완화하기 위해 HTTP / 1.1은 구현하기 어려운 파이프 라이닝과 지속적인 연결을 도입했습니다. 기본 TCP 연결은 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 부분적으로 제어 할 수 있습니다 . HTTP / 2는 단일 연결을 통해 메시지를 다중화하여 연결을 따뜻하고 효율적으로 유지하는 데 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="d06ed585978c0a513808590b8c6743bd98c74164" translate="yes" xml:space="preserve">
          <source>In parallel to the somewhat chaotic use of the diverse implementations of HTTP/1.0, and since 1995, well before the publication of HTTP/1.0 document the next year, proper standardization was in progress. The first standardized version of HTTP, HTTP/1.1 was published in early 1997, only a few months after HTTP/1.0.</source>
          <target state="translated">HTTP / 1.0의 다양한 구현을 다소 혼란스럽게 사용하고 1995 년 이후로 내년 HTTP / 1.0 문서를 게시하기 훨씬 전에 적절한 표준화가 진행되었습니다. HTTP의 첫 번째 표준화 된 버전 인 HTTP / 1.1은 1997 년 초에 발표되었으며 HTTP / 1.0 이후 불과 몇 달이 지나지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4a373ca506ac7942c288749c8f149a921b16adb3" translate="yes" xml:space="preserve">
          <source>In particular, a request is preflighted if &lt;strong&gt;any of the following conditions&lt;/strong&gt; is true:</source>
          <target state="translated">특히 &lt;strong&gt;다음 조건 중 하나&lt;/strong&gt; 라도 &lt;strong&gt;해당되는&lt;/strong&gt; 경우 요청이 프리 플라이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d1e5ffefab8e49049390586276d922518d4d867" translate="yes" xml:space="preserve">
          <source>In particular, the request &lt;em&gt;requires&lt;/em&gt; these two additional headers:</source>
          <target state="translated">특히, 요청 &lt;em&gt;에는&lt;/em&gt; 다음 두 가지 추가 헤더 &lt;em&gt;가 필요합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32f825d053979b2bbea746eee217de968d1740ce" translate="yes" xml:space="preserve">
          <source>In practice, hop-by-hop compression is transparent for the server and the client, and is rarely used. &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; are mostly used to send a response by chunks, allowing to start transmitting a resource without knowing its length.</source>
          <target state="translated">실제로 홉별 압축은 서버와 클라이언트에 대해 투명하며 거의 사용되지 않습니다. &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 은 대부분 청크로 응답을 전송하는 데 사용되므로 길이를 알지 않고도 리소스 전송을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fb0378e9b8c8212e3d2de953dca5265e4ca3124" translate="yes" xml:space="preserve">
          <source>In practice, this error is very rarely used. Instead of responding using this error code, which would be cryptic for the end user and difficult to fix, servers ignore the relevant header and serve an actual page to the user. It is assumed that even if the user won't be completely happy, they will prefer this to an error code.</source>
          <target state="translated">실제로이 오류는 거의 사용되지 않습니다. 최종 사용자에게는 암호화되어 수정하기 어려운이 오류 코드를 사용하여 응답하는 대신 서버는 관련 헤더를 무시하고 사용자에게 실제 페이지를 제공합니다. 사용자가 완전히 만족하지 않더라도 오류 코드보다 선호한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5897a27e39859a1490a88859d07dae77805526ee" translate="yes" xml:space="preserve">
          <source>In practice, web developers don't need to implement compression mechanisms, both browsers and servers have it implemented already, but they have to be sure that the server is configured adequately. Compression happens at three different levels:</source>
          <target state="translated">실제로 웹 개발자는 압축 메커니즘을 구현할 필요가 없으며 브라우저와 서버 모두 이미 구현되어 있지만 서버가 적절하게 구성되어 있는지 확인해야합니다. 압축은 세 가지 다른 수준에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="495136708e3b335d9a535e1968ab6547efcb7046" translate="yes" xml:space="preserve">
          <source>In presence of an &lt;code&gt;Accept-Ranges&lt;/code&gt; header, the browser may try to &lt;em&gt;resume&lt;/em&gt; an interrupted download, rather than to start it from the start again.</source>
          <target state="translated">&lt;code&gt;Accept-Ranges&lt;/code&gt; 헤더 가 있으면 브라우저는 처음부터 다시 시작하지 않고 중단 된 다운로드 를 &lt;em&gt;다시 시작&lt;/em&gt; 하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c4393bb4e04346146f3edbaf7c8cd5fd81dd69" translate="yes" xml:space="preserve">
          <source>In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top at the application layer. Although important to diagnose network problems, the underlying layers are mostly irrelevant to the description of HTTP.</source>
          <target state="translated">실제로 브라우저와 서버 사이에 요청을 처리하는 컴퓨터가 더 많습니다. 라우터, 모뎀 등이 있습니다. 웹의 계층 디자인 덕분에 네트워크와 전송 계층에 숨겨져 있습니다. HTTP는 응용 프로그램 계층에서 최상위에 있습니다. 네트워크 문제를 진단하는 데 중요하지만 기본 계층은 대부분 HTTP 설명과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bf5f583aa5451ac94eabad6345a75ed78fe4350" translate="yes" xml:space="preserve">
          <source>In requests, (such as &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;), the client tells the server what type of data is actually sent.</source>
          <target state="translated">요청 (예 : &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; )에서 클라이언트는 서버에 실제로 전송되는 데이터 유형을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="1d41bda365255372b63ef811da0c711c5a50b4a0" translate="yes" xml:space="preserve">
          <source>In responses, a &lt;code&gt;Content-Type&lt;/code&gt; header tells the client what the content type of the returned content actually is. Browsers will do MIME sniffing in some cases and will not necessarily follow the value of this header; to prevent this behavior, the header &lt;a href=&quot;x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; can be set to &lt;code&gt;nosniff&lt;/code&gt;.</source>
          <target state="translated">응답에서 &lt;code&gt;Content-Type&lt;/code&gt; 헤더는 클라이언트에게 반환 된 컨텐츠의 컨텐츠 유형이 무엇인지 알려줍니다. 브라우저는 경우에 따라 MIME 스니핑을 수행하며이 헤더의 값을 반드시 따를 필요는 없습니다. 이 동작을 방지하기 위해 &lt;a href=&quot;x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt; 헤더 를 &lt;code&gt;nosniff&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7328d876f6eb63e7721164796f1284534dc9f3db" translate="yes" xml:space="preserve">
          <source>In short the EU directive means that before somebody can store or retrieve any information from a computer, mobile phone or other device, the user must give informed consent to do so. Many websites have added banners (AKA &quot;cookie banners&quot;) since then to inform the user about the use of cookies.</source>
          <target state="translated">간단히 말해서 EU 지침은 누군가 컴퓨터, 휴대 전화 또는 기타 장치에서 정보를 저장하거나 검색하기 전에 사용자가 정보에 동의해야한다는 것을 의미합니다. 그 이후로 많은 웹 사이트에서 사용자에게 쿠키 사용에 대해 알리기 위해 배너 (일명 &quot;쿠키 배너&quot;)를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="1d12b916e1ea56872beecbf2e4e9757af03ec500" translate="yes" xml:space="preserve">
          <source>In some cases, the operator of a cache MAY choose to configure it to
   return stale responses even when not requested by clients. This
   decision ought not be made lightly, but may be necessary for reasons
   of availability or performance, especially when the cache is poorly
   connected to the origin server. Whenever a cache returns a stale
   response, it MUST mark it as such (using a Warning header) enabling
   the client software to alert the user that there might be a potential
   problem. 

   It also allows the user agent to take steps to obtain a first-hand or
   fresh response. For this reason, a cache SHOULD NOT return a stale
   response if the client explicitly requests a first-hand or fresh one,
   unless it is impossible to comply for technical or policy reasons.</source>
          <target state="translated">경우에 따라 캐시 운영자는 클라이언트가 요청하지 않은 경우에도 오래된 응답을 반환하도록 캐시를 구성 할 수 있습니다. 이 결정은 간단하게 이루어져서는 안되지만 가용성 또는 성능상의 이유로, 특히 캐시가 원본 서버에 제대로 연결되지 않은 경우 필요할 수 있습니다. 캐시가 오래된 응답을 반환 할 때마다 클라이언트 소프트웨어가 잠재적 인 문제가있을 수 있음을 사용자에게 경고 할 수 있도록 캐시 경고 (경고 헤더 사용)로 표시해야합니다. 또한 사용자 에이전트가 직접 또는 새로운 응답을 얻기위한 단계를 수행 할 수 있습니다. 이러한 이유로, 기술적이거나 정책적인 이유로 준수 할 수없는 경우를 제외하고, 클라이언트가 명시 적으로 직접 또는 새로 요청한 경우 캐시는 오래된 응답을 반환해서는 안됩니다 (SHOULD NOT).</target>
        </trans-unit>
        <trans-unit id="d9444a4e91ad14c01e9590e0bedd4b5d6e8c782c" translate="yes" xml:space="preserve">
          <source>In summary, we recommend looking for the string &amp;ldquo;Mobi&amp;rdquo; anywhere in the User Agent to detect a mobile device.</source>
          <target state="translated">요약하면, 모바일 장치를 탐지하기 위해 사용자 에이전트의 어느 곳에서나&amp;ldquo;Mobi&amp;rdquo;라는 문자열을 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32c2d5256e5dc0b53e01514a025fbdaca4825463" translate="yes" xml:space="preserve">
          <source>In the absence of a MIME type, or in certain cases where browsers believe they are incorrect, browsers may perform &lt;em&gt;MIME sniffing&lt;/em&gt; &amp;mdash; guessing the correct MIME type by looking at the bytes of the resource.</source>
          <target state="translated">MIME 형식이 없거나 브라우저가 잘못되었다고 생각하는 특정 경우 브라우저는 &lt;em&gt;MIME 스니핑을&lt;/em&gt; 수행 할 수 있습니다. 리소스의 바이트를보고 올바른 MIME 형식을 추측합니다.</target>
        </trans-unit>
        <trans-unit id="cdc3e1dfd2d8a54df8817aa9e2334a8c551dfaed" translate="yes" xml:space="preserve">
          <source>In the case of a &quot;Basic&quot; authentication like shown in the figure, the exchange &lt;strong&gt;must&lt;/strong&gt; happen over an HTTPS (TLS) connection to be secure.</source>
          <target state="translated">그림과 같이 &quot;기본&quot;인증의 경우 교환 을 위해 HTTPS (TLS) 연결을 통해 교환이 &lt;strong&gt;이루어져야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9597ab40baf818d41d5819712b2c6f8aebbfee81" translate="yes" xml:space="preserve">
          <source>In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give a response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resource but a confirmation message such as: 'you successfully uploaded XYZ'.</source>
          <target state="translated">메소드를 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경하려는 경우 대신 &lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 이것은 업로드 된 리소스가 아니라 'XYZ를 성공적으로 업로드했습니다'와 같은 확인 메시지 인 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 메소드에 응답을 제공하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="8606d0b35470c00c20840dcc3a06c5fbe9904c62" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept = [ ( &quot;,&quot; / ( media-range [ accept-params ] ) ) *( OWS &quot;,&quot; [
    OWS ( media-range [ accept-params ] ) ] ) ]
   Accept-Charset = *( &quot;,&quot; OWS ) ( ( charset / &quot;*&quot; ) [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( ( charset / &quot;*&quot; ) [ weight ] ) ] )
   Accept-Encoding = [ ( &quot;,&quot; / ( codings [ weight ] ) ) *( OWS &quot;,&quot; [ OWS
    ( codings [ weight ] ) ] ) ]
   Accept-Language = *( &quot;,&quot; OWS ) ( language-range [ weight ] ) *( OWS
    &quot;,&quot; [ OWS ( language-range [ weight ] ) ] )
   Allow = [ ( &quot;,&quot; / method ) *( OWS &quot;,&quot; [ OWS method ] ) ]

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Content-Encoding = *( &quot;,&quot; OWS ) content-coding *( OWS &quot;,&quot; [ OWS
    content-coding ] )
   Content-Language = *( &quot;,&quot; OWS ) language-tag *( OWS &quot;,&quot; [ OWS
    language-tag ] )
   Content-Location = absolute-URI / partial-URI
   Content-Type = media-type

   Date = HTTP-date

   Expect = &quot;100-continue&quot;

   From = mailbox

   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date

   IMF-fixdate = day-name &quot;,&quot; SP date1 SP time-of-day SP GMT

   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   RWS = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds 

   Server = product *( RWS ( product / comment ) )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   User-Agent = product *( RWS ( product / comment ) )

   Vary = &quot;*&quot; / ( *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ]
    ) )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]
   accept-params = weight *accept-ext
   asctime-date = day-name SP date3 SP time-of-day SP year

   charset = token
   codings = content-coding / &quot;identity&quot; / &quot;*&quot;
   comment = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   content-coding = token

   date1 = day SP month SP year
   date2 = day &quot;-&quot; month &quot;-&quot; 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   field-name = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   hour = 2DIGIT

   language-range = &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;
   language-tag = &amp;lt;Language-Tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   media-range = ( &quot;*/*&quot; / ( type &quot;/*&quot; ) / ( type &quot;/&quot; subtype ) ) *( OWS
    &quot;;&quot; OWS parameter ) 

   media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date / asctime-date

   parameter = token &quot;=&quot; ( token / quoted-string )
   partial-URI = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   product = token [ &quot;/&quot; product-version ]
   product-version = token
   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   qvalue = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )

   &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   subtype = token

   time-of-day = hour &quot;:&quot; minute &quot;:&quot; second
   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   type = token

   weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue

   year = 4DIGIT 

Index

   1
      1xx Informational (status code class)  50

   2
      2xx Successful (status code class)  51

   3
      3xx Redirection (status code class)  54

   4
      4xx Client Error (status code class)  58

   5
      5xx Server Error (status code class)  62

   1
      100 Continue (status code)  50
      100-continue (expect value)  34
      101 Switching Protocols (status code)  50

   2
      200 OK (status code)  51
      201 Created (status code)  52
      202 Accepted (status code)  52
      203 Non-Authoritative Information (status code)  52
      204 No Content (status code)  53
      205 Reset Content (status code)  53

   3
      300 Multiple Choices (status code)  55
      301 Moved Permanently (status code)  56
      302 Found (status code)  56
      303 See Other (status code)  57
      305 Use Proxy (status code)  58
      306 (Unused) (status code)  58
      307 Temporary Redirect (status code)  58

   4
      400 Bad Request (status code)  58
      402 Payment Required (status code)  59
      403 Forbidden (status code)  59
      404 Not Found (status code)  59
      405 Method Not Allowed (status code)  59
      406 Not Acceptable (status code)  59
      408 Request Timeout (status code)  60
      409 Conflict (status code)  60 

      410 Gone (status code)  60
      411 Length Required (status code)  61
      413 Payload Too Large (status code)  61
      414 URI Too Long (status code)  61
      415 Unsupported Media Type (status code)  62
      417 Expectation Failed (status code)  62
      426 Upgrade Required (status code)  62

   5
      500 Internal Server Error (status code)  63
      501 Not Implemented (status code)  63
      502 Bad Gateway (status code)  63
      503 Service Unavailable (status code)  63
      504 Gateway Timeout (status code)  63
      505 HTTP Version Not Supported (status code)  64

   A
      Accept header field  38
      Accept-Charset header field  40
      Accept-Encoding header field  41
      Accept-Language header field  42
      Allow header field  72

   C
      cacheable  24
      compress (content coding)  11
      conditional request  36
      CONNECT method  30
      content coding  11
      content negotiation  6
      Content-Encoding header field  12
      Content-Language header field  13
      Content-Location header field  15
      Content-Transfer-Encoding header field  89
      Content-Type header field  10

   D
      Date header field  67
      deflate (content coding)  11
      DELETE method  29

   E
      Expect header field  34

   F
      From header field  44 

   G
      GET method  24
      Grammar
         Accept  38
         Accept-Charset  40
         Accept-Encoding  41
         accept-ext  38
         Accept-Language  42
         accept-params  38
         Allow  72
         asctime-date  66
         charset  9
         codings  41
         content-coding  11
         Content-Encoding  12
         Content-Language  13
         Content-Location  15
         Content-Type  10
         Date  67
         date1  65
         day  65
         day-name  65
         day-name-l  65
         delay-seconds  69
         Expect  34
         From  44
         GMT  65
         hour  65
         HTTP-date  65
         IMF-fixdate  65
         language-range  42
         language-tag  13
         Location  68
         Max-Forwards  36
         media-range  38
         media-type  8
         method  21
         minute  65
         month  65
         obs-date  66
         parameter  8
         product  46
         product-version  46
         qvalue  38
         Referer  45
         Retry-After  69
         &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  66
         second  65 

         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip (content coding)  11

   H
      HEAD method  25

   I
      idempotent  23

   L
      Location header field  68

   M
      Max-Forwards header field  36
      MIME-Version header field  89

   O
      OPTIONS method  31

   P
      payload  17
      POST method  25
      PUT method  26

   R
      Referer header field  45
      representation  7
      Retry-After header field  69

   S
      safe  22
      selected representation  7, 71
      Server header field  73
      Status Codes Classes
         1xx Informational  50
         2xx Successful  51
         3xx Redirection  54
         4xx Client Error  58
         5xx Server Error  62 

   T
      TRACE method  32

   U
      User-Agent header field  46

   V
      Vary header field  70

   X
      x-compress (content coding)  11
      x-gzip (content coding)  11

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                  [Page 101]</source>
          <target state="translated">아래에 수집 된 ABNF에서 목록 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]의 1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;절에&lt;/a&gt; 따라 확장됩니다 . Accept = [( &quot;,&quot;/ (미디어 범위 [accept-params])) * (OWS &quot;,&quot;[OWS (미디어 범위 [accept-params])])] Accept-Charset = * ( &quot;,&quot;OWS ) ((문자셋 / &quot;*&quot;) [무게]) * (OWS &quot;,&quot;[OWS ((문자셋 / &quot;*&quot;) [무게])]) Accept-Encoding = [( &quot;,&quot;/ (코딩 [무게] )) * (OWS &quot;,&quot;[OWS (코딩 [weight])])] Accept-Language = * ( &quot;,&quot;OWS) (language-range [weight]) * (OWS &quot;,&quot;[OWS (언어 범위 [weight])]) Allow = [( &quot;,&quot;/ method) * (OWS &quot;,&quot;[OWS method])] BWS = &amp;lt;BWS &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;, 섹션 3.2.3&lt;/a&gt; 참조 [RFC7230]&amp;gt; 콘텐츠 인코딩 = * ( &quot;,&quot;OWS) 콘텐츠 코딩 * (OWS &quot;,&quot;[OWS 콘텐츠 코딩]) 콘텐츠 언어 = * ( &quot;,&quot;OWS) 언어 태그 * (OWS &quot;,&quot;[OWS 언어 태그]) Content-Location = 절대 URI / 부분 URI Content-Type = 미디어 유형 날짜 = HTTP 날짜 예상 = &quot;100- 연속&quot;보낸 사람 = 사서함 GMT = % x47.4D.54; GMT HTTP-date = IMF-fixdate / obs-date IMF-fixdate = day-name &quot;,&quot;SP date1 SP 시간 SP SP-MT SP = MT- 참조 Max-Forwards = 1 * DIGIT OWS = &amp;lt;OWS &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3&lt;/a&gt; &amp;gt;참조 자 = 절대 URI / 부분 URI 재시도 후 = HTTP 날짜 / 지연 시간 서버 = 제품 * (RWS (제품 / 주석)) URI 참조 = &amp;lt;URI 참조, 참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], 2.7 절&lt;/a&gt; &amp;gt; User-Agent = product * (RWS (product / comment)) Vary = &quot;*&quot;/ (* ( &quot;,&quot;OWS) field-name * (OWS &quot;,&quot;[OWS field-name] )) 절대 URI = &amp;lt;절대 URI, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], 섹션 2.7 참조&lt;/a&gt; &amp;gt; accept-ext = OWS &quot;;&quot; OWS 토큰 [ &quot;=&quot;(token / quoted-string)] accept-params = weight * accept-ext asctime-date = day-name SP 날짜 3 SP SP 시간 문자 연도 = 토큰 코딩 = 콘텐츠 코딩 / &quot; identity &quot;/&quot;* &quot;comment = &amp;lt;comment, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt;&amp;gt; 콘텐츠 코딩 = 토큰 날짜 1 = 일 SP 월 SP 년 날짜 2 = 일 &quot;-&quot;월 &quot;-&quot;2DIGIT 날짜 3 = 월 SP (2DIGIT / (SP DIGIT)) 일 = ​​2DIGIT 요일 이름 = % x4D.6F.6E; Mon / % x54.75.65; 화 / % x57.65.64; 수 /%x54.68.75; Thu / % x46.72.69; Fri / % x53.61.74; 토 / % x53.75.6E; 일요일 이름 -l = % x4D.6F.6E.64.61.79; 월요일 / % x54.75.65.73.64.61.79; 화요일 / % x57.65.64.6E.65.73.64.61.79; 수요일 / % x54.68.75.72.73.64.61.79; 목요일 / % x46.72.69.64.61.79; 금요일 / % x53.61.74.75.72.64.61.79; 토요일 / % x53.75.6E.64.61.79; 일요일 지연 시간 = 1 * DIGIT field-name = &amp;lt;comment, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;섹션 [RFC7230], 섹션 3.2&lt;/a&gt; &amp;gt; hour = 2DIGIT 언어 범위 = &amp;lt;language-range &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;, 섹션 2.1 [RFC4647], 섹션 2.1 참조&lt;/a&gt;&amp;gt; language-tag = &amp;lt;Language-Tag, &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;섹션 2.1 [RFC5646], 섹션 2.1&lt;/a&gt; &amp;gt; mailbox = &amp;lt;mailbox &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;섹션, 섹션 3.4 참조&lt;/a&gt; &amp;gt; media-range = ( &quot;* / *&quot;/ (type &quot;/ *&quot;) / (유형 &quot;/&quot;하위 유형)) * (OWS &quot;;&quot;OWS 매개 변수) 미디어 유형 = 유형 &quot;/&quot;하위 유형 * (OWS &quot;;&quot;OWS 매개 변수) 방법 = 토큰 분 = 2DIGIT 월 = % x4A.61.6E; Jan / % x46.65.62; 2 월 / % x4D.61.72; 3 월 / % x41.70.72; Apr / % x4D.61.79; 5 월 / % x4A.75.6E; Jun / % x4A.75.6C; Jul / % x41.75.67; Aug / % x53.65.70; 9 월 /%x4F.63.74; Oct / % x4E.6F.76; 11 월 /%x44.65.63; 12 월 obs-date = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date / asctime-date 매개 변수 = 토큰 &quot;=&quot;(token / quoted-string) partial-URI = &amp;lt;partial-URI &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;, 섹션 2.7 [RFC7230] 참조&lt;/a&gt;&amp;gt; product = token [ &quot;/&quot;product-version] product-version = token quoted-string = &amp;lt;quoted-string &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;, 섹션 3.2.6&lt;/a&gt; 참조 [RFC7230] &amp;gt; qvalue = ( &quot;0&quot;[ &quot;.&quot;* 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;* 3 &quot;0&quot;]) &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; -date = day-name-l &quot;,&quot;SP date2 SP 시간 SP GMT 초 = 2DIGIT 하위 유형 = 토큰 시간 = 시간 &quot;:&quot;분 &quot;:&quot;두 번째 토큰 = &amp;lt;토큰, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt;&amp;gt; 유형 = 토큰 무게 = OWS &quot;;&quot; OWS &quot;q =&quot;qvalue 연도 = 4DIGIT 색인 1 1xx 정보 (상태 코드 클래스) 50 2 2xx 성공 (상태 코드 클래스) 51 3 3xx 리디렉션 (상태 코드 클래스) 54 4 4xx 클라이언트 오류 (상태 코드 클래스) 58 5 5xx 서버 오류 (상태 코드 클래스) ) 62 1100 Continue (상태 코드) 50100-continue (예상 값) 34101 스위칭 프로토콜 (상태 코드) 50 2200 OK (상태 코드) 51201 생성 (상태 코드) 52202 수락 (상태 코드) 52203 비 -인증 정보 (상태 코드) 52204 콘텐츠 없음 (상태 코드) 53205 콘텐츠 재설정 (상태 코드) 53 3300 다중 선택 (상태 코드) 55301 영구 이동 (상태 코드) 56302 발견 (상태 코드) 56303 참조 기타 (상태 코드) 57305 사용프록시 (상태 코드) 58306 (사용하지 않음) (상태 코드) 58307 임시 리디렉션 (상태 코드) 58 4400 잘못된 요청 (상태 코드) 58402 결제 필요 (상태 코드) 59403 금지 (상태 코드) 59404 찾을 수 없음 (상태 코드) 59405 허용되지 않는 방법 (상태 코드) 59406 허용되지 않음 (상태 코드) 59408 요청 시간 초과 (상태 코드) 60 409 충돌 (상태 코드) 60410 사라짐 (상태 코드) 60411 길이 (상태 코드) ) 61413 페이로드가 너무 큼 (상태 코드) 61414 URI가 너무 큼 (상태 코드) 61415 지원되지 않는 미디어 유형 (상태 코드) 624117 예상 실패 (상태 코드) 62426 업그레이드 필요 (상태 코드) 62 5500 내부 서버 오류 (상태 코드) 63501 구현되지 않음 (상태 코드) 63502 잘못된 게이트웨이 (상태 코드) 63503 서비스를 사용할 수 없음 (상태 코드) 63504 게이트웨이 시간 초과 (상태 코드) 63505 HTTP 버전이 지원되지 않음 (상태 코드) 64 A 수락 헤더 필드 38 수락-문자셋 헤더 필드 40 수락 인코딩 헤더 필드 41 수락 언어 헤더 필드 42 헤더 필드 허용 72 C 캐시 가능 24 압축 (콘텐츠 코딩) 11 조건부 요청 36 연결 방법 30 콘텐츠 코딩 11 콘텐츠 협상 6 콘텐츠 인코딩 헤더 필드 12 콘텐츠 언어 헤더 필드 13 콘텐츠 위치 헤더 필드 15 Content-Transfer-Encoding 헤더 필드 89 Content-Type 헤더 필드 10 D 날짜 헤더 필드 67 deflate (컨텐츠 코딩) 11 DELETE 방법 29 E 예상 헤더필드 34 F 헤더 필드에서 44 G GET 방법 24 문법 수락 38 수락 문자 세트 40 수락 인코딩 41 수락 확장 38 수락 언어 42 수락 매개 변수 38 허용 72 어시스트 날짜 66 문자 세트 9 코딩 41 내용 코딩 11 내용- 인코딩 12 내용 언어 13 내용 위치 15 내용 유형 10 날짜 67 날짜 1 65 일 65 일 이름 65 일 이름 -l 65 지연 시간 69 예상 34 44부터 44 GMT 65 시간 65 HTTP- 날짜 65 IMF 수정 날짜 65 언어 범위 42 언어 태그 13 위치 68 최대 전달 36 미디어 범위 38미디어 유형 8 방법 21 분 65 개월 65 예상치 66 매개 변수 8 제품 46 제품 버전 46 q 값 38 리퍼러 45 재시도 후 69 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-66 일 65 초 65 서버 73 하위 유형 8 시간 65 일 유형 8 사용자 에이전트 46 변동 70 중량 38 년 65 gzip (콘텐츠 코딩) 11 H HEAD 방법 25 i 등원 23 L 위치 헤더 필드 68 M 최대 전달 헤더 필드 36 MIME- 버전 헤더 필드 89 O 옵션 방법 31 P 페이로드 17 POST 방법 25 PUT 방법 26 R 참조 헤더 필드 45 표시 7 재시도 후 헤더 필드 69 S 안전 22 선택된 표시 7,71 서버 헤더 필드 73 상태 코드 클래스 1xx 정보 50 2xx 성공 51 3xx 리디렉션 54 4xx 클라이언트 오류 58 5xx 서버 오류 62 T TRACE 방법 32 U 사용자 에이전트 헤더 필드 46 V 가변 헤더 필드 70 X x 압축 (콘텐츠 코딩) 11 x-gzip (콘텐츠 코딩) 11 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI :CA 95110 USA 이메일 : fielding@gbiv.com URI :CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; 필딩 &amp;amp; Reschke 표준 트랙 [페이지 101]</target>
        </trans-unit>
        <trans-unit id="e5c21a021da725c4cf94f0a415f9a51eddeeff8c" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Accept-Ranges = acceptable-ranges

   Content-Range = byte-content-range / other-content-range

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Range = entity-tag / HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Range = byte-ranges-specifier / other-ranges-specifier

   acceptable-ranges = ( *( &quot;,&quot; OWS ) range-unit *( OWS &quot;,&quot; [ OWS
    range-unit ] ) ) / &quot;none&quot;

   byte-content-range = bytes-unit SP ( byte-range-resp /
    unsatisfied-range )
   byte-range = first-byte-pos &quot;-&quot; last-byte-pos
   byte-range-resp = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
   byte-range-set = *( &quot;,&quot; OWS ) ( byte-range-spec /
    suffix-byte-range-spec ) *( OWS &quot;,&quot; [ OWS ( byte-range-spec /
    suffix-byte-range-spec ) ] )
   byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
   byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
   bytes-unit = &quot;bytes&quot;

   complete-length = 1*DIGIT

   entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;

   first-byte-pos = 1*DIGIT

   last-byte-pos = 1*DIGIT

   other-content-range = other-range-unit SP other-range-resp
   other-range-resp = *CHAR
   other-range-set = 1*VCHAR
   other-range-unit = token
   other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set

   range-unit = bytes-unit / other-range-unit

   suffix-byte-range-spec = &quot;-&quot; suffix-length 

   suffix-length = 1*DIGIT

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   unsatisfied-range = &quot;*/&quot; complete-length

Index

   2
      206 Partial Content (status code)  10

   4
      416 Range Not Satisfiable (status code)  15

   A
      Accept-Ranges header field  7

   C
      Content-Range header field  12

   G
      Grammar
         Accept-Ranges  7
         acceptable-ranges  7
         byte-content-range  12
         byte-range  12
         byte-range-resp  12
         byte-range-set  5
         byte-range-spec  5
         byte-ranges-specifier  5
         bytes-unit  5
         complete-length  12
         Content-Range  12
         first-byte-pos  5
         If-Range  9
         last-byte-pos  5
         other-content-range  12
         other-range-resp  12
         other-range-unit  5, 7
         Range  8
         range-unit  5
         ranges-specifier  5
         suffix-byte-range-spec  6
         suffix-length  6
         unsatisfied-range  12 

   I
      If-Range header field  9

   M
      Media Type
         multipart/byteranges  18, 21
         multipart/x-byteranges  19
      multipart/byteranges Media Type  18, 21
      multipart/x-byteranges Media Type  21

   R
      Range header field  8

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Yves Lafon (editor)
   World Wide Web Consortium
   W3C / ERCIM
   2004, rte des Lucioles
   Sophia-Antipolis, AM  06902
   France

   EMail: ylafon@w3.org
   URI:   &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http://www.raubacapeu.net/people/yves/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 25]</source>
          <target state="translated">아래에 수집 된 ABNF에서 목록 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]의 1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;절에&lt;/a&gt; 따라 확장됩니다 . 수용 범위 = 수용 가능 범위 Content-Range = byte-content-range / other-content-range HTTP-date = &amp;lt;HTTP-date &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;, 섹션 7.1.1.1 [RFC7231], 섹션 7.1.1.1 참조&lt;/a&gt; &amp;gt; If-Range = entity-tag / HTTP -date OWS = &amp;lt;OWS &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;, 섹션 3.2.3 [RFC7230]&lt;/a&gt; 참조&amp;gt; 범위 = 바이트 범위 지정자 / 기타 범위 지정자 수용 가능 범위 = (* ( &quot;,&quot;OWS) 범위 단위 * (OWS &quot;,&quot;[OWS 범위 단위])) / &quot;없음&quot;바이트 내용 -range = bytes-unit SP (바이트-범위 -resp / 만족 된 범위) byte-range = first-byte-pos &quot;-&quot;last-byte-pos 바이트-범위 -resp = 바이트-범위 &quot;/&quot;(완료- length / &quot;*&quot;) 바이트 범위 세트 = * ( &quot;,&quot;OWS) (바이트 범위 스펙 / 접미사 바이트 범위 스펙) * (OWS &quot;,&quot;[OWS (바이트 범위 스펙 / 접미사 -byte-range-spec)]) byte-range-spec = first-byte-pos &quot;-&quot;[last-byte-pos] 바이트 범위 지정자 = bytes-unit &quot;=&quot;바이트 범위 설정 바이트 단위 = &quot;바이트&quot;complete-length = 1 * DIGIT 엔티티 태그 = &amp;lt;엔티티 태그, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232]&lt;/a&gt; 참조 ,섹션 2.3&amp;gt; first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT other-content-range = 기타 범위 단위 SP other-range-resp other-range-resp = * CHAR other-range-set = 1 * VCHAR other-range-unit = token other-ranges-specifier = other-range-unit &quot;=&quot;other-range-set range-unit = bytes-unit / other-range-unit 접미사-바이트-범위-사양 = &quot;-&quot;접미사 길이 접미사 길이 = 1 * DIGIT 토큰 = &amp;lt;토큰, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt;&amp;gt; 만족스럽지 않은 범위 = &quot;* /&quot;전체 길이 색인 2206 부분 컨텐츠 (상태 코드) 10 4416 범위를 만족할 수없는 범위 (상태 코드) 15 A 수락 범위 헤더 필드 7 C 컨텐츠 범위 헤더 필드 12 G 문법 수락- 범위 7 허용 범위 7 바이트 내용 범위 12 바이트 범위 12 바이트 범위 해상도 12 바이트 범위 세트 5 바이트 범위 스펙 5 바이트 범위 지정자 5 바이트 단위 5 전체 길이 12 내용 범위 12 first-byte-pos 5 If-Range 9 last-byte-pos 5 other-content-range 12 other-range-resp 12 other-range-unit 5,7 범위 8 범위 단위 5 범위 지정자 5 접미사 바이트 범위 사양 6 접미사 길이 6 불만족 범위 12 I If-Range 헤더 필드 9 M 미디어 유형 멀티 파트 / 바이트 범위 18, 21 멀티 파트 / x- 바이트 범위 19 멀티 파트 / byteranges 미디어 유형 18, 21 multipart / x-byteranges 미디어 유형 21 R 범위 헤더 필드 8 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI :21 멀티 파트 / x- 바이트 범위 미디어 유형 21 R 범위 헤더 필드 8 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI :21 멀티 파트 / x- 바이트 범위 미디어 유형 21 R 범위 헤더 필드 8 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Yves Lafon (편집자) 월드 와이드 웹 컨소시엄 W3C / ERCIM 2004, rte des Lucioles Sophia-Antipolis, AM 06902 프랑스 이메일 : ylafon@w3.org URI : &lt;a href=&quot;http://www.raubacapeu.net/people/yves/&quot;&gt;http : //www.raubacapeu .net / people / yves /&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; Fielding, et al . 표준 트랙 [페이지 25]</target>
        </trans-unit>
        <trans-unit id="7f7187563510f7b95d508990280bc6d64358c455" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Age = delta-seconds

   Cache-Control = *( &quot;,&quot; OWS ) cache-directive *( OWS &quot;,&quot; [ OWS
    cache-directive ] )

   Expires = HTTP-date

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Pragma = *( &quot;,&quot; OWS ) pragma-directive *( OWS &quot;,&quot; [ OWS
    pragma-directive ] )

   Warning = *( &quot;,&quot; OWS ) warning-value *( OWS &quot;,&quot; [ OWS warning-value ]
    )

   cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   delta-seconds = 1*DIGIT

   extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   field-name = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;

   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
   pragma-directive = &quot;no-cache&quot; / extension-pragma
   pseudonym = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   uri-host = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   warn-code = 3DIGIT
   warn-date = DQUOTE HTTP-date DQUOTE
   warn-text = quoted-string
   warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date
    ] 

Index

   1
      110 (warn-code)  31
      111 (warn-code)  31
      112 (warn-code)  31
      113 (warn-code)  31
      199 (warn-code)  32

   2
      214 (warn-code)  32
      299 (warn-code)  32

   A
      age  11
      Age header field  21

   C
      cache  4
      cache entry  5
      cache key  5-6
      Cache-Control header field  21

   D
      Disconnected Operation (warn-text)  31

   E
      Expires header field  28
      explicit expiration time  11

   F
      fresh  11
      freshness lifetime  11

   G
      Grammar
         Age  21
         Cache-Control  22
         cache-directive  22
         delta-seconds  5
         Expires  28
         extension-pragma  29
         Pragma  29
         pragma-directive  29
         warn-agent  29
         warn-code  29
         warn-date  29
         warn-text  29 

         Warning  29
         warning-value  29

   H
      Heuristic Expiration (warn-text)  31
      heuristic expiration time  11
   M
      max-age (cache directive)  22, 26
      max-stale (cache directive)  22
      min-fresh (cache directive)  22
      Miscellaneous Persistent Warning (warn-text)  32
      Miscellaneous Warning (warn-text)  32
      must-revalidate (cache directive)  24

   N
      no-cache (cache directive)  23, 25
      no-store (cache directive)  23, 24
      no-transform (cache directive)  23, 25

   O
      only-if-cached (cache directive)  23

   P
      Pragma header field  29
      private (cache directive)  25
      private cache  4
      proxy-revalidate (cache directive)  26
      public (cache directive)  25

   R
      Response is Stale (warn-text)  30
      Revalidation Failed (warn-text)  31

   S
      s-maxage (cache directive)  27
      shared cache  4
      stale  11
      strong validator  18

   T
      Transformation Applied (warn-text)  32

   V
      validator  16

   W
      Warning header field  29 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Mark Nottingham (editor)
   Akamai

   EMail: mnot@mnot.net
   URI:   &lt;a href=&quot;http://www.mnot.net/&quot;&gt;http://www.mnot.net/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding, et al.             Standards Track                   [Page 43]</source>
          <target state="translated">아래에 수집 된 ABNF에서 목록 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]의 1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;절에&lt;/a&gt; 따라 확장됩니다 . Age = delta-seconds Cache-Control = * ( &quot;,&quot;OWS) 캐시 지정 * (OWS &quot;,&quot;[OWS cache-directive]) 만료 = HTTP-date HTTP-date = &amp;lt;HTTP-date, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]&lt;/a&gt; 참조 , 7.1.1.1 섹션 &amp;gt; OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 3.2.3 섹션&lt;/a&gt; 참조 &amp;gt; Pragma = * ( &quot;,&quot;OWS) pragma-directive * (OWS &quot;,&quot;[OWS pragma-directive]) 경고 = * ( &quot;,&quot;OWS) warning-value * (OWS &quot;,&quot;[OWS warning-value]) cache-directive = token [ &quot;=&quot;(token / quoted-string)] delta-seconds = 1 * DIGIT 확장명 -pragma = 토큰 [ &quot;=&quot;(token / quoted-string)] field-name = &amp;lt;field-name,&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], 섹션 3.2&lt;/a&gt; &amp;gt; 포트 = &amp;lt;포트 참조, 참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], 섹션 2.7&lt;/a&gt; &amp;gt; pragma-directive = &quot;no-cache&quot;/ extension-pragma pseudonym = &amp;lt;pseudonym, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], 섹션 5.7.1 참조&lt;/a&gt; &amp;gt; 인용 문자열 = &amp;lt;quoted-string, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 참조 3.2.6&lt;/a&gt; &amp;gt; 토큰 = &amp;lt;토큰, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;섹션 [RFC7230], 섹션 3.2.6&lt;/a&gt; &amp;gt; uri-host = &amp;lt;uri-host &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;, 섹션 2.7, [RFC7230]&lt;/a&gt; 참조&amp;gt; warn-agent = (uri-host [ &quot;:&quot;포트]) / 가명 경고 코드 = 3DIGIT 경고 날짜 = DQUOTE HTTP 날짜 DQUOTE 경고 텍스트 = 인용 문자열 경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트 [SP 경고 날짜] 인덱스 1 110 (경고 코드) 31111 (경고) 31112 (경고) 31113 (경고) 31 199 (경고) 32 2214 (경고) 32 299 (경고) 32 A 연령 11 연령 헤더 필드 21 C 캐시 4 캐시 항목 5 캐시 키 5-6 캐시 제어 헤더 필드 21 D 연결 끊김 작업 (경고 텍스트) 31 E 헤더 필드 만료 28 명시 적 만료 시간 11 F 새로 고침 11 신선도 수명 11 G 문법 연령 21 캐시 제어 22 캐시 지정 22 델타 초 5 만료 28extension-pragma 29 Pragma 29 pragma-directive 29 경고 에이전트 29 경고 코드 29 경고 날짜 29 경고 텍스트 29 경고 29 경고 값 29 H 휴리스틱 만료 (warn-text) 31 휴리스틱 만료 시간 11 M max-age ( 캐시 지시문) 22, 26 최대 스토리 (캐시 지시문) 22 min-fresh (캐시 지시문) 22 기타 지속 경고 (경고 텍스트) 32 기타 경고 (경고 텍스트) 32 반드시 재확인 (캐시 지시) 24 N no- 캐시 (캐시 지시문) 23, 25 no-store (캐시 지시문) 23, 24 no-transform (캐시 지시문) 23,25 O 전용 캐시 (캐시 지시문) 23 P Pragma 헤더 필드 29 개인 (캐시 지시문) 25 프라이빗 캐시 4 프록시 재확인 (캐시 지시문) 26 공개 (캐시 지시문) 25 R 응답이 오래되었습니다 (경고 텍스트) 30 재확인 실패 (경고 텍스트) 31 Ss-maxage (캐시 지시문) 27 공유 캐시 4 부실 11 강력한 유효성 검사기 18 T 변환 적용 (경고 텍스트) 32 V 유효성 검사기 16 W 경고 헤더 필드 29 작성자 주소 Roy T. Fielding ( 편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI :필딩 (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI :필딩 (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Mark Nottingham (편집자) Akamai 이메일 : mnot@mnot.net URI : &lt;a href=&quot;http://www.mnot.net/&quot;&gt;http://www.mnot.net/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; Fielding, et al. 표준 트랙 [페이지 43]</target>
        </trans-unit>
        <trans-unit id="847bccd23d1c7feafc0bf9bbe4823064cad9878a" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   Authorization = credentials

   BWS = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   Proxy-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS
    challenge ] )
   Proxy-Authorization = credentials

   WWW-Authenticate = *( &quot;,&quot; OWS ) challenge *( OWS &quot;,&quot; [ OWS challenge
    ] )

   auth-param = token BWS &quot;=&quot; BWS ( token / quoted-string )
   auth-scheme = token

   challenge = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param ) *(
    OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]
   credentials = auth-scheme [ 1*SP ( token68 / [ ( &quot;,&quot; / auth-param )
    *( OWS &quot;,&quot; [ OWS auth-param ] ) ] ) ]

   quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   token = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   token68 = 1*( ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; )
    *&quot;=&quot; 

Index

   4
      401 Unauthorized (status code)  6
      407 Proxy Authentication Required (status code)  6

   A
      Authorization header field  8

   C
      Canonical Root URI  5

   G
      Grammar
         auth-param  4
         auth-scheme  4
         Authorization  8
         challenge  4
         credentials  5
         Proxy-Authenticate  8
         Proxy-Authorization  9
         token68  4
         WWW-Authenticate  7

   P
      Protection Space  5
      Proxy-Authenticate header field  8
      Proxy-Authorization header field  9

   R
      Realm  5

   W
      WWW-Authenticate header field  7 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 19]</source>
          <target state="translated">아래에 수집 된 ABNF에서 목록 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]의 1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;절에&lt;/a&gt; 따라 확장됩니다 . 인증 = 자격 증명 BWS = &amp;lt;BWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;섹션 3.2.3 [RFC7230]&lt;/a&gt; 참조 &amp;gt; OWS = &amp;lt;OWS &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;, 섹션 3.2.3 [RFC7230]&lt;/a&gt; 참조&amp;gt; 프록시 인증 = * ( &quot;,&quot;OWS) 챌린지 * (OWS &quot;,&quot;[OWS 챌린지]) 프록시 인증 = 자격 증명 WWW-Authenticate = * ( &quot;,&quot;OWS) 챌린지 * (OWS &quot;,&quot;[OWS 챌린지 ]) auth-param = token BWS &quot;=&quot;BWS (token / quoted-string) auth-scheme = token challenge = auth-scheme [1 * SP (token68 / [( &quot;,&quot;/ auth-param) * (OWS &quot; , &quot;[OWS auth-param])])] 자격 증명 = auth-scheme [1 * SP (token68 / [(&quot;, &quot;/ auth-param) * (OWS&quot;, &quot;[OWS auth-param])])] quoted-string = &amp;lt;quoted-string, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt; &amp;gt; token = &amp;lt;token, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt;&amp;gt; token68 = 1 * (ALPHA / DIGIT / &quot;-&quot;/ &quot;.&quot;/ &quot;_&quot;/ &quot;~&quot;/ &quot;+&quot;/ &quot;/&quot;) * &quot;=&quot;색인 4401 인증되지 않은 (상태 코드) 6407 프록시 인증 필수 (상태 코드) 6 A 인증 헤더 필드 8 C 정식 루트 URI 5 G 문법 auth-param 4 auth-scheme 4 인증 8 챌린지 4 자격 증명 5 프록시 인증 8 프록시 인증 9 token68 4 WWW 인증 7 P 보호 공간 5 프록시 인증 헤더 필드 8 프록시 인증 헤더 필드 9 R 영역 5 W WWW 인증 헤더 필드 7 작성자 주소 Roy T.필딩 (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; 필딩 &amp;amp; Reschke 표준 트랙 [페이지 19]</target>
        </trans-unit>
        <trans-unit id="feeba52d99d5a0008f5d811bd13452d39d2497a5" translate="yes" xml:space="preserve">
          <source>In the collected ABNF below, list rules are expanded as per &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;1.2 of [RFC7230]&lt;/a&gt;.

   ETag = entity-tag

   HTTP-date = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;

   If-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Modified-Since = HTTP-date
   If-None-Match = &quot;*&quot; / ( *( &quot;,&quot; OWS ) entity-tag *( OWS &quot;,&quot; [ OWS
    entity-tag ] ) )
   If-Unmodified-Since = HTTP-date

   Last-Modified = HTTP-date

   OWS = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;

   entity-tag = [ weak ] opaque-tag
   etagc = &quot;!&quot; / %x23-7E ; '#'-'~'
    / obs-text

   obs-text = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
   opaque-tag = DQUOTE *etagc DQUOTE

   weak = %x57.2F ; W/ 

Index

   3
      304 Not Modified (status code)  19

   4
      412 Precondition Failed (status code)  18

   E
      ETag header field  9

   G
      Grammar
         entity-tag  9
         ETag  9
         etagc  9
         If-Match  13
         If-Modified-Since  15
         If-None-Match  14
         If-Unmodified-Since  17
         Last-Modified  7
         opaque-tag  9
         weak  9

   I
      If-Match header field  13
      If-Modified-Since header field  16
      If-None-Match header field  14
      If-Unmodified-Since header field  17

   L
      Last-Modified header field  7

   M
      metadata  5

   S
      selected representation  4

   V
      validator  5
         strong  5
         weak  5 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 28]</source>
          <target state="translated">아래에 수집 된 ABNF에서 목록 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;[RFC7230]의 1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-1.2&quot;&gt;절에&lt;/a&gt; 따라 확장됩니다 . ETag = entity-tag HTTP-date = &amp;lt;HTTP-date, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;섹션 7.1.1.1 [RFC7231] 참조&lt;/a&gt; &amp;gt; If-Match = &quot;*&quot;/ (* ( &quot;,&quot;OWS) entity-tag * (OWS &quot;,&quot;[ OWS entity-tag])) If-Modified-Since = HTTP-date If-None-Match = &quot;*&quot;/ (* ( &quot;,&quot;OWS) entity-tag * (OWS &quot;,&quot;[OWS entity-tag]) ) If-Unmodified-Since = HTTP-date Last-Modified = HTTP-date OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3 참조&lt;/a&gt; &amp;gt; entity-tag = [weak] opaque-tag etagc = &quot;!&quot; / % x23-7E; '#'- '~'/ obs-text obs-text = &amp;lt;obs-text &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;, 섹션 3.2.6 [RFC7230] 참조&lt;/a&gt;&amp;gt; 불투명 태그 = DQUOTE * etagc DQUOTE 약한 = % x57.2F; W / Index 3 304 수정되지 않음 (상태 코드) 19 4 412 전제 조건 실패 (상태 코드) 18 E ETag 헤더 필드 9 G 문법 엔터티 태그 9 ETag 9 etagc 9 If-Match 13 If-Modified-Since 15 If-None- 일치 14 수정하지 않은 상태부터 17 마지막 수정 된 7 불투명 한 태그 9 약한 9 I 일치하는 헤더 필드 13 수정하지 않은 헤더 필드 16 If-None-Match 헤더 필드 14 수정하지 않은 -Since 헤더 필드 17 L Last-Modified 헤더 필드 7 M 메타 데이터 5 S 선택된 표현 4 V 유효성 검사기 5 강력 5 약 5 작성자 주소 Roy T.필딩 (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; 필딩 &amp;amp; Reschke 표준 트랙 [페이지 28]</target>
        </trans-unit>
        <trans-unit id="472f98def3eac77e06a2358d336b65f3adb470f7" translate="yes" xml:space="preserve">
          <source>In the example above, line 3 creates an XML body to send with the &lt;code&gt;POST&lt;/code&gt; request in line 8. Also, on line 9, a &quot;customized&quot; (non-standard) HTTP request header is set (&lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt;). Such headers are not part of the HTTP/1.1 protocol, but are generally useful to web applications. Since the request uses a Content-Type of &lt;code&gt;application/xml&lt;/code&gt;, and since a custom header is set, this request is preflighted.</source>
          <target state="translated">위의 예에서 3 행은 8 행 에서 &lt;code&gt;POST&lt;/code&gt; 요청 과 함께 전송할 XML 본문을 작성합니다. 또한 9 행에서 &quot;사용자 정의 된&quot;(비표준) HTTP 요청 헤더가 설정됩니다 ( &lt;code&gt;X-PINGOTHER: pingpong&lt;/code&gt; ). 이러한 헤더는 HTTP / 1.1 프로토콜의 일부가 아니지만 일반적으로 웹 응용 프로그램에 유용합니다. 요청이 Content-Type of &lt;code&gt;application/xml&lt;/code&gt; 을 사용하고 사용자 정의 헤더가 설정되었으므로이 요청이 사전 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="90a33fcc28f73464c7c1ed80b477376d44e96863" translate="yes" xml:space="preserve">
          <source>In the first half of the 2010s, Google demonstrated an alternative way of exchanging data between client and server, by implementing an experimental protocol SPDY. This amassed interest from developers working on both browsers and servers. Defining an increase in responsiveness, and solving the problem of duplication of data transmitted, SPDY served as the foundations of the HTTP/2 protocol.</source>
          <target state="translated">2010 년 상반기에 Google은 실험적인 프로토콜 SPDY를 구현하여 클라이언트와 서버간에 데이터를 교환하는 다른 방법을 시연했습니다. 이는 브라우저와 서버 모두에서 작업하는 개발자의 관심을 끌었습니다. 응답 성의 증가를 정의하고 전송 된 데이터의 복제 문제를 해결하는 SPDY는 HTTP / 2 프로토콜의 기초가되었습니다.</target>
        </trans-unit>
        <trans-unit id="20562e67671b5bf845611bfa4f3b14fd6e956c7a" translate="yes" xml:space="preserve">
          <source>In the past, specific plug-ins, add-ons or extensions added user agent parts to notify sites they were installed. The recommended way to do this, if it's absolutely necessary (remember that it slows down every request) is to &lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;set a custom HTTP header&lt;/a&gt;.</source>
          <target state="translated">과거에는 특정 플러그인, 애드온 또는 확장 프로그램에 사용자 에이전트 파트가 추가되어 사이트에 설치된 사이트를 알 렸습니다. 절대적으로 필요한 경우 권장되는 방법 (모든 요청이 느려짐을 기억하십시오)은 &lt;a href=&quot;https://developer.mozilla.org/en/Setting_HTTP_request_headers&quot;&gt;사용자 정의 HTTP 헤더&lt;/a&gt; 를 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="312bfeb98e09b0ebf786270e4655ffbe98874e6b" translate="yes" xml:space="preserve">
          <source>In the past, web content was able to access whatever &lt;code&gt;resource:&lt;/code&gt; URIs were desired &amp;mdash; not only Firefox&amp;rsquo;s internal resources, but also extensions&amp;rsquo; assets. Now this behavior is prohibited by default.</source>
          <target state="translated">과거에는 웹 컨텐츠가 Firefox의 내부 리소스뿐만 아니라 확장 기능의 자산 &lt;code&gt;resource:&lt;/code&gt; URI와 같은 모든 리소스 에 액세스 할 수있었습니다 . 이제이 동작은 기본적으로 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="75008cbe2513d02694dbb1b988119207d90d0106" translate="yes" xml:space="preserve">
          <source>In the realm of internationalization, this specification complies
   with the IETF Character Set Policy [&lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt;].  In this specification,
   human-readable fields can be found either in the value of a property,
   or in an error message returned in a response entity body.  In both
   cases, the human-readable content is encoded using XML, which has
   explicit provisions for character set tagging and encoding, and
   requires that XML processors read XML elements encoded, at minimum,
   using the UTF-8 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] and UTF-16 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt;] encodings of the ISO
   10646 multilingual plane.  XML examples in this specification
   demonstrate use of the charset parameter of the Content-Type header
   (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]), as well as XML charset declarations.

   XML also provides a language tagging capability for specifying the
   language of the contents of a particular XML element.  The &quot;xml:lang&quot;
   attribute appears on an XML element to identify the language of its
   content and attributes.  See [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;] for definitions of values and
   scoping.

   WebDAV applications MUST support the character set tagging, character
   set encoding, and the language tagging functionality of the XML
   specification.  Implementors of WebDAV applications are strongly
   encouraged to read &quot;XML Media Types&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;] for instruction on
   which MIME media type to use for XML transport, and on use of the
   charset parameter of the Content-Type header.

   Names used within this specification fall into four categories: names
   of protocol elements such as methods and headers, names of XML
   elements, names of properties, and names of conditions.  Naming of
   protocol elements follows the precedent of HTTP, using English names
   encoded in US-ASCII for methods and headers.  Since these protocol
   elements are not visible to users, and are simply long token
   identifiers, they do not need to support multiple languages.
   Similarly, the names of XML elements used in this specification are
   not visible to the user and hence do not need to support multiple
   languages.

   WebDAV property names are qualified XML names (pairs of XML namespace
   name and local name).  Although some applications (e.g., a generic
   property viewer) will display property names directly to their users,
   it is expected that the typical application will use a fixed set of
   properties, and will provide a mapping from the property name and
   namespace to a human-readable field when displaying the property name 

   to a user.  It is only in the case where the set of properties is not
   known ahead of time that an application need display a property name
   to a user.  We recommend that applications provide human-readable
   property names wherever feasible.

   For error reporting, we follow the convention of HTTP/1.1 status
   codes, including with each status code a short, English description
   of the code (e.g., 423 (Locked)).  While the possibility exists that
   a poorly crafted user agent would display this message to a user,
   internationalized applications will ignore this message, and display
   an appropriate message in the user's language and character set.

   Since interoperation of clients and servers does not require locale
   information, this specification does not specify any mechanism for
   transmission of this information.</source>
          <target state="translated">국제화 영역에서이 사양은 IETF 문자 집합 정책 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC2277&lt;/a&gt; ]을 준수합니다 . 이 사양에서 사람이 읽을 수있는 필드는 속성 값 또는 응답 엔터티 본문에 반환 된 오류 메시지에서 찾을 수 있습니다. 두 경우 모두, 사람이 읽을 수있는 컨텐츠는 XML을 사용하여 인코딩되며, 이는 문자 세트 태깅 및 인코딩에 대한 명시적인 조항이 있으며 XML 프로세서는 최소한 UTF-8 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt; ] 및 UTF-16을 사용하여 인코딩 된 XML 요소를 읽어야합니다. ISO 10646 다국어 평면의 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC2781&lt;/a&gt; ] 인코딩. 이 사양의 XML 예제는 Content-Type 헤더의 charset 매개 변수 사용을 보여줍니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023에&lt;/a&gt; 정의 됨)]) 및 XML 문자 세트 선언. XML은 또한 특정 XML 요소 내용의 언어를 지정하기위한 언어 태그 기능을 제공합니다. &quot;xml : lang&quot;속성은 내용 및 속성의 언어를 식별하기 위해 XML 요소에 나타납니다. 값 및 범위 정의에 대해서는 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]을 참조하십시오 . WebDAV 응용 프로그램은 XML 사양의 문자 세트 태그 지정, 문자 세트 인코딩 및 언어 태그 기능을 지원해야합니다. WebDAV 응용 프로그램 구현자는 &quot;XML 미디어 유형&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; 을 읽을 것을 적극 권장합니다.] XML 전송에 사용할 MIME 매체 유형 및 Content-Type 헤더의 charset 매개 변수 사용에 대한 지시 사항. 이 사양에서 사용되는 이름은 메서드 및 헤더와 같은 프로토콜 요소 이름, XML 요소 이름, 속성 이름 및 조건 이름의 네 가지 범주로 분류됩니다. 프로토콜 요소의 이름은 메소드와 헤더에 대해 US-ASCII로 인코딩 된 영어 이름을 사용하여 HTTP의 선례를 따릅니다. 이러한 프로토콜 요소는 사용자에게 보이지 않으며 단순히 긴 토큰 식별자이기 때문에 여러 언어를 지원할 필요가 없습니다. 마찬가지로이 사양에 사용 된 XML 요소의 이름은 사용자에게 표시되지 않으므로 여러 언어를 지원할 필요가 없습니다.WebDAV 특성 이름은 규정 된 XML 이름 (XML 네임 스페이스 이름 및 로컬 이름 쌍)입니다. 일부 응용 프로그램 (예 : 일반 속성 뷰어)은 속성 이름을 사용자에게 직접 표시하지만 일반적인 응용 프로그램은 고정 된 속성 집합을 사용하고 속성 이름과 네임 스페이스에서 사람으로의 매핑을 제공 할 것으로 예상됩니다. 속성 이름을 사용자에게 표시 할 때 읽을 수있는 필드입니다. 응용 프로그램이 사용자에게 속성 이름을 표시해야하는 것은 미리 속성 집합을 알 수없는 경우에만 해당됩니다. 응용 프로그램은 가능한 모든 사람이 읽을 수있는 속성 이름을 제공하는 것이 좋습니다. 오류보고의 경우, 각 상태 코드와 함께 짧은 영어 코드 설명 (예 : 423 (잠김))을 포함하여 HTTP / 1.1 상태 코드 규칙을 따릅니다.잘못 만들어진 사용자 에이전트는이 메시지를 사용자에게 표시 할 가능성이 있지만 국제화 된 응용 프로그램은이 메시지를 무시하고 사용자의 언어 및 문자 집합으로 적절한 메시지를 표시합니다. 클라이언트와 서버의 상호 운용에는 로캘 정보가 필요하지 않으므로이 사양에서는이 정보의 전송 메커니즘을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08819ce444413d248ed409d1bf3d59a094d39073" translate="yes" xml:space="preserve">
          <source>In this article, we focus on resource URIs, which are used internally by Firefox to point to built-in resources.</source>
          <target state="translated">이 기사에서는 내장 리소스를 가리 키기 위해 Firefox에서 내부적으로 사용하는 리소스 URI에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0238c032fe8b075e22eb8b6c9fa8e03afd0be1e7" translate="yes" xml:space="preserve">
          <source>In this case, responses can be sent back based on some considerations.</source>
          <target state="translated">이 경우 몇 가지 고려 사항에 따라 응답을 다시 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b277eb0332b7d0f528bc488b7a6ac8fc32ac6b" translate="yes" xml:space="preserve">
          <source>In this case, the server can send back a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) response that will contain the right information, but if the reload button is pressed, only this page is redisplayed, without replaying the unsafe requests.</source>
          <target state="translated">이 경우 서버는 올바른 정보를 포함 하는 &lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (기타 참조) 응답을 다시 보낼 수 있지만 다시로드 단추를 누르면 안전하지 않은 요청을 재생하지 않고이 페이지 만 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="18d9fe67ef95cf5048b92cb9c02dafef0b4ac177" translate="yes" xml:space="preserve">
          <source>In this case, you need to configure the server receiving the HTTP requests (which is most likely the same for www and non-www URLs) to respond with an adequate HTTP &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; response to any request to the non-canonical domain. This will redirect the browser trying to access the non-canonical URLs to their canonical equivalent. For example, if you've chosen to use non-www URLs as the canonical type, you should redirect all www URLs to their equivalent URL without the www.</source>
          <target state="translated">이 경우 비정규 도메인에 대한 모든 요청에 대해 적절한 HTTP &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; 응답으로 응답하도록 HTTP 요청 (www 및 www가 아닌 ​​URL에 대해 거의 동일 함)을 수신하는 서버를 구성해야 합니다. 그러면 비정규 URL에 액세스하려고하는 브라우저가 정식 URL로 리디렉션됩니다. 예를 들어, www가 아닌 ​​URL을 표준 유형으로 사용하기로 선택한 경우 www가없는 모든 www URL을 동등한 URL로 리디렉션해야합니다.</target>
        </trans-unit>
        <trans-unit id="7847050425f6d076cc4ad765d4143b2fe451ad2c" translate="yes" xml:space="preserve">
          <source>In this example all of the hosts in a given subnet are connected-to directly, others are connected through the proxy:</source>
          <target state="translated">이 예에서는 지정된 서브넷의 모든 호스트가 직접 연결되어 있고 다른 호스트는 프록시를 통해 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="463b3c56a942948bf5001ffa290aad288ddfa0e2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.net/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">이 예에서 &lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt; 는 프로덕션에 사용되는 서버의 공개 키를 고정합니다. 두 번째 핀 선언 &lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt; 도 백업 키를 고정합니다. &lt;strong&gt;max-age = 5184000&lt;/strong&gt; 은 클라이언트에게이 정보를 2 개월 동안 저장 &lt;strong&gt;하도록&lt;/strong&gt; 지시합니다. 이는 IETF RFC에 따라 합리적인 시간 제한입니다. 이 키 고정은 모든 하위 도메인에 유효하며 &lt;strong&gt;includeSubDomains&lt;/strong&gt; 선언에서 알 수 있습니다. 마지막으로 &lt;strong&gt;report-uri = &quot;https://www.example.net/hpkp-report&quot;&lt;/strong&gt; 는 핀 유효성 검사 실패를보고 할 위치를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="15fe4fb824d6da70afb6414abaf5dbbc417ed391" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. &lt;strong&gt;max-age=5184000&lt;/strong&gt; tells the client to store this information for two months, which is a reasonable time limit according to the IETF RFC. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">이 예에서 &lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt; 는 프로덕션에 사용되는 서버의 공개 키를 고정합니다. 두 번째 핀 선언 &lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt; 도 백업 키를 고정합니다. &lt;strong&gt;max-age = 5184000&lt;/strong&gt; 은 클라이언트에게이 정보를 2 개월 동안 저장 &lt;strong&gt;하도록&lt;/strong&gt; 지시합니다. 이는 IETF RFC에 따라 합리적인 시간 제한입니다. 이 키 고정은 모든 하위 도메인에 유효하며 &lt;strong&gt;includeSubDomains&lt;/strong&gt; 선언에서 알 수 있습니다. 마지막으로 &lt;strong&gt;report-uri = &quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; 는 핀 검증 실패보고 위치를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7b4d6bd9abca71a4536572bc7fcac564f95ec372" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;pin-sha256=&quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2+soZS7sWs=&quot;&lt;/strong&gt; pins the server's public key used in production. The second pin declaration &lt;strong&gt;pin-sha256=&quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE=&quot;&lt;/strong&gt; also pins the backup key. This key pinning is also valid for all subdomains, which is told by the &lt;strong&gt;includeSubDomains&lt;/strong&gt; declaration. Finally, &lt;strong&gt;report-uri=&quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; explains where to report pin validation failures.</source>
          <target state="translated">이 예에서 &lt;strong&gt;pin-sha256 = &quot;cUPcTAZWKaASuYWhhneDttWpY3oBAkE3h2 + soZS7sWs =&quot;&lt;/strong&gt; 는 프로덕션에 사용되는 서버의 공개 키를 고정합니다. 두 번째 핀 선언 &lt;strong&gt;pin-sha256 = &quot;M8HztCzM3elUxkcjR2S5P4hhyBNf6lHkmjAHKhpGPWE =&quot;&lt;/strong&gt; 도 백업 키를 고정합니다. 이 키 고정은 모든 하위 도메인에 유효하며 &lt;strong&gt;includeSubDomains&lt;/strong&gt; 선언에서 알 수 있습니다. 마지막으로 &lt;strong&gt;report-uri = &quot;https://www.example.org/hpkp-report&quot;&lt;/strong&gt; 는 핀 유효성 검사 실패보고 위치를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="26e35d19a2c9f9c005f9c384d2fca94ef727d3c6" translate="yes" xml:space="preserve">
          <source>In this example, content originally loaded from &lt;code&gt;http://foo.example&lt;/code&gt; makes a simple GET request to a resource on &lt;code&gt;http://bar.other&lt;/code&gt; which sets Cookies. Content on foo.example might contain JavaScript like this:</source>
          <target state="translated">이 예제에서 원래 &lt;code&gt;http://foo.example&lt;/code&gt; 에서로드 된 컨텐츠 는 쿠키를 설정하는 &lt;code&gt;http://bar.other&lt;/code&gt; 의 자원에 간단한 GET 요청을 작성합니다 . foo.example의 내용은 다음과 같은 JavaScript를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bad895874eb650b248a44ce79a14ea76d8467d2" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;a href=&quot;expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is used at the end of the chunked message and serves as a trailing header.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; 헤더는 청크 된 메시지의 끝에 사용되며 후행 헤더로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3619c052570e6c7b13df3247db7eb34508081c2" translate="yes" xml:space="preserve">
          <source>In this example, the domain name &quot;&lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt;&quot; will be pre-resolved.</source>
          <target state="translated">이 예에서는 도메인 이름 &quot; &lt;a href=&quot;http://www.spreadfirefox.com&quot;&gt;www.spreadfirefox.com&lt;/a&gt; &quot;이 사전 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="ece92baae1897d8ad92e5e7a0a62d4670b062563" translate="yes" xml:space="preserve">
          <source>In this example, the user agent string is mobile safari version. It contains the word &quot;Mobile&quot;.</source>
          <target state="translated">이 예에서 사용자 에이전트 문자열은 모바일 사파리 버전입니다. &quot;모바일&quot;이라는 단어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb7d3fc0025e51622cf41c74720e5e287c75d33c" translate="yes" xml:space="preserve">
          <source>In this response, &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; indicates that bytes can be used as unit to define a range. Here the &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header is also useful as it indicates the full size of the image to retrieve.</source>
          <target state="translated">이 응답에서 &lt;code&gt;Accept-Ranges: bytes&lt;/code&gt; 는 바이트를 범위로 정의하는 단위로 사용할 수 있음을 나타냅니다. 여기서 &lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더는 검색 할 이미지의 전체 크기를 나타내므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="795b5c095ca34b9eb4357638cfdaae755baa1753" translate="yes" xml:space="preserve">
          <source>In this section, the final line of each section gives the element
   type declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).  Note that all of the elements defined
   here may be extended according to the rules defined in &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;.
   All elements defined here are in the &quot;DAV:&quot; namespace.</source>
          <target state="translated">이 섹션에서 각 섹션의 마지막 줄은 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ]에 정의 된 형식을 사용하여 요소 유형 선언을 제공합니다 . &quot;값&quot;필드는 존재하는 경우 BNF를 사용하여 (즉, PCDATA 요소의 값을 추가로 제한하기 위해) XML 요소의 허용 가능한 컨텐츠에 대한 추가 제한 사항을 지정합니다. 여기에 정의 된 모든 요소는 &lt;a href=&quot;#section-17&quot;&gt;섹션 17에&lt;/a&gt; 정의 된 규칙에 따라 확장 될 수 있습니다 . 여기에 정의 된 모든 요소는 &quot;DAV :&quot;네임 스페이스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="179432a2d14c1874e18b6638eed524eeb5842b02" translate="yes" xml:space="preserve">
          <source>Included in the response message from the server during the opening handshake process when the server is willing to initiate a WebSocket connection. It will appear no more than once in the response headers.</source>
          <target state="translated">서버가 WebSocket 연결을 시작하려고 할 때 핸드 셰이크 프로세스를 여는 동안 서버의 응답 메시지에 포함됩니다. 응답 헤더에 한 번만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9cab054870dbf49daaae3aee35de09e7abf09a42" translate="yes" xml:space="preserve">
          <source>Incomplete results: a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt; (Partial Content) response.</source>
          <target state="translated">불완전한 결과 : &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; (부분 컨텐츠) 응답.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="522b16bedc865c8cbd64e7b9adb9223fbc62cbb9" translate="yes" xml:space="preserve">
          <source>IndexedDB (for each database execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt;&lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IndexedDB (각 데이터베이스에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/deleteDatabase&quot;&gt; &lt;code&gt;IDBFactory.deleteDatabase&lt;/code&gt; &lt;/a&gt; 실행 ),</target>
        </trans-unit>
        <trans-unit id="77a0f0c640c4020f67d5dbd8adc3745275738665" translate="yes" xml:space="preserve">
          <source>Indicates a URL path that must exist in the requested resource before sending the Cookie header. The %x2F (&quot;/&quot;) character is interpreted as a directory separator and sub directories will be matched as well (e.g. path=/docs, &quot;/docs&quot;, &quot;/docs/Web/&quot;, or &quot;/docs/Web/HTTP&quot; will all be matched).</source>
          <target state="translated">쿠키 헤더를 보내기 전에 요청 된 리소스에 존재해야하는 URL 경로를 나타냅니다. % x2F ( &quot;/&quot;) 문자는 디렉토리 분리 자로 해석되며 하위 디렉토리도 일치합니다 (예 : path = / docs, &quot;/ docs&quot;, &quot;/ docs / Web /&quot;또는 &quot;/ docs / Web / HTTP &quot;가 모두 일치합니다).</target>
        </trans-unit>
        <trans-unit id="2cd7bebabc246b7398c2557d2f27d3f5dfbfc228" translate="yes" xml:space="preserve">
          <source>Indicates an alternate location for the returned data.</source>
          <target state="translated">반환 된 데이터의 대체 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bf3af3031e2a167d607e233517fe07840ad0ce2" translate="yes" xml:space="preserve">
          <source>Indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">요청을 올바르게 처리하기 위해 서버가 충족해야하는 기대를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="552935b2453887e59cf2e4f3e94e2e9ac12d93ef" translate="yes" xml:space="preserve">
          <source>Indicates how long the results of a preflight request can be cached.</source>
          <target state="translated">프리 플라이트 요청 결과를 캐시 할 수있는 기간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7c9b44d689ef4104318af0511c11748dc3967c95" translate="yes" xml:space="preserve">
          <source>Indicates how long the user agent should wait before making a follow-up request.</source>
          <target state="translated">후속 요청을하기 전에 사용자 에이전트가 대기해야하는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ad3a4c007f7db3dfac95c3ba5f703c8f8dd59961" translate="yes" xml:space="preserve">
          <source>Indicates if the server supports range requests and if so, in which unit the range can be expressed.</source>
          <target state="translated">서버가 범위 요청을 지원하는지 여부와 지원하는 경우 범위를 표현할 수있는 단위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3430ae2cd395b1c94c2f79f53999b8989357367e" translate="yes" xml:space="preserve">
          <source>Indicates that either the client or the server would like to close the connection. This is the default on HTTP/1.0 requests.</source>
          <target state="translated">클라이언트 또는 서버가 연결을 닫으려고 함을 나타냅니다. 이것이 HTTP / 1.0 요청의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c99b1484ee170cc3fd51d8eb0f92ba2eff8fc73e" translate="yes" xml:space="preserve">
          <source>Indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application.</source>
          <target state="translated">브라우저 (Internet Explorer)는 파일이 응용 프로그램의 컨텍스트에서 실행되도록 액세스 할 수 있으므로 피싱 공격을 방지하기 위해 응용 프로그램에서 다운로드 한 파일을 &quot;열기&quot;옵션을 표시하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c4f79f8a6a3c8718f3618cea1550c9060b2c9c67" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a response that has exceeded its expiration time. Optionally, you can assign a value in seconds, indicating the time the response must not be expired by.</source>
          <target state="translated">클라이언트가 만료 시간을 초과 한 응답을 기꺼이 수락 함을 나타냅니다. 선택적으로 응답을 만료하지 않아야하는 시간을 나타내는 값을 초 단위로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f0d192853b0ab8b3406d2dd070fa47ec20ae34" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response if the check for a fresh one fails. The seconds value indicates for how long the client is willing to accept the stale response after the initial expiration.</source>
          <target state="translated">새로운 응답 확인에 실패하면 클라이언트가 오래된 응답을 기꺼이 수락 함을 나타냅니다. 초 값은 클라이언트가 초기 만료 후 오래된 응답을 기꺼이 수락 할 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="deaef90dde647ea30a46f347a0d9e248199a5f91" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept a stale response while asynchronously checking in the background for a fresh one. The seconds value indicates for how long the client is willing to accept a stale response.</source>
          <target state="translated">클라이언트가 백그라운드에서 새로운 응답을 비동기 적으로 검사하는 동안 오래된 응답을 기꺼이 수락 함을 나타냅니다. 초 값은 클라이언트가 오래된 응답을 기꺼이 수락 할 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33fbfac7a3753ad2fc4a262b8c0b818d20d43473" translate="yes" xml:space="preserve">
          <source>Indicates that the client is willing to accept trailer fields in a chunked transfer coding.</source>
          <target state="translated">클라이언트가 청크 분할 전송 코딩에서 트레일러 필드를 기꺼이 수락 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a44c16e62480d86b3a9b9458e2ea45fed4f4e530" translate="yes" xml:space="preserve">
          <source>Indicates that the client wants a response that will still be fresh for at least the specified number of seconds.</source>
          <target state="translated">클라이언트가 최소한 지정된 시간 (초) 동안 새로운 응답을 원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b642df972d92ffd9369fe8f647cb5c9e563d0505" translate="yes" xml:space="preserve">
          <source>Indicates that the client would like to keep the connection open. Having a persistent connection is the default on HTTP/1.1 requests. The list of headers are the name of the header to be removed by the first non-transparent proxy or cache in-between: these headers define the connection between the emitter and the first entity, not the destination node.</source>
          <target state="translated">클라이언트가 연결을 계속 열려고 함을 나타냅니다. 지속적인 연결이 HTTP / 1.1 요청의 기본값입니다. 헤더 목록은 첫 번째 비 투명 프록시 또는 그 사이의 캐시에 의해 제거 될 헤더의 이름입니다.이 헤더는 대상 노드가 아닌 이미 터와 첫 번째 엔티티 사이의 연결을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f97447000dd6a21db07563d6ef729be734f5e4a3" translate="yes" xml:space="preserve">
          <source>Indicates that the request has been conveyed in early data.</source>
          <target state="translated">요청이 초기 데이터로 전달되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5955a042968bb418bc770fb1ac84f6a1e3b04e52" translate="yes" xml:space="preserve">
          <source>Indicates that the response body will not change over time. The resource, if unexpired, is unchanged on the server and therefore the client should not send a conditional revalidation for it (e.g. &lt;code&gt;If-None-Match&lt;/code&gt; or &lt;code&gt;If-Modified-Since&lt;/code&gt;) to check for updates, even when the user explicitly refreshes the page. Clients that aren't aware of this extension must ignore them as per the HTTP specification. In Firefox, &lt;code&gt;immutable&lt;/code&gt; is only honored on &lt;code&gt;https://&lt;/code&gt; transactions. For more information, see also this &lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">응답 본문이 시간이 지나도 변경되지 않음을 나타냅니다. 만료되지 않은 리소스는 서버에서 변경되지 않으므로 클라이언트는 사용자가 명시 적으로 페이지를 새로 고치더라도 업데이트를 확인하기 위해 조건부 유효성 재확인 (예 : &lt;code&gt;If-None-Match&lt;/code&gt; 또는 &lt;code&gt;If-Modified-Since&lt;/code&gt; )을 보내지 않아야 합니다. . 이 확장명을 모르는 클라이언트는 HTTP 사양에 따라 무시해야합니다. Firefox에서 &lt;code&gt;immutable&lt;/code&gt; 은 &lt;code&gt;https://&lt;/code&gt; 트랜잭션 에서만 유효 합니다. 자세한 내용은이 &lt;a href=&quot;http://bitsup.blogspot.de/2016/05/cache-control-immutable.html&quot;&gt;블로그 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d6f6e0f4b09d76d1dc1ccd2d2b141f2a442a1d2" translate="yes" xml:space="preserve">
          <source>Indicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.</source>
          <target state="translated">응답이 단일 사용자를위한 것이며 공유 캐시에 저장되어서는 안됨을 나타냅니다. 개인 캐시는 응답을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="619c7b97c107a9d7b9f0f9a1bf6f8d31f3066053" translate="yes" xml:space="preserve">
          <source>Indicates that the response may be cached by any cache.</source>
          <target state="translated">캐시가 응답을 캐시 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0a024414359139c546eb2b06d1c63cbb97a90599" translate="yes" xml:space="preserve">
          <source>Indicates that the server is unwilling to risk processing a request that might be replayed.</source>
          <target state="translated">서버가 재생할 수있는 요청을 처리 할 위험이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1764f0a2dc1d82d92287ff0957396522996daa3d" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to clear all types of data for the origin of the response. If more data types are added in future versions of this header, they will also be covered by it.</source>
          <target state="translated">서버가 응답의 출처에 대한 모든 유형의 데이터를 지우려고 함을 나타냅니다. 이 헤더의 이후 버전에서 더 많은 데이터 유형이 추가되는 경우 해당 유형도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d0874c17bb0051bdad46f81276a7a676b678ee89" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to reload all browsing contexts for the origin of the response (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt;&lt;code&gt;Location.reload&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">서버가 응답의 출처 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Location/reload&quot;&gt; &lt;code&gt;Location.reload&lt;/code&gt; &lt;/a&gt; )에 대한 모든 찾아보기 컨텍스트를 다시로드하려고 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cc5b7853c11f1c815426aacf326e6a5f1048b0f0" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all DOM storage for the origin of the response URL. This includes storage mechanisms such as:</source>
          <target state="translated">서버가 응답 URL의 출처에 대한 모든 DOM 스토리지를 제거하려고 함을 나타냅니다. 여기에는 다음과 같은 저장 메커니즘이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7e1742a157a2de2bf388f99e235ed9711fd524" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove all cookies for the origin of the response URL. HTTP authentication credentials are also cleared out. This affects the entire registered domain, including subdomains. So https://example.com as well as https://stage.example.com, will have cookies cleared.</source>
          <target state="translated">서버가 응답 URL의 출처에 대한 모든 쿠키를 제거하려고 함을 나타냅니다. HTTP 인증 자격 증명도 지워집니다. 이는 하위 도메인을 포함하여 등록 된 전체 도메인에 영향을줍니다. 따라서 https://example.com과 https://stage.example.com은 쿠키를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="ac63007b3c6f50bd4fa2b0ef581a82efee07a128" translate="yes" xml:space="preserve">
          <source>Indicates that the server wishes to remove locally cached data (i.e. the browser cache, see &lt;a href=&quot;../caching&quot;&gt;HTTP caching&lt;/a&gt;) for the origin of the response URL. Depending on the browser, this might also clear out things like pre-rendered pages, script caches, WebGL shader caches, or address bar suggestions.</source>
          <target state="translated">서버 가 응답 URL의 출처에 대해 로컬로 캐시 된 데이터 (예 : 브라우저 캐시, &lt;a href=&quot;../caching&quot;&gt;HTTP 캐싱&lt;/a&gt; 참조 ) 를 제거하려고 함을 나타냅니다 . 브라우저에 따라 사전 렌더링 된 페이지, 스크립트 캐시, WebGL 셰이더 캐시 또는 주소 표시 줄 제안과 같은 사항도 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf528554c916e8834415e263fe337623229bfac2" translate="yes" xml:space="preserve">
          <source>Indicates the URL to redirect a page to.</source>
          <target state="translated">페이지를 리디렉션 할 URL을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c8fbcc1100e604b3e848463d05946c3ca0c4fdb5" translate="yes" xml:space="preserve">
          <source>Indicates the approximate amount of device RAM. This value is an approximation given by rounding to the nearest power of 2 and dividing that number by 1024. For example, 512 megabytes will be reported as &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">대략적인 장치 RAM 양을 나타냅니다. 이 값은 가장 가까운 2의 거듭 제곱으로 반올림하고 해당 숫자를 1024로 나눈 근사값입니다. 예를 들어 512MB는 &lt;code&gt;0.5&lt;/code&gt; 로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="79a4facd7bfa2752abc2651ad8a22d1290f85fac" translate="yes" xml:space="preserve">
          <source>Indicates the client's device pixel ratio.</source>
          <target state="translated">클라이언트의 장치 픽셀 비율을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7c99e10959087264a8f9f76bbe0fb6c6616be7db" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">식별 기능을 나타냅니다 (예 : 압축 및 수정 없음). 명시 적으로 지정된 경우를 제외하고이 토큰은 항상 허용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="300e6bcab08b44f020c00b953beb914707cf781f" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e. no compression, nor modification). This value is always considered as acceptable, even if not present.</source>
          <target state="translated">식별 기능을 나타냅니다 (예 : 압축 및 수정 없음). 존재하지 않더라도이 값은 항상 허용 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4412b21a02fb471172b40a65fca71a926bc03433" translate="yes" xml:space="preserve">
          <source>Indicates the identity function (i.e., no compression or modification). This token, except if explicitly specified, is always deemed acceptable.</source>
          <target state="translated">신원 기능을 나타냅니다 (즉, 압축 또는 수정 없음). 명시 적으로 지정된 경우를 제외하고이 토큰은 항상 허용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="76a871a5c993107287ac4f26321af85411e97af4" translate="yes" xml:space="preserve">
          <source>Indicates the layout viewport width in CSS pixels.</source>
          <target state="translated">CSS 픽셀로 레이아웃 뷰포트 너비를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13225f32edcd936d283f2308a7685081e9a67758" translate="yes" xml:space="preserve">
          <source>Indicates the media type of the resource.</source>
          <target state="translated">자원의 매체 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc5582911590b64a930b456a56b69a37cf02610d" translate="yes" xml:space="preserve">
          <source>Indicates the part of a document that the server should return.</source>
          <target state="translated">서버가 반환해야하는 문서 부분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d639acdf32e7294320e546fc64936adb232d2c83" translate="yes" xml:space="preserve">
          <source>Indicates the resource width in physical pixels (in other words the intrinsic size of an image).</source>
          <target state="translated">실제 너비 (즉, 이미지의 고유 한 크기)로 리소스 너비를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7befcc9a5a8e27a8f507455ba0c663658e48c7d6" translate="yes" xml:space="preserve">
          <source>Indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">해당 요청에 적용된 추적 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9743929feee03e6db93823d546a5b6519ece671b" translate="yes" xml:space="preserve">
          <source>Indicates to not retrieve new data. This being the case, the server wishes the client to obtain a response only once and then cache. From this moment the client should keep releasing a cached copy and avoid contacting the origin-server to see if a newer copy exists.</source>
          <target state="translated">새 데이터를 검색하지 않음을 나타냅니다. 이 경우 서버는 클라이언트가 응답을 한 번만 얻은 다음 캐시하기를 원합니다. 이 순간부터 클라이언트는 캐시 된 사본을 계속 공개하고 원본 서버에 접속하여 새로운 사본이 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3f04a324f464c13b3de7ed6c10ccdaea39b71f5" translate="yes" xml:space="preserve">
          <source>Indicates where a fetch originates from.</source>
          <target state="translated">가져 오기가 시작된 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="850af2d2f10fe8221618b8b2b077bcf0329a3edf" translate="yes" xml:space="preserve">
          <source>Indicates where in a full body message a partial message belongs.</source>
          <target state="translated">전신 메시지에서 부분 메시지가 속하는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be2f75e053430254664cae4d27f3e51d38721d53" translate="yes" xml:space="preserve">
          <source>Indicates whether a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">브라우저가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 페이지를 렌더링 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f69a3c7ddba822bcbbe58dfda37543497c04707b" translate="yes" xml:space="preserve">
          <source>Indicates whether the response can be shared.</source>
          <target state="translated">응답을 공유 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1d669ea27317208a9d7ef5173080a7f6aeec565" translate="yes" xml:space="preserve">
          <source>Indicates whether the response to the request can be exposed when the credentials flag is true.</source>
          <target state="translated">자격 증명 플래그가 true 일 때 요청에 대한 응답을 표시 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fc014b0691c6356400a50c33337bc3eb5a7b831" translate="yes" xml:space="preserve">
          <source>Indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">이름을 나열하여 응답의 일부로 노출 될 수있는 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99d7331d101ff2b635886de75d335f15281ec8b0" translate="yes" xml:space="preserve">
          <source>Indicates which protocol was used to make the request (typically &quot;http&quot; or &quot;https&quot;).</source>
          <target state="translated">요청에 사용 된 프로토콜을 나타냅니다 (일반적으로 &quot;http&quot;또는 &quot;https&quot;).</target>
        </trans-unit>
        <trans-unit id="0c0dafad80f67d7e9dd4f5b440cd064e7a6c1c13" translate="yes" xml:space="preserve">
          <source>Indicating a target audience for a resource</source>
          <target state="translated">자원의 대상 고객 표시</target>
        </trans-unit>
        <trans-unit id="5a9618787236f752551e7febb8e28aa6e4ab7345" translate="yes" xml:space="preserve">
          <source>Indicating the URL of a transaction's result</source>
          <target state="translated">거래 결과의 URL 표시</target>
        </trans-unit>
        <trans-unit id="fca6301092f0f25b345065ddc8bcf56276e0afd5" translate="yes" xml:space="preserve">
          <source>Indicating the language a document is written in</source>
          <target state="translated">문서가 작성된 언어를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7f8525ef38cab4390ca786bdef36f2a78190d70f" translate="yes" xml:space="preserve">
          <source>Information regarding the HSTS preload list in Chrome : &lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https://www.chromium.org/hsts&lt;/a&gt;</source>
          <target state="translated">Chrome의 HSTS 사전로드 목록에 대한 정보 : &lt;a href=&quot;https://www.chromium.org/hsts&quot;&gt;https://www.chromium.org/hsts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a98006b47abdad4b8d9d147e829058b52579a85e" translate="yes" xml:space="preserve">
          <source>Information responses</source>
          <target state="translated">정보 응답</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="9e7c1323910f2b5174a834226f71b3b7aee441c8" translate="yes" xml:space="preserve">
          <source>Informational (Expired)</source>
          <target state="translated">정보 제공 (만료)</target>
        </trans-unit>
        <trans-unit id="1af57283b2cb4e6ccf06b8fbe5453fc2d6fbb913" translate="yes" xml:space="preserve">
          <source>Informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) interim response.</source>
          <target state="translated">이 요청에서 클라이언트가 (아마도 큰) 메시지 본문을 보내려고하고 &lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt; (계속) 중간 응답 을 수신하려고 함을 수신자에게 알립니다 .</target>
        </trans-unit>
        <trans-unit id="59f3ea8d1fb37b159cf5cc21991810bccf67d68b" translate="yes" xml:space="preserve">
          <source>Informs the server about the encoding algorithm, usually a compression algorithm, that can be used on the resource sent back.</source>
          <target state="translated">서버에게 다시 보낸 리소스에서 사용할 수있는 인코딩 알고리즘 (일반적으로 압축 알고리즘)에 대해 알립니다.</target>
        </trans-unit>
        <trans-unit id="ddb5e7a065792d4b30e1cbf2d728a2ac83ecc7bb" translate="yes" xml:space="preserve">
          <source>Informs the server about the language the server is expected to send back. This is a hint and is not necessarily under the full control of the user: the server should always pay attention not to override an explicit user choice (like selecting a language in a drop down list).</source>
          <target state="translated">서버에게 서버가 다시 보낼 것으로 예상되는 언어를 알려줍니다. 이것은 힌트이며 반드시 사용자를 완전히 제어 할 필요는 없습니다. 서버는 항상 명시적인 사용자 선택을 무시하지 않도록주의해야합니다 (드롭 다운 목록에서 언어 선택).</target>
        </trans-unit>
        <trans-unit id="87b0141515a7b36be28ca5afb9e3d2f36da758a0" translate="yes" xml:space="preserve">
          <source>Informs the server about the types of data that can be sent back. It is MIME-type.</source>
          <target state="translated">다시 보낼 수있는 데이터 유형에 대해 서버에 알립니다. MIME 타입입니다.</target>
        </trans-unit>
        <trans-unit id="eee6e27810ba2393a1392a0340b18fa6717ec6eb" translate="yes" xml:space="preserve">
          <source>Informs the server about which character set the client is able to understand.</source>
          <target state="translated">클라이언트가 이해할 수있는 문자 집합을 서버에 알립니다.</target>
        </trans-unit>
        <trans-unit id="42cf6c04980a1ce5076cbc436e3d8fd8f9bd1eaa" translate="yes" xml:space="preserve">
          <source>Inheritance of policy for embedded content</source>
          <target state="translated">임베드 된 컨텐츠에 대한 정책 상속</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33acc0f454b7bc534181d5c180450e08b663048" translate="yes" xml:space="preserve">
          <source>Initial definition. Defines the &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header. Directives are defined in the specs for the features they control. See individual directive pages for details.</source>
          <target state="translated">초기 정의. &lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더를 정의합니다 . 지시문은 제어하는 ​​기능의 스펙에 정의되어 있습니다. 자세한 내용은 개별 지시문 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edd05a55e87a0a4d81fe6d4260b5996b65256986" translate="yes" xml:space="preserve">
          <source>Inline style attributes are also blocked:</source>
          <target state="translated">인라인 스타일 속성도 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b1392fca8ed54aab0cc2cacc082edcfe0d478690" translate="yes" xml:space="preserve">
          <source>Inspecting cookies using the Storage Inspector</source>
          <target state="translated">Storage Inspector를 사용하여 쿠키 검사</target>
        </trans-unit>
        <trans-unit id="888016dc3b8bc43c7d35e5a67e82071570e7e662" translate="yes" xml:space="preserve">
          <source>Instantiation of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; element will fail if:</source>
          <target state="translated">다음과 같은 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 인스턴스화 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fcd90298324aef5e8378a11b58c0458589479afd" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;content-security-policy/frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-security-policy/worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; 대신 중첩 된 브라우징 컨텍스트 및 작업자를 조정하려는 작성자는 각각 &lt;a href=&quot;content-security-policy/frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;content-security-policy/worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt; 지시문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7d972ef39c5afd44ac2beb99c854651c87a78a6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;child-src&lt;/code&gt;, authors who wish to regulate nested browsing contexts and workers should use the &lt;a href=&quot;frame-src&quot;&gt;&lt;code&gt;frame-src&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;worker-src&quot;&gt;&lt;code&gt;worker-src&lt;/code&gt;&lt;/a&gt; directives, respectively.</source>
          <target state="translated">&lt;code&gt;child-src&lt;/code&gt; 대신 중첩 된 브라우징 컨텍스트 및 작업자를 조정하려는 작성자는 각각 &lt;a href=&quot;frame-src&quot;&gt; &lt;code&gt;frame-src&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;worker-src&quot;&gt; &lt;code&gt;worker-src&lt;/code&gt; &lt;/a&gt; 지시문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e2c345c2bb8c9ae2f11a593aebecd152fbd0acd7" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client closes,&lt;em&gt;permanent cookies&lt;/em&gt; expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">클라이언트가 닫힐 때 만료되는 대신 &lt;em&gt;영구 쿠키&lt;/em&gt; 는 특정 날짜 ( &lt;code&gt;Expires&lt;/code&gt; ) 또는 특정 기간 ( &lt;code&gt;Max-Age&lt;/code&gt; ) 후에 만료 됩니다.</target>
        </trans-unit>
        <trans-unit id="687abe5b976f19cc45e08804dc047a80872035fb" translate="yes" xml:space="preserve">
          <source>Instead of expiring when the client is closed, permanent cookies expire at a specific date (&lt;code&gt;Expires&lt;/code&gt;) or after a specific length of time (&lt;code&gt;Max-Age&lt;/code&gt;).</source>
          <target state="translated">클라이언트가 닫힐 때 만료되는 대신 영구 쿠키는 특정 날짜 ( &lt;code&gt;Expires&lt;/code&gt; ) 또는 특정 기간 ( &lt;code&gt;Max-Age&lt;/code&gt; ) 후에 만료 됩니다.</target>
        </trans-unit>
        <trans-unit id="36cf82c2a961317e1eff83740cd0b4132837ed88" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header you can also use a &lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt;&lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt;&lt;/a&gt; header. This header only sends reports to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header and does still allow browsers to connect to the webserver even if the pinning is violated.</source>
          <target state="translated">&lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 헤더를 사용하는 대신 &lt;a href=&quot;headers/public-key-pins-report-only&quot;&gt; &lt;code&gt;Public-Key-Pins-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 를 사용할 수도 있습니다 . 이 헤더는 헤더에 지정된 &lt;code&gt;report-uri&lt;/code&gt; 로만 보고서를 전송 하며 고정을 위반하더라도 브라우저가 웹 서버에 계속 연결할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3750ed931b77d473b6340fb847310a94be2c064d" translate="yes" xml:space="preserve">
          <source>Instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">사용자 에이전트에게 콘텐츠 보안 정책 위반 시도를보고하도록 지시합니다. 이러한 위반 보고서 는 HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 통해 지정된 URI로 전송 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; 문서로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="da42a3abb7f8b91ffc4fd5c08ba6b30c83141085" translate="yes" xml:space="preserve">
          <source>Instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">사용자 에이전트가 모든 사이트의 안전하지 않은 URL (HTTP를 통해 제공되는 URL)을 보안 URL (HTTPS를 통해 제공되는 URL)로 교체 한 것처럼 처리하도록 지시합니다. 이 지정 문은 다시 작성해야하는 안전하지 않은 기존 URL이 많은 웹 사이트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="206bbd6a7b7d6a23df99e3ac10a5c7e4495332dd" translate="yes" xml:space="preserve">
          <source>Integration with CSS</source>
          <target state="translated">CSS와 통합</target>
        </trans-unit>
        <trans-unit id="eded9e1af9c609a228692b23c36ea0973e62cf9c" translate="yes" xml:space="preserve">
          <source>Integration with HTML</source>
          <target state="translated">HTML과 통합</target>
        </trans-unit>
        <trans-unit id="241c7e4997c321b689e3324be2a21f7dbf1a7358" translate="yes" xml:space="preserve">
          <source>Integrity of a partial download</source>
          <target state="translated">부분 다운로드의 무결성</target>
        </trans-unit>
        <trans-unit id="d7339840c521459441002b60ebbff7f9e4807175" translate="yes" xml:space="preserve">
          <source>Internet Draft</source>
          <target state="translated">인터넷 초안</target>
        </trans-unit>
        <trans-unit id="944b611c46b28ffd8244fb42daaa4b9496b1cf13" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7230                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                    J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818&lt;/a&gt;                                           greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7230 Adobe 단종 제품 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;2145&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke, Ed. 업데이트 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;2818&lt;/a&gt; greenbytes 범주 : 표준 트랙 2014 년 6 월 ISSN : 2070-1721</target>
        </trans-unit>
        <trans-unit id="a37f9383c64e54f8eb287b01c2b6207a20637c11" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7231 Adobe 지원되지 않음 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke, Ed. 업데이트 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;2817&lt;/a&gt; greenbytes 범주 : 표준 트랙 2014 년 6 월 ISSN : 2070-1721</target>
        </trans-unit>
        <trans-unit id="ac7e3a4b626b90a8dbd99bacd4566ca932b34a3b" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7232                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Category: Standards Track                                     greenbytes
ISSN: 2070-1721                                                June 2014</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7232 Adobe 지원되지 않음 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke, Ed. 카테고리 : 표준 트랙 그린 바이트 ISSN : 2070-1721 2014 년 6 월</target>
        </trans-unit>
        <trans-unit id="f19a38d04cab53923494c67976d4e498a99f2c29" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7233                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                            Y. Lafon, Ed.
Category: Standards Track                                            W3C
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                              June 2014</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7233 Adobe 단종 제품 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; Y. Lafon, Ed. 카테고리 : 표준 트랙 W3C ISSN : 2070-1721 J. Reschke, Ed. greenbytes 2014 년 6 월</target>
        </trans-unit>
        <trans-unit id="abf0c52384302c538626557887406ff5785b7493" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7234                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                       M. Nottingham, Ed.
Category: Standards Track                                         Akamai
ISSN: 2070-1721                                          J. Reschke, Ed.
                                                              greenbytes
                                                               June 2014</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7234 Adobe 단종 제품 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; M. Nottingham, Ed. 카테고리 : 표준 트랙 Akamai ISSN : 2070-1721 J. Reschke, Ed. greenbytes 2014 년 6 월</target>
        </trans-unit>
        <trans-unit id="4cf7cbfbbfccd70ae7ed26796d1828c5ad2463df" translate="yes" xml:space="preserve">
          <source>Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7235                                         Adobe
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt;                                          J. Reschke, Ed.
Updates: &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721</source>
          <target state="translated">IETF (Internet Engineering Task Force) R. Fielding, Ed. 의견 요청 : 7235 Adobe 단종 제품 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;2616&lt;/a&gt; J. Reschke, Ed. 업데이트 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt; greenbytes 범주 : 표준 트랙 2014 년 6 월 ISSN : 2070-1721</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">인터넷 익스플로러</target>
        </trans-unit>
        <trans-unit id="ee29687168fb4fd84a3acc654a9db5d9db8c1813" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8</source>
          <target state="translated">인터넷 익스플로러 8</target>
        </trans-unit>
        <trans-unit id="b50d4fdd010f7da47bc090ba56b32ab192bd7efd" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 and 9 expose CORS via the &lt;code&gt;XDomainRequest&lt;/code&gt; object, but have a full implementation in IE 10.</source>
          <target state="translated">Internet Explorer 8 및 9는 &lt;code&gt;XDomainRequest&lt;/code&gt; 객체 를 통해 CORS를 노출 하지만 IE 10에서는 완전히 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f09fc55fe960cdc577a491b6af400c7ecc717639" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 or earlier</source>
          <target state="translated">Internet Explorer 8 이하</target>
        </trans-unit>
        <trans-unit id="9df82ce454660e2e95801528c257a56a7c65b8f4" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9</source>
          <target state="translated">인터넷 익스플로러 9</target>
        </trans-unit>
        <trans-unit id="ab3ccd4c44d2e9f7601c41c05c58eb093f7971c4" translate="yes" xml:space="preserve">
          <source>Internet Explorer UA string</source>
          <target state="translated">Internet Explorer UA 문자열</target>
        </trans-unit>
        <trans-unit id="935b07a4771d1ecca905a5712a8abb0cb5f5eebd" translate="yes" xml:space="preserve">
          <source>Internet Explorer doesn't put its name in the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; format</source>
          <target state="translated">Internet Explorer는 이름을 &lt;em&gt;BrowserName / VersionNumber&lt;/em&gt; 형식으로 지정하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b2b280e0cd215dee60eed1d1e3dbd22fa9b08456" translate="yes" xml:space="preserve">
          <source>Internet Explorer put this token in the &lt;em&gt;comment&lt;/em&gt; part of the User Agent String</source>
          <target state="translated">Internet Explorer는이 토큰을 사용자 에이전트 문자열 의 &lt;em&gt;주석&lt;/em&gt; 부분에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="a1ee7fdf2dfeeebbbf381e7307a8cb5b69c060fd" translate="yes" xml:space="preserve">
          <source>Internet Standard</source>
          <target state="translated">인터넷 표준</target>
        </trans-unit>
        <trans-unit id="a3dfded56299e82b9ecd1b36148982d1169af1c0" translate="yes" xml:space="preserve">
          <source>Internet hosts by name or IP address, as well as an optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL scheme&lt;/a&gt; and/or port number. The site's address may include an optional leading wildcard (the asterisk character, &lt;code&gt;'*'&lt;/code&gt;), and you may use a wildcard (again, &lt;code&gt;'*'&lt;/code&gt;) as the port number, indicating that all legal ports are valid for the source.</source>
          <target state="translated">선택적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/URIs_and_URLs&quot;&gt;URL 체계&lt;/a&gt; 및 / 또는 포트 번호 뿐만 아니라 이름 또는 IP 주소 별 인터넷 호스트 . 사이트 주소에는 선택적 선행 와일드 카드 (별표 문자 &lt;code&gt;'*'&lt;/code&gt; )가 포함될 수 있으며 와일드 카드 (다시 &lt;code&gt;'*'&lt;/code&gt; )를 포트 번호로 사용하여 모든 유효한 포트가 소스에 유효 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="037a2067974b5b1a90e1e346b9991a68825acb64" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form in order to
   be interoperable among systems with varying native encoding formats.
   Representations selected or transferred via HTTP ought to be in
   canonical form, for many of the same reasons described by the
   Multipurpose Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;].  However, the
   performance characteristics of email deployments (i.e., store and
   forward messages to peers) are significantly different from those
   common to HTTP and the Web (server-based information services).
   Furthermore, MIME's constraints for the sake of compatibility with
   older mail transfer protocols do not apply to HTTP (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;). 

   MIME's canonical form requires that media subtypes of the &quot;text&quot; type
   use CRLF as the text line break.  HTTP allows the transfer of text
   media with plain CR or LF alone representing a line break, when such
   line breaks are consistent for an entire representation.  An HTTP
   sender MAY generate, and a recipient MUST be able to parse, line
   breaks in text media that consist of CRLF, bare CR, or bare LF.  In
   addition, text media in HTTP is not limited to charsets that use
   octets 13 and 10 for CR and LF, respectively.  This flexibility
   regarding line breaks applies only to text within a representation
   that has been assigned a &quot;text&quot; media type; it does not apply to
   &quot;multipart&quot; types or HTTP elements outside the payload body (e.g.,
   header fields).

   If a representation is encoded with a content-coding, the underlying
   data ought to be in a form defined above prior to being encoded.</source>
          <target state="translated">인터넷 미디어 유형은 다양한 기본 인코딩 형식을 가진 시스템간에 상호 운용 될 수 있도록 표준 형식으로 등록됩니다. HTTP를 통해 선택 또는 전송 된 표현은 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에 설명 된 것과 동일한 여러 가지 이유로 정식 형식이어야 합니다. 그러나 전자 메일 배포의 성능 (즉, 메시지를 피어에 저장 및 전달)의 성능 특성은 HTTP 및 웹 (서버 기반 정보 서비스)에 일반적인 것과 크게 다릅니다. 또한 이전 메일 전송 프로토콜과의 호환성을 위해 MIME의 제약 조건은 HTTP에 적용되지 않습니다 ( &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; 참조) .). MIME의 정식 형식에서는 &quot;text&quot;형식의 미디어 하위 유형에 CRLF를 텍스트 줄 바꿈으로 사용해야합니다. 줄 바꿈이 전체 표현에 대해 일관된 경우 HTTP는 줄 바꿈을 나타내는 일반 CR 또는 LF만으로 텍스트 미디어를 전송할 수 있습니다. HTTP 발신자는 CRLF, 베어 CR 또는 베어 LF로 구성된 텍스트 미디어에서 줄 바꿈을 생성하고 구문 분석 할 수 있어야합니다. 또한 HTTP의 텍스트 미디어는 각각 CR 및 LF에 대해 옥텟 13과 10을 사용하는 문자 집합으로 제한되지 않습니다. 줄 바꿈과 관련된 이러한 유연성은 &quot;텍스트&quot;미디어 유형이 지정된 표현 내의 텍스트에만 적용됩니다. 페이로드 본문 외부의 &quot;멀티 파트&quot;유형 또는 HTTP 요소 (예 : 헤더 필드)에는 적용되지 않습니다.표현이 컨텐츠 코딩으로 인코딩되는 경우, 기본 데이터는 인코딩되기 전에 위에서 정의 된 형식이어야한다.</target>
        </trans-unit>
        <trans-unit id="23ce3ccc1ff356540fdaac404f8bf64e60f80ef1" translate="yes" xml:space="preserve">
          <source>Internet media types are registered with a canonical form. An
   entity-body transferred via HTTP messages MUST be represented in the
   appropriate canonical form prior to its transmission except for
   &quot;text&quot; types, as defined in the next paragraph.

   When in canonical form, media subtypes of the &quot;text&quot; type use CRLF as
   the text line break. HTTP relaxes this requirement and allows the
   transport of text media with plain CR or LF alone representing a line
   break when it is done consistently for an entire entity-body. HTTP
   applications MUST accept CRLF, bare CR, and bare LF as being
   representative of a line break in text media received via HTTP. In
   addition, if the text is represented in a character set that does not
   use octets 13 and 10 for CR and LF respectively, as is the case for
   some multi-byte character sets, HTTP allows the use of whatever octet
   sequences are defined by that character set to represent the
   equivalent of CR and LF for line breaks. This flexibility regarding
   line breaks applies only to text media in the entity-body; a bare CR
   or LF MUST NOT be substituted for CRLF within any of the HTTP control
   structures (such as header fields and multipart boundaries).

   If an entity-body is encoded with a content-coding, the underlying
   data MUST be in a form defined above prior to being encoded.

   The &quot;charset&quot; parameter is used with some media types to define the
   character set (&lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;) of the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the &quot;text&quot;
   type are defined to have a default charset value of &quot;ISO-8859-1&quot; when
   received via HTTP. Data in character sets other than &quot;ISO-8859-1&quot; or
   its subsets MUST be labeled with an appropriate charset value. See
   &lt;a href=&quot;#section-3.4.1&quot;&gt;section 3.4.1&lt;/a&gt; for compatibility problems.</source>
          <target state="translated">인터넷 미디어 유형은 표준 형식으로 등록됩니다. HTTP 메시지를 통해 전송 된 엔티티 본문은 다음 단락에 정의 된 &quot;텍스트&quot;유형을 제외하고 전송 전에 적절한 정식 형식으로 표시되어야합니다. 정식 형식 인 경우 &quot;텍스트&quot;유형의 미디어 하위 유형은 CRLF를 텍스트 줄 바꿈으로 사용합니다. HTTP는이 요구 사항을 완화하고 전체 엔터티 본문에 대해 일관된 작업을 수행 할 때 줄 바꿈을 나타내는 일반 CR 또는 LF만으로 텍스트 미디어를 전송할 수 있습니다. HTTP 응용 프로그램은 반드시 HTTP를 통해 수신 한 텍스트 미디어의 줄 바꿈을 나타내는 CRLF, Bare CR 및 Bare LF를 수용해야합니다. 또한 텍스트가 CR 및 LF에 대해 각각 옥텟 13과 10을 사용하지 않는 문자 세트로 표시되는 경우,일부 멀티 바이트 문자 집합의 경우와 마찬가지로 HTTP를 사용하면 해당 문자 집합으로 정의 된 모든 8 진수 시퀀스를 사용하여 줄 바꿈에 대한 CR 및 LF에 해당합니다. 줄 바꿈과 관련된 이러한 유연성은 엔티티 본문의 텍스트 미디어에만 적용됩니다. 베어 CR 또는 LF는 HTTP 제어 구조 (예 : 헤더 필드 및 멀티 파트 경계) 내에서 CRLF로 대체해서는 안됩니다. 엔터티 본문이 콘텐츠 코딩으로 인코딩 된 경우 기본 데이터는 인코딩되기 전에 위에서 정의한 형식이어야합니다. &quot;charset&quot;매개 변수는 일부 매체 유형과 함께 사용하여 문자 세트를 정의합니다 (줄 바꿈과 관련된 이러한 유연성은 엔티티 본문의 텍스트 미디어에만 적용됩니다. 베어 CR 또는 LF는 HTTP 제어 구조 (예 : 헤더 필드 및 멀티 파트 경계) 내에서 CRLF로 대체해서는 안됩니다. 엔터티 본문이 콘텐츠 코딩으로 인코딩 된 경우 기본 데이터는 인코딩되기 전에 위에서 정의한 형식이어야합니다. &quot;charset&quot;매개 변수는 일부 매체 유형과 함께 사용하여 문자 세트를 정의합니다 (줄 바꿈과 관련된 이러한 유연성은 엔티티 본문의 텍스트 미디어에만 적용됩니다. 베어 CR 또는 LF는 HTTP 제어 구조 (예 : 헤더 필드 및 멀티 파트 경계) 내에서 CRLF로 대체해서는 안됩니다. 엔터티 본문이 콘텐츠 코딩으로 인코딩 된 경우 기본 데이터는 인코딩되기 전에 위에서 정의한 형식이어야합니다. &quot;charset&quot;매개 변수는 일부 매체 유형과 함께 사용하여 문자 세트를 정의합니다 (매개 변수는 일부 매체 유형과 함께 사용하여 문자 세트를 정의합니다 (매개 변수는 일부 매체 유형과 함께 사용하여 문자 세트를 정의합니다 (&lt;a href=&quot;#section-3.4&quot;&gt;&lt;/a&gt;데이터의 섹션 3.4 ). 발신자가 명시적인 문자 집합 매개 변수를 제공하지 않으면 &quot;text&quot;형식의 미디어 하위 유형은 HTTP를 통해 수신 될 때 기본 문자 집합 값 &quot;ISO-8859-1&quot;을 갖도록 정의됩니다. &quot;ISO-8859-1&quot;이외의 문자 세트 또는 해당 서브 세트의 데이터는 적절한 문자 세트 값으로 레이블되어야합니다. 호환성 문제는 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ded9c72dfd997c4640e3e4defef803106231f1f6" translate="yes" xml:space="preserve">
          <source>Introduced in HTTP/1.0, &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; made this protocol easy to extend and experiment with. New functionality can even be introduced by a simple agreement between a client and a server about a new header's semantics.</source>
          <target state="translated">HTTP / 1.0에 도입 된 HTTP &lt;a href=&quot;headers&quot;&gt;헤더&lt;/a&gt; 를 통해이 프로토콜을 쉽게 확장하고 실험 할 수 있습니다. 새로운 헤더의 의미에 대해 클라이언트와 서버 간의 간단한 계약을 통해 새로운 기능을 도입 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1117753f6df6a46418e743d7060ef1767501957d" translate="yes" xml:space="preserve">
          <source>Introduction to Feature Policy</source>
          <target state="translated">기능 정책 소개</target>
        </trans-unit>
        <trans-unit id="80e829c3a10d9e489ea935dbe19658e50845954c" translate="yes" xml:space="preserve">
          <source>Invalid dates, like the value 0, represent a date in the past and mean that the resource is already expired.</source>
          <target state="translated">값 0과 같은 유효하지 않은 날짜는 과거의 날짜를 나타내며 리소스가 이미 만료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dfa60022094016d57bd557254bafb6ff9bbe3d2a" translate="yes" xml:space="preserve">
          <source>Invalid domains</source>
          <target state="translated">잘못된 도메인</target>
        </trans-unit>
        <trans-unit id="9032ed3737ead87641e8c9fd63add1c68fa832be" translate="yes" xml:space="preserve">
          <source>Invalid parameters in media, or typos when specifying &lt;code&gt;'base64'&lt;/code&gt;, are ignored, but no error is provided.</source>
          <target state="translated">미디어의 잘못된 매개 변수 또는 &lt;code&gt;'base64'&lt;/code&gt; 를 지정할 때 오타 가 무시되지만 오류는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db5e158a717067d22e2fe4cb88250953ddf29eb6" translate="yes" xml:space="preserve">
          <source>Invalidation (RFC 7234)</source>
          <target state="translated">무효화 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="380eceb118a2210931ae6c7c6f4918fcad2be151" translate="yes" xml:space="preserve">
          <source>Invention of the World Wide Web</source>
          <target state="translated">월드 와이드 웹의 발명</target>
        </trans-unit>
        <trans-unit id="96fe62d1784a07fd038cfab3bf1502f6c16a7790" translate="yes" xml:space="preserve">
          <source>Invocations of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs in a cross-site manner, as discussed above.</source>
          <target state="translated">위에서 설명한대로 교차 사이트 방식으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; API를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2422fcd418c687b013805ec7620a6399f1372c7e" translate="yes" xml:space="preserve">
          <source>Is a response header if the resource transmitted should be displayed inline (default behavior when the header is not present), or it should be handled like a download and the browser should present a 'Save As' window.</source>
          <target state="translated">전송 된 리소스가 인라인으로 표시되거나 (헤더가없는 경우 기본 동작) 응답 헤더이며 다운로드처럼 처리되어야하며 브라우저에 '다른 이름으로 저장'창이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="54e9ec692a56ffab91bf47f24b6f5f04f83ce33b" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot; or is left out.</source>
          <target state="translated">문자열 &quot;GMT&quot;이거나 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="a64fa4c3a913c82e4add144ea7fbfd9cf3825b6d" translate="yes" xml:space="preserve">
          <source>Is either the string &quot;GMT&quot;, which makes time comparison occur in GMT timezone, or is left out. If left unspecified, times are taken to be in the local timezone.</source>
          <target state="translated">&quot;GMT&quot;문자열로, GMT 시간대에서 시간 비교가 발생하거나 생략됩니다. 지정하지 않으면 시간이 현지 시간대로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba85fc81b8929d8f78e20fd1bc753c0fb30e0fc" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the name of the HTML field in the form that the content of this subpart refers to. When dealing with multiple files in the same field (for example, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; attribute of an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; element), there can be several subparts with the same name.</source>
          <target state="translated">이 서브 파트의 내용이 참조하는 형식으로 HTML 필드의 이름을 포함하는 문자열이 뒤에옵니다. 동일한 필드에서 여러 파일을 처리 할 때 (예 : &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&amp;lt;input type=file&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-multiple&quot;&gt;multiple&lt;/a&gt;&lt;/code&gt; 속성 ) 동일한 이름을 가진 여러 하위 파트가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e092b4d92d6c6e47005b961bfdf49f31576121c" translate="yes" xml:space="preserve">
          <source>Is followed by a string containing the original name of the file transmitted. The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done. This parameter provides mostly indicative information. When used in combination with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;, it is used as the default filename for an eventual &quot;Save As&quot; dialog presented to the user.</source>
          <target state="translated">전송 된 파일의 원래 이름이 포함 된 문자열이 뒤에옵니다. 파일 이름은 항상 선택 사항이며 응용 프로그램에서 맹목적으로 사용해서는 안됩니다. 경로 정보를 제거하고 서버 파일 시스템 규칙으로 변환해야합니다. 이 매개 변수는 주로 표시 정보를 제공합니다. &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 와 함께 사용하면 최종 &quot;다른 이름으로 저장&quot;대화 상자의 기본 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad350b49b6105f7ba408d2cd47de12fe45080a69" translate="yes" xml:space="preserve">
          <source>Is one of the ordered month strings below.</source>
          <target state="translated">아래의 주문 월 문자열 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="77e28a9350d45487207b84bc262233bfb40e6bc5" translate="yes" xml:space="preserve">
          <source>Is the domain name to test the hostname against.</source>
          <target state="translated">호스트 이름을 테스트 할 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5e530d4a48748eedf183a271fc2d6561b7e57883" translate="yes" xml:space="preserve">
          <source>Is the hostname from the URL.</source>
          <target state="translated">URL의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2e041ae111b4fa679b2480031c90505ef7ed4674" translate="yes" xml:space="preserve">
          <source>Is the hour from 0 to 23. (0 is midnight, 23 is 11 pm.)</source>
          <target state="translated">0부터 23까지의 시간입니다. (0은 자정, 23은 오후 11시입니다.)</target>
        </trans-unit>
        <trans-unit id="76bc382859db96f13208fadcaadcd35c9c7d32d7" translate="yes" xml:space="preserve">
          <source>Is the ordered day of the month between 1 and 31 (as an integer).</source>
          <target state="translated">1에서 31 사이의 월 순서 (정수)입니다.</target>
        </trans-unit>
        <trans-unit id="7165ac45c85ea0d30878e33d1b544beb92ad0407" translate="yes" xml:space="preserve">
          <source>Is the ordered full year integer number. For example, 2016 (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">정렬 된 전체 연도 정수입니다. 예를 들어 2016은 16이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ecffee78fc03e20a569b23ceac7747629660f84c" translate="yes" xml:space="preserve">
          <source>Is true if the hostname matches exactly the specified hostname, or if there is no domain name part in the hostname, but the unqualified hostname matches.</source>
          <target state="translated">호스트 이름이 지정된 호스트 이름과 정확히 일치하거나 호스트 이름에 도메인 이름 부분이 없지만 규정되지 않은 호스트 이름이 일치하면 true입니다.</target>
        </trans-unit>
        <trans-unit id="0bea60d3e6673895b89b3e27ba8883ed44567185" translate="yes" xml:space="preserve">
          <source>It allows a server to populate data in a client cache, in advance of it being required, through a mechanism called the server push.</source>
          <target state="translated">서버 푸시라는 메커니즘을 통해 서버가 클라이언트 캐시에 필요한 데이터를 미리 데이터를 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f46736fbac23773dd54664bce214c5dc4f10a2c6" translate="yes" xml:space="preserve">
          <source>It can be used when the total number of request header fields is too large, or when a single header field is at too large.</source>
          <target state="translated">요청 헤더 필드의 총 수가 너무 많거나 단일 헤더 필드가 너무 클 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1727a3eed7f9b9c35a928b776172744af8666f3" translate="yes" xml:space="preserve">
          <source>It compresses headers. As these are often similar among a set of requests, this removes duplication and overhead of data transmitted.</source>
          <target state="translated">헤더를 압축합니다. 이것들은 종종 일련의 요청들 사이에서 유사하기 때문에 전송 된 데이터의 복제 및 오버 헤드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4b480764290e819516d7c049141dbc95445b3642" translate="yes" xml:space="preserve">
          <source>It is a binary protocol rather than text. It can no longer be read and created manually. Despite this hurdle, improved optimization techniques can now be implemented.</source>
          <target state="translated">텍스트가 아닌 이진 프로토콜입니다. 더 이상 수동으로 읽고 만들 수 없습니다. 이러한 장애물에도 불구하고, 이제 개선 된 최적화 기술을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad2ad311f9d8d7e181ed23c4b923cbf915ec8c4" translate="yes" xml:space="preserve">
          <source>It is a multiplexed protocol. Parallel requests can be handled over the same connection, removing the order and blocking constraints of the HTTP/1.x protocol.</source>
          <target state="translated">다중화 된 프로토콜입니다. 병렬 요청은 동일한 연결을 통해 처리 될 수있어 HTTP / 1.x 프로토콜의 순서와 차단 제약 조건을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a7b12c882112937be30ce15f7fdc909be28edb8f" translate="yes" xml:space="preserve">
          <source>It is a validator, a unique string identifying the version of the resource. Conditional requests using &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">자원의 버전을 식별하는 고유 한 문자열 인 유효성 검증기입니다. &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; 를&lt;/a&gt; 사용하는 조건부 요청 은이 값을 사용하여 요청의 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5cdf965cca7cbedbb40498332c66597692a803a9" translate="yes" xml:space="preserve">
          <source>It is a validator, the last modification date of the resource, used to compare several versions of the same resource. It is less accurate than &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but easier to calculate in some environments. Conditional requests using &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">자원의 마지막 수정 날짜 인 유효성 검증기로서 동일한 자원의 여러 버전을 비교하는 데 사용됩니다. &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 보다 정확도는 떨어지지 만 일부 환경에서는 계산하기가 더 쉽습니다. &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 를&lt;/a&gt; 사용하는 조건부 요청 은이 값을 사용하여 요청의 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="9785aaf5047339a17ab49de4a65661f34c75c502" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of a protocol specification to mandate
   compliance with previous versions. HTTP/1.1 was deliberately
   designed, however, to make supporting previous versions easy. It is
   worth noting that, at the time of composing this specification
   (1996), we would expect commercial HTTP/1.1 servers to:

      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and
        1.1 requests; 

      - understand any valid request in the format of HTTP/0.9, 1.0, or
        1.1;

      - respond appropriately with a message in the same major version
        used by the client.

   And we would expect HTTP/1.1 clients to:

      - recognize the format of the Status-Line for HTTP/1.0 and 1.1
        responses;

      - understand any valid response in the format of HTTP/0.9, 1.0, or
        1.1.

   For most implementations of HTTP/1.0, each connection is established
   by the client prior to the request and closed by the server after
   sending the response. Some implementations implement the Keep-Alive
   version of persistent connections described in section 19.7.1 of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">이전 버전의 준수를 요구하는 것은 프로토콜 사양의 범위를 벗어납니다. 그러나 HTTP / 1.1은 의도적으로 이전 버전을 쉽게 지원할 수 있도록 설계되었습니다. 이 규격 (1996)을 작성할 당시에 상용 HTTP / 1.1 서버는 다음을 기대할 것입니다.-HTTP / 0.9, 1.0 및 1.1 요청에 대한 요청 라인의 형식을 인식합니다. -HTTP / 0.9, 1.0 또는 1.1 형식의 유효한 요청을 이해합니다. -클라이언트가 사용하는 것과 동일한 주 버전의 메시지로 적절하게 응답합니다. 그리고 우리는 HTTP / 1.1 클라이언트가 :-HTTP / 1.0 및 1.1 응답을위한 Status-Line의 형식을 인식합니다; -HTTP / 0.9, 1.0 또는 1.1 형식의 유효한 응답을 이해하십시오.대부분의 HTTP / 1.0 구현에서 각 연결은 요청 전에 클라이언트에 의해 설정되고 응답을 보낸 후 서버에 의해 닫힙니다. 일부 구현에서는 섹션 19.7.1에 설명 된 영구 연결의 Keep-Alive 버전을 구현합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="8259fef778fc701ed117ff363698b323da319cfd" translate="yes" xml:space="preserve">
          <source>It is beyond the scope of this specification to describe how
   connections are established via various transport- or session-layer
   protocols.  Each connection applies to only one transport link.</source>
          <target state="translated">다양한 전송 또는 세션 계층 프로토콜을 통해 연결이 설정되는 방법을 설명하는 것은이 사양의 범위를 벗어납니다. 각 연결은 하나의 전송 링크에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d087e11ffd49739b77d44827cb4d007b8288ad" translate="yes" xml:space="preserve">
          <source>It is especially important that proxies correctly implement the
   properties of the Connection header field as specified in &lt;a href=&quot;#section-14.10&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;.

   The proxy server MUST signal persistent connections separately with
   its clients and the origin servers (or other proxy servers) that it
   connects to. Each persistent connection applies to only one transport
   link.

   A proxy server MUST NOT establish a HTTP/1.1 persistent connection
   with an HTTP/1.0 client (but see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;] for information and
   discussion of the problems with the Keep-Alive header implemented by
   many HTTP/1.0 clients).</source>
          <target state="translated">프록시가 &lt;a href=&quot;#section-14.10&quot;&gt;14.10 &lt;/a&gt;&lt;a href=&quot;#section-14.10&quot;&gt;섹션에&lt;/a&gt; 지정된 연결 헤더 필드의 속성을 올바르게 구현하는 것이 특히 중요합니다 . 프록시 서버는 반드시 클라이언트와 연결되는 오리진 서버 (또는 다른 프록시 서버)와 지속적으로 연결을 신호해야합니다. 각 영구 연결은 하나의 전송 링크에만 적용됩니다. 프록시 서버는 HTTP / 1.0 클라이언트와 HTTP / 1.1 영구 연결을 설정해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;안됩니다&lt;/a&gt; (그러나 많은 HTTP / 1.0 클라이언트가 구현 한 Keep-Alive 헤더의 문제점에 대한 정보 및 논의는 RFC 2068 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ] 참조 ).</target>
        </trans-unit>
        <trans-unit id="b498c25fadce9f183d82dd50870c277f51907a88" translate="yes" xml:space="preserve">
          <source>It is however still necessary for Firefox to load resources in web content under certain circumstances. For example, if you open the view source page (View Page Source or View Selection Source), you will find it requires &lt;code&gt;viewsource.css&lt;/code&gt; through a &lt;code&gt;resource:&lt;/code&gt; URI. Resources that have to be exposed to web content have been moved to a new location named &lt;code&gt;resource://content-accessible/&lt;/code&gt;, which is isolated and only contains non-sensitive resources. In this way we can keep essential resources exposed and have most threats eliminated.</source>
          <target state="translated">그러나 특정 상황에서 Firefox가 여전히 웹 컨텐츠에 자원을로드해야합니다. 예를 들어, 뷰 소스 페이지 (뷰 페이지 소스 또는 뷰 선택 소스)를 열면 &lt;code&gt;resource:&lt;/code&gt; URI를 통해 &lt;code&gt;viewsource.css&lt;/code&gt; 가 필요하다는 것을 알 수 있습니다 . 웹 컨텐츠에 노출되어야하는 &lt;code&gt;resource://content-accessible/&lt;/code&gt; 이라는 새 위치로 이동되었습니다.이 위치 는 격리되며 민감하지 않은 자원 만 포함합니다. 이러한 방식으로 필수 자원을 노출시키고 대부분의 위협을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7d678015e6dbddd6cd806a3a207ba38d15b32ae" translate="yes" xml:space="preserve">
          <source>It is important to avoid redirection loops as they completely break the user experience.</source>
          <target state="translated">리디렉션 루프는 사용자 환경을 완전히 손상시킬 수 있으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="7abd5b5646d7b956a07aef0207e3f862399863c2" translate="yes" xml:space="preserve">
          <source>It is possible to add a special HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element to a page to indicate what the canonical address of a page is. This has no impact on the human reader of the page, but tells search engine crawlers where the page actually lives. This way, search engines don't index the same page several times, potentially leading to it being considered as duplicate content or spam, and even removing or lowering your page from the search engine result pages.</source>
          <target state="translated">페이지의 표준 주소가 무엇인지 나타 내기 위해 페이지에 특수 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 추가 할 수 있습니다 . 이는 사람이 페이지를 읽는 사람에게는 영향을 미치지 않지만 검색 엔진 크롤러에게 페이지의 실제 위치를 알려줍니다. 이러한 방식으로 검색 엔진은 동일한 페이지를 여러 번 색인 생성하지 않으므로 중복 된 콘텐츠 나 스팸으로 간주 될 수 있으며 검색 엔진 결과 페이지에서 페이지를 제거하거나 줄일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a360170218e1e7d2c6f7cc097d32c2f58946eee" translate="yes" xml:space="preserve">
          <source>It is possible to deploy &lt;code&gt;strict-dynamic&lt;/code&gt; in a backwards compatible way, without requiring user-agent sniffing.</source>
          <target state="translated">사용자 에이전트 스니핑을 요구하지 않고 이전 버전과 호환되는 방식으로 &lt;code&gt;strict-dynamic&lt;/code&gt; 배포가 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="d542c890e06636447b6f6b9d8af60c44ef672877" translate="yes" xml:space="preserve">
          <source>It is quite difficult to have a unique identifier for strong validation with &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt;. Often this is done using an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; with the MD5 hash of the resource (or a derivative).</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; 로&lt;/a&gt; 강력한 검증을위한 고유 식별자를 갖는 것은 매우 어렵습니다 . 자원의 MD5 해시 (또는 파생물)와 함께 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 를 사용하여 종종 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="98ff32d0856e5c15bbca04673b6c6f97714c4530" translate="yes" xml:space="preserve">
          <source>It's difficult to build a website that uses all the latest best practices and provides great performance and user experiences. As the website evolves, it can become even harder to maintain the user experience over time. You can use feature policies to specify the desired best practices, and rely on the browser to enforce the policies to prevent regressions.</source>
          <target state="translated">모든 최신 모범 사례를 사용하고 뛰어난 성능과 사용자 경험을 제공하는 웹 사이트를 구축하는 것은 어렵습니다. 웹 사이트가 발전함에 따라 시간이 지남에 따라 사용자 경험을 유지하기가 더욱 어려워 질 수 있습니다. 기능 정책을 사용하여 원하는 모범 사례를 지정하고 브라우저를 사용하여 정책을 적용하여 회귀를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa57fd9b104487236e3d21ead681f7448b30db9" translate="yes" xml:space="preserve">
          <source>It's easy to find the correspondences by looking at the &lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurial repository names&lt;/a&gt;: repositories starting by &lt;code&gt;mozilla-b2g&lt;/code&gt; are the release repositories for Firefox OS, and have both Firefox OS and Gecko versions in their names.</source>
          <target state="translated">&lt;a href=&quot;https://hg.mozilla.org/releases&quot;&gt;Mercurial 리포지토리 이름&lt;/a&gt; 을 보면 해당 내용을 쉽게 찾을 수 있습니다 . &lt;code&gt;mozilla-b2g&lt;/code&gt; 로 시작하는 리포지토리는 Firefox OS의 릴리스 리포지토리이며 이름에 Firefox OS 및 Gecko 버전이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="5250b829db5c42c7a082fb33c46a6aed6b45b478" translate="yes" xml:space="preserve">
          <source>It's important point to note that connection management in HTTP applies to the connection between two consecutive nodes, which is &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; and not &lt;a href=&quot;headers#e2e&quot;&gt;end-to-end&lt;/a&gt;. The model used in connections between a client and its first proxy may differ from the model between a proxy and the destination server (or any intermediate proxies). The HTTP headers involved in defining the connection model, like &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, are &lt;a href=&quot;headers#hbh&quot;&gt;hop-by-hop&lt;/a&gt; headers with their values able to be changed by intermediary nodes.</source>
          <target state="translated">그것은 HTTP의 연결 관리는 두 개의 연속적인 노드 사이의 연결에 적용하는 것이 중요 포인트입니다 &lt;a href=&quot;headers#hbh&quot;&gt;홉 - 바이 - 홉&lt;/a&gt; 아니라 &lt;a href=&quot;headers#e2e&quot;&gt;엔드 - 투 - 엔드&lt;/a&gt; . 클라이언트와 첫 번째 프록시 간의 연결에 사용되는 모델은 프록시와 대상 서버 (또는 중간 프록시) 간의 모델과 다를 수 있습니다. &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; 와 같은 연결 모델 정의와 관련된 HTTP 헤더 는 중간 노드에서 값을 변경할 수있는 &lt;a href=&quot;headers#hbh&quot;&gt;홉별&lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="739ff299232862f99e9340517c687340775d8925" translate="yes" xml:space="preserve">
          <source>It's standard procedure to start a connection using HTTP/1.1, due to its broad support, then request an upgrade to HTTP/2. This way, you have a functioning connection still even if HTTP/2 isn't supported by the server. However, you can only upgrade to an insecure (cleartext) HTTP/2 connection. This is done using the target protocol name &lt;code&gt;h2c&lt;/code&gt;, which stands for &quot;HTTP/2 Cleartext&quot;. This also &lt;em&gt;requires&lt;/em&gt; the specification of the &lt;code&gt;HTTP2-Settings&lt;/code&gt; header field.</source>
          <target state="translated">광범위한 지원으로 인해 HTTP / 1.1을 사용하여 연결을 시작한 다음 HTTP / 2 로의 업그레이드를 요청하는 표준 절차입니다. 이렇게하면 서버에서 HTTP / 2를 지원하지 않더라도 연결이 작동합니다. 그러나 안전하지 않은 (일반 텍스트) HTTP / 2 연결로만 업그레이드 할 수 있습니다. 이는 &quot;HTTP / 2 &lt;code&gt;h2c&lt;/code&gt; &quot;를 나타내는 대상 프로토콜 이름 h2c를 사용하여 수행됩니다 . 또한 &lt;code&gt;HTTP2-Settings&lt;/code&gt; 헤더 필드 의 스펙 이 &lt;em&gt;필요&lt;/em&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="8bea6d61f9c2501d81011d81f34e205f8686dfa5" translate="yes" xml:space="preserve">
          <source>It's worth re-iterating: it's very rarely a good idea to use user agent sniffing. You can almost always find a better, more broadly compatible way to solve your problem!</source>
          <target state="translated">다시 언급 할 가치가 있습니다. 사용자 에이전트 스니핑을 사용하는 것은 매우 드물다. 거의 항상 문제를 해결할 수있는 더 우수하고 광범위하게 호환되는 방법을 찾을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="1eed6d58a74c7c8d582fdf2be8d22bcb2c8939ca" translate="yes" xml:space="preserve">
          <source>JPEG images</source>
          <target state="translated">JPEG 이미지</target>
        </trans-unit>
        <trans-unit id="5766bfd5841dee1b6f2aaf89bbb921f60e7d1b6f" translate="yes" xml:space="preserve">
          <source>JSON format</source>
          <target state="translated">JSON 형식</target>
        </trans-unit>
        <trans-unit id="eb7b5a55874bccbd5415aa333ebe2f4d5bc10f49" translate="yes" xml:space="preserve">
          <source>Java Archive (JAR)</source>
          <target state="translated">자바 아카이브 (JAR)</target>
        </trans-unit>
        <trans-unit id="0bd88372ee65c120d42e02af79e6d6a3eb158cea" translate="yes" xml:space="preserve">
          <source>JavaScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">JavaScript ( &lt;a href=&quot;https://www.iana.org/assignments/media-types/application/javascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; 사양&lt;/em&gt;&lt;/a&gt; ) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 섹션 8.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="14198645a38762965b009588906bec6466424e7f" translate="yes" xml:space="preserve">
          <source>JavaScript access using &lt;code&gt;Document.cookie&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Document.cookie&lt;/code&gt; 를 사용한 JavaScript 액세스</target>
        </trans-unit>
        <trans-unit id="02726ffcb85ce089b78555f5977ff60b7b1e1236" translate="yes" xml:space="preserve">
          <source>JavaScript files</source>
          <target state="translated">자바 스크립트 파일</target>
        </trans-unit>
        <trans-unit id="3be64216bdf0b966d93ddd891c18c487fb2b9ae8" translate="yes" xml:space="preserve">
          <source>JavaScript redirections</source>
          <target state="translated">자바 스크립트 리디렉션</target>
        </trans-unit>
        <trans-unit id="8a908fed06c72f5e490a9950a8717a85839ac02f" translate="yes" xml:space="preserve">
          <source>JavaScript redirects are used as the last resort, and only if JavaScript is enabled on the client side.</source>
          <target state="translated">JavaScript 리디렉션은 최후의 수단으로 사용되며 클라이언트 측에서 JavaScript가 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a51f0d37d8a868b09fd7045118623248a30aff4" translate="yes" xml:space="preserve">
          <source>JavaScript types</source>
          <target state="translated">자바 스크립트 유형</target>
        </trans-unit>
        <trans-unit id="b2bea8b7008e2db2d0b0548f31cebaf54a8e8d9f" translate="yes" xml:space="preserve">
          <source>Julian Reschke
   &amp;lt;green/&amp;gt;bytes GmbH
   Hafenweg 16, 48155 Muenster, Germany
   EMail: julian.reschke@greenbytes.de


   Elias Sinderson
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: elias@cse.ucsc.edu


   Jim Whitehead
   University of California, Santa Cruz
   1156 High Street, Santa Cruz, CA 95064
   EMail: ejw@soe.ucsc.edu</source>
          <target state="translated">Julian Reschke &amp;lt;green /&amp;gt; bytes GmbH Hafenweg 16, 48155 Muenster, Germany 이메일 : julian.reschke@greenbytes.de Elias Sinderson University of California, Santa Cruz 1156 High Street, Santa Cruz, CA 95064 이메일 : elias@cse.ucsc.edu Jim Whitehead University of California, Santa Cruz 1156 High Street, 산타 크루즈, CA 95064 이메일 : ejw@soe.ucsc.edu</target>
        </trans-unit>
        <trans-unit id="7e8b1d0fc088bb90dbbe8a2dbd8d00105aebfdf3" translate="yes" xml:space="preserve">
          <source>Keep-Alive</source>
          <target state="translated">Keep-Alive</target>
        </trans-unit>
        <trans-unit id="518fe23acc32b680b6c7064b18768ce9a4edc6c7" translate="yes" xml:space="preserve">
          <source>Keeping links alive</source>
          <target state="translated">링크를 유지</target>
        </trans-unit>
        <trans-unit id="0b80404ac1f938e0ad58d9a575e0e0aa00a66dd0" translate="yes" xml:space="preserve">
          <source>Kind of document</source>
          <target state="translated">문서의 종류</target>
        </trans-unit>
        <trans-unit id="471e7dd9c2f2d4bd1722ed06bd63bae32d792b07" translate="yes" xml:space="preserve">
          <source>Klar Version (Rendering Engine)</source>
          <target state="translated">클라 버전 (렌더링 엔진)</target>
        </trans-unit>
        <trans-unit id="53a344b79c8c2c1639455bd4ca9631b250cbb736" translate="yes" xml:space="preserve">
          <source>Klar for Android</source>
          <target state="translated">Android 용 Klar</target>
        </trans-unit>
        <trans-unit id="1cfc0d8b05e463c4269f42611f344e37e54aaf18" translate="yes" xml:space="preserve">
          <source>Konqueror 4.6</source>
          <target state="translated">Konqueror 4.6</target>
        </trans-unit>
        <trans-unit id="1971c93380e2bf924d413b56239bd916d71c69a0" translate="yes" xml:space="preserve">
          <source>Lack of error handling</source>
          <target state="translated">오류 처리 부족</target>
        </trans-unit>
        <trans-unit id="3df68e70fa194f3c844cf64d5417d8356ae60b51" translate="yes" xml:space="preserve">
          <source>Large message body</source>
          <target state="translated">큰 메시지 본문</target>
        </trans-unit>
        <trans-unit id="aba1a47c51ae2e1013a1da8b769f84aea5b8154d" translate="yes" xml:space="preserve">
          <source>Large-Allocation</source>
          <target state="translated">Large-Allocation</target>
        </trans-unit>
        <trans-unit id="4312b9cdc22a0d8cf25ab213c9d034cee9ce16ee" translate="yes" xml:space="preserve">
          <source>Last-Modified</source>
          <target state="translated">Last-Modified</target>
        </trans-unit>
        <trans-unit id="5ad73a8c3ddef48b03c719ec7b68bf049b1d82e3" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 2616)</source>
          <target state="translated">최종 수정 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="99e5db4754c5b7e5f7aa2bb6b93799f72088bd2e" translate="yes" xml:space="preserve">
          <source>Last-Modified (RFC 7232)</source>
          <target state="translated">최종 수정 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="47055864cbe7192dae27bdfff260957e5075db67" translate="yes" xml:space="preserve">
          <source>Lastly, the above code snippets bring about a critical issue with cross-browser coding that must always be taken into account. Don't unintentionally use the API you are testing for in unsupported browsers. This may sound obvious and simple, but sometimes it is not. For example, in the above code snippets, using lookbehind in short-regexp notation (e.g. /reg/igm) will cause a parser error in unsupported browsers. Thus, in the above example, you would use &lt;em&gt;new RegExp(&quot;(?&amp;lt;=look_behind_stuff)&quot;);&lt;/em&gt; instead of &lt;em&gt;/(?&amp;lt;=look_behind_stuff)/&lt;/em&gt;, even in the lookbehind supported section of your code.</source>
          <target state="translated">마지막으로, 위의 코드 스 니펫은 항상 고려해야하는 크로스 브라우저 코딩의 중요한 문제를 야기합니다. 지원되지 않는 브라우저에서 테스트중인 API를 실수로 사용하지 마십시오. 이것은 명백하고 단순하게 들릴 수 있지만 때로는 그렇지 않습니다. 예를 들어, 위 코드 스 니펫에서 짧은 정규 표현식 표기법 (예 : / reg / igm)으로 lookbehind를 사용하면 지원되지 않는 브라우저에서 파서 오류가 발생합니다. 따라서 위의 예에서는 &lt;em&gt;new RegExp ( &quot;(? &amp;lt;= look_behind_stuff)&quot;); &lt;/em&gt;코드의 지원되는 지원 섹션에서도 &lt;em&gt;/ (? &amp;lt;= look_behind_stuff) /&lt;/em&gt; 대신에 .</target>
        </trans-unit>
        <trans-unit id="eafc1856088b0c25b5dc46fcf0e9827359916eb5" translate="yes" xml:space="preserve">
          <source>Layout-inducing Animations</source>
          <target state="translated">레이아웃 유도 애니메이션</target>
        </trans-unit>
        <trans-unit id="2c4b740fafd105be97b958562b8d0b2c61b96ad1" translate="yes" xml:space="preserve">
          <source>Layout-inducing animations</source>
          <target state="translated">레이아웃 유도 애니메이션</target>
        </trans-unit>
        <trans-unit id="002f595b3413c96ece78e3ec6628adfe5d342941" translate="yes" xml:space="preserve">
          <source>Lazyload</source>
          <target state="translated">Lazyload</target>
        </trans-unit>
        <trans-unit id="4c1df5a82059a1ccfbe352d4ab0834213813478b" translate="yes" xml:space="preserve">
          <source>Learn how to use HTTP with guides and tutorials.</source>
          <target state="translated">안내서 및 학습서와 함께 HTTP를 사용하는 방법을 학습하십시오.</target>
        </trans-unit>
        <trans-unit id="14b20b4a9f9427cb013c488330c0a01cc370bf8c" translate="yes" xml:space="preserve">
          <source>Legacy image formats</source>
          <target state="translated">레거시 이미지 형식</target>
        </trans-unit>
        <trans-unit id="657da249aededaf980a2d1ed290fee63a37d340e" translate="yes" xml:space="preserve">
          <source>Length limitations</source>
          <target state="translated">길이 제한</target>
        </trans-unit>
        <trans-unit id="5084aa81ee35e345974545e25d8c6c32ab615e45" translate="yes" xml:space="preserve">
          <source>Let us look at what the browser will send to the server in this case, and let's see how the server responds:</source>
          <target state="translated">이 경우 브라우저가 서버로 전송하는 내용을 살펴보고 서버가 어떻게 응답하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="fa210c261a8eda6a3085253bdfc33931dfb0a50f" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://example.com/signup.html&quot;&gt;http://example.com/signup.html&lt;/a&gt;&lt;/code&gt; 에 있는 페이지를 고려하십시오 . 다음 정책을 사용하여 &lt;code&gt;cdn.example.com&lt;/code&gt; 의 스타일 시트를 제외한 모든 것을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="152516c7d9cfd6fae5d3a79c8e35a362dbc55ac2" translate="yes" xml:space="preserve">
          <source>Let's consider a page located at &lt;code&gt;http://example.com/signup.html&lt;/code&gt;. It uses the following policy, disallowing everything but stylesheets from &lt;code&gt;cdn.example.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://example.com/signup.html&lt;/code&gt; 에 있는 페이지를 고려하십시오 . 다음 정책을 사용하여 &lt;code&gt;cdn.example.com&lt;/code&gt; 의 스타일 시트를 제외한 모든 것을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="442acc84011b22aa128b910d7dd61aeabb2c24b6" translate="yes" xml:space="preserve">
          <source>Let's look at an example of a preflight request involving &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 와 관련된 프리 플라이트 요청의 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="928b6441798d4590009f5cc1febcd4f4cc9b6912" translate="yes" xml:space="preserve">
          <source>Let's say a site's API can return data in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt; formats. If the URL for a particular document is at &lt;code&gt;https://example.com/documents/foo&lt;/code&gt;, the site could return different URLs for &lt;code&gt;Content-Location&lt;/code&gt; depending on the request's &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">사이트의 API가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XML&quot;&gt;XML&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;CSV&lt;/a&gt; 형식으로 데이터를 반환 할 수 있다고 가정 해 보겠습니다 . 특정 문서의 URL이 &lt;code&gt;https://example.com/documents/foo&lt;/code&gt; 인 경우 사이트 는 요청의 &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; 헤더 에 따라 &lt;code&gt;Content-Location&lt;/code&gt; 에 대해 다른 URL을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a649ee77f17b9ff4d60ac31c6bda763b09061da1" translate="yes" xml:space="preserve">
          <source>Let's take a look at the full exchange between client and server. The first exchange is the &lt;em&gt;preflight request/response&lt;/em&gt;:</source>
          <target state="translated">클라이언트와 서버의 전체 교환을 살펴 보겠습니다. 첫 번째 교환은 &lt;em&gt;프리 플라이트 요청 / 응답입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76d8e88746aed29c5732084d86f85c42f51868b5" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="db10ddafdbaf44fe84055e66ecf49ecd6e6f7755" translate="yes" xml:space="preserve">
          <source>Like HTML redirections, this can't work on all resources, and obviously, this will only work on clients that execute JavaScript. On the other side, there are more possibilities as you can trigger the redirection only if some conditions are met, for example.</source>
          <target state="translated">HTML 리디렉션과 마찬가지로 모든 리소스에서 작동하지는 않으며 JavaScript를 실행하는 클라이언트에서만 작동합니다. 반면에 일부 조건이 충족되는 경우에만 리디렉션을 트리거 할 수있는 가능성이 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="70be75ce577f3ebafccca55b5df13ee8aef2157c" translate="yes" xml:space="preserve">
          <source>Like any generic data transfer protocol, HTTP cannot regulate the
   content of the data that is transferred, nor is there any a priori
   method of determining the sensitivity of any particular piece of
   information within the context of any given request. Therefore,
   applications SHOULD supply as much control over this information as
   possible to the provider of that information. Four header fields are
   worth special mention in this context: Server, Via, Referer and From.

   Revealing the specific software version of the server might allow the
   server machine to become more vulnerable to attacks against software
   that is known to contain security holes. Implementors SHOULD make the
   Server header field a configurable option.

   Proxies which serve as a portal through a network firewall SHOULD
   take special precautions regarding the transfer of header information
   that identifies the hosts behind the firewall. In particular, they
   SHOULD remove, or replace with sanitized versions, any Via fields
   generated behind the firewall.

   The Referer header allows reading patterns to be studied and reverse
   links drawn. Although it can be very useful, its power can be abused
   if user details are not separated from the information contained in 

   the Referer. Even when the personal information has been removed, the
   Referer header might indicate a private document's URI whose
   publication would be inappropriate.

   The information sent in the From field might conflict with the user's
   privacy interests or their site's security policy, and hence it
   SHOULD NOT be transmitted without the user being able to disable,
   enable, and modify the contents of the field. The user MUST be able
   to set the contents of this field within a user preference or
   application defaults configuration.

   We suggest, though do not require, that a convenient toggle interface
   be provided for the user to enable or disable the sending of From and
   Referer information.

   The User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;) or Server (&lt;a href=&quot;#section-14.38&quot;&gt;section 14.38&lt;/a&gt;) header
   fields can sometimes be used to determine that a specific client or
   server have a particular security hole which might be exploited.
   Unfortunately, this same information is often used for other valuable
   purposes for which HTTP currently has no better mechanism.</source>
          <target state="translated">일반적인 데이터 전송 프로토콜과 마찬가지로 HTTP는 전송되는 데이터의 내용을 규제 할 수 없으며, 주어진 요청의 맥락 내에서 특정 정보의 민감도를 결정하는 선험적 인 방법도 없습니다. 따라서 응용 프로그램은 가능한 한 해당 정보 제공 업체에이 정보를 최대한 제어 할 수 있어야합니다. 이 문맥에서 Server, Via, Referer 및 From의 네 가지 헤더 필드를 특별히 언급 할 가치가 있습니다. 서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 만들어야합니다 (SHOULD).네트워크 방화벽을 통해 포털 역할을하는 프록시는 방화벽 뒤의 호스트를 식별하는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야합니다 (SHOULD). 특히 방화벽 뒤에 생성 된 모든 Via 필드를 제거하거나 위생 화 된 버전으로 교체해야합니다. Referer 헤더를 사용하면 판독 패턴을 연구하고 역방향 링크를 그릴 수 있습니다. 매우 유용 할 수 있지만 사용자 정보가 Referer에 포함 된 정보와 분리되지 않으면 그 기능이 남용 될 수 있습니다. 개인 정보가 제거 된 경우에도 Referer 헤더는 공개가 부적절한 개인 문서의 URI를 나타낼 수 있습니다. 보낸 사람 입력란에 전송 된 정보는 사용자의 개인 정보 보호 관심사 또는 사이트의 보안 정책과 충돌 할 수 있습니다.따라서 사용자가 필드의 내용을 비활성화, 활성화 및 수정할 수 없으면 전송해서는 안됩니다. 사용자는 사용자 기본 설정 또는 응용 프로그램 기본 구성 내에서이 필드의 내용을 설정할 수 있어야합니다. 필수는 아니지만 사용자가 From 및 Referer 정보 전송을 활성화 또는 비활성화 할 수있는 편리한 토글 인터페이스를 제공하는 것이 좋습니다. 사용자 에이전트 (From 및 Referer 정보의 전송을 활성화 또는 비활성화 할 수있는 편리한 토글 인터페이스를 제공합니다. 사용자 에이전트 (From 및 Referer 정보의 전송을 활성화 또는 비활성화 할 수있는 편리한 토글 인터페이스를 제공합니다. 사용자 에이전트 (&lt;a href=&quot;#section-14.43&quot;&gt;섹션 14.43&lt;/a&gt; ) 또는 서버 ( &lt;a href=&quot;#section-14.38&quot;&gt;섹션 14.38&lt;/a&gt; ) 헤더 필드를 사용하여 특정 클라이언트 나 서버에 악용 될 수있는 특정 보안 허점이 있는지 확인할 수 있습니다. 불행히도,이 같은 정보는 종종 HTTP가 현재 더 나은 메커니즘을 갖지 않는 다른 중요한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de09479df824aa67e637b0690aa7154dd273d917" translate="yes" xml:space="preserve">
          <source>Like images, HTML doesn't define supported types for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, so only some can be used on the Web. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;Media formats supported by the HTML audio and video elements&lt;/a&gt; explains both the codecs and container formats which can be used.</source>
          <target state="translated">이미지와 마찬가지로 HTML은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 지원되는 유형을 정의하지 않으므로 일부는 웹에서 사용할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats&quot;&gt;HTML 오디오 및 비디오 요소가 지원하는 미디어 형식&lt;/a&gt; 은 사용할 수있는 코덱 및 컨테이너 형식을 모두 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b17f9b3a3f5f94964505eae8dc076c8167b437f2" translate="yes" xml:space="preserve">
          <source>Like in all cases, these strings may change in the future, one should use them only in conjunction with the detection of already released browsers. A technological survey must be in place to adapt the script when new browser versions are coming out.</source>
          <target state="translated">모든 경우와 마찬가지로 이러한 문자열은 나중에 변경 될 수 있으므로 이미 릴리스 된 브라우저의 감지와 함께 만 사용해야합니다. 새로운 브라우저 버전이 출시 될 때 스크립트를 적용하려면 기술 조사를 실시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3f7813f6513530fae5d20c357e1018dfbdab752" translate="yes" xml:space="preserve">
          <source>Like the compress program, which has disappeared from most UNIX distributions, this content-encoding is used by almost no browsers today, partly because of a patent issue (which expired in 2003).</source>
          <target state="translated">대부분의 유닉스 배포판에서 사라진 압축 프로그램과 마찬가지로,이 컨텐츠 인코딩은 오늘날 거의 모든 브라우저에서 사용되지 않으며, 부분적으로는 특허 문제 (2003 년에 만료 됨) 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c924aeab714bffe66c4c22bc5d8bd00099533380" translate="yes" xml:space="preserve">
          <source>Limiting the possible &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; values to a set of allowed origins requires code on the server side to check the value of the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header, compare that to a list of allowed origins, and then if the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value is in the list, to set the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">가능한 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 값을 허용 된 원점 세트로 제한하려면 서버 측에서 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 요청 헤더 의 값을 확인하고 허용 된 원점 목록과 비교 한 다음 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 값이 목록은 설정하는 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 와 같은 값으로 값을 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="a118fb8cb53f5dd1fc14f29be01804384762f7e9" translate="yes" xml:space="preserve">
          <source>Line 7 shows the flag on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; that has to be set in order to make the invocation with Cookies, namely the &lt;code&gt;withCredentials&lt;/code&gt; boolean value. By default, the invocation is made without Cookies. Since this is a simple &lt;code&gt;GET&lt;/code&gt; request, it is not preflighted, but the browser will &lt;strong&gt;reject&lt;/strong&gt; any response that does not have the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header, and &lt;strong&gt;not&lt;/strong&gt; make the response available to the invoking web content.</source>
          <target state="translated">7 행은 쿠키를 사용하여 호출하기 위해 설정 &lt;code&gt;withCredentials&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 의 플래그 , 즉 withCredentials 부울 값을 표시합니다. 기본적으로 호출은 쿠키없이 이루어집니다. 이 요청 은 간단한 &lt;code&gt;GET&lt;/code&gt; 요청이므로 프리 플라이트되지 않지만 브라우저는 &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 헤더 가없는 응답을 &lt;strong&gt;거부&lt;/strong&gt; 하고 호출하는 웹 컨텐츠에 응답을 제공 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e4ad5eac403df09e0c0c7d48c364588c499b639" translate="yes" xml:space="preserve">
          <source>Lines 1 - 10 are headers sent. The main HTTP request header of note here is the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header on line 10 above, which shows that the invocation is coming from content on the domain &lt;code&gt;http://foo.example&lt;/code&gt;.</source>
          <target state="translated">1-10 행은 헤더가 전송됩니다. 여기서 주 HTTP 요청 헤더는 위의 10 행에 있는 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더이며 호출은 &lt;code&gt;http://foo.example&lt;/code&gt; 도메인의 컨텐츠에서 온 것임을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a288b2c5ce1d7dc2f4906f2097cd01bf3ad43ed7" translate="yes" xml:space="preserve">
          <source>Lines 1 - 12 above represent the preflight request with the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method. The browser determines that it needs to send this based on the request parameters that the JavaScript code snippet above was using, so that the server can respond whether it is acceptable to send the request with the actual request parameters. OPTIONS is an HTTP/1.1 method that is used to determine further information from servers, and is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, meaning that it can't be used to change the resource. Note that along with the OPTIONS request, two other request headers are sent (lines 10 and 11 respectively):</source>
          <target state="translated">위의 1-12 행은 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 메소드를 사용한 프리 플라이트 요청을 나타냅니다 . 브라우저는 위의 JavaScript 코드 스 니펫이 사용중인 요청 매개 변수를 기반으로이를 전송해야하므로 서버가 실제 요청 매개 변수로 요청을 보낼 수 있는지 여부에 응답 할 수 있습니다. OPTIONS는 서버에서 추가 정보를 확인하는 데 사용되는 HTTP / 1.1 방법이며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전한&lt;/a&gt; 방법이므로 리소스를 변경하는 데 사용할 수 없습니다. OPTIONS 요청과 함께 두 개의 다른 요청 헤더가 전송됩니다 (각각 10 행과 11 행).</target>
        </trans-unit>
        <trans-unit id="656e5cef78d93570c111bd1f498ea5a75f7e0f4b" translate="yes" xml:space="preserve">
          <source>Lines 13 - 22 show the HTTP response from the server on domain &lt;code&gt;http://bar.other&lt;/code&gt;. In response, the server sends back an &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, shown above in line 16. The use of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header and of &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; show the access control protocol in its simplest use. In this case, the server responds with a &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; which means that the resource can be accessed by &lt;strong&gt;any&lt;/strong&gt; domain in a cross-site manner. If the resource owners at &lt;code&gt;http://bar.other&lt;/code&gt; wished to restrict access to the resource to requests only from &lt;code&gt;http://foo.example&lt;/code&gt;, they would send back:</source>
          <target state="translated">&lt;code&gt;http://bar.other&lt;/code&gt; 도메인에있는 서버의 HTTP 응답을 보여줍니다 . 이에 대한 응답으로 서버는 위의 16 행에 표시된 &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더를 다시 보냅니다 . &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더와 &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 을&lt;/a&gt; 사용하면 가장 간단한 사용으로 액세스 제어 프로토콜이 표시됩니다. 이 경우 서버는 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; 응답합니다 . 즉, &lt;strong&gt;모든&lt;/strong&gt; 도메인에서 교차 사이트 방식으로 리소스에 액세스 할 수 있습니다 . 에서 자원 소유자 경우 &lt;code&gt;http://bar.other&lt;/code&gt; 단지의 요청에 자원에 대한 접근을 제한하고 싶다고 &lt;code&gt;http://foo.example&lt;/code&gt; , 그들은 다시 보낼 것이다 :</target>
        </trans-unit>
        <trans-unit id="0936ed44f0ff243a8948b7ff1f3424ae3dd946dd" translate="yes" xml:space="preserve">
          <source>Lines 14 - 26 above are the response that the server sends back indicating that the request method (&lt;code&gt;POST&lt;/code&gt;) and request headers (&lt;code&gt;X-PINGOTHER&lt;/code&gt;) are acceptable. In particular, let's look at lines 17-20:</source>
          <target state="translated">위의 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 은 요청 메소드 ( &lt;code&gt;POST&lt;/code&gt; ) 및 요청 헤더 ( X-PINGOTHER )가 허용됨을 나타내는 서버가 다시 보내는 응답입니다 . 특히 17 ~ 20 행을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="82027c0f9c7057e65bf210d13353910e8d71c0f4" translate="yes" xml:space="preserve">
          <source>Links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;.</source>
          <target state="translated">생성 된 코드를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;소스 맵에 연결&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="549589564fb88551ce209cf08bbdd821d0b56959" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686</source>
          <target state="translated">리눅스 데스크탑, i686</target>
        </trans-unit>
        <trans-unit id="2c1006c548ffce988561b572ae63ee4b2e4e044d" translate="yes" xml:space="preserve">
          <source>Linux desktop, i686 running on x86_64</source>
          <target state="translated">x86_64에서 실행되는 Linux 데스크탑, i686</target>
        </trans-unit>
        <trans-unit id="7162da293f4c110abd9006ea0fe9502688b6d134" translate="yes" xml:space="preserve">
          <source>Linux desktop, x86_64</source>
          <target state="translated">리눅스 데스크탑, x86_64</target>
        </trans-unit>
        <trans-unit id="ceb42a6047d0fbee0d6dbc845c8b0bf73fb0ee1b" translate="yes" xml:space="preserve">
          <source>Linux is a more diverse platform. A few common examples are given below.</source>
          <target state="translated">리눅스는보다 다양한 플랫폼입니다. 몇 가지 일반적인 예가 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="065f1e3b7da760e47bd326f001407c11b87dca01" translate="yes" xml:space="preserve">
          <source>Linux version</source>
          <target state="translated">리눅스 버전</target>
        </trans-unit>
        <trans-unit id="f35d685de7aa50ed56af00a2c8d048a65fb3313a" translate="yes" xml:space="preserve">
          <source>List of HTTP status codes on Wikipedia</source>
          <target state="translated">Wikipedia의 HTTP 상태 코드 목록</target>
        </trans-unit>
        <trans-unit id="c7facdad0c38a8be559aae543266310890041f74" translate="yes" xml:space="preserve">
          <source>Lists the set of HTTP request methods support by a resource.</source>
          <target state="translated">자원이 지원하는 HTTP 요청 메소드 세트를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="59afca4aa349dcb2585efb358d932b086d06c52a" translate="yes" xml:space="preserve">
          <source>Live properties described in this document SHOULD be moved along with
   the resource, such that the resource has identically behaving live
   properties at the destination resource, but not necessarily with the
   same values.  Note that some live properties are defined such that
   the absence of the property has a specific meaning (e.g., a flag with
   one meaning if present, and the opposite if absent), and in these
   cases, a successful MOVE might result in the property being reported
   as &quot;Not Found&quot; in subsequent requests.  If the live properties will
   not work the same way at the destination, the server MAY fail the
   request.

   MOVE is frequently used by clients to rename a file without changing
   its parent collection, so it's not appropriate to reset all live
   properties that are set at resource creation.  For example, the DAV:
   creationdate property value SHOULD remain the same after a MOVE.

   Dead properties MUST be moved along with the resource.</source>
          <target state="translated">이 문서에 설명 된 라이브 속성은 리소스와 함께 이동해야합니다. 그래야 리소스가 대상 리소스에서 동일하게 동작하지만 반드시 동일한 값을 가질 필요는 없습니다. 일부 라이브 속성은 속성이없는 경우 특정 의미 (예 : 하나의 의미가있는 플래그,없는 경우 반대의 플래그)를 갖도록 정의되며,이 경우 MOVE가 성공하면 속성이 발생할 수 있습니다. 후속 요청에서 &quot;찾을 수 없음&quot;으로보고되었습니다. 실제 속성이 대상에서 동일한 방식으로 작동하지 않으면 서버가 요청에 실패 할 수 있습니다. MOVE는 클라이언트가 상위 컬렉션을 변경하지 않고 파일 이름을 바꾸는 데 자주 사용되므로 리소스 생성시 설정된 모든 라이브 속성을 재설정하는 것은 적절하지 않습니다.예를 들어, DAV : creationdate 속성 값은 이동 후에도 동일하게 유지되어야한다. 죽은 속성은 리소스와 함께 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="d81b072a609cb829f45333cb83e086a659ba9738" translate="yes" xml:space="preserve">
          <source>Living Standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7b5bd9c1e9247bb26bc70611e9ed0c08ee1e45" translate="yes" xml:space="preserve">
          <source>Load balancing/routing based on URL patterns</source>
          <target state="translated">URL 패턴에 따른로드 밸런싱 / 라우팅</target>
        </trans-unit>
        <trans-unit id="2bf154fc59dbac071e95bfd447b96ee4cb26055c" translate="yes" xml:space="preserve">
          <source>Load balancing: distribute the load to several web servers,</source>
          <target state="translated">로드 밸런싱 :로드를 여러 웹 서버에 분배</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="a65e984205ab4c0ed633ba5ae6a32d6c797cec2d" translate="yes" xml:space="preserve">
          <source>Location (RFC 2616)</source>
          <target state="translated">위치 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a192553dfc610dd4624b27cebff4825c0c7e9331" translate="yes" xml:space="preserve">
          <source>Location (RFC 7231)</source>
          <target state="translated">위치 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="c6e7ecfb5bf0d5af9da443ea9b5d77cb9bee2bce" translate="yes" xml:space="preserve">
          <source>Lock-Token = &quot;Lock-Token&quot; &quot;:&quot; Coded-URL

   The Lock-Token request header is used with the UNLOCK method to
   identify the lock to be removed.  The lock token in the Lock-Token
   request header MUST identify a lock that contains the resource
   identified by Request-URI as a member.

   The Lock-Token response header is used with the LOCK method to
   indicate the lock token created as a result of a successful LOCK
   request to create a new lock.</source>
          <target state="translated">Lock-Token = &quot;Lock-Token&quot; &quot;:&quot;코딩 된 URL 잠금 토큰 요청 헤더는 UNLOCK 메서드와 함께 사용하여 제거 할 잠금을 식별합니다. Lock-Token 요청 헤더의 잠금 토큰은 Request-URI가 구성원으로 식별 한 자원을 포함하는 잠금을 식별해야합니다. Lock-Token 응답 헤더는 LOCK 메소드와 함께 사용되어 새 잠금을 작성하기위한 성공적인 LOCK 요청의 결과로 작성된 잠금 토큰을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1a4b53727bcb9a035c59d80c57451cf3de2a5c3e" translate="yes" xml:space="preserve">
          <source>Logins, shopping carts, game scores, or anything else the server should remember</source>
          <target state="translated">로그인, 쇼핑 카트, 게임 점수 또는 서버가 기억해야 할 다른 것</target>
        </trans-unit>
        <trans-unit id="bf49284c6e80b1a37a4cb9aa4fa17eb56ebba27b" translate="yes" xml:space="preserve">
          <source>Look, or ask, in specialized forums: you're unlikely to be the first to hit this problem. Also, experts, or simply people with another point of view, can give you ideas for working around the bug. If the problem seems uncommon, it's worth checking if this bug has been reported to the browser vendor via their bug tracking system (&lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt;; &lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt;; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt;; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt;). Browser makers do pay attention to bug reports, and the analysis may hint about other workarounds for the bug.</source>
          <target state="translated">전문 포럼에서 보거나 물어보십시오.이 문제를 가장 먼저 경험하지는 못할 것입니다. 또한 전문가 또는 단순히 다른 관점을 가진 사람이 버그를 해결하기위한 아이디어를 제공 할 수 있습니다. 문제가 흔하지 않은 경우 버그 추적 시스템 ( &lt;a href=&quot;https://bugzilla.mozilla.org&quot;&gt;Mozilla&lt;/a&gt; ; &lt;a href=&quot;http://bugs.webkit.org&quot;&gt;WebKit&lt;/a&gt; ; &lt;a href=&quot;https://www.chromium.org/issue-tracking&quot;&gt;Blink&lt;/a&gt; ; &lt;a href=&quot;https://bugs.opera.com/&quot;&gt;Opera&lt;/a&gt; )을 통해이 버그가 브라우저 공급 업체에보고되었는지 확인할 가치가 있습니다. 브라우저 제조업체는 버그 보고서에주의를 기울이고 분석 결과 버그에 대한 다른 해결 방법이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ddda7cc2412992344e22fd844143dbcfe3bfc3" translate="yes" xml:space="preserve">
          <source>Lossy compression algorithms are usually more efficient that loss-less ones.</source>
          <target state="translated">손실 압축 알고리즘은 일반적으로 손실이없는 알고리즘보다 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ac2665911917ab5f698cf6ff5ed62343c6057a6a" translate="yes" xml:space="preserve">
          <source>MIME Type</source>
          <target state="translated">MIME 유형</target>
        </trans-unit>
        <trans-unit id="403274b7a1852e5261e595fa61397d41178bdb18" translate="yes" xml:space="preserve">
          <source>MIME Types</source>
          <target state="translated">MIME 유형</target>
        </trans-unit>
        <trans-unit id="8e48cee9b67b50e883f2ce1444b5166e76e1cf17" translate="yes" xml:space="preserve">
          <source>MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field.  Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the Content-Type header
   field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail
   have used a media-type parameter of &quot;;conversions=&amp;lt;content-coding&amp;gt;&quot;
   to perform a function equivalent to Content-Encoding.  However, this
   parameter is not part of the MIME standards).</source>
          <target state="translated">MIME에는 HTTP / 1.1의 Content-Encoding 헤더 필드와 동등한 개념이 포함되어 있지 않습니다. 미디어 유형에서 수정 자 역할을하기 때문에 HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드의 값을 변경하거나 표현을 디코딩해야합니다. 인터넷 메일 용 Content-Type의 일부 실험 응용 프로그램에서는 &quot;; conversions = &amp;lt;content-coding&amp;gt;&quot;의 미디어 유형 매개 변수를 사용하여 Content-Encoding과 동등한 기능을 수행했지만이 매개 변수는 MIME 표준의 일부가 아닙니다. ).</target>
        </trans-unit>
        <trans-unit id="969c21cbc7a0aaa20e68f4d797544fee58a73005" translate="yes" xml:space="preserve">
          <source>MIME media types define what kind of document a specific resource is. This article presents both the syntax and the most useful MIME types for use on the Web.</source>
          <target state="translated">MIME 미디어 유형은 특정 리소스가 어떤 종류의 문서인지 정의합니다. 이 기사에서는 웹에서 사용하기위한 구문과 가장 유용한 MIME 유형을 모두 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6bd9c9b5a57f317bcf5534bd7d83b023a8ee7df7" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more entities within a single message-body. All multipart
   types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;section&amp;nbsp;5.1.1 of RFC 2046&lt;/a&gt; 

   [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;], and MUST include a boundary parameter as part of the media type
   value. The message body is itself a protocol element and MUST
   therefore use only CRLF to represent line breaks between body-parts.
   Unlike in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, the epilogue of any multipart message MUST be
   empty; HTTP applications MUST NOT transmit the epilogue (even if the
   original multipart contains an epilogue). These restrictions exist in
   order to preserve the self-delimiting nature of a multipart message-
   body, wherein the &quot;end&quot; of the message-body is indicated by the
   ending multipart boundary.

   In general, HTTP treats a multipart message-body no differently than
   any other media type: strictly as payload. The one exception is the
   &quot;multipart/byteranges&quot; type (appendix 19.2) when it appears in a 206
   (Partial Content) response, which will be interpreted by some HTTP
   caching mechanisms as described in sections &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; and &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. In all
   other cases, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   The MIME header fields within each body-part of a multipart message-
   body do not have any significance to HTTP beyond that defined by
   their MIME semantics.

   In general, an HTTP user agent SHOULD follow the same or similar
   behavior as a MIME user agent would upon receipt of a multipart type.
   If an application receives an unrecognized multipart subtype, the
   application MUST treat it as being equivalent to &quot;multipart/mixed&quot;.

      Note: The &quot;multipart/form-data&quot; type has been specifically defined
      for carrying form data suitable for processing via the POST
      request method, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [&lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt;].</source>
          <target state="translated">MIME은 단일 메시지 본문 내에 하나 이상의 엔터티를 캡슐화하여 여러 &quot;멀티 파트&quot;유형을 제공합니다. 모든 멀티 파트 유형 &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;은 RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]의 5.1.1 섹션에 정의 된대로 공통 구문을 공유하며 미디어 유형 값의 일부로 경계 매개 변수를 포함해야합니다. 메시지 본문 자체는 프로토콜 요소이므로 본문 부분 사이의 줄 바꿈을 나타내는 데 CRLF 만 사용해야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; 과 달리멀티 파트 메시지의 에필로그는 비어 있어야합니다. HTTP 응용 프로그램은 에필로그를 전송해서는 안됩니다 (원래 멀티 파트에 에필로그가 포함되어 있어도). 이러한 제한은 멀티 파트 메시지 본문의 자체 구분 특성을 유지하기 위해 존재하며, 여기서 메시지 바디의 &quot;끝&quot;은 끝 멀티 파트 경계로 표시됩니다. 일반적으로 HTTP는 멀티 파트 메시지 본문을 다른 미디어 유형과 다르게 페이로드로 취급합니다. 한 가지 예외는 &quot;multipart / byteranges&quot;유형 (부록 19.2)이 206 (부분 내용) 응답에 나타날 때 &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; 및 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; 섹션에 설명 된 일부 HTTP 캐싱 메커니즘에 의해 해석됩니다.. 다른 모든 경우에 HTTP 사용자 에이전트는 멀티 파트 유형을 수신 할 때 MIME 사용자 에이전트와 동일하거나 유사한 동작을 따라야합니다. 멀티 파트 메시지 본문의 각 본문 부분에있는 MIME 헤더 필드는 MIME 시맨틱에 의해 정의 된 것보다 HTTP에 의미가 없습니다. 일반적으로 HTTP 사용자 에이전트는 멀티 파트 유형을 수신 할 때 MIME 사용자 에이전트와 동일하거나 유사한 동작을 따라야합니다. 응용 프로그램이 인식 할 수없는 멀티 파트 하위 유형을 수신하는 경우 응용 프로그램은이를 &quot;멀티 파트 / 혼합&quot;과 동등한 것으로 취급해야합니다. 참고 : &quot;multipart / form-data&quot;유형은 POST 요청 방법을 통해 처리하기에 적합한 양식 데이터를 전달하기 위해 특별히 정의되었습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC 1867&lt;/a&gt; [ &lt;a href=&quot;#ref-15&quot;&gt;15&lt;/a&gt; ]에 기술 된 바와 같이 .</target>
        </trans-unit>
        <trans-unit id="4a0b826ef29a7a4a5fcb4cc1856fb5706a1d940c" translate="yes" xml:space="preserve">
          <source>MIME provides for a number of &quot;multipart&quot; types -- encapsulations of
   one or more representations within a single message body.  All
   multipart types share a common syntax, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of
   [RFC2046]&lt;/a&gt;, and include a boundary parameter as part of the media type
   value.  The message body is itself a protocol element; a sender MUST
   generate only CRLF to represent line breaks between body parts.

   HTTP message framing does not use the multipart boundary as an
   indicator of message body length, though it might be used by
   implementations that generate or process the payload.  For example,
   the &quot;multipart/form-data&quot; type is often used for carrying form data
   in a request, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388&lt;/a&gt;], and the &quot;multipart/
   byteranges&quot; type is defined by this specification for use in some 206
   (Partial Content) responses [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;].</source>
          <target state="translated">MIME은 하나의 메시지 본문 내에 하나 이상의 표현을 캡슐화하여 여러 &quot;멀티 파트&quot;유형을 제공합니다. 모든 다중 파트 유형 &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1.1&quot;&gt;은 [RFC2046]의 5.1.1 섹션에&lt;/a&gt; 정의 된대로 공통 구문을 공유하며 매체 유형 값의 일부로 경계 매개 변수를 포함합니다. 메시지 본문 자체는 프로토콜 요소입니다. 발신자는 본문 부분 사이의 줄 바꿈을 나타 내기 위해 CRLF 만 생성해야합니다. HTTP 메시지 프레임은 다중 파트 경계를 메시지 본문 길이의 표시 자로 사용하지 않지만 페이로드를 생성하거나 처리하는 구현에서 사용될 수 있습니다. 예를 들어, &quot;multipart / form-data&quot;유형은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC2388에&lt;/a&gt; 설명 된대로 요청에서 양식 데이터를 전달하는 데 종종 사용됩니다.] 및 &quot;멀티 파트 / 바이트 범위&quot;유형은 일부 206 (부분 컨텐츠) 응답에 사용하기 위해이 스펙에 의해 정의됩니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="c8e0f31f1df09630671c1f651e4e3b3a2f9c9629" translate="yes" xml:space="preserve">
          <source>MIME requires that an Internet mail body part be converted to
   canonical form prior to being transferred, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;Section&amp;nbsp;4
   of [RFC2049]&lt;/a&gt;.  &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document describes the forms
   allowed for subtypes of the &quot;text&quot; media type when transmitted over
   HTTP.  [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] requires that content with a type of &quot;text&quot;
   represent line breaks as CRLF and forbids the use of CR or LF outside
   of line break sequences.  HTTP allows CRLF, bare CR, and bare LF to
   indicate a line break within text content.

   A proxy or gateway from HTTP to a strict MIME environment ought to
   translate all line breaks within the text media types described in
   &lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; of this document to the &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; canonical form of
   CRLF.  Note, however, this might be complicated by the presence of a
   Content-Encoding and by the fact that HTTP allows the use of some
   charsets that do not use octets 13 and 10 to represent CR and LF,
   respectively. 

   Conversion will break any cryptographic checksums applied to the
   original content unless the original content is already in canonical
   form.  Therefore, the canonical form is recommended for any content
   that uses such checksums in HTTP.</source>
          <target state="translated">MIME에서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2049#section-4&quot;&gt;[RFC2049]의 섹션 4에&lt;/a&gt; 설명 된대로 인터넷 메일 본문 부분을 전송하기 전에 정식 형식으로 변환해야 합니다. 이 문서의 &lt;a href=&quot;#section-3.1.1.3&quot;&gt;3.1.1.3 절&lt;/a&gt; 은 HTTP를 통해 전송 될 때 &quot;텍스트&quot;미디어 유형의 하위 유형에 허용되는 양식을 설명합니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]은 &quot;텍스트&quot;유형의 컨텐츠는 CRLF로 줄 바꿈을 나타내며 줄 바꿈 시퀀스 외부에서 CR 또는 LF의 사용을 금지해야합니다. HTTP를 사용하면 CRLF, Bare CR 및 Bare LF가 텍스트 내용 내의 줄 바꿈을 표시 할 수 있습니다. HTTP에서 엄격한 MIME 환경으로의 프록시 또는 게이트웨이 는이 문서의 &lt;a href=&quot;#section-3.1.1.3&quot;&gt;3.1.1.3 절에&lt;/a&gt; 설명 된 텍스트 미디어 유형 내의 모든 줄 바꿈 을 &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049로 변환해야합니다.&lt;/a&gt;표준 형태의 CRLF. 그러나 콘텐츠 인코딩이 존재하고 HTTP에서 8 진수 13과 10을 사용하지 않는 일부 문자 집합을 사용하여 CR과 LF를 각각 표현할 수 있기 때문에 이는 복잡 할 수 있습니다. 원본 콘텐츠가 이미 정식 형식이 아닌 경우 변환하면 원본 콘텐츠에 적용된 암호화 체크섬이 손상됩니다. 따라서 HTTP에서 이러한 체크섬을 사용하는 컨텐츠에는 표준 형식이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3173f339d6234c3d312054225c8bdaf39b65b0" translate="yes" xml:space="preserve">
          <source>MIME sniffing</source>
          <target state="translated">MIME 스니핑</target>
        </trans-unit>
        <trans-unit id="8c6307bfb3b795f533739b8404318fa008b26432" translate="yes" xml:space="preserve">
          <source>MIME type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4195024d58b7afd14c9753b91c2a9db35d2b08f" translate="yes" xml:space="preserve">
          <source>MIME types</source>
          <target state="translated">MIME 유형</target>
        </trans-unit>
        <trans-unit id="c3957f21878ad7ce2b26fefff8051376805431e8" translate="yes" xml:space="preserve">
          <source>MIME types are case-insensitive but traditionally written in lowercase.</source>
          <target state="translated">MIME 형식은 대소 문자를 구분하지만 전통적으로 소문자로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b860a02c04e9037685ceb44ac49fc8833ef95f3c" translate="yes" xml:space="preserve">
          <source>MIME types are not the only way to convey document type information:</source>
          <target state="translated">MIME 유형이 문서 유형 정보를 전달하는 유일한 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4da8182b81c1bb802c3acafa674af9adc81313c0" translate="yes" xml:space="preserve">
          <source>MIME types: Complete list of MIME types</source>
          <target state="translated">MIME 유형 : MIME 유형의 전체 목록</target>
        </trans-unit>
        <trans-unit id="148704e082bf337e21217553e9d3d3709aea42bf" translate="yes" xml:space="preserve">
          <source>MKCOL creates a new collection resource at the location specified by
   the Request-URI.  If the Request-URI is already mapped to a resource,
   then the MKCOL MUST fail.  During MKCOL processing, a server MUST
   make the Request-URI an internal member of its parent collection,
   unless the Request-URI is &quot;/&quot;.  If no such ancestor exists, the
   method MUST fail.  When the MKCOL operation creates a new collection
   resource, all ancestors MUST already exist, or the method MUST fail
   with a 409 (Conflict) status code.  For example, if a request to
   create collection /a/b/c/d/ is made, and /a/b/c/ does not exist, the
   request must fail.

   When MKCOL is invoked without a request body, the newly created
   collection SHOULD have no members. 

   A MKCOL request message may contain a message body.  The precise
   behavior of a MKCOL request when the body is present is undefined,
   but limited to creating collections, members of a collection, bodies
   of members, and properties on the collections or members.  If the
   server receives a MKCOL request entity type it does not support or
   understand, it MUST respond with a 415 (Unsupported Media Type)
   status code.  If the server decides to reject the request based on
   the presence of an entity or the type of an entity, it should use the
   415 (Unsupported Media Type) status code.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">MKCOL은 Request-URI로 지정된 위치에 새 콜렉션 자원을 작성합니다. Request-URI가 이미 자원에 맵핑 된 경우 MKCOL은 실패해야합니다. MKCOL 처리 동안 Request-URI가 &quot;/&quot;가 아닌 한, 서버는 반드시 Request-URI를 상위 컬렉션의 내부 구성원으로 만들어야합니다. 그러한 조상이 존재하지 않으면, 반드시 실패해야한다. MKCOL 오퍼레이션이 새 콜렉션 자원을 작성할 때 모든 조상이 이미 존재해야하거나 메소드가 409 (충돌) 상태 코드와 함께 실패해야합니다. 예를 들어, / a / b / c / d / 콜렉션 작성 요청이 작성되고 / a / b / c /가 존재하지 않으면 요청이 실패해야합니다. 요청 본문없이 MKCOL을 호출 할 때 새로 생성 된 컬렉션에는 멤버가 없어야합니다 (SHOULD). MKCOL 요청 메시지는 메시지 본문을 포함 할 수 있습니다.본문이있을 때 MKCOL 요청의 정확한 동작은 정의되어 있지 않지만 콜렉션, 콜렉션 멤버, 멤버 본문 및 콜렉션 또는 멤버에 대한 특성 작성으로 제한됩니다. 서버가 지원하지 않거나 이해하지 못하는 MKCOL 요청 엔티티 유형을 수신하면 415 (지원되지 않는 매체 유형) 상태 코드로 응답해야합니다. 서버가 엔티티 존재 또는 엔티티 유형에 따라 요청을 거부하기로 결정한 경우 415 (지원되지 않는 매체 유형) 상태 코드를 사용해야합니다. 이 방법은 dem 등이지만 안전하지는 않습니다 (참조서버가 지원하지 않거나 이해하지 못하는 MKCOL 요청 엔티티 유형을 수신하면 415 (지원되지 않는 매체 유형) 상태 코드로 응답해야합니다. 서버가 엔티티 존재 또는 엔티티 유형에 따라 요청을 거부하기로 결정한 경우 415 (지원되지 않는 매체 유형) 상태 코드를 사용해야합니다. 이 방법은 dem 등이지만 안전하지는 않습니다 (참조서버가 지원하지 않거나 이해하지 못하는 MKCOL 요청 엔티티 유형을 수신하면 415 (지원되지 않는 매체 유형) 상태 코드로 응답해야합니다. 서버가 엔티티 존재 또는 엔티티 유형에 따라 요청을 거부하기로 결정한 경우 415 (지원되지 않는 매체 유형) 상태 코드를 사용해야합니다. 이 방법은 dem 등이지만 안전하지는 않습니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a7163944345c31e87c18d422da826101ae9abe5" translate="yes" xml:space="preserve">
          <source>MPEG Video</source>
          <target state="translated">MPEG 비디오</target>
        </trans-unit>
        <trans-unit id="6856eb8cd7bbe158e86b90aca7643f9eb2028c7e" translate="yes" xml:space="preserve">
          <source>MS Embedded OpenType fonts</source>
          <target state="translated">MS Embedded OpenType 글꼴</target>
        </trans-unit>
        <trans-unit id="6ee635274712baef8781c8d8f996b059e9c0d4e0" translate="yes" xml:space="preserve">
          <source>Mac OS X on Intel x86 or x86_64</source>
          <target state="translated">Intel x86 또는 x86_64의 Mac OS X</target>
        </trans-unit>
        <trans-unit id="973e3aaf5ab321c24d7296e6f425c45df453a860" translate="yes" xml:space="preserve">
          <source>Mac OS X on PowerPC</source>
          <target state="translated">PowerPC의 Mac OS X</target>
        </trans-unit>
        <trans-unit id="70bafc26930c7270181eba7fdab16bde2ac8ad22" translate="yes" xml:space="preserve">
          <source>Mac OS X version</source>
          <target state="translated">Mac OS X 버전</target>
        </trans-unit>
        <trans-unit id="c0fd8053739db52e4d7f47348c57c75e3099c202" translate="yes" xml:space="preserve">
          <source>Macintosh</source>
          <target state="translated">Macintosh</target>
        </trans-unit>
        <trans-unit id="cd1cb4ddbb5f5f302fe8ca08ece123325b6c28dd" translate="yes" xml:space="preserve">
          <source>Magic numbers. The syntax of different formats allows file-type inference by looking at their byte structure. For example, GIF files start with the &lt;code&gt;47 49 46 38 39&lt;/code&gt; hexadecimal value (&lt;code&gt;GIF89&lt;/code&gt;), and PNG files with &lt;code&gt;89 50 4E 47&lt;/code&gt; (&lt;code&gt;.PNG&lt;/code&gt;). Not all file types have magic numbers, so this is not 100% reliable either.</source>
          <target state="translated">마법의 숫자. 다른 형식의 구문은 바이트 구조를보고 파일 형식 유추를 허용합니다. 예를 들어 GIF 파일은 &lt;code&gt;47 49 46 38 39&lt;/code&gt; 16 진수 값 ( &lt;code&gt;GIF89&lt;/code&gt; )으로 시작하고 PNG 파일은 &lt;code&gt;89 50 4E 47&lt;/code&gt; ( &lt;code&gt;.PNG&lt;/code&gt; )입니다. 모든 파일 유형에 마법 번호가있는 것은 아니므로 100 % 신뢰할 수있는 것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="37e6025eda2c374b5e1db64db721c1f61e0d7e8c" translate="yes" xml:space="preserve">
          <source>Make a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; (using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt;&lt;code&gt;Response.url&lt;/code&gt;&lt;/a&gt; for the Fetch API, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt;&lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt;&lt;/a&gt;) to determine what URL the real preflighted request would end up at.</source>
          <target state="translated">화장 &lt;a href=&quot;#Simple_requests&quot;&gt;간단한 요청을&lt;/a&gt; (사용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Response/url&quot;&gt; &lt;code&gt;Response.url&lt;/code&gt; 를&lt;/a&gt; 페치 API에 대한, 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL&quot;&gt; &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; 는&lt;/a&gt; ) URL이 실제 preflighted 요청에 끝날 것입니다 어떤 결정하기 위해.</target>
        </trans-unit>
        <trans-unit id="db608f8e24798e21b8d041453cb94e74e2d2499f" translate="yes" xml:space="preserve">
          <source>Make another request (the &amp;ldquo;real&amp;rdquo; request) using the URL you obtained from &lt;code&gt;Response.url&lt;/code&gt; or &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; in the first step.</source>
          <target state="translated">첫 번째 단계 에서 &lt;code&gt;Response.url&lt;/code&gt; 또는 &lt;code&gt;XMLHttpRequest.responseURL&lt;/code&gt; 에서 얻은 URL을 사용하여 다른 요청 ( &quot;실제&quot;요청)을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="05029130870878b79b7335852828d865e01799dc" translate="yes" xml:space="preserve">
          <source>Make sure your code only uses the permitted HTTP methods when accessing the service.</source>
          <target state="translated">서비스에 액세스 할 때 코드가 허용 된 HTTP 메소드 만 사용하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="85896aa2638b32ee0bc92737649fbc2fda06cf32" translate="yes" xml:space="preserve">
          <source>Make your page work for both</source>
          <target state="translated">두 페이지 모두에서 페이지 작동</target>
        </trans-unit>
        <trans-unit id="f989199f5291676ea54cc4b082182819742c121f" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource doesn't match any of the given ETags. This is used to update caches (for safe requests), or to prevent to upload a new resource when one is already existing.</source>
          <target state="translated">저장된 리소스가 주어진 ETag와 일치하지 않는 경우에만 요청을 조건부로 만들고 메서드를 적용합니다. 캐시를 업데이트하거나 (안전한 요청을 위해) 이미 존재하는 경우 새 리소스를 업로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="44bbd70969c3a3e1d64163feeed015fad79d423a" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and applies the method only if the stored resource matches one of the given ETags.</source>
          <target state="translated">저장된 자원이 주어진 ETag 중 하나와 일치하는 경우에만 요청을 조건부로 작성하고 메소드를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="169b3478c02104479a6e6958b18af330ce9e16b1" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has been modified after the given date. This is used to transmit data only when the cache is out of date.</source>
          <target state="translated">요청을 조건부로 지정하고 주어진 날짜 이후에 수정 된 경우에만 엔티티가 전송 될 것으로 예상합니다. 캐시가 오래되었을 때만 데이터를 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09d74b4e76e350446f9d2ba5e44f9fb97d8901cd" translate="yes" xml:space="preserve">
          <source>Makes the request conditional and expects the entity to be transmitted only if it has not been modified after the given date. This is used to ensure the coherence of a new fragment of a specific range with previous ones, or to implement an optimistic concurrency control system when modifying existing documents.</source>
          <target state="translated">요청을 조건부로 지정하고 주어진 날짜 이후에 수정하지 않은 경우에만 엔티티가 전송 될 것으로 예상합니다. 이는 이전 범위와 특정 범위의 새로운 단편의 일관성을 유지하거나 기존 문서를 수정할 때 낙관적 동시성 제어 시스템을 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee449b1a1e7a790032bd3390fdea7fc50fbb85e5" translate="yes" xml:space="preserve">
          <source>Mandatory upgrade</source>
          <target state="translated">필수 업그레이드</target>
        </trans-unit>
        <trans-unit id="aa95526dca52047ea17840984f5ae03c1700be81" translate="yes" xml:space="preserve">
          <source>Many &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;developer tools' network panels&lt;/a&gt; of browsers create extraneous requests leading to &lt;code&gt;304&lt;/code&gt; responses, so that access to the local cache is visible to developers.</source>
          <target state="translated">많은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;개발자 도구&lt;/a&gt; 의 브라우저 네트워크 패널 은 &lt;code&gt;304&lt;/code&gt; 개의 응답으로 이어지는 외부 요청을 생성 하므로 로컬 캐시에 대한 액세스가 개발자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c2d53d901c528a1965720abe35932f4bbca17a" translate="yes" xml:space="preserve">
          <source>Many WebDAV clients that have already been implemented have account
   settings (similar to the way email clients store IMAP account
   settings).  Thus, the WebDAV client would be able to authenticate
   with its first couple requests to the server, provided it had a way
   to get the authentication challenge from the server with realm name, 

   nonce, and other challenge information.  Note that the results of
   some requests might vary according to whether or not the client is
   authenticated -- a PROPFIND might return more visible resources if
   the client is authenticated, yet not fail if the client is anonymous.

   There are a number of ways the client might be able to trigger the
   server to provide an authentication challenge.  This appendix
   describes a couple approaches that seem particularly likely to work.

   The first approach is to perform a request that ought to require
   authentication.  However, it's possible that a server might handle
   any request even without authentication, so to be entirely safe, the
   client could add a conditional header to ensure that even if the
   request passes permissions checks, it's not actually handled by the
   server.  An example of following this approach would be to use a PUT
   request with an &quot;If-Match&quot; header with a made-up ETag value.  This
   approach might fail to result in an authentication challenge if the
   server does not test authorization before testing conditionals as is
   required (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;), or if the server does not need to test
   authorization.

   Example - forcing auth challenge with write request

   &amp;gt;&amp;gt;Request

     PUT /forceauth.txt HTTP/1.1
     Host: www.example.com
     If-Match: &quot;xxx&quot;
     Content-Type: text/plain
     Content-Length: 0


   The second approach is to use an Authorization header (defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]), which is likely to be rejected by the server but which
   will then prompt a proper authentication challenge.  For example, the
   client could start with a PROPFIND request containing an
   Authorization header containing a made-up Basic userid:password
   string or with actual plausible credentials.  This approach relies on
   the server responding with a &quot;401 Unauthorized&quot; along with a
   challenge if it receives an Authorization header with an unrecognized
   username, invalid password, or if it doesn't even handle Basic
   authentication.  This seems likely to work because of the
   requirements of &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;: 

   &quot;If the origin server does not wish to accept the credentials sent
   with a request, it SHOULD return a 401 (Unauthorized) response.  The
   response MUST include a WWW-Authenticate header field containing at
   least one (possibly new) challenge applicable to the requested
   resource.&quot;

   There's a slight problem with implementing that recommendation in
   some cases, because some servers do not even have challenge
   information for certain resources.  Thus, when there's no way to
   authenticate to a resource or the resource is entirely publicly
   available over all accepted methods, the server MAY ignore the
   Authorization header, and the client will presumably try again later.

   Example - forcing auth challenge with Authorization header

   &amp;gt;&amp;gt;Request

     PROPFIND /docs/ HTTP/1.1
     Host: www.example.com
     Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
     Content-type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     [body omitted]</source>
          <target state="translated">이미 구현 된 많은 WebDAV 클라이언트에는 계정 설정이 있습니다 (이메일 클라이언트가 IMAP 계정 설정을 저장하는 방식과 유사). 따라서 WebDAV 클라이언트는 영역 이름, nonce 및 기타 요청 정보를 사용하여 서버에서 인증 요청을 얻는 방법이 있다면 서버에 대한 첫 번째 커플 요청으로 인증 할 수 있습니다. 일부 요청의 결과는 클라이언트의 인증 여부에 따라 달라질 수 있습니다. PROPFIND는 클라이언트가 인증 된 경우 더 많은 가시적 리소스를 반환하지만 클라이언트가 익명 인 경우 실패하지 않을 수 있습니다. 클라이언트가 인증 요청을 제공하기 위해 서버를 트리거 할 수있는 여러 가지 방법이 있습니다. 이 부록에서는 특히 효과가있을 것으로 보이는 몇 가지 접근법에 대해 설명합니다.첫 번째 방법은 인증이 필요한 요청을 수행하는 것입니다. 그러나 서버가 인증 없이도 모든 요청을 처리 할 수 ​​있으므로 완전히 안전하기 위해 클라이언트는 요청이 권한 검사를 통과하더라도 실제로 서버에서 처리하지 않도록 조건부 헤더를 추가 할 수 있습니다. 이 방법을 따르는 예는 구성 ETag 값이있는 &quot;If-Match&quot;헤더와 함께 PUT 요청을 사용하는 것입니다. 필요에 따라 조건부 테스트 전에 서버가 권한 부여를 테스트하지 않으면이 방법으로 인증 시도가 실패 할 수 있습니다 (참조클라이언트는 요청이 권한 검사를 통과하더라도 실제로는 서버에 의해 처리되지 않도록 조건부 헤더를 추가 할 수 있습니다. 이 방법을 따르는 예는 구성 ETag 값이있는 &quot;If-Match&quot;헤더와 함께 PUT 요청을 사용하는 것입니다. 필요에 따라 조건부 테스트 전에 서버가 권한 부여를 테스트하지 않으면이 방법으로 인증 시도가 실패 할 수 있습니다 (참조클라이언트는 요청이 권한 검사를 통과하더라도 실제로는 서버에 의해 처리되지 않도록 조건부 헤더를 추가 할 수 있습니다. 이 방법을 따르는 예는 구성 ETag 값이있는 &quot;If-Match&quot;헤더와 함께 PUT 요청을 사용하는 것입니다. 필요에 따라 조건부 테스트 전에 서버가 권한 부여를 테스트하지 않으면이 방법으로 인증 시도가 실패 할 수 있습니다 (참조필요에 따라 조건부 테스트 전에 서버가 권한 부여를 테스트하지 않으면이 방법으로 인증 시도가 실패 할 수 있습니다 (참조필요에 따라 조건부 테스트 전에 서버가 권한 부여를 테스트하지 않으면이 방법으로 인증 시도가 실패 할 수 있습니다 (참조&lt;a href=&quot;#section-8.5&quot;&gt;섹션 8.5&lt;/a&gt; ) 또는 서버가 인증을 테스트 할 필요가없는 경우 예-쓰기 요청으로 인증 요청 강제하기 &amp;gt;&amp;gt; 요청 PUT /forceauth.txt HTTP / 1.1 호스트 : www.example.com If-Match : &quot;xxx&quot;Content-Type : text / plain Content-Length : 0 두 번째 방법은 승인 헤더 사용 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617에&lt;/a&gt; 정의 됨)]), 이는 서버에 의해 거부 될 수 있지만 적절한 인증 시도를 촉발합니다. 예를 들어, 클라이언트는 기본 Basic userid : password 문자열을 포함하는 Authorization 헤더 또는 실제 그럴듯한 자격 증명을 포함하는 PROPFIND 요청으로 시작할 수 있습니다. 이 방법은 인식 할 수없는 사용자 이름, 유효하지 않은 비밀번호를 가진 Authorization 헤더를 받거나 기본 인증을 처리하지 못하는 경우, &quot;401 Unauthorized&quot;로 응답하는 서버를 사용합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; 의 요구 사항으로 인해 작동하는 것 같습니다.: &quot;원본 서버가 요청과 함께 전송 된 자격 증명을 수락하지 않으려면 401 (권한 없음) 응답을 반환해야합니다. 응답에는 최소한 하나의 (신규) 도전 과제를 포함하는 WWW 인증 헤더 필드가 포함되어야합니다. 요청 된 리소스. &quot; 일부 서버에는 특정 리소스에 대한 챌린지 정보가 없기 때문에 권장 사항을 구현하는 데 약간의 문제가 있습니다. 따라서 리소스를 인증 할 방법이 없거나 허용되는 모든 방법을 통해 리소스를 공개적으로 사용할 수있는 경우 서버는 Authorization 헤더를 무시할 수 있으며 클라이언트는 나중에 다시 시도합니다. 예-인증 헤더 &amp;gt;&amp;gt; Request PROPFIND / docs / HTTP / 1.1 호스트를 사용하여 인증 요청 강제 실행 : www.example.com 인증 : 기본 QWxhZGRpbjpvcGVuIHNlc2FtZQ == 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;Content-Length : xxxx [본문 생략]</target>
        </trans-unit>
        <trans-unit id="c2f40e3ce20552730e2da9b44cf88aa049c3f277" translate="yes" xml:space="preserve">
          <source>Many clients also let you avoid the login prompt by using an encoded URL containing the username and the password like this:</source>
          <target state="translated">많은 클라이언트는 다음과 같이 사용자 이름과 비밀번호를 포함하는 인코딩 된 URL을 사용하여 로그인 프롬프트를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283c9af22dd90c8866e71dddbfce0cce3700a5b6" translate="yes" xml:space="preserve">
          <source>Many of the request header fields for proactive negotiation use a
   common parameter, named &quot;q&quot; (case-insensitive), to assign a relative
   &quot;weight&quot; to the preference for that associated kind of content.  This
   weight is referred to as a &quot;quality value&quot; (or &quot;qvalue&quot;) because the
   same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various
   representations that can be selected for a resource. 

   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred; a
   value of 0 means &quot;not acceptable&quot;.  If no &quot;q&quot; parameter is present,
   the default weight is 1.

     weight = OWS &quot;;&quot; OWS &quot;q=&quot; qvalue
     qvalue = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
            / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   A sender of qvalue MUST NOT generate more than three digits after the
   decimal point.  User configuration of these values ought to be
   limited in the same fashion.</source>
          <target state="translated">사전 협상을위한 많은 요청 헤더 필드는 &quot;q&quot;(대소 문자를 구분하지 않음)라는 공통 매개 변수를 사용하여 해당하는 종류의 콘텐츠에 대한 기본 설정에 상대적 &quot;무게&quot;를 할당합니다. 이 가중치는 &quot;품질 값&quot;(또는 &quot;qvalue&quot;)이라고합니다. 동일한 매개 변수 이름이 종종 서버 구성 내에서 사용되어 자원에 대해 선택할 수있는 다양한 표현의 상대적인 품질에 가중치를 할당하기 때문입니다. 가중치는 0 내지 1 범위의 실수로 정규화되는데, 0.001이 가장 바람직하지 않고 1이 가장 바람직하다. 0 값은 &quot;허용되지 않음&quot;을 의미합니다. &quot;q&quot;매개 변수가 없으면 기본 가중치는 1입니다. weight = OWS &quot;;&quot; OWS &quot;q =&quot;qvalue qvalue = ( &quot;0&quot;[ &quot;.&quot; 0 * 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;0 * 3 ( &quot;0&quot;)]) qvalue의 발신자는 소수점 다음에 3 자리를 초과하여 생성해서는 안됩니다. 이러한 값의 사용자 구성은 동일한 방식으로 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fec0947cbf922d8434fc8fe01a93bf6110f4bdb" translate="yes" xml:space="preserve">
          <source>Many user agents make it possible for users to override the basic
   caching mechanisms. For example, the user agent might allow the user
   to specify that cached entities (even explicitly stale ones) are
   never validated. Or the user agent might habitually add &quot;Cache-
   Control: max-stale=3600&quot; to every request. The user agent SHOULD NOT
   default to either non-transparent behavior, or behavior that results
   in abnormally ineffective caching, but MAY be explicitly configured
   to do so by an explicit action of the user.

   If the user has overridden the basic caching mechanisms, the user
   agent SHOULD explicitly indicate to the user whenever this results in
   the display of information that might not meet the server's
   transparency requirements (in particular, if the displayed entity is
   known to be stale). Since the protocol normally allows the user agent
   to determine if responses are stale or not, this indication need only
   be displayed when this actually happens. The indication need not be a
   dialog box; it could be an icon (for example, a picture of a rotting
   fish) or some other indicator.

   If the user has overridden the caching mechanisms in a way that would
   abnormally reduce the effectiveness of caches, the user agent SHOULD
   continually indicate this state to the user (for example, by a
   display of a picture of currency in flames) so that the user does not
   inadvertently consume excess resources or suffer from excessive
   latency.</source>
          <target state="translated">많은 사용자 에이전트가 사용자가 기본 캐싱 메커니즘을 대체 할 수있게합니다. 예를 들어, 사용자 에이전트는 사용자가 캐시 된 엔티티 (명시 적으로 오래된 엔티티도)의 유효성을 검증하지 않도록 지정할 수 있습니다. 또는 사용자 에이전트는 습관적으로 모든 요청에 ​​&quot;캐시 제어 : max-stale = 3600&quot;을 추가 할 수 있습니다. 사용자 에이전트는 투명하지 않은 동작 또는 비정상적으로 비효율적 인 캐싱을 초래하는 동작으로 기본 설정되어서는 안되지만, 사용자의 명시 적 조치에 의해 명시 적으로 구성 될 수 있습니다. 사용자가 기본 캐싱 메커니즘을 재정의 한 경우, 사용자 에이전트는 서버의 투명성 요구 사항을 충족하지 못할 수있는 정보가 표시 될 때마다 (특히 표시된 엔터티가 오래되었다고 알려진 경우) 사용자에게 명시 적으로 표시해야합니다.프로토콜은 일반적으로 사용자 에이전트가 응답이 오래되었는지 여부를 판별 할 수있게하므로 실제로 발생하는 경우에만이 표시를 표시하면됩니다. 표시는 대화 상자 일 필요는 없습니다. 아이콘 (예 : 썩은 물고기 그림) 또는 다른 표시 기일 수 있습니다. 캐시의 효과를 비정상적으로 감소시키는 방식으로 사용자가 캐싱 메커니즘을 재정의 한 경우, 사용자 에이전트는 사용자에게이 상태를 지속적으로 표시해야합니다 (예 : 화염 그림 표시). 실수로 과도한 리소스를 소비하거나 과도한 대기 시간이 발생하지 않습니다.표시는 대화 상자 일 필요는 없습니다. 아이콘 (예 : 썩은 물고기 그림) 또는 다른 표시 기일 수 있습니다. 캐시의 효과를 비정상적으로 감소시키는 방식으로 사용자가 캐싱 메커니즘을 재정의 한 경우, 사용자 에이전트는 사용자에게이 상태를 지속적으로 표시해야합니다 (예 : 화염 그림 표시). 실수로 과도한 리소스를 소비하거나 과도한 대기 시간이 발생하지 않습니다.표시는 대화 상자 일 필요는 없습니다. 아이콘 (예 : 썩은 물고기 그림) 또는 다른 표시 기일 수 있습니다. 캐시의 효과를 비정상적으로 감소시키는 방식으로 사용자가 캐싱 메커니즘을 재정의 한 경우, 사용자 에이전트는 사용자에게이 상태를 지속적으로 표시해야합니다 (예 : 화염 그림 표시). 실수로 과도한 리소스를 소비하거나 과도한 대기 시간이 발생하지 않습니다.화염에 화폐 그림을 표시하여) 사용자가 실수로 초과 리소스를 소비하지 않거나 대기 시간이 지나치게 길지 않도록합니다.화염에 화폐 그림을 표시하여) 사용자가 실수로 초과 리소스를 소비하지 않거나 대기 시간이 지나치게 길지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="91d901c4ba5ec936d334c6e339e3c5a344ea50ad" translate="yes" xml:space="preserve">
          <source>Many web sites customize the look of a 404 page to be more helpful to the user and provide guidance on what to do next. Apache servers can be configured using an &lt;code&gt;.htaccess&lt;/code&gt; file and a code snippet like the following example.</source>
          <target state="translated">많은 웹 사이트에서 404 페이지의 모양을 사용자 지정하여 사용자에게보다 도움이되고 다음에 수행 할 작업에 대한 지침을 제공합니다. Apache 서버는 &lt;code&gt;.htaccess&lt;/code&gt; 파일과 다음 예제와 같은 코드 스 니펫을 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a17963b7961c54316ccf166b602f9000c64c4f9a" translate="yes" xml:space="preserve">
          <source>Matches any content encoding not already listed in the header. This is the default value if the header is not present. It doesn't mean that any algorithm is supported; merely that no preference is expressed.</source>
          <target state="translated">헤더에 아직 나열되지 않은 콘텐츠 인코딩과 일치합니다. 헤더가없는 경우 이것이 기본값입니다. 모든 알고리즘이 지원되는 것은 아닙니다. 단지 선호도가 표현되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="380542fdbbc688e8e6c3dd27ea8f678b7e9f1ca5" translate="yes" xml:space="preserve">
          <source>Max-Age=&amp;lt;number&amp;gt; Optional</source>
          <target state="translated">최대 연령 = &amp;lt;번호&amp;gt; 선택</target>
        </trans-unit>
        <trans-unit id="1f82181c1557956a09c87927dc4ce27ccc4098f3" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 2616)</source>
          <target state="translated">최대 전달 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="2b2d8c8ce404909b199641932433093016cba38f" translate="yes" xml:space="preserve">
          <source>Max-Forwards (RFC 7231)</source>
          <target state="translated">최대 전달 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="02e6cf952f41741b2d0d0521bab1b080b79a5956" translate="yes" xml:space="preserve">
          <source>Maximum number of seconds the results can be cached.</source>
          <target state="translated">결과를 캐시 할 수있는 최대 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="cfef933803d5e6538306daeac1d4318fa9cda10c" translate="yes" xml:space="preserve">
          <source>May be set by hosting environments or other frameworks and contains information about them while not providing any usefulness to the application or its visitors. Unset this header to avoid exposing potential vulnerabilities.</source>
          <target state="translated">환경 또는 다른 프레임 워크를 호스팅하여 설정할 수 있으며 응용 프로그램이나 방문자에게 유용하지 않은 정보를 포함합니다. 잠재적 인 취약점이 노출되지 않도록이 헤더를 설정 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="0d2e9b5ce7309f95a7890febc6e837b7f6d73bb0" translate="yes" xml:space="preserve">
          <source>Media formats supported by the HTML audio and video elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73c2e204a43c925f331f4a9f4aa965ffa11300d" translate="yes" xml:space="preserve">
          <source>Media is only allowed from media1.com and media2.com (and not from subdomains of those sites).</source>
          <target state="translated">미디어는 media1.com 및 media2.com에서만 허용되며 해당 사이트의 하위 도메인에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62da738dbc54cd00c3ecc7aaa0efba6cf80eed5e" translate="yes" xml:space="preserve">
          <source>Message Format (RFC 7230)</source>
          <target state="translated">메시지 형식 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="cd72d478c14d1e61f4d253f077b3b5817e52cd02" translate="yes" xml:space="preserve">
          <source>Message Routing (RFC 7230)</source>
          <target state="translated">메시지 라우팅 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="ed576c67d1fde583bfb7d4b0af04da9e09035d6c" translate="yes" xml:space="preserve">
          <source>Message body information</source>
          <target state="translated">메시지 본문 정보</target>
        </trans-unit>
        <trans-unit id="f1702b4686278becffc88baabe6f4b7a8355532c" translate="yes" xml:space="preserve">
          <source>Messages</source>
          <target state="translated">Messages</target>
        </trans-unit>
        <trans-unit id="f361b914c2431b8337949e5a832a53f9c04c4160" translate="yes" xml:space="preserve">
          <source>Messages are parsed using a generic algorithm, independent of the
   individual header field names.  The contents within a given field
   value are not parsed until a later stage of message interpretation
   (usually after the message's entire header section has been
   processed).  Consequently, this specification does not use ABNF rules
   to define each &quot;Field-Name: Field Value&quot; pair, as was done in
   previous editions.  Instead, this specification uses ABNF rules that
   are named according to each registered field name, wherein the rule
   defines the valid grammar for that field's corresponding field values
   (i.e., after the field-value has been extracted from the header
   section by a generic field parser).

   No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.

   A field value might be preceded and/or followed by optional
   whitespace (OWS); a single SP preceding the field-value is preferred
   for consistent readability by humans.  The field value does not
   include any leading or trailing whitespace: OWS occurring before the
   first non-whitespace octet of the field value or after the last
   non-whitespace octet of the field value ought to be excluded by
   parsers when extracting the field value from a header field.

   Historically, HTTP header field values could be extended over
   multiple lines by preceding each extra line with at least one space
   or horizontal tab (obs-fold).  This specification deprecates such
   line folding except within the message/http media type
   (&lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).  A sender MUST NOT generate a message that includes
   line folding (i.e., that has any field-value that contains a match to
   the obs-fold rule) unless the message is intended for packaging
   within the message/http media type. 

   A server that receives an obs-fold in a request message that is not
   within a message/http container MUST either reject the message by
   sending a 400 (Bad Request), preferably with a representation
   explaining that obsolete line folding is unacceptable, or replace
   each received obs-fold with one or more SP octets prior to
   interpreting the field value or forwarding the message downstream.

   A proxy or gateway that receives an obs-fold in a response message
   that is not within a message/http container MUST either discard the
   message and replace it with a 502 (Bad Gateway) response, preferably
   with a representation explaining that unacceptable line folding was
   received, or replace each received obs-fold with one or more SP
   octets prior to interpreting the field value or forwarding the
   message downstream.

   A user agent that receives an obs-fold in a response message that is
   not within a message/http container MUST replace each received
   obs-fold with one or more SP octets prior to interpreting the field
   value.

   Historically, HTTP has allowed field content with text in the
   ISO-8859-1 charset [&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;], supporting other charsets only
   through use of [&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt;] encoding.  In practice, most HTTP header
   field values use only a subset of the US-ASCII charset [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;].
   Newly defined header fields SHOULD limit their field values to
   US-ASCII octets.  A recipient SHOULD treat other octets in field
   content (obs-text) as opaque data.</source>
          <target state="translated">메시지는 개별 헤더 필드 이름과 상관없이 일반 알고리즘을 사용하여 구문 분석됩니다. 주어진 필드 값 내의 내용은 메시지 해석의 나중 단계 (일반적으로 메시지의 전체 헤더 섹션이 처리 된 후)까지 구문 분석되지 않습니다. 결과적으로이 사양에서는 이전 버전 에서처럼 ABNF 규칙을 사용하여 각 &quot;Field-Name : Field Value&quot;쌍을 정의하지 않습니다. 대신이 사양은 등록 된 각 필드 이름에 따라 이름이 지정된 ABNF 규칙을 사용합니다. 여기서 규칙은 해당 필드의 해당 필드 값에 대한 유효한 문법을 ​​정의합니다 (즉, 필드 값이 일반 필드 파서에 의해 헤더 섹션에서 추출 된 후) ). 헤더 field-name과 콜론 사이에는 공백이 허용되지 않습니다. 과거에,이러한 공백 처리의 차이로 인해 요청 라우팅 및 응답 처리에서 보안 취약점이 발생했습니다. 서버는 헤더 필드 이름과 콜론 사이에 응답 코드 400 (잘못된 요청)으로 공백이 포함 된 수신 요청 메시지를 거부해야합니다. 프록시는 메시지를 다운 스트림으로 전달하기 전에 응답 메시지에서 이러한 공백을 제거해야합니다. 필드 값 앞에 선택적 공백 (OWS)이 올 수 있습니다. 사람이 일관된 가독성을 위해 필드 값 앞에 단일 SP가 선호됩니다. 필드 값에는 선행 또는 후행 공백이 포함되지 않습니다.필드 값의 첫 번째 공백이 아닌 8 진수 이전 또는 필드 값의 마지막 공백이 아닌 8 진수 이후에 발생하는 OWS는 헤더 필드에서 필드 값을 추출 할 때 파서에서 제외해야합니다. 역사적으로 HTTP 헤더 필드 값은 각 추가 줄 앞에 최소한 하나의 공백 또는 가로 탭 (가리개)이있어 여러 줄로 확장 될 수있었습니다. 이 사양은 메시지 / http 미디어 유형 (&lt;a href=&quot;#section-8.3.1&quot;&gt;섹션 8.3.1&lt;/a&gt;). 메시지 / http 미디어 유형 내에 패키징하기위한 것이 아니라면 발신자는 줄 바꿈을 포함하는 메시지를 생성하지 않아야합니다 (예 : obs-fold 규칙과 일치하는 필드 값을 가짐). 메시지 / http 컨테이너 내에 있지 않은 요청 메시지에서 겹침을 수신하는 서버는 400 (잘못된 요청)을 보내서 메시지를 거부해야하며, 바람직하게는 쓸모없는 라인 폴딩이 허용되지 않음을 설명하는 표시와 함께 각각을 대체해야합니다. 필드 값을 해석하거나 메시지를 다운 스트림으로 전달하기 전에 하나 이상의 SP 옥텟으로 obs-fold를 수신 한 경우. 메시지 / http 컨테이너 내에없는 응답 메시지에서 겹침을 수신하는 프록시 또는 게이트웨이는 메시지를 버리고 502 (Bad Gateway) 응답으로 대체해야합니다.바람직하게는 수용 불가능한 라인 폴딩이 수신되었음을 설명하는 표현으로, 또는 필드 값을 해석하거나 메시지를 다운 스트림으로 전달하기 전에 각각의 수신 된 오버 폴딩을 하나 이상의 SP 옥텟으로 대체한다. 메시지 / http 컨테이너 내에 있지 않은 응답 메시지에서 obs-fold를 수신 한 사용자 에이전트는 필드 값을 해석하기 전에 수신 된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체해야합니다. 역사적으로 HTTP는 ISO-8859-1 문자셋 [메시지 / http 컨테이너 내에 있지 않은 응답 메시지에서 obs-fold를 수신 한 사용자 에이전트는 필드 값을 해석하기 전에 수신 된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체해야합니다. 역사적으로 HTTP는 ISO-8859-1 문자셋 [메시지 / http 컨테이너 내에 있지 않은 응답 메시지에서 obs-fold를 수신 한 사용자 에이전트는 필드 값을 해석하기 전에 수신 된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체해야합니다. 역사적으로 HTTP는 ISO-8859-1 문자셋 [&lt;a href=&quot;#ref-ISO-8859-1&quot;&gt;&lt;/a&gt;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt; ] 인코딩 을 사용하는 경우에만 다른 문자 집합을 지원하는 ISO-8859-1 ] . 실제로 대부분의 HTTP 헤더 필드 값은 US-ASCII 문자 집합의 일부만 사용합니다 [ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ]. 새로 정의 된 헤더 필드는 필드 값을 US-ASCII 옥텟으로 제한해야합니다. 수신자는 필드 내용 (obs-text)의 다른 옥텟을 불투명 한 데이터로 취급해야한다.</target>
        </trans-unit>
        <trans-unit id="a45a53f69ac8d4f9beb81fdb6abdda0d81b83401" translate="yes" xml:space="preserve">
          <source>Meta tag configuration</source>
          <target state="translated">메타 태그 구성</target>
        </trans-unit>
        <trans-unit id="d3bc7449553df912945049faf23d54805daa3cef" translate="yes" xml:space="preserve">
          <source>Method Definitions (RFC 2616)</source>
          <target state="translated">분석법 정의 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="cb7ac4b5940dd1c323d62b5a8e651330e7495257" translate="yes" xml:space="preserve">
          <source>Method and body not changed</source>
          <target state="translated">방법과 몸은 바뀌지 않았습니다</target>
        </trans-unit>
        <trans-unit id="2d2721aaa9ac715c71cff1347bdeb0765b82f40d" translate="yes" xml:space="preserve">
          <source>Method and body not changed.</source>
          <target state="translated">방법과 본문은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="53d262d73147d297967a65df5e7306875b16e48d" translate="yes" xml:space="preserve">
          <source>Method handling</source>
          <target state="translated">분석법 처리</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="7e8cf9e2eae4020fb1e8917e8ab3068925ba7380" translate="yes" xml:space="preserve">
          <source>Methods can also have the property of &quot;idempotence&quot; in that (aside
   from error or expiration issues) the side-effects of N &amp;gt; 0 identical
   requests is the same as for a single request. The methods GET, HEAD,
   PUT and DELETE share this property. Also, the methods OPTIONS and
   TRACE SHOULD NOT have side effects, and so are inherently idempotent. 

   However, it is possible that a sequence of several requests is non-
   idempotent, even if all of the methods executed in that sequence are
   idempotent. (A sequence is idempotent if a single execution of the
   entire sequence always yields a result that is not changed by a
   reexecution of all, or part, of that sequence.) For example, a
   sequence is non-idempotent if its result depends on a value that is
   later modified in the same sequence.

   A sequence that never has side effects is idempotent, by definition
   (provided that no concurrent operations are being executed on the
   same set of resources).</source>
          <target state="translated">또한 메소드는 &quot;오류 또는 만기 문제를 제외하고&quot;N&amp;gt; 0 동일한 요청의 부작용이 단일 요청의 부작용과 동일하다는 점에서 &quot;등전위&quot;특성을 가질 수 있습니다. GET, HEAD, PUT 및 DELETE 메소드는이 특성을 공유합니다. 또한, OPTIONS 및 TRACE 메소드는 부작용이 없어야하며, 따라서 본질적으로 dem 등호입니다. 그러나 해당 시퀀스에서 실행 된 모든 메소드가 dem 등수 인 경우에도 여러 요청의 순서가 i 등원이 아닐 수 있습니다. (전체 시퀀스의 단일 실행이 항상 해당 시퀀스의 전체 또는 일부를 다시 실행해도 변경되지 않는 결과를 생성하는 경우 시퀀스는 dem 등원입니다.) 예를 들어, 시퀀스의 결과가 나중에 같은 순서로 수정되는 값.부작용이없는 시퀀스는 정의 상으로는 dem 등수입니다 (동일한 리소스 세트에서 동시 작업이 실행되지 않는 경우).</target>
        </trans-unit>
        <trans-unit id="242805378404a310345cf70839197bf474f74005" translate="yes" xml:space="preserve">
          <source>Microphone</source>
          <target state="translated">Microphone</target>
        </trans-unit>
        <trans-unit id="87276ecf605640589cec1d79d00bf26c970b94e4" translate="yes" xml:space="preserve">
          <source>Microsoft Excel</source>
          <target state="translated">마이크로 소프트 엑셀</target>
        </trans-unit>
        <trans-unit id="2a323ed6449b617238b82a3dfc75eb9621adc7da" translate="yes" xml:space="preserve">
          <source>Microsoft Excel (OpenXML)</source>
          <target state="translated">Microsoft Excel (OpenXML)</target>
        </trans-unit>
        <trans-unit id="95afea748c2d83deeb5e505cb3467080a79ec0dd" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint</source>
          <target state="translated">마이크로 소프트 파워 포인트</target>
        </trans-unit>
        <trans-unit id="66f10ebd0f328820d7789369e62c94f10eb4d83b" translate="yes" xml:space="preserve">
          <source>Microsoft PowerPoint (OpenXML)</source>
          <target state="translated">Microsoft PowerPoint (OpenXML)</target>
        </trans-unit>
        <trans-unit id="f8f6993a5165c131c1d8c5214734c809b756f2ef" translate="yes" xml:space="preserve">
          <source>Microsoft Visio</source>
          <target state="translated">Microsoft Visio</target>
        </trans-unit>
        <trans-unit id="1549499155dcad76ee4cf933519cd8cacaf632b7" translate="yes" xml:space="preserve">
          <source>Microsoft Word</source>
          <target state="translated">마이크로 소프트 워드</target>
        </trans-unit>
        <trans-unit id="36cf4ee07cac5059a5ad97ffe928503bd176751c" translate="yes" xml:space="preserve">
          <source>Microsoft Word (OpenXML)</source>
          <target state="translated">Microsoft Word (OpenXML)</target>
        </trans-unit>
        <trans-unit id="1198ed8512c8cdd797293daa67494bddc3770413" translate="yes" xml:space="preserve">
          <source>Microsoft document</source>
          <target state="translated">Microsoft 문서</target>
        </trans-unit>
        <trans-unit id="1df4b94ae4d5602d088aff532dae5e38510a6678" translate="yes" xml:space="preserve">
          <source>Midi</source>
          <target state="translated">Midi</target>
        </trans-unit>
        <trans-unit id="f3c717723ab8734d12784f68a0722e11e80fcc72" translate="yes" xml:space="preserve">
          <source>Minutes from 0 to 59.</source>
          <target state="translated">0 ~ 59 분</target>
        </trans-unit>
        <trans-unit id="89539c6918ebad2db5606b4128932b01811ff405" translate="yes" xml:space="preserve">
          <source>Miscellaneous Persistent Warning</source>
          <target state="translated">기타 지속적 경고</target>
        </trans-unit>
        <trans-unit id="a58539b42f2a5b03e79f0e0357f01220b1c564c9" translate="yes" xml:space="preserve">
          <source>Miscellaneous Warning</source>
          <target state="translated">기타 경고</target>
        </trans-unit>
        <trans-unit id="6440b6c15fbd440237dd7ddf04fa83c555b31d51" translate="yes" xml:space="preserve">
          <source>Mitigating MIME Confusion Attacks in Firefox</source>
          <target state="translated">Firefox에서 MIME 혼동 공격 완화</target>
        </trans-unit>
        <trans-unit id="5d489f5457c01748e6b6d121f8ab0bb76ce6faab" translate="yes" xml:space="preserve">
          <source>Mitigating cross site scripting</source>
          <target state="translated">크로스 사이트 스크립팅 완화</target>
        </trans-unit>
        <trans-unit id="a06d1d2ac6f2847420dd550f09dcb2166ef5252d" translate="yes" xml:space="preserve">
          <source>Mitigating packet sniffing attacks</source>
          <target state="translated">패킷 스니핑 공격 완화</target>
        </trans-unit>
        <trans-unit id="f7fb61404c2b0add12a8de94361ca1262d06c970" translate="yes" xml:space="preserve">
          <source>Mixed Content</source>
          <target state="translated">혼합 컨텐츠</target>
        </trans-unit>
        <trans-unit id="4a03a5aca91ea4ae835ab37b3456e345e1c824ad" translate="yes" xml:space="preserve">
          <source>Mixed Content&lt;br/&gt;&lt;small&gt;The definition of 'block-all-mixed-content' in that specification.&lt;/small&gt;</source>
          <target state="translated">혼합 컨텐츠 &lt;br/&gt;&lt;small&gt;해당 사양에서 '전부 혼합 컨텐츠'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="69248b8f3367a963f6ed1431265d03d542c43778" translate="yes" xml:space="preserve">
          <source>Mixed content</source>
          <target state="translated">혼합 컨텐츠</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="0efeb0636336539c3bcea3d1fe128360ba3a0b9d" translate="yes" xml:space="preserve">
          <source>Mobile Device Detection</source>
          <target state="translated">모바일 장치 감지</target>
        </trans-unit>
        <trans-unit id="2ae9795ad44783e26e39ba8db6b981786d39f71b" translate="yes" xml:space="preserve">
          <source>Mobile and Tablet indicators</source>
          <target state="translated">모바일 및 태블릿 표시기</target>
        </trans-unit>
        <trans-unit id="183f26ae5771e151ff87bc3aac010eef4b387ac0" translate="yes" xml:space="preserve">
          <source>Mobile, Tablet or Desktop</source>
          <target state="translated">모바일, 태블릿 또는 데스크탑</target>
        </trans-unit>
        <trans-unit id="1387238e2992cdaf972778c0a1519b7892c33930" translate="yes" xml:space="preserve">
          <source>More specifically, this article is for web administrators, server developers, and front-end developers. Modern browsers handle the client-side components of cross-origin sharing, including headers and policy enforcement. But this new standard means servers have to handle new request and response headers. Another article for server developers discussing &lt;a href=&quot;server-side_access_control&quot;&gt;cross-origin sharing from a server perspective (with PHP code snippets)&lt;/a&gt; is supplementary reading.</source>
          <target state="translated">보다 구체적으로이 기사는 웹 관리자, 서버 개발자 및 프론트 엔드 개발자를위한 것입니다. 최신 브라우저는 헤더 및 정책 시행을 포함하여 교차 출처 공유의 클라이언트 측 구성 요소를 처리합니다. 그러나이 새로운 표준은 서버가 새로운 요청 및 응답 헤더를 처리해야 함을 의미합니다. &lt;a href=&quot;server-side_access_control&quot;&gt;서버 관점에서 (PHP 코드 스 니펫을 사용하여) 교차 출처 공유를&lt;/a&gt; 논의하는 서버 개발자를위한 또 다른 기사 는 보충 자료입니다.</target>
        </trans-unit>
        <trans-unit id="4d672ad094374129b7ac45aa56021f772e22d674" translate="yes" xml:space="preserve">
          <source>More than 15 years of extensions</source>
          <target state="translated">15 년 이상의 연장</target>
        </trans-unit>
        <trans-unit id="93defa8d9384e526ec8c563df8553e7f68474a93" translate="yes" xml:space="preserve">
          <source>More than one &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header was sent by the server. This isn't allowed.</source>
          <target state="translated">서버에서 둘 이상의 &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더를 보냈습니다. 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1be543deb68df132d0c179bafbe0c9f9d5ae66cd" translate="yes" xml:space="preserve">
          <source>Most HTTP header field values are defined using common syntax
   components (token, quoted-string, and comment) separated by
   whitespace or specific delimiting characters.  Delimiters are chosen
   from the set of US-ASCII visual characters not allowed in a token
   (DQUOTE and &quot;(),/:;&amp;lt;=&amp;gt;?@[\]{}&quot;).

     token          = 1*tchar

     tchar          = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot;
                    / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot;
                    / DIGIT / ALPHA
                    ; any VCHAR, except delimiters

   A string of text is parsed as a single value if it is quoted using
   double-quote marks.

     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
     obs-text       = %x80-FF

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses.  Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.

     comment        = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text

   The backslash octet (&quot;\&quot;) can be used as a single-octet quoting
   mechanism within quoted-string and comment constructs.  Recipients
   that process the value of a quoted-string MUST handle a quoted-pair
   as if it were replaced by the octet following the backslash.

     quoted-pair    = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )

   A sender SHOULD NOT generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within
   that string.  A sender SHOULD NOT generate a quoted-pair in a comment
   except where necessary to quote parentheses [&quot;(&quot; and &quot;)&quot;] and
   backslash octets occurring within that comment.</source>
          <target state="translated">대부분의 HTTP 헤더 필드 값은 공백 또는 특정 구분 문자로 구분 된 공통 구문 구성 요소 (토큰, 따옴표로 묶은 문자열 및 주석)를 사용하여 정의됩니다. 구분 기호는 토큰에 허용되지 않는 US-ASCII 시각적 문자 세트 (DQUOTE 및 &quot;(), / :; &amp;lt;=&amp;gt;? @ [\] {}&quot;)에서 선택됩니다. token = 1 * tchar tchar = &quot;!&quot; / &quot;#&quot;/ &quot;$&quot;/ &quot;%&quot;/ &quot;&amp;amp;&quot;/ &quot; '&quot;/ &quot;*&quot;/ &quot;+&quot;/ &quot;-&quot;/ &quot;.&quot; / &quot;^&quot;/ &quot;_&quot;/ &quot;`&quot;/ &quot;|&quot; / &quot;~&quot;/ DIGIT / ALPHA; 구분자를 제외한 모든 VCHAR 큰 따옴표를 사용하여 따옴표로 묶인 텍스트 문자열은 단일 값으로 구문 분석됩니다.인용 문자열 = DQUOTE * (qdtext / quoted-pair) DQUOTE qdtext = HTAB / SP / % x21 / % x23-5B / % x5D-7E / obs-text obs-text = % x80-FF 주석은 일부에 포함될 수 있습니다 주석 텍스트를 괄호로 묶어 HTTP 헤더 필드 주석은 필드 값 정의의 일부로 &quot;comment&quot;를 포함하는 필드에서만 허용됩니다. comment = &quot;(&quot;* (ctext / quoted-pair / comment) &quot;)&quot;ctext = HTAB / SP / % x21-27 / % x2A-5B / % x5D-7E / obs-text 백 슬래시 옥텟 ( &quot;\&quot;) 인용 문자열 및 주석 구성 내에서 단일 옥텟 인용 메커니즘으로 사용할 수 있습니다. 인용 문자열 값을 처리하는 수신자는 인용 쌍을 백 슬래시 다음의 8 진수로 대체 한 것처럼 처리해야합니다. 인용 쌍 = &quot;\ &quot;(HTAB / SP / VCHAR / obs-text) 발신자는 문자열 내에서 발생하는 DQUOTE 및 백 슬래시 옥텟을 인용 할 필요가있는 경우를 제외하고 인용 문자열에서 인용 쌍을 생성하지 않아야합니다. 발신자는 인용 쌍을 생성해서는 안됩니다 (SHOULD NOT). 주석 내에서 괄호 [ &quot;(&quot;및 &quot;)&quot;]와 백 슬래시 옥텟을 인용해야하는 경우를 제외하고 주석 내에서.</target>
        </trans-unit>
        <trans-unit id="812bdf18b5a605c99457c43782814e036fcbedcf" translate="yes" xml:space="preserve">
          <source>Most HTTP responses include an entity which contains information for
   interpretation by a human user. Naturally, it is desirable to supply
   the user with the &quot;best available&quot; entity corresponding to the
   request. Unfortunately for servers and caches, not all users have the
   same preferences for what is &quot;best,&quot; and not all user agents are
   equally capable of rendering all entity types. For that reason, HTTP
   has provisions for several mechanisms for &quot;content negotiation&quot; --
   the process of selecting the best representation for a given response
   when there are multiple representations available.

      Note: This is not called &quot;format negotiation&quot; because the
      alternate representations may be of the same media type, but use
      different capabilities of that type, be in different languages,
      etc. 

   Any response containing an entity-body MAY be subject to negotiation,
   including error responses.

   There are two kinds of content negotiation which are possible in
   HTTP: server-driven and agent-driven negotiation. These two kinds of
   negotiation are orthogonal and thus may be used separately or in
   combination. One method of combination, referred to as transparent
   negotiation, occurs when a cache uses the agent-driven negotiation
   information provided by the origin server in order to provide
   server-driven negotiation for subsequent requests.</source>
          <target state="translated">대부분의 HTTP 응답에는 사용자가 해석하기위한 정보가 포함 된 엔티티가 포함됩니다. 당연히, 요청에 대응하는 &quot;최고 이용 가능한&quot;엔티티를 사용자에게 제공하는 것이 바람직하다. 불행히도 서버와 캐시의 경우 모든 사용자가 &quot;최고&quot;에 대해 동일한 환경 설정을 갖는 것은 아니며 모든 사용자 에이전트가 모든 엔티티 유형을 동일하게 렌더링 할 수있는 것은 아닙니다. 이러한 이유로 HTTP에는 &quot;컨텐츠 협상&quot;을위한 여러 가지 메커니즘 (제공되는 여러 표현이있을 때 주어진 응답에 대한 최상의 표현을 선택하는 프로세스)이 있습니다. 참고 : 대체 표현은 동일한 미디어 유형일 수 있지만 해당 유형의 다른 기능을 사용하기 때문에 &quot;형식 협상&quot;이라고하지 않습니다.엔티티 본문을 포함하는 모든 응답은 오류 응답을 포함하여 협상 될 수 있습니다. HTTP에서 가능한 두 가지 종류의 컨텐츠 협상이 있습니다 : 서버 중심 및 에이전트 중심 협상. 이 두 종류의 협상은 직교이므로 따로 또는 조합하여 사용할 수 있습니다. 투명 협상이라고하는 한 가지 조합 방법은 캐시가 후속 요청에 대한 서버 구동 협상을 제공하기 위해 오리진 서버가 제공 한 에이전트 중심 협상 정보를 사용할 때 발생합니다.이 두 종류의 협상은 직교이므로 따로 또는 조합하여 사용할 수 있습니다. 투명 협상이라고하는 한 가지 조합 방법은 캐시가 후속 요청에 대한 서버 구동 협상을 제공하기 위해 오리진 서버가 제공 한 에이전트 중심 협상 정보를 사용할 때 발생합니다.이 두 종류의 협상은 직교이므로 따로 또는 조합하여 사용할 수 있습니다. 투명 협상이라고하는 한 가지 조합 방법은 캐시가 후속 요청에 대한 서버 구동 협상을 제공하기 위해 오리진 서버가 제공 한 에이전트 중심 협상 정보를 사용할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7460036b5d618f72b9d5e87b1f21806669419e9d" translate="yes" xml:space="preserve">
          <source>Most browsers set the name and version in the format &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt;, with the notable exception of Internet Explorer. But as the name is not the only information in a user agent string that is in that format, you can not discover the name of the browser, you can only check if the name you are looking for. But note that some browsers are lying: Chrome for example reports both as Chrome and Safari. So to detect Safari you have to check for the Safari string and the absence of the Chrome string, Chromium often reports itself as Chrome too or Seamonkey sometimes reports itself as Firefox.</source>
          <target state="translated">대부분의 브라우저 는 Internet Explorer를 제외하고 &lt;em&gt;BrowserName / VersionNumber&lt;/em&gt; 형식으로 이름과 버전을 설정합니다 . 그러나 이름은 해당 형식의 사용자 에이전트 문자열에있는 유일한 정보가 아니므로 브라우저 이름을 찾을 수 없으며 찾고있는 이름 만 확인할 수 있습니다. 그러나 일부 브라우저는 거짓말을하고 있습니다. 예를 들어 Chrome은 Chrome과 Safari로보고합니다. 따라서 Safari를 감지하려면 Safari 문자열과 Chrome 문자열이 없는지 확인해야합니다. Chromium은 종종 자체를 Chrome으로보고하거나 Seamonkey가 자체적으로 Firefox로보고합니다.</target>
        </trans-unit>
        <trans-unit id="02c0fa975a9a4f1c1a39487a5147f2636b69eb9e" translate="yes" xml:space="preserve">
          <source>Most of the standard JavaScript functionality is available for use in the FindProxyForURL() function. As an example, to set different proxies based on the protocol the substring() function can be used:</source>
          <target state="translated">대부분의 표준 JavaScript 기능은 FindProxyForURL () 함수에서 사용할 수 있습니다. 예를 들어, 프로토콜을 기반으로 다른 프록시를 설정하기 위해 substring () 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92624466818eb51fd53a17208603205adea7766c" translate="yes" xml:space="preserve">
          <source>Most of the time identity and location of a Web resource are shared, this can be changed with the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">웹 리소스의 ID와 위치는 대부분 공유되며 &lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b365dcd7a6f5dfd969c8f5a85717b49e744e8f9" translate="yes" xml:space="preserve">
          <source>Most of the time this is a server problem, and if the server cannot detect it, it will send back a &lt;a href=&quot;status/500&quot;&gt;&lt;code&gt;500&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Internal Server Error&lt;/code&gt;. If you encounter such an error soon after modifying a server configuration, this is likely a redirection loop.</source>
          <target state="translated">대부분의 경우 이는 서버 문제점이며 서버가이를 감지 할 수없는 경우 &lt;a href=&quot;status/500&quot;&gt; &lt;code&gt;500&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Internal Server Error&lt;/code&gt; 다시 보냅니다 . 서버 구성을 수정 한 직후에 이러한 오류가 발생하면 리디렉션 루프 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd93e26ede2192a4f8e353e3bbf7ab476b541a23" translate="yes" xml:space="preserve">
          <source>Most rendering engines put the version number in the &lt;em&gt;RenderingEngine/VersionNumber&lt;/em&gt; token, with the notable exception of Gecko. Gecko puts the Gecko version number in the comment part of the User Agent after the &lt;code&gt;rv:&lt;/code&gt; string. From Gecko 14 for the mobile version and Gecko 17 for the desktop version, it also puts this value in the &lt;code&gt;Gecko/version&lt;/code&gt; token (previous version put there the build date, then a fixed date called the GeckoTrail).</source>
          <target state="translated">대부분의 렌더링 엔진 은 Gecko를 제외 하고 &lt;em&gt;RenderingEngine / VersionNumber&lt;/em&gt; 토큰 에 버전 번호를 넣습니다 . Gecko는 &lt;code&gt;rv:&lt;/code&gt; 문자열 다음에 사용자 에이전트의 주석 부분에 Gecko 버전 번호를 넣습니다 . 모바일 버전의 Gecko 14와 데스크톱 버전의 Gecko 17에서이 값을 &lt;code&gt;Gecko/version&lt;/code&gt; 토큰에 넣습니다 (이전 버전에는 빌드 날짜를 입력 한 다음 GeckoTrail이라는 고정 날짜를 입력).</target>
        </trans-unit>
        <trans-unit id="c37f0d1445fedf718be400753c3dbf6a2412f759" translate="yes" xml:space="preserve">
          <source>Most web servers send unrecognized resources as the &lt;code&gt;application/octet-stream&lt;/code&gt; MIME type. For security reasons, most browsers do not allow setting a custom default action for such resources, forcing the user to save it to disk to use it.</source>
          <target state="translated">대부분의 웹 서버는 인식 할 수없는 리소스를 &lt;code&gt;application/octet-stream&lt;/code&gt; MIME 유형 으로 보냅니다 . 보안상의 이유로 대부분의 브라우저는 이러한 리소스에 대한 사용자 지정 기본 작업을 설정하도록 허용하지 않으므로 사용자가이를 사용하기 위해 디스크에 저장하도록합니다.</target>
        </trans-unit>
        <trans-unit id="6a8946eed2c78e3706e8f2276333fa60dc5390eb" translate="yes" xml:space="preserve">
          <source>Moving to a different domain. For example, your company has been renamed and you when searching for the old name, you want people used to the old company Web site still find you under the new name.</source>
          <target state="translated">다른 도메인으로 이동 예를 들어, 회사 이름이 바뀌었고 이전 이름을 검색 할 때 이전 회사 웹 사이트에 익숙한 사람들이 여전히 새 이름 아래에서 나를 찾도록하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0ef3be393a351dfa2ef963cfdc34f9e6563cc892" translate="yes" xml:space="preserve">
          <source>Mozilla (Gecko, Firefox)</source>
          <target state="translated">모질라 (Gecko, Firefox)</target>
        </trans-unit>
        <trans-unit id="a0934075575145263129d33cbbd963bcda3860f4" translate="yes" xml:space="preserve">
          <source>Mozilla Observatory</source>
          <target state="translated">모질라 전망대</target>
        </trans-unit>
        <trans-unit id="decab94514e261dda8ed0ab5f5a50868157343e3" translate="yes" xml:space="preserve">
          <source>Mozilla web security guidelines</source>
          <target state="translated">Mozilla 웹 보안 지침</target>
        </trans-unit>
        <trans-unit id="0fee1a221e5d621522c4cae25d2d3f0781412c73" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Mobile; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla / 5.0 (Android 4.4; 모바일; rv : 41.0) Gecko / 41.0 Firefox / 41.0</target>
        </trans-unit>
        <trans-unit id="06ca2e8b107ebc3017f1b6838abe49d90a2337b1" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 4.4; Tablet; rv:41.0) Gecko/41.0 Firefox/41.0</source>
          <target state="translated">Mozilla / 5.0 (Android 4.4; 태블릿; rv : 41.0) Gecko / 41.0 Firefox / 41.0</target>
        </trans-unit>
        <trans-unit id="12388f0ea73a7de9d571898b4be2154ce15cb9f4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android 7.0; Mobile; rv:62.0) Gecko/62.0 Firefox/62.0</source>
          <target state="translated">Mozilla / 5.0 (Android 7.0; 모바일; rv : 62.0) Gecko / 62.0 Firefox / 62.0</target>
        </trans-unit>
        <trans-unit id="adf944b54ec9b6df9ba954b5789e4f037d57ad12" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:13.0) Gecko/13.0 Firefox/13.0</source>
          <target state="translated">Mozilla / 5.0 (Android; 모바일; rv : 13.0) Gecko / 13.0 Firefox / 13.0</target>
        </trans-unit>
        <trans-unit id="4d33bd8f87ba06abe4fe1c0b9f3fd3d4ef39a64b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla / 5.0 (Android; 모바일; rv : 40.0) Gecko / 40.0 Firefox / 40.0</target>
        </trans-unit>
        <trans-unit id="b1165e7e7925427d068dfe4278ee0a0ab81d03a6" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Android; Tablet; rv:40.0) Gecko/40.0 Firefox/40.0</source>
          <target state="translated">Mozilla / 5.0 (Android; 태블릿; rv : 40.0) Gecko / 40.0 Firefox / 40.0</target>
        </trans-unit>
        <trans-unit id="1eff4492cf201da272b181a0826abf69087bdbae" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 4.4.2); Nexus 5 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 4.4.2); Nexus 5 Build / KOT49H) AppleWebKit / 537.36 (Gcko와 같은 KHTML) Chrome / 33.0.1750.117 모바일 Safari / 537.36 OPR / 20.0.1396.72047</target>
        </trans-unit>
        <trans-unit id="187263e2548b4eea2d8d1b7718d1e58bc486ee8f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 5.1.1) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.1 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux, Android 5.1.1) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Focus / 1.1 Chrome / 59.0.3017.125 Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="f069d17af594e5cc6ceb8bcf6da674fc68ec9615" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 7.0) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Focus / 1.0 Chrome / 59.0.3029.83 Mobile Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="5cdca6439d9f4f75159a9c3f7e09c52e695e1e6d" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/1.0 Chrome/59.0.3029.83 Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 7.0) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Focus / 1.0 Chrome / 59.0.3029.83 Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="d3772cfc2095a71baa2d031dbccc5f42fe0a9faa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/4.1 Chrome/62.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 7.0) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Focus / 4.1 Chrome / 62.0.3029.83 Mobile Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="5c9a7c5212d961b33810bd5d24bd5d65d22acc7b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.0) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Klar/1.0 Chrome/58.0.3029.83 Mobile Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 7.0) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Klar / 1.0 Chrome / 58.0.3029.83 모바일 Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="3ebf95e0e00b50d02895700858ee637ccce16aee" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; Android 7.1.2) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Focus/3.0 Chrome/59.0.3017.125 Safari/537.36</source>
          <target state="translated">Mozilla / 5.0 (Linux; Android 7.1.2) AppleWebKit / 537.36 (Gcko와 같은 KHTML) 버전 /4.0 Focus / 3.0 Chrome / 59.0.3017.125 Safari / 537.36</target>
        </trans-unit>
        <trans-unit id="2107ee483b37620cd27469a83622677f75ba74e7" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Linux; U; Android 4.0.3; de-ch; HTC Sensation Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</source>
          <target state="translated">Mozilla / 5.0 (Linux; U; Android 4.0.3; de-ch; HTC Sensation Build / IML74K) AppleWebKit / 534.30 (Gcko와 같은 KHTML) 버전 /4.0 모바일 Safari / 534.30</target>
        </trans-unit>
        <trans-unit id="b1d3f926e92bfa21fd4b0d0fe771e000d5d2b871" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla / 5.0 (Macintosh; Intel Mac OS X 10.5; rv : 10.0.1) Gecko / 20100101 Firefox / 10.0.1 SeaMonkey / 2.7.1</target>
        </trans-unit>
        <trans-unit id="6d87ab26fc3278b385f67646186cafe62f1226c0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; rv:2.0.1) Gecko/20100101 Firefox/4.0.1 Camino/2.2.1</source>
          <target state="translated">Mozilla / 5.0 (Macintosh; Intel Mac OS X 10.5; rv : 2.0.1) Gecko / 20100101 Firefox / 4.0.1 Camino / 2.2.1</target>
        </trans-unit>
        <trans-unit id="08a47789f901ac4697d74b3d7f335103a2d1b4b2" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; Intel Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (Macintosh; Intel Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="92e71ac1941b70b8a195b2038b988eb15e2633cf" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Macintosh; PPC Mac OS X &lt;em&gt;x.y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (Macintosh; PPC Mac OS X &lt;em&gt;xy&lt;/em&gt; ; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="49a7b83668313b9e1281eda63779e0047234a704" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0) Gecko/20100101 Firefox/10.0 Fennec/10.0</source>
          <target state="translated">Mozilla / 5.0 (Maemo; Linux armv7l; rv : 10.0) Gecko / 20100101 Firefox / 10.0 Fennec / 10.0</target>
        </trans-unit>
        <trans-unit id="4912bc7f8d14158acb5958155825887af72f69e0" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Maemo; Linux armv7l; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1</source>
          <target state="translated">Mozilla / 5.0 (Maemo; Linux armv7l; rv : 10.0.1) Gecko / 20100101 Firefox / 10.0.1 Fennec / 10.0.1</target>
        </trans-unit>
        <trans-unit id="24d7bfb4e448eb6a6f2b2c05f9ccace8303e7951" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla / 5.0 (모바일; &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; rv : 26.0) Gecko / 26.0 Firefox / 26.0</target>
        </trans-unit>
        <trans-unit id="fe824479059b41314b08fccf6ffd2df216b210a4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Mobile; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla / 5.0 (모바일; rv : 26.0) Gecko / 26.0 Firefox / 26.0</target>
        </trans-unit>
        <trans-unit id="1e65d98e39260d268ec140c75dfc14eb88fe1d22" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (TV; rv:44.0) Gecko/44.0 Firefox/44.0</source>
          <target state="translated">Mozilla / 5.0 (TV; rv : 44.0) Gecko / 44.0 Firefox / 44.0</target>
        </trans-unit>
        <trans-unit id="1b0c7be81a38400e6eab6ae6602316f1c9727b89" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Tablet; rv:26.0) Gecko/26.0 Firefox/26.0</source>
          <target state="translated">Mozilla / 5.0 (태블릿; rv : 26.0) Gecko / 26.0 Firefox / 26.0</target>
        </trans-unit>
        <trans-unit id="d5494fe16df11ab5f5d2c945da5478c2861a6327" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT 5.2; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla / 5.0 (Windows NT 5.2; rv : 10.0.1) Gecko / 20100101 Firefox / 10.0.1 SeaMonkey / 2.7.1</target>
        </trans-unit>
        <trans-unit id="c103c7575720327d828e07fcd68a2f214656eb84" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; WOW64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (Windows NT &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;y&lt;/em&gt; ; WOW64; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="e357311b1eddbb286305456c0cae57cb232b5c1f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; Win64; x64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">모질라 / 5.0 (Windows NT는 &lt;em&gt;X&lt;/em&gt; . &lt;em&gt;Y&lt;/em&gt; ; Win64를, 64 장, 10.0) 게코 / 20100101 파이어 폭스 / 10.0</target>
        </trans-unit>
        <trans-unit id="325bb5b76845bcf2d6d17880f0df8de3120fa91b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (Windows NT &lt;em&gt;x&lt;/em&gt;.&lt;em&gt;y&lt;/em&gt;; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (Windows NT &lt;em&gt;x&lt;/em&gt; . &lt;em&gt;y&lt;/em&gt; ; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="5530c08605b863c3ac834dac7f9e551adfc1e552" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686 on x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (X11; x86_64의 Linux i686; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="b117257c04f02d34e73001cfc8d0da1abaac01f8" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (X11; Linux i686; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="fa04af9816f0793fdc1a867eef08c9bba4602d70" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux i686; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1</source>
          <target state="translated">Mozilla / 5.0 (X11; Linux i686; rv : 10.0.1) Gecko / 20100101 Firefox / 10.0.1 SeaMonkey / 2.7.1</target>
        </trans-unit>
        <trans-unit id="3d160a2e76c2d144bd854abad33abe579e0d1e79" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0</source>
          <target state="translated">Mozilla / 5.0 (X11; Linux x86_64; rv : 10.0) Gecko / 20100101 Firefox / 10.0</target>
        </trans-unit>
        <trans-unit id="709cd7ecb895ccc0d811c9b3e76ade66b0e1f3aa" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)</source>
          <target state="translated">Mozilla / 5.0 (호환 가능; MSIE 9.0; Windows Phone OS 7.5; Trident / 5.0; IEMobile / 9.0)</target>
        </trans-unit>
        <trans-unit id="eb659b396a68f6ea514ab25964c9404e2397367b" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPad; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0 (iPad, Mac OS X와 ​​같은 CPU iPhone OS 8_3) AppleWebKit / 600.1.4 (Gcko와 같은 KHTML) &lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="4e72c500d652c15de7cda1433b6379f4dfd1c6c4" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0 (iPhone, Mac OS X와 ​​같은 CPU iPhone OS 8_3) AppleWebKit / 600.1.4 (Gcko와 같은 KHTML) &lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="f8a8856f3bffbe976e558e919bc886558bcab84f" translate="yes" xml:space="preserve">
          <source>Mozilla/5.0 (iPod touch; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) &lt;strong&gt;FxiOS/1.0&lt;/strong&gt; Mobile/12F69 Safari/600.1.4</source>
          <target state="translated">Mozilla / 5.0 (iPod touch, Mac OS X와 ​​같은 CPU iPhone OS 8_3) AppleWebKit / 600.1.4 (Gcko와 같은 KHTML) &lt;strong&gt;FxiOS / 1.0&lt;/strong&gt; Mobile / 12F69 Safari / 600.1.4</target>
        </trans-unit>
        <trans-unit id="6c18301fd3a10882deaa39ee10288f7f929f1e77" translate="yes" xml:space="preserve">
          <source>Multipart ranges</source>
          <target state="translated">멀티 파트 범위</target>
        </trans-unit>
        <trans-unit id="6492593dec5dae0d0f4611760da5545108ace9bb" translate="yes" xml:space="preserve">
          <source>Multipart types</source>
          <target state="translated">멀티 파트 유형</target>
        </trans-unit>
        <trans-unit id="d39efeff869bd677fa96ec0c45b55ce64ce505cd" translate="yes" xml:space="preserve">
          <source>Multiple content security policies</source>
          <target state="translated">여러 콘텐츠 보안 정책</target>
        </trans-unit>
        <trans-unit id="313424e8960d9a8154e0f8c4d03334fd46afad67" translate="yes" xml:space="preserve">
          <source>Multiple headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdca688fc4125e8ff0c8017144fee0ab18afe32f" translate="yes" xml:space="preserve">
          <source>Multiple language tags are separated by comma. Each language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character (&quot;&lt;code&gt;-&lt;/code&gt;&quot;, &lt;code&gt;%x2D&lt;/code&gt;). In most cases, a language tag consists of a primary language subtag that identifies a broad family of related languages (e.g., &quot;&lt;code&gt;en&lt;/code&gt;&quot; = English), which is optionally followed by a series of subtags that refine or narrow that language's range (e.g., &quot;&lt;code&gt;en-CA&lt;/code&gt;&quot; = the variety of English as communicated in Canada).</source>
          <target state="translated">여러 언어 태그는 쉼표로 구분됩니다. 각 언어 태그는 대소 문자를 구분하지 않는 하나 이상의 하위 태그 시퀀스로, 하이픈 문자 ( &quot; &lt;code&gt;-&lt;/code&gt; &quot;, &lt;code&gt;%x2D&lt;/code&gt; )로 구분됩니다. 대부분의 경우 언어 태그는 광범위한 관련 언어 (예 : &quot; &lt;code&gt;en&lt;/code&gt; &quot;= English) 를 식별하는 기본 언어 하위 태그로 구성되며 , 선택적으로 해당 언어의 범위를 세분화하거나 좁히는 일련의 하위 태그 (예 : &quot; &lt;code&gt;en-CA&lt;/code&gt; &quot;= 캐나다에서 의사 소통되는 다양한 영어).</target>
        </trans-unit>
        <trans-unit id="b290c69355489b91460f7513bfaca4d5713cfa85" translate="yes" xml:space="preserve">
          <source>Musical Instrument Digital Interface (MIDI)</source>
          <target state="translated">악기 디지털 인터페이스 (MIDI)</target>
        </trans-unit>
        <trans-unit id="38d7a0163e1ee433772d04a8bfb66c70abef1a41" translate="yes" xml:space="preserve">
          <source>Must contain</source>
          <target state="translated">포함해야합니다</target>
        </trans-unit>
        <trans-unit id="7eb2625cecaa68b91f751ad2fe9dc1b532d0b9b2" translate="yes" xml:space="preserve">
          <source>Must not contain</source>
          <target state="translated">포함해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="7fba45dc69034264a59f6cf73b586c39dab3f873" translate="yes" xml:space="preserve">
          <source>Name/alias of an internal proxy.</source>
          <target state="translated">내부 프록시의 이름 / 별칭</target>
        </trans-unit>
        <trans-unit id="fc0e8280e5c94d0883853c5c4b17f81c3e799bdf" translate="yes" xml:space="preserve">
          <source>Name:   activelock

   Purpose:   Describes a lock on a resource.


   &amp;lt;!ELEMENT activelock (lockscope, locktype, depth, owner?, timeout?,
             locktoken?, lockroot)&amp;gt;</source>
          <target state="translated">이름 : activelock 목적 : 자원에 대한 잠금을 설명합니다. &amp;lt;! ELEMENT activelock (lockscope, locktype, depth, owner ?, timeout ?, locktoken ?, lockroot)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7309308604381e0eab9cfba61516e4469cbce658" translate="yes" xml:space="preserve">
          <source>Name:   allprop

   Purpose:   Specifies that all names and values of dead properties and
      the live properties defined by this document existing on the
      resource are to be returned.

   &amp;lt;!ELEMENT allprop EMPTY &amp;gt;</source>
          <target state="translated">이름 : allprop 목적 : 자원에 존재하는이 문서에 의해 정의 된 사용 불능 특성 및 활성 특성의 모든 이름과 값이 리턴되도록 지정합니다. &amp;lt;! ELEMENT allprop EMPTY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1ba1c5dfdf3f6b036dcf6b3dcedf50ec6b5d7aa0" translate="yes" xml:space="preserve">
          <source>Name:   collection

   Purpose:   Identifies the associated resource as a collection.  The
      DAV:resourcetype property of a collection resource MUST contain
      this element.  It is normally empty but extensions may add sub-
      elements.

   &amp;lt;!ELEMENT collection EMPTY &amp;gt;</source>
          <target state="translated">이름 : 모음 목적 : 관련 리소스를 모음으로 식별합니다. 컬렉션 리소스의 DAV : resourcetype 속성은이 요소를 포함해야합니다. 일반적으로 비어 있지만 확장은 하위 요소를 추가 할 수 있습니다. &amp;lt;! 요소 컬렉션 빈&amp;gt;</target>
        </trans-unit>
        <trans-unit id="87181b0cf2e6abfd8e3d27cf6a43721cccb1a786" translate="yes" xml:space="preserve">
          <source>Name:   creationdate

   Purpose:   Records the time and date the resource was created.

   Value:   date-time (defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt;], see the ABNF in &lt;a href=&quot;#section-5.6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt;.)

   Protected:   MAY be protected.  Some servers allow DAV:creationdate
      to be changed to reflect the time the document was created if that
      is more meaningful to the user (rather than the time it was
      uploaded).  Thus, clients SHOULD NOT use this property in
      synchronization logic (use DAV:getetag instead).

   COPY/MOVE behavior:   This property value SHOULD be kept during a
      MOVE operation, but is normally re-initialized when a resource is
      created with a COPY.  It should not be set in a COPY. 

   Description:   The DAV:creationdate property SHOULD be defined on all
      DAV compliant resources.  If present, it contains a timestamp of
      the moment when the resource was created.  Servers that are
      incapable of persistently recording the creation date SHOULD
      instead leave it undefined (i.e. report &quot;Not Found&quot;).

   &amp;lt;!ELEMENT creationdate (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : creationdate 목적 : 리소스가 만들어진 시간과 날짜를 기록합니다. 값 : 날짜-시간 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC3339&lt;/a&gt; ]에 정의되어 있으며 &lt;a href=&quot;#section-5.6&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt; 의 ABNF 참조.) 보호 : 보호 될 수 있습니다. 일부 서버에서는 DAV : creationdate를 변경하여 사용자에게보다 의미있는 경우 (업로드 된 시간이 아닌) 문서가 작성된 시간을 반영 할 수 있습니다. 따라서 클라이언트는 동기화 논리에서이 속성을 사용하지 않아야합니다 (대신 DAV : getetag 사용). COPY / MOVE 동작 :이 속성 값은 MOVE 작업 중에 유지해야하지만 일반적으로 COPY로 리소스를 만들 때 다시 초기화됩니다. COPY에 설정해서는 안됩니다. 설명 : DAV : creationdate 속성은 모든 DAV 호환 리소스에 정의해야합니다. 존재하는 경우 리소스가 생성 된 순간의 타임 스탬프가 포함됩니다. 작성 날짜를 지속적으로 기록 할 수없는 서버는 대신 정의되지 않은 상태로 두어야합니다 (예 :&quot;찾을 수 없음&quot;으로보고). &amp;lt;! ELEMENT 생성 일 (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5001a824af50b50969330b6c455279fcb16d4902" translate="yes" xml:space="preserve">
          <source>Name:   depth

   Purpose:   Used for representing depth values in XML content (e.g.,
      in lock information).

   Value:   &quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;

   &amp;lt;!ELEMENT depth (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : 깊이 용도 : XML 내용 (예 : 잠금 정보)의 깊이 값을 나타내는 데 사용됩니다. 값 : &quot;0&quot;| &quot;1&quot;| &quot;무한대&quot;&amp;lt;! 요소 깊이 (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7e7ea482bed86ee2dc49b17649f3cd7cddfe06a" translate="yes" xml:space="preserve">
          <source>Name:   displayname

   Purpose:   Provides a name for the resource that is suitable for
      presentation to a user.

   Value:   Any text.

   Protected:   SHOULD NOT be protected.  Note that servers implementing
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have made this a protected property as this is a
      new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   Contains a description of the resource that is
      suitable for presentation to a user.  This property is defined on
      the resource, and hence SHOULD have the same value independent of
      the Request-URI used to retrieve it (thus, computing this property
      based on the Request-URI is deprecated).  While generic clients
      might display the property value to end users, client UI designers
      must understand that the method for identifying resources is still
      the URL.  Changes to DAV:displayname do not issue moves or copies
      to the server, but simply change a piece of meta-data on the
      individual resource.  Two resources can have the same DAV:
      displayname value even within the same collection.

   &amp;lt;!ELEMENT displayname (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : 표시 이름 목적 : 사용자에게 표시하기에 적합한 리소스 이름을 제공합니다. 값 : 모든 텍스트 보호 : 보호해서는 안됩니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518을&lt;/a&gt; 구현하는 서버]은 새로운 요구 사항이므로이 속성을 보호 된 속성으로 만들었을 수 있습니다. COPY / MOVE 동작 :이 속성 값은 COPY 및 MOVE 작업에서 유지되어야합니다. 설명 : 사용자에게 프리젠 테이션하기에 적합한 자원에 대한 설명을 포함합니다. 이 속성은 리소스에 정의되어 있으므로이를 검색하는 데 사용 된 Request-URI와 독립적으로 동일한 값을 가져야합니다 (따라서 Request-URI를 기반으로이 속성을 계산하는 것은 더 이상 사용되지 않습니다). 일반 클라이언트는 일반 사용자에게 속성 값을 표시 할 수 있지만 클라이언트 UI 디자이너는 리소스를 식별하는 방법이 여전히 URL임을 이해해야합니다. DAV : displayname을 변경해도 서버로 이동하거나 복사하지 않고 개별 자원의 메타 데이터를 변경하기 만하면됩니다.두 개의 자원이 동일한 DAV를 가질 수 있습니다. 동일한 콜렉션 내에서도 표시 이름 값입니다. &amp;lt;! ELEMENT 표시 이름 (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="908d0146c1dea86489e704e923e0d7a5ee16a7b9" translate="yes" xml:space="preserve">
          <source>Name:   error

   Purpose:   Error responses, particularly 403 Forbidden and 409
      Conflict, sometimes need more information to indicate what went
      wrong.  In these cases, servers MAY return an XML response body
      with a document element of 'error', containing child elements
      identifying particular condition codes.

   Description:   Contains at least one XML element, and MUST NOT
      contain text or mixed content.  Any element that is a child of the
      'error' element is considered to be a precondition or
      postcondition code.  Unrecognized elements MUST be ignored.

   &amp;lt;!ELEMENT error ANY &amp;gt;</source>
          <target state="translated">이름 : 오류 목적 : 오류 응답, 특히 403 Forbidden 및 409 Conflict는 때때로 무엇이 잘못되었는지 나타내는 추가 정보가 필요합니다. 이 경우 서버는 특정 조건 코드를 식별하는 하위 요소를 포함하는 문서 요소가 'error'인 XML 응답 본문을 반환 할 수 있습니다. 설명 : 하나 이상의 XML 요소를 포함하며 텍스트 또는 혼합 컨텐츠를 포함해서는 안됩니다. 'error'요소의 하위 요소 인 모든 요소는 사전 조건 또는 사후 조건 코드로 간주됩니다. 인식 할 수없는 요소는 무시해야합니다. &amp;lt;! ELEMENT 오류 ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2f1ac95ad14a19297b93321befb3877e2c61a0da" translate="yes" xml:space="preserve">
          <source>Name:   exclusive

   Purpose:   Specifies an exclusive lock.


   &amp;lt;!ELEMENT exclusive EMPTY &amp;gt;</source>
          <target state="translated">이름 : 독점 목적 : 독점 잠금을 지정합니다. &amp;lt;! 요소 독점 비우기&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1139af3688a412e172379a1792bf370d7f0f7b0c" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlanguage

   Purpose:   Contains the Content-Language header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;14.12 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without
      accept headers.

   Value:   language-tag (language-tag is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;Section&amp;nbsp;3.10 of
      [RFC2616]&lt;/a&gt;) 

   Protected:   SHOULD NOT be protected, so that clients can reset the
      language.  Note that servers implementing [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] might have
      made this a protected property as this is a new requirement.

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   The DAV:getcontentlanguage property MUST be defined on
      any DAV-compliant resource that returns the Content-Language
      header on a GET.

   &amp;lt;!ELEMENT getcontentlanguage (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : getcontentlanguage 목적 : Accept 헤더없이 GET에 의해 리턴되는 Content-Language 헤더 값 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;[RFC2616]의 14.12 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.12&quot;&gt;섹션 참조&lt;/a&gt; )을 포함합니다. 값 : 언어 태그 (언어 태그는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.10&quot;&gt;[RFC2616]의 섹션 3.10에&lt;/a&gt; 정의되어 있음 ) 보호됨 : 클라이언트가 언어를 재설정 할 수 있도록 보호해서는 안됩니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518을&lt;/a&gt; 구현하는 서버]은 새로운 요구 사항이므로이 속성을 보호 된 속성으로 만들었을 수 있습니다. COPY / MOVE 동작 :이 속성 값은 COPY 및 MOVE 작업에서 유지되어야합니다. 설명 : DAV : getcontentlanguage 속성은 GET의 Content-Language 헤더를 반환하는 DAV 호환 리소스에서 정의해야합니다. &amp;lt;! ELEMENT getcontentlanguage (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="741fdc043a5b70d84410dff935be0a476ea27e62" translate="yes" xml:space="preserve">
          <source>Name:   getcontentlength

   Purpose:   Contains the Content-Length header returned by a GET
      without accept headers.

   Value:   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;Section&amp;nbsp;14.13 of [RFC2616]&lt;/a&gt;.

   Protected:   This property is computed, therefore protected.

   Description:   The DAV:getcontentlength property MUST be defined on
      any DAV-compliant resource that returns the Content-Length header
      in response to a GET.

   COPY/MOVE behavior:   This property value is dependent on the size of
      the destination resource, not the value of the property on the
      source resource.

   &amp;lt;!ELEMENT getcontentlength (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : getcontentlength 목적 : 승인 헤더없이 GET에서 반환 한 Content-Length 헤더가 들어 있습니다. 값 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.13&quot;&gt;[RFC2616]의 섹션 14.13을&lt;/a&gt; 참조하십시오 . 보호됨 :이 속성은 계산되어 보호됩니다. 설명 : DAV : getcontentlength 속성은 GET에 대한 응답으로 Content-Length 헤더를 반환하는 DAV 호환 리소스에서 정의해야합니다. COPY / MOVE 동작 :이 속성 값은 원본 리소스의 속성 값이 아니라 대상 리소스의 크기에 따라 다릅니다. &amp;lt;! ELEMENT getcontentlength (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="55495eb7b11d239e680b68a767ce90c04bf9b3b4" translate="yes" xml:space="preserve">
          <source>Name:   getcontenttype

   Purpose:   Contains the Content-Type header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;Section&amp;nbsp;14.17
      of [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   media-type (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;Section&amp;nbsp;3.7 of [RFC2616]&lt;/a&gt;)

   Protected:   Potentially protected if the server prefers to assign
      content types on its own (see also discussion in &lt;a href=&quot;#section-9.7.1&quot;&gt;Section 9.7.1&lt;/a&gt;). 

   COPY/MOVE behavior:   This property value SHOULD be preserved in COPY
      and MOVE operations.

   Description:   This property MUST be defined on any DAV-compliant
      resource that returns the Content-Type header in response to a
      GET.

   &amp;lt;!ELEMENT getcontenttype (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : getcontenttype 목적 : Accept 헤더없이 GET에 의해 리턴되는 Content-Type 헤더 값 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.17&quot;&gt;[RFC2616]의 14.17 섹션 참조&lt;/a&gt; )을 포함합니다. 값 : 미디어 유형 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.7&quot;&gt;[RFC2616]의 3.7 절에&lt;/a&gt; 정의 됨 ) 보호됨 : 서버가 자체적으로 컨텐츠 유형을 할당하는 것을 선호하는 경우 잠재적으로 보호됩니다 ( &lt;a href=&quot;#section-9.7.1&quot;&gt;섹션 9.7.1의&lt;/a&gt; 설명 참조 ). COPY / MOVE 동작 :이 속성 값은 COPY 및 MOVE 작업에서 유지되어야합니다. 설명 :이 속성은 GET에 대한 응답으로 Content-Type 헤더를 반환하는 모든 DAV 호환 리소스에서 정의되어야합니다. &amp;lt;! ELEMENT getcontenttype (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1498b05efb25d9004f005f650420e0059a4a660f" translate="yes" xml:space="preserve">
          <source>Name:   getetag

   Purpose:   Contains the ETag header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;Section&amp;nbsp;14.19 of
      [RFC2616]&lt;/a&gt;) as it would be returned by a GET without accept
      headers.

   Value:   entity-tag (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;)

   Protected:  MUST be protected because this value is created and
      controlled by the server.

   COPY/MOVE behavior:   This property value is dependent on the final
      state of the destination resource, not the value of the property
      on the source resource.  Also note the considerations in
      &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The getetag property MUST be defined on any DAV-
      compliant resource that returns the Etag header.  Refer to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;3.11 of RFC 2616&lt;/a&gt; for a complete definition of the semantics of an
      ETag, and to &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt; for a discussion of ETags in WebDAV.

   &amp;lt;!ELEMENT getetag (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : getetag 목적 : 수락 헤더없이 GET에 의해 리턴 될 ETag 헤더 값 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.19&quot;&gt;[RFC2616]의 섹션 14.19&lt;/a&gt; )을 포함합니다. 값 : entity-tag ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]의 섹션 3.11에&lt;/a&gt; 정의 됨 ) 보호됨 :이 값은 서버에서 생성하고 제어하므로 반드시 보호해야합니다. COPY / MOVE 동작 :이 속성 값은 원본 리소스의 속성 값이 아니라 대상 리소스의 최종 상태에 따라 다릅니다. &lt;a href=&quot;#section-8.8&quot;&gt;섹션 8.8&lt;/a&gt; 의 고려 사항도 참고하십시오 . 설명 : getetag 속성은 Etag 헤더를 반환하는 DAV 호환 리소스에서 정의해야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;RFC 2616의 3.11 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;절을&lt;/a&gt; 참조하십시오.ETag의 시맨틱에 대한 완전한 정의는 WebDAV의 ETag에 대한 논의는 &lt;a href=&quot;#section-8.6&quot;&gt;섹션 8.6&lt;/a&gt; 을 참조하십시오. &amp;lt;! ELEMENT getetag (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="11ad3ec496de5f06b2c28a5d5dd7a81ca07caa74" translate="yes" xml:space="preserve">
          <source>Name:   getlastmodified

   Purpose:   Contains the Last-Modified header value (from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;14.29 of [RFC2616]&lt;/a&gt;) as it would be returned by a GET method
      without accept headers.

   Value:   &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC2616]&lt;/a&gt;)

   Protected:   SHOULD be protected because some clients may rely on the
      value for appropriate caching behavior, or on the value of the
      Last-Modified header to which this property is linked. 

   COPY/MOVE behavior:   This property value is dependent on the last
      modified date of the destination resource, not the value of the
      property on the source resource.  Note that some server
      implementations use the file system date modified value for the
      DAV:getlastmodified value, and this can be preserved in a MOVE
      even when the HTTP Last-Modified value SHOULD change.  Note that
      since [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] requires clients to use ETags where provided, a
      server implementing ETags can count on clients using a much better
      mechanism than modification dates for offline synchronization or
      cache control.  Also note the considerations in &lt;a href=&quot;#section-8.8&quot;&gt;Section 8.8&lt;/a&gt;.

   Description:   The last-modified date on a resource SHOULD only
      reflect changes in the body (the GET responses) of the resource.
      A change in a property only SHOULD NOT cause the last-modified
      date to change, because clients MAY rely on the last-modified date
      to know when to overwrite the existing body.  The DAV:
      getlastmodified property MUST be defined on any DAV-compliant
      resource that returns the Last-Modified header in response to a
      GET.

   &amp;lt;!ELEMENT getlastmodified (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : getlastmodified 목적 : Accept 헤더없이 GET 메소드에 의해 리턴되는 Last-Modified 헤더 값 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;[RFC2616]의 14.29 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.29&quot;&gt;섹션 참조&lt;/a&gt; )을 포함합니다. 값 : &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.3.1&quot;&gt;[RFC2616]의 3.3.1 절에&lt;/a&gt; 정의 됨 )) 보호됨 : 일부 클라이언트는 적절한 캐싱 동작에 대한 값 또는이 속성이 연결된 Last-Modified 헤더의 값에 의존 할 수 있으므로 보호해야합니다. 복사 / 이동 동작 :이 속성 값은 원본 리소스의 속성 값이 아니라 대상 리소스의 마지막 수정 날짜에 따라 다릅니다. 일부 서버 구현에서는 DAV : getlastmodified 값에 대해 파일 시스템 날짜 수정 값을 사용하며 이는 HTTP Last-Modified 값을 변경해야하는 경우에도 MOVE로 유지 될 수 있습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; 이후]는 클라이언트가 제공된 경우 ETag를 사용해야하며, ETag를 구현하는 서버는 오프라인 동기화 또는 캐시 제어를위한 수정 날짜보다 훨씬 더 나은 메커니즘을 사용하여 클라이언트를 신뢰할 수 있습니다. &lt;a href=&quot;#section-8.8&quot;&gt;섹션 8.8&lt;/a&gt; 의 고려 사항도 참고하십시오 . 설명 : 자원의 마지막 수정 날짜는 자원의 본문 (GET 응답)의 변경 사항 만 반영해야합니다. 클라이언트가 기존 본문을 덮어 쓰는 시점을 알기 위해 마지막 수정 날짜에 의존 할 수 있기 때문에 속성 변경만으로 최종 수정 날짜를 변경해서는 안됩니다. DAV : getlastmodified 속성은 GET에 대한 응답으로 Last-Modified 헤더를 반환하는 모든 DAV 호환 리소스에서 정의되어야합니다. &amp;lt;! ELEMENT getlastmodified (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="863060182a5c2848f88469f61b18814776f39625" translate="yes" xml:space="preserve">
          <source>Name:   href

   Purpose:   MUST contain a URI or a relative reference.

   Description:   There may be limits on the value of 'href' depending
      on the context of its use.  Refer to the specification text where
      'href' is used to see what limitations apply in each case.

   Value:   Simple-ref


   &amp;lt;!ELEMENT href (#PCDATA)&amp;gt;</source>
          <target state="translated">이름 : href 목적 : URI 또는 ​​상대 참조를 포함해야합니다. 설명 : 사용 상황에 따라 'href'값에 제한이있을 수 있습니다. 각 경우에 어떤 제한이 적용되는지 확인하려면 'href'가 사용 된 사양 텍스트를 참조하십시오. 값 : 단순 참조 &amp;lt;! ELEMENT href (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="893dbb5e6ea2e164b3fe7cab59b462026c86e341" translate="yes" xml:space="preserve">
          <source>Name:   include

   Purpose:   Any child element represents the name of a property to be
      included in the PROPFIND response.  All elements inside an
      'include' XML element MUST define properties related to the
      resource, although possible property names are in no way limited
      to those property names defined in this document or other
      standards.  This element MUST NOT contain text or mixed content.

   &amp;lt;!ELEMENT include ANY &amp;gt;</source>
          <target state="translated">이름 : 포함 목적 : 모든 하위 요소는 PROPFIND 응답에 포함 할 속성의 이름을 나타냅니다. '포함'XML 요소 내부의 모든 요소는 반드시 리소스와 관련된 속성을 정의해야하지만 가능한 속성 이름은이 문서 나 다른 표준에 정의 된 속성 이름으로 제한되지 않습니다. 이 요소는 텍스트 또는 혼합 컨텐츠를 포함해서는 안됩니다. &amp;lt;! 요소에는 모두 포함&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6c0d5c7c18f7351f5e5ec4a0e565194906f570e3" translate="yes" xml:space="preserve">
          <source>Name:   location

   Purpose:   HTTP defines the &quot;Location&quot; header (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-14.30&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;) for use with some status codes (such as 201 and the 300
      series codes).  When these codes are used inside a 'multistatus'
      element, the 'location' element can be used to provide the
      accompanying Location header value. 

   Description:   Contains a single href element with the same value
      that would be used in a Location header.


   &amp;lt;!ELEMENT location (href)&amp;gt;</source>
          <target state="translated">이름 : location 목적 : HTTP는 일부 상태 코드 (예 : 201 및 300 시리즈 코드)와 함께 사용할 &quot;Location&quot;헤더 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-14.30&quot;&gt;14.30 &lt;/a&gt;&lt;a href=&quot;#section-14.30&quot;&gt;절&lt;/a&gt; 참조)를 정의합니다 . 이러한 코드가 'multistatus'요소 내부에서 사용되는 경우 'location'요소를 사용하여 해당하는 Location 헤더 값을 제공 할 수 있습니다. 설명 : Location 헤더에 사용되는 것과 동일한 값을 가진 단일 href 요소를 포함합니다. &amp;lt;! ELEMENT 위치 (href)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="611ed05ab7ed30cc8633acf614bc5f74d180e99e" translate="yes" xml:space="preserve">
          <source>Name:   lockdiscovery

   Purpose:   Describes the active locks on a resource

   Protected:   MUST be protected.  Clients change the list of locks
      through LOCK and UNLOCK, not through PROPPATCH.

   COPY/MOVE behavior:   The value of this property depends on the lock
      state of the destination, not on the locks of the source resource.
      Recall that locks are not moved in a MOVE operation.

   Description:   Returns a listing of who has a lock, what type of lock
      he has, the timeout type and the time remaining on the timeout,
      and the associated lock token.  Owner information MAY be omitted
      if it is considered sensitive.  If there are no locks, but the
      server supports locks, the property will be present but contain
      zero 'activelock' elements.  If there are one or more locks, an
      'activelock' element appears for each lock on the resource.  This
      property is NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT lockdiscovery (activelock)* &amp;gt;</source>
          <target state="translated">이름 : lockdiscovery 목적 : 자원의 활성 잠금을 설명합니다. 보호 : 보호되어야합니다. 클라이언트는 PROPPATCH가 아닌 LOCK 및 UNLOCK을 통해 잠금 목록을 변경합니다. 복사 / 이동 동작 :이 속성의 값은 소스 리소스의 잠금이 아니라 대상의 잠금 상태에 따라 다릅니다. MOVE 조작에서 잠금이 이동되지 않았 음을 기억하십시오. 설명 : 잠금을 보유한 사람, 보유한 잠금 유형, 시간 종료 유형 및 시간 종료 시간 및 관련 잠금 토큰의 목록을 리턴합니다. 소유자 정보가 민감한 것으로 간주되는 경우 생략 될 수 있습니다. 잠금이 없지만 서버가 잠금을 지원하는 경우 속성이 존재하지만 'activelock'요소는 포함되지 않습니다. 하나 이상의 잠금이 있으면 '자원의 각 잠금에 대해 activelock '요소가 나타납니다. 이 속성은 쓰기 잠금과 관련하여 잠글 수 없습니다 (&lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ). &amp;lt;! ELEMENT lockdiscovery (액티브 락) *&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c16989808c9336197d43ba1941662e1c595ca03" translate="yes" xml:space="preserve">
          <source>Name:   lockentry

   Purpose:   Defines the types of locks that can be used with the
      resource.

   &amp;lt;!ELEMENT lockentry (lockscope, locktype) &amp;gt;</source>
          <target state="translated">이름 : lockentry 목적 : 자원과 함께 사용할 수있는 잠금 유형을 정의합니다. &amp;lt;! ELEMENT 잠금 장치 (Lockscope, Locktype)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5083904af81384e6886493a202104354cd3f8853" translate="yes" xml:space="preserve">
          <source>Name:   lockinfo

   Purpose:   The 'lockinfo' XML element is used with a LOCK method to
      specify the type of lock the client wishes to have created.


   &amp;lt;!ELEMENT lockinfo (lockscope, locktype, owner?)  &amp;gt;</source>
          <target state="translated">이름 : lockinfo 목적 : 'lockinfo'XML 요소는 클라이언트가 작성하려는 잠금 유형을 지정하기 위해 LOCK 메소드와 함께 사용됩니다. &amp;lt;! ELEMENT lockinfo (lockscope, locktype, owner?)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="852a23c678d8306e5d8708150d7c2bf16c39adbc" translate="yes" xml:space="preserve">
          <source>Name:   lockroot

   Purpose:   Contains the root URL of the lock, which is the URL
      through which the resource was addressed in the LOCK request.

   Description:   The href element contains the root of the lock.  The
      server SHOULD include this in all DAV:lockdiscovery property
      values and the response to LOCK requests.

   &amp;lt;!ELEMENT lockroot (href) &amp;gt;</source>
          <target state="translated">이름 : lockroot 목적 : 잠금의 루트 URL을 포함합니다. 이는 잠금 요청에서 자원이 처리 된 URL입니다. 설명 : href 요소는 잠금의 루트를 포함합니다. 서버는 이것을 모든 DAV : lockdiscovery 속성 값과 LOCK 요청에 대한 응답에 포함시켜야한다. &amp;lt;! ELEMENT lockroot (href)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="00e11eedce57a66ee497b17831a568c69036832c" translate="yes" xml:space="preserve">
          <source>Name:   lockscope

   Purpose:   Specifies whether a lock is an exclusive lock, or a shared
      lock.


     &amp;lt;!ELEMENT lockscope (exclusive | shared) &amp;gt;</source>
          <target state="translated">이름 : lockscope 목적 : 잠금이 독점 잠금인지 공유 잠금인지 지정합니다. &amp;lt;! ELEMENT lockscope (독점 | 공유)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82de61827789e036e8393a1e1b328cd94701a6ea" translate="yes" xml:space="preserve">
          <source>Name:   locktoken

   Purpose:   The lock token associated with a lock.

   Description:   The href contains a single lock token URI, which
      refers to the lock.

   &amp;lt;!ELEMENT locktoken (href) &amp;gt;</source>
          <target state="translated">이름 : locktoken 목적 : 잠금과 연관된 잠금 토큰. 설명 : href에는 잠금을 나타내는 단일 잠금 토큰 URI가 포함되어 있습니다. &amp;lt;! ELEMENT 잠금 토큰 (href)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="598c85ffd24685cdfcbe4799404f4c9aeaa83551" translate="yes" xml:space="preserve">
          <source>Name:   locktype

   Purpose:   Specifies the access type of a lock.  At present, this
      specification only defines one lock type, the write lock.


   &amp;lt;!ELEMENT locktype (write) &amp;gt;</source>
          <target state="translated">이름 : locktype 목적 : 잠금 액세스 유형을 지정합니다. 현재이 사양에서는 하나의 잠금 유형 인 쓰기 잠금 만 정의합니다. &amp;lt;! ELEMENT 잠금 유형 (쓰기)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e05fdca8059417af4c532004b86578fb46a8667c" translate="yes" xml:space="preserve">
          <source>Name:   multistatus

   Purpose:   Contains multiple response messages.

   Description:   The 'responsedescription' element at the top level is
      used to provide a general message describing the overarching
      nature of the response.  If this value is available, an
      application may use it instead of presenting the individual
      response descriptions contained within the responses.


   &amp;lt;!ELEMENT multistatus (response*, responsedescription?)  &amp;gt;</source>
          <target state="translated">이름 : multistatus 목적 : 여러 응답 메시지를 포함합니다. 설명 : 최상위 레벨의 '응답 설명'요소는 응답의 전반적인 특성을 설명하는 일반 메시지를 제공하는 데 사용됩니다. 이 값을 사용할 수 있으면 응용 프로그램은 응답 내에 포함 된 개별 응답 설명을 표시하는 대신이 값을 사용할 수 있습니다. &amp;lt;! ELEMENT 다중 상태 (응답 *, 응답 설명?)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e7255f62e0866a1ff69ffde8c78451b0557e060" translate="yes" xml:space="preserve">
          <source>Name:   owner

   Purpose:   Holds client-supplied information about the creator of a
      lock.

   Description:   Allows a client to provide information sufficient for
      either directly contacting a principal (such as a telephone number
      or Email URI), or for discovering the principal (such as the URL 

      of a homepage) who created a lock.  The value provided MUST be
      treated as a dead property in terms of XML Information Item
      preservation.  The server MUST NOT alter the value unless the
      owner value provided by the client is empty.  For a certain amount
      of interoperability between different client implementations, if
      clients have URI-formatted contact information for the lock
      creator suitable for user display, then clients SHOULD put those
      URIs in 'href' child elements of the 'owner' element.

   Extensibility:   MAY be extended with child elements, mixed content,
      text content or attributes.

   &amp;lt;!ELEMENT owner ANY &amp;gt;</source>
          <target state="translated">이름 : owner 목적 : 잠금 생성자에 대한 클라이언트 제공 정보를 보유합니다. 설명 : 클라이언트가 전화 번호 나 이메일 URI와 같은 보안 주체에게 직접 연락하거나 잠금을 생성 한 보안 주체 (예 : 홈페이지의 URL)를 검색하기에 충분한 정보를 제공 할 수 있습니다. 제공된 값은 XML 정보 항목 보존 측면에서 사용 불능 속성으로 취급되어야합니다. 클라이언트가 제공 한 소유자 값이 비어 있지 않으면 서버는 값을 변경해서는 안됩니다. 서로 다른 클라이언트 구현 사이의 특정 상호 운용성을 위해 클라이언트가 사용자 표시에 적합한 잠금 작성자에 대한 URI 형식의 연락처 정보를 가지고 있으면 클라이언트는 해당 URI를 'href'하위 요소에 배치해야합니다.소유자 요소. 확장 성 : 하위 요소, 혼합 컨텐츠, 텍스트 컨텐츠 또는 속성으로 확장 될 수 있습니다. &amp;lt;! 요소 소유자 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a4e49012d04e6acebeb0c6719ce7d291a7d9aa8" translate="yes" xml:space="preserve">
          <source>Name:   prop

   Purpose:   Contains properties related to a resource.

   Description:   A generic container for properties defined on
      resources.  All elements inside a 'prop' XML element MUST define
      properties related to the resource, although possible property
      names are in no way limited to those property names defined in
      this document or other standards.  This element MUST NOT contain
      text or mixed content.

   &amp;lt;!ELEMENT prop ANY &amp;gt;</source>
          <target state="translated">이름 : prop 목적 : 리소스와 관련된 속성이 들어 있습니다. 설명 : 리소스에 정의 된 속성의 일반 컨테이너입니다. 'prop'XML 요소 내부의 모든 요소는 반드시 리소스와 관련된 속성을 정의해야하지만 가능한 속성 이름은이 문서 나 다른 표준에 정의 된 속성 이름으로 제한되지 않습니다. 이 요소는 텍스트 또는 혼합 컨텐츠를 포함해서는 안됩니다. &amp;lt;! 요소 소품 ANY&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a17076c9f6d61a5ed9b6362d78be28ae87fb3ec" translate="yes" xml:space="preserve">
          <source>Name:   propertyupdate

   Purpose:   Contains a request to alter the properties on a resource.

   Description:   This XML element is a container for the information
      required to modify the properties on the resource.

   &amp;lt;!ELEMENT propertyupdate (remove | set)+ &amp;gt;</source>
          <target state="translated">이름 : propertyupdate 목적 : 자원의 등록 정보를 변경하라는 요청이 포함되어 있습니다. 설명 :이 XML 요소는 자원의 특성을 수정하는 데 필요한 정보의 컨테이너입니다. &amp;lt;! ELEMENT 속성 업데이트 (제거 | 설정) +&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f033076f90b712249c25c9cf538723f50fb05452" translate="yes" xml:space="preserve">
          <source>Name:   propfind 

   Purpose:   Specifies the properties to be returned from a PROPFIND
      method.  Four special elements are specified for use with
      'propfind': 'prop', 'allprop', 'include', and 'propname'.  If
      'prop' is used inside 'propfind', it MUST NOT contain property
      values.

   &amp;lt;!ELEMENT propfind ( propname | (allprop, include?) | prop ) &amp;gt;</source>
          <target state="translated">이름 : propfind 목적 : PROPFIND 메소드에서 리턴 될 특성을 지정합니다. 'propfind'와 함께 사용할 'prop', 'allprop', 'include'및 'propname'의 네 가지 특수 요소가 지정됩니다. 'propfind'내에서 'prop'를 사용하는 경우 속성 값을 포함해서는 안됩니다. &amp;lt;! ELEMENT propfind (propname | (allprop, include?) | prop)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b132fa457cc7b2c94116ac2aad40a7507857d840" translate="yes" xml:space="preserve">
          <source>Name:   propname

   Purpose:   Specifies that only a list of property names on the
      resource is to be returned.

   &amp;lt;!ELEMENT propname EMPTY &amp;gt;</source>
          <target state="translated">이름 : propname 목적 : 자원의 등록 정보 이름 목록 만 반환되도록 지정합니다. &amp;lt;! 요소 propname 비어 있음&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb18d77861af3bb5b094ee60954452e584d7dbd8" translate="yes" xml:space="preserve">
          <source>Name:   propstat

   Purpose:   Groups together a prop and status element that is
      associated with a particular 'href' element.

   Description:   The propstat XML element MUST contain one prop XML
      element and one status XML element.  The contents of the prop XML
      element MUST only list the names of properties to which the result
      in the status element applies.  The optional precondition/
      postcondition element and 'responsedescription' text also apply to
      the properties named in 'prop'.

   &amp;lt;!ELEMENT propstat (prop, status, error?, responsedescription?) &amp;gt;</source>
          <target state="translated">이름 : propstat 목적 : 특정 'href'요소와 연관된 prop 및 status 요소를 그룹화합니다. 설명 : propstat XML 요소는 prop XML 요소 하나와 상태 XML 요소 하나를 포함해야합니다. prop XML 요소의 내용에는 status 요소의 결과가 적용되는 속성 이름 만 나열해야합니다. 선택적 전제 조건 / 후 조건 요소 및 '응답 설명'텍스트는 'prop'에 이름이 지정된 특성에도 적용됩니다. &amp;lt;! ELEMENT propstat (prop, status, error ?, responsedescription?)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="54b0bd4bd32a031047ae1be302a66b6e6c5b1f5b" translate="yes" xml:space="preserve">
          <source>Name:   remove

   Purpose:   Lists the properties to be removed from a resource.

   Description:   Remove instructs that the properties specified in prop
      should be removed.  Specifying the removal of a property that does
      not exist is not an error.  All the XML elements in a 'prop' XML
      element inside of a 'remove' XML element MUST be empty, as only
      the names of properties to be removed are required.

   &amp;lt;!ELEMENT remove (prop) &amp;gt;</source>
          <target state="translated">이름 : 제거 목적 : 리소스에서 제거 할 속성을 나열합니다. 설명 : Remove는 prop에 지정된 속성을 제거하도록 지시합니다. 존재하지 않는 속성 제거를 지정하는 것은 오류가 아닙니다. 제거 할 속성 이름 만 필요하므로 '제거'XML 요소 내부의 'prop'XML 요소에있는 모든 XML 요소는 비어 있어야합니다. &amp;lt;! ELEMENT 제거 (prop)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bf23482b4d15a7ccf582eb373f0c59dfd927c56a" translate="yes" xml:space="preserve">
          <source>Name:   resourcetype

   Purpose:   Specifies the nature of the resource.

   Protected:   SHOULD be protected.  Resource type is generally decided
      through the operation creating the resource (MKCOL vs PUT), not by
      PROPPATCH.

   COPY/MOVE behavior:   Generally a COPY/MOVE of a resource results in
      the same type of resource at the destination.

   Description:   MUST be defined on all DAV-compliant resources.  Each
      child element identifies a specific type the resource belongs to,
      such as 'collection', which is the only resource type defined by
      this specification (see &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;).  If the element contains
      the 'collection' child element plus additional unrecognized
      elements, it should generally be treated as a collection.  If the
      element contains no recognized child elements, it should be
      treated as a non-collection resource.  The default value is empty.
      This element MUST NOT contain text or mixed content.  Any custom
      child element is considered to be an identifier for a resource
      type.

   Example: (fictional example to show extensibility)

       &amp;lt;x:resourcetype xmlns:x=&quot;DAV:&quot;&amp;gt;
           &amp;lt;x:collection/&amp;gt;
           &amp;lt;f:search-results xmlns:f=&quot;http://www.example.com/ns&quot;/&amp;gt;
       &amp;lt;/x:resourcetype&amp;gt;</source>
          <target state="translated">이름 : resourcetype 목적 : 자원의 특성을 지정합니다. 보호 : 보호해야합니다. 자원 유형은 일반적으로 PROPPATCH가 아니라 자원을 작성하는 조작 (MKCOL vs PUT)을 통해 결정됩니다. COPY / MOVE 동작 : 일반적으로 자원의 COPY / MOVE는 대상에서 동일한 유형의 자원이됩니다. 설명 : 모든 DAV 호환 리소스에서 정의해야합니다. 각 자식 요소는이 명세에 의해 정의 된 유일한 자원 유형 인 'collection'과 같이 자원이 속하는 특정 유형을 식별한다 ( &lt;a href=&quot;#section-14.3&quot;&gt;14.3 절&lt;/a&gt; 참조)). 요소에 'collection'하위 요소와 인식 할 수없는 추가 요소가 포함 된 경우 일반적으로 컬렉션으로 취급해야합니다. 요소에 인식 된 자식 요소가 없으면 컬렉션이 아닌 리소스로 처리해야합니다. 기본값은 비어 있습니다. 이 요소는 텍스트 또는 혼합 컨텐츠를 포함해서는 안됩니다. 모든 사용자 정의 하위 요소는 자원 유형의 식별자로 간주됩니다. 예 : (확장 성을 보여주는 가상의 예) &amp;lt;x : resourcetype xmlns : x = &quot;DAV :&quot;&amp;gt; &amp;lt;x : collection /&amp;gt; &amp;lt;f : search-results xmlns : f = &quot;http://www.example.com/ns &quot;/&amp;gt; &amp;lt;/ x : resourcetype&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba963fb29afc5c7063b3f544c4e233040e8f1dab" translate="yes" xml:space="preserve">
          <source>Name:   response

   Purpose:   Holds a single response describing the effect of a method
      on resource and/or its properties.

   Description:   The 'href' element contains an HTTP URL pointing to a
      WebDAV resource when used in the 'response' container.  A
      particular 'href' value MUST NOT appear more than once as the
      child of a 'response' XML element under a 'multistatus' XML
      element.  This requirement is necessary in order to keep
      processing costs for a response to linear time.  Essentially, this
      prevents having to search in order to group together all the
      responses by 'href'.  There are, however, no requirements
      regarding ordering based on 'href' values.  The optional
      precondition/postcondition element and 'responsedescription' text
      can provide additional information about this resource relative to
      the request or result.


   &amp;lt;!ELEMENT response (href, ((href*, status)|(propstat+)),
                       error?, responsedescription? , location?) &amp;gt;</source>
          <target state="translated">이름 : response 목적 : 자원 및 / 또는 해당 속성에 대한 메소드의 영향을 설명하는 단일 응답을 보유합니다. 설명 : 'href'요소는 'response'컨테이너에서 사용될 때 WebDAV 자원을 가리키는 HTTP URL을 포함합니다. 특정 'href'값은 'multistatus'XML 요소 아래에서 'response'XML 요소의 자식으로 두 번 이상 표시되어서는 안됩니다 (MUST NOT). 선형 시간에 대한 응답으로 처리 비용을 유지하려면이 요구 사항이 필요합니다. 본질적으로 이렇게하면 모든 응답을 'href'로 그룹화하기 위해 검색하지 않아도됩니다. 그러나 'href'값을 기반으로하는 주문과 관련된 요구 사항은 없습니다. 선택적 전제 조건 / 후 조건 요소 및 'responsedescription '텍스트는 요청 또는 결과와 관련된이 자원에 대한 추가 정보를 제공 할 수 있습니다. &amp;lt;! ELEMENT 응답 (href, ((href *, status) | (propstat +)), error ?, responsedescription?, location?)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e79aa3cfbb4886f68f0cdccf03d0aaa6df292652" translate="yes" xml:space="preserve">
          <source>Name:   responsedescription

   Purpose:   Contains information about a status response within a
      Multi-Status.

   Description:   Provides information suitable to be presented to a
      user.

   &amp;lt;!ELEMENT responsedescription (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : responsedescription 목적 : 다중 상태 내의 상태 응답에 대한 정보가 들어 있습니다. 설명 : 사용자에게 제시하기에 적합한 정보를 제공합니다. &amp;lt;! ELEMENT 응답 설명 (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="faf150c453c206be333d64c2eb169ece66eddf4f" translate="yes" xml:space="preserve">
          <source>Name:   set

   Purpose:   Lists the property values to be set for a resource.

   Description:   The 'set' element MUST contain only a 'prop' element.
      The elements contained by the 'prop' element inside the 'set'
      element MUST specify the name and value of properties that are set
      on the resource identified by Request-URI.  If a property already
      exists, then its value is replaced.  Language tagging information
      appearing in the scope of the 'prop' element (in the &quot;xml:lang&quot; 

      attribute, if present) MUST be persistently stored along with the
      property, and MUST be subsequently retrievable using PROPFIND.

   &amp;lt;!ELEMENT set (prop) &amp;gt;</source>
          <target state="translated">이름 : set 목적 : 자원에 설정할 특성 값을 나열합니다. 설명 : 'set'요소는 'prop'요소 만 포함해야합니다. 'set'요소 내부의 'prop'요소에 포함 된 요소는 Request-URI로 식별 된 자원에 설정된 특성의 이름과 값을 지정해야합니다. 특성이 이미 존재하면 해당 값이 대체됩니다. 'prop'요소의 범위에있는 언어 태그 정보 (있는 경우 &quot;xml : lang&quot;속성에 있음)는 속성과 함께 지속적으로 저장해야하며, PROPFIND를 사용하여 검색 할 수 있어야합니다. &amp;lt;! ELEMENT set (prop)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="034ef0121821410e6799f280fbce98e61bb36fec" translate="yes" xml:space="preserve">
          <source>Name:   shared

   Purpose:   Specifies a shared lock.


   &amp;lt;!ELEMENT shared EMPTY &amp;gt;</source>
          <target state="translated">이름 : 공유 목적 : 공유 잠금을 지정합니다. &amp;lt;! ELEMENT 공유 빈&amp;gt;</target>
        </trans-unit>
        <trans-unit id="89e2c86f49074c5456840897eea52e652dab08d2" translate="yes" xml:space="preserve">
          <source>Name:   status

   Purpose:   Holds a single HTTP status-line.

   Value:   status-line (defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC2616]&lt;/a&gt;)

   &amp;lt;!ELEMENT status (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : status 목적 : 단일 HTTP 상태 표시 줄을 보유합니다. 값 : 상태 표시 줄 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6.1&quot;&gt;[RFC2616]의 섹션 6.1에&lt;/a&gt; 정의 됨 ) &amp;lt;! ELEMENT 상태 (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6cd030e3b2b200c8abb49cd69f079bd0720dc672" translate="yes" xml:space="preserve">
          <source>Name:   supportedlock

   Purpose:   To provide a listing of the lock capabilities supported by
      the resource.

   Protected:   MUST be protected.  Servers, not clients, determine what
      lock mechanisms are supported. 

   COPY/MOVE behavior:   This property value is dependent on the kind of
      locks supported at the destination, not on the value of the
      property at the source resource.  Servers attempting to COPY to a
      destination should not attempt to set this property at the
      destination.

   Description:   Returns a listing of the combinations of scope and
      access types that may be specified in a lock request on the
      resource.  Note that the actual contents are themselves controlled
      by access controls, so a server is not required to provide
      information the client is not authorized to see.  This property is
      NOT lockable with respect to write locks (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   &amp;lt;!ELEMENT supportedlock (lockentry)* &amp;gt;</source>
          <target state="translated">이름 : supportedlock 목적 : 자원이 지원하는 잠금 기능 목록을 제공합니다. 보호 : 반드시 보호해야합니다. 클라이언트가 아닌 서버가 지원되는 잠금 메커니즘을 결정합니다. 복사 / 이동 동작 :이 속성 값은 소스 리소스의 속성 값이 아니라 대상에서 지원되는 잠금 종류에 따라 다릅니다. 대상으로 복사를 시도하는 서버는 대상에서이 속성을 설정하지 않아야합니다. 설명 : 자원의 잠금 요청에 지정 될 수있는 범위 및 액세스 유형의 조합 목록을 리턴합니다. 실제 내용은 자체적으로 액세스 제어에 의해 제어되므로 서버가 클라이언트에게 볼 권한이없는 정보를 제공 할 필요는 없습니다.이 속성은 쓰기 잠금과 관련하여 잠글 수 없습니다 (&lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ). &amp;lt;! ELEMENT supportedlock (잠금) *&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35119527bc63f501789916897c0befe464dc6217" translate="yes" xml:space="preserve">
          <source>Name:   timeout

   Purpose:   The number of seconds remaining before a lock expires.

   Value:   TimeType (defined in &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)


      &amp;lt;!ELEMENT timeout (#PCDATA) &amp;gt;</source>
          <target state="translated">이름 : timeout 목적 : 잠금이 만료되기까지 남은 시간 (초). 값 : TimeType ( &lt;a href=&quot;#section-10.7&quot;&gt;섹션 10.7에&lt;/a&gt; 정의 됨 ) &amp;lt;! ELEMENT timeout (#PCDATA)&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89a920056d92541b3e4aaafcac0f2c97ae89ad3" translate="yes" xml:space="preserve">
          <source>Name:   write

   Purpose:   Specifies a write lock.


   &amp;lt;!ELEMENT write EMPTY &amp;gt;</source>
          <target state="translated">이름 : 쓰기 목적 : 쓰기 잠금을 지정합니다. &amp;lt;! 요소 쓰기 빈&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef928101d810c7b294edc543143c4a9808fc0cd4" translate="yes" xml:space="preserve">
          <source>Navigate to the web site or web app in question and open the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;Developer Tools&lt;/a&gt;.</source>
          <target state="translated">해당 웹 사이트 또는 웹 앱으로 이동하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools&quot;&gt;개발자 도구를&lt;/a&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="24cfea67414a6051f8ef6f58e4703f34128176fb" translate="yes" xml:space="preserve">
          <source>Navigation directive</source>
          <target state="translated">네비게이션 지시어</target>
        </trans-unit>
        <trans-unit id="6cb820339644262483e0df69ef7b63b3ff7eb0cf" translate="yes" xml:space="preserve">
          <source>Navigation directives</source>
          <target state="translated">탐색 지시문</target>
        </trans-unit>
        <trans-unit id="3d7680d3ffd85eebd63677687a9aa06b50aefc80" translate="yes" xml:space="preserve">
          <source>Navigation directives govern to which location a user can navigate to or submit a form to, for example.</source>
          <target state="translated">탐색 지시문은 예를 들어 사용자가 양식을 탐색하거나 양식을 제출할 수있는 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7d198c1bf717002743411eff6ca257f87f502017" translate="yes" xml:space="preserve">
          <source>Navigation to</source>
          <target state="translated">로 이동</target>
        </trans-unit>
        <trans-unit id="4fd5b390b406ef3a192cb33756658713f813cdd9" translate="yes" xml:space="preserve">
          <source>Navigational upgrades to third-party resources brings a significantly higher potential for breakage, these are not upgraded:</source>
          <target state="translated">타사 리소스로의 탐색 업그레이드는 업그레이드 가능성이 크게 높아지지만 업그레이드되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fd128a511cf81f2a11a5b15d991245ba541495b" translate="yes" xml:space="preserve">
          <source>Negotiating an HTTP version</source>
          <target state="translated">HTTP 버전 협상</target>
        </trans-unit>
        <trans-unit id="9359b43b3679ffebf30c6ff7f3222f0b6df7956c" translate="yes" xml:space="preserve">
          <source>Network Working Group                                      R. Fielding
Request for Comments: 2616                                   UC Irvine
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;                                              J. Gettys
Category: Standards Track                                   Compaq/W3C
                                                              J. Mogul
                                                                Compaq
                                                            H. Frystyk
                                                               W3C/MIT
                                                           L. Masinter
                                                                 Xerox
                                                              P. Leach
                                                             Microsoft
                                                        T. Berners-Lee
                                                               W3C/MIT
                                                             June 1999</source>
          <target state="translated">Network Working Group R. Fielding 의견 요청 : 2616 UC Irvine 사용되지 않음 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; J. Gettys 카테고리 : 표준 트랙 Compaq / W3C J. Mogul Compaq H. Frystyk W3C / MIT L. Masinter Xerox P. Leach Microsoft T.Berners-Lee W3C / MIT 1999 년 6 월</target>
        </trans-unit>
        <trans-unit id="5428bbcea03dea51ffb7eb6864dea642db9e9245" translate="yes" xml:space="preserve">
          <source>Network Working Group                                   J. Gregorio, Ed.
Request for Comments: 5023                                        Google
Category: Standards Track                                B. de hOra, Ed.
                                                         NewBay Software
                                                            October 2007</source>
          <target state="translated">네트워크 실무 그룹 J. Gregorio, Ed. 의견 요청 : 5023 Google 카테고리 : 표준 Track B. de hOra, Ed. 2007 년 10 월 NewBay 소프트웨어</target>
        </trans-unit>
        <trans-unit id="4d8ae710cb99c4a7621dd240f2f410770ca46d77" translate="yes" xml:space="preserve">
          <source>Network Working Group                                  L. Dusseault, Ed.
Request for Comments: 4918                                   CommerceNet
Obsoletes: &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;                                                June 2007
Category: Standards Track</source>
          <target state="translated">네트워크 실무 그룹 L. Dusseault, Ed. 의견 요청 : 4918 CommerceNet 사용되지 않음 : 2007 년 6 월 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt; 범주 : 표준 트랙</target>
        </trans-unit>
        <trans-unit id="e3623b4b3820bb728eda2dde15946a4290819387" translate="yes" xml:space="preserve">
          <source>Network monitor</source>
          <target state="translated">네트워크 모니터</target>
        </trans-unit>
        <trans-unit id="e50032eb35aad47bed9d5ff741f087c1986c82ba" translate="yes" xml:space="preserve">
          <source>Network operators sometimes require some authentication, acceptance of terms, or other user interaction before granting access (for example in an internet caf&amp;eacute; or at an airport). They often identify clients who have not done so using their Media Access Control (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MAC&quot;&gt;MAC&lt;/a&gt;) addresses.</source>
          <target state="translated">네트워크 운영자는 액세스 권한을 부여하기 전에 (예 : 인터넷 카페 또는 공항에서) 일부 인증, 용어 수락 또는 기타 사용자 상호 작용이 필요한 경우가 있습니다. 종종 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MAC&quot;&gt;MAC&lt;/a&gt; (Media Access Control ) 주소를 사용하여 그렇게하지 않은 클라이언트를 식별 합니다.</target>
        </trans-unit>
        <trans-unit id="6b43fa182a48c949aed212293ef54b74e65782bb" translate="yes" xml:space="preserve">
          <source>Never assume that a browser or a rendering engine only runs on one type of device. Especially don't make different defaults for different browsers or rendering engines.</source>
          <target state="translated">브라우저 또는 렌더링 엔진이 한 유형의 장치에서만 실행된다고 가정하지 마십시오. 특히 브라우저 나 렌더링 엔진마다 다른 기본값을 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ec7bc9b9c4ccaf3179748dcdf8d87e35784c21d" translate="yes" xml:space="preserve">
          <source>Never use the OS token to define if a browser is on mobile, tablet or desktop. The OS may run on more than one type of (for example, Android runs on tablets as well as phones).</source>
          <target state="translated">브라우저가 모바일, 태블릿 또는 데스크톱에 있는지 여부를 정의하기 위해 OS 토큰을 사용하지 마십시오. OS는 둘 이상의 유형에서 실행될 수 있습니다 (예 : Android는 태블릿뿐만 아니라 전화에서도 실행).</target>
        </trans-unit>
        <trans-unit id="9f77f8caaa3035ec127bade7a0545aa68e91b610" translate="yes" xml:space="preserve">
          <source>New cookies can also be created via JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, and if the &lt;code&gt;HttpOnly&lt;/code&gt; flag is not set, existing cookies can be accessed from JavaScript as well.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 JavaScript를 통해 새 쿠키를 만들 수도 있고 &lt;code&gt;HttpOnly&lt;/code&gt; 플래그를 설정하지 않으면 JavaScript에서도 기존 쿠키에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5dfd3e32cc719743d36b551e2cc31f5efa09bb4" translate="yes" xml:space="preserve">
          <source>New definition; supplants &lt;a href=&quot;https://www.w3.org/TR/cors/&quot;&gt;W3C CORS&lt;/a&gt; specification.</source>
          <target state="translated">새로운 정의; &lt;a href=&quot;https://www.w3.org/TR/cors/&quot;&gt;W3C CORS&lt;/a&gt; 사양을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="07349da357d41ca5084e50db9d4b1c35940a7768" translate="yes" xml:space="preserve">
          <source>New extension directives ought to consider defining:

   o  What it means for a directive to be specified multiple times,

   o  When the directive does not take an argument, what it means when
      an argument is present,

   o  When the directive requires an argument, what it means when it is
      missing,

   o  Whether the directive is specific to requests, responses, or able
      to be used in either.

   See also &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.</source>
          <target state="translated">새로운 확장 지시어는 다음을 정의하는 것을 고려해야한다 : o 지시어가 여러 번 지정되는 의미 o 지시어가 누락 된 경우, o 지시어가 요청, 응답에 고유한지 또는 어느 쪽에서 나 사용할 수 있는지 여부를 의미합니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="e03ab58c9bd12196de6bace27f6b044aff80f31c" translate="yes" xml:space="preserve">
          <source>New specifications MAY require that the &quot;type&quot; parameter be used to
   identify the Atom Document type.  Producers of Atom Entry Documents
   SHOULD use the &quot;type&quot; parameter regardless of whether or not it is
   mandatory.  Producers of Atom Feed Documents MAY use the parameter.

   Atom processors that do not recognize the &quot;type&quot; parameter MUST
   ignore its value and examine the root element to determine the
   document type.

   Atom processors that do recognize the &quot;type&quot; parameter SHOULD detect
   and report inconsistencies between the parameter's value and the
   actual type of the document's root element.</source>
          <target state="translated">새로운 사양에서는 &quot;type&quot;매개 변수를 사용하여 Atom 문서 유형을 식별해야 할 수도 있습니다. Atom Entry Documents 생산자는 필수 여부에 관계없이 &quot;type&quot;매개 변수를 사용해야합니다. Atom Feed Documents 생산자는 매개 변수를 사용할 수 있습니다. &quot;type&quot;매개 변수를 인식하지 않는 원자 프로세서는 해당 값을 무시하고 루트 요소를 검사하여 문서 유형을 결정해야합니다. &quot;type&quot;매개 변수를 인식하는 원자 프로세서는 매개 변수 값과 문서 루트 요소의 실제 유형 사이의 불일치를 감지하고보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7b12052c0895e1742c7c3344db204110106e883" translate="yes" xml:space="preserve">
          <source>Next, you should configure your server to map the .pac filename extension to the MIME type.</source>
          <target state="translated">다음으로, .pac 파일 이름 확장자를 MIME 유형에 매핑하도록 서버를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2560cbce63028d4ce27fdd2ae2588b9ae69ca1e" translate="yes" xml:space="preserve">
          <source>Nginx</source>
          <target state="translated">Nginx</target>
        </trans-unit>
        <trans-unit id="cec384f7e83e464f4943c72ce6f108fdb5f1b9ed" translate="yes" xml:space="preserve">
          <source>Nginx configuration</source>
          <target state="translated">Nginx 구성</target>
        </trans-unit>
        <trans-unit id="4f024b156ff549e7822c3e7d3365e8b43d1fb094" translate="yes" xml:space="preserve">
          <source>Nicholas Zakas article on cookies</source>
          <target state="translated">쿠키에 대한 니콜라스 자 카스 기사</target>
        </trans-unit>
        <trans-unit id="d49005ff40f6342035c0b550381a16bf3992b810" translate="yes" xml:space="preserve">
          <source>Nicholas Zakas article on cookies and security</source>
          <target state="translated">쿠키 및 보안에 대한 Nicholas Zakas 기사</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="2e029a8ccab5f30d2a37a9fb7c59617e13c16abc" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream&quot;&gt;&lt;code&gt;ReadableStream&lt;/code&gt;&lt;/a&gt; object is used in the request.</source>
          <target state="translated">요청에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream&quot;&gt; &lt;code&gt;ReadableStream&lt;/code&gt; &lt;/a&gt; 객체가 사용 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="17a7d28f373846b5f71d72172ff5a2f4594ba504" translate="yes" xml:space="preserve">
          <source>No cache storage at all</source>
          <target state="translated">캐시 스토리지가 전혀 없음</target>
        </trans-unit>
        <trans-unit id="c55e5b38338e0330c22fc379f2150b6de3dd84ba" translate="yes" xml:space="preserve">
          <source>No caching</source>
          <target state="translated">캐싱 없음</target>
        </trans-unit>
        <trans-unit id="9b1fcbda693f085c4d6d33acbf333e420ba23fca" translate="yes" xml:space="preserve">
          <source>No changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0e9228f3e84fb358ddccd2e00420664a85404" translate="yes" xml:space="preserve">
          <source>No common browsers send the &lt;code&gt;Expect&lt;/code&gt; header, but some other clients such as cURL do so by default.</source>
          <target state="translated">일반적인 브라우저는 &lt;code&gt;Expect&lt;/code&gt; 헤더를 보내지 않지만 cURL과 같은 다른 클라이언트는 기본적으로 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="cdd99c30977facc38dbb4433f72792cc98e7b957" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Alt-Svc&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Alt-Svc&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f9ea7be16970fe67508438505a3982b349d0124" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Feature-Policy.document-domain&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Feature-Policy.document-domain&quot;(깊이 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="087056739c3ab34d873287ef53ff57a465326155" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Sec-WebSocket-Accept&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Sec-WebSocket-Accept&quot;(깊이 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9d95fc0c4c68f783d6998d3d7b74901ffbf32e7" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.status.418&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.status.418&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbe238f0711bff5f6e8bc80d9997d6930718ad5" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http/methods&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http / methods&quot;(깊이 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b939e4151278ce4695f67fb994a918f9a84e18f" translate="yes" xml:space="preserve">
          <source>No custom headers are sent with the HTTP request (such as &lt;code&gt;X-Modified&lt;/code&gt;, etc.)</source>
          <target state="translated">HTTP 요청과 함께 사용자 정의 헤더가 전송되지 않습니다 (예 : &lt;code&gt;X-Modified&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="573822ae80155d86cf67051167134df0cef110f2" translate="yes" xml:space="preserve">
          <source>No event listeners are registered on any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt;&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt;&lt;/a&gt; object used in the request; these are accessed using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt;&lt;code&gt;XMLHttpRequest.upload&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">요청에 사용 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt; &lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; &lt;/a&gt; 객체 에는 이벤트 리스너가 등록되어 있지 않습니다 . 이들은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt; &lt;code&gt;XMLHttpRequest.upload&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="c8bef9415aed440d614d66a570191aedb63a9755" translate="yes" xml:space="preserve">
          <source>No inheritance with &lt;code&gt;default-src&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; 로 상속받지 않음</target>
        </trans-unit>
        <trans-unit id="759bb2da44cf0b5255c1bd66673ad4fd56926c2b" translate="yes" xml:space="preserve">
          <source>No multiplexing can be done. Several connections need opening on the same server: and warm TCP connections are more efficient than cold ones.</source>
          <target state="translated">다중화를 수행 할 수 없습니다. 동일한 서버에서 여러 연결을 열어야합니다. 웜 연결은 콜드 연결보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="701e86c07a175edb82d6e91e08c1b08340403b9b" translate="yes" xml:space="preserve">
          <source>No other expectations except &quot;100-continue&quot; are specified currently.</source>
          <target state="translated">현재 &quot;100-continue&quot;을 제외한 다른 기대는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8f8ea3fe1de09718f410e58fb2b6aa218c2ce1a" translate="yes" xml:space="preserve">
          <source>No range unit is supported, this makes the header equivalent of its own absence and is therefore rarely used, though some browsers, like IE9, it is used to disable or remove the pause buttons in the download manager.</source>
          <target state="translated">범위 단위가 지원되지 않으므로 헤더가 자체적으로 존재하지 않으므로 IE9와 같은 일부 브라우저는 다운로드 관리자에서 일시 중지 버튼을 비활성화하거나 제거하는 데 사용되지만 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="733083ad7466dbb41b8dd82838b716da4b0d421f" translate="yes" xml:space="preserve">
          <source>No support for query strings, etc.</source>
          <target state="translated">쿼리 문자열 등을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c586fc9306c6c90357e137cd076d0c1a8ba40b34" translate="yes" xml:space="preserve">
          <source>No transformations or conversions should be made to the resource. The Content-Encoding, Content-Range, Content-Type headers must not be modified by a proxy. A non- transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. The &lt;code&gt;no-transform&lt;/code&gt; directive disallows this.</source>
          <target state="translated">자원을 변환하거나 변환하지 않아야합니다. Content-Encoding, Content-Range, Content-Type 헤더는 프록시에 의해 수정되어서는 안됩니다. 예를 들어, 투명하지 않은 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 은 &lt;code&gt;no-transform&lt;/code&gt; 지시어 것을 허용하지이.</target>
        </trans-unit>
        <trans-unit id="cbffbe0b8b6d1110e3c62d1a5647e0d5355ab572" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows any URL.</source>
          <target state="translated">아니요. 설정하지 않으면 URL이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7968e9f59fc3ea4d8f9120bc13639ba2c96128a" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows anything.</source>
          <target state="translated">아니요. 설정하지 않으면 아무 것도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="43b56bdc9a2f449dd95a29cc4403aabc8d987dfc" translate="yes" xml:space="preserve">
          <source>Node.JS</source>
          <target state="translated">Node.JS</target>
        </trans-unit>
        <trans-unit id="c77a87d79945cb92381e651d3b83555dc60d5cee" translate="yes" xml:space="preserve">
          <source>Nokia N900 Linux mobile, on the Fennec browser</source>
          <target state="translated">Fennec 브라우저의 Nokia N900 Linux 모바일</target>
        </trans-unit>
        <trans-unit id="4b8c1db000b37532ee78f68154fa3781e4c83d96" translate="yes" xml:space="preserve">
          <source>Non-DAV-aware proxies will not honor the If header, since they will
   not understand the If header, and HTTP requires non-understood
   headers to be ignored.  When communicating with HTTP/1.1 proxies, the
   client MUST use the &quot;Cache-Control: no-cache&quot; request header so as to
   prevent the proxy from improperly trying to service the request from
   its cache.  When dealing with HTTP/1.0 proxies, the &quot;Pragma: no-
   cache&quot; request header MUST be used for the same reason.

   Because in general clients may not be able to reliably detect non-
   DAV-aware intermediates, they are advised to always prevent caching
   using the request directives mentioned above.</source>
          <target state="translated">DAV를 인식하지 않는 프록시는 If 헤더를 이해하지 못하므로 If 헤더를 존중하지 않으며 HTTP는 이해할 수없는 헤더를 무시해야합니다. HTTP / 1.1 프록시와 통신 할 때 클라이언트는 &quot;캐시 제어 : 캐시 없음&quot;요청 헤더를 사용하여 프록시가 캐시에서 요청을 부적절하게 서비스하지 못하도록해야합니다. HTTP / 1.0 프록시를 다룰 때 같은 이유로 &quot;Pragma : no-cache&quot;요청 헤더를 사용해야합니다. 일반적으로 클라이언트는 DAV를 인식하지 않는 중간체를 안정적으로 감지하지 못할 수 있으므로 위에서 언급 한 요청 지시문을 사용하여 캐싱을 항상 방지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b75bcc6b482971118032246352667713443b845" translate="yes" xml:space="preserve">
          <source>Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after a preflighted request, some browsers currently will report an error message such as the following.</source>
          <target state="translated">모든 브라우저가 현재 사전 요청 후 다음 리디렉션을 지원하지는 않습니다. 프리 플라이트 요청 후 리디렉션이 발생하면 일부 브라우저는 현재 다음과 같은 오류 메시지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="cf38fd002847999f4fcff82b501a332885b56449" translate="yes" xml:space="preserve">
          <source>Not all types of HTTP requests can be pipelined: only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt; methods, that is &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, can be replayed safely: should a failure happen, the pipeline content can simply be repeated.</source>
          <target state="translated">모든 유형의 HTTP 요청을 파이프 라인 할 수있는 것은 아닙니다. &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 라는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;dem 등원&lt;/a&gt; 메소드 만 안전하게 재생할 수 있습니다. 장애가 발생하면 파이프 라인 컨텐츠를 간단히 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10691f4c6439e42e1fb5e5f7a828b53b02a4fd2a" translate="yes" xml:space="preserve">
          <source>Not many: the choices are listed in an HTML page in the body. Could be served with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">많지 않음 : 선택 사항이 본문의 HTML 페이지에 나열됩니다. &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36e6c8b66ebeebd54bd9a904c7fbeea61aee185c" translate="yes" xml:space="preserve">
          <source>Not part of any current specification. The standardized version of this header is &lt;a href=&quot;forwarded&quot;&gt;&lt;code&gt;Forwarded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 사양의 일부가 아닙니다. 이 헤더의 표준화 된 버전은 &lt;a href=&quot;forwarded&quot;&gt; &lt;code&gt;Forwarded&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1500ffdc7dad0acff37ead2e9bc7fa9274c76bf3" translate="yes" xml:space="preserve">
          <source>Not part of any current specifications. An explainer of the ideas behind this header can be found in &lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;this document&lt;/a&gt;.</source>
          <target state="translated">현재 사양의 일부가 아닙니다. 이 헤더 뒤에있는 아이디어에 대한 설명은 &lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;이 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4de1afe5413225e5f1765ec1032b7844a5f2454" translate="yes" xml:space="preserve">
          <source>Not part of any specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ef8eb2962577a32c14b0ab70a829a6c4372bb9" translate="yes" xml:space="preserve">
          <source>Not part of any specifications or drafts.</source>
          <target state="translated">사양이나 초안의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7da173654def19a4d625df2150ac9e2fae338ac" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests until Firefox 58, see &lt;a href=&quot;https://bugzil.la/446344&quot;&gt;bug 446344&lt;/a&gt;.</source>
          <target state="translated">Firefox 58까지 &lt;code&gt;POST&lt;/code&gt; 요청 과 함께 전송되지 않습니다 ( &lt;a href=&quot;https://bugzil.la/446344&quot;&gt;버그 446344&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="37cdc0eab1650d512c35c0138237e99aeced5b05" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests, see &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;bug 10482384&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 요청 과 함께 전송되지 않습니다 ( &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;버그 10482384&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="50453dd141739f1c493d302dd3803fa4331745be" translate="yes" xml:space="preserve">
          <source>Not tracking.</source>
          <target state="translated">추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="e3a2dfaed75d27647860fc3263ef2225f1db15d5" translate="yes" xml:space="preserve">
          <source>Note that 'allprop', despite its name, which remains for backward-
   compatibility, does not return every property, but only dead
   properties and the live properties defined in this specification.

   &amp;gt;&amp;gt;Request

     PROPFIND /container/ HTTP/1.1
     Host: www.example.com
     Depth: 1
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
     &amp;lt;/D:propfind&amp;gt;


   &amp;gt;&amp;gt;Response

     HTTP/1.1 207 Multi-Status
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:multistatus xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type A&amp;lt;/R:BoxType&amp;gt;&amp;lt;/R:bigbox&amp;gt;
             &amp;lt;R:author&amp;gt;&amp;lt;R:Name&amp;gt;Hadrian&amp;lt;/R:Name&amp;gt;&amp;lt;/R:author&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T17:42:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example collection&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:resourcetype&amp;gt;&amp;lt;D:collection/&amp;gt;&amp;lt;/D:resourcetype&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt; 

           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/front.html&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type B&amp;lt;/R:BoxType&amp;gt;
             &amp;lt;/R:bigbox&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T18:27:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example HTML resource&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:getcontentlength&amp;gt;4525&amp;lt;/D:getcontentlength&amp;gt;
             &amp;lt;D:getcontenttype&amp;gt;text/html&amp;lt;/D:getcontenttype&amp;gt;
             &amp;lt;D:getetag&amp;gt;&quot;zzyzx&quot;&amp;lt;/D:getetag&amp;gt;
             &amp;lt;D:getlastmodified
               &amp;gt;Mon, 12 Jan 1998 09:25:56 GMT&amp;lt;/D:getlastmodified&amp;gt;
             &amp;lt;D:resourcetype/&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt;
           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
     &amp;lt;/D:multistatus&amp;gt;

   In this example, PROPFIND was invoked on the resource
   http://www.example.com/container/ with a Depth header of 1, meaning
   the request applies to the resource and its children, and a propfind
   XML element containing the allprop XML element, meaning the request
   should return the name and value of all the dead properties defined
   on the resources, plus the name and value of all the properties
   defined in this specification.  This example illustrates the use of
   relative references in the 'href' elements of the response.

   The resource http://www.example.com/container/ has six properties
   defined on it: 'bigbox' and 'author in the
   &quot;http://ns.example.com/boxschema/&quot; namespace, DAV:creationdate, DAV:
   displayname, DAV:resourcetype, and DAV:supportedlock. 

   The last four properties are WebDAV-specific, defined in &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;.
   Since GET is not supported on this resource, the get* properties
   (e.g., DAV:getcontentlength) are not defined on this resource.  The
   WebDAV-specific properties assert that &quot;container&quot; was created on
   December 1, 1997, at 5:42:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example collection&quot; (DAV:
   displayname), a collection resource type (DAV:resourcetype), and
   supports exclusive write and shared write locks (DAV:supportedlock).

   The resource http://www.example.com/container/front.html has nine
   properties defined on it:

   'bigbox' in the &quot;http://ns.example.com/boxschema/&quot; namespace (another
   instance of the &quot;bigbox&quot; property type), DAV:creationdate, DAV:
   displayname, DAV:getcontentlength, DAV:getcontenttype, DAV:getetag,
   DAV:getlastmodified, DAV:resourcetype, and DAV:supportedlock.

   The DAV-specific properties assert that &quot;front.html&quot; was created on
   December 1, 1997, at 6:27:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example HTML resource&quot; (DAV:
   displayname), a content length of 4525 bytes (DAV:getcontentlength),
   a MIME type of &quot;text/html&quot; (DAV:getcontenttype), an entity tag of
   &quot;zzyzx&quot; (DAV:getetag), was last modified on Monday, January 12, 1998,
   at 09:25:56 GMT (DAV:getlastmodified), has an empty resource type,
   meaning that it is not a collection (DAV:resourcetype), and supports
   both exclusive write and shared write locks (DAV:supportedlock).</source>
          <target state="translated">이전 버전과의 호환성을 위해 남아있는 이름에도 불구하고 'allprop'는 모든 속성을 반환하지는 않으며이 사양에 정의 된 죽은 속성과 라이브 속성 만 반환합니다. &amp;gt;&amp;gt; PROPFIND 요청 / container / HTTP / 1.1 호스트 : www.example.com 깊이 : 1 Content-Type : application / xml; charset = &quot;utf-8&quot;Content-Length : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : allprop /&amp;gt; &amp;lt;/ D : propfind&amp;gt; &amp;gt;&amp;gt; 응답 HTTP / 1.1 207 다중 상태 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;콘텐츠 길이 : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : multistatus xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : response&amp;gt;&amp;lt;D : href&amp;gt; / container / &amp;lt;/ D : href&amp;gt; &amp;lt;D : propstat&amp;gt; &amp;lt;D : prop xmlns : R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R : bigbox&amp;gt; &amp;lt;R : BoxType&amp;gt; 상자 유형 A &amp;lt;/ R : BoxType&amp;gt; &amp;lt;/ R : bigbox&amp;gt; &amp;lt;R : author&amp;gt; &amp;lt;R : Name&amp;gt; Hadrian &amp;lt;/ R : Name&amp;gt; &amp;lt;/ R : author&amp;gt; &amp;lt;D : creationdate&amp;gt; 1997-12-01T17 : 42 : 21-08 : 00 &amp;lt;/ D : creationdate&amp;gt; &amp;lt;D : displayname&amp;gt; 예제 컬렉션 &amp;lt;/ D : displayname&amp;gt; &amp;lt;D : resourcetype&amp;gt; &amp;lt;D : collection /&amp;gt; &amp;lt;/ D : resourcetype&amp;gt; &amp;lt;D : supportedlock&amp;gt; &amp;lt; D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : exclusive /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;D :lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : shared /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;/ D : supportedlock&amp;gt; &amp;lt;/ D : 잠금&amp;gt; D : prop&amp;gt; &amp;lt;D : status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D : status&amp;gt; &amp;lt;/ D : propstat&amp;gt; &amp;lt;/ D : response&amp;gt; &amp;lt;D : response&amp;gt; &amp;lt;D : href&amp;gt; /container/front.html &amp;lt;/ D : href&amp;gt; &amp;lt;D : propstat&amp;gt; &amp;lt;D : prop xmlns : R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R : bigbox&amp;gt; &amp;lt;R : BoxType&amp;gt; 상자 유형 B &amp;lt;/ R : BoxType &amp;gt; &amp;lt;/ R : bigbox&amp;gt; &amp;lt;D : creationdate&amp;gt; 1997-12-01T18 : 27 : 21-08 : 00 &amp;lt;/ D : creationdate&amp;gt; &amp;lt;D : displayname&amp;gt; HTML 리소스 예 &amp;lt;/ D : displayname&amp;gt; &amp;lt;D :getcontentlength&amp;gt; 4525 &amp;lt;/ D : getcontentlength&amp;gt; &amp;lt;D : getcontenttype&amp;gt; text / html &amp;lt;/ D : getcontenttype&amp;gt; &amp;lt;D : getetag&amp;gt; &quot;zzyzx&quot;&amp;lt;/ D : getetag&amp;gt; &amp;lt;D : getlastmodified&amp;gt; 1998 년 1 월 12 일 09:25 : 56 GMT &amp;lt;/ D : getlastmodified&amp;gt; &amp;lt;D : resourcetype /&amp;gt; &amp;lt;D : supportedlock&amp;gt; &amp;lt;D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : exclusive /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : 쓰기 /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : shared /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;/ D : supportedlock&amp;gt;&amp;lt;/ D : prop&amp;gt; &amp;lt;D : status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D : status&amp;gt; &amp;lt;/ D : propstat&amp;gt; &amp;lt;/ D : response&amp;gt; &amp;lt;/ D : multistatus&amp;gt;이 예에서 PROPFIND는 자원에서 호출되었습니다. 깊이 헤더가 1 인 http://www.example.com/container/ : 요청이 자원 및 해당 하위 항목에 적용되고 allprop XML 요소가 포함 된 propfind XML 요소 (요청이 이름과 값을 리턴해야 함)를 의미 함 자원에 정의 된 모든 죽은 특성과이 스펙에 정의 된 모든 특성의 이름 및 값. 이 예는 응답의 'href'요소에서 상대 참조를 사용하는 것을 보여줍니다. http://www.example.com/container/ 리소스에는 'bigbox'및 ''&quot;http://ns.example.com/boxschema/&quot;네임 스페이스의 작성자, DAV : creationdate, DAV : 표시 이름, DAV : resourcetype 및 DAV : supportedlock 마지막 네 가지 속성은 WebDAV에 따라 다릅니다.&lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt;. 이 자원에서 GET이 지원되지 않으므로 get * 특성 (예 : DAV : getcontentlength)이이 자원에서 정의되지 않습니다. WebDAV 관련 속성은 &quot;컨테이너&quot;가 1997 년 12 월 1 일 오후 5:42:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate) 시간대에 만들어졌으며 &quot;예제 수집&quot;(DAV)이라는 이름을 가지고 있다고 주장합니다. : 표시 이름), 콜렉션 자원 유형 (DAV : resourcetype)이며 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 지원합니다. http://www.example.com/container/front.html 리소스에는 9 개의 속성이 정의되어 있습니다. &quot;http://ns.example.com/boxschema/&quot;네임 스페이스의 'bigbox'( &quot; bigbox &quot;속성 유형), DAV : 작성 날짜, DAV : 표시 이름, DAV : getcontentlength, DAV : getcontenttype, DAV : getetag, DAV :getlastmodified, DAV : resourcetype 및 DAV : supportedlock. DAV 관련 속성은 &quot;front.html&quot;이 1997 년 12 월 1 일 6:27:21 PM에 GMT에서 서쪽으로 8 시간 (DAV : creationdate) 표준 시간대에 만들어졌으며 &quot;HTML 리소스 예&quot;라는 이름을 갖습니다. &quot;(DAV : 표시 이름)&quot;, 콘텐츠 길이 4525 바이트 (DAV : getcontentlength), &quot;text / html&quot;(DAV : getcontenttype)의 MIME 유형, &quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그가 마지막으로 수정되었습니다. 1998 년 1 월 12 일 월요일, 09:25:56 GMT (DAV : getlastmodified)에 비어있는 자원 유형이 있으며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 ( DAV : supportedlock).1997 년 12 월 1 일 오후 6:27:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate)에 이름이 &quot;예제 HTML 리소스&quot;(DAV : 표시 이름)이며 콘텐츠 길이는 4525입니다. &quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 &quot;text / html&quot;(DAV : getcontenttype)의 MIME 유형 인 바이트 (DAV : getcontentlength)는 1998 년 1 월 12 일 월요일 09:25에 마지막으로 수정되었습니다. : 56 GMT (DAV : getlastmodified)는 빈 자원 유형을 가지며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.1997 년 12 월 1 일 오후 6:27:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate)에 이름이 &quot;예제 HTML 리소스&quot;(DAV : 표시 이름)이며 콘텐츠 길이는 4525입니다. &quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 &quot;text / html&quot;(DAV : getcontenttype)의 MIME 유형 인 바이트 (DAV : getcontentlength)는 1998 년 1 월 12 일 월요일 09:25에 마지막으로 수정되었습니다. : 56 GMT (DAV : getlastmodified)는 빈 자원 유형을 가지며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.&quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 text / html &quot;(DAV : getcontenttype)은 1998 년 1 월 12 일 월요일 오전 9시 25 분 56 초 (GMT) (DAV : getlastmodified)에 비어 있습니다. 자원 유형. 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.&quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 text / html &quot;(DAV : getcontenttype)은 1998 년 1 월 12 일 월요일 오전 9시 25 분 56 초 (GMT) (DAV : getlastmodified)에 비어 있습니다. 자원 유형. 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="733da1ea06ac6c1e1c6fc58cd54e3b6560771890" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is actually a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="translated">&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 는 실제로 &quot;referrer&quot;라는 단어의 철자 가 틀립니다 . &lt;code&gt;Referrer-Policy&lt;/code&gt; 헤더이 오자를 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88907399933c092ee116572f07a09e971f2ea48c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;text/plain&lt;/code&gt; does not mean &lt;em&gt;any kind of textual data&lt;/em&gt;. If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a &lt;code&gt;text/plain&lt;/code&gt; file from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element declaring a CSS files, they will not recognize it as a valid CSS files if presented with &lt;code&gt;text/plain&lt;/code&gt;. The CSS mime type &lt;code&gt;text/css&lt;/code&gt; must be used.</source>
          <target state="translated">참고 것을 &lt;code&gt;text/plain&lt;/code&gt; 의미하지 않는다 &lt;em&gt;텍스트 데이터의 종류&lt;/em&gt; . 특정 종류의 텍스트 데이터를 기대하면 일치하는 것으로 간주하지 않을 것입니다. 그들이 다운로드 특히 경우 &lt;code&gt;text/plain&lt;/code&gt; A로부터 파일을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 되게 경우 CSS 파일을 선언하는 요소는, 그들은 유효한 CSS 파일로 인식되지 않습니다 &lt;code&gt;text/plain&lt;/code&gt; . CSS mime 유형 &lt;code&gt;text/css&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9dc294e0815213796bc980c17d902a5389831b1" translate="yes" xml:space="preserve">
          <source>Note that certain headers are &lt;em&gt;always&lt;/em&gt; allowed: &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;). These are called the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;simple headers&lt;/a&gt;, and you don't need to specify them explicitly.</source>
          <target state="translated">참고 특정 헤더가되도록 &lt;em&gt;항상&lt;/em&gt; 허용 : &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; (만의 구문 분석 된 값의 MIME 타입 중 하나의 (무시 매개 변수) &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; 또는 &lt;code&gt;text/plain&lt;/code&gt; ). 이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;단순 헤더&lt;/a&gt; 라고하며 명시 적으로 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dde5258cb287b7e5f1335b4b8968fc964826436" translate="yes" xml:space="preserve">
          <source>Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from &lt;code&gt;foo.example&lt;/code&gt;, but the cookie on line 22 is sent by &lt;code&gt;bar.other&lt;/code&gt;, and would thus not be saved if the user has configured their browser to reject all third-party cookies.</source>
          <target state="translated">CORS 응답에 설정된 쿠키에는 일반적인 타사 쿠키 정책이 적용됩니다. 위의 예에서 페이지는 &lt;code&gt;foo.example&lt;/code&gt; 에서 로드 되지만 22 행의 쿠키는 &lt;code&gt;bar.other&lt;/code&gt; 에 의해 전송 되므로 사용자가 브라우저를 모든 타사 쿠키를 거부하도록 구성한 경우 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2f243d962235cf432887667d07e758583b705da" translate="yes" xml:space="preserve">
          <source>Note that in any access control request, the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header is &lt;strong&gt;always&lt;/strong&gt; sent.</source>
          <target state="translated">모든 액세스 제어 요청에서 &lt;strong&gt;항상 &lt;/strong&gt;&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더가 전송됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c4aaaf9288e658776e9fcfd33685b0df524267a" translate="yes" xml:space="preserve">
          <source>Note that in the case of credentialed requests, the &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; header &lt;strong&gt;must not&lt;/strong&gt; have a wildcard value of &quot;*&quot;. It &lt;strong&gt;must&lt;/strong&gt; mention a valid origin domain. The example above can be seen &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;running here&lt;/a&gt;.</source>
          <target state="translated">자격 증명 요청의 경우 &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; 헤더 에는 &quot;*&quot;와일드 카드 값이 &lt;strong&gt;없어야합니다&lt;/strong&gt; . 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 유효한 원래 도메인을 언급. 위 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기&lt;/a&gt; 에서 실행되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13d83d306a8b3e2d42d4c3ab70727c3afb42e937" translate="yes" xml:space="preserve">
          <source>Note that inline event handlers are blocked as well:</source>
          <target state="translated">인라인 이벤트 핸들러도 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="482d5e7da59888db6e881351a22dd4cf2b2344da" translate="yes" xml:space="preserve">
          <source>Note that now, no domain other than &lt;code&gt;http://foo.example&lt;/code&gt; (identified by the ORIGIN: header in the request, as in line 10 above) can access the resource in a cross-site manner. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header should contain the value that was sent in the request's &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">이제 &lt;code&gt;http://foo.example&lt;/code&gt; 이외의 도메인 (위의 10 행에서와 같이 요청에서 ORIGIN : 헤더로 식별) 이외의 도메인 은 사이트 간 방식으로 자원에 액세스 할 수 없습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더는 요청의 전송 된 값이 포함되어야 &lt;code&gt;Origin&lt;/code&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="ceb9adaebb159a4870cdc204a80a7efec8b3349e" translate="yes" xml:space="preserve">
          <source>Note that referer is actually a misspelling of the word &quot;referrer&quot;. See &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;HTTP referer on Wikipedia&lt;/a&gt; for more details.</source>
          <target state="translated">referer는 실제로 &quot;referrer&quot;라는 단어의 철자가 틀립니다. 자세한 내용 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;은 Wikipedia의 HTTP referer&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e77f5478415d507325d52c5303120a20756b6b78" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Set-Cookie&lt;/code&gt; response header in the example above also sets a further cookie. In case of failure, an exception&amp;mdash;depending on the API used&amp;mdash;is raised.</source>
          <target state="translated">위 예제 의 &lt;code&gt;Set-Cookie&lt;/code&gt; 응답 헤더는 추가 쿠키를 설정합니다. 실패한 경우 사용 된 API에 따라 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bd9d3cba4ca919c6212e4317b95019fb2ffe615" translate="yes" xml:space="preserve">
          <source>Note that the HTTP response headers &quot;Etag&quot; and &quot;Last-Modified&quot; (see
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], Sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; and &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;) are defined per URL (not per
   resource), and are used by clients for caching.  Therefore servers
   must ensure that executing any operation that affects the URL
   namespace (such as COPY, MOVE, DELETE, PUT, or MKCOL) does preserve
   their semantics, in particular: 

   o  For any given URL, the &quot;Last-Modified&quot; value MUST increment every
      time the representation returned upon GET changes (within the
      limits of timestamp resolution).

   o  For any given URL, an &quot;ETag&quot; value MUST NOT be reused for
      different representations returned by GET.

   In practice this means that servers

   o  might have to increment &quot;Last-Modified&quot; timestamps for every
      resource inside the destination namespace of a namespace operation
      unless it can do so more selectively, and

   o  similarly, might have to re-assign &quot;ETag&quot; values for these
      resources (unless the server allocates entity tags in a way so
      that they are unique across the whole URL namespace managed by the
      server).

   Note that these considerations also apply to specific use cases, such
   as using PUT to create a new resource at a URL that has been mapped
   before, but has been deleted since then.

   Finally, WebDAV properties (such as DAV:getetag and DAV:
   getlastmodified) that inherit their semantics from HTTP headers must
   behave accordingly.</source>
          <target state="translated">HTTP 응답 헤더 &quot;Etag&quot;및 &quot;Last-Modified&quot;([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], 섹션 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; 및 &lt;a href=&quot;#section-14.29&quot;&gt;14.29 참조)&lt;/a&gt;)은 URL별로 (리소스별로가 아님) 정의되며 클라이언트가 캐싱에 사용합니다. 따라서 서버는 URL 네임 스페이스에 영향을 미치는 작업 (예 : COPY, MOVE, DELETE, PUT 또는 MKCOL)을 실행하면 시맨틱이 다음과 같은 의미를 유지하도록해야합니다. GET에 따라 반환 된 표현이 변경 될 때마다 (타임 스탬프 해상도 제한 내) o 주어진 URL의 경우, &quot;ETag&quot;값은 GET이 반환 한 다른 표현에 재사용해서는 안됩니다. 실제로 이것은 서버가 네임 스페이스 작업의 대상 네임 스페이스 내의 모든 리소스에 대해 &quot;마지막으로 수정 된&quot;타임 스탬프를 더 선택적으로 또는 유사하게 수행 할 수없는 경우가 아니면 증가시켜야 할 수도 있음을 의미합니다서버가 서버가 관리하는 전체 URL 네임 스페이스에서 고유 한 방식으로 엔티티 태그를 할당하지 않는 한 이러한 자원에 대해 &quot;ETag&quot;값을 다시 할당해야 할 수도 있습니다. 이러한 고려 사항은 PUT을 사용하여 이전에 매핑되었지만 그 이후 삭제 된 URL에서 새 리소스를 만드는 등의 특정 사용 사례에도 적용됩니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.예를 들어 PUT을 사용하여 이전에 매핑되었지만 그 이후로 삭제 된 URL에서 새 리소스를 만드는 등의 작업을 수행 할 수 있습니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.예를 들어 PUT을 사용하여 이전에 매핑되었지만 그 이후로 삭제 된 URL에서 새 리소스를 만드는 등의 작업을 수행 할 수 있습니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="524a5391e04da5188d8d6239340a145a47bbb106" translate="yes" xml:space="preserve">
          <source>Note that the server is not obligated to use any compression method. Compression highly depends on server settings and used server modules.</source>
          <target state="translated">서버는 압축 방법을 사용할 의무가 없습니다. 압축은 서버 설정 및 사용 된 서버 모듈에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8fc871d77bd2a17b1592fb06f1975897a38785b1" translate="yes" xml:space="preserve">
          <source>Note that these redirections break the back button in a browser: you can go back to a page with this header but it instantaneously moves forward again.</source>
          <target state="translated">이러한 리디렉션은 브라우저에서 뒤로 버튼을 깰 수 있습니다.이 헤더가있는 페이지로 돌아갈 수 있지만 즉시 다시 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c19e315f56095fa3fee06607e90fa58ce789809b" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't specify a &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt;; with the example CSP, this site uses the setting specified by the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, which means that scripts can be loaded only from the originating server.</source>
          <target state="translated">이 예제는 &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; 를&lt;/a&gt; 지정하지 않습니다 . CSP 예제에서이 사이트는 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문에 지정된 설정을 사용 합니다. 즉, 원래 서버에서만 스크립트를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="877bc59b4de188751558af6e41e4cec35b5f4e71" translate="yes" xml:space="preserve">
          <source>Note that using &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and compression at the hop level is so rare that most servers, like Apache, nginx, or IIS, have no easy way to configure it. Such configuration usually happens at the proxy level.</source>
          <target state="translated">사용하는 것을 참고 &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 홉 수준에서 압축하는 대부분의 서버, 아파치, nginx를, 또는 IIS와 같은, 그것을 구성하는 쉬운 방법이 없다 정도로 드물다. 이러한 구성은 일반적으로 프록시 수준에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50344a1423a5adbde9caeb6452a36fbce49d2ef4" translate="yes" xml:space="preserve">
          <source>Note the appropriate headers being sent back in response to the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; preflight as well as to the &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; data. One resource thus handles the preflight as well as the actual request. In the response to the &lt;code&gt;OPTIONS&lt;/code&gt; request, the server notifies the client that the actual request can indeed be made with the &lt;code&gt;POST&lt;/code&gt; method, and header fields such as &lt;code&gt;X-PINGARUNER&lt;/code&gt; can be sent with the actual request. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 프리 플라이트 및 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 데이터 에 대한 응답으로 적절한 헤더가 다시 전송됩니다 . 따라서 하나의 리소스는 실제 요청뿐만 아니라 프리 플라이트도 처리합니다. &lt;code&gt;OPTIONS&lt;/code&gt; 요청에 대한 응답으로, 서버는 클라이언트에게 실제 요청이 실제로 &lt;code&gt;POST&lt;/code&gt; 메소드를 사용하여 수행 될 수 있음을 통지하고 &lt;code&gt;X-PINGARUNER&lt;/code&gt; 와 같은 헤더 필드 가 실제 요청과 함께 전송 될 수 있습니다. 이 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기서 실행되는&lt;/a&gt; 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f9a467b619f845068306fd652ae12e97054ab19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nosniff&lt;/code&gt; only applies to &quot;&lt;code&gt;script&lt;/code&gt;&quot; and &quot;&lt;code&gt;style&lt;/code&gt;&quot; types. Also applying &lt;code&gt;nosniff&lt;/code&gt; to images turned out to be &lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;incompatible with existing web sites&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;nosniff&lt;/code&gt; 는 &quot; &lt;code&gt;script&lt;/code&gt; &quot;및 &quot; &lt;code&gt;style&lt;/code&gt; &quot;유형 에만 적용됩니다 . 또한 이미지에 &lt;code&gt;nosniff&lt;/code&gt; 를 적용 하면 &lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;기존 웹 사이트와 호환되지 않는&lt;/a&gt; 것으로 나타났습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a73e692e8090c4e69881a90ac391d6c2513e11" translate="yes" xml:space="preserve">
          <source>Note: this user agent was retrieved from an iPhone XR simulator and may be different on device.</source>
          <target state="translated">참고 :이 사용자 에이전트는 iPhone XR 시뮬레이터에서 검색되었으며 장치마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d54b40413d81662c3ae8fb48a8db7dac1e55e9" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource doesn't exist:</source>
          <target state="translated">요청한 리소스가 존재하지 않는다는 알림 :</target>
        </trans-unit>
        <trans-unit id="bc2f4cbb79515b85b2c0d07b3e431b778d1e12e4" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource has permanently moved:</source>
          <target state="translated">요청한 자원이 영구적으로 이동했다는 알림 :</target>
        </trans-unit>
        <trans-unit id="cc6b7b178c03549f9e2a165aa485d916c9c4a3c5" translate="yes" xml:space="preserve">
          <source>Now try to reproduce the failing transaction and check the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;console&lt;/a&gt; if you are seeing a CORS violation error message. It will probably look like this:</source>
          <target state="translated">이제 실패한 트랜잭션을 재현하고 CORS 위반 오류 메시지가 표시되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;콘솔을&lt;/a&gt; 확인하십시오 . 아마 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="c64e26807cf49c7d258e3a38b854c3cbcc1da88a" translate="yes" xml:space="preserve">
          <source>Now, if you are logged into your bank account and your cookies are still valid (and there is no other validation), you will transfer money as soon as you load the HTML that contains this image. There are a few techniques that are used to prevent this from happening:</source>
          <target state="translated">이제 은행 계좌에 로그인 한 상태에서 쿠키가 여전히 유효하고 다른 유효성 검사가없는 경우이 이미지가 포함 된 HTML을로드하자마자 송금됩니다. 이를 방지하기 위해 사용되는 몇 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="316d446c2137e3fdd66e7c6a93e085285024a055" translate="yes" xml:space="preserve">
          <source>Now, with every new request to the server, the browser will send back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이제 서버에 대한 모든 새로운 요청이있을 때마다 브라우저는 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 이전에 저장된 모든 쿠키를 서버로 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="7f7f99421dc23022f9d4dad472dad8c1219a1e24" translate="yes" xml:space="preserve">
          <source>Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. Older browsers (ie6, ie7, and ie8) do not support max-age. For other browsers, if both (&lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Max-Age&lt;/code&gt;) are set, &lt;code&gt;Max-Age&lt;/code&gt; will have precedence.</source>
          <target state="translated">쿠키가 만료 될 때까지의 시간 (초)입니다. 0 또는 음수는 쿠키를 즉시 만료시킵니다. 이전 브라우저 (ie6, ie7 및 ie8)는 최대 연령을 지원하지 않습니다. 다른 브라우저의 경우 ( &lt;code&gt;Expires&lt;/code&gt; 및 &lt;code&gt;Max-Age&lt;/code&gt; )가 모두 설정된 경우 &lt;code&gt;Max-Age&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3d83594903f329fd61c74db928326d01462cddbd" translate="yes" xml:space="preserve">
          <source>OGG</source>
          <target state="translated">OGG</target>
        </trans-unit>
        <trans-unit id="abdf49e40c006cace12b860c577ebfd2f514568f" translate="yes" xml:space="preserve">
          <source>OGG audio</source>
          <target state="translated">OGG 오디오</target>
        </trans-unit>
        <trans-unit id="e4b5a3d314e8c7201a4940347e84ecf91f139bbf" translate="yes" xml:space="preserve">
          <source>OGG video</source>
          <target state="translated">OGG 비디오</target>
        </trans-unit>
        <trans-unit id="891db7e7c01ff7470565d35fe04852a76dd5cce8" translate="yes" xml:space="preserve">
          <source>OPR/xyz &lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">OPR / xyz &lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="940af152764ecc453e50e12e715144d6352503d7" translate="yes" xml:space="preserve">
          <source>OPTIONS (RFC 7231)</source>
          <target state="translated">옵션 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="6c906f4846c2cf5d1ef947e89e2af3a972efb9b3" translate="yes" xml:space="preserve">
          <source>OWASP Article: &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">OWASP 기사 : &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="305837b5ab2d13ba142d5f5e5b4aaf80f1816434" translate="yes" xml:space="preserve">
          <source>Observe that final empty line, this separates the data block from the header block. As there is no &lt;code&gt;Content-Length&lt;/code&gt; provided in an HTTP header, this data block is presented empty, marking the end of the headers, allowing the server to process the request the moment it receives this empty line.</source>
          <target state="translated">마지막 빈 줄을 관찰하면 데이터 블록이 헤더 블록과 분리됩니다. HTTP 헤더에 &lt;code&gt;Content-Length&lt;/code&gt; 가 제공 되지 않으므로이 데이터 블록은 비어 있으며 헤더의 끝을 표시하여 서버가이 빈 라인을받는 순간 요청을 처리 할 수 ​​있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="a81ab58e0a7c48e950453b07afbc07c0041ca461" translate="yes" xml:space="preserve">
          <source>Obviously, this method only works with HTML pages (or similar) and cannot be used for images or any other type of content.</source>
          <target state="translated">분명히이 방법은 HTML 페이지 (또는 이와 유사한)에서만 작동하며 이미지 나 다른 유형의 콘텐츠에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="252f4b9010eb27d3590ba7cf70072cb1ff858d02" translate="yes" xml:space="preserve">
          <source>Of course, there is absolutely no guarantee that another browser will not hijack some of these things (like Chrome hijacked the Safari string in the past). That's why browser detection using the user agent string is unreliable and should be done only with the check of the version number (hijacking of past versions is less likely).</source>
          <target state="translated">물론 다른 브라우저가 이러한 것들 중 일부를 납치하지 않을 것이라는 보장은 없습니다 (예 : Chrome이 과거에 Safari 문자열을 납치 한 것처럼). 그렇기 때문에 사용자 에이전트 문자열을 사용한 브라우저 감지는 신뢰할 수 없으며 버전 번호를 확인해야만 수행 할 수 있습니다 (이전 버전의 도용 가능성은 적음).</target>
        </trans-unit>
        <trans-unit id="728f9313847dcc9ab70ed90ce6b11c13e63d839d" translate="yes" xml:space="preserve">
          <source>Officially standardized, in May 2015, HTTP/2 has had much success. By July 2016, 8.7% of all Web sites&lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; were already using it, representing more than 68% of all requests&lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;. High-traffic Web sites showed the most rapid adoption, saving considerably on data transfer overheads and subsequent budgets.</source>
          <target state="translated">2015 년 5 월 공식적으로 표준화 된 HTTP / 2는 많은 성공을 거두었습니다. 2016 년 7 월까지 모든 웹 사이트의 8.7 % 가 이미이를 사용하고 있었으며 &lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 모든 요청의 68 % 이상을 나타 냈습니다 &lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; . 트래픽이 많은 웹 사이트가 가장 빠르게 채택되어 데이터 전송 오버 헤드와 그에 따른 예산을 크게 절약했습니다.</target>
        </trans-unit>
        <trans-unit id="deebb87fa96ee64c661fcfa4f0b7108c7212c6a5" translate="yes" xml:space="preserve">
          <source>Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was not
   terminated by a line-ending.  An HTTP/1.1 user agent MUST NOT preface
   or follow a request with an extra CRLF.  If terminating the request
   message body with a line-ending is desired, then the user agent MUST
   count the terminating CRLF octets as part of the message body length.

   In the interest of robustness, a server that is expecting to receive
   and parse a request-line SHOULD ignore at least one empty line (CRLF)
   received prior to the request-line. 

   Although the line terminator for the start-line and header fields is
   the sequence CRLF, a recipient MAY recognize a single LF as a line
   terminator and ignore any preceding CR.

   Although the request-line and status-line grammar rules require that
   each of the component elements be separated by a single SP octet,
   recipients MAY instead parse on whitespace-delimited word boundaries
   and, aside from the CRLF terminator, treat any form of whitespace as
   the SP separator while ignoring preceding or trailing whitespace;
   such whitespace includes one or more of the following octets: SP,
   HTAB, VT (%x0B), FF (%x0C), or bare CR.  However, lenient parsing can
   result in security vulnerabilities if there are multiple recipients
   of the message and each has its own unique interpretation of
   robustness (see &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the server
   SHOULD respond with a 400 (Bad Request) response.</source>
          <target state="translated">이전 HTTP / 1.0 사용자 에이전트 구현은 줄 끝으로 끝나지 않은 메시지 본문 내용을 읽지 못한 일부 초기 서버 응용 프로그램에 대한 해결 방법으로 POST 요청 후 추가 CRLF를 보낼 수 있습니다. HTTP / 1.1 사용자 에이전트는 추가 CRLF로 요청을 시작하거나 따라 가지 않아야합니다. 줄 끝으로 요청 메시지 본문을 종료해야하는 경우 사용자 에이전트는 메시지 본문 길이의 일부로 종료 CRLF 옥텟을 계산해야합니다. 견고성을 위해, 요청 라인을 수신하고 파싱 할 것으로 예상되는 서버는 요청 라인 이전에 수신 된 적어도 하나의 빈 라인 (CRLF)을 무시해야한다. 시작 라인 및 헤더 필드에 대한 라인 종결자가 시퀀스 CRLF이지만, 수신자는 단일 LF를 라인 종결 자로 인식하고 선행 CR을 무시할 수 있습니다.요청 라인 및 상태 라인 문법 규칙에 따라 각 구성 요소가 단일 SP 8 진수로 분리되어야하지만 수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 종료자를 제외하고 모든 형태의 공백을 선행 또는 후행 공백을 무시하면서 SP 분리기; 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 터미네이터를 제외하고 선행 또는 후행 공백을 무시하면서 모든 형식의 공백을 SP 구분자로 처리 할 수 ​​있습니다. 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 터미네이터를 제외하고 선행 또는 후행 공백을 무시하면서 모든 형식의 공백을 SP 구분자로 처리 할 수 ​​있습니다. 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조&lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; ). 서버가 HTTP 요청 메시지만을 수신하거나 시작 라인에서 HTTP 요청 메시지로 처리되는 것을 처리 할 때 위에 나열된 견고성 예외를 제외하고 HTTP 메시지 문법과 일치하지 않는 일련의 8 진수를 수신합니다. 400 (잘못된 요청) 응답으로 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="eccaba534ca9f5591f571f69a93afec9e199b19d" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the fixed string &quot;&lt;code&gt;20100101&lt;/code&gt;&quot;</source>
          <target state="translated">데스크탑에서 &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; 은 고정 문자열 &quot; &lt;code&gt;20100101&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dc422faa1ec0593c27e5dd94351848b8f4c22acb" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt; is the fixed string &quot;20100101&quot;</source>
          <target state="translated">데스크탑에서 &lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt; 은 고정 문자열 &quot;20100101&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3c55762a68b0fe67eed8220b92fc45172bf563b7" translate="yes" xml:space="preserve">
          <source>On the client side, you can advertise a list of compression schemes that will be sent along in an HTTP request. The &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header is used for negotiating content encoding.</source>
          <target state="translated">클라이언트 측에서는 HTTP 요청과 함께 전송 될 압축 체계 목록을 광고 할 수 있습니다. &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 콘텐츠 인코딩을 협상을 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a2d4459ba0ff06a3947af0742918817fc3eb06" translate="yes" xml:space="preserve">
          <source>On the opposite side of the communication channel, is the server which &lt;em&gt;serves&lt;/em&gt; the document as requested by the client. A server presents only as a single machine virtually: this is because it may actually be a collection of servers, sharing the load (load balancing) or a complex piece of software interrogating other computers (like cache, a DB server, e-commerce servers, &amp;hellip;), totally or partially generating the document on demand.</source>
          <target state="translated">통신 채널의 반대편 에는 클라이언트가 요청한대로 문서 를 &lt;em&gt;제공&lt;/em&gt; 하는 서버가 &lt;em&gt;있습니다&lt;/em&gt; . 서버는 사실상 단일 머신으로 만 제공됩니다. 실제로 서버 모음,로드 공유 (로드 밸런싱) 또는 다른 컴퓨터 (캐시, DB 서버, 전자 상거래 서버 등)를 조사하는 복잡한 소프트웨어 일 수 있기 때문입니다. ,&amp;hellip;), 필요에 따라 문서를 완전히 또는 부분적으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f66620c684e8eb3de3262130d1e274b88e19dc70" translate="yes" xml:space="preserve">
          <source>On the other hand, &quot;private&quot; indicates that the response is intended for a single user only and must not be stored by a shared cache. A private browser cache may store the response in this case.</source>
          <target state="translated">반면, &quot;비공개&quot;는 응답이 단일 사용자만을위한 것이며 공유 캐시에 저장되어서는 안됨을 나타냅니다. 이 경우 개인 브라우저 캐시는 응답을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2b9186180061f8add8f4849f50a8d8fdd4125d" translate="yes" xml:space="preserve">
          <source>On the standard track</source>
          <target state="translated">표준 트랙에서</target>
        </trans-unit>
        <trans-unit id="7a52b249e2a4a19c25945f39f4219130ebc33285" translate="yes" xml:space="preserve">
          <source>Once a Resource has been created and its Member URI is known, that
   URI can be used to retrieve, edit, and delete the Resource.  &lt;a href=&quot;#section-11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; describes extensions to the Atom Syndication Format used in the
   Atom Protocol for editing purposes.</source>
          <target state="translated">자원이 작성되고 구성원 URI가 알려지면 해당 URI를 사용하여 자원을 검색, 편집 및 삭제할 수 있습니다. &lt;a href=&quot;#section-11&quot;&gt;11 &lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;장&lt;/a&gt; 에서는 편집을 위해 Atom 프로토콜에서 사용되는 Atom 신디케이션 형식의 확장에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1157586853a498fecd0d5788bdf7e2636f066412" translate="yes" xml:space="preserve">
          <source>Once a resource is stored in a cache, it could theoretically be served by the cache forever. Caches have finite storage so items are periodically removed from storage. This process is called &lt;em&gt;cache eviction&lt;/em&gt;. On the other side, some resources may change on the server so the cache should be updated. As HTTP is a client-server protocol, servers can't contact caches and clients when a resource changes; they have to communicate an expiration time for the resource. Before this expiration time, the resource is &lt;em&gt;fresh&lt;/em&gt;; after the expiration time, the resource is &lt;em&gt;stale&lt;/em&gt;. Eviction algorithms often privilege fresh resources over stale resources. Note that a stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it forwards this request with a &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; to check if it is in fact still fresh. If so, the server returns a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) header without sending the body of the requested resource, saving some bandwidth.</source>
          <target state="translated">일단 리소스가 캐시에 저장되면 이론적으로 캐시가 영원히 서비스를 제공 할 수 있습니다. 캐시에는 한정된 저장소가 있으므로 항목이 저장소에서 주기적으로 제거됩니다. 이 과정을 &lt;em&gt;캐시 제거&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 반면에 일부 리소스는 서버에서 변경 될 수 있으므로 캐시를 업데이트해야합니다. HTTP는 클라이언트-서버 프로토콜이므로 리소스가 변경 될 때 서버는 캐시와 클라이언트에 접속할 수 없습니다. 그들은 자원의 만료 시간을 전달해야합니다. 이 만료 시간 전에 리소스가 &lt;em&gt;최신 상태입니다&lt;/em&gt; . 만료 시간이 지나면 리소스가 &lt;em&gt;오래되었습니다&lt;/em&gt;. 제거 알고리즘은 종종 오래된 리소스보다 새로운 리소스에 권한을 부여합니다. 부실 리소스는 제거되거나 무시되지 않습니다. 캐시는 오래된 리소스에 대한 요청을 받으면이 요청을 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 와 함께 전달 하여 실제로 최신 상태인지 확인합니다. 그렇다면 서버는 요청 된 리소스의 본문을 보내지 않고 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; (수정되지 않음) 헤더를 반환하여 대역폭을 절약합니다.</target>
        </trans-unit>
        <trans-unit id="d79e1072067e9270a5021d23e2d543ff572b05d8" translate="yes" xml:space="preserve">
          <source>Once a user has overridden the server-chosen language, a site should no longer use language detection and should stick with the explicitly-chosen language. In other words, only entry pages of a site should select the proper language using this header.</source>
          <target state="translated">사용자가 서버가 선택한 언어를 재정의하면 사이트에서 더 이상 언어 감지 기능을 사용하지 않아야하며 명시 적으로 선택된 언어를 사용해야합니다. 즉, 사이트의 시작 페이지 만이 헤더를 사용하여 적절한 언어를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="8571c0f2c52762afed434f53c93e37e6519192e0" translate="yes" xml:space="preserve">
          <source>Once an inbound connection is obtained, the client sends an HTTP
   request message (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) with a request-target derived from the
   target URI.  There are four distinct formats for the request-target,
   depending on both the method being requested and whether the request
   is to a proxy.

     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form</source>
          <target state="translated">인바운드 연결이 확보되면 클라이언트는 대상 URI에서 파생 된 요청 대상과 함께 HTTP 요청 메시지 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; )를 보냅니다 . 요청되는 메소드와 요청이 프록시에 대한 것인지 여부에 따라 요청 대상에 대해 4 가지 개별 형식이 있습니다. 요청 대상 = 원산지 양식 / 절대 양식 / 권한 양식 / 별표 양식</target>
        </trans-unit>
        <trans-unit id="90dcbb9bf6b3864e512e171d7b57669e95d50401" translate="yes" xml:space="preserve">
          <source>Once the TLS handshake is complete, the original request will be responded to as normal.</source>
          <target state="translated">TLS 핸드 셰이크가 완료되면 원래 요청이 정상적으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="555084494ae9b3d3ddba4fd675d1b872eb531308" translate="yes" xml:space="preserve">
          <source>Once the connection is established, the user-agent can send the request (a user-agent is typically a web browser, but can be anything else, a crawler, for example). A client request consists of text directives, separated by CRLF (carriage return, followed by line feed), divided into three blocks:</source>
          <target state="translated">연결이 설정되면 사용자 에이전트는 요청을 보낼 수 있습니다 (사용자 에이전트는 일반적으로 웹 브라우저이지만 크롤러와 같은 다른 도구 일 수 있음). 클라이언트 요청은 CRLF (캐리지 리턴, 줄 바꿈)로 구분 된 텍스트 지시문으로 구성되며 다음 세 블록으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="c2dcba3e69f215847ccd37ccdc0e122ddb02db7e" translate="yes" xml:space="preserve">
          <source>Once the preflight request is complete, the real request is sent:</source>
          <target state="translated">프리 플라이트 요청이 완료되면 실제 요청이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9ae143a5ad6f92b100c0c78400768cc4838d90" translate="yes" xml:space="preserve">
          <source>Once the target URI is determined, a client needs to decide whether a
   network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.

   If the client has a cache [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] and the request can be satisfied
   by it, then the request is usually directed there first.

   If the request is not satisfied by a cache, then a typical client
   will check its configuration to determine whether a proxy is to be
   used to satisfy the request.  Proxy configuration is implementation-
   dependent, but is often based on URI prefix matching, selective
   authority matching, or both, and the proxy itself is usually
   identified by an &quot;http&quot; or &quot;https&quot; URI.  If a proxy is applicable,
   the client connects inbound by establishing (or reusing) a connection
   to that proxy.

   If no proxy is applicable, a typical client will invoke a handler
   routine, usually specific to the target URI's scheme, to connect
   directly to an authority for the target resource.  How that is
   accomplished is dependent on the target URI scheme and defined by its
   associated specification, similar to how this specification defines
   origin server access for resolution of the &quot;http&quot; (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) and
   &quot;https&quot; (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) schemes.

   HTTP requirements regarding connection management are defined in
   &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.</source>
          <target state="translated">대상 URI가 결정되면 클라이언트는 원하는 의미를 달성하기 위해 네트워크 요청이 필요한지 여부와 필요한 경우 해당 요청이 전달되는 위치를 결정해야합니다. 클라이언트에 캐시가있는 경우 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]로 요청을 충족시킬 수 있으며 일반적으로 요청이 먼저 전달됩니다. 요청이 캐시에 의해 충족되지 않으면 일반 클라이언트는 구성을 확인하여 프록시를 사용하여 요청을 충족 시킬지 여부를 결정합니다. 프록시 구성은 구현에 따라 다르지만 종종 URI 접두사 일치, 선택적 권한 일치 또는 둘 다를 기반으로하며 프록시 자체는 일반적으로 &quot;http&quot;또는 &quot;https&quot;URI로 식별됩니다. 프록시가 적용 가능한 경우 클라이언트는 해당 프록시에 대한 연결을 설정 (또는 재사용)하여 인바운드에 연결합니다. 적용 가능한 프록시가없는 경우 일반 클라이언트는 일반적으로 대상 URI의 체계에 특정한 핸들러 루틴을 호출하여 대상 자원의 권한에 직접 연결합니다.이 방법은 대상 URI 체계에 따라 다르며 관련 사양으로 정의됩니다.이 사양은 &quot;http&quot;(&lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ) 및 &quot;https&quot;( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt; ) 체계. 연결 관리에 관한 HTTP 요구 사항은 &lt;a href=&quot;#section-6&quot;&gt;6 장에&lt;/a&gt; 정의되어있다 .</target>
        </trans-unit>
        <trans-unit id="1ffcfdc99522dda87985b6e020ac99791f96f9b5" translate="yes" xml:space="preserve">
          <source>One helpful trick is to use an Apache rewrite, environment variable, and headers to apply &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; to certain URIs. This is useful, for example, to constrain cross-origin requests to &lt;code&gt;GET /api(.*).json&lt;/code&gt; requests without credentials:</source>
          <target state="translated">유용한 트릭 중 하나는 Apache 재 작성, 환경 변수 및 헤더를 사용 하여 특정 URI에 &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; 를 적용하는 것입니다. 예를 들어, 출처 간 요청을 자격 증명없이 &lt;code&gt;GET /api(.*).json&lt;/code&gt; 요청 으로 제한하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a8582a1553ee6a6943be8472937795233c896987" translate="yes" xml:space="preserve">
          <source>One of &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; (case sensitive).</source>
          <target state="translated">&quot;1 월&quot;, &quot;2 월&quot;, &quot;3 월&quot;, &quot;4 월&quot;, &quot;5 월&quot;, &quot;6 월&quot;, &quot;7 월&quot;, &quot;8 월&quot;, &quot;9 월&quot;, &quot;10 월&quot;, &quot;11 월&quot;, &quot;12 월&quot;( 대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="cc3c09e9e2558b885fb3094c63215174af4c22c6" translate="yes" xml:space="preserve">
          <source>One of &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, or &quot;Sun&quot; (case-sensitive).</source>
          <target state="translated">&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;또는 &quot;Sun&quot;(대소 문자 구분) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ed1f5145c366e1525cfdac1afb12bea74657baef" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;, for example &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 한 &lt;a href=&quot;../methods&quot;&gt;HTTP 요청 방법&lt;/a&gt; 예를 들어, &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 은&lt;/a&gt; , &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 는&lt;/a&gt; , 또는 &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="390c6d9e0ac6e814868f106e3b1a949d7f65c2f1" translate="yes" xml:space="preserve">
          <source>One of the ordered weekday strings:</source>
          <target state="translated">정렬 된 요일 문자열 중 하나 :</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">하나 이상</target>
        </trans-unit>
        <trans-unit id="d8241709124a392624ea93bbc5c857f96e735f3e" translate="yes" xml:space="preserve">
          <source>One or more &lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; can be set for the &lt;code&gt;plugin-types&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;plugin-types&lt;/code&gt; 정책에 대해 하나 이상의 &lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="301b7fe5870eedf464270ce13c1fa28571750cd1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;default-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06bce7998d9ba504b451b0feee8e296f1daee8d8" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;font-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;font-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c94c5922cba00a6f423d74692c379c4b5a45de3" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;frame-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4df1448fbf4125c9dedf0cb65e25a27cddc8034" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;img-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;img-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95bedd54418ece3d0cc9bc840eec50ca73bd04b1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;manifest-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;manifest-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1ab57ca6a220519b6bf1112428f33a86176cf91" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;media-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;media-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e69da8927408051c551ec50a1bc254784fcf5e0" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;script-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;script-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db657b004d9023ddfd0f626de17ba73007526d9f" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;style-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;style-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="482d29a7e2a3ad999de3eaccec198f96895c6c4b" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;worker-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;worker-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03175b17a2f8591861f06a407654d0deac74f4ce" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the child-src policy:</source>
          <target state="translated">child-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2abb90bd1216bb48e062c09ced50f4e78627b20" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the connect-src policy:</source>
          <target state="translated">connect-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd38d0ca560fb98a1494ecf0e9a7973691560553" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the object-src policy:</source>
          <target state="translated">object-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d617d27a877454aafa7fdb2c25048b068c100553" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;form-action&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;form-action&lt;/code&gt; 정책에 대해 하나 이상의 소스를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="614e797f67ee3998c43d2279b0efb9b69d35d0b7" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;frame-ancestors&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; 정책에 대해 하나 이상의 소스를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="440e37e5146514a1b09e389a18211dea7ea8dac6" translate="yes" xml:space="preserve">
          <source>Only a few image types are widely recognized enough to be safe for use in a Web page:</source>
          <target state="translated">웹 페이지에서 안전하게 사용할 수있을 정도로 소수의 이미지 유형 만 널리 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="728dfd233770caccb04ac6af9ed8ff6472ef3733" translate="yes" xml:space="preserve">
          <source>Only from Firefox 11 onwards.</source>
          <target state="translated">Firefox 11 이상에서만.</target>
        </trans-unit>
        <trans-unit id="7aa6633a592e629108d330108c9845898ccefcf7" translate="yes" xml:space="preserve">
          <source>Only if freshness information is included</source>
          <target state="translated">신선도 정보가 포함 된 경우에만</target>
        </trans-unit>
        <trans-unit id="923411c2bc01cfda42c24f6cd8d7e71d494b59bb" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer in all cases.</source>
          <target state="translated">모든 경우에 문서의 출처 만 참조 자로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="504a19ebb593f19f5c15be75bd6a14b10d61cc2c" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), but don't send it to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">프로토콜 보안 수준이 동일하게 유지되면 (HTTPS &amp;rarr; HTTPS) 문서의 출처를 리퍼러로만 보내지 만 보안 수준이 낮은 대상 (HTTPS &amp;rarr; HTTP)으로 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2dee33c23ec83af1e9b47f42ab34f35452828624" translate="yes" xml:space="preserve">
          <source>Only the first parameter is mandatory. Either the second, the third, or both may be left out.</source>
          <target state="translated">첫 번째 매개 변수 만 필수입니다. 두 번째, 세 번째 또는 둘 다 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d87b3098d93fe460f69fc84cf084280f871953" translate="yes" xml:space="preserve">
          <source>Open a TCP connection: The TCP connection will be used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.</source>
          <target state="translated">TCP 연결 열기 : TCP 연결은 하나 이상의 요청을 보내고 응답을받는 데 사용됩니다. 클라이언트는 새 연결을 열거 나 기존 연결을 재사용하거나 서버에 대한 여러 TCP 연결을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="075672a8517397eeef73c16b7924c5637eb3e6f7" translate="yes" xml:space="preserve">
          <source>OpenDocument presentation document</source>
          <target state="translated">OpenDocument 프리젠 테이션 문서</target>
        </trans-unit>
        <trans-unit id="9c8c7fbf48609de1ffb436774d400bc486986b1e" translate="yes" xml:space="preserve">
          <source>OpenDocument spreadsheet document</source>
          <target state="translated">OpenDocument 스프레드 시트 문서</target>
        </trans-unit>
        <trans-unit id="ae259e53c368ebd11d83ff7013840fd030bc4e12" translate="yes" xml:space="preserve">
          <source>OpenDocument text document</source>
          <target state="translated">OpenDocument 텍스트 문서</target>
        </trans-unit>
        <trans-unit id="b15775ed71872d7bda87125462ecf55ba4b4a044" translate="yes" xml:space="preserve">
          <source>OpenType font</source>
          <target state="translated">OpenType 글꼴</target>
        </trans-unit>
        <trans-unit id="19c9c9ed8477a3a275bcf0fa3f27c69151b58b7d" translate="yes" xml:space="preserve">
          <source>Opera</source>
          <target state="translated">Opera</target>
        </trans-unit>
        <trans-unit id="ea83f20e4af1c088f0ff12d9f40107e1fae7cd91" translate="yes" xml:space="preserve">
          <source>Opera 11.10</source>
          <target state="translated">오페라 11.10</target>
        </trans-unit>
        <trans-unit id="94504c9918ec0e2b645287a73d2e76cbf6604f4e" translate="yes" xml:space="preserve">
          <source>Opera UA string</source>
          <target state="translated">오페라 UA 문자열</target>
        </trans-unit>
        <trans-unit id="4497b69b3e58a8b8c4ab04b8430dd1bf6b9df545" translate="yes" xml:space="preserve">
          <source>Opera for Android</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256d43d577a1728bc1dc921d68a8fa6c2b037086" translate="yes" xml:space="preserve">
          <source>Opera/9.80 (Android 2.3.3; Linux; Opera Mobi/ADR-1111101157; U; es-ES) Presto/2.9.201 Version/11.50</source>
          <target state="translated">Opera / 9.80 (Android 2.3.3; Linux; Opera Mobi / ADR-1111101157; U; es-ES) Presto / 2.9.201 버전 /11.50</target>
        </trans-unit>
        <trans-unit id="d21816adfc84e4894b30f5b80678333d5c37dce9" translate="yes" xml:space="preserve">
          <source>Opera/xyz</source>
          <target state="translated">Opera/xyz</target>
        </trans-unit>
        <trans-unit id="08a9921e90aae36fdabfc9ba080c0517a0f9df35" translate="yes" xml:space="preserve">
          <source>Opera/xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">오페라 / 엑시즈 &lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="793b3dcdefb9f6d9d75d16cae958fafb4b6cc0a0" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt; that convey additional information for the servers.</source>
          <target state="translated">서버에 대한 추가 정보를 전달하는 선택적 &lt;a href=&quot;headers&quot;&gt;헤더&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b489d6278596ad8cbce00fb97015da3fdf24a162" translate="yes" xml:space="preserve">
          <source>Optional upgrade</source>
          <target state="translated">선택적 업그레이드</target>
        </trans-unit>
        <trans-unit id="39c86106a7fb30538fb6bf0bd6b42312db26ab4c" translate="yes" xml:space="preserve">
          <source>Optional. If more than one &lt;code&gt;Warning&lt;/code&gt; header is sent, include a date that matches the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">선택 과목. 둘 이상의 &lt;code&gt;Warning&lt;/code&gt; 헤더가 전송 된 경우 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 헤더 와 일치하는 날짜를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6070787c35a58d9bea898c231c2152bcd0af813" translate="yes" xml:space="preserve">
          <source>Optional. The name of the protocol used, such as &quot;HTTP&quot;.</source>
          <target state="translated">선택 과목. 사용 된 프로토콜의 이름 (예 : &quot;HTTP&quot;)</target>
        </trans-unit>
        <trans-unit id="38b7579808079b250ea2022859caac9497170a85" translate="yes" xml:space="preserve">
          <source>Optionally, a body containing the fetched resource.</source>
          <target state="translated">선택적으로 페치 된 자원을 포함하는 본문.</target>
        </trans-unit>
        <trans-unit id="eb46e915c8c19f6af68e7a6bdae7009a1807f316" translate="yes" xml:space="preserve">
          <source>Or a body, for some methods like &lt;code&gt;POST&lt;/code&gt;, similar to those in responses, which contain the resource sent.</source>
          <target state="translated">또는 &lt;code&gt;POST&lt;/code&gt; 와 같은 일부 메소드의 경우 응답의 메소드와 유사하며 전송 된 자원을 포함 하는 본문 입니다.</target>
        </trans-unit>
        <trans-unit id="e2b445db4463b9f0e28207704251d3ed52ff3148" translate="yes" xml:space="preserve">
          <source>Or by using the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt;&lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt; &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 &lt;code&gt;referrerpolicy&lt;/code&gt; 속성을 사용하여 :</target>
        </trans-unit>
        <trans-unit id="5cb1a52345d3e8948ce99c302fcc32162e6809d7" translate="yes" xml:space="preserve">
          <source>Or the de-facto standard versions:</source>
          <target state="translated">또는 사실상의 표준 버전 :</target>
        </trans-unit>
        <trans-unit id="3faf8dc540861f535e93a1016c4c11a4d714285a" translate="yes" xml:space="preserve">
          <source>Order of precedence</source>
          <target state="translated">우선 순위</target>
        </trans-unit>
        <trans-unit id="44ab85a252adb7ade8ca36fec4157a862c1f725f" translate="yes" xml:space="preserve">
          <source>Origin</source>
          <target state="translated">Origin</target>
        </trans-unit>
        <trans-unit id="290335c298a77e839fe785e3a86ced4673d12093" translate="yes" xml:space="preserve">
          <source>Origin servers frequently make use of their local file system to
   manage the mapping from effective request URI to resource
   representations.  Most file systems are not designed to protect
   against malicious file or path names.  Therefore, an origin server
   needs to avoid accessing names that have a special significance to
   the system when mapping the request target to files, folders, or
   directories.

   For example, UNIX, Microsoft Windows, and other operating systems use
   &quot;..&quot; as a path component to indicate a directory level above the
   current one, and they use specially named paths or file names to send
   data to system devices.  Similar naming conventions might exist
   within other types of storage systems.  Likewise, local storage
   systems have an annoying tendency to prefer user-friendliness over
   security when handling invalid or unexpected characters,
   recomposition of decomposed characters, and case-normalization of
   case-insensitive names.

   Attacks based on such special names tend to focus on either denial-
   of-service (e.g., telling the server to read from a COM port) or
   disclosure of configuration and source files that are not meant to be
   served.</source>
          <target state="translated">오리진 서버는 종종 로컬 파일 시스템을 사용하여 효과적인 요청 URI에서 자원 표시로의 맵핑을 관리합니다. 대부분의 파일 시스템은 악성 파일 또는 경로 이름으로부터 보호하도록 설계되지 않았습니다. 따라서 오리진 서버는 요청 대상을 파일, 폴더 또는 디렉토리에 맵핑 할 때 시스템에 특별한 의미가있는 이름에 액세스하지 않아야합니다. 예를 들어, UNIX, Microsoft Windows 및 기타 운영 체제는 &quot;..&quot;를 경로 구성 요소로 사용하여 현재 디렉토리보다 높은 디렉토리 레벨을 나타내며 특별히 명명 된 경로 또는 파일 이름을 사용하여 시스템 장치로 데이터를 보냅니다. 다른 유형의 스토리지 시스템 내에 유사한 이름 지정 규칙이 존재할 수 있습니다. 마찬가지로,로컬 스토리지 시스템은 유효하지 않거나 예상치 못한 문자를 처리 할 때 보안보다 사용자 친 화성을 선호하는 성가신 경향이 있으며, 분해 된 문자의 재구성 및 대소 문자를 구분하지 않는 이름의 대소 문자를 정규화합니다. 이러한 특수 이름을 기반으로하는 공격은 서비스 거부 (예 : 서버에 COM 포트에서 읽도록 지시) 또는 제공되지 않는 구성 및 소스 파일의 공개에 중점을 두는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="39574fdeedd527e498bc8ce3b971e8f064927c65" translate="yes" xml:space="preserve">
          <source>Origin servers often use parameters within the URI as a means of
   identifying system services, selecting database entries, or choosing
   a data source.  However, data received in a request cannot be
   trusted.  An attacker could construct any of the request data
   elements (method, request-target, header fields, or body) to contain
   data that might be misinterpreted as a command, code, or query when
   passed through a command invocation, language interpreter, or
   database interface.

   For example, SQL injection is a common attack wherein additional
   query language is inserted within some part of the request-target or
   header fields (e.g., Host, Referer, etc.).  If the received data is
   used directly within a SELECT statement, the query language might be
   interpreted as a database command instead of a simple string value.
   This type of implementation vulnerability is extremely common, in
   spite of being easy to prevent. 

   In general, resource implementations ought to avoid use of request
   data in contexts that are processed or interpreted as instructions.
   Parameters ought to be compared to fixed strings and acted upon as a
   result of that comparison, rather than passed through an interface
   that is not prepared for untrusted data.  Received data that isn't
   based on fixed parameters ought to be carefully filtered or encoded
   to avoid being misinterpreted.

   Similar considerations apply to request data when it is stored and
   later processed, such as within log files, monitoring tools, or when
   included within a data format that allows embedded scripts.</source>
          <target state="translated">오리진 서버는 종종 시스템 서비스 식별, 데이터베이스 항목 선택 또는 데이터 소스 선택의 수단으로 URI 내의 매개 변수를 사용합니다. 그러나 요청에서 수신 한 데이터는 신뢰할 수 없습니다. 공격자는 명령 호출, 언어 인터프리터 또는 데이터베이스를 통해 전달 될 때 명령, 코드 또는 쿼리로 잘못 해석 될 수있는 데이터를 포함하도록 요청 데이터 요소 (메서드, 요청 대상, 헤더 필드 또는 본문)를 구성 할 수 있습니다. 상호 작용. 예를 들어, SQL 삽입은 추가 쿼리 언어가 요청 대상 또는 헤더 필드의 일부 (예 : 호스트, 참조 자 등)에 삽입되는 일반적인 공격입니다. 수신 된 데이터가 SELECT 문 내에서 직접 사용되는 경우 조회 언어는 단순 문자열 값 대신 데이터베이스 명령으로 해석 될 수 있습니다.이러한 유형의 구현 취약점은 예방하기 쉽지만 매우 일반적입니다. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.예방하기 쉽지만. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.예방하기 쉽지만. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.고정 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="f2f4c2c9ebacb9837f6d36a5f8a3b8e0b622d3aa" translate="yes" xml:space="preserve">
          <source>Other Gecko-based browsers</source>
          <target state="translated">다른 Gecko 기반 브라우저</target>
        </trans-unit>
        <trans-unit id="a9f706611dc18f06545758348b461f7f0adb2b15" translate="yes" xml:space="preserve">
          <source>Other Range Units (RFC 7233)</source>
          <target state="translated">기타 범위 단위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="c3ce9f69b8cfd7c68b552621813174d43df7c2b9" translate="yes" xml:space="preserve">
          <source>Other directives</source>
          <target state="translated">다른 지시어</target>
        </trans-unit>
        <trans-unit id="625b9f557aeca38bef04ac2454ddfa89b0a0c358" translate="yes" xml:space="preserve">
          <source>Other headers may be required depending on the requested protocol; for example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket&lt;/a&gt; upgrades allow additional headers to configure details about the WebSocket connection as well as to offer a degree of security in opening the connection. See &lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;Upgrading to a WebSocket connection&lt;/a&gt; for more details.</source>
          <target state="translated">요청 된 프로토콜에 따라 다른 헤더가 필요할 수 있습니다. 예를 들어, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket&lt;/a&gt; 업그레이드를 통해 추가 헤더가 WebSocket 연결에 대한 세부 정보를 구성하고 연결을 열 때 어느 정도의 보안을 제공 할 수 있습니다. 자세한 내용 &lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;은 WebSocket 연결&lt;/a&gt; 로 업그레이드를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="85ebef3f22c7ab64a892270dec3fa2ec5f09eb93" translate="yes" xml:space="preserve">
          <source>Other kinds of images can be found in Web documents. For example, many browsers support ICO images for favicons with the &lt;code&gt;image/x-icon&lt;/code&gt; MIME type.</source>
          <target state="translated">다른 종류의 이미지는 웹 문서에서 찾을 수 있습니다. 예를 들어, 많은 브라우저는 &lt;code&gt;image/x-icon&lt;/code&gt; MIME 유형의 즐겨 찾기 아이콘에 대한 ICO 이미지를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="7ab593da14a28bf9d35c50c2c46a830c857de1cc" translate="yes" xml:space="preserve">
          <source>Other methods of conveying document type</source>
          <target state="translated">문서 유형을 전달하는 다른 방법</target>
        </trans-unit>
        <trans-unit id="996796a4631242928596cc5bcca3b11a2ae12348" translate="yes" xml:space="preserve">
          <source>Other non-standard forms:</source>
          <target state="translated">다른 비표준 형태 :</target>
        </trans-unit>
        <trans-unit id="c72c6b541f8af743f2c407a4401af9c3f96dae91" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b84d6d36913561f68541fe18676efd3d770dbda0" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d85834ec62e00c548dc17fc4f00c0165fdd2bae" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38408917877ccb7a2526344ef45c30543e381d4f" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6cfd07479f00708fdf4d74f365c52cc07a8f329" translate="yes" xml:space="preserve">
          <source>Others &lt;em&gt;changed&lt;/em&gt; to &lt;code&gt;GET&lt;/code&gt; (body lost).</source>
          <target state="translated">다른 사람들 은 &lt;code&gt;GET&lt;/code&gt; (바디 분실)으로 &lt;em&gt;변경되었습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="82d2325236dcdd66d736da750430f95549e17f4d" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">다른 사람들은 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경되거나 변경되지 않을 수 있습니다 . &lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87489c6b3237d9c5e336cbbf949df80f405e54e2" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">다른 사람들은 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경되거나 변경되지 않을 수 있습니다 . &lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1389ad925826fb57f506c6950b9975e96c5e84ae" translate="yes" xml:space="preserve">
          <source>Over the years, Web pages have become much more complex, even becoming applications in their own right. The amount of visual media displayed, the volume and size of scripts adding interactivity, has also increased: much more data is transmitted over significantly more HTTP requests. HTTP/1.1 connections need requests sent in the correct order. Theoretically, several parallel connections could be used (typically between 5 and 8), bringing considerable overhead and complexity. For example, HTTP pipelining has emerged as a resource burden in Web development.</source>
          <target state="translated">수년에 걸쳐 웹 페이지는 훨씬 더 복잡해졌으며 심지어 자체적으로 응용 프로그램이되었습니다. 표시되는 시각적 미디어의 양, 대화 형 작업을 추가하는 스크립트의 크기 및 크기도 증가했습니다. 훨씬 더 많은 데이터가 훨씬 더 많은 HTTP 요청을 통해 전송됩니다. HTTP / 1.1 연결에는 올바른 순서로 요청이 전송되어야합니다. 이론적으로 여러 병렬 연결을 사용할 수 있으며 (일반적으로 5와 8 사이) 상당한 오버 헤드와 복잡성을 가져옵니다. 예를 들어, HTTP 파이프 라이닝은 웹 개발에서 리소스 부담으로 등장했습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
