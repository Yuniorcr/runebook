<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="a5b93109d2910f83b46a8f8b84565a2b90f04e8f" translate="yes" xml:space="preserve">
          <source>Android webview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2272152aaed514a90142950fb3ee1816c7074cb" translate="yes" xml:space="preserve">
          <source>Annotation of existing resources</source>
          <target state="translated">기존 자원의 주석</target>
        </trans-unit>
        <trans-unit id="30a34db762af17ee412c2a1fc9d092bc9dce7999" translate="yes" xml:space="preserve">
          <source>Another (implicit) indication that PATCH is allowed, is the presence of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; header, which specifies the patch document formats accepted by the server.</source>
          <target state="translated">PATCH가 허용된다는 또 다른 (암시 적) 표시는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; &lt;/a&gt; 헤더 가 존재한다는 것입니다.이 헤더는 서버가 승인 한 패치 문서 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ea2ea80d736402d761cc48753f37ae87a7086f1" translate="yes" xml:space="preserve">
          <source>Another API, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;server-sent events&lt;/a&gt;, is a one-way service that allows a server to send events to the client, using HTTP as a transport mechanism. Using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt;&lt;code&gt;EventSource&lt;/code&gt;&lt;/a&gt; interface, the client opens a connection and establishes event handlers. The client browser automatically converts the messages that arrive on the HTTP stream into appropriate &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; objects, delivering them to the event handlers that have been registered for the events' &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; if known, or to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt;&lt;code&gt;onmessage&lt;/code&gt;&lt;/a&gt; event handler if no type-specific event handler was established.</source>
          <target state="translated">또 다른 API 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;server-sent events&lt;/a&gt; 는 전송 메커니즘으로 HTTP를 사용하여 서버가 클라이언트에 이벤트를 보낼 수있는 단방향 서비스입니다. 클라이언트 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt; &lt;code&gt;EventSource&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 연결을 열고 이벤트 핸들러를 설정합니다. 클라이언트 브라우저는 HTTP 스트림에 도착한 메시지를 적절한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 객체 로 자동 변환하여 알려진 경우 이벤트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 에 등록 된 이벤트 핸들러 또는 유형별 이벤트 핸들러가없는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt; &lt;code&gt;onmessage&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러로 전달합니다. 설립.</target>
        </trans-unit>
        <trans-unit id="82dda038aa2cce2ed80f2fe178807efbf3638a7c" translate="yes" xml:space="preserve">
          <source>Another typical use case of the &lt;code&gt;ETag&lt;/code&gt; header is to cache resources that are unchanged. If a user visits a given URL again (that has an &lt;code&gt;ETag&lt;/code&gt; set), and it is &lt;em&gt;stale&lt;/em&gt;, that is too old to be considered usable, the client will send the value of its &lt;code&gt;ETag&lt;/code&gt; along in an &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; header field:</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 헤더 의 또 다른 일반적인 사용 사례 는 변경되지 않은 리소스를 캐시하는 것입니다. 사용자가 지정된 URL ( &lt;code&gt;ETag&lt;/code&gt; 세트가 있음)을 다시 방문하고 유효 &lt;em&gt;하지 않은 오래된&lt;/em&gt; URL 인 경우 클라이언트는 &lt;code&gt;ETag&lt;/code&gt; 값을 &lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 헤더 필드 와 함께 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="5e02264f317d706ccbea92e11ccd2f204223b4b4" translate="yes" xml:space="preserve">
          <source>Any MIME type</source>
          <target state="translated">모든 MIME 유형</target>
        </trans-unit>
        <trans-unit id="d073236284623914133cba02aa3f08d7e4a1a8da" translate="yes" xml:space="preserve">
          <source>Any attempt to identify the entity ultimately responsible for the resource being unavailable, such as the name of the person or organization that made a legal demand resulting in the content's removal belongs in the response body, not in the &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; link.</source>
          <target state="translated">콘텐츠를 삭제하도록 법적 요구를 한 사람 또는 조직의 이름과 같이 리소스를 사용할 수없는 궁극적 인 책임이있는 엔티티를 식별하려는 시도는 &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; 링크가 아닌 응답 본문에 속합니다. .</target>
        </trans-unit>
        <trans-unit id="2f93939c7c6cb77a4b58edcc0e622cd4847d28e7" translate="yes" xml:space="preserve">
          <source>Any charset not mentioned elsewhere in the header; &lt;code&gt;'*'&lt;/code&gt; being used as a wildcard.</source>
          <target state="translated">헤더의 다른 곳에서 언급되지 않은 모든 문자 집합; &lt;code&gt;'*'&lt;/code&gt; 는 와일드 카드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cffac48fe322697cea7b86272c21674cea37081d" translate="yes" xml:space="preserve">
          <source>Any document that contains text and is theoretically human readable</source>
          <target state="translated">텍스트를 포함하고 이론적으로 사람이 읽을 수있는 모든 문서</target>
        </trans-unit>
        <trans-unit id="2222f9e23d53ca401d68b85209e6a60c148699f8" translate="yes" xml:space="preserve">
          <source>Any dotted address such as an IP address or mask.</source>
          <target state="translated">IP 주소 또는 마스크와 같은 점으로 구분 된 주소</target>
        </trans-unit>
        <trans-unit id="019e0e72fd8d034b92757591b2abd6fca20d6e93" translate="yes" xml:space="preserve">
          <source>Any kind of audio file</source>
          <target state="translated">모든 종류의 오디오 파일</target>
        </trans-unit>
        <trans-unit id="dd4445bb33a492123fee27932f107bd3fb3d96ab" translate="yes" xml:space="preserve">
          <source>Any kind of binary data</source>
          <target state="translated">모든 종류의 이진 데이터</target>
        </trans-unit>
        <trans-unit id="d6114a2f683fe140d2073d3c42d6efbc65bb0052" translate="yes" xml:space="preserve">
          <source>Any kind of binary data, especially data that will be executed or interpreted somehow.</source>
          <target state="translated">모든 종류의 이진 데이터, 특히 어떻게 든 실행되거나 해석 될 데이터.</target>
        </trans-unit>
        <trans-unit id="1efabcb6609afdf043de0f7cdb84bbe7f95e6d79" translate="yes" xml:space="preserve">
          <source>Any kind of image. Videos are not included, though animated images (like animated GIF) are described with an image type.</source>
          <target state="translated">모든 종류의 이미지. 애니메이션 GIF와 같은 애니메이션 이미지는 이미지 유형으로 설명되지만 비디오는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01b107a882caf2ec54e57571bc8a5b70f3cfd436" translate="yes" xml:space="preserve">
          <source>Any kind of video file</source>
          <target state="translated">모든 종류의 비디오 파일</target>
        </trans-unit>
        <trans-unit id="1bebfb3250f36aea1f47b92ea11652dd128e36ff" translate="yes" xml:space="preserve">
          <source>Any language; &lt;code&gt;'*'&lt;/code&gt; is used as a wildcard.</source>
          <target state="translated">모든 언어; &lt;code&gt;'*'&lt;/code&gt; 는 와일드 카드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2b54a4202ec978d3ce61340b71c764fd12c522" translate="yes" xml:space="preserve">
          <source>Any of those URLs can be typed into your browser's address bar to tell it to load the associated page (resource).</source>
          <target state="translated">해당 URL을 브라우저의 주소 표시 줄에 입력하여 관련 페이지 (자원)를로드하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55969e44ed3bb85f72438df20e0888b1d448e7d" translate="yes" xml:space="preserve">
          <source>Any request can contain a conditional header defined in HTTP (If-
   Match, If-Modified-Since, etc.) or the &quot;If&quot; or &quot;Overwrite&quot;
   conditional headers defined in this specification.  If the server
   evaluates a conditional header, and if that condition fails to hold,
   then this error code MUST be returned.  On the other hand, if the
   client did not include a conditional header in the request, then the
   server MUST NOT use this status code.</source>
          <target state="translated">모든 요청에는 HTTP에 정의 된 조건부 헤더 (If- Match, If-Modified-Since 등) 또는이 사양에 정의 된 &quot;If&quot;또는 &quot;Overwrite&quot;조건부 헤더가 포함될 수 있습니다. 서버가 조건부 헤더를 평가하고 해당 조건이 유지되지 않으면이 오류 코드가 리턴되어야합니다. 반면에 클라이언트가 요청에 조건부 헤더를 포함하지 않은 경우 서버는이 상태 코드를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8478316470e4f240737c39611f11363ddfca7c9b" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">모든 값은 &lt;em&gt;weight&lt;/em&gt; 라는 상대적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0362e9377af962c1e1e3c9526a03e0bd8afd66f5" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">모든 값은 &lt;em&gt;weight&lt;/em&gt; 라는 상대적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2511c542d2415f42594a069865e3cebb0df0bdbf" translate="yes" xml:space="preserve">
          <source>Any value placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;weight&lt;/em&gt; 라는 상대적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 선호하는 순서대로 배치 된 값 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="028f46051e76ed93ba7b2778ec6eb36735319f74" translate="yes" xml:space="preserve">
          <source>Any value used is placed in an order of preference expressed using relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">사용 된 모든 값 은 &lt;em&gt;가중치&lt;/em&gt; 라고하는 상대적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="8999d296169b8dd735b6c2a66a1890fdaeaf65ac" translate="yes" xml:space="preserve">
          <source>Apache (.htaccess)</source>
          <target state="translated">아파치 (.htaccess)</target>
        </trans-unit>
        <trans-unit id="7723239d4f8c294f39821b7409607014e4779e8f" translate="yes" xml:space="preserve">
          <source>Apache configuration</source>
          <target state="translated">아파치 설정</target>
        </trans-unit>
        <trans-unit id="aa0a9cd5c584e9e02295690438c89eb9804a2974" translate="yes" xml:space="preserve">
          <source>Apache examples</source>
          <target state="translated">아파치 예제</target>
        </trans-unit>
        <trans-unit id="c418bff5ffb1981f5504dddf5424420a352c8db4" translate="yes" xml:space="preserve">
          <source>Apache supports compression and uses &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt;; for nginx there is &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt;; for IIS, the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">Apache는 압축을 지원하고 &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate를 사용합니다&lt;/a&gt; . nginx의 경우 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module이 있습니다&lt;/a&gt; . IIS의 경우 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소</target>
        </trans-unit>
        <trans-unit id="970faa6cb472b485c0f707488c5cdc08b7986c8b" translate="yes" xml:space="preserve">
          <source>Apart from the headers set automatically by the user agent (for example, &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;any of the other headers with names defined in the Fetch spec as a &amp;ldquo;forbidden header name&amp;rdquo;&lt;/a&gt;), the only headers which are allowed to be manually set are &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;those which the Fetch spec defines as being a &amp;ldquo;CORS-safelisted request-header&amp;rdquo;&lt;/a&gt;, which are:</source>
          <target state="translated">사용자 에이전트가 자동으로 설정 한 헤더 (예 : &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;Fetch 사양에서 &quot;금지 된 헤더 이름&quot;으로 정의 된 이름을 가진 다른 헤더)&lt;/a&gt; 외에는 허용되는 유일한 헤더 수동 설정은 &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;Fetch 스펙이 &quot;CORS-safelisted request-header&quot;로 정의한 것입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa865a302682de3015e0ace4594cebfe9d891b1" translate="yes" xml:space="preserve">
          <source>AppCache,</source>
          <target state="translated">AppCache,</target>
        </trans-unit>
        <trans-unit id="f4f943fdac0850a40c1e416faae62566138da37d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">부록 A. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="918d2c04181755c7d2a2da27da64eb8b93bdb750" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from RFCs 2616 and 2617</source>
          <target state="translated">부록 A. RFC 2616 및 2617의 변경 사항</target>
        </trans-unit>
        <trans-unit id="b43034e2e81ab244701cc36ac5fa225c7d47a6b7" translate="yes" xml:space="preserve">
          <source>Appendix A.  Contributors</source>
          <target state="translated">부록 A. 기고자</target>
        </trans-unit>
        <trans-unit id="81248f72eaaeaa9ce24d21fe4f273f8ddcbc8c1d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Differences between HTTP and MIME</source>
          <target state="translated">부록 A. HTTP와 MIME의 차이점</target>
        </trans-unit>
        <trans-unit id="7952612f081e615aa7bd03aa23dc4c518656090e" translate="yes" xml:space="preserve">
          <source>Appendix A.  HTTP Version History</source>
          <target state="translated">부록 A. HTTP 버전 히스토리</target>
        </trans-unit>
        <trans-unit id="6a6a944bd171bde6db3410fdca99b9555cb916eb" translate="yes" xml:space="preserve">
          <source>Appendix A.  Internet Media Type multipart/byteranges</source>
          <target state="translated">부록 A. 인터넷 매체 유형 멀티 파트 / 바이트 범위</target>
        </trans-unit>
        <trans-unit id="5a342778d6d38dec85304f64cb11f4d4619e78db" translate="yes" xml:space="preserve">
          <source>Appendix A.  Notes on Processing XML Elements</source>
          <target state="translated">부록 A. XML 요소 처리에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="1ee9c6db5c064e35f5da900ad01918c6a6eb39c9" translate="yes" xml:space="preserve">
          <source>Appendix B.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">부록 B. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="66e5d9de6262db2adaa063f2f1cfab6dede8a9d3" translate="yes" xml:space="preserve">
          <source>Appendix B.  Collected ABNF</source>
          <target state="translated">부록 B. 수집 된 ABNF</target>
        </trans-unit>
        <trans-unit id="4047ada28894f318e92d4c1e37bfb1baca1a4956" translate="yes" xml:space="preserve">
          <source>Appendix B.  Imported ABNF</source>
          <target state="translated">부록 B. 수입 된 ABNF</target>
        </trans-unit>
        <trans-unit id="e8da15ad98d1a9ffbcd6d66ba2fd87d4baebf827" translate="yes" xml:space="preserve">
          <source>Appendix B.  Notes on HTTP Client Compatibility</source>
          <target state="translated">부록 B. HTTP 클라이언트 호환성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4bc7060239451790c0c340964acba077f07d510e" translate="yes" xml:space="preserve">
          <source>Appendix B.  RELAX NG Compact Schema</source>
          <target state="translated">부록 B. RELAX NG 컴팩트 스키마</target>
        </trans-unit>
        <trans-unit id="058387e6d5459c618bca63d6f49f8d5971089303" translate="yes" xml:space="preserve">
          <source>Appendix C.  Collected ABNF</source>
          <target state="translated">부록 C. ABNF 수집</target>
        </trans-unit>
        <trans-unit id="977523ad17c09cc35f1c89152295090a33b58a76" translate="yes" xml:space="preserve">
          <source>Appendix C.  Imported ABNF</source>
          <target state="translated">부록 C. 수입 된 ABNF</target>
        </trans-unit>
        <trans-unit id="de902e4f9b3096f5f049db4d8e97c98cde2df389" translate="yes" xml:space="preserve">
          <source>Appendix C.  The 'opaquelocktoken' Scheme and URIs</source>
          <target state="translated">부록 C. 'opaquelocktoken'체계 및 URI</target>
        </trans-unit>
        <trans-unit id="ce8263e94ec9fefd83f8c080b1172f0fb08a91c8" translate="yes" xml:space="preserve">
          <source>Appendix D.  Collected ABNF</source>
          <target state="translated">부록 D. 수집 된 ABNF</target>
        </trans-unit>
        <trans-unit id="0d9be62baed7f2691c136ca29f5d801725b346de" translate="yes" xml:space="preserve">
          <source>Appendix D.  Lock-null Resources</source>
          <target state="translated">부록 D. 잠금 널 자원</target>
        </trans-unit>
        <trans-unit id="b843d7a45c5fbfe004e6dab880398f2c109d318b" translate="yes" xml:space="preserve">
          <source>Appendix E.  Guidance for Clients Desiring to Authenticate</source>
          <target state="translated">부록 E. 인증을 원하는 고객을위한 지침</target>
        </trans-unit>
        <trans-unit id="1e32692b4682e33761a3d401d643e95f4fc629c6" translate="yes" xml:space="preserve">
          <source>Appendix F.  Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;</source>
          <target state="translated">부록 F. &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 의 변경 사항 요약</target>
        </trans-unit>
        <trans-unit id="a6b70da19fe698facbbf74a7c6848c10082c6db6" translate="yes" xml:space="preserve">
          <source>Apple Installer Package</source>
          <target state="translated">애플 인스톨러 패키지</target>
        </trans-unit>
        <trans-unit id="594c277ced56ff92f49f5549dcb6e9bb01873e08" translate="yes" xml:space="preserve">
          <source>Apple Safari rejects any such data. Google Chrome and Microsoft Edge discard up to four invalid bytes preceding a valid response. Firefox tolerates in excess of a kilobyte of invalid data preceding a valid response.</source>
          <target state="translated">Apple Safari는 그러한 데이터를 거부합니다. Chrome 및 Microsoft Edge는 유효한 응답을하기 전에 최대 4 개의 유효하지 않은 바이트를 버립니다. Firefox는 유효한 응답에 앞서 킬로바이트를 초과하는 유효하지 않은 데이터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a7e444ff8fa9777e03d5103a61265a5f5c06bddc" translate="yes" xml:space="preserve">
          <source>AppleWebKit/xyz</source>
          <target state="translated">AppleWebKit/xyz</target>
        </trans-unit>
        <trans-unit id="978492a43f30387de57a216152fb92287c408810" translate="yes" xml:space="preserve">
          <source>April 1st joke spec</source>
          <target state="translated">4 월 1 일 농담 사양</target>
        </trans-unit>
        <trans-unit id="c3cfa2d1b2b69734300d2888ba207ad587d929b9" translate="yes" xml:space="preserve">
          <source>Arbitrary, non-specific warning</source>
          <target state="translated">임의의 비 특정 경고</target>
        </trans-unit>
        <trans-unit id="ef596164d3adddb52527e23859760cbb72f418cb" translate="yes" xml:space="preserve">
          <source>Architecture (RFC 7230)</source>
          <target state="translated">아키텍처 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="2cd9571b02d0b5f97d07115fe12dfba195dd6de2" translate="yes" xml:space="preserve">
          <source>Archive document (multiple files embedded)</source>
          <target state="translated">보관 문서 (여러 파일 포함)</target>
        </trans-unit>
        <trans-unit id="96df099182a80fa56639e210174f84a1514aeddb" translate="yes" xml:space="preserve">
          <source>Are you trying to check for the existence of a specific feature?</source>
          <target state="translated">특정 기능이 있는지 확인하려고합니까?</target>
        </trans-unit>
        <trans-unit id="22374513ed4cb776e85f41fade4e611b7089d973" translate="yes" xml:space="preserve">
          <source>Are you trying to work around a specific bug in some version of a browser?</source>
          <target state="translated">일부 버전의 브라우저에서 특정 버그를 해결하려고합니까?</target>
        </trans-unit>
        <trans-unit id="8cab0add88f8e2a278cfb8a5e8b164090488d38a" translate="yes" xml:space="preserve">
          <source>Arguably the most common use and misuse of user agent sniffing is to detect if the device is a mobile device. However, what is failed to be accountable is what they're really after. People use user agent sniffing to detect if the users' device is touch-friendly and has a small screen so they can optimize their website accordingly. While user agent sniffing can sometimes detect these, not all devices are the same. Some mobile devices have big screen sizes, some desktops have a small touchscreen, some people use smart TV's which are an entirely different ballgame altogether, some people can dynamically change the width and height of their screen by flipping their tablet on its side! So, user agent sniffing is definitely not the way to go. But, there are much better alternatives. Use &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt; to detect if the user's device has a touchscreen. Then, default back to checking the user agent screen only &lt;em&gt;if (!(&quot;maxTouchPoints&quot; in Navigator)) { /*Code here*/}&lt;/em&gt;. Using this information of whether the device has a touchscreen, do not change the entire layout of the website just for touch devices: you will only create more work and maintenance for yourself. Rather, add in touch conveniences such as bigger, more easily clickable buttons (you can do this using CSS by simply increasing the font size). As for the screen size, simply use &lt;em&gt;window.innerWidth&lt;/em&gt; and &lt;em&gt;window.addEventListener(&quot;resize&quot;, function(){ /*refresh screen size dependent things*/ })&lt;/em&gt;. What you want to do for screen size is not slash off information on smaller screens. That will only annoy people because it will force them to use the desktop version. Rather, try to have fewer columns of information in a longer page on smaller screens while having more columns with a shorter page on larger screen sizes. This effect can be easily achieved using CSS flexboxes. Next, always make your code dynamic. The user can flip their mobile device on its side, changing the width and height of the page. Never be satisfied with your webpage until you can open up the dev tools side panel and resize the screen while the webpage looks smooth, fluid, and dynamically resized.</source>
          <target state="translated">사용자 에이전트 스니핑의 가장 일반적인 사용 및 오용은 장치가 모바일 장치인지 여부를 감지하는 것입니다. 그러나 책임을지지 않는 것은 그들이 실제로 추구하는 것입니다. 사람들은 사용자 에이전트 스니핑을 사용하여 사용자의 기기가 터치 친화적이고 작은 화면을 가지고 있는지 여부를 감지하여 그에 따라 웹 사이트를 최적화 할 수 있습니다. 사용자 에이전트 스니핑이 때때로이를 감지 할 수 있지만 모든 장치가 동일한 것은 아닙니다. 일부 휴대 기기에는 화면 크기가 크며 일부 데스크톱에는 터치 스크린이 작고 일부 사람들은 완전히 다른 볼 게임 인 스마트 TV를 사용하며 일부 사람들은 태블릿을 옆으로 뒤집어 화면의 너비와 높이를 동적으로 변경할 수 있습니다! 따라서 사용자 에이전트 스니핑은 확실히 진행되지 않습니다. 그러나 훨씬 더 나은 대안이 있습니다. &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt; 사용&lt;em&gt;&lt;/em&gt;사용자의 기기에 터치 스크린이 있는지 감지합니다. 그런 다음 기본적으로 사용자 에이전트 화면 확인으로 돌아갑니다 &lt;em&gt;((((Navigator의 경우 maxTouchPoints))) {/ * Code here * /}&lt;/em&gt; . 장치에 터치 스크린이 있는지 여부에 대한이 정보를 사용하여 터치 장치에 대해서만 웹 사이트의 전체 레이아웃을 변경하지 마십시오. 더 많은 작업과 유지 보수 만 만들 수 있습니다. 오히려 더 크고 더 쉽게 클릭 할 수있는 버튼과 같은 편리한 터치 기능을 추가하십시오 (글꼴 크기를 늘리면 CSS를 사용하여이를 수행 할 수 있음). 화면 크기는 &lt;em&gt;window.innerWidth&lt;/em&gt; 와 &lt;em&gt;window.addEventListener ( &quot;resize&quot;, function () {/ * 화면 크기에 따라 새로 고침 * /})를 사용하십시오.&lt;/em&gt;. 화면 크기에 대해 수행하려는 작업은 더 작은 화면의 정보를 제거하지 않습니다. 데스크톱 버전을 사용하도록 강요하기 때문에 사람들을 귀찮게 할 것입니다. 오히려 작은 화면에서는 긴 페이지에 정보 열이 적고 큰 화면에서는 짧은 페이지의 열이 더 많습니다. 이 효과는 CSS flexbox를 사용하여 쉽게 달성 할 수 있습니다. 다음으로 항상 코드를 동적으로 만드십시오. 사용자는 모바일 장치를 옆으로 뒤집어 페이지 너비와 높이를 변경할 수 있습니다. 웹 페이지가 매끄럽고 유동적이며 동적으로 크기가 조정되는 동안 개발 도구 측면 패널을 열고 화면 크기를 조정할 수있을 때까지 웹 페이지에 만족하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aec8c8505f13b416d6485fc08c67f5112086e6ad" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name

   The &quot;no-cache&quot; response directive indicates that the response MUST
   NOT be used to satisfy a subsequent request without successful
   validation on the origin server.  This allows an origin server to
   prevent a cache from using it to satisfy a request without contacting
   it, even by caches that have been configured to send stale responses.

   If the no-cache response directive specifies one or more field-names,
   then a cache MAY use the response to satisfy a subsequent request,
   subject to any other restrictions on caching.  However, any header
   fields in the response that have the field-name(s) listed MUST NOT be
   sent in the response to a subsequent request without successful
   revalidation with the origin server.  This allows an origin server to
   prevent the re-use of certain header fields in a response, while
   still allowing caching of the rest of the response.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive. 

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: Although it has been back-ported to many implementations, some
   HTTP/1.0 caches will not recognize or obey this directive.  Also,
   no-cache response directives with field-names are often handled by
   caches as if an unqualified no-cache directive was received; i.e.,
   the special handling for the qualified form is not widely
   implemented.</source>
          <target state="translated">인수 구문 : # field-name &quot;no-cache&quot;응답 지시문은 오리진 서버에서 성공적으로 검증하지 않고 후속 요청을 만족시키기 위해 응답을 사용해서는 안됨을 나타냅니다. 따라서 원본 서버는 오래된 응답을 보내도록 구성된 캐시에 의해서도 캐시가 캐시를 사용하여 요청을 충족시키지 못하도록합니다. 캐시 없음 응답 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한 사항에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 필드 이름이 나열된 응답의 헤더 필드는 원본 서버와의 유효성을 다시 확인하지 않고 후속 요청에 대한 응답으로 전송해서는 안됩니다 (MUST NOT).이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 제공된 필드 이름은이 사양에 의해 정의 된 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. 이 지시문은 따옴표로 묶은 문자열 형식의 인수 구문을 사용합니다. 발신자는 토큰 양식을 생성하지 않아야합니다 (단일 입력 목록에 인용이 필요하지 않은 경우에도). 참고 : 많은 구현으로 백 포트되었지만 일부 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다. 또한 필드 이름이있는 캐시없는 응답 지시문은 종종 정규화되지 않은 캐시없는 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1831ae5ad42c135eef58117ca5beea27918ee39" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name 

   The &quot;private&quot; response directive indicates that the response message
   is intended for a single user and MUST NOT be stored by a shared
   cache.  A private cache MAY store the response and reuse it for later
   requests, even if the response would normally be non-cacheable.

   If the private response directive specifies one or more field-names,
   this requirement is limited to the field-values associated with the
   listed response header fields.  That is, a shared cache MUST NOT
   store the specified field-names(s), whereas it MAY store the
   remainder of the response message.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive.

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: This usage of the word &quot;private&quot; only controls where the
   response can be stored; it cannot ensure the privacy of the message
   content.  Also, private response directives with field-names are
   often handled by caches as if an unqualified private directive was
   received; i.e., the special handling for the qualified form is not
   widely implemented.</source>
          <target state="translated">인수 구문 : # field-name &quot;private&quot;응답 지시문은 응답 메시지가 단일 사용자 용이며 공유 캐시에 저장되어서는 안됨을 나타냅니다. 개인 캐시는 응답을 캐시 할 수없는 경우에도 응답을 저장하고 나중에 요청에 재사용 할 수 있습니다. 개인 응답 지시문이 하나 이상의 필드 이름을 지정하면이 요구 사항은 나열된 응답 헤더 필드와 연관된 필드 값으로 제한됩니다. 즉, 공유 캐시는 지정된 필드 이름을 저장해서는 안되며 나머지 응답 메시지는 저장할 수 있습니다. 제공된 필드 이름은이 사양에 의해 정의 된 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. 이 지시문은 따옴표로 묶은 문자열 형식의 인수 구문을 사용합니다.발신자는 토큰 양식을 생성하지 않아야합니다 (단일 입력 목록에 인용이 필요하지 않은 경우에도). 참고 :이 &quot;비공개&quot;라는 단어 사용법은 응답을 저장할 수있는 위치 만 제어합니다. 메시지 내용의 프라이버시를 보장 할 수 없습니다. 또한 필드 이름이있는 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.필드 이름을 가진 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.필드 이름을 가진 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4aefbf84315b53b56a158fafd1e4047cf84680b4" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; request directive indicates that the client is
   unwilling to accept a response whose age is greater than the
   specified number of seconds.  Unless the max-stale request directive
   is also present, the client is not willing to accept a stale
   response.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-age&quot;요청 지시문은 클라이언트가 연령이 지정된 시간 (초)보다 큰 응답을 수락하지 않음을 나타냅니다. max-stale 요청 지시문도 없으면 클라이언트는 오래된 응답을 기꺼이 수락하지 않습니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-age = &quot;5&quot;'가 아닌 'max-age = 5' '). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="13b97b4c1790a5d1690e4603b26402d86eb7b629" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; response directive indicates that the response is to be
   considered stale after its age is greater than the specified number
   of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-age&quot;응답 지시문은 응답 시간이 지정된 시간 (초)보다 큰 후에 응답이 무효로 간주됨을 나타냅니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-age = &quot;5&quot;'가 아닌 'max-age = 5' '). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="06cca4dcd60697e3d0f6bcb9d03459f0446ded37" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-stale&quot; request directive indicates that the client is
   willing to accept a response that has exceeded its freshness
   lifetime.  If max-stale is assigned a value, then the client is
   willing to accept a response that has exceeded its freshness lifetime
   by no more than the specified number of seconds.  If no value is
   assigned to max-stale, then the client is willing to accept a stale
   response of any age.

   This directive uses the token form of the argument syntax: e.g.,
   'max-stale=10' not 'max-stale=&quot;10&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-stale&quot;요청 지시문은 클라이언트가 신선도 수명을 초과 한 응답을 기꺼이 수락 함을 나타냅니다. max-stale에 값이 할당되면 클라이언트는 지정된 시간 (초)보다 신선도 수명을 초과 한 응답을 기꺼이 수락합니다. max-stale에 값이 지정되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 수락합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-stale = &quot;10&quot;'이 아닌 'max-stale = 10' '). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a825cbd8ee60bf462c6dee710ec7c6f4b00811e3" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;s-maxage&quot; response directive indicates that, in shared caches,
   the maximum age specified by this directive overrides the maximum age
   specified by either the max-age directive or the Expires header
   field.  The s-maxage directive also implies the semantics of the
   proxy-revalidate response directive.

   This directive uses the token form of the argument syntax: e.g.,
   's-maxage=10' not 's-maxage=&quot;10&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : 델타-초 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;섹션 1.2.1&lt;/a&gt; 참조 ) &quot;s-maxage&quot;응답 지시문은 공유 캐시에서이 지시문에 의해 지정된 최대 보존 기간이 max-age 지시어 또는 만료에 의해 지정된 최대 보존 기간보다 우선 함을 나타냅니다. 헤더 필드. s-maxage 지시문은 또한 proxy-revalidate 응답 지시문의 의미를 의미합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 's-maxage = 10'not 's-maxage = &quot;10&quot;'). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc2f52fea65ff20c3fe05e836282a0ecfcb5341" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;) 

   The &quot;min-fresh&quot; request directive indicates that the client is
   willing to accept a response whose freshness lifetime is no less than
   its current age plus the specified time in seconds.  That is, the
   client wants a response that will still be fresh for at least the
   specified number of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'min-fresh=20' not 'min-fresh=&quot;20&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">인수 구문 : 델타-초 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;섹션 1.2.1&lt;/a&gt; 참조 ) &quot;min-fresh&quot;요청 지시문은 클라이언트가 최신 수명과 현재 시간에 지정된 시간 (초)을 더한 응답을 기꺼이 수락 함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간 (초) 동안 새로운 응답을 원합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'min-fresh = 20'not 'min-fresh = &quot;20&quot;'). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="cbe5fd2ae86fbae88e539aaddac116ef8cfd88d6" translate="yes" xml:space="preserve">
          <source>As a header for a multipart body</source>
          <target state="translated">멀티 파트 바디의 헤더로</target>
        </trans-unit>
        <trans-unit id="4db566644cc9fbe6a83b2c42804119cde6babd72" translate="yes" xml:space="preserve">
          <source>As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash &lt;code&gt;'--'&lt;/code&gt;). Each part is its own entity with its own HTTP headers, &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; for file uploading fields.</source>
          <target state="translated">여러 부분으로 구성된 문서 형식은 경계 (두 개의 대시 &lt;code&gt;'--'&lt;/code&gt; 시작하는 문자열)로 구분 된 다른 부분으로 구성됩니다 . 각 부분은 파일 업로드 필드를위한 고유 한 HTTP 헤더, &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이있는 자체 엔티티입니다 .</target>
        </trans-unit>
        <trans-unit id="f8c3d44cd58fb8f4d3b3944cc4bb1a87c5213f6f" translate="yes" xml:space="preserve">
          <source>As a response header for the main body</source>
          <target state="translated">본체에 대한 응답 헤더로</target>
        </trans-unit>
        <trans-unit id="fe358a19fe3a891412dc63b31012cfff7e86b53a" translate="yes" xml:space="preserve">
          <source>As above, but use proxy for local servers which are outside the firewall</source>
          <target state="translated">위와 같지만 방화벽 외부에있는 로컬 서버에는 프록시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21bb09d2ae7faa16332b73a9ff9b212546d3db2e" translate="yes" xml:space="preserve">
          <source>As an HTTP/1.x connection is serializing requests, even without any ordering, it can't be optimal without large enough available bandwidth. As a solution, browsers open several connections to each domain, sending parallel requests. Default was once 2 to 3 connections, but this has now increased to a more common use of 6 parallel connections. There is a risk of triggering &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; protection on the server side if attempting more than this number.</source>
          <target state="translated">HTTP / 1.x 연결은 순서를 지정하지 않아도 요청을 직렬화하므로 사용 가능한 충분한 대역폭이 없으면 최적이 될 수 없습니다. 솔루션으로 브라우저는 각 도메인에 여러 연결을 열어 병렬 요청을 보냅니다. 기본값은 한 번 2 ~ 3 개의 연결 이었지만 이제는 6 개의 병렬 연결이 더 많이 사용됩니다. 이 번호 이상을 시도하면 서버 측에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; 보호 가 트리거 될 위험 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac2caa651e1c42338fb211a69aa78825a0cefdcd" translate="yes" xml:space="preserve">
          <source>As an ultimate form of protection, sites that want to never allow scripts to be executed can opt to globally disallow script execution.</source>
          <target state="translated">궁극적 인 보호 방법으로 스크립트 실행을 절대 원하지 않는 사이트는 전체적으로 스크립트 실행을 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5fdf8f8fd2b7a8d4e1fc4e882626af24bfa4c2" translate="yes" xml:space="preserve">
          <source>As compression brings significant performance improvements, it is recommended to activate it for all files, but already compressed ones like images, audio files and videos.</source>
          <target state="translated">압축시 성능이 크게 향상되므로 모든 파일에 대해 압축을 활성화하는 것이 좋지만 이미 이미지, 오디오 파일 및 비디오와 같은 압축 파일을 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="07e3361838eead49089d2124cc5527647d9a433d" translate="yes" xml:space="preserve">
          <source>As compression works better on a specific kind of files, it usually provides nothing to compress them a second time. In fact, this is often counter productive as the cost of the overhead (algorithms usually need a dictionary that add to the initial size) can be higher than the extra gain in compression resulting in a larger file. Do not use the two following techniques for files in a compressed format.</source>
          <target state="translated">압축은 특정 종류의 파일에서 더 잘 작동하므로 일반적으로 두 번째로 압축 할 수 없습니다. 실제로 오버 헤드 비용 (알고리즘에는 일반적으로 초기 크기에 추가되는 사전이 필요함)이 압축시 추가 이득보다 높아 파일 크기가 커질 수 있기 때문에 이는 종종 역효과를 낳습니다. 압축 형식의 파일에는 다음 두 가지 기술을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="81962caea1092807ea8b2efefdcc4ff1e7fe59fa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;, intermediaries can serve a variety of
   roles in the processing of HTTP requests and responses.  Some
   intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.  Since an
   HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an
   intermediary can enhance (or interfere) with either direction of the
   stream.

   An intermediary not acting as a tunnel MUST implement the Connection
   header field, as specified in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;, and exclude fields from
   being forwarded that are only intended for the incoming connection.

   An intermediary MUST NOT forward a message to itself unless it is
   protected from an infinite request loop.  In general, an intermediary
   ought to recognize its own server names, including any aliases, local
   variations, or literal IP addresses, and respond to such requests
   directly.</source>
          <target state="translated">&lt;a href=&quot;#section-2.3&quot;&gt;2.3 절&lt;/a&gt; 에서 설명한 것처럼 중개자는 HTTP 요청 및 응답 처리에서 다양한 역할을 수행 할 수 있습니다. 일부 중개자는 성능 또는 가용성을 향상시키기 위해 사용됩니다. 다른 것은 액세스 제어 또는 컨텐츠 필터링에 사용됩니다. HTTP 스트림은 파이프 앤 필터 아키텍처와 유사한 특성을 갖기 때문에 중개자가 스트림의 어느 방향 으로든 향상 (또는 간섭) 할 수있는 범위에는 고유 한 제한이 없습니다. 터널로 작동하지 않는 중개자는 &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; 에 명시된 대로 연결 헤더 필드를 구현해야합니다.수신 연결 전용 필드가 전달되지 않도록 제외합니다. 중개자는 무한 요청 루프로부터 보호되지 않는 한 메시지를 자신에게 전달해서는 안된다 (MUST NOT). 일반적으로 중개자는 별칭, 로컬 변형 또는 리터럴 IP 주소를 포함하여 자체 서버 이름을 인식하고 이러한 요청에 직접 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="0808a49d5ce5e6736477468b862009c7c3fdd1ef" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;#section-8.7&quot;&gt;Section 8.7&lt;/a&gt;, extra information on error conditions
   can be included in the body of many status responses.  This section
   makes requirements on the use of the error body mechanism and
   introduces a number of precondition and postcondition codes.

   A &quot;precondition&quot; of a method describes the state of the server that
   must be true for that method to be performed.  A &quot;postcondition&quot; of a
   method describes the state of the server that must be true after that
   method has been completed.

   Each precondition and postcondition has a unique XML element
   associated with it.  In a 207 Multi-Status response, the XML element
   MUST appear inside an 'error' element in the appropriate 'propstat or
   'response' element depending on whether the condition applies to one
   or more properties or to the resource as a whole.  In all other error
   responses where this specification's 'error' body is used, the
   precondition/postcondition XML element MUST be returned as the child
   of a top-level 'error' element in the response body, unless otherwise
   negotiated by the request, along with an appropriate response status.
   The most common response status codes are 403 (Forbidden) if the
   request should not be repeated because it will always fail, and 409
   (Conflict) if it is expected that the user might be able to resolve
   the conflict and resubmit the request.  The 'error' element MAY
   contain child elements with specific error information and MAY be
   extended with any custom child elements.

   This mechanism does not take the place of using a correct numeric
   status code as defined here or in HTTP, because the client must
   always be able to take a reasonable course of action based only on
   the numeric code.  However, it does remove the need to define new
   numeric codes.  The new machine-readable codes used for this purpose
   are XML elements classified as preconditions and postconditions, so
   naturally, any group defining a new condition code can use their own
   namespace.  As always, the &quot;DAV:&quot; namespace is reserved for use by
   IETF-chartered WebDAV working groups. 

   A server supporting this specification SHOULD use the XML error
   whenever a precondition or postcondition defined in this document is
   violated.  For error conditions not specified in this document, the
   server MAY simply choose an appropriate numeric status and leave the
   response body blank.  However, a server MAY instead use a custom
   condition code and other supporting text, because even when clients
   do not automatically recognize condition codes, they can be quite
   useful in interoperability testing and debugging.

   Example - Response with precondition code

   &amp;gt;&amp;gt;Response

      HTTP/1.1 423 Locked
      Content-Type: application/xml; charset=&quot;utf-8&quot;
      Content-Length: xxxx

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:error xmlns:D=&quot;DAV:&quot;&amp;gt;
        &amp;lt;D:lock-token-submitted&amp;gt;
          &amp;lt;D:href&amp;gt;/workspace/webdav/&amp;lt;/D:href&amp;gt;
        &amp;lt;/D:lock-token-submitted&amp;gt;
      &amp;lt;/D:error&amp;gt;

   In this example, a client unaware of a depth-infinity lock on the
   parent collection &quot;/workspace/webdav/&quot; attempted to modify the
   collection member &quot;/workspace/webdav/proposal.doc&quot;.

   Some other useful preconditions and postconditions have been defined
   in other specifications extending WebDAV, such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] (see
   particularly &lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;), [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;], and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC3648&lt;/a&gt;].

   All these elements are in the &quot;DAV:&quot; namespace.  If not specified
   otherwise, the content for each condition's XML element is defined to
   be empty.


   Name:  lock-token-matches-request-uri

   Use with:  409 Conflict

   Purpose:  (precondition) -- A request may include a Lock-Token header
      to identify a lock for the UNLOCK method.  However, if the
      Request-URI does not fall within the scope of the lock identified
      by the token, the server SHOULD use this error.  The lock may have
      a scope that does not include the Request-URI, or the lock could
      have disappeared, or the token may be invalid. 

   Name:  lock-token-submitted (precondition)

   Use with:  423 Locked

   Purpose:  The request could not succeed because a lock token should
      have been submitted.  This element, if present, MUST contain at
      least one URL of a locked resource that prevented the request.  In
      cases of MOVE, COPY, and DELETE where collection locks are
      involved, it can be difficult for the client to find out which
      locked resource made the request fail -- but the server is only
      responsible for returning one such locked resource.  The server
      MAY return every locked resource that prevented the request from
      succeeding if it knows them all.

   &amp;lt;!ELEMENT lock-token-submitted (href+) &amp;gt;


   Name:  no-conflicting-lock (precondition)

   Use with:  Typically 423 Locked

   Purpose:  A LOCK request failed due the presence of an already
      existing conflicting lock.  Note that a lock can be in conflict
      although the resource to which the request was directed is only
      indirectly locked.  In this case, the precondition code can be
      used to inform the client about the resource that is the root of
      the conflicting lock, avoiding a separate lookup of the
      &quot;lockdiscovery&quot; property.

   &amp;lt;!ELEMENT no-conflicting-lock (href)* &amp;gt;


   Name:  no-external-entities

   Use with:  403 Forbidden

   Purpose:  (precondition) -- If the server rejects a client request
      because the request body contains an external entity, the server
      SHOULD use this error.


   Name:  preserved-live-properties

   Use with:  409 Conflict

   Purpose:  (postcondition) -- The server received an otherwise-valid
      MOVE or COPY request, but cannot maintain the live properties with
      the same behavior at the destination.  It may be that the server 

      only supports some live properties in some parts of the
      repository, or simply has an internal error.


   Name:  propfind-finite-depth

   Use with:  403 Forbidden

   Purpose:  (precondition) -- This server does not allow infinite-depth
      PROPFIND requests on collections.


   Name:  cannot-modify-protected-property

   Use with:  403 Forbidden

   Purpose:  (precondition) -- The client attempted to set a protected
      property in a PROPPATCH (such as DAV:getetag).  See also
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], Section&amp;nbsp;3.12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#section-8.7&quot;&gt;섹션 8.7&lt;/a&gt; 에서 소개 된 바와 같이오류 상태에 대한 추가 정보는 여러 상태 응답 본문에 포함될 수 있습니다. 이 섹션에서는 오류 본문 메커니즘 사용에 대한 요구 사항을 만들고 여러 전제 조건 및 사후 조건 코드를 소개합니다. 메소드의 &quot;전제 조건&quot;은 해당 메소드가 수행 되려면 서버의 상태를 설명합니다. 메소드의 &quot;사후 조건&quot;은 해당 메소드가 완료된 후 참이어야하는 서버의 상태를 설명합니다. 각 사전 조건과 사후 조건에는 고유 한 XML 요소가 있습니다. 207 다중 상태 응답에서 XML 요소는 적절한 'propstat 또는'response '의'error '요소 안에 있어야합니다.조건이 하나 이상의 속성에 적용되는지 또는 리소스 전체에 적용되는지에 따라 요소. 이 명세의 '오류'본문이 사용되는 다른 모든 오류 응답에서, 사전 조건 / 사후 조건 XML 요소는 요청과 다르게 협상되지 않는 한 응답 본문에서 최상위 '오류'요소의 자식으로 반환되어야합니다. 적절한 응답 상태. 요청이 항상 실패하여 반복되지 않아야하는 경우 가장 일반적인 응답 상태 코드는 403 (금지됨)이고, 사용자가 충돌을 해결하고 요청을 다시 제출할 수있을 것으로 예상되는 경우 409 (충돌)입니다. 'error'요소는 특정 오류 정보가있는 자식 요소를 포함 할 수 있으며 모든 사용자 정의 자식 요소로 확장 될 수 있습니다.클라이언트는 항상 숫자 코드만을 기반으로 합리적인 조치를 취할 수 있어야하기 때문에이 메커니즘은 여기 또는 HTTP에 정의 된 올바른 숫자 상태 코드를 사용하지 않습니다. 그러나 새 숫자 코드를 정의 할 필요가 없습니다. 이 목적으로 사용되는 새로운 기계 판독 가능 코드는 전제 조건과 사후 조건으로 분류 된 XML 요소이므로 당연히 새 조건 코드를 정의하는 모든 그룹은 자체 네임 스페이스를 사용할 수 있습니다. 항상 그렇듯이 &quot;DAV :&quot;네임 스페이스는 IETF 공인 WebDAV 작업 그룹에서 사용하도록 예약되어 있습니다. 이 사양을 지원하는 서버는이 문서에 정의 된 전제 조건 또는 사후 조건을 위반할 때마다 XML 오류를 사용해야합니다. 이 문서에 명시되지 않은 오류 조건의 경우서버는 단순히 적절한 숫자 상태를 선택하고 응답 본문을 비워 둘 수 있습니다. 그러나 클라이언트가 조건 코드를 자동으로 인식하지 않더라도 상호 운용성 테스트 및 디버깅에 매우 유용 할 수 있기 때문에 서버는 대신 사용자 정의 조건 코드 및 기타 지원 텍스트를 사용할 수 있습니다. 예-전제 조건 코드 &amp;gt;&amp;gt; 응답 HTTP / 1.1의 응답 423 잠긴 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;콘텐츠 길이 : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : error xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : lock-token-submitted &amp;gt; &amp;lt;D : href&amp;gt; / workspace / webdav / &amp;lt;/ D : href&amp;gt; &amp;lt;/ D : lock-token-submitted&amp;gt; &amp;lt;/ D : error&amp;gt;이 예에서상위 콜렉션 &quot;/ workspace / webdav /&quot;에서 깊이 무한대 잠금을 인식하지 못하는 클라이언트가 콜렉션 구성원 &quot;/workspace/webdav/proposal.doc&quot;을 수정하려고했습니다. WebDAV를 확장하는 다른 사양에는 다음과 같은 다른 유용한 전제 조건과 사후 조건이 정의되어 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt; ] (특히 &lt;a href=&quot;#section-7.1.1&quot;&gt;섹션 7.1.1&lt;/a&gt; 참조 ), [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC3648&lt;/a&gt;]. 이러한 모든 요소는 &quot;DAV :&quot;네임 스페이스에 있습니다. 달리 지정하지 않으면 각 조건의 XML 요소에 대한 내용이 비어있는 것으로 정의됩니다. 이름 : lock-token-matches-request-uri 다음과 함께 사용 : 409 충돌 목적 : (전제 조건)-요청에 UNLOCK 메서드의 잠금을 식별하기위한 Lock-Token 헤더가 포함될 수 있습니다. 그러나 Request-URI가 토큰으로 식별 된 잠금 범위에 속하지 않으면 서버는이 오류를 사용해야합니다. 잠금에 Request-URI가 포함되지 않은 범위가 있거나 잠금이 사라 졌거나 토큰이 유효하지 않을 수 있습니다. 이름 : 잠금 토큰 제출 (전제 조건) 다음과 함께 사용 : 423 잠금 목적 : 잠금 토큰이 제출되어 요청이 실패했습니다. 이 요소가 있다면요청을 방해하는 잠겨진 리소스의 URL을 하나 이상 포함해야합니다. 콜렉션 잠금이 관련된 MOVE, COPY 및 DELETE의 경우, 클라이언트가 어떤 잠금 자원이 요청을 실패하게했는지 알아내는 것이 어려울 수 있지만 서버는 이러한 잠금 자원 중 하나만 리턴해야합니다. 서버는 요청을 모두 알고 있으면 요청이 성공하지 못하도록 잠긴 모든 자원을 반환 할 수 있습니다. &amp;lt;! ELEMENT 잠금 토큰 제출 (href +)&amp;gt; 이름 : 충돌 방지 잠금 (전제 조건) 함께 사용 : 일반적으로 423 잠금 목적 : 기존 충돌 잠금이 이미 존재하므로 잠금 요청에 실패했습니다. 요청이 전달 된 리소스가 간접적으로 만 잠겨 있어도 잠금이 충돌 할 수 있습니다. 이 경우전제 조건 코드는 &quot;lockdiscovery&quot;특성의 개별적인 조회를 피하면서 충돌 잠금의 루트 인 자원에 대해 클라이언트에 알리는 데 사용될 수 있습니다. &amp;lt;! ELEMENT no-conflicting-lock (href) *&amp;gt; 이름 : no-external-entities와 함께 사용 : 403 금지 목적 : (전제 조건)-요청 본문에 외부 엔터티가 포함되어있어 서버가 클라이언트 요청을 거부하는 경우 서버 이 오류를 사용해야합니다. 이름 : preserved-live-properties 다음과 함께 사용 : 409 충돌 목적 : (사후 조건)-서버가 유효하지 않은 MOVE 또는 COPY 요청을 받았지만 대상에서 동일한 동작으로 라이브 속성을 유지할 수 없습니다. 서버가 저장소 일부의 일부 라이브 속성 만 지원할 수 있습니다.또는 단순히 내부 오류가 있습니다. 이름 : propfind-finite-depth 다음과 함께 사용 : 403 금지 용도 : (전제 조건)-이 서버는 컬렉션에서 무한 깊이 PROPFIND 요청을 허용하지 않습니다. 이름 : 수정할 수 없음-속성 속성 사용 : 403 금지 목적 : (전제 조건)-클라이언트가 PROPPATCH에서 보호 속성 (예 : DAV : getetag)을 설정하려고했습니다. 또한보십시오 &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], 섹션 3.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe77ba78e510c9166dbea1c2b28c359c08ac3d8" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;identity&lt;/code&gt; value, meaning no encoding, is not explicitly forbidden, by an &lt;code&gt;identity;q=0&lt;/code&gt; or a &lt;code&gt;*;q=0&lt;/code&gt; without another explicitly set value for identity, the server must never send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Acceptable&lt;/code&gt; error.</source>
          <target state="translated">긴만큼 &lt;code&gt;identity&lt;/code&gt; 더 인코딩을 의미가없는 값, 명시 적으로 금지되지 않는 &lt;code&gt;identity;q=0&lt;/code&gt; 또는 &lt;code&gt;*;q=0&lt;/code&gt; 정체성에 대한 또 다른 명시 적으로 설정 값없이 서버가 다시 보낼 안 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Acceptable&lt;/code&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="74200951f8f3fa2318cb0493483bd1ef3add00e6" translate="yes" xml:space="preserve">
          <source>As long as the cache is not stale, no requests are issued at all. But once it has become stale, this is mostly controlled by the &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header, the client doesn't use the cached value directly but issues a &lt;em&gt;conditional request&lt;/em&gt;. The value of the validator is used as a parameter of the &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">캐시가 오래되지 않으면 요청이 전혀 발행되지 않습니다. 그러나 그것이 오래되면, 이것은 대부분 &lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 헤더에 의해 제어되며 , 클라이언트는 캐시 된 값을 직접 사용하지 않고 &lt;em&gt;조건부 요청을&lt;/em&gt; 발행합니다 . 유효성 검증기의 값은 &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 매개 변수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="39de7dbf0fcbd56548611790fd4f9d1859fcff38" translate="yes" xml:space="preserve">
          <source>As of HTTP/1.1, the connection is no longer closed after completing the third phase, and the client is now granted a further request: this means the second and third phases can now be performed any number of times.</source>
          <target state="translated">HTTP / 1.1 기준으로, 3 단계를 완료 한 후 연결이 더 이상 닫히지 않으며 이제 클라이언트에게 추가 요청이 부여됩니다. 이는 이제 2 단계 및 3 단계를 여러 번 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10737eb038a18f448d914366beb682e160b36994" translate="yes" xml:space="preserve">
          <source>As seen earlier, in most cases, looking for the rendering engine is a better way to go. This will help to not exclude lesser known browsers. Browsers sharing a common rendering engine will display a page in the same way: it is often a fair assumption that what will work in one will work in the other.</source>
          <target state="translated">앞에서 본 것처럼 대부분의 경우 렌더링 엔진을 찾는 것이 더 좋은 방법입니다. 이렇게하면 덜 알려진 브라우저를 제외하지 않을 수 있습니다. 공통 렌더링 엔진을 공유하는 브라우저는 같은 방식으로 페이지를 표시합니다. 한 페이지에서 작동하는 것이 다른 사이트에서도 작동 할 것이라고 가정하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="78c188cf3444dcabae8c9d4a1f5961a9553d9194" translate="yes" xml:space="preserve">
          <source>As several representations of a given resource are sent, shared caches are less efficient and server implementations are more complex.</source>
          <target state="translated">주어진 자원의 여러 표현이 전송 될 때 공유 캐시의 효율성이 떨어지고 서버 구현이 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="7377d313a5ee9a8718b11c2ecd95fc7f352f8569" translate="yes" xml:space="preserve">
          <source>As the above code demonstrates, there is &lt;strong&gt;always &lt;/strong&gt;a way to test browser support on anything, no exceptions. There &lt;strong&gt;never &lt;/strong&gt;any reason to check the user string for this.</source>
          <target state="translated">위의 코드에서 알 수 있듯이 예외없이 브라우저 지원을 테스트 할 수있는 방법 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다. 이를 위해 사용자 문자열을 확인할 이유 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1896c32232ae10635b0e9d7b6084cf07068dbb" translate="yes" xml:space="preserve">
          <source>As the name implies, a reverse proxy does the opposite of what a forward proxy does: A forward proxy acts in behalf of clients (or requesting hosts), a reverse proxy acts in behalf of servers. Forward proxies can hide the identities of clients whereas reverse proxies can hide the identities of servers. Reverse proxies have several use cases, a few are:</source>
          <target state="translated">이름에서 알 수 있듯이 역방향 프록시는 정방향 프록시의 기능과 반대입니다. 정방향 프록시는 클라이언트 대신 (또는 호스트 요청), 역방향 프록시는 서버를 대신하여 작동합니다. 정방향 프록시는 클라이언트의 ID를 숨길 수 있지만 역방향 프록시는 서버의 ID를 숨길 수 있습니다. 리버스 프록시에는 몇 가지 사용 사례가 있으며 그 중 몇 가지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444c366dc18e9c8a26e52d6d891adf57495dae72" translate="yes" xml:space="preserve">
          <source>As the user ID and password are passed over the network as clear text (it is base64 encoded, but base64 is a reversible encoding), the basic authentication scheme is not secure. HTTPS / TLS should be used in conjunction with basic authentication. Without these additional security enhancements, basic authentication should not be used to protect sensitive or valuable information.</source>
          <target state="translated">사용자 ID와 비밀번호가 일반 텍스트 (base64 인코딩이지만 base64는 가역 인코딩)로 네트워크를 통해 전달되므로 기본 인증 체계는 안전하지 않습니다. 기본 인증과 함께 HTTPS / TLS를 사용해야합니다. 이러한 추가 보안 향상 기능이 없으면 기본 인증을 사용하여 중요하거나 중요한 정보를 보호해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a6c3ae8778eda348525a5dd269ea2b796710e51f" translate="yes" xml:space="preserve">
          <source>As there is no uniformity of the different part of the user agent string, this is the tricky part.</source>
          <target state="translated">사용자 에이전트 문자열의 다른 부분에는 균일 성이 없으므로 까다로운 부분입니다.</target>
        </trans-unit>
        <trans-unit id="17fdcd20e92320a37954cc0aaa2c4492b1c32a15" translate="yes" xml:space="preserve">
          <source>As well as styles that are applied in Javascript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt;&lt;code&gt;cssText&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">뿐만 아니라 설정하여 자바 스크립트에 적용되는 스타일 &lt;code&gt;style&lt;/code&gt; , 또는 설정하여 직접 속성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt; &lt;code&gt;cssText&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d02d7f17a2dcce723df40692e0f522ac350d18cf" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;, input filtering is important.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; 와 마찬가지로 입력 필터링이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="090adf7d66d69b3cc82ada8155a31b95b1d5cc05" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt;&lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;&lt;/a&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">보다시피, 보고서에는 &lt;code&gt;blocked-uri&lt;/code&gt; 의 위반 리소스에 대한 전체 경로가 포함됩니다 . 항상 그런 것은 아닙니다. 예를 들어 &lt;code&gt;signup.html&lt;/code&gt; 이 &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt; &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; &lt;/a&gt; 에서 CSS를로드하려고 하면 브라우저 에 전체 경로는 포함 &lt;em&gt;되지 않고&lt;/em&gt; 원본 ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ) 만 포함됩니다 ). CSP 사양 &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;은&lt;/a&gt; 이 이상한 행동에 대한 설명 을 제공합니다 . 요약하면, 이는 출처 간 자원에 대한 민감한 정보가 유출되는 것을 방지하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec92124be22f59c3429bab49ee1de958a60686bc" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). This is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">보다시피, 보고서에는 &lt;code&gt;blocked-uri&lt;/code&gt; 의 위반 리소스에 대한 전체 경로가 포함됩니다 . 항상 그런 것은 아닙니다. 예를 들어 &lt;code&gt;signup.html&lt;/code&gt; 이 &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; 에서 CSS를로드하려고 하면 브라우저 에 전체 경로는 포함 &lt;em&gt;되지 않고&lt;/em&gt; 원본 ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ) 만 포함됩니다 ). 이는 출처 간 자원에 대한 민감한 정보가 유출되는 것을 방지하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2597783f8778af171536ba979953d5e5baf049" translate="yes" xml:space="preserve">
          <source>Associates a specific cryptographic public key with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates.</source>
          <target state="translated">특정 암호화 공개 키를 특정 웹 서버 와 연결하여 위조 된 인증서 로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; 공격 의 위험을 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="4423c564a6dd958705092c9f3f6196baaeb909f9" translate="yes" xml:space="preserve">
          <source>At this point, a typical request and response looked like this:</source>
          <target state="translated">이 시점에서 일반적인 요청 및 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="640a65ab124efd895e7362db6ab879724f9f4606" translate="yes" xml:space="preserve">
          <source>Atom Entry and Feed Documents can contain XML Digital Signatures
   [&lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;] and can be encrypted using XML Encryption
   [&lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;] as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC4287]&lt;/a&gt;.  Handling
   of signatures and encrypted elements in Atom documents is discussed
   in Sections &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   Neither servers nor clients are under any obligation to support
   encryption and digital signature of Entries or Feeds, although it is
   certainly possible that in some installations, clients or servers
   might require signing or encrypting of the documents exchanged in the
   Atom Protocol.

   Because servers are allowed (and in some cases, expected) to modify
   the contents of an Entry Document before publishing it, signatures
   within an entry are only likely to be useful to the server to which
   the entry is being sent.  Clients cannot assume that the signature
   will be valid when viewed by a third party, or even that the server
   will publish the client's signature.

   A server is allowed to strip client-applied signatures, to strip
   client-applied signatures and then re-sign with its own public key,
   and to oversign an entry with its own public key.  The meaning to a
   third party of a signature applied by a server is the same as a
   signature from anyone, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  It is RECOMMENDED
   that a server that is aware that it has changed any part of an Entry
   Document that was signed by the client should strip that signature
   before publishing the entry in order to prevent third parties from
   trying to interpret a signature that cannot be validated.</source>
          <target state="translated">원자 입력 및 피드 문서는 XML 디지털 서명 [ &lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ]을 포함 할 수 있으며 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;[RFC4287]의 섹션 5에&lt;/a&gt; 지정된 XML 암호화 [ &lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ]를 사용하여 암호화 할 수 있습니다 . Atom 문서의 서명 및 암호화 된 요소 처리는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; 의 섹션 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 및 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; 에 설명되어 있습니다.]. 서버 나 클라이언트는 항목 또는 피드의 암호화 및 디지털 서명을 지원할 의무가 없지만, 일부 설치에서는 클라이언트 또는 서버가 Atom 프로토콜에서 교환 된 문서의 서명 또는 암호화를 요구할 수 있습니다. 항목 문서를 게시하기 전에 서버가 항목 문서의 내용을 수정할 수 있고 (경우에 따라 예상되는) 항목 항목의 서명은 항목을 보내는 서버에만 유용 할 것입니다. 클라이언트는 제 3자가 볼 때 서명이 유효하거나 서버가 클라이언트의 서명을 게시한다고 가정 할 수 없습니다. 서버는 클라이언트에 적용된 서명을 제거하고 클라이언트에 적용된 서명을 제거한 다음 자체 공개 키로 다시 서명 할 수 있습니다.자신의 공개 키로 항목을 서명합니다. 서버에서 적용한 서명의 타사에 대한 의미는 [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. 클라이언트가 서명 한 항목 문서의 일부를 변경했음을 알고있는 서버는 항목을 공개하기 전에 해당 서명을 제거하여 검증 할 수없는 서명을 해석하지 못하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c5aa3a3e4c19a0f5bd9d139cb1cf724de62f5c3f" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain XML External Entities as
   defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  Atom implementations are not
   required to load external entities.  External entities are subject to
   the same security concerns as any network operation and can alter the
   semantics of an Atom document.  The same issues exist for Resources
   linked to by Atom elements such as atom:link and atom:content.</source>
          <target state="translated">Atom Feed 및 Entry 문서는 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]의 4.2.2 섹션에 정의 된 XML 외부 엔티티를 포함 할 수 있습니다 . 외부 엔티티를로드하기 위해 Atom 구현이 필요하지 않습니다. 외부 엔터티는 모든 네트워크 작업과 동일한 보안 문제가 적용되며 Atom 문서의 의미를 변경할 수 있습니다. atom : link 및 atom : content와 같은 Atom 요소로 링크 된 자원에 대해서도 동일한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb39269091e71d2cf80365bde28208d78373e852" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain a broad range of content
   types including code that might be executable in some contexts.
   Malicious clients could attempt to attack servers or other clients by
   injecting code into a Collection Document's Entry or Media Resources.

   Server implementations are strongly encouraged to verify that client-
   supplied content is safe prior to accepting, processing, or
   publishing it.  In the case of HTML, experience indicates that
   verification based on a white list of acceptable content is more
   effective than a black list of forbidden content.

   Additional information about XHTML and HTML content safety can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;Section&amp;nbsp;8.1 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">Atom Feed and Entry Documents는 일부 컨텍스트에서 실행 가능한 코드를 포함하여 광범위한 컨텐츠 유형을 포함 할 수 있습니다. 악의적 인 클라이언트는 수집 문서의 항목 또는 미디어 리소스에 코드를 삽입하여 서버 또는 다른 클라이언트를 공격 할 수 있습니다. 서버에서 구현하면 클라이언트가 제공 한 콘텐츠가 수락, 처리 또는 게시되기 전에 안전한지 확인하는 것이 좋습니다. HTML의 경우 경험에 따르면 허용되는 콘텐츠의 허용 목록을 기반으로하는 확인은 금지 된 콘텐츠의 차단 목록보다 효과적입니다. XHTML 및 HTML 컨텐츠 안전에 대한 추가 정보 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;는 [RFC4287] 섹션 8.1&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f30f294721759bc8f3b4c8af76920be111f1ebd" translate="yes" xml:space="preserve">
          <source>Atom Protocol Document formats are specified in terms of the XML
   Information Set [&lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;], serialized as XML 1.0 [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].

   The Infoset terms &quot;Element Information Item&quot; and &quot;Attribute
   Information Item&quot; are shortened to &quot;element&quot; and &quot;attribute&quot;
   respectively.  Therefore, when this specification uses the term
   &quot;element&quot;, it is referring to an Element Information Item, and when
   it uses the term &quot;attribute&quot;, it is referring to an Attribute
   Information Item.</source>
          <target state="translated">Atom 프로토콜 문서 형식은 XML 정보 세트 [ &lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ]로 지정되며 XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]으로 직렬화됩니다 . 정보 요소 용어 &quot;요소 정보 항목&quot;및 &quot;속성 정보 항목&quot;은 각각 &quot;요소&quot;및 &quot;속성&quot;으로 단축됩니다. 따라서, 본 명세서에서 &quot;요소&quot;라는 용어를 사용하는 경우에는 요소 정보 항목을 의미하고, &quot;속성&quot;이라는 용어를 사용하는 경우 속성 정보 항목을 의미한다.</target>
        </trans-unit>
        <trans-unit id="2e1b50db6b134e88169d0061fffd21c5907dcc49" translate="yes" xml:space="preserve">
          <source>Atom Protocol documents allow the use of IRIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;] as well as
   URIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to identify Resources.  Before an IRI in a document is
   used by HTTP, the IRI is first converted to a URI according to the
   procedure defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC3987]&lt;/a&gt;.  In accordance with
   that specification, the conversion SHOULD be applied as late as
   possible.  Conversion does not imply Resource creation -- the IRI and
   the URI into which it is converted identify the same Resource.

   While the Atom Protocol specifies the formats of the representations
   that are exchanged and the actions that can be performed on the IRIs
   embedded in those representations, it does not constrain the form of
   the URIs that are used.  HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] specifies that the URI space
   of each server is controlled by that server, and this protocol
   imposes no further constraints on that control.</source>
          <target state="translated">Atom 프로토콜 문서를 사용하면 IRI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]와 URI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]를 사용하여 자원을 식별 할 수 있습니다. HTTP에서 문서의 IRI를 사용하기 전에 먼저 &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;IRF가 [RFC3987] 3.1 절에&lt;/a&gt; 정의 된 절차에 따라 URI로 변환됩니다 . 그 사양에 따라, 변환은 가능한 한 늦게 적용되어야한다. 변환은 자원 작성을 의미하지 않습니다. IRI와 변환 된 URI는 동일한 자원을 식별합니다. Atom 프로토콜은 교환되는 표시 형식과 해당 표시에 임베드 된 IRI에서 수행 할 수있는 조치를 지정하지만 사용되는 URI의 형식을 제한하지는 않습니다. HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]는 각 서버의 URI 공간이 해당 서버에 의해 제어되도록 지정하며이 프로토콜은 해당 제어에 대한 추가 제한 조건을 부과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="736c134a608fda6f7298f3bba3cfd72a9fdecd9a" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations are susceptible to a variety
   of spoofing attacks.  Malicious clients might send Atom Entries
   containing inaccurate information anywhere in the document.</source>
          <target state="translated">Atom Publishing Protocol 구현은 다양한 스푸핑 공격에 취약합니다. 악의적 인 클라이언트는 문서의 어느 곳에서나 부정확 한 정보가 포함 된 Atom 항목을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde284149405876b277c263099cd3f0fe408f3d" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations handle URIs and IRIs.  See
   &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;Section&amp;nbsp;7 of [RFC3986]&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC3987]&lt;/a&gt; for security
   considerations related to their handling and use. 

   The Atom Publishing Protocol leaves the server in control of minting
   URIs.  The use of any client-supplied data for creating new URIs is
   subject to the same concerns as described in the next section.</source>
          <target state="translated">Atom Publishing Protocol 구현은 URI 및 IRI를 처리합니다. 취급 및 사용과 관련된 보안 고려 사항에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;[RFC3986]의 섹션 7&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;[RFC3987]의 섹션 8을&lt;/a&gt; 참조하십시오 . Atom Publishing Protocol은 서버를 Minting URI를 제어하도록합니다. 새 URI를 작성하기 위해 클라이언트가 제공 한 데이터를 사용하는 경우 다음 섹션에서 설명한 것과 동일한 우려가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="43c64fa2cad1ec9b5d7097b9637cf7e73d027deb" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations are susceptible to
   replay attacks.  Specifically, this specification does not define a
   means of detecting duplicate requests.  Accidentally sent duplicate
   requests are indistinguishable from intentional and malicious replay
   attacks.</source>
          <target state="translated">Atom Publishing Protocol 서버 구현은 공격을 재생하기 쉽습니다. 특히이 사양에서는 중복 요청을 감지하는 방법을 정의하지 않습니다. 실수로 전송 된 중복 요청은 의도적 인 악의적 재생 공격과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2972250359d4c37b4863cb1f87236835622705f3" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations need to take adequate
   precautions to ensure malicious clients cannot consume excessive
   server resources (CPU, memory, disk, etc.).</source>
          <target state="translated">Atom Publishing Protocol 서버 구현은 악의적 인 클라이언트가 과도한 서버 리소스 (CPU, 메모리, 디스크 등)를 소비 할 수 없도록 적절한 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c002bc6355801197a02bfae106d0ff5c2ac8619" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit

   Description:  An IRI of an editable Member Entry.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Resource represented by that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">속성 값 : 편집 설명 : 편집 가능한 멤버 항목의 IRI atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목이 나타내는 자원을 검색, 업데이트 및 삭제할 수 있습니다. 예상 디스플레이 특성 : 정의되지 않음; 이 관계는 백그라운드 처리 또는 값을 표시하지 않고 확장 된 기능을 제공하는 데 사용될 수 있습니다. 보안 고려 사항 : 자동화 된 에이전트는이 관계가 관리 도메인을 교차 할 때주의해야합니다 (예 : URI가 현재 문서와 다른 권한을 가짐).</target>
        </trans-unit>
        <trans-unit id="37137689e8aac586d2a2206e3451c0c78ed0404b" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit-media

   Description:  An IRI of an editable Media Resource.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Media Resource associated with that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">속성 값 : edit-media 설명 : 편집 가능한 미디어 리소스의 IRI. atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목과 연관된 매체 자원을 검색, 업데이트 및 삭제할 수 있습니다. 예상 디스플레이 특성 : 정의되지 않음; 이 관계는 백그라운드 처리 또는 값을 표시하지 않고 확장 된 기능을 제공하는 데 사용될 수 있습니다. 보안 고려 사항 : 자동화 된 에이전트는이 관계가 관리 도메인을 교차 할 때주의해야합니다 (예 : URI가 현재 문서와 다른 권한을 가짐).</target>
        </trans-unit>
        <trans-unit id="f249c1f3c78b5d8dfebf667cc36b2ac178b2dfce" translate="yes" xml:space="preserve">
          <source>Audio and video types</source>
          <target state="translated">오디오 및 비디오 유형</target>
        </trans-unit>
        <trans-unit id="e6d4341caf182975ff694c881dad755bd726c7a8" translate="yes" xml:space="preserve">
          <source>Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. Be sure to &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;use the correct type for audio and video&lt;/a&gt;.</source>
          <target state="translated">오디오 및 비디오. 올바른 MIME 유형을 가진 리소스 만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 재생됩니다 . &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;오디오 및 비디오에 올바른 유형&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="147b0d392949573e61339af923f0d61f3d4158e3" translate="yes" xml:space="preserve">
          <source>Audio or video type</source>
          <target state="translated">오디오 또는 비디오 유형</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="fc6c8170f13d7b26f5b4b7880a4d642545c57a00" translate="yes" xml:space="preserve">
          <source>Authentication challenges indicate what mechanisms are available for
   the client to provide authentication credentials in future requests.

   +--------------------+--------------------------+
   | Header Field Name  | Defined in...            |
   +--------------------+--------------------------+
   | WWW-Authenticate   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authenticate | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7235]&lt;/a&gt; |
   +--------------------+--------------------------+</source>
          <target state="translated">인증 문제는 클라이언트가 향후 요청에서 인증 자격 증명을 제공 할 수있는 메커니즘을 나타냅니다. + -------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + -------------------- + -------------------------- + | WWW 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;[RFC7235] 섹션 4.1&lt;/a&gt; | | 프록시 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;[RFC7235] 섹션 4.3&lt;/a&gt; | + -------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="153bcddcdfb94a1c4fcc1b07386bec94f199b549" translate="yes" xml:space="preserve">
          <source>Authentication of cross-origin images</source>
          <target state="translated">교차 출처 이미지 인증</target>
        </trans-unit>
        <trans-unit id="76f2d621f56ba98464057328fa277805b179a4c3" translate="yes" xml:space="preserve">
          <source>Authentication schemes</source>
          <target state="translated">인증 체계</target>
        </trans-unit>
        <trans-unit id="82c6eeec306dfcdeb221624f2ddf32ce5652cd2a" translate="yes" xml:space="preserve">
          <source>Authentication schemes that solely rely on the &quot;realm&quot; mechanism for
   establishing a protection space will expose credentials to all
   resources on an origin server.  Clients that have successfully made
   authenticated requests with a resource can use the same
   authentication credentials for other resources on the same origin
   server.  This makes it possible for a different resource to harvest
   authentication credentials for other resources.

   This is of particular concern when an origin server hosts resources
   for multiple parties under the same canonical root URI (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;).
   Possible mitigation strategies include restricting direct access to
   authentication credentials (i.e., not making the content of the
   Authorization request header field available), and separating
   protection spaces by using a different host name (or port number) for
   each party.</source>
          <target state="translated">보호 공간을 설정하기 위해 &quot;영역&quot;메커니즘에만 의존하는 인증 체계는 원본 서버의 모든 리소스에 자격 증명을 노출합니다. 리소스로 인증 된 요청을 한 클라이언트는 동일한 원본 서버의 다른 리소스에 대해 동일한 인증 자격 증명을 사용할 수 있습니다. 이를 통해 다른 리소스가 다른 리소스에 대한 인증 자격 증명을 수집 할 수 있습니다. 이는 오리진 서버가 동일한 표준 루트 URI ( &lt;a href=&quot;#section-2.2&quot;&gt;2.2 절)&lt;/a&gt; 에서 여러 당사자에 대한 자원을 호스팅 할 때 특히 중요합니다.). 가능한 완화 전략에는 인증 자격 증명에 대한 직접 액세스 제한 (즉, 인증 요청 헤더 필드의 내용을 사용할 수 없음) 및 각 당사자에 대해 다른 호스트 이름 (또는 포트 번호)을 사용하여 보호 공간 분리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e8fe0af4751860c096cd4a38e3b9eeae02683be" translate="yes" xml:space="preserve">
          <source>Authentification for AWS servers (&lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt;)</source>
          <target state="translated">AWS 서버 인증 ( &lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="97a9869cf89f831749f9533eebd33a7ff2d561cb" translate="yes" xml:space="preserve">
          <source>Authority</source>
          <target state="translated">Authority</target>
        </trans-unit>
        <trans-unit id="5e25ce007aa95ea2ea8b158aee9c630a32ea5616" translate="yes" xml:space="preserve">
          <source>Authorization</source>
          <target state="translated">Authorization</target>
        </trans-unit>
        <trans-unit id="3224c382af3d5fca4ce96ea1f1e751cb8cb2158f" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 2616)</source>
          <target state="translated">승인 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="bae9490e931f2a313f9d9d7c5b0605ca243c7183" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 7235)</source>
          <target state="translated">승인 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="95619b532fe893a1b62f3f25950021c4a689dd4d" translate="yes" xml:space="preserve">
          <source>Autoplay</source>
          <target state="translated">Autoplay</target>
        </trans-unit>
        <trans-unit id="c2caaa3b5ae832f6f7280b3a4c0e89023587c880" translate="yes" xml:space="preserve">
          <source>Avoiding mid-air collisions</source>
          <target state="translated">공중 충돌 방지</target>
        </trans-unit>
        <trans-unit id="cff193e7487bbc8578fa13e29841eaf30a9bedc1" translate="yes" xml:space="preserve">
          <source>Avoiding the lost update problem with optimistic locking</source>
          <target state="translated">낙관적 잠금으로 인한 업데이트 손실 문제 방지</target>
        </trans-unit>
        <trans-unit id="8d576102d4917836a687b68a54b6ec02b0270e5d" translate="yes" xml:space="preserve">
          <source>Avoiding user agent detection</source>
          <target state="translated">사용자 에이전트 감지 방지</target>
        </trans-unit>
        <trans-unit id="ecd4ecba402cd2d1689af61cc723efcbd052a8bf" translate="yes" xml:space="preserve">
          <source>BWS = OWS

   Connection = *( &quot;,&quot; OWS ) connection-option *( OWS &quot;,&quot; [ OWS
    connection-option ] )

   Content-Length = 1*DIGIT

   HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body
    ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
   Host = uri-host [ &quot;:&quot; port ]

   OWS = *( SP / HTAB )

   RWS = 1*( SP / HTAB )

   TE = [ ( &quot;,&quot; / t-codings ) *( OWS &quot;,&quot; [ OWS t-codings ] ) ]
   Trailer = *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ] )
   Transfer-Encoding = *( &quot;,&quot; OWS ) transfer-coding *( OWS &quot;,&quot; [ OWS
    transfer-coding ] )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
   Upgrade = *( &quot;,&quot; OWS ) protocol *( OWS &quot;,&quot; [ OWS protocol ] )

   Via = *( &quot;,&quot; OWS ) ( received-protocol RWS received-by [ RWS comment
    ] ) *( OWS &quot;,&quot; [ OWS ( received-protocol RWS received-by [ RWS
    comment ] ) ] )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
   absolute-form = absolute-URI
   absolute-path = 1*( &quot;/&quot; segment )
   asterisk-form = &quot;*&quot;
   authority = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
   authority-form = authority 

   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-part CRLF
   comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
   connection-option = token
   ctext = HTAB / SP / %x21-27 ; '!'-'''
    / %x2A-5B ; '*'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text

   field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   field-name = token
   field-value = *( field-content / obs-fold )
   field-vchar = VCHAR / obs-text
   fragment = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

   header-field = field-name &quot;:&quot; OWS field-value OWS
   http-URI = &quot;http://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]
   https-URI = &quot;https://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]

   last-chunk = 1*&quot;0&quot; [ chunk-ext ] CRLF

   message-body = *OCTET
   method = token

   obs-fold = CRLF 1*( SP / HTAB )
   obs-text = %x80-FF
   origin-form = absolute-path [ &quot;?&quot; query ]

   partial-URI = relative-part [ &quot;?&quot; query ]
   path-abempty = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   protocol = protocol-name [ &quot;/&quot; protocol-version ]
   protocol-name = token
   protocol-version = token
   pseudonym = token

   qdtext = HTAB / SP / &quot;!&quot; / %x23-5B ; '#'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text
   query = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text ) 

   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE

   rank = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )
   reason-phrase = *( HTAB / SP / VCHAR / obs-text )
   received-by = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
   relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
   request-line = method SP request-target SP HTTP-version CRLF
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form

   scheme = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
   segment = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   start-line = request-line / status-line
   status-code = 3DIGIT
   status-line = HTTP-version SP status-code SP reason-phrase CRLF

   t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
   t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
   tchar = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot; / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; /
    &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot; / DIGIT / ALPHA
   token = 1*tchar
   trailer-part = *( header-field CRLF )
   transfer-coding = &quot;chunked&quot; / &quot;compress&quot; / &quot;deflate&quot; / &quot;gzip&quot; /
    transfer-extension
   transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )
   transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   uri-host = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt; 

Index

   A
      absolute-form (of request-target)  42
      accelerator  10
      application/http Media Type  63
      asterisk-form (of request-target)  43
      authoritative response  67
      authority-form (of request-target)  42-43

   B
      browser  7

   C
      cache  11
      cacheable  12
      captive portal  11
      chunked (Coding Format)  28, 32, 36
      client  7
      close  51, 56
      compress (Coding Format)  38
      connection  7
      Connection header field  51, 56
      Content-Length header field  30

   D
      deflate (Coding Format)  38
      Delimiters  27
      downstream  10

   E
      effective request URI  45

   G
      gateway  10
      Grammar
         absolute-form  42
         absolute-path  16
         absolute-URI  16
         ALPHA  6
         asterisk-form  41, 43
         authority  16
         authority-form  42-43
         BWS  25
         chunk  36
         chunk-data  36
         chunk-ext  36
         chunk-ext-name  36 

         chunk-ext-val  36
         chunk-size  36
         chunked-body  36
         comment  27
         Connection  51
         connection-option  51
         Content-Length  30
         CR  6
         CRLF  6
         ctext  27
         CTL  6
         DIGIT  6
         DQUOTE  6
         field-content  23
         field-name  23, 40
         field-value  23
         field-vchar  23
         fragment  16
         header-field  23, 37
         HEXDIG  6
         Host  44
         HTAB  6
         HTTP-message  19
         HTTP-name  14
         http-URI  17
         HTTP-version  14
         https-URI  18
         last-chunk  36
         LF  6
         message-body  28
         method  21
         obs-fold  23
         obs-text  27
         OCTET  6
         origin-form  42
         OWS  25
         partial-URI  16
         port  16
         protocol-name  47
         protocol-version  47
         pseudonym  47
         qdtext  27
         query  16
         quoted-pair  27
         quoted-string  27
         rank  39
         reason-phrase  22
         received-by  47 

         received-protocol  47
         request-line  21
         request-target  41
         RWS  25
         scheme  16
         segment  16
         SP  6
         start-line  21
         status-code  22
         status-line  22
         t-codings  39
         t-ranking  39
         tchar  27
         TE  39
         token  27
         Trailer  40
         trailer-part  37
         transfer-coding  35
         Transfer-Encoding  28
         transfer-extension  35
         transfer-parameter  35
         Upgrade  57
         uri-host  16
         URI-reference  16
         VCHAR  6
         Via  47
      gzip (Coding Format)  39

   H
      header field  19
      header section  19
      headers  19
      Host header field  44
      http URI scheme  17
      https URI scheme  17
   I
      inbound  9
      interception proxy  11
      intermediary  9

   M
      Media Type
         application/http  63
         message/http  62
      message  7
      message/http Media Type  62
      method  21 

   N
      non-transforming proxy  49

   O
      origin server  7
      origin-form (of request-target)  42
      outbound  10

   P
      phishing  67
      proxy  10

   R
      recipient  7
      request  7
      request-target  21
      resource  16
      response  7
      reverse proxy  10

   S
      sender  7
      server  7
      spider  7

   T
      target resource  40
      target URI  40
      TE header field  39
      Trailer header field  40
      Transfer-Encoding header field  28
      transforming proxy  49
      transparent proxy  11
      tunnel  10

   U
      Upgrade header field  57
      upstream  9
      URI scheme
         http  17
         https  17
      user agent  7

   V
      Via header field  47 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 89]</source>
          <target state="translated">BWS = OWS 연결 = * ( &quot;,&quot;OWS) 연결 옵션 * (OWS &quot;,&quot;[OWS 연결 옵션]) 컨텐츠 길이 = 1 * DIGIT HTTP 메시지 = 시작 줄 * (헤더 필드 CRLF) CRLF [메시지 본문] HTTP- 이름 = % x48.54.54.50; HTTP HTTP-version = HTTP- 이름 &quot;/&quot;DIGIT &quot;.&quot; DIGIT 호스트 = uri-host [ &quot;:&quot;포트] OWS = * (SP / HTAB) RWS = 1 * (SP / HTAB) TE = [( &quot;,&quot;/ t-codings) * (OWS &quot;,&quot;[OWS t -codings])] Trailer = * ( &quot;,&quot;OWS) field-name * (OWS &quot;,&quot;[OWS field-name]) Transfer-Encoding = * ( &quot;,&quot;OWS) 전송 코딩 * (OWS &quot;,&quot; [OWS 전송 코딩]) URI-reference = &amp;lt;URI-reference, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], 섹션 4.1 참조&lt;/a&gt;&amp;gt; 업그레이드 = * ( &quot;,&quot;OWS) 프로토콜 * (OWS &quot;,&quot;[OWS 프로토콜]) Via = * ( &quot;,&quot;OWS) ([RWS 의견]에 의해 수신 된 프로토콜 RWS 수신) * (OWS &quot;,&quot; [OWS ([RWS 설명]에 의해 수신 된 수신 프로토콜 RWS]]]) absolute-URI = &amp;lt;absolute-URI &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;, 섹션 4.3&lt;/a&gt; 참조 [RFC3986], 섹션 4.3 &amp;gt; absolute-form = absolute-URI 절대 경로 = 1 * ( &quot;/ &quot;segment) 별표 형식 =&quot;* &quot;권한 = &amp;lt;기관, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], 섹션 3.2 참조&lt;/a&gt;&amp;gt; authority-form = authority chunk = 청크 크기 [chunk-ext] CRLF chunk-data CRLF chunk-data = 1 * OCTET chunk-ext = * ( &quot;;&quot;chunk-ext-name [ &quot;=&quot;chunk-ext- val]) chunk-ext-name = token chunk-ext-val = token / quoted-string chunk-size = 1 * HEXDIG chunked-body = * chunk last-chunk trailer-part CRLF comment = &quot;(&quot;* (ctext / 인용 쌍 / 주석) &quot;)&quot;연결 옵션 = 토큰 ctext = HTAB / SP / % x21-27; '!'- '' '/ % x2A-5B; '*'- '['/ % x5D-7E; ']'- '~'/ obs-text field-content = field-vchar [1 * (SP / HTAB) field-vchar] field-name = 토큰 field-value = * (field-content / obs-fold) 필드 -vchar = VCHAR / obs-text fragment = &amp;lt;fragment, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], 섹션 3.5 참조&lt;/a&gt;&amp;gt; header-field = field-name &quot;:&quot;OWS 필드 값 OWS http-URI = &quot;http : //&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;#&quot;fragment] https-URI = &quot;https : //&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;#&quot;fragment] last-chunk = 1 * &quot;0&quot;[chunk-ext] CRLF 메시지 본문 = * OCTET 메소드 = 토큰 obs-fold = CRLF 1 * (SP / HTAB) obs-text = % x80 -FF origin-form = 절대 경로 [ &quot;?&quot; query] partial-URI = 상대 부분 [ &quot;?&quot; query] path-abempty = &amp;lt;path-abempty &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;, 섹션 [RFC3986], 섹션 3.3&lt;/a&gt; &amp;gt; 포트 = &amp;lt;port &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;, 섹션 3.2.3 [RFC3986]&lt;/a&gt; 참조&amp;gt; 프로토콜 = 프로토콜 이름 [ &quot;/&quot;프로토콜 버전] 프로토콜 이름 = 토큰 프로토콜 버전 = 토큰 가명 = 토큰 qdtext = HTAB / SP / &quot;!&quot; / % x23-5B; '#'- '['/ % x5D-7E; ']'- '~'/ obs-text query = &amp;lt;query, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], 3.4 절&lt;/a&gt; 참조 &amp;gt; quoted-pair = &quot;\&quot;(HTAB / SP / VCHAR / obs-text) quoted-string = DQUOTE * (qdtext / quoted-pair) DQUOTE 순위 = ( &quot;0&quot;[ &quot;.&quot;* 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;* 3 &quot;0&quot;]) 이유 문구 = * (HTAB / SP / VCHAR / obs- text) received-by = (uri-host [ &quot;:&quot;port]) / pseudonym received-protocol = [protocol-name &quot;/&quot;] protocol-version relative-part = &amp;lt;상대 부분 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;, 섹션 4.2 [RFC3986]&lt;/a&gt; 참조&amp;gt; request-line = 메소드 SP request-target SP HTTP 버전 CRLF request-target = origin-form / absolute-form / authority-form / asterisk-form scheme = &amp;lt;체계, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], 섹션 3.1&lt;/a&gt; &amp;gt; segment = &amp;lt; 세그먼트, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], 섹션 3.3 참조&lt;/a&gt;&amp;gt; 시작 라인 = 요청 라인 / 상태 라인 상태 코드 = 3DIGIT 상태 라인 = HTTP 버전 SP 상태 코드 SP 이유 문구 CRLF t-codings = &quot;트레일러&quot;/ (전송 코딩 [t- 순위] ) t- 순위 = OWS &quot;;&quot; OWS &quot;q =&quot;랭크 tchar = &quot;!&quot; / &quot;#&quot;/ &quot;$&quot;/ &quot;%&quot;/ &quot;&amp;amp;&quot;/ &quot; '&quot;/ &quot;*&quot;/ &quot;+&quot;/ &quot;-&quot;/ &quot;.&quot; / &quot;^&quot;/ &quot;_&quot;/ &quot;`&quot;/ &quot;|&quot; / &quot;~&quot;/ DIGIT / ALPHA 토큰 = 1 * tchar 트레일러 부분 = * (헤더 필드 CRLF) 전송 코딩 = &quot;청크&quot;/ &quot;압축&quot;/ &quot;수축&quot;/ &quot;gzip&quot;/ 전송 확장 전송 확장 = 토큰 * (OWS &quot;;&quot;OWS 전송 매개 변수) 전송 매개 변수 = 토큰 BWS &quot;= &quot;BWS (token / quoted-string) uri-host = &amp;lt;host, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], 섹션 3.2.2 참조&lt;/a&gt;&amp;gt; 색인 A 절대 형식 (요청 대상) 42 가속기 10 응용 프로그램 / http 미디어 유형 63 별표 형식 (요청 대상) 43 권위있는 응답 67 권한 형식 (요청 대상) 42-43 B 브라우저 7 C 캐시 11 캐시 가능 12 캡 티브 포털 11 청크 (코딩 형식) 28, 32, 36 클라이언트 7 닫기 51, 56 압축 (코딩 형식) 38 연결 7 연결 헤더 필드 51, 56 콘텐츠 길이 헤더 필드 30 D 수축 (코딩 형식) 38 구분 기호 27 다운 스트림 10 E 유효 요청 URI 45 G 게이트웨이 10 문법 절대 형식 42 절대 경로 16 절대 URI 16 ALPHA 6 별표 형식 41,43 권한 16 권한 양식 42-43 BWS 25 청크 36 청크 데이터 36 청크 확장명 36 청크 확장명 36 청크 확장명 36 청크 크기 36 청크 본문 36 코멘트 27 연결 51 연결 옵션 51 내용 길이 30 CR 6 CRLF 6 ctext 27 CTL 6 DIGIT 6 DQUOTE 6 필드 내용 23 필드 이름 23, 40 필드 값 23 field-vchar 23 조각 16 헤더 필드 23,37 HEXDIG 6 호스트 44 HTAB 6 HTTP 메시지 19 HTTP 이름 14 http-URI 17 HTTP 버전 14 https-URI 18 마지막 청크 36 LF 6 메시지 본문 28 방법 21 obs-fold 23 obs-text 27 OCTET 6 origin 양식 42 OWS 25 부분 URI 16 포트 16 프로토콜 이름 47 프로토콜 버전 47 가명 47 qdtext 27 쿼리 16 인용 쌍 27 인용 문자열 27 순위 39 이유 문구 22 수신 한 47 수신 프로토콜 47 요청 라인 21 요청 대상 41 RWS 25 구성표 16 세그먼트 16 SP 6 시작 라인 21 상태 코드22 상태 표시 줄 22 t- 코딩 39 t- 순위 39 tchar 27 TE 39 토큰 27 트레일러 40 트레일러 부품 37 전송 코드 35 전송 인코딩 28 전송 확장 35 전송 매개 변수 35 업그레이드 57 URI 호스트 16 URI 참조 16 VCHAR 6 Via 47 gzip (코딩 형식) 39 H 헤더 필드 19 헤더 섹션 19 헤더 19 호스트 헤더 필드 44 http URI 스킴 17 https URI 스킴 17 I 인바운드 9 차단 프록시 11 중개자 9 M 미디어 유형 애플리케이션 / http 63 메시지 / http 62 메시지 7 메시지 / http 미디어 유형 62 방법 21 N 비 변환 프록시 49 O오리진 서버 7 오리진 양식 (요청 대상) 42 아웃 바운드 10 P 피싱 67 프록시 10 R 수신자 7 요청 7 요청 대상 21 리소스 16 응답 7 리버스 프록시 10 S 발신자 7 서버 7 스파이더 7 T 대상 리소스 40 대상 URI 40 TE 헤더 필드 39 트레일러 헤더 필드 40 전송 인코딩 헤더 필드 28 변환 프록시 49 투명 프록시 11 터널 10 U 업그레이드 헤더 필드 57 업스트림 9 URI 체계 http 17 https 17 사용자 에이전트 7 V 헤더 필드 47 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; 필딩 &amp;amp; Reschke 표준 트랙 [페이지 89]</target>
        </trans-unit>
        <trans-unit id="5f38d91a98f445cfaf31a1b87315c344133fcf77" translate="yes" xml:space="preserve">
          <source>BZip archive</source>
          <target state="translated">BZip 아카이브</target>
        </trans-unit>
        <trans-unit id="9268ec259738e5664244ab3e240148d4cb02f539" translate="yes" xml:space="preserve">
          <source>BZip2 archive</source>
          <target state="translated">BZip2 아카이브</target>
        </trans-unit>
        <trans-unit id="6b6c8e8e9e899e58c8a82dcfe5a52c51d8589bc9" translate="yes" xml:space="preserve">
          <source>Base64 encoding and decoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f89697a7bc4483ffe13d2dcbf8d58f7b7c1be20" translate="yes" xml:space="preserve">
          <source>Basic aspects of HTTP</source>
          <target state="translated">HTTP의 기본 측면</target>
        </trans-unit>
        <trans-unit id="f1141fef0f5d80de5637d17a79c2912b21db48fe" translate="yes" xml:space="preserve">
          <source>Basic authentication scheme</source>
          <target state="translated">기본 인증 체계</target>
        </trans-unit>
        <trans-unit id="48e2b3aff207a2929af920ad2047a4854ec8d687" translate="yes" xml:space="preserve">
          <source>Basic support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81efe3a6d9678e29a4c810740a95dcc9bb4f25f2" translate="yes" xml:space="preserve">
          <source>Basics of HTTP</source>
          <target state="translated">HTTP의 기초</target>
        </trans-unit>
        <trans-unit id="2390d6f45ac482880e651868f977b3b748a0f6b2" translate="yes" xml:space="preserve">
          <source>Because HTTP uses mostly textual, character-delimited fields, parsers
   are often vulnerable to attacks based on sending very long (or very
   slow) streams of data, particularly where an implementation is
   expecting a protocol element with no predefined length.

   To promote interoperability, specific recommendations are made for
   minimum size limits on request-line (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;) and header fields
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;).  These are minimum recommendations, chosen to be
   supportable even by implementations with limited resources; it is
   expected that most implementations will choose substantially higher
   limits.

   A server can reject a message that has a request-target that is too
   long (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Section&amp;nbsp;6.5.12 of [RFC7231]&lt;/a&gt;) or a request payload that is too
   large (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;Section&amp;nbsp;6.5.11 of [RFC7231]&lt;/a&gt;).  Additional status codes related
   to capacity limits have been defined by extensions to HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt;].

   Recipients ought to carefully limit the extent to which they process
   other protocol elements, including (but not limited to) request
   methods, response status phrases, header field-names, numeric values,
   and body chunks.  Failure to limit such processing can result in
   buffer overflows, arithmetic overflows, or increased vulnerability to
   denial-of-service attacks.</source>
          <target state="translated">HTTP는 대부분 문자로 구분 된 텍스트로 구분 된 필드를 사용하기 때문에 파서는 종종 매우 긴 (또는 매우 느린) 데이터 스트림 전송을 기반으로하는 공격에 취약합니다. 특히 구현시 미리 정의 된 길이가없는 프로토콜 요소가 필요한 경우. 상호 운용성을 높이기 위해 요청 라인 ( &lt;a href=&quot;#section-3.1.1&quot;&gt;섹션 3.1.1&lt;/a&gt; ) 및 헤더 필드 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; ) 에 대한 최소 크기 제한에 대한 특정 권장 사항이 있습니다. 이것들은 제한된 자원을 가진 구현에서도 지원할 수 있도록 선택된 최소 권장 사항입니다. 대부분의 구현은 실질적으로 더 높은 한계를 선택할 것으로 예상됩니다. 서버가 요청 대상이 너무 긴 메시지를 거부 할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;[RFC7231]의 6.5.12 절)&lt;/a&gt;) 또는 요청 페이로드가 너무 큽니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;[RFC7231]의 섹션 6.5.11&lt;/a&gt; ). 용량 제한과 관련된 추가 상태 코드는 HTTP 확장으로 정의되었습니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt; ]. 받는 사람은 요청 방법, 응답 상태 문구, 헤더 필드 이름, 숫자 값 및 본문 청크를 포함하여 다른 프로토콜 요소를 처리하는 범위를 신중하게 제한해야합니다. 이러한 처리를 제한하지 않으면 버퍼 오버플로, 산술 오버플로 또는 서비스 거부 공격에 대한 취약성이 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e347f7f4e0eb64be97283fb708464f948f15cd41" translate="yes" xml:space="preserve">
          <source>Because a client might be receiving responses via multiple paths, so
   that some responses flow through one set of caches and other
   responses flow through a different set of caches, a client might
   receive responses in an order different from that in which the origin
   server sent them. We would like the client to use the most recently
   generated response, even if older responses are still apparently
   fresh.

   Neither the entity tag nor the expiration value can impose an
   ordering on responses, since it is possible that a later response
   intentionally carries an earlier expiration time. The Date values are
   ordered to a granularity of one second.

   When a client tries to revalidate a cache entry, and the response it
   receives contains a Date header that appears to be older than the one
   for the existing entry, then the client SHOULD repeat the request
   unconditionally, and include

       Cache-Control: max-age=0

   to force any intermediate caches to validate their copies directly
   with the origin server, or

       Cache-Control: no-cache

   to force any intermediate caches to obtain a new copy from the origin
   server. 

   If the Date values are equal, then the client MAY use either response
   (or MAY, if it is being extremely prudent, request a new response).
   Servers MUST NOT depend on clients being able to choose
   deterministically between responses generated during the same second,
   if their expiration times overlap.</source>
          <target state="translated">클라이언트가 여러 경로를 통해 응답을 수신 할 수 있으므로 일부 응답은 한 세트의 캐시를 통과하고 다른 응답은 다른 캐시 세트를 통과하므로 클라이언트는 원래 서버가 보낸 순서와 다른 순서로 응답을 수신 할 수 있습니다. . 오래된 응답이 여전히 최신 인 경우에도 클라이언트는 가장 최근에 생성 된 응답을 사용하기를 원합니다. 나중에 응답이 의도적으로 더 빠른 만료 시간을 가질 수 있기 때문에 엔티티 태그 나 만료 값 모두 응답에 순서를 지정할 수 없습니다. 날짜 값은 1 초 단위로 정렬됩니다. 클라이언트가 캐시 항목의 유효성을 다시 검사하려고 시도하고 수신 한 응답에 기존 항목의 항목보다 오래된 것으로 보이는 날짜 헤더가 포함 된 경우,그런 다음 클라이언트는 요청을 무조건 반복해야하며 Cache-Control : max-age = 0을 포함하여 중간 캐시가 원본 서버와 직접 복사본을 검증하도록하거나 Cache-Control : no-cache를 사용하여 중간 캐시를 강제로 가져와야합니다. 오리진 서버의 새 사본. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버는 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수 있어야해서는 안됩니다.no-cache는 중간 캐시가 원본 서버로부터 새 사본을 얻도록 강제합니다. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버는 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수 있어야해서는 안됩니다.no-cache는 중간 캐시가 원본 서버로부터 새 사본을 얻도록 강제합니다. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버는 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수 있어야해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="86455b35c9696e2ada5790776540ffdd90e87107" translate="yes" xml:space="preserve">
          <source>Because expiration values are assigned optimistically, it is possible
   for two caches to contain fresh values for the same resource that are
   different.

   If a client performing a retrieval receives a non-first-hand response
   for a request that was already fresh in its own cache, and the Date
   header in its existing cache entry is newer than the Date on the new
   response, then the client MAY ignore the response. If so, it MAY
   retry the request with a &quot;Cache-Control: max-age=0&quot; directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;), to force a check with the origin server.

   If a cache has two fresh responses for the same representation with
   different validators, it MUST use the one with the more recent Date
   header. This situation might arise because the cache is pooling
   responses from other caches, or because a client has asked for a
   reload or a revalidation of an apparently fresh cache entry.</source>
          <target state="translated">만료 값이 낙관적으로 할당되므로 두 캐시에 동일한 동일한 리소스에 대한 새로운 값이 포함될 수 있습니다. 검색을 수행하는 클라이언트가 자체 캐시에서 이미 새로운 요청에 대해 직접 응답이 아닌 응답을 수신하고 기존 캐시 항목의 날짜 헤더가 새 응답의 날짜보다 최신 인 경우 클라이언트는 무시할 수 있습니다 (MAY) 응답. 그렇다면 &quot;Cache-Control : max-age = 0&quot;지시문으로 요청을 다시 시도 할 수 있습니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; 참조). ), 원본 서버를 강제로 확인합니다. 캐시에 다른 유효성 검사기를 가진 동일한 표현에 대해 두 개의 새로운 응답이있는 경우 최신 날짜 헤더가있는 응답을 사용해야합니다. 이 상황은 캐시가 다른 캐시의 응답을 풀링하거나 클라이언트가 명백히 새로운 캐시 항목의 재로드 또는 재확인을 요청했기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8925ede0629c5d28bf60e237373ba50709672d6" translate="yes" xml:space="preserve">
          <source>Because some of the information shared by &lt;code&gt;resource:&lt;/code&gt; URLs is available to websites, a web page could run internal scripts and inspect internal resources of Firefox, including the default preferences, which could be a serious security and privacy issue.</source>
          <target state="translated">&lt;code&gt;resource:&lt;/code&gt; 공유하는 일부 정보 : 웹 사이트에서 URL을 사용할 수 있으므로 웹 페이지는 내부 스크립트를 실행하고 기본 환경 설정을 포함하여 Firefox의 내부 리소스를 검사 할 수 있으며 이는 심각한 보안 및 개인 정보 보호 문제 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546f4d232503e1d341d388da112b0bb01eea4130" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different (&quot;varies&quot;) for mobile and desktop clients, caches will not be used to serve mobile content mistakenly to desktop users or vice versa.</source>
          <target state="translated">모바일 및 데스크톱 클라이언트 의 &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 헤더 값이 다르기 때문에 ( &quot;다양성&quot;), 캐시는 모바일 콘텐츠를 데스크톱 사용자에게 실수로 제공하거나 그 반대로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8cadc83ac6b7350fa14508ccacb5caa822a4e4b" translate="yes" xml:space="preserve">
          <source>Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header were &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot;&lt;code&gt;http://foo.example&lt;/code&gt;&quot; (an actual origin) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, the credential-cognizant content is returned to the invoking web content.</source>
          <target state="translated">위 예의 요청 헤더에 &lt;code&gt;Cookie&lt;/code&gt; 헤더가 포함되어 있으므로 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더의 값이 &quot;*&quot;인 경우 요청이 실패합니다 . 그러나 실패하지는 않습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더의 값이 &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드가 아닌 &quot; &lt;code&gt;http://foo.example&lt;/code&gt; &quot;(실제 원점) 이므로 자격 증명 인식 내용이 호출 웹 컨텐츠.</target>
        </trans-unit>
        <trans-unit id="9f1e2820de19096a78681bfbbd2529f24bd989c8" translate="yes" xml:space="preserve">
          <source>Because the source of a link might be private information or might
   reveal an otherwise private information source, it is strongly
   recommended that the user be able to select whether or not the
   Referer field is sent. For example, a browser client could have a
   toggle switch for browsing openly/anonymously, which would
   respectively enable/disable the sending of Referer and From
   information.

   Clients SHOULD NOT include a Referer header field in a (non-secure)
   HTTP request if the referring page was transferred with a secure
   protocol.

   Authors of services which use the HTTP protocol SHOULD NOT use GET
   based forms for the submission of sensitive data, because this will
   cause this data to be encoded in the Request-URI. Many existing
   servers, proxies, and user agents will log the request URI in some
   place where it might be visible to third parties. Servers can use
   POST-based form submission instead</source>
          <target state="translated">링크의 소스는 개인 정보이거나 다른 개인 정보 소스를 표시 할 수 있으므로 사용자는 Referer 필드의 전송 여부를 선택할 수있는 것이 좋습니다. 예를 들어, 브라우저 클라이언트에는 공개 / 익명으로 브라우징하기위한 토글 스위치가있어 Referer 및 From 정보의 전송을 각각 활성화 / 비활성화 할 수 있습니다. 참조 페이지가 보안 프로토콜로 전송 된 경우 클라이언트는 (비보안) HTTP 요청에 Referer 헤더 필드를 포함하지 않아야합니다. HTTP 프로토콜을 사용하는 서비스 작성자는 민감한 데이터를 제출하기 위해 GET 기반 양식을 사용해서는 안됩니다.이 데이터는 Request-URI로 인코딩되기 때문입니다. 많은 기존 서버, 프록시,사용자 에이전트는 요청 URI를 제 3자가 볼 수있는 위치에 기록합니다. 서버는 대신 POST 기반 양식 제출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89777ff4d87ff412faf166b9388ba8bd9eb18838" translate="yes" xml:space="preserve">
          <source>Because unsafe request methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) such as
   PUT, POST or DELETE have the potential for changing state on the
   origin server, intervening caches can use them to keep their contents
   up to date.

   A cache MUST invalidate the effective Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) as well as the URI(s) in the Location and Content-Location
   response header fields (if present) when a non-error status code is
   received in response to an unsafe request method.

   However, a cache MUST NOT invalidate a URI from a Location or
   Content-Location response header field if the host part of that URI
   differs from the host part in the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  This helps prevent denial-of-service attacks.

   A cache MUST invalidate the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) when it receives a non-error response to a request with a
   method whose safety is unknown.

   Here, a &quot;non-error response&quot; is one with a 2xx (Successful) or 3xx
   (Redirection) status code.  &quot;Invalidate&quot; means that the cache will
   either remove all stored responses related to the effective request
   URI or will mark these as &quot;invalid&quot; and in need of a mandatory
   validation before they can be sent in response to a subsequent
   request.

   Note that this does not guarantee that all appropriate responses are
   invalidated.  For example, a state-changing request might invalidate
   responses in the caches it travels through, but relevant responses
   still might be stored in other caches that it has not.</source>
          <target state="translated">PUT, POST 또는 DELETE와 같은 안전하지 않은 요청 방법 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; )은 오리진 서버에서 상태를 변경할 가능성이 있기 때문에 중간 캐시는이 방법을 사용하여 해당 내용을 최신 상태로 유지할 수 있습니다. 캐시 는 오류가 아닌 상태 코드가 다음에 대한 응답으로 수신 될 때 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; )와 위치 및 컨텐츠 위치 응답 헤더 필드 (있는 경우)의 URI를 무효화해야 합니다. 안전하지 않은 요청 방법 그러나 캐시는 해당 URI의 호스트 부분이 유효 요청 URI의 호스트 부분과 다를 경우 Location 또는 Content-Location 응답 헤더 필드에서 URI를 무효화해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;안됩니다 ([RFC7230]의 5.5 절&lt;/a&gt;). 이를 통해 서비스 거부 공격을 방지 할 수 있습니다. 캐시는 유효 요청 URI를 무효화해야한다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 5.5 절&lt;/a&gt;) 안전성이 알려지지 않은 방법으로 요청에 대한 오류가 아닌 응답을 수신 한 경우 여기서 &quot;비 오류 응답&quot;은 2xx (성공) 또는 3xx (리디렉션) 상태 코드가있는 것입니다. &quot;유효하지 않음&quot;은 캐시가 유효 요청 URI와 관련된 모든 저장된 응답을 제거하거나 이러한 요청을 &quot;유효하지 않은&quot;것으로 표시하고 후속 요청에 대한 응답으로 전송되기 전에 필수 유효성 검증이 필요함을 의미합니다. 모든 적절한 응답이 무효화되는 것은 아닙니다. 예를 들어, 상태 변경 요청은 이동하는 캐시에서 응답을 무효화 할 수 있지만 관련 응답은 여전히 ​​그렇지 않은 다른 캐시에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7164b8ce21f524d63c0906c78c5305985077fd8f" translate="yes" xml:space="preserve">
          <source>Before Firefox 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">Firefox 58 이전 에는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 에서 &lt;code&gt;frame-ancestors&lt;/code&gt; 이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1aa5f2715f87eb515763d2edd53baeae3f8d201" translate="yes" xml:space="preserve">
          <source>Before Firefox for Android 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">Android 58 용 Firefox 이전 에는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 에서 &lt;code&gt;frame-ancestors&lt;/code&gt; 이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="62fc5c2bc1f37893a14f09a3227f0a7bbc9e9b1c" translate="yes" xml:space="preserve">
          <source>Beginning in version 41, Firefox for Android will contain the Android version as part of the &lt;var&gt;platform&lt;/var&gt; token. For increased interoperability, if the browser is running on a version below 4 it will report 4.4. Android versions 4 and above will report the version accurately. Note that the same Gecko&amp;mdash;with the same capabilities&amp;mdash;is shipped to all versions of Android.</source>
          <target state="translated">버전 41부터 Android 용 Firefox는 &lt;var&gt;platform&lt;/var&gt; 토큰의 일부로 Android 버전을 포함합니다 . 상호 운용성을 높이기 위해 브라우저가 4 이하 버전에서 실행되는 경우 4.4를보고합니다. Android 버전 4 이상은 버전을 정확하게보고합니다. 동일한 기능을 가진 동일한 Gecko는 모든 버전의 Android에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3dac22f5a23b1f3829fde1d94704586ae962f362" translate="yes" xml:space="preserve">
          <source>Below, the client creates a Member Entry using POST:

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201,
   and returns an ETag header in the response.  Because, in this case,
   the server returned a Content-Location header and Location header
   with the same value, the returned Entry representation can be
   understood to be a complete representation of the newly created Entry
   (see &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

       HTTP/1.1 201 Created
       Date: Fri, 23 Feb 2007 21:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry
       Location: http://example.org/edit/first-post.atom
       Content-Location: http://example.org/edit/first-post.atom
       ETag: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can, if it wishes, use the returned ETag value to later
   construct a &quot;Conditional GET&quot; as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  In this case,
   prior to editing, the client sends the ETag value for the Member
   using the If-None-Match header. 

       GET /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       If-None-Match: &quot;e180ee84f0671b1&quot;

   If the Entry has not been modified, the response will be a status
   code of 304 (&quot;Not Modified&quot;).  This allows the client to determine
   whether it still has the most recent representation of the Entry at
   the time of editing.

       HTTP/1.1 304 Not Modified
       Date: Sat, 24 Feb 2007 13:17:11 GMT

   After editing, the client can PUT the Entry and send the ETag entity
   value in an If-Match header, informing the server to accept the entry
   on the condition that the entity value sent still matches the
   server's.

       PUT /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-24T16:34:06Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Update: it's a hoax!&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server however has since received a more recent copy than the
   client's, and it responds with a status code of 412 (&quot;Precondition
   Failed&quot;).

       HTTP/1.1 412 Precondition Failed
       Date: Sat, 24 Feb 2007 16:34:11 GMT

   This informs the client that the server has a more recent version of
   the Entry and will not allow the sent entity to be stored.</source>
          <target state="translated">아래에서 클라이언트는 POST를 사용하여 멤버 항목을 작성합니다. POST : POST / myblog / entries HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 컨텐츠 유형 : application / atom + xml; type = entry 컨텐츠 길이 : nnn Slug : 첫 번째 게시물 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원격 로봇이 Amok를 실행 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17 : 09 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 움직이는 것입니다 ... solid metal &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 서버는 상태 코드가 201 인 성공적인 생성을 알립니다.응답에 ETag 헤더를 반환합니다. 이 경우, 서버는 동일한 값을 가진 Content-Location 헤더와 Location 헤더를 반환했기 때문에 반환 된 Entry 표현은 새로 작성된 Entry의 완전한 표현으로 이해 될 수 있습니다 (참조&lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; ). HTTP / 1.1 201 작성 날짜 : 2007 년 2 월 23 일 금요일 21:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry 위치 : http://example.org/edit/first- post.atom 컨텐츠 위치 : http://example.org/edit/first-post.atom ETag : &quot;e180ee84f0671b1&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http : //www.w3. org / 2005 / Atom &quot;&amp;gt; &amp;lt;title&amp;gt; 원자력 로봇이 Amok를 실행합니다 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17 : 09 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 움직이는 무언가 ... 단단한 금속 &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt;원하는 경우 클라이언트는 반환 된 ETag 값을 사용하여 나중에 [조건부 GET &quot;을 정의 할 수 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]. 이 경우 클라이언트는 편집하기 전에 If-None-Match 헤더를 사용하여 멤버에 대한 ETag 값을 보냅니다. GET /edit/first-post.atom HTTP / 1.1 호스트 : example.org 권한 부여 : 기본 ZGFmZnk6c2VjZXJldA == 일치하지 않는 항목 : &quot;e180ee84f0671b1&quot;항목이 수정되지 않은 경우 응답은 상태 코드 304 ( &quot;수정되지 않음&quot;). 이를 통해 클라이언트는 편집 할 때 여전히 최신 항목을 가지고 있는지 확인할 수 있습니다. HTTP / 1.1 304 수정되지 않은 날짜 : 토요일, 2007 년 2 월 24 일 13:17:11 GMT 편집 후 클라이언트는 항목을 PUT하고 If-Match 헤더에 ETag 엔티티 값을 보내 서버가 서버의 항목을 수락하도록 지시합니다. 전송 된 엔티티 값이 여전히 서버의 값과 일치한다는 조건.PUT /edit/first-post.atom HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 유형 : application / atom + xml; type = entry 콘텐츠 길이 : nnn If-Match : &quot;e180ee84f0671b1&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원격 로봇이 Amok를 실행합니다 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695- cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-24T16 : 34 : 06Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 업데이트 : hoax! &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 그러나 서버는 이후 클라이언트보다 최신 사본을 받았습니다.상태 코드 412 ( &quot;전제 조건 실패&quot;)로 응답합니다. HTTP / 1.1 412 전제 조건 실패 날짜 : 2007 년 2 월 24 일 (토) 16:34:11 GMT 클라이언트에게 서버에 최신 버전의 항목이 있음을 알리고 보낸 엔터티를 저장할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="c0330bfb1138bf9fb6ae44f78a5af3bf13c6fff6" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing a PNG image to the
   URI of a Collection that accepts PNG images:

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member URI of
   the Media Link Entry and a representation of that entry in the body
   of the response.  The Media Link Entry includes a content element
   with a &quot;src&quot; attribute.  It also contains a link with a link relation
   of &quot;edit-media&quot;, specifying the IRI to be used for modifying the
   Media Resource.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt; 

   Later, the client sends a PUT request containing the new PNG using
   the URI indicated in the Media Link Entry's &quot;edit-media&quot; link:

       PUT /edit/the_beach.png HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful edit with a status code of 200.

       HTTP/1.1 200 Ok
       Date: Fri, 8 Oct 2006 17:17:11 GMT

   The client can edit the metadata for the picture.  First GET the
   Media Link Entry:

       GET /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==

   The Media Link Entry is returned.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:18:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       ETag: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The metadata can be updated, in this case to add a summary, and then
   PUT back to the server. 

       PUT /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot;&amp;gt;
             A nice sunset picture over the water.
         &amp;lt;/summary&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The update was successful.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:19:11 GMT
       Content-Length: 0

   Multiple Media Resources can be added to the Collection.

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Pier
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The Resource is created successfully.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_pier.atom 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Pier&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efe6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:26:43Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_pier.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_pier.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can now create a new Atom Entry in the blog Entry
   Collection that references the two newly created Media Resources.

       POST /blog/ HTTP/1.1
       Host: example.org
       Content-Type: application/atom+xml;type=entry
       Slug: A day at the beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:40:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                         src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img  alt=&quot;the pier&quot;
                         src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Resource is created successfully. 

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:20:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/blog/atom/a-day-at-the-beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;http://example.org/blog/a-day-at-the-beach.xhtml&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:43:07Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                        src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img alt=&quot;the pier&quot;
                        src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
           href=&quot;http://example.org/blog/edit/a-day-at-the-beach.atom&quot;/&amp;gt;
         &amp;lt;link rel=&quot;alternate&quot; type=&quot;text/html&quot;
           href=&quot;http://example.org/blog/a-day-at-the-beach.html&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   Note that the returned Entry contains a link with a relation of
   &quot;alternate&quot; that points to the associated HTML page that was created
   -- this is not required by this specification, but is included to
   show the kinds of changes a server can make to an Entry.</source>
          <target state="translated">아래에서 클라이언트는 PNG 이미지를 포함하는 POST 요청을 PNG 이미지를 허용하는 컬렉션의 URI로 보냅니다. POST / edit / HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 : image / png 슬러그 : 해변 인증 : 기본 ZGFmZnk6c2VjZXJldA == Content-Length : nnn ... binary data 서버는 상태 코드가 201 인 성공적인 작성을 신호합니다. 응답에는 Media Link Entry의 멤버 URI를 나타내는 Location 헤더와 해당 항목의 해당 항목의 표현이 포함됩니다. 응답의 본문. 미디어 링크 항목에는 &quot;src&quot;속성을 가진 컨텐츠 요소가 포함됩니다. 또한 미디어 리소스를 수정하는 데 사용할 IRI를 지정하는 &quot;edit-media&quot;링크 관계가있는 링크가 포함되어 있습니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17 :11 GMT Content-Length : nnn Content-Type : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http://example.org/media/edit/the_beach.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot;http://media.example.org/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit-media &quot;href =&quot;http://media.example.org/edit/the_beach.png &quot; /&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/media/edit/the_beach.atom&quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 나중에 클라이언트는 미디어에 표시된 URI를 사용하여 새 PNG가 포함 된 PUT 요청을 보냅니다. 링크 엔트리의 &quot;미디어 편집&quot;링크 : PUT /edit/the_beach.png HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 : image / png 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn ... 바이너리 데이터 서버는 상태 코드 200으로 편집 성공을 알립니다. HTTP / 1.1 200 Ok 날짜 : 금, 2006 년 10 월 8 일 17:17:11 GMT 클라이언트는 그림의 메타 데이터를 편집 할 수 있습니다. 먼저 미디어 링크 항목을 가져옵니다. GET /media/edit/the_beach.atom HTTP / 1.1 호스트 : example.org 인증 :기본 ZGFmZnk6c2VjZXJldA == 미디어 링크 항목이 반환됩니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:18:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;ETag : &quot;c181bb840673b5&quot;&amp;lt; ? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb -aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit-media&quot;href = &quot;http://media.example.org/edit/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/media/edit/the_beach.atom&quot;/&amp;gt; &amp;lt; / entry&amp;gt; 메타 데이터를 업데이트하여이 경우 요약을 추가 한 다음 서버에 다시 PUT 할 수 있습니다. PUT /media/edit/the_beach.atom HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 컨텐츠 유형 : application / atom + xml; type = entry 컨텐츠 길이 : nnn If-Match : &quot;c181bb840673b5&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb- aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;&amp;gt; 물 위의 멋진 일몰 사진. &amp;lt;/ summary&amp;gt; &amp;lt;content type = &quot;image / png&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit-media&quot;href = &quot;http : // media. example.org/edit/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit &quot;href =&quot;http://example.org/media/edit/the_beach.atom &quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 업데이트에 성공했습니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:19:11 GMT 콘텐츠 길이 : 0 여러 미디어 리소스를 컬렉션에 추가 할 수 있습니다. POST / edit / HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 :슬러그 : 피어 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn ... 이진 데이터 리소스가 성공적으로 생성되었습니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/media/edit/the_pier.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 부두 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efe6b &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 26 : 43Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ 저자 &amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot;http://media.example.org/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit-media &quot;href =&quot;http://media.example.org/edit/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit &quot;href =&quot;http://example.org/media/edit/the_pier.atom &quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 이제 클라이언트는 블로그 항목 콜렉션에서 새 Atom 항목을 작성할 수 있습니다. POST / blog / HTTP / 1.1 호스트 : example.org 콘텐츠 유형 : application / atom + xml; type = entry 슬러그 : 해변에서의 하루 승인 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변에서의 즐거운 하루 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6b &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 40 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml : div xmlns : xhtml = &quot;http://www.w3.org/1999/xhtml&quot;&amp;gt; &amp;lt;xhtml : p&amp;gt; 해변에서 즐거운 하루를 보냈습니다. &amp;lt;xhtml : img alt = &quot;해변&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;xhtml : p&amp;gt; 나중에 부두까지 걸어갔습니다. &amp;lt;xhtml : img alt = &quot;부두&quot;src = &quot;http://media.example.org/the_pier.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;/ xhtml : div&amp;gt; &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 리소스가 성공적으로 생성되었습니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:20:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/blog/atom/a-day-at-the-beach.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt; title&amp;gt; 해변에서의 즐거운 하루 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; http://example.org/blog/a-day-at-the-beach.xhtml &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 43 : 07Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml : div xmlns : xhtml = &quot;http://www.w3.org/1999/ xhtml &quot;&amp;gt;&amp;lt;xhtml : p&amp;gt; 해변에서 즐거운 하루를 보냈습니다. &amp;lt;xhtml : img alt = &quot;해변&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;xhtml : p&amp;gt; 나중에 부두까지 걸어갔습니다. &amp;lt;xhtml : img alt = &quot;부두&quot;src = &quot;http://media.example.org/the_pier.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;/ xhtml : div&amp;gt; &amp;lt;/ content&amp;gt; &amp;lt;link rel = &quot; edit &quot;href =&quot;http://example.org/blog/edit/a-day-at-the-beach.atom &quot;/&amp;gt; &amp;lt;link rel =&quot;alternate &quot;type =&quot;text / html &quot;href =&quot;http : //example.org/blog/a-day-at-the-beach.html &quot;/&amp;gt; &amp;lt;/ entry&amp;gt;반환 된 Entry에는 생성 된 관련 HTML 페이지를 가리키는 &quot;alternate&quot;관계가있는 링크가 포함되어 있습니다.이 사양에서는 필요하지 않지만 서버가 변경할 수있는 종류를 보여주기 위해 포함됩니다. 기입.</target>
        </trans-unit>
        <trans-unit id="be9cb09a54952403acfaab07ff33017f6f0fca24" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing an Atom Entry
   representation using the URI of the Collection:

       POST /edit/ HTTP/1.1
       Host: example.org
       User-Agent: Thingio/1.0
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member Entry
   URI of the Atom Entry, and a representation of that Entry in the body
   of the response.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/edit/first-post.atom
       ETag: &quot;c180de84f991g8&quot; 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
             href=&quot;http://example.org/edit/first-post.atom&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Entry created and returned by the Collection might not match the
   Entry POSTed by the client.  A server MAY change the values of
   various elements in the Entry, such as the atom:id, atom:updated, and
   atom:author values, and MAY choose to remove or add other elements
   and attributes, or change element content and attribute values.</source>
          <target state="translated">아래에서 클라이언트는 콜렉션의 URI를 사용하여 Atom Entry 표현을 포함하는 POST 요청을 보냅니다. POST / edit / HTTP / 1.1 Host : example.org User-Agent : Thingio / 1.0 Authorization : Basic ZGFmZnk6c2VjZXJldA == Content-Type : application / atom + xml; type = entry 콘텐츠 길이 : nnn 슬러그 : 첫 번째 게시물 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원자력 로봇이 Amok를 실행 함 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18 : 30 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt; name&amp;gt; John Doe &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 일부 텍스트 &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt;서버는 상태 코드 201로 성공적인 작성을 알립니다. 응답에는 Atom 항목의 구성원 항목 URI를 나타내는 Location 헤더와 응답 본문에 해당 항목의 표현이 포함됩니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/edit/first-post.atom ETag : &quot;c180de84f991g8&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Atom -Powered Robots Amok 실행 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18 : 30 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;저자&amp;gt; &amp;lt;name&amp;gt; John Doe &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 일부 텍스트 &amp;lt;/ content&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/edit/first-post.atom&quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 컬렉션에서 생성하고 반환 한 항목이 클라이언트가 게시 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.콜렉션에서 작성하여 리턴 한 항목이 클라이언트가 POST 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.콜렉션에서 작성하여 리턴 한 항목이 클라이언트가 POST 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552d2669fbc3963dfa12ac837a60570b8d21b825" translate="yes" xml:space="preserve">
          <source>Besides the setting of the validators on the server side, this mechanism is transparent: all browsers manage a cache and send such conditional requests without any special work to be done by Web developers.</source>
          <target state="translated">서버 측에서 유효성 검사기를 설정하는 것 외에도이 메커니즘은 투명합니다. 모든 브라우저는 캐시를 관리하고 웹 개발자가 수행 할 특별한 작업없이 이러한 조건부 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="95a31c7b8d5f0b04cb1a96329834684da05258b3" translate="yes" xml:space="preserve">
          <source>Best Practices for Using the Vary Header &amp;ndash; fastly.com</source>
          <target state="translated">가변 헤더 사용에 대한 모범 사례 &amp;ndash; fastly.com</target>
        </trans-unit>
        <trans-unit id="3696a45b0fbbf421a242df5da5ec4b688f7df3d0" translate="yes" xml:space="preserve">
          <source>Best practices for good user experiences</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례</target>
        </trans-unit>
        <trans-unit id="e8192d28d193fb637729d7681a715b53c8d8e6fa" translate="yes" xml:space="preserve">
          <source>Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at either the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, or not (changing requests going through them), and may perform numerous functions:</source>
          <target state="translated">웹 브라우저와 서버 사이에서 수많은 컴퓨터와 시스템이 HTTP 메시지를 릴레이합니다. 웹 스택의 계층 구조로 인해 대부분의 전송, 네트워크 또는 물리적 수준에서 작동하여 HTTP 계층에서 투명 해지고 성능에 상당한 영향을 줄 수 있습니다. 응용 계층에서 작동하는 것을 일반적으로 &lt;strong&gt;프록시&lt;/strong&gt; 라고 합니다. 이들은 투명하거나 투명하지 않을 수 있으며 (요청을 변경하는 요청) 여러 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7b5639c2d5c6aefb6a4756b1924c7615e2b7af" translate="yes" xml:space="preserve">
          <source>Blink</source>
          <target state="translated">Blink</target>
        </trans-unit>
        <trans-unit id="d47c2c9d44766d5026529dab6ab5f38489055deb" translate="yes" xml:space="preserve">
          <source>Blink-based (Chromium, Google Chrome, Opera 15+)</source>
          <target state="translated">깜박임 기반 (Chromium, Google Chrome, Opera 15+)</target>
        </trans-unit>
        <trans-unit id="12dcd04f8772116c748e7a1686d74433478cbbb7" translate="yes" xml:space="preserve">
          <source>Block pages from loading when they detect reflected XSS attacks:</source>
          <target state="translated">반영된 XSS 공격을 탐지 할 때 페이지가로드되지 않도록 차단 :</target>
        </trans-unit>
        <trans-unit id="72005736b3d633e161ec04f9f5626d8efc05d101" translate="yes" xml:space="preserve">
          <source>Block the use of outdated APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;synchronous XHR&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt;&lt;code&gt;document.write()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;동기 XHR&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt; &lt;code&gt;document.write()&lt;/code&gt; &lt;/a&gt; 와 같은 오래된 API의 사용을 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ae08957fc64f7c37c7fd78d3088b53f4a0ac969" translate="yes" xml:space="preserve">
          <source>Blocks a request if the requested type is</source>
          <target state="translated">요청 된 유형이 다음과 같은 경우 요청을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="46c32d078786c9c754da18021b9cdd7c2ac0a06f" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</source>
          <target state="translated">블로그 게시물 : &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security가 출시되었습니다!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f7b0d6ecddd36325803a206713ad475fcf71d8b" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</source>
          <target state="translated">블로그 게시물 : &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (HTTPS 강제 적용)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8874edbfb3bde7b175aaba19f751935d9beacccf" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into three categories:</source>
          <target state="translated">시체는 크게 세 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2274273379451e1b300d8da8d1d55a10464ef909" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into two categories:</source>
          <target state="translated">시체는 크게 두 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="c11c5c92eb4bb23f4e3a2e484b5d01a2f02ca7c0" translate="yes" xml:space="preserve">
          <source>Bourne shell script</source>
          <target state="translated">Bourne 쉘 스크립트</target>
        </trans-unit>
        <trans-unit id="35387df992c10423a1e97a8fdd9850a0e2b7c2bb" translate="yes" xml:space="preserve">
          <source>Brotli Compressed Data Format</source>
          <target state="translated">Brotli 압축 데이터 형식</target>
        </trans-unit>
        <trans-unit id="ebd022bdbe14f7ec31423f0eeb91b8cd71a827f2" translate="yes" xml:space="preserve">
          <source>Browse through detailed HTTP reference documentation.</source>
          <target state="translated">자세한 HTTP 참조 문서를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="54a2cf5e634dbba0be2bf8a55f79252f5c790bdb" translate="yes" xml:space="preserve">
          <source>Browser</source>
          <target state="translated">Browser</target>
        </trans-unit>
        <trans-unit id="63fac1fb83ccf0b03f982fe1fa1a1b2cd86ed72c" translate="yes" xml:space="preserve">
          <source>Browser Name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18eb74e69d3d38bec47169d773de18efefdfab3" translate="yes" xml:space="preserve">
          <source>Browser behavior differs if this response erroneously includes a body on persistent connections See &lt;a href=&quot;204&quot;&gt;204 No Content&lt;/a&gt; for more detail.</source>
          <target state="translated">이 응답에 영구 연결의 본문이 잘못 포함 된 경우 브라우저 동작이 다릅니다 . 자세한 &lt;a href=&quot;204&quot;&gt;내용&lt;/a&gt; 은 204 내용 없음을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99b91e559917941bb0e259fb1c7151b747a651d" translate="yes" xml:space="preserve">
          <source>Browser compatibility</source>
          <target state="translated">브라우저 호환성</target>
        </trans-unit>
        <trans-unit id="b9596fac5cc2ce26e02f68794e8302c229989e32" translate="yes" xml:space="preserve">
          <source>Browser compatibility&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;Update compatibility data on GitHub&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa3ab903e2b10d31d9550e3d19e0235e67965c5" translate="yes" xml:space="preserve">
          <source>Browser detection using the user agent</source>
          <target state="translated">사용자 에이전트를 사용한 브라우저 감지</target>
        </trans-unit>
        <trans-unit id="b250936e425b70355734e2e64ef7dec7333eb610" translate="yes" xml:space="preserve">
          <source>Browser fingerprinting is a set of techniques for identifying a
   specific user agent over time through its unique set of
   characteristics.  These characteristics might include information
   related to its TCP behavior, feature capabilities, and scripting
   environment, though of particular interest here is the set of unique
   characteristics that might be communicated via HTTP.  Fingerprinting
   is considered a privacy concern because it enables tracking of a user
   agent's behavior over time without the corresponding controls that
   the user might have over other forms of data collection (e.g.,
   cookies).  Many general-purpose user agents (i.e., Web browsers) have
   taken steps to reduce their fingerprints.

   There are a number of request header fields that might reveal
   information to servers that is sufficiently unique to enable
   fingerprinting.  The From header field is the most obvious, though it
   is expected that From will only be sent when self-identification is
   desired by the user.  Likewise, Cookie header fields are deliberately 

   designed to enable re-identification, so fingerprinting concerns only
   apply to situations where cookies are disabled or restricted by the
   user agent's configuration.

   The User-Agent header field might contain enough information to
   uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive
   details about the user's system or extensions.  However, the source
   of unique information that is least expected by users is proactive
   negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), including the Accept, Accept-Charset,
   Accept-Encoding, and Accept-Language header fields.

   In addition to the fingerprinting concern, detailed use of the
   Accept-Language header field can reveal information the user might
   consider to be of a private nature.  For example, understanding a
   given language set might be strongly correlated to membership in a
   particular ethnic group.  An approach that limits such loss of
   privacy would be for a user agent to omit the sending of
   Accept-Language except for sites that have been whitelisted, perhaps
   via interaction after detecting a Vary header field that indicates
   language negotiation might be useful.

   In environments where proxies are used to enhance privacy, user
   agents ought to be conservative in sending proactive negotiation
   header fields.  General-purpose user agents that provide a high
   degree of header field configurability ought to inform users about
   the loss of privacy that might result if too much detail is provided.
   As an extreme privacy measure, proxies could filter the proactive
   negotiation header fields in relayed requests.</source>
          <target state="translated">브라우저 핑거 프린팅은 고유 한 특성 세트를 통해 시간이 지남에 따라 특정 사용자 에이전트를 식별하는 일련의 기술입니다. 이러한 특성에는 TCP 동작, 기능 기능 및 스크립팅 환경과 관련된 정보가 포함될 수 있지만 여기에는 특히 HTTP를 통해 통신 할 수있는 고유 한 특성이 있습니다. 지문은 사용자가 다른 형태의 데이터 수집 (예 : 쿠키)에 대해 가질 수있는 해당 제어없이 시간이 지남에 따라 사용자 에이전트의 동작을 추적 할 수 있기 때문에 개인 정보 보호 문제로 간주됩니다. 많은 범용 사용자 에이전트 (예 : 웹 브라우저)는 지문을 줄이기위한 조치를 취했습니다.지문을 사용할 수있을 정도로 고유 한 서버에 정보를 표시 할 수있는 여러 요청 헤더 필드가 있습니다. From 헤더 필드가 가장 분명하지만 From은 사용자가 자체 식별을 원하는 경우에만 전송 될 것으로 예상됩니다. 마찬가지로 쿠키 헤더 필드는 의도적으로 재 식별을 가능하게하도록 설계되었으므로 지문 처리 문제는 사용자 에이전트의 구성에 의해 쿠키가 비활성화되거나 제한되는 상황에만 적용됩니다. User-Agent 헤더 필드에는 특히 다른 특성과 결합 될 때, 특히 사용자 에이전트가 사용자 시스템 또는 확장에 대한 과도한 세부 정보를 보내는 경우 특정 장치를 고유하게 식별하기에 충분한 정보가 포함될 수 있습니다. 하나,사용자가 가장 적게 기대하는 고유 한 정보의 출처는 사전 협상 (&lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;) (Accept, Accept-Charset, Accept-Encoding 및 Accept-Language 헤더 필드 포함) 지문 문제 외에도 Accept-Language 헤더 필드를 자세하게 사용하면 사용자가 사적인 것으로 간주 할 수있는 정보를 알 수 있습니다. 예를 들어, 주어진 언어 세트를 이해하는 것은 특정 민족 그룹의 멤버십과 밀접한 관련이있을 수 있습니다. 이러한 개인 정보 손실을 제한하는 접근 방식은 사용자 에이전트가 허용 된 언어를 보내는 것을 생략하는 것입니다. 허용 된 언어는 언어 협상을 나타내는 Vary 헤더 필드를 감지 한 후 상호 작용을 통해 허용됩니다. 프라이버시를 향상시키기 위해 프록시가 사용되는 환경에서 사용자 에이전트는 사전 협상 헤더 필드를 전송하는 데 보수적이어야합니다.높은 수준의 헤더 필드 구성 기능을 제공하는 범용 사용자 에이전트는 사용자에게 세부 정보가 너무 많이 제공 될 경우 발생할 수있는 개인 정보의 손실에 대해 알려야합니다. 극단적 인 개인 정보 보호 조치로서 프록시는 릴레이 된 요청에서 사전 협상 헤더 필드를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc469bc098ba2e7153a183b517baa5e07dc2864" translate="yes" xml:space="preserve">
          <source>Browser test site: &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS and HPKP test&lt;/a&gt;</source>
          <target state="translated">브라우저 테스트 사이트 : &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS 및 HPKP 테스트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d7e0a33cf80fe452070f36fa8edcaff2499ee3" translate="yes" xml:space="preserve">
          <source>Browser version</source>
          <target state="translated">브라우저 버전</target>
        </trans-unit>
        <trans-unit id="a862ea052d45f44e70d62ee3df599d55e7a99307" translate="yes" xml:space="preserve">
          <source>Browsers send specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; for cross-site requests initiated from within &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;. It also expects to see specific HTTP headers sent back with cross-site responses. An overview of these headers, including sample JavaScript code that initiates requests and processes responses from the server, as well as a discussion of each header, &lt;a href=&quot;cors&quot;&gt;can be found in the HTTP Access Control (CORS) article&lt;/a&gt; and should be read as a companion article to this one. This article covers processing &lt;strong&gt;Access Control Requests&lt;/strong&gt; and formulating &lt;strong&gt;Access Control Responses&lt;/strong&gt; in PHP. The target audience for this article are server programmers or administrators. Although the code samples shown here are in PHP, similar concepts apply for ASP.net, Perl, Python, Java, etc.; in general, these concepts can be applied to any server-side programming environment that processes HTTP requests and dynamically formulates HTTP responses.</source>
          <target state="translated">브라우저는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; 내에서 시작된 사이트 간 요청에 대한 특정 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; 를 보냅니다 . 또한 교차 사이트 응답과 함께 특정 HTTP 헤더가 다시 전송 될 것으로 예상합니다. 요청을 시작하고 서버의 응답을 처리하는 샘플 JavaScript 코드 및 각 헤더에 대한 설명을 포함하여 이러한 헤더에 대한 개요는 &lt;a href=&quot;cors&quot;&gt;HTTP 액세스 제어 (CORS) 기사에서 찾을 수 있으며 이에 대한 기사&lt;/a&gt; 로 읽어야합니다. 이 하나. 이 문서에서는 &lt;strong&gt;액세스 제어 요청&lt;/strong&gt; 처리 및 &lt;strong&gt;액세스 제어 응답&lt;/strong&gt; 공식화에 대해 설명합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;PHP에서. 이 기사의 대상은 서버 프로그래머 또는 관리자입니다. 여기에 표시된 코드 샘플은 PHP로되어 있지만 ASP.net, Perl, Python, Java 등에 유사한 개념이 적용됩니다. 일반적으로 이러한 개념은 HTTP 요청을 처리하고 HTTP 응답을 동적으로 공식화하는 모든 서버 측 프로그래밍 환경에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4d0e2f5033f06ac6f49cc655a388250e954dd48" translate="yes" xml:space="preserve">
          <source>Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords. Firefox used to use &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed over to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers, and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="translated">브라우저 는 사용자 이름 및 비밀번호에 &lt;code&gt;utf-8&lt;/code&gt; 인코딩을 사용 합니다. Firefox는 &lt;code&gt;ISO-8859-1&lt;/code&gt; 을 사용 했지만 다른 브라우저와의 패리티를 위해 &lt;code&gt;utf-8&lt;/code&gt; 로 변경 되었으며 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;버그 1419658에&lt;/a&gt; 설명 된대로 잠재적 인 문제를 피 했습니다 .</target>
        </trans-unit>
        <trans-unit id="a63957685418f827a422303f2aa0c711fe3143d4" translate="yes" xml:space="preserve">
          <source>Browsers use the MIME type, &lt;strong&gt;not the file extension&lt;/strong&gt;, to determine how to process a URL &amp;mdash; it is important that servers send the correct MIME type in the response's &lt;a href=&quot;../headers/content-type&quot;&gt;Content-Type header&lt;/a&gt;.</source>
          <target state="translated">브라우저 &lt;strong&gt;는 파일 확장자가 아닌&lt;/strong&gt; MIME 유형을 사용하여 URL을 처리하는 방법을 결정합니다. 서버는 응답의 &lt;a href=&quot;../headers/content-type&quot;&gt;Content-Type 헤더&lt;/a&gt; 에 올바른 MIME 유형을 보내는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="5bc12d6c5418def433565d97fa4386bb760ddfa9" translate="yes" xml:space="preserve">
          <source>Buggy &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;proxies&lt;/a&gt; are still common and these lead to strange and erratic behaviors that Web developers cannot foresee and diagnose easily.</source>
          <target state="translated">버기 &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;프록시&lt;/a&gt; 는 여전히 일반적이며 웹 개발자가 쉽게 예측하고 진단 할 수없는 이상하고 불규칙한 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="3838036b670cc0248afd246abbe594ee328cf4de" translate="yes" xml:space="preserve">
          <source>But browsers and standards are not perfect, and there are still some edge cases where detecting the browser is needed. Using the user agent to detect the browser looks simple, but doing it well is, in fact, a very hard problem. This document will guide you in doing this as correctly as possible.</source>
          <target state="translated">그러나 브라우저와 표준은 완벽하지 않으며 브라우저 감지가 필요한 경우가 여전히 있습니다. 사용자 에이전트를 사용하여 브라우저를 감지하는 것은 간단 해 보이지만 실제로는 매우 어려운 문제입니다. 이 문서는 가능한 한 정확하게이 작업을 수행하도록 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7c8e3ceffa66e087ea7c8b96aa7587bcaf4d90e8" translate="yes" xml:space="preserve">
          <source>But if it&amp;rsquo;s not possible to make those changes, then another way that may be possible is to this:</source>
          <target state="translated">그러나 이러한 변경을 수행 할 수없는 경우 가능한 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95da926485cbe7c1b54926edc5fadc82e556e609" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; 요청은 순차적으로 발행됩니다. 다음 요청은 현재 요청에 대한 응답이 수신 된 후에 만 ​​발행됩니다. 네트워크 대기 시간 및 대역폭 제한의 영향을 받으 므로 서버 에서 다음 요청이 &lt;em&gt;표시&lt;/em&gt; 되기 전에 상당한 지연이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbfb748d8e0737c34e1264e5236d921dd7f9917f" translate="yes" xml:space="preserve">
          <source>By default, a response is cacheable if the requirements of the
   request method, request header fields, and the response status
   indicate that it is cacheable. &lt;a href=&quot;#section-13.4&quot;&gt;Section 13.4&lt;/a&gt; summarizes these defaults
   for cacheability. The following Cache-Control response directives
   allow an origin server to override the default cacheability of a
   response:

   public
      Indicates that the response MAY be cached by any cache, even if it
      would normally be non-cacheable or cacheable only within a non-
      shared cache. (See also Authorization, &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;, for
      additional details.)

   private
      Indicates that all or part of the response message is intended for
      a single user and MUST NOT be cached by a shared cache. This
      allows an origin server to state that the specified parts of the 

      response are intended for only one user and are not a valid
      response for requests by other users. A private (non-shared) cache
      MAY cache the response.

       Note: This usage of the word private only controls where the
       response may be cached, and cannot ensure the privacy of the
       message content.

   no-cache
       If the no-cache directive does not specify a field-name, then a
      cache MUST NOT use the response to satisfy a subsequent request
      without successful revalidation with the origin server. This
      allows an origin server to prevent caching even by caches that
      have been configured to return stale responses to client requests.

      If the no-cache directive does specify one or more field-names,
      then a cache MAY use the response to satisfy a subsequent request,
      subject to any other restrictions on caching. However, the
      specified field-name(s) MUST NOT be sent in the response to a
      subsequent request without successful revalidation with the origin
      server. This allows an origin server to prevent the re-use of
      certain header fields in a response, while still allowing caching
      of the rest of the response.

       Note: Most HTTP/1.0 caches will not recognize or obey this
       directive.</source>
          <target state="translated">요청 메소드, 요청 헤더 필드 및 응답 상태의 요구 사항이 캐시 가능함을 표시하는 경우 기본적으로 응답은 캐시 가능합니다. &lt;a href=&quot;#section-13.4&quot;&gt;섹션 13.4&lt;/a&gt; 에는 캐시 가능성에 대한 이러한 기본값이 요약되어 있습니다. 다음과 같은 캐시 제어 응답 지시문을 사용하면 오리진 서버가 응답의 기본 캐시 가능성을 대체 할 수 있습니다. . (권한, &lt;a href=&quot;#section-14.8&quot;&gt;섹션 14.8 참조&lt;/a&gt;비공개 응답 메시지의 일부 또는 전부가 단일 사용자를위한 것이며 공유 캐시에 의해 캐시되지 않아야 함을 나타냅니다. 이를 통해 오리진 서버는 응답의 지정된 부분이 한 명의 사용자만을위한 것이며 다른 사용자의 요청에 대한 올바른 응답이 아니라고 진술 할 수 있습니다. 비공개 (비공유) 캐시는 응답을 캐시 할 수 있습니다. 참고 :이 private이라는 단어 사용은 응답을 캐시 할 수있는 위치 만 제어하며 메시지 내용의 프라이버시를 보장 할 수 없습니다. no-cache no-cache 지시문이 field-name을 지정하지 않으면, 캐시는 원본 서버와의 재확인없이 후속 요청을 만족시키기 위해 응답을 사용해서는 안됩니다.이를 통해 오리진 서버는 클라이언트 요청에 부실 응답을 리턴하도록 구성된 캐시로도 캐싱을 방지 할 수 있습니다. no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.지정된 field-name (s)은 오리진 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.지정된 field-name (s)은 오리진 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11cebe099b732834a230be98a924681140743e7e" translate="yes" xml:space="preserve">
          <source>By default, only the 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;simple response headers&lt;/a&gt; are exposed:</source>
          <target state="translated">기본적으로 6 개의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;간단한 응답 헤더&lt;/a&gt; 만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f534edc05bd142ea112ee3efccba58b43dd4c66" translate="yes" xml:space="preserve">
          <source>By default, the Geolocation API can be used within top-level documents and their same-origin child frames. This directive allows or prevents cross-origin frames from accessing geolocation. This includes same-origin frames.</source>
          <target state="translated">기본적으로 Geolocation API는 최상위 문서 및 동일한 원본 자식 프레임 내에서 사용할 수 있습니다. 이 지시문은 출처 간 프레임이 지리적 위치에 액세스하는 것을 허용하거나 방지합니다. 여기에는 동일한 출처 프레임이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e044c03f1a747bedf5cf5499ef70c090ed113f76" translate="yes" xml:space="preserve">
          <source>By default, top-level documents and their same-origin child frames can request and enter fullscreen mode. This directive allows or prevents cross-origin frames from using fullscreen mode. This includes same-origin frames.</source>
          <target state="translated">기본적으로 최상위 문서 및 동일한 원본 자식 프레임은 전체 화면 모드를 요청하고 입력 할 수 있습니다. 이 지시문은 출처 간 프레임이 전체 화면 모드를 사용하도록 허용하거나 방지합니다. 여기에는 동일한 출처 프레임이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d23c07d6cec707b5f2b899cf897854aba60b3de4" translate="yes" xml:space="preserve">
          <source>By default, violation reports aren't sent. To enable violation reporting, you need to specify the &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; policy directive, providing at least one URI to which to deliver the reports:</source>
          <target state="translated">기본적으로 위반 보고서는 전송되지 않습니다. 위반보고를 사용하려면 &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 를 전달할 URI를 하나 이상 제공 하여 report-uri 정책 지시문 을 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8029f70a8cb4b060850538e53207e165c56eb9a2" translate="yes" xml:space="preserve">
          <source>By far, the most common use case for upgrading an HTTP connection is to use WebSockets, which are always implemented by upgrading an HTTP or HTTPS connection. Keep in mind that if you're opening a new connection using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket API&lt;/a&gt;, or any library that does WebSockets, most or all of this is done for you. For example, opening a WebSocket connection is as simple as:</source>
          <target state="translated">지금까지 HTTP 연결을 업그레이드하는 가장 일반적인 사용 사례는 항상 HTTP 또는 HTTPS 연결을 업그레이드하여 구현되는 WebSocket을 사용하는 것입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket API&lt;/a&gt; 또는 WebSocket을 수행하는 라이브러리를 사용하여 새 연결을 여는 경우이 중 대부분 또는 전부가 자동으로 수행됩니다. 예를 들어, WebSocket 연결을 여는 것은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8358024c4d3220c8cee184585d77cac9c14c31ac" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts, regardless of their origin.</source>
          <target state="translated">지정하여 &lt;code&gt;'none'&lt;/code&gt; 원점 목록 키워드를, 지정된 기능을 기점과 상관없이, 모든 검색 컨텍스트에 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="424fa2e5f873eae608f951882e066b4cbc6e7248" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP intermediaries are men-in-the-middle and,
   thus, represent an opportunity for man-in-the-middle attacks.
   Compromise of the systems on which the intermediaries run can result
   in serious security and privacy problems.  Intermediaries might have
   access to security-related information, personal information about
   individual users and organizations, and proprietary information
   belonging to users and content providers.  A compromised
   intermediary, or an intermediary implemented or configured without
   regard to security and privacy considerations, might be used in the
   commission of a wide range of potential attacks.

   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC7234]&lt;/a&gt;. 

   Implementers need to consider the privacy and security implications
   of their design and coding decisions, and of the configuration
   options they provide to operators (especially the default
   configuration).

   Users need to be aware that intermediaries are no more trustworthy
   than the people who run them; HTTP itself cannot solve this problem.</source>
          <target state="translated">본질적으로 HTTP 중개자는 중간자 (man-in-the-middle)이므로 중간자 (man-in-the-middle) 공격의 기회를 나타냅니다. 중개자가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 중개자는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보 및 사용자 및 컨텐츠 제공자에 속하는 독점 정보에 액세스 할 수 있습니다. 보안 및 개인 정보 보호 고려 사항과 무관하게 훼손된 중개자 또는 구현되거나 구성된 중개자가 광범위한 잠재적 공격을 수행하는 데 사용될 수 있습니다. 공유 캐시를 포함하는 중개자 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;는 [RFC7234]의 섹션 8에&lt;/a&gt; 설명 된 것처럼 캐시 중독 공격에 특히 취약합니다 .. 구현자는 설계 및 코딩 결정, 그리고 운영자에게 제공하는 구성 옵션 (특히 기본 구성)의 개인 정보 보호 및 보안 관련 사항을 고려해야합니다. 사용자는 중개자가 자신을 운영하는 사람들보다 더 신뢰할 수 없다는 것을 알고 있어야합니다. HTTP 자체는이 문제를 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="068b79ba257daf146b30abe76ed868aecb1b606b" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP proxies are men-in-the-middle, and
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the proxies run can result in serious security
   and privacy problems. Proxies have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised proxy, or a proxy implemented or
   configured without regard to security and privacy considerations,
   might be used in the commission of a wide range of potential attacks.

   Proxy operators should protect the systems on which proxies run as
   they would protect any system that contains or transports sensitive
   information. In particular, log information gathered at proxies often
   contains highly sensitive personal information, and/or information
   about organizations. Log information should be carefully guarded, and
   appropriate guidelines for use developed and followed. (&lt;a href=&quot;#section-15.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). 

   Caching proxies provide additional potential vulnerabilities, since
   the contents of the cache represent an attractive target for
   malicious exploitation. Because cache contents persist after an HTTP
   request is complete, an attack on the cache can reveal information
   long after a user believes that the information has been removed from
   the network. Therefore, cache contents should be protected as
   sensitive information.

   Proxy implementors should consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to proxy operators (especially the
   default configuration).

   Users of a proxy need to be aware that they are no trustworthier than
   the people who run the proxy; HTTP itself cannot solve this problem.

   The judicious use of cryptography, when appropriate, may suffice to
   protect against a broad range of security and privacy attacks. Such
   cryptography is beyond the scope of the HTTP/1.1 specification.</source>
          <target state="translated">본질적으로 HTTP 프록시는 중간자 (man-in-the-middle)이며 중간자 (man-in-the-middle) 공격의 기회를 나타냅니다. 프록시가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 프록시는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보 및 사용자 및 컨텐츠 제공자에 속하는 독점 정보에 액세스 할 수 있습니다. 보안 및 개인 정보 보호 고려 사항에 관계없이 구현 된 프록시 또는 손상된 프록시가 광범위한 잠재적 공격에 사용될 수 있습니다. 프록시 운영자는 중요한 정보를 포함하거나 전송하는 시스템을 보호 할 때 프록시가 실행되는 시스템을 보호해야합니다. 특히,프록시에 수집 된 로그 정보에는 종종 민감한 개인 정보 및 / 또는 조직에 대한 정보가 포함됩니다. 로그 정보는주의해서 보호해야하며 사용에 대한 적절한 지침을 개발하고 준수해야합니다. (&lt;a href=&quot;#section-15.1.1&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). 캐시의 내용은 악의적 인 악용의 매력적인 대상이되기 때문에 캐싱 프록시는 추가적인 잠재적 취약점을 제공합니다. HTTP 요청이 완료된 후에도 캐시 내용이 유지되므로 사용자가 네트워크에서 정보가 제거되었다고 생각한 후에 캐시를 공격하면 정보가 노출 될 수 있습니다. 따라서 캐시 내용은 중요한 정보로 보호되어야합니다. 프록시 구현자는 디자인 및 코딩 결정, 프록시 운영자에게 제공하는 구성 옵션 (특히 기본 구성)의 개인 정보 보호 및 보안 영향을 고려해야합니다. 프록시 사용자는 프록시를 실행하는 사람들보다 자신이 신뢰할 수 없음을 알고 있어야합니다. HTTP 자체는이 문제를 해결할 수 없습니다. 암호화의 신중한 사용적절한 경우 광범위한 보안 및 개인 정보 공격으로부터 보호하기에 충분할 수 있습니다. 이러한 암호화는 HTTP / 1.1 사양의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="3dfb40a9e84e63716a4b33d9963c4cfd678075a5" translate="yes" xml:space="preserve">
          <source>Byte Ranges (RFC 7233)</source>
          <target state="translated">바이트 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b18368c56eb40788963923a6e1129947a0d58087" translate="yes" xml:space="preserve">
          <source>C-Shell script</source>
          <target state="translated">C 쉘 스크립트</target>
        </trans-unit>
        <trans-unit id="6e288959d3443bcec62386f7d9014542f6872829" translate="yes" xml:space="preserve">
          <source>CONNECT</source>
          <target state="translated">CONNECT</target>
        </trans-unit>
        <trans-unit id="2600bf1e8e192e1bd65ac3bc3a4d82977f60d6da" translate="yes" xml:space="preserve">
          <source>CONNECT (RFC 7231)</source>
          <target state="translated">연결 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="2139aadec237bbecb581e62932f94bc3bce7a704" translate="yes" xml:space="preserve">
          <source>CORS</source>
          <target state="translated">CORS</target>
        </trans-unit>
        <trans-unit id="6296a1fd2a34552fbb648aabe29411711a0e4595" translate="yes" xml:space="preserve">
          <source>CORS and caching</source>
          <target state="translated">CORS 및 캐싱</target>
        </trans-unit>
        <trans-unit id="3c63268612970c5bd579c70dbeed257045fe1f70" translate="yes" xml:space="preserve">
          <source>CORS enabled image</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e825c1a70b304027f50005fcb1118744bfcdf168" translate="yes" xml:space="preserve">
          <source>CORS error messages</source>
          <target state="translated">CORS 오류 메시지</target>
        </trans-unit>
        <trans-unit id="184d3111cdadf6b3fad8c042206c94ffd04e65c3" translate="yes" xml:space="preserve">
          <source>CORS errors</source>
          <target state="translated">CORS 오류</target>
        </trans-unit>
        <trans-unit id="e389a185748256670e3bef3e9d485d4db6698009" translate="yes" xml:space="preserve">
          <source>CORS failures result in errors, but for security reasons, specifics about what went wrong &lt;em&gt;are not available to JavaScript code&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</source>
          <target state="translated">CORS 실패로 인해 오류가 발생하지만 보안상의 이유로 잘못된 사항에 대한 세부 사항 &lt;em&gt;은 JavaScript 코드에서 사용할 수 없습니다&lt;/em&gt; . 모든 코드는 오류가 발생했다는 것을 알고 있습니다. 구체적으로 무엇이 잘못되었는지 확인하는 유일한 방법은 브라우저 콘솔에서 자세한 내용을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="de24c9d37107bb00fdf3a04f2c2a9d24eabcbabc" translate="yes" xml:space="preserve">
          <source>CORS introduction</source>
          <target state="translated">CORS 소개</target>
        </trans-unit>
        <trans-unit id="ee0eba3ae2bb3a8277a088b3fe2cba0700041b16" translate="yes" xml:space="preserve">
          <source>CORS settings attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c658a0ab02da27fa9bc91475d5f929983201d0e9" translate="yes" xml:space="preserve">
          <source>CORS-safelisted request-header</source>
          <target state="translated">CORS 안전 요청 헤더</target>
        </trans-unit>
        <trans-unit id="4822cee4b44a5acfdf824aef5c202c725aa2e1ef" translate="yes" xml:space="preserve">
          <source>CORS-safelisted response-header</source>
          <target state="translated">CORS 허용 응답 헤더</target>
        </trans-unit>
        <trans-unit id="3115498a58c30161e8334af0606a41f44c318e04" translate="yes" xml:space="preserve">
          <source>CSP</source>
          <target state="translated">CSP</target>
        </trans-unit>
        <trans-unit id="70771af22a8b356fbf094cdf8ec696e798056732" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시어</target>
        </trans-unit>
        <trans-unit id="44f87a469d5fa9f5e3c9a3ab2c29c19df8341c51" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="2e0d3366da966d21d7a419c2ed0bbe7fe3d112f6" translate="yes" xml:space="preserve">
          <source>CSP Level 2 frame-ancestors directive</source>
          <target state="translated">CSP 레벨 2 프레임 조상 지시문</target>
        </trans-unit>
        <trans-unit id="d9132b00c8144355d2ffb30916581bd6454aef63" translate="yes" xml:space="preserve">
          <source>CSP allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSP는 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더, &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 포함하여 리소스에 대해 여러 정책을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84514b55cad8a4471776e8261e9056e00bb80eff" translate="yes" xml:space="preserve">
          <source>CSP directives</source>
          <target state="translated">CSP 지시어</target>
        </trans-unit>
        <trans-unit id="ac7e232a207938fbc334d7ae81fd9271bdea2b5f" translate="yes" xml:space="preserve">
          <source>CSP in workers</source>
          <target state="translated">근로자의 CSP</target>
        </trans-unit>
        <trans-unit id="62becf9c2b19df7737b78178e6297a23a4286119" translate="yes" xml:space="preserve">
          <source>CSP is designed to be fully backward compatible (except CSP version 2 where there are some explicitly-mentioned inconsistencies in backward compatibility; more details &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;here&lt;/a&gt; section 1.1). Browsers that don't support it still work with servers that implement it, and vice-versa: browsers that don't support CSP simply ignore it, functioning as usual, defaulting to the standard same-origin policy for web content. If the site doesn't offer the CSP header, browsers likewise use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;.</source>
          <target state="translated">CSP는 이전 버전과 완벽하게 호환되도록 설계되었습니다 (CSP 버전 2는 하위 호환성에 명시 적으로 불일치가 &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;있습니다&lt;/a&gt; ( 자세한 내용 은 섹션 1.1)). 이를 지원하지 않는 브라우저는 여전히이를 구현하는 서버에서 작동하며 그 반대도 마찬가지입니다. CSP를 지원하지 않는 브라우저는이를 무시하고 평소와 같이 작동하며 기본적으로 웹 컨텐츠에 대한 표준 동일 출처 정책으로 기본 설정됩니다. 사이트에서 CSP 헤더를 제공하지 않으면 브라우저도 마찬가지로 표준 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일 출처 정책을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc54f753bc7cbbc002ef53de42786ebf31429cfa" translate="yes" xml:space="preserve">
          <source>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those whitelisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</source>
          <target state="translated">CSP를 통해 서버 관리자는 브라우저가 실행 가능한 스크립트의 유효한 소스로 간주해야하는 도메인을 지정하여 XSS가 발생할 수있는 벡터를 줄이거 나 없앨 수 있습니다. 그러면 CSP 호환 브라우저는 허용 된 도메인에서받은 소스 파일에로드 된 스크립트 만 실행하며 다른 모든 스크립트 (인라인 스크립트 및 이벤트 처리 HTML 속성 포함)는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7031a0ce63915761c940ed51b1837a242dbd3b4b" translate="yes" xml:space="preserve">
          <source>CSP version</source>
          <target state="translated">CSP 버전</target>
        </trans-unit>
        <trans-unit id="a3d4a5f94061540e9f0aa3594fa2f993bb976f3b" translate="yes" xml:space="preserve">
          <source>CSP: base-uri</source>
          <target state="translated">CSP : 기본 URI</target>
        </trans-unit>
        <trans-unit id="e1f387bd5a0bc1c97fc48409c2910b8698c8640e" translate="yes" xml:space="preserve">
          <source>CSP: block-all-mixed-content</source>
          <target state="translated">CSP : 모든 콘텐츠 혼합</target>
        </trans-unit>
        <trans-unit id="b25eb56df44cb67b582b21cd3edbd78acfb7b3e7" translate="yes" xml:space="preserve">
          <source>CSP: child-src</source>
          <target state="translated">CSP : child-src</target>
        </trans-unit>
        <trans-unit id="d8d4703b593508b27eaeff8d0aebcd15f991e8e2" translate="yes" xml:space="preserve">
          <source>CSP: connect-src</source>
          <target state="translated">CSP : connect-src</target>
        </trans-unit>
        <trans-unit id="68907bfebcb9f7aaac284a06b0682cb8062e8905" translate="yes" xml:space="preserve">
          <source>CSP: default-src</source>
          <target state="translated">CSP : default-src</target>
        </trans-unit>
        <trans-unit id="33201263305688f8d0319035bf86905e02a74b2e" translate="yes" xml:space="preserve">
          <source>CSP: font-src</source>
          <target state="translated">CSP : font-src</target>
        </trans-unit>
        <trans-unit id="288f4f31fbc4626f98b2f869fd485b9fad754b76" translate="yes" xml:space="preserve">
          <source>CSP: form-action</source>
          <target state="translated">CSP : 양식 동작</target>
        </trans-unit>
        <trans-unit id="1110c66ccba3f4594386963f17efd01ebfc1cd32" translate="yes" xml:space="preserve">
          <source>CSP: frame-ancestors</source>
          <target state="translated">CSP : 프레임 조상</target>
        </trans-unit>
        <trans-unit id="a9d7881b7f2e872886dea3318b9ec4ad54690900" translate="yes" xml:space="preserve">
          <source>CSP: frame-src</source>
          <target state="translated">CSP : 프레임 -SRC</target>
        </trans-unit>
        <trans-unit id="21056b59bbdeaabbcbf48e5b78e6825df16fd152" translate="yes" xml:space="preserve">
          <source>CSP: img-src</source>
          <target state="translated">CSP : img-src</target>
        </trans-unit>
        <trans-unit id="5b7bbbea8fbb911ad61a95926c52038e17270734" translate="yes" xml:space="preserve">
          <source>CSP: manifest-src</source>
          <target state="translated">CSP : manifest-src</target>
        </trans-unit>
        <trans-unit id="216739951c2911845bfa3c58a3e1759ef762351f" translate="yes" xml:space="preserve">
          <source>CSP: media-src</source>
          <target state="translated">CSP : 미디어 SRC</target>
        </trans-unit>
        <trans-unit id="4b0f2d6ea1745b227865a7908c705926a5818865" translate="yes" xml:space="preserve">
          <source>CSP: object-src</source>
          <target state="translated">CSP : object-src</target>
        </trans-unit>
        <trans-unit id="9310170277ea799be8285b0064422067334219b7" translate="yes" xml:space="preserve">
          <source>CSP: plugin-types</source>
          <target state="translated">CSP : 플러그인 유형</target>
        </trans-unit>
        <trans-unit id="61f55d98b5a3ac85d047f911ee4a486f34144e3d" translate="yes" xml:space="preserve">
          <source>CSP: referrer</source>
          <target state="translated">CSP : 리퍼러</target>
        </trans-unit>
        <trans-unit id="a53be58aafa7031586553deadc48190f849f218d" translate="yes" xml:space="preserve">
          <source>CSP: report-to</source>
          <target state="translated">CSP :보고</target>
        </trans-unit>
        <trans-unit id="865f9627c1b6ca237d57e68fc76c695bc3af6d64" translate="yes" xml:space="preserve">
          <source>CSP: report-uri</source>
          <target state="translated">CSP : 보고서 URI</target>
        </trans-unit>
        <trans-unit id="360c612795c5fa6ec239445c2a3549cdd177ae8f" translate="yes" xml:space="preserve">
          <source>CSP: require-sri-for</source>
          <target state="translated">CSP : 요구 사항</target>
        </trans-unit>
        <trans-unit id="95233e49e595781c9ba6c45123a969ceace0209c" translate="yes" xml:space="preserve">
          <source>CSP: sandbox</source>
          <target state="translated">CSP : 샌드 박스</target>
        </trans-unit>
        <trans-unit id="746f3a678a7fdd2c8e56ab69cf9f85ffa266928d" translate="yes" xml:space="preserve">
          <source>CSP: script-src</source>
          <target state="translated">CSP : 스크립트 -SRC</target>
        </trans-unit>
        <trans-unit id="073f20d15a570fd6d41695506e3f4b44db4ec9c8" translate="yes" xml:space="preserve">
          <source>CSP: style-src</source>
          <target state="translated">CSP : 스타일 -SRC</target>
        </trans-unit>
        <trans-unit id="bdec421ab6d7add012ba02e55c66584a25b4ae24" translate="yes" xml:space="preserve">
          <source>CSP: upgrade-insecure-requests</source>
          <target state="translated">CSP : 업그레이드 비보안 요청</target>
        </trans-unit>
        <trans-unit id="fb8f32fe79e286807b14bcfd102e8d5b1bd01893" translate="yes" xml:space="preserve">
          <source>CSP: worker-src</source>
          <target state="translated">CSP : 작업자 -SRC</target>
        </trans-unit>
        <trans-unit id="63b89c4cbe4e07b5d318b0db30585680356a57b5" translate="yes" xml:space="preserve">
          <source>CSS &lt;code&gt;url()&lt;/code&gt;</source>
          <target state="translated">CSS &lt;code&gt;url()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc5b4a629abbfbd5eccc6eedfa9f028a8215b669" translate="yes" xml:space="preserve">
          <source>CSS can fetch resources referenced from stylesheets. These resources are following a referrer policy as well.</source>
          <target state="translated">CSS는 스타일 시트에서 참조 된 리소스를 가져올 수 있습니다. 이러한 리소스는 리퍼러 정책도 준수합니다.</target>
        </trans-unit>
        <trans-unit id="f7417538e496bd203aa442ce377a765b360b5ad7" translate="yes" xml:space="preserve">
          <source>CSS files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a58e854c19a4742126d3d6571cf7bf2c94f204" translate="yes" xml:space="preserve">
          <source>CSS files used to style a Web page&lt;strong&gt; must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt;. If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</source>
          <target state="translated">웹 페이지의 스타일을 지정하는 데 사용되는 CSS 파일 은 &lt;code&gt;text/css&lt;/code&gt; 와 함께 전송 &lt;strong&gt;되어야합니다&lt;/strong&gt; . 서버가 CSS 파일 의 &lt;code&gt;.css&lt;/code&gt; 접미사를 인식하지 못하면 &lt;code&gt;text/plain&lt;/code&gt; 또는 &lt;code&gt;application/octet-stream&lt;/code&gt; MIME 형식으로 보낼 수 있습니다. 그렇다면 대부분의 브라우저에서 CSS로 인식되지 않으므로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c9387eaae83736c3d69453fd21bd568dec8f4524" translate="yes" xml:space="preserve">
          <source>Cache handling of a response to a conditional request is dependent
   upon its status code:

   o  A 304 (Not Modified) response status code indicates that the
      stored response can be updated and reused; see &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;.

   o  A full response (i.e., one with a payload body) indicates that
      none of the stored responses nominated in the conditional request
      is suitable.  Instead, the cache MUST use the full response to
      satisfy the request and MAY replace the stored response(s).

   o  However, if a cache receives a 5xx (Server Error) response while
      attempting to validate a response, it can either forward this
      response to the requesting client, or act as if the server failed
      to respond.  In the latter case, the cache MAY send a previously
      stored response (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">조건부 요청에 대한 응답의 캐시 처리는 상태 코드에 따라 다릅니다. o 304 (수정되지 않음) 응답 상태 코드는 저장된 응답을 업데이트하고 재사용 할 수 있음을 나타냅니다. &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; 참조 . o 전체 응답 (즉, 페이로드 본문이있는 응답)은 조건부 요청에 지정된 저장된 응답이 적합하지 않음을 나타냅니다. 대신, 캐시는 요청을 충족시키기 위해 전체 응답을 사용해야하며 저장된 응답을 대체 할 수 있습니다. o 그러나 응답의 유효성을 검증하는 중에 캐시가 5xx (서버 오류) 응답을 수신하면 요청 응답 클라이언트에게이 응답을 전달하거나 서버가 응답하지 않은 것처럼 작동 할 수 있습니다. 후자의 경우, 캐시는 이전에 저장된 응답을 보낼 수 있습니다&lt;a href=&quot;#section-4.2.4&quot;&gt;섹션 4.2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9eca146b7d059bac1fffb373a3b4ac5a46895065" translate="yes" xml:space="preserve">
          <source>Cache refresh: this indicates that the cache value is still fresh and can be used.</source>
          <target state="translated">캐시 새로 고침 : 캐시 값이 여전히 최신 상태이며 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="797e92b9fd4173be50b6906927ba56a7e66b9d27" translate="yes" xml:space="preserve">
          <source>Cache request directives</source>
          <target state="translated">캐시 요청 지시문</target>
        </trans-unit>
        <trans-unit id="0b943ff4cafdda6a82e806c4186ad1f27a30b226" translate="yes" xml:space="preserve">
          <source>Cache response directives</source>
          <target state="translated">캐시 응답 지시문</target>
        </trans-unit>
        <trans-unit id="363657bc3c95ae010a3ed0bae48a02dfa27c59c4" translate="yes" xml:space="preserve">
          <source>Cache results of a preflight request for 10 minutes:</source>
          <target state="translated">프리 플라이트 요청 결과를 10 분 동안 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="0426eb019de93cd2ae1c3a3a04b09dc6cfd746ab" translate="yes" xml:space="preserve">
          <source>Cache static content: offload the web servers by caching static content like pictures,</source>
          <target state="translated">정적 컨텐츠 캐시 : 그림과 같은 정적 컨텐츠를 캐시하여 웹 서버를 오프로드하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc8d7aabbcac8d512fa7176f44889e337cb29b2" translate="yes" xml:space="preserve">
          <source>Cache update</source>
          <target state="translated">캐시 업데이트</target>
        </trans-unit>
        <trans-unit id="f39c0f09e8619679ee8854f8b7b8e45d8271d16d" translate="yes" xml:space="preserve">
          <source>Cache validation</source>
          <target state="translated">캐시 유효성 검사</target>
        </trans-unit>
        <trans-unit id="9b09c51972b24aaf8bff4e23301b40da54c025b6" translate="yes" xml:space="preserve">
          <source>Cache-Control</source>
          <target state="translated">Cache-Control</target>
        </trans-unit>
        <trans-unit id="96c175aa287942740a4c9dc0851f228f568c2dd0" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 2616)</source>
          <target state="translated">캐시 제어 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="db46bd114028441fc2cb90df358efa899df9e03d" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 7234)</source>
          <target state="translated">캐시 제어 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="f831d9e40838da8be7663f96e7bf5e81e81f1527" translate="yes" xml:space="preserve">
          <source>Cacheability</source>
          <target state="translated">Cacheability</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="367eb2cade8f9a82f981b9ecbd24bcbcccc4234d" translate="yes" xml:space="preserve">
          <source>Cacheable Methods (RFC 7231)</source>
          <target state="translated">캐시 가능한 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="6d4faa9c38ae0bea36b2a77a74f1c5565404a706" translate="yes" xml:space="preserve">
          <source>Caching FAQ</source>
          <target state="translated">캐싱 FAQ</target>
        </trans-unit>
        <trans-unit id="c30dddf76b8532fde16158f240307de27191ec53" translate="yes" xml:space="preserve">
          <source>Caching Tutorial &amp;ndash; Mark Nottingham</source>
          <target state="translated">캐싱 튜토리얼 &amp;ndash; Mark Nottingham</target>
        </trans-unit>
        <trans-unit id="0587c95421ffd96422e6ce52f99b0eeb12897612" translate="yes" xml:space="preserve">
          <source>Caching in HTTP (RFC 2616)</source>
          <target state="translated">HTTP 캐싱 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="12274da356087ef702ccbb200cdfa705f2a6cb21" translate="yes" xml:space="preserve">
          <source>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading from the originating server. This achieves several goals: it eases the load of the server that doesn&amp;rsquo;t need to serve all clients itself, and it improves performance by being closer to the client, i.e., it takes less time to transmit the resource back. For a web site, it is a major component in achieving high performance. On the other side, it has to be configured properly as not all resources stay identical forever: it is important to cache a resource only until it changes, not longer.</source>
          <target state="translated">캐싱은 주어진 리소스의 복사본을 저장하고 요청시 다시 서비스하는 기술입니다. 웹 캐시에 해당 저장소에 요청 된 리소스가 있으면 요청을 차단하고 원래 서버에서 다시 다운로드하는 대신 복사본을 반환합니다. 이를 통해 여러 가지 목표를 달성 할 수 있습니다. 모든 클라이언트에게 서비스를 제공 할 필요가없는 서버의로드를 줄이고, 클라이언트와 더 가까워 지므로 성능을 향상시킵니다. 즉, 리소스를 다시 전송하는 데 걸리는 시간이 줄어 듭니다. 웹 사이트의 경우 고성능을 달성하는 데있어 주요 구성 요소입니다. 반면에 모든 리소스가 영원히 동일하게 유지되는 것은 아니므로 올바르게 구성해야합니다. 더 이상 변경되지 않을 때까지만 리소스를 캐시하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d5bd9f8c4cb307c4c859ece3e85c3287fab9c02d" translate="yes" xml:space="preserve">
          <source>Caching is very important for fast Web sites. This article describes different methods of caching and how to use HTTP Headers to control them.</source>
          <target state="translated">캐싱은 빠른 웹 사이트에 매우 중요합니다. 이 문서에서는 다양한 캐싱 방법과 HTTP 헤더를 사용하여이를 캐싱하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="948ba29270deb9f483242162487c780bcfdc8dba" translate="yes" xml:space="preserve">
          <source>Caching of unchanged resources</source>
          <target state="translated">변경되지 않은 리소스 캐싱</target>
        </trans-unit>
        <trans-unit id="23206d16033b30654e4d04b8e38733f9a9b711e1" translate="yes" xml:space="preserve">
          <source>Caching static assets</source>
          <target state="translated">정적 자산 캐싱</target>
        </trans-unit>
        <trans-unit id="224012a44d1a3dcbedc904993d8d0726b013bed5" translate="yes" xml:space="preserve">
          <source>Caching-related headers that are sent along with this response should be taken care of, as a 503 status is often a temporary condition and responses shouldn't usually be cached.</source>
          <target state="translated">이 응답과 함께 전송되는 캐싱 관련 헤더는 503 상태가 일시적인 조건이므로 응답을 캐시하지 않기 때문에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="72bc7dfdbfb35fbe7d280800db5164dcd1988d57" translate="yes" xml:space="preserve">
          <source>Calculating Secondary Keys with Vary (RFC 7234)</source>
          <target state="translated">가변으로 2 차 키 계산 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="1c8974e3fdbd4a7f871b765b73b10e7d5c3e086c" translate="yes" xml:space="preserve">
          <source>Camino on Mac</source>
          <target state="translated">Mac의 카미노</target>
        </trans-unit>
        <trans-unit id="2f86269acd3e77cefb32ddc78f8c4c6c9bd506e6" translate="yes" xml:space="preserve">
          <source>Can you spot the mistake? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">실수를 알아낼 수 있습니까? 스타일 시트는 &lt;code&gt;cdn.example.com&lt;/code&gt; 에서만로드 할 수 있지만 웹 사이트는 고유 한 원점 ( &lt;code&gt;http://example.com&lt;/code&gt; ) 에서로드하려고합니다 . CSP를 적용 할 수있는 브라우저 는 문서를 방문 할 때 다음 위반 보고서를 POST 요청으로 &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt; 에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8b35fa85102875260c5079cd9bdec0d2fdc2ee7d" translate="yes" xml:space="preserve">
          <source>Can you spot the violation? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">위반 사항을 발견 할 수 있습니까? 스타일 시트는 &lt;code&gt;cdn.example.com&lt;/code&gt; 에서만로드 할 수 있지만 웹 사이트는 고유 한 원점 ( &lt;code&gt;http://example.com&lt;/code&gt; ) 에서로드하려고합니다 . CSP를 적용 할 수있는 브라우저 는 문서를 방문 할 때 다음 위반 보고서를 POST 요청으로 &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt; 에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c19fa848f8d18f6a6f2a50f399649151c43d2ccf" translate="yes" xml:space="preserve">
          <source>Candidate Recommendation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23538d20ac9108dc1735c5b220e319e9fe9ebfa3" translate="yes" xml:space="preserve">
          <source>Cascading Style Sheets (CSS)</source>
          <target state="translated">캐스 케이 딩 스타일 시트 (CSS)</target>
        </trans-unit>
        <trans-unit id="aa1717d0e9589578b46ef62dc5cfe9cd1de83ba5" translate="yes" xml:space="preserve">
          <source>Category Documents contain lists of categories described using the
   &quot;atom:category&quot; element from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].
   Categories can also appear in Service Documents, where they indicate
   the categories allowed in a Collection (see &lt;a href=&quot;#section-8.3.6&quot;&gt;Section 8.3.6&lt;/a&gt;).

   Category Documents are identified with the &quot;application/atomcat+xml&quot;
   media type (see &lt;a href=&quot;#section-16.1&quot;&gt;Section 16.1&lt;/a&gt;).</source>
          <target state="translated">카테고리 문서에는 Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 &quot;atom : category&quot;요소를 사용하여 설명 된 카테고리 목록이 포함되어 있습니다 . 카테고리는 서비스 문서에도 나타날 수 있으며, 여기서 컬렉션에서 허용되는 카테고리를 나타냅니다 ( &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6 절&lt;/a&gt; 참조 ). 카테고리 문서는 &quot;application / atomcat + xml&quot;매체 유형으로 식별됩니다 ( &lt;a href=&quot;#section-16.1&quot;&gt;16.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="98cfdc8dc518c66839eb93c58f7c6441910d5d79" translate="yes" xml:space="preserve">
          <source>Change the default behavior of autoplay on mobile and third party videos.</source>
          <target state="translated">모바일 및 타사 비디오에서 자동 재생의 기본 동작을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e97cb80f95cbab0c6a227b198b72f39726ca3006" translate="yes" xml:space="preserve">
          <source>Change the default values or options that control the feature behavior.</source>
          <target state="translated">기능 동작을 제어하는 ​​기본값 또는 옵션을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="811bf2bd6edd23474dfa0570cd89845010ee8135" translate="yes" xml:space="preserve">
          <source>Character encoding of HTTP authentication</source>
          <target state="translated">HTTP 인증의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="245374780def29c61ce1165c1fdbe13bc3583f38" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility table&lt;/a&gt; carefully before using this in production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de85527d64c40bc55991f2429578ed63d3ac01ed" translate="yes" xml:space="preserve">
          <source>Checking if a server supports partial requests</source>
          <target state="translated">서버가 부분 요청을 지원하는지 확인</target>
        </trans-unit>
        <trans-unit id="ffef88d017227b1ea1b9169e0335da32c5b6a9dd" translate="yes" xml:space="preserve">
          <source>Choosing between www and non-www URLs</source>
          <target state="translated">www와 www가 아닌 ​​URL 중에서 선택</target>
        </trans-unit>
        <trans-unit id="218e75c7a912404b048fff0747e40108873b6334" translate="yes" xml:space="preserve">
          <source>Chrome</source>
          <target state="translated">Chrome</target>
        </trans-unit>
        <trans-unit id="04c901a0daf91c2a0f3e8fdc0701d52f69dd276c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">Chrome 59 이상은 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="4f8f8ffcc2cbf126c04a5b0120a393e971c34f1c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the deprecated &lt;code&gt;child-src&lt;/code&gt; directive.</source>
          <target state="translated">Chrome 59 이상은 더 이상 사용되지 않는 &lt;code&gt;child-src&lt;/code&gt; 지시문을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="936b3a2c1e8b0dd5e471f5ddaa07ff52d2e26abf" translate="yes" xml:space="preserve">
          <source>Chrome UA string</source>
          <target state="translated">크롬 UA 문자열</target>
        </trans-unit>
        <trans-unit id="d099f88b010d4398cebebe8e633ffe4874c4aa01" translate="yes" xml:space="preserve">
          <source>Chrome for Android</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019a920351ae1cc253d801e3029fcb49f0363eb6" translate="yes" xml:space="preserve">
          <source>Chrome/xyz</source>
          <target state="translated">Chrome/xyz</target>
        </trans-unit>
        <trans-unit id="530e72f2ef34a9545e0a5330771934b72c420c79" translate="yes" xml:space="preserve">
          <source>Chrome/xyz or Chromium/xyz</source>
          <target state="translated">Chrome / xyz 또는 Chromium / xyz</target>
        </trans-unit>
        <trans-unit id="32166e83eed3818d45d2cbecbe2e6cf85528e265" translate="yes" xml:space="preserve">
          <source>Chromium</source>
          <target state="translated">Chromium</target>
        </trans-unit>
        <trans-unit id="a00534e71fb83f1f72f13c598065c49858fefc4a" translate="yes" xml:space="preserve">
          <source>Chromium/xyz</source>
          <target state="translated">Chromium/xyz</target>
        </trans-unit>
        <trans-unit id="f2e3d3255876440830fb74bf171c1d2ece3388ed" translate="yes" xml:space="preserve">
          <source>Chromium: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;Issue 615313&lt;/a&gt;</source>
          <target state="translated">크롬 : &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;문제 615313&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02dae4314d1b02d0bfeeff3a285006bc4766d38a" translate="yes" xml:space="preserve">
          <source>Chunked encoding</source>
          <target state="translated">청크 인코딩</target>
        </trans-unit>
        <trans-unit id="0e13d13f96bc6fbff5ad281601f23302761c061e" translate="yes" xml:space="preserve">
          <source>Chunked encoding is useful when larger amounts of data are sent to the client and the total size of the response may not be known until the request has been fully processed. For example, when generating a large HTML table resulting from a database query or when transmitting large images. A chunked response looks like this:</source>
          <target state="translated">청크 인코딩은 더 많은 양의 데이터가 클라이언트로 전송 될 때 유용하며 요청이 완전히 처리 될 때까지 응답의 전체 크기를 알 수 없습니다. 예를 들어, 데이터베이스 쿼리로 인해 큰 HTML 테이블을 생성하거나 큰 이미지를 전송할 때. 청크 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8220572e0102502603e5875887b5183212dd190a" translate="yes" xml:space="preserve">
          <source>Chunked responses are now also supported.</source>
          <target state="translated">청크 응답도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db3313f2827a057e3a64943f9f95e2ab49a79565" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding</source>
          <target state="translated">청크 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="02f5fbe3823ae3ee8836aabcd6aedc25a237e372" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding using a trailing header</source>
          <target state="translated">후행 헤더를 사용하는 청크 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="5b18750fa39107d207083b7b1ced1d41dba0f08b" translate="yes" xml:space="preserve">
          <source>Clear Site Data</source>
          <target state="translated">명확한 사이트 데이터</target>
        </trans-unit>
        <trans-unit id="563a0adf9cc2a772ffc80a2f072b2791b10b2699" translate="yes" xml:space="preserve">
          <source>Clear-Site-Data</source>
          <target state="translated">Clear-Site-Data</target>
        </trans-unit>
        <trans-unit id="47c3b55337992becca7776593cb6ed91ea600664" translate="yes" xml:space="preserve">
          <source>Clearing cookies</source>
          <target state="translated">쿠키 삭제</target>
        </trans-unit>
        <trans-unit id="cc7132c182abf9d906ed90a092216ab6aefbc162" translate="yes" xml:space="preserve">
          <source>Clears browsing data (e.g. cookies, storage, cache) associated with the requesting website.</source>
          <target state="translated">요청하는 웹 사이트와 관련된 탐색 데이터 (예 : 쿠키, 저장소, 캐시)를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ca8349d76abe296a6950f45aded7fe82937ec47" translate="yes" xml:space="preserve">
          <source>ClickJacking Defenses - IEBlog</source>
          <target state="translated">ClickJacking Defense-IEBlog</target>
        </trans-unit>
        <trans-unit id="04d39ef8ff1810b107a1befbb4f275d469a941cd" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) DELETE to Member URI                 |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a DELETE request to the URI of a Member
       Resource.

   2.  If the deletion is successful, the server responds with a status
       code of 200.

   A different approach is taken for deleting Media Resources; see
   &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for details.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 멤버 URI로 삭제 | | ------------------------------------------&amp;gt; | | | | 2.) 200 OK | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 DELETE 요청을 멤버 리소스의 URI로 보냅니다. 2. 삭제에 성공하면 서버는 상태 코드 200으로 응답합니다. 미디어 리소스를 삭제하는 다른 방법이 사용됩니다. 자세한 내용 &lt;a href=&quot;#section-9.4&quot;&gt;은 9.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06414e618e271894c3e9df0da8e1288e8b9d978d" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Member URI                    |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Member Representation                |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of a Member Resource to
       retrieve its representation.

   2.  The server responds with the representation of the Member
       Resource.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 회원 URI에 GET | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ok | | 회원 대표 | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 GET 요청을 구성원 자원의 URI로 보내 해당 표현을 검색합니다. 2. 서버는 구성원 자원의 표시로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="76876be155df9d3b1979f0004de22edc27efe8b1" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Service Document URI          |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Service Document                     |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of the Service
       Document.

   2.  The server responds with a Service Document enumerating the IRIs
       of a group of Collections and the capabilities of those
       Collections supported by the server.  The content of this
       document can vary based on aspects of the client request,
       including, but not limited to, authentication credentials.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 서비스 문서 URI로 GET | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ok | | 서비스 문서 | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 서비스 문서의 URI에 GET 요청을 보냅니다. 2. 서버는 컬렉션 그룹의 IRI 및 서버가 지원하는 컬렉션의 기능을 열거하는 서비스 문서로 응답합니다. 이 문서의 내용은 클라이언트 요청의 측면에 따라 다를 수 있습니다.인증 자격 증명.</target>
        </trans-unit>
        <trans-unit id="1d5b247b01ee86613d994ca606b20cb6279035ed" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) POST to Collection URI               |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 201 Created                          |
     |      Location: Member Entry URI           |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client POSTs a representation of the Member to the URI of the
       Collection.

   2.  If the Member Resource was created successfully, the server
       responds with a status code of 201 and a Location header that
       contains the IRI of the newly created Entry Resource.  Media
       Resources could have also been created and their IRIs can be
       found through the Entry Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt; for more
       details.</source>
          <target state="translated">클라이언트 서버 | | | 1.) POST to Collection URI | | 회원 대표 | | ------------------------------------------&amp;gt; | | | | 2) 201 Created | | 위치 : 회원 항목 URI | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 Member의 표현을 Collection의 URI에 POST합니다. 2. 구성원 자원이 성공적으로 작성된 경우, 서버는 상태 코드 201과 새로 작성된 항목 자원의 IRI를 포함하는 Location 헤더로 응답합니다.미디어 리소스도 만들 수 있었으며 IRI는 엔트리 리소스를 통해 찾을 수 있습니다. 보다&lt;a href=&quot;#section-9.6&quot;&gt;&lt;/a&gt;자세한 내용은 섹션 9.6 .</target>
        </trans-unit>
        <trans-unit id="cd91d64f5ba1c2b561dc68aad78122e44b4031ba" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) PUT to Member URI                    |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|

   1.  The client sends a PUT request to store a representation of a
       Member Resource.

   2.  If the request is successful, the server responds with a status
       code of 200.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 회원 URI에 PUT | | 회원 대표 | | ------------------------------------------&amp;gt; | | | | 2.) 200 OK | | &amp;lt;------------------------------------------ | 1. 클라이언트는 PUT 요청을 보내 회원 리소스의 표현을 저장합니다. 2. 요청이 성공하면 서버는 상태 코드 200으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="2ab41737272cae6324e9b264638622ce30e7016c" translate="yes" xml:space="preserve">
          <source>Client error responses</source>
          <target state="translated">클라이언트 오류 응답</target>
        </trans-unit>
        <trans-unit id="dd407b441928f45e73a186d44c8d9b1022e9b952" translate="yes" xml:space="preserve">
          <source>Client hints</source>
          <target state="translated">클라이언트 힌트</target>
        </trans-unit>
        <trans-unit id="d5d9a54cc11d8f25e2a07fd30bc5b8caf775ec8d" translate="yes" xml:space="preserve">
          <source>Client request</source>
          <target state="translated">고객 요청</target>
        </trans-unit>
        <trans-unit id="c5b2b8d440453db220355b3130f1ed0c4ab07917" translate="yes" xml:space="preserve">
          <source>Client-Side &amp;amp; Server-Side (Java) sample for Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">CORS (Cross-Origin Resource Sharing)에 대한 클라이언트 측 및 서버 측 (Java) 샘플</target>
        </trans-unit>
        <trans-unit id="6f5874c4570fe3f1c919c21b9967af34bee3005c" translate="yes" xml:space="preserve">
          <source>Client-initiated upgrade to HTTP over TLS</source>
          <target state="translated">TLS를 통한 HTTP로 클라이언트 시작 업그레이드</target>
        </trans-unit>
        <trans-unit id="922d22a1c7654940e60c03245c40184c1e28e1bb" translate="yes" xml:space="preserve">
          <source>Client: the user-agent</source>
          <target state="translated">클라이언트 : 사용자 에이전트</target>
        </trans-unit>
        <trans-unit id="28beb9075baceef63887e188043a5dc8f9f8abcf" translate="yes" xml:space="preserve">
          <source>Clients and servers communicate by exchanging individual messages (as opposed to a stream of data). The messages sent by the client, usually a Web browser, are called &lt;em&gt;requests&lt;/em&gt; and the messages sent by the server as an answer are called &lt;em&gt;responses&lt;/em&gt;.</source>
          <target state="translated">클라이언트와 서버는 개별 메시지를 교환하여 통신합니다 (데이터 스트림이 아닌). 클라이언트 (보통 웹 브라우저)가 보낸 메시지를 &lt;em&gt;요청&lt;/em&gt; 이라고 하고 서버가 응답으로 보낸 메시지를 &lt;em&gt;response&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="f0a6c74917d2b5e80cb29e5ed1cc31e500515eb2" translate="yes" xml:space="preserve">
          <source>Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with
   resources (e.g., the user's name, location, mail address, passwords,
   encryption keys, etc.) and information about the user's browsing
   activity over time (e.g., history, bookmarks, etc.).  Implementations
   need to prevent unintentional disclosure of personal information.</source>
          <target state="translated">클라이언트는 종종 사용자가 리소스와 상호 작용하기 위해 제공 한 정보 (예 : 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등) 및 사용자의 브라우징 활동에 대한 정보를 포함하여 많은 양의 개인 정보를 소유합니다. 시간 (예 : 기록, 북마크 등). 구현시 의도하지 않은 개인 정보 공개가 방지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8385dd1dcb9fe615c68497e7d83ea0f53328707" translate="yes" xml:space="preserve">
          <source>Clients using HTTP rely heavily on the Domain Name Service, and are
   thus generally prone to security attacks based on the deliberate
   mis-association of IP addresses and DNS names. Clients need to be
   cautious in assuming the continuing validity of an IP number/DNS name
   association.

   In particular, HTTP clients SHOULD rely on their name resolver for
   confirmation of an IP number/DNS name association, rather than
   caching the result of previous host name lookups. Many platforms
   already can cache host name lookups locally when appropriate, and
   they SHOULD be configured to do so. It is proper for these lookups to
   be cached, however, only when the TTL (Time To Live) information
   reported by the name server makes it likely that the cached
   information will remain useful.

   If HTTP clients cache the results of host name lookups in order to
   achieve a performance improvement, they MUST observe the TTL
   information reported by DNS.

   If HTTP clients do not observe this rule, they could be spoofed when
   a previously-accessed server's IP address changes. As network
   renumbering is expected to become increasingly common [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;], the
   possibility of this form of attack will grow. Observing this
   requirement thus reduces this potential security vulnerability.

   This requirement also improves the load-balancing behavior of clients
   for replicated servers using the same DNS name and reduces the
   likelihood of a user's experiencing failure in accessing sites which
   use that strategy.</source>
          <target state="translated">HTTP를 사용하는 클라이언트는 도메인 이름 서비스에 크게 의존하므로 일반적으로 IP 주소와 DNS 이름의 잘못된 연결을 기반으로 보안 공격을 받기 쉽습니다. IP 번호 / DNS 이름 연결이 계속 유효하다고 가정 할 때 클라이언트는주의해야합니다. 특히, HTTP 클라이언트는 이전 호스트 이름 조회 결과를 캐싱하기보다는 IP 번호 / DNS 이름 연결을 확인하기 위해 이름 확인자에 의존해야합니다 (SHOULD). 많은 플랫폼이 이미 적절한 경우 호스트 이름 조회를 로컬로 캐시 할 수 있으므로 그렇게 구성해야합니다. 이름 서버가보고 한 TTL (Time To Live) 정보로 인해 캐시 된 정보가 유용 할 가능성이있는 경우에만 이러한 조회를 캐시하는 것이 좋습니다.HTTP 클라이언트가 성능 향상을 위해 호스트 이름 조회 결과를 캐시하는 경우 DNS에서보고 한 TTL 정보를 준수해야합니다. HTTP 클라이언트가이 규칙을 준수하지 않으면 이전에 액세스 한 서버의 IP 주소가 변경 될 때 스푸핑 될 수 있습니다. 네트워크 번호 변경이 점점 일반화 될 것으로 예상됨에 따라 [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ], 이러한 형태의 공격 가능성이 커질 것이다. 따라서이 요구 사항을 준수하면 잠재적 인 보안 취약점이 줄어 듭니다. 또한이 요구 사항은 동일한 DNS 이름을 사용하여 복제 된 서버에 대한 클라이언트의 부하 분산 동작을 개선하고 해당 전략을 사용하는 사이트에 액세스하는 데 사용자가 실패 할 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="939f605954e45144b33768a5bb94ffea000db6cc" translate="yes" xml:space="preserve">
          <source>Close or reuse the connection for further requests.</source>
          <target state="translated">추가 요청을 위해 연결을 닫거나 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="2a1800f5cb859b9d67e384c7da846507f055a233" translate="yes" xml:space="preserve">
          <source>Code Samples Showing &lt;code&gt;XMLHttpRequest&lt;/code&gt; and Cross-Origin Resource Sharing</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 Cross-Origin 리소스 공유를 보여주는 코드 샘플</target>
        </trans-unit>
        <trans-unit id="d674b2dea57bb6fd7e6a35edd6eb081470fbfe96" translate="yes" xml:space="preserve">
          <source>Collection Resources MUST provide representations in the form of Atom
   Feed Documents whose Entries contain the IRIs of the Members in the
   Collection.  No distinction is made between Collection Feeds and
   other kinds of Feeds -- a Feed might act both as a 'public' feed for
   subscription purposes and as a Collection Feed.

   Each Entry in the Feed Document SHOULD have an atom:link element with
   a relation of &quot;edit&quot; (see &lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;).

   The Entries in the returned Atom Feed SHOULD be ordered by their
   &quot;app:edited&quot; property, with the most recently edited Entries coming
   first in the document order.  The app:edited value is not equivalent
   to the HTTP Last-Modified header and cannot be used to determine the
   freshness of cached responses.

   Clients MUST NOT assume that an Atom Entry returned in the Feed is a
   full representation of an Entry Resource and SHOULD perform a GET on
   the URI of the Member Entry before editing it.  See &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt; for a
   discussion on the implications of cache control directives when
   obtaining entries.</source>
          <target state="translated">수거 자료는 Atom Feed Documents 형식으로 출품작에 해당 회원의 IRI가 포함 된 표현을 제공해야합니다. 수집 피드와 다른 종류의 피드는 구별되지 않습니다. 피드는 구독 목적을위한 '공개'피드와 수집 피드의 역할을합니다. 피드 문서의 각 엔트리는 &quot;edit&quot;관계의 atom : link 요소를 가져야합니다 ( &lt;a href=&quot;#section-11.1&quot;&gt;11.1 장&lt;/a&gt; 참조)). 반환 된 Atom Feed의 항목은 &quot;app : edited&quot;속성으로 주문해야하며 가장 최근에 편집 한 항목이 문서 순서에서 먼저 나타납니다. app : edited 값은 HTTP Last-Modified 헤더와 같지 않으며 캐시 된 응답의 최신 성을 결정하는 데 사용할 수 없습니다. 고객은 피드에 반환 된 Atom Entry가 Entry Resource의 전체 표현이라고 가정해서는 안되며, 편집하기 전에 Member Entry의 URI에서 GET을 수행해야합니다. 항목을 얻을 때 캐시 제어 지시문의 의미에 대한 설명 은 &lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b11e6ff9806f23d877b8f28e66ba1d2666df0aba" translate="yes" xml:space="preserve">
          <source>Collection resources differ from other resources in that they also
   act as containers.  Some HTTP methods apply only to a collection, but
   some apply to some or all of the resources inside the container
   defined by the collection.  When the scope of a method is not clear,
   the client can specify what depth to apply.  Depth can be either zero
   levels (only the collection), one level (the collection and directly
   contained resources), or infinite levels (the collection and all
   contained resources recursively).

   A collection's state consists of at least a set of mappings between
   path segments and resources, and a set of properties on the
   collection itself.  In this document, a resource B will be said to be
   contained in the collection resource A if there is a path segment
   mapping that maps to B and that is contained in A.  A collection MUST
   contain at most one mapping for a given path segment, i.e., it is
   illegal to have the same path segment mapped to more than one
   resource. 

   Properties defined on collections behave exactly as do properties on
   non-collection resources.  A collection MAY have additional state
   such as entity bodies returned by GET.

   For all WebDAV-compliant resources A and B, identified by URLs &quot;U&quot;
   and &quot;V&quot;, respectively, such that &quot;V&quot; is equal to &quot;U/SEGMENT&quot;, A MUST
   be a collection that contains a mapping from &quot;SEGMENT&quot; to B.  So, if
   resource B with URL &quot;http://example.com/bar/blah&quot; is WebDAV compliant
   and if resource A with URL &quot;http://example.com/bar/&quot; is WebDAV
   compliant, then resource A must be a collection and must contain
   exactly one mapping from &quot;blah&quot; to B.

   Although commonly a mapping consists of a single segment and a
   resource, in general, a mapping consists of a set of segments and a
   resource.  This allows a server to treat a set of segments as
   equivalent (i.e., either all of the segments are mapped to the same
   resource, or none of the segments are mapped to a resource).  For
   example, a server that performs case-folding on segments will treat
   the segments &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, and &quot;AB&quot; as equivalent.  A client can
   then use any of these segments to identify the resource.  Note that a
   PROPFIND result will select one of these equivalent segments to
   identify the mapping, so there will be one PROPFIND response element
   per mapping, not one per segment in the mapping.

   Collection resources MAY have mappings to non-WebDAV-compliant
   resources in the HTTP URL namespace hierarchy but are not required to
   do so.  For example, if resource X with URL
   &quot;http://example.com/bar/blah&quot; is not WebDAV compliant and resource A
   with &quot;URL http://example.com/bar/&quot; identifies a WebDAV collection,
   then A may or may not have a mapping from &quot;blah&quot; to X.

   If a WebDAV-compliant resource has no WebDAV-compliant internal
   members in the HTTP URL namespace hierarchy, then the WebDAV-
   compliant resource is not required to be a collection.

   There is a standing convention that when a collection is referred to
   by its name without a trailing slash, the server MAY handle the
   request as if the trailing slash were present.  In this case, it
   SHOULD return a Content-Location header in the response, pointing to
   the URL ending with the &quot;/&quot;.  For example, if a client invokes a
   method on http://example.com/blah (no trailing slash), the server may
   respond as if the operation were invoked on http://example.com/blah/
   (trailing slash), and should return a Content-Location header with
   the value http://example.com/blah/.  Wherever a server produces a URL
   referring to a collection, the server SHOULD include the trailing
   slash.  In general, clients SHOULD use the trailing slash form of
   collection names.  If clients do not use the trailing slash form the
   client needs to be prepared to see a redirect response.  Clients will 

   find the DAV:resourcetype property more reliable than the URL to find
   out if a resource is a collection.

   Clients MUST be able to support the case where WebDAV resources are
   contained inside non-WebDAV resources.  For example, if an OPTIONS
   response from &quot;http://example.com/servlet/dav/collection&quot; indicates
   WebDAV support, the client cannot assume that
   &quot;http://example.com/servlet/dav/&quot; or its parent necessarily are
   WebDAV collections.

   A typical scenario in which mapped URLs do not appear as members of
   their parent collection is the case where a server allows links or
   redirects to non-WebDAV resources.  For instance, &quot;/col/link&quot; might
   not appear as a member of &quot;/col/&quot;, although the server would respond
   with a 302 status to a GET request to &quot;/col/link&quot;; thus, the URL
   &quot;/col/link&quot; would indeed be mapped.  Similarly, a dynamically-
   generated page might have a URL mapping from &quot;/col/index.html&quot;, thus
   this resource might respond with a 200 OK to a GET request yet not
   appear as a member of &quot;/col/&quot;.

   Some mappings to even WebDAV-compliant resources might not appear in
   the parent collection.  An example for this case are servers that
   support multiple alias URLs for each WebDAV-compliant resource.  A
   server may implement case-insensitive URLs, thus &quot;/col/a&quot; and
   &quot;/col/A&quot; identify the same resource, yet only either &quot;a&quot; or &quot;A&quot; is
   reported upon listing the members of &quot;/col&quot;.  In cases where a server
   treats a set of segments as equivalent, the server MUST expose only
   one preferred segment per mapping, consistently chosen, in PROPFIND
   responses.</source>
          <target state="translated">수집 자원은 컨테이너 역할도한다는 점에서 다른 자원과 다릅니다. 일부 HTTP 메소드는 콜렉션에만 적용되지만 일부는 콜렉션에 의해 정의 된 컨테이너 내부의 일부 또는 모든 자원에 적용됩니다. 메소드의 범위가 명확하지 않은 경우 클라이언트는 적용 할 깊이를 지정할 수 있습니다. 깊이는 0 레벨 (컬렉션 만), 1 레벨 (컬렉션 및 직접 포함 된 자원) 또는 무한 레벨 (컬렉션 및 모든 포함 된 자원을 재귀 적으로)입니다. 컬렉션의 상태는 최소한 경로 세그먼트와 리소스 간의 매핑 집합과 컬렉션 자체의 속성 집합으로 구성됩니다. 이 문서에서B에 매핑되고 A에 포함 된 경로 세그먼트 매핑이있는 경우 리소스 B는 컬렉션 리소스 A에 포함되어 있다고합니다. 컬렉션은 주어진 경로 세그먼트에 대해 최대 하나의 매핑을 포함해야합니다. 동일한 경로 세그먼트를 둘 이상의 리소스에 매핑하는 것은 불법입니다. 컬렉션에 정의 된 속성은 컬렉션이 아닌 리소스의 속성과 똑같이 동작합니다. 컬렉션은 GET에 의해 반환 된 엔티티 본문과 같은 추가 상태를 가질 수 있습니다. &quot;V&quot;가 &quot;U / SEGMENT&quot;와 같은 URL &quot;U&quot;및 &quot;V&quot;로 식별되는 모든 WebDAV 호환 리소스 A 및 B에 대해 A는 &quot;SEGMENT&quot;의 매핑을 포함하는 모음이어야합니다. URL이 &quot;http://example.com/bar/blah&quot;인 리소스 B가URL이 &quot;http://example.com/bar/&quot;인 자원 A가 WebDAV를 준수하는 경우 자원 A는 콜렉션이어야하며 &quot;blah&quot;에서 B로 정확히 하나의 맵핑을 포함해야합니다. 단일 세그먼트 및 자원의 일반적으로, 맵핑은 일련의 세그먼트 및 자원으로 구성된다. 이를 통해 서버는 세그먼트 세트를 동등한 것으로 처리 할 수 ​​있습니다 (즉, 모든 세그먼트가 동일한 자원에 맵핑되거나 세그먼트에 자원이 맵핑되지 않음). 예를 들어, 세그먼트에서 케이스 접기를 수행하는 서버는 세그먼트 &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;및 &quot;AB&quot;를 동등한 것으로 취급합니다. 클라이언트는 이러한 세그먼트 중 하나를 사용하여 리소스를 식별 할 수 있습니다.PROPFIND 결과는 맵핑을 식별하기 위해 이러한 동등한 세그먼트 중 하나를 선택하므로 맵핑에서 세그먼트 당 하나가 아니라 맵핑 당 하나의 PROPFIND 응답 요소가 있습니다. 콜렉션 자원은 HTTP URL 네임 스페이스 계층 구조에서 WebDAV 호환이 아닌 자원에 대한 맵핑을 가질 수 있지만 그렇게 할 필요는 없습니다. 예를 들어 URL이 &quot;http://example.com/bar/blah&quot;인 자원 X가 WebDAV를 준수하지 않고 &quot;URL http://example.com/bar/&quot;를 가진 자원 A가 WebDAV 콜렉션을 식별하면 A가 WebDAV 호환 리소스에 HTTP URL 네임 스페이스 계층 구조에 WebDAV 호환 내부 멤버가없는 경우 WebDAV 호환 리소스가 컬렉션 일 필요는 없습니다.컬렉션이 후행 슬래시없이 이름으로 참조 될 경우 서버는 후행 슬래시가있는 것처럼 요청을 처리 할 수 ​​있습니다. 이 경우 응답에 Content-Location 헤더를 반환하고 &quot;/&quot;로 끝나는 URL을 가리켜 야합니다. 예를 들어, 클라이언트가 http://example.com/blah (후행 슬래시 없음)에서 메소드를 호출하면 서버는 http://example.com/blah/ (트레일 슬래시)에서 작업이 호출 된 것처럼 응답 할 수 있습니다. 이며 값이 http://example.com/blah/ 인 Content-Location 헤더를 반환해야합니다. 서버가 컬렉션을 참조하는 URL을 생성 할 때마다 서버 뒤에 슬래시를 포함해야합니다. 일반적으로 클라이언트는 슬래시 형식의 컬렉션 이름을 사용해야합니다.클라이언트가 후행 슬래시 양식을 사용하지 않으면 클라이언트가 경로 재 지정 응답을 볼 수 있도록 준비해야합니다. 클라이언트는 DAV : resourcetype 속성이 URL보다 더 안정적이라는 것을 알게되어 리소스가 컬렉션인지 확인합니다. 클라이언트는 WebDAV 자원이 WebDAV가 아닌 자원에 포함 된 경우를 지원할 수 있어야합니다. 예를 들어, &quot;http://example.com/servlet/dav/collection&quot;의 OPTIONS 응답이 WebDAV 지원을 나타내는 경우 클라이언트는 &quot;http://example.com/servlet/dav/&quot;또는 해당 상위가 WebDAV 모음입니다. 맵핑 된 URL이 상위 콜렉션의 구성원으로 나타나지 않는 일반적인 시나리오는 서버가 WebDAV 이외의 자원으로의 링크 또는 경로 재 지정을 허용하는 경우입니다. 예를 들어 &quot;/ col / link&quot;서버가 &quot;/ col / link&quot;에 대한 GET 요청에 대해 302 상태로 응답하지만 &quot;/ col /&quot;의 구성원으로 나타나지 않을 수 있습니다. 따라서 URL &quot;/ col / link&quot;는 실제로 매핑됩니다. 마찬가지로 동적으로 생성 된 페이지에는 &quot;/col/index.html&quot;의 URL 맵핑이있을 수 있으므로이 자원은 200 OK로 GET 요청에 응답하지만 &quot;/ col /&quot;의 구성원으로 표시되지 않을 수 있습니다. WebDAV 호환 리소스에 대한 일부 매핑은 상위 컬렉션에 나타나지 않을 수 있습니다. 이 경우의 예는 각 WebDAV 호환 자원에 대해 다중 별명 URL을 지원하는 서버입니다. 서버는 대소 문자를 구분하지 않는 URL을 구현할 수 있으므로 &quot;/ col / a&quot;및 &quot;/ col / A&quot;는 동일한 리소스를 식별하지만 &quot;a&quot;또는 &quot;A&quot;만 식별합니다&quot;/ col&quot;의 회원을 등록하면보고됩니다. 서버가 세그먼트 세트를 동등한 것으로 취급하는 경우, 서버는 PROPFIND 응답에서 일관되게 선택된 맵핑 당 하나의 선호 세그먼트 만 노출해야합니다.</target>
        </trans-unit>
        <trans-unit id="92c14ed70a70a4eecdf0beb11029acb63043ecd0" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  Due to interoperability problems, allowable formats for contents
      of 'href' elements in multistatus responses have been limited (see
      &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).

   o  Due to lack of implementation, support for the 'propertybehavior'
      request body for COPY and MOVE has been removed.  Instead,
      requirements for property preservation have been clarified (see
      Sections &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; and &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;).

   Properties

   o  Strengthened server requirements for storage of property values,
      in particular persistence of language information (xml:lang),
      whitespace, and XML namespace information (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   o  Clarified requirements on which properties should be writable by
      the client; in particular, setting &quot;DAV:displayname&quot; should be
      supported by servers (see &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;).

   o  Only '&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date' productions are legal as values for DAV:
      getlastmodified (see &lt;a href=&quot;#section-15.7&quot;&gt;Section 15.7&lt;/a&gt;).

   Headers and Marshalling

   o  Servers are now required to do authorization checks before
      processing conditional headers (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;).

   Locking

   o  Strengthened requirement to check identity of lock creator when
      accessing locked resources (see &lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;).  Clients should be
      aware that lock tokens returned to other principals can only be
      used to break a lock, if at all. 

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;Section&amp;nbsp;8.10.4 of [RFC2518]&lt;/a&gt; incorrectly required servers to return
      a 409 status where a 207 status was really appropriate.  This has
      been corrected (&lt;a href=&quot;#section-9.10&quot;&gt;Section 9.10&lt;/a&gt;).</source>
          <target state="translated">컬렉션 및 네임 스페이스 작업 o 상호 운용성 문제로 인해 다중 상태 응답에서 'href'요소의 내용에 허용되는 형식이 제한되었습니다 ( &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ). o 구현 부족으로 인해 COPY 및 MOVE에 대한 'propertybehavior'요청 본문에 대한 지원이 제거되었습니다. 대신, 재산 보존에 대한 요구 사항이 명확 해졌습니다 (섹션 &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; 및 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; 참조 ). 속성 o 속성 값 저장, 특히 언어 정보의 지속성 (xml : lang), 공백 및 XML 네임 스페이스 정보에 대한 서버 요구 사항 강화 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 단원&lt;/a&gt; 참조)). o 고객이 속성을 쓸 수있는 명확한 요구 사항 특히, &quot;DAV : displayname&quot;설정은 서버에서 지원해야합니다 ( &lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt; 참조 ). o ' &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date'프로덕션 만 DAV의 값으로 유효합니다 : getlastmodified ( &lt;a href=&quot;#section-15.7&quot;&gt;15.7 절&lt;/a&gt; 참조 ). 헤더 및 마샬링 o 이제 서버는 조건부 헤더를 처리하기 전에 권한 검사를 수행해야합니다 ( &lt;a href=&quot;#section-8.5&quot;&gt;8.5 절&lt;/a&gt; 참조 ). 잠금 o 잠금 리소스에 액세스 할 때 잠금 생성기의 신원을 확인하기위한 요구 사항 강화 ( &lt;a href=&quot;#section-6.4&quot;&gt;6.4 단원&lt;/a&gt; 참조)). 클라이언트는 다른 프린시 펄로 리턴 된 잠금 토큰은 잠금을 해제하는 데에만 사용될 수 있음을 알고 있어야합니다. o &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;[RFC2518] 섹션 8.10.4는&lt;/a&gt; 서버가 207 상태가 실제로 적절한 409 상태를 반환하도록 잘못 요구했습니다. 이것은 수정되었습니다 ( &lt;a href=&quot;#section-9.10&quot;&gt;Section 9.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cfd2e08606ba977053d3bef5451af9337fdfae03" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  The semantics of PROPFIND 'allprop' (&lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;) have been
      relaxed so that servers return results including, at a minimum,
      the live properties defined in this specification, but not
      necessarily return other live properties.  The 'allprop' directive
      therefore means something more like &quot;return all properties that
      are supposed to be returned when 'allprop' is requested&quot; -- a set
      of properties that may include custom properties and properties
      defined in other specifications if those other specifications so
      require.  Related to this, 'allprop' requests can now be extended
      with the 'include' syntax to include specific named properties, 

      thereby avoiding additional requests due to changed 'allprop'
      semantics.

   o  Servers are now allowed to reject PROPFIND requests with Depth:
      Infinity.  Clients that used this will need to be able to do a
      series of Depth:1 requests instead.

   o  Multi-Status response bodies now can transport the value of HTTP's
      Location response header in the new 'location' element.  Clients
      may use this to avoid additional roundtrips to the server when
      there is a 'response' element with a 3xx status (see
      &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt;).

   o  The definition of COPY has been relaxed so that it doesn't require
      servers to first delete the target resources anymore (this was a
      known incompatibility with [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  See &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;.

   Headers and Marshalling

   o  The Destination and If request headers now allow absolute paths in
      addition to full URIs (see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).  This may be useful for
      clients operating through a reverse proxy that does rewrite the
      Host request header, but not WebDAV-specific headers.

   o  This specification adopts the error marshalling extensions and the
      &quot;precondition/postcondition&quot; terminology defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] (see
      &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;).  Related to that, it adds the &quot;error&quot; XML element
      inside multistatus response bodies (see &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;, however note
      that it uses a format different from the one recommended in &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt;).

   o  Senders and recipients are now required to support the UTF-16
      character encoding in XML message bodies (see &lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;).

   o  Clients are now required to send the Depth header on PROPFIND
      requests, although servers are still encouraged to support clients
      that don't.

   Locking

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;'s concept of &quot;lock-null resources&quot; (LNRs) has been
      replaced by a simplified approach, the &quot;locked empty resources&quot;
      (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;).  There are some aspects of lock-null resources
      clients cannot rely on anymore, namely, the ability to use them to
      create a locked collection or the fact that they disappear upon
      UNLOCK when no PUT or MKCOL request was issued.  Note that servers
      are still allowed to implement LNRs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;. 

   o  There is no implicit refresh of locks anymore.  Locks are only
      refreshed upon explicit request (see &lt;a href=&quot;#section-9.10.2&quot;&gt;Section 9.10.2&lt;/a&gt;).

   o  Clarified that the DAV:owner value supplied in the LOCK request
      must be preserved by the server just like a dead property
      (&lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;).  Also added the DAV:lockroot element
      (&lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;), which allows clients to discover the root of
      lock.</source>
          <target state="translated">컬렉션과 네임 스페이스 연산 o PROPFIND 'allprop'의 의미론 ( &lt;a href=&quot;#section-9.1&quot;&gt;9.1 절)&lt;/a&gt;)는 서버가이 사양에 정의 된 라이브 속성을 포함하여 결과를 반환하지만 반드시 다른 라이브 속성을 반환하지는 않습니다. 따라서 'allprop'지시어는 &quot; 'allprop'가 요청 될 때 리턴되어야하는 모든 특성 리턴&quot;과 같은 것을 의미합니다. 다른 특성에서 요구하는 경우 다른 스펙에 정의 된 사용자 정의 특성 및 특성을 포함 할 수있는 특성 세트 . 이와 관련하여 'allprop'요청을 'include'구문으로 확장하여 특정 명명 된 속성을 포함함으로써 변경된 'allprop'시맨틱으로 인한 추가 요청을 피할 수 있습니다. o 이제 서버는 깊이가있는 PROPFIND 요청을 거부 할 수 있습니다.무한대. 이를 사용하는 클라이언트는 일련의 Depth : 1 요청을 대신 수행 할 수 있어야합니다. o 다중 상태 응답 본문은 이제 새로운 'location'요소에서 HTTP의 Location 응답 헤더 값을 전송할 수 있습니다. 클라이언트는 이것을 사용하여 상태가 3xx 인 '응답'요소가있을 때 서버에 대한 추가 왕복을 피할 수 있습니다 (참조 &lt;a href=&quot;#section-14.24&quot;&gt;섹션 14.24&lt;/a&gt; ). o COPY의 정의가 완화되어 서버에서 더 이상 대상 자원을 더 이상 삭제하지 않아도됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 과의 알려진 비 호환성 임 ). &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; 참조 . 헤더 및 마샬링 o 대상 및 If 요청 헤더는 이제 전체 URI 외에 절대 경로를 허용합니다 ( &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ). 이는 WebDAV 특정 헤더가 아닌 호스트 요청 헤더를 다시 쓰는 리버스 프록시를 통해 작동하는 클라이언트에 유용 할 수 있습니다. o이 규격은 오류 마샬링 확장과 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]에 정의 된 &quot;전제 조건 / 후 조건&quot;용어를 채택 한다 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; 참조) ). 이와 관련하여 다중 상태 응답 본문 내에 &quot;오류&quot;XML 요소를 추가합니다 ( &lt;a href=&quot;#section-14.5&quot;&gt;14.5 절&lt;/a&gt; 참조 ). &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt; 에서 권장되는 형식과 다른 형식을 사용합니다 . o 이제 발신자와 수신자는 XML 메시지 본문에서 UTF-16 문자 인코딩을 지원해야합니다 ( &lt;a href=&quot;#section-19&quot;&gt;섹션 19&lt;/a&gt; 참조 ). o 서버는 여전히 지원하지 않는 클라이언트를 지원하도록 권장되지만 클라이언트는 이제 PROPFIND 요청에 대해 Depth 헤더를 보내야합니다. 잠금 o &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 의 &quot;LNR (lock-null resources)&quot;개념은 &quot;빈 자원 잠금&quot;이라는 간단한 접근 방식으로 대체되었습니다 ( &lt;a href=&quot;#section-7.3&quot;&gt;섹션 7.3&lt;/a&gt; 참조).). 클라이언트가 더 이상 사용할 수없는 잠금 널 자원의 일부 측면, 즉 잠금 콜렉션을 작성하는 기능 또는 PUT 또는 MKCOL 요청이 발행되지 않은 경우 UNLOCK시 사라진다는 사실이 있습니다. 서버는 여전히 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518에&lt;/a&gt; 따라 LNR을 구현할 수 있습니다. o 더 이상 암시적인 잠금 새로 고침이 없습니다. 잠금은 명시 적 요청시에만 새로 고쳐집니다 ( &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2 절&lt;/a&gt; 참조 ). o LOCK 요청에 제공된 DAV : owner 값이 죽은 속성과 마찬가지로 서버에 의해 보존되어야 함을 &lt;a href=&quot;#section-14.17&quot;&gt;명시&lt;/a&gt; 했습니다 ( 14.17 절 ). 또한 클라이언트가 잠금 루트를 발견 할 수 있는 DAV : lockroot 요소 ( &lt;a href=&quot;#section-14.12&quot;&gt;14.12 절&lt;/a&gt; )를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ea7b149981164a5bdbbf89dc8821115528f3f53c" translate="yes" xml:space="preserve">
          <source>Collections can contain large numbers of Resources.  A client such as
   a web spider or web browser might be overwhelmed if the response to a
   GET contained every Entry in a Collection -- in turn the server might
   also waste bandwidth and processing time on generating a response
   that cannot be handled.  For this reason, servers MAY respond to
   Collection GET requests with a Feed Document containing a partial
   list of the Collection's members, and a link to the next partial list
   feed, if it exists.  The first such partial list returned MUST
   contain the most recently edited member Resources and MUST have an
   atom:link with a &quot;next&quot; relation whose &quot;href&quot; value is the URI of the
   next partial list of the Collection.  This next partial list will
   contain the next most recently edited set of Member Resources (and an
   atom:link to the following partial list if it exists).

   In addition to the &quot;next&quot; relation, partial list feeds MAY contain
   link elements with &quot;rel&quot; attribute values of &quot;previous&quot;, &quot;first&quot;, and
   &quot;last&quot;, that can be used to navigate through the complete set of
   entries in the Collection.

   For instance, suppose a client is supplied the URI
   &quot;http://example.org/entries/go&quot; of a Collection of Member Entries,
   where the server as a matter of policy avoids generating Feed
   Documents containing more than 10 Entries.  The Atom Feed Document 

   for the Collection will then represent the first partial list of a
   set of 10 linked Feed Documents.  The &quot;first&quot; relation references the
   initial Feed Document in the set and the &quot;last&quot; relation references
   the final Feed Document in the set.  Within each document, the
   &quot;previous&quot; and &quot;next&quot; link relations reference the preceding and
   subsequent documents.

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/2&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;

   The &quot;previous&quot; and &quot;next&quot; link elements for the partial list feed
   located at &quot;http://example.org/entries/2&quot; would look like this:

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;previous&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/3&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;</source>
          <target state="translated">컬렉션에는 많은 리소스가 포함될 수 있습니다. GET에 대한 응답이 콜렉션의 모든 항목을 포함하는 경우 웹 스파이더 또는 웹 브라우저와 같은 클라이언트가 압도 될 수 있습니다. 따라서 서버는 처리 할 수없는 응답을 생성하는 데 대역폭 및 처리 시간이 낭비 될 수 있습니다. 이러한 이유로 서버는 컬렉션 구성원의 일부 목록이 포함 된 피드 문서와 다음 부분 목록 피드 (있는 경우)에 대한 링크를 사용하여 컬렉션 GET 요청에 응답 할 수 있습니다. 리턴 된 첫 번째 부분 목록은 가장 최근에 편집 된 구성원 자원을 포함해야하며 &quot;href&quot;값이 콜렉션의 다음 부분 목록의 URI 인 &quot;다음&quot;관계를 갖는 atom : link를 가져야합니다.이 다음 부분 목록에는 가장 최근에 편집 된 다음 구성원 자원 세트 (및 다음 부분 목록에 대한 atom : link)가 포함됩니다. &quot;다음&quot;관계에 추가하여 부분 목록 피드에는 &quot;rel&quot;속성 값이 &quot;previous&quot;, &quot;first&quot;및 &quot;last&quot;인 링크 요소가 포함될 수 있습니다.이 요소의 전체 항목 세트를 탐색하는 데 사용할 수 있습니다. 수집. 예를 들어, 클라이언트에 구성원 항목 콜렉션의 URI &quot;http://example.org/entries/go&quot;가 클라이언트에 제공되고 정책의 문제로 서버가 10 개 이상의 항목을 포함하는 피드 문서를 생성하지 못하게한다고 가정하십시오. 컬렉션에 대한 Atom 피드 문서는 10 개의 연결된 피드 문서 세트의 첫 번째 부분 목록을 나타냅니다. 첫번째&quot;관계는 세트의 초기 피드 문서를 참조하고 &quot;마지막&quot;관계는 세트의 최종 피드 문서를 참조합니다. 각 문서 내에서 &quot;이전&quot;및 &quot;다음&quot;링크 관계는 이전 및 이후 문서를 참조합니다. &amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot;href = &quot;http://example.org/entries/go&quot;/&amp;gt; &amp;lt;link rel = &quot;next &quot;href =&quot;http://example.org/entries/2 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;&quot;이전 &quot; &quot;http://example.org/entries/2&quot;에있는 부분 목록 피드의 &quot;다음&quot;링크 요소는 다음과 같습니다.&amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot;href = &quot;http://example.org/entries/go&quot;/&amp;gt; &amp;lt;link rel = &quot;이전 &quot;href =&quot;http://example.org/entries/go &quot;/&amp;gt; &amp;lt;link rel =&quot;next &quot;href =&quot;http://example.org/entries/3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href = &quot;http://example.org/entries/10&quot;/&amp;gt; &amp;lt;/ feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;</target>
        </trans-unit>
        <trans-unit id="19b77d56fd18f49783fa29dab7e6057a1e912b7b" translate="yes" xml:space="preserve">
          <source>Combating ClickJacking with X-Frame-Options - IEInternals</source>
          <target state="translated">ClickJacking과 X-Frame-Options의 결합-IEInternals</target>
        </trans-unit>
        <trans-unit id="4b4da2aaa941fd10619ebba8b1a33ab3b456b5cf" translate="yes" xml:space="preserve">
          <source>Combining Ranges (RFC 7233)</source>
          <target state="translated">결합 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="d9439543fdbba1e16aeffe917fc7d29f50cbcc79" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of the allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">허용 된 &lt;a href=&quot;../methods&quot;&gt;HTTP 요청 메소드&lt;/a&gt; 의 쉼표로 구분 된 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="5bb95ba15fb836d98586a3edad9ec1fd27077fa7" translate="yes" xml:space="preserve">
          <source>Comma-separated values (CSV)</source>
          <target state="translated">쉼표로 구분 된 값 (CSV)</target>
        </trans-unit>
        <trans-unit id="68546dfaabacefbed271a8286b33a08186cc138e" translate="yes" xml:space="preserve">
          <source>Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</source>
          <target state="translated">명령 행 : &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="4861e90f90a057c5903a2cf3d60626141d9b6010" translate="yes" xml:space="preserve">
          <source>Comments to &lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform에 대한&lt;/a&gt; 의견</target>
        </trans-unit>
        <trans-unit id="355f9fe714bdefce689d0719b3940842115ebbd1" translate="yes" xml:space="preserve">
          <source>Common browsers User Agent strings</source>
          <target state="translated">일반적인 브라우저 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="93c3c55fe8f9dff2940ed7383aee89cb47a05822" translate="yes" xml:space="preserve">
          <source>Common causes are a server that is down for maintenance or that is overloaded. This response should be used for temporary conditions and the &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; HTTP header should, if possible, contain the estimated time for the recovery of the service.</source>
          <target state="translated">일반적인 원인은 유지 관리를 위해 다운되었거나 과부하 된 서버입니다. 이 응답은 임시 조건에 사용해야하며 가능하면 &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; HTTP 헤더에는 가능한 경우 서비스 복구 예상 시간이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="38d604abe4effd051b577737efcac0be5dd312de" translate="yes" xml:space="preserve">
          <source>Common problems</source>
          <target state="translated">일반적인 문제</target>
        </trans-unit>
        <trans-unit id="e69ef1fa14a563c69b2071931128d46e80d8fcab" translate="yes" xml:space="preserve">
          <source>Common uses for this mechanism</source>
          <target state="translated">이 메커니즘의 일반적인 용도</target>
        </trans-unit>
        <trans-unit id="a3e3c123b281c1fc386d6962bf0c8c55f62330c3" translate="yes" xml:space="preserve">
          <source>Communicates one or more metrics and descriptions for the given request-response cycle.</source>
          <target state="translated">주어진 요청-응답주기에 대한 하나 이상의 메트릭 및 설명을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="36eba05ecfef326403242e9b2557dc4cf61823c3" translate="yes" xml:space="preserve">
          <source>Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</source>
          <target state="translated">인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더 필드</target>
        </trans-unit>
        <trans-unit id="bb4f07ea51666d42daa68586d151fd1eee7f250c" translate="yes" xml:space="preserve">
          <source>Comparing versions of the same resource is a bit tricky: depending on the context, there are two kinds of &lt;em&gt;equality checks&lt;/em&gt;:</source>
          <target state="translated">동일한 리소스의 버전을 비교하는 것은 약간 까다 롭습니다. 컨텍스트에 따라 두 가지 종류의 &lt;em&gt;동등성 검사가 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="187c3be8f0ded5cfb27cd980759930707dd51a48" translate="yes" xml:space="preserve">
          <source>Comparison to chunked &lt;code&gt;Transfer-Encoding&lt;/code&gt;</source>
          <target state="translated">청크 &lt;code&gt;Transfer-Encoding&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="2cb53559d09ec4706b50627aafe05c3f74ccaf5c" translate="yes" xml:space="preserve">
          <source>Compatibility Notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d648a6dff363974f754bb78876c2b10dadd8183" translate="yes" xml:space="preserve">
          <source>Compatibility notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079f93e4945f9092390a018ed062372bdcfd86bd" translate="yes" xml:space="preserve">
          <source>Complete list of MIME types</source>
          <target state="translated">MIME 유형의 전체 목록</target>
        </trans-unit>
        <trans-unit id="8a9facd0c43149e93efff61f4e5ddc45591658e4" translate="yes" xml:space="preserve">
          <source>Components of HTTP-based systems</source>
          <target state="translated">HTTP 기반 시스템의 구성 요소</target>
        </trans-unit>
        <trans-unit id="c3c91e1eed116d8885305f2a420a8509e0cc75cc" translate="yes" xml:space="preserve">
          <source>Comprehensive list of MIME types useful for Web developers.</source>
          <target state="translated">웹 개발자에게 유용한 종합적인 MIME 유형 목록.</target>
        </trans-unit>
        <trans-unit id="e99b96873911e57f5de9103e887195406f68cd32" translate="yes" xml:space="preserve">
          <source>Compressing HTTP messages is one of the most important ways to improve the performance of a Web site, it shrinks the size of the data transmitted and makes better use of the available bandwidth; browsers always send this header and the server should be configured to abide to it and to use compression.</source>
          <target state="translated">HTTP 메시지를 압축하는 것은 웹 사이트의 성능을 향상시키는 가장 중요한 방법 중 하나이며, 전송되는 데이터의 크기를 줄이고 사용 가능한 대역폭을 더 잘 활용합니다. 브라우저는 항상이 헤더를 보내고 서버는이를 준수하고 압축을 사용하도록 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b19ee5750a4f428fdbb3471286458f10f3749ac9" translate="yes" xml:space="preserve">
          <source>Compressing with gzip</source>
          <target state="translated">gzip으로 압축</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="26b0ce5a72c7b5ba41f70c30e64c6c6b62713bf9" translate="yes" xml:space="preserve">
          <source>Compression: compress and optimize content to speed up load time.</source>
          <target state="translated">압축 : 컨텐츠를 압축 및 최적화하여로드 시간을 단축합니다.</target>
        </trans-unit>
        <trans-unit id="afa306b4fc5fbd90b0a114f6bd08ca2cc8754f57" translate="yes" xml:space="preserve">
          <source>Concatenates the four dot-separated bytes into one 4-byte word and converts it to decimal.</source>
          <target state="translated">4 개의 도트로 구분 된 바이트를 하나의 4 바이트 워드로 연결하고 10 진수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b5c1cd3785db2824d1ab278c24866501932dedaf" translate="yes" xml:space="preserve">
          <source>Concepts and usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9a261b82a98b8bdc6d75dae90ec8ee01b54eeff4" translate="yes" xml:space="preserve">
          <source>Conditional headers</source>
          <target state="translated">조건부 헤더</target>
        </trans-unit>
        <trans-unit id="8bcd73be2170abf93875e1fa36640534488be6c5" translate="yes" xml:space="preserve">
          <source>Conditional range requests</source>
          <target state="translated">조건부 범위 요청</target>
        </trans-unit>
        <trans-unit id="32f3486df02697cc767cdf9f317b7c01b4f54138" translate="yes" xml:space="preserve">
          <source>Conditional requests</source>
          <target state="translated">조건부 요청</target>
        </trans-unit>
        <trans-unit id="b96d7430d9350e321fe2f05974da38d1376f5101" translate="yes" xml:space="preserve">
          <source>Conditional requests allow implementing the &lt;em&gt;optimistic locking algorithm&lt;/em&gt; (used by most wikis or source control systems). The concept is to allow all clients to get copies of the resource, then let them modify it locally, controlling concurrency by successfully allowing the first client submitting an update. All subsequent updates, based on the now obsolete version of the resource, are rejected:</source>
          <target state="translated">조건부 요청을 통해 &lt;em&gt;낙관적 잠금 알고리즘&lt;/em&gt; (대부분의 위키 또는 소스 제어 시스템에서 사용)을 구현할 수 있습니다. 개념은 모든 클라이언트가 자원의 사본을 확보 한 다음 로컬로 수정하여 첫 번째 클라이언트가 업데이트를 제출하도록 허용함으로써 동시성을 제어하도록하는 것입니다. 더 이상 사용되지 않는 리소스 버전을 기반으로하는 모든 후속 업데이트는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="bb657402b08e081af170034d16476c261b3e0bd6" translate="yes" xml:space="preserve">
          <source>Conditional requests are HTTP requests [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;] that include one or
   more header fields indicating a precondition to be tested before
   applying the method semantics to the target resource.  This document
   defines the HTTP/1.1 conditional request mechanisms in terms of the
   architecture, syntax notation, and conformance criteria defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  Conditionals can also be applied to
   state-changing methods, such as PUT and DELETE, to prevent the &quot;lost
   update&quot; problem: one client accidentally overwriting the work of
   another client that has been acting in parallel.

   Conditional request preconditions are based on the state of the
   target resource as a whole (its current value set) or the state as
   observed in a previously obtained representation (one value in that
   set).  A resource might have multiple current representations, each
   with its own observable state.  The conditional request mechanisms
   assume that the mapping of requests to a &quot;selected representation&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;) will be consistent over time if the server
   intends to take advantage of conditionals.  Regardless, if the
   mapping is inconsistent and the server is unable to select the
   appropriate representation, then no harm will result when the
   precondition evaluates to false.

   The conditional request preconditions defined by this specification
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) are evaluated when applicable to the recipient
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) according to their order of precedence (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).</source>
          <target state="translated">조건부 요청은 메소드 시맨틱을 대상 자원에 적용하기 전에 테스트 할 전제 조건을 나타내는 하나 이상의 헤더 필드를 포함하는 HTTP 요청 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]입니다. 이 문서는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처, 구문 표기법 및 적합성 기준으로 HTTP / 1.1 조건부 요청 메커니즘을 정의 합니다. 조건부 GET 요청은 HTTP 캐시 업데이트를위한 가장 효율적인 메커니즘입니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]. &quot;손실 된 업데이트&quot;문제를 방지하기 위해 PUT 및 DELETE와 같은 상태 변경 방법에도 조건을 적용 할 수 있습니다. 한 클라이언트가 실수로 병렬로 작업 한 다른 클라이언트의 작업을 덮어 씁니다. 조건부 요청 전제 조건은 대상 자원의 전체 상태 (현재 값 세트) 또는 이전에 얻은 표시 (해당 세트의 하나의 값)에서 관찰 된 상태를 기반으로합니다. 자원에는 각각 자체 관찰 가능한 상태를 가진 여러 개의 현재 표현이있을 수 있습니다. 조건부 요청 메커니즘은 요청을 &quot;선택된 표현&quot;에 매핑한다고 가정합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]의 섹션 3&lt;/a&gt;)는 서버가 조건을 활용하려는 경우 시간이 지남에 따라 일관됩니다. 그럼에도 불구하고 매핑이 일치하지 않고 서버가 적절한 표현을 선택할 수없는 경우 전제 조건이 거짓으로 평가 될 때 아무런 해가 발생하지 않습니다. 본 명세서 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; )에 의해 정의 된 조건부 요청 전제 조건 은 우선 순위 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 에 따라 수신자 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; )에 적용 가능한 경우 평가된다 .</target>
        </trans-unit>
        <trans-unit id="f8c4083d3ac1096a523190657f90870d3b790d6a" translate="yes" xml:space="preserve">
          <source>Conditional requests are a key feature of HTTP, and allow the building of efficient and complex applications. For caching or resuming downloads, the only work required for webmasters is to configure the server correctly; setting correct etags in some environments can be tricky. Once achieved, the browser will serve the expected conditional requests.</source>
          <target state="translated">조건부 요청은 HTTP의 핵심 기능이며 효율적이고 복잡한 애플리케이션을 빌드 할 수 있습니다. 다운로드 캐싱 또는 다시 시작의 경우 웹 마스터에게 필요한 유일한 작업은 서버를 올바르게 구성하는 것입니다. 일부 환경에서 올바른 etag를 설정하는 것은 까다로울 수 있습니다. 일단 달성되면 브라우저는 예상되는 조건부 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d6a56385d0729f6ff4bf27671cc845cb6f2cfde5" translate="yes" xml:space="preserve">
          <source>Conditionals</source>
          <target state="translated">Conditionals</target>
        </trans-unit>
        <trans-unit id="168256d8522ab8aa1e488cbca9a371a273b318a6" translate="yes" xml:space="preserve">
          <source>Confidential or sensitive information should never be stored or transmitted in HTTP Cookies, as the entire mechanism is inherently insecure.</source>
          <target state="translated">전체 메커니즘이 본질적으로 안전하지 않기 때문에 기밀 또는 민감한 정보는 HTTP 쿠키에 저장하거나 전송해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f09b9822b4fcc7ee7448f402f4626bb6d634c3" translate="yes" xml:space="preserve">
          <source>Configuring Apache</source>
          <target state="translated">아파치 설정</target>
        </trans-unit>
        <trans-unit id="5aa009cf30d646a189a2b32b2e2f211086ce4d68" translate="yes" xml:space="preserve">
          <source>Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to a web page and giving it values to control resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</source>
          <target state="translated">콘텐츠 보안 정책을 구성 하려면 웹 페이지에 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더를 추가하고 해당 페이지에 대해 사용자 에이전트가로드 할 수있는 리소스를 제어하는 ​​값을 제공해야합니다. 예를 들어 이미지를 업로드하고 표시하는 페이지는 어디에서나 이미지를 허용하지만 양식 작업을 특정 엔드 포인트로 제한 할 수 있습니다. 올바르게 설계된 콘텐츠 보안 정책은 사이트 간 스크립팅 공격으로부터 페이지를 보호합니다. 이 기사에서는 이러한 헤더를 올바르게 구성하는 방법을 설명하고 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f39d4583059888ab118eae8d20c986e51f1274e" translate="yes" xml:space="preserve">
          <source>Configuring HAProxy</source>
          <target state="translated">HAProxy 구성</target>
        </trans-unit>
        <trans-unit id="d70d5fc578cb203b115c05b384a205e2f62a043b" translate="yes" xml:space="preserve">
          <source>Configuring IIS</source>
          <target state="translated">IIS 구성</target>
        </trans-unit>
        <trans-unit id="2031ab4ee84e7e349fa32c5b2095aa6cafb6bd65" translate="yes" xml:space="preserve">
          <source>Configuring nginx</source>
          <target state="translated">nginx 구성</target>
        </trans-unit>
        <trans-unit id="532521e6c325d8d9c38dfb2c90ab768c58d19d39" translate="yes" xml:space="preserve">
          <source>Configuring prefetching in the browser</source>
          <target state="translated">브라우저에서 프리 페치 구성</target>
        </trans-unit>
        <trans-unit id="cfe2338ad9f0d231c9e7e937eb36ba083fe3da49" translate="yes" xml:space="preserve">
          <source>Configuring redirects in common servers</source>
          <target state="translated">공통 서버에서 리디렉션 구성</target>
        </trans-unit>
        <trans-unit id="82949d3ffebaebf9aadf54999c74e7c2fdc71165" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request. For example, you may get a 409 response when uploading a file which is older than the one already on the server resulting in a version control conflict.</source>
          <target state="translated">&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 요청 에 대한 응답으로 충돌이 발생할 가능성이 높습니다 . 예를 들어 서버에 이미있는 파일보다 오래된 파일을 업로드하면 버전 제어 충돌이 발생하여 409 응답이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="32e5f579d6704066fd06ba7fbc38b931e1dbb869" translate="yes" xml:space="preserve">
          <source>Connection (RFC 2616)</source>
          <target state="translated">연결 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="1f3fc181701dc7eaafa3f89e076f2b6541c863f2" translate="yes" xml:space="preserve">
          <source>Connection Management (RFC 7230)</source>
          <target state="translated">연결 관리 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="07f35038b27fc876a57591119e37327c7b80eb76" translate="yes" xml:space="preserve">
          <source>Connection management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e280c573f66ef8d6ccfd66829478dd956d810c" translate="yes" xml:space="preserve">
          <source>Connection management in HTTP 1.x</source>
          <target state="translated">HTTP 1.x의 연결 관리</target>
        </trans-unit>
        <trans-unit id="990f921e1f05ae3668d86bed8ec78ce685923ba2" translate="yes" xml:space="preserve">
          <source>Connection management in HTTP/1.x</source>
          <target state="translated">HTTP / 1.x의 연결 관리</target>
        </trans-unit>
        <trans-unit id="d26cd7de0355631b3af679ee8c4f387ae6c0345d" translate="yes" xml:space="preserve">
          <source>Connection management in HTTP/2</source>
          <target state="translated">HTTP / 2의 연결 관리</target>
        </trans-unit>
        <trans-unit id="eefea8ffbb95e9e96d5a01166af470e8ec510898" translate="yes" xml:space="preserve">
          <source>Connection management is a key topic in HTTP: opening and maintaining connections largely impacts the performance of Web sites and Web applications. In HTTP/1.x, there are several models: &lt;em&gt;short-lived connections&lt;/em&gt;, &lt;em&gt;persistent connections&lt;/em&gt;, and &lt;em&gt;HTTP pipelining. &lt;/em&gt;</source>
          <target state="translated">연결 관리는 HTTP의 핵심 주제입니다. 연결을 열고 유지 관리하면 웹 사이트 및 웹 응용 프로그램의 성능에 큰 영향을 미칩니다. HTTP / 1.x에는 &lt;em&gt;단기 연결&lt;/em&gt; , &lt;em&gt;영구 연결&lt;/em&gt; 및 &lt;em&gt;HTTP 파이프 라이닝&lt;/em&gt; 과 같은 몇 가지 모델이 있습니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a58d7aa5a546a742dab251e82c3cdd41f9f9f74" translate="yes" xml:space="preserve">
          <source>Connection-specific header fields such as &lt;code&gt;Connection&lt;/code&gt; must not be used with HTTP/2.</source>
          <target state="translated">Connection과 같은 &lt;code&gt;Connection&lt;/code&gt; 별 헤더 필드 는 HTTP / 2와 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="83b3d90f6ebaf8967f6fdf65affbfced1f355cf1" translate="yes" xml:space="preserve">
          <source>Connections (RFC 2616)</source>
          <target state="translated">연결 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="41f1b9f6cf26210329e4ae7de5efdbca18c92386" translate="yes" xml:space="preserve">
          <source>Connections can be closed at any time, with or without intention.
   Implementations ought to anticipate the need to recover from
   asynchronous close events. 

   When an inbound connection is closed prematurely, a client MAY open a
   new connection and automatically retransmit an aborted sequence of
   requests if all of those requests have idempotent methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;4.2.2 of [RFC7231]&lt;/a&gt;).  A proxy MUST NOT automatically retry
   non-idempotent requests.

   A user agent MUST NOT automatically retry a request with a non-
   idempotent method unless it has some means to know that the request
   semantics are actually idempotent, regardless of the method, or some
   means to detect that the original request was never applied.  For
   example, a user agent that knows (through design or configuration)
   that a POST request to a given resource is safe can repeat that
   request automatically.  Likewise, a user agent designed specifically
   to operate on a version control repository might be able to recover
   from partial failure conditions by checking the target resource
   revision(s) after a failed connection, reverting or fixing any
   changes that were partially applied, and then automatically retrying
   the requests that failed.

   A client SHOULD NOT automatically retry a failed automatic retry.</source>
          <target state="translated">의도적 유무에 관계없이 언제든지 연결을 닫을 수 있습니다. 구현시 비동기 클로즈 이벤트로부터 복구해야 할 필요성을 예상해야합니다. 인바운드 연결이 너무 일찍 닫히면 모든 요청에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;dem 등원 한&lt;/a&gt; 방법이있는 경우 클라이언트는 새 연결을 열고 중단 된 요청 시퀀스를 자동으로 재전송 할 수 있습니다 ( [RFC7231]의 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;섹션 &lt;/a&gt;4.2.2).). 프록시는 비등 전성 요청을 자동으로 재 시도해서는 안됩니다 (MUST NOT). 사용자 에이전트는 메소드와 상관없이 요청 시맨틱이 실제로 dem 등원임을 알 수있는 수단이 있거나 원래 요청이 적용되지 않았 음을 감지하는 수단이 아닌 한, 비등 전성이 아닌 메소드로 요청을 자동으로 재 시도해서는 안됩니다 (MUST NOT). 예를 들어, 주어진 리소스에 대한 POST 요청이 안전하다는 것을 (디자인 또는 구성을 통해) 알고있는 사용자 에이전트는 해당 요청을 자동으로 반복 할 수 있습니다. 마찬가지로, 버전 제어 저장소에서 작동하도록 특별히 설계된 사용자 에이전트는 연결에 실패한 후 대상 자원 개정을 확인하거나 부분적으로 적용된 변경 사항을 되돌 리거나 수정하여 부분 실패 조건에서 복구 할 수 있습니다.그런 다음 실패한 요청을 자동으로 다시 시도합니다. 클라이언트는 자동 재시도 실패를 자동으로 재 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="edd0d4a07d58840f12a945e2fbf5da173a233595" translate="yes" xml:space="preserve">
          <source>Connections should be made directly, without any proxies</source>
          <target state="translated">프록시없이 직접 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e2d5c68194fbc69ab147c44c40d78e1dcf5fbc9" translate="yes" xml:space="preserve">
          <source>Consider a collection &quot;/locked&quot; with an exclusive, depth-infinity
   write lock, and an attempt to delete an internal member &quot;/locked/
   member&quot;:

   &amp;gt;&amp;gt;Request

     DELETE /locked/member HTTP/1.1
     Host: example.com

   &amp;gt;&amp;gt;Response

     HTTP/1.1 423 Locked
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:error xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:lock-token-submitted&amp;gt;
         &amp;lt;D:href&amp;gt;/locked/&amp;lt;/D:href&amp;gt;
       &amp;lt;/D:lock-token-submitted&amp;gt;
     &amp;lt;/D:error&amp;gt;

   Thus, the client would need to submit the lock token with the request
   to make it succeed.  To do that, various forms of the If header (see
   &lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;) could be used.

   &quot;No-Tag-List&quot; format:

     If: (&amp;lt;urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;)

   &quot;Tagged-List&quot; format, for &quot;http://example.com/locked/&quot;:

     If: &amp;lt;http://example.com/locked/&amp;gt;
         (&amp;lt;urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;)

   &quot;Tagged-List&quot; format, for &quot;http://example.com/locked/member&quot;:

     If: &amp;lt;http://example.com/locked/member&amp;gt;
         (&amp;lt;urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;)

   Note that, for the purpose of submitting the lock token, the actual
   form doesn't matter; what's relevant is that the lock token appears
   in the If header, and that the If header itself evaluates to true.</source>
          <target state="translated">독점적 인 깊이 무한 쓰기 잠금을 사용하고 &quot;/ locked / member&quot;내부 구성원을 삭제하려는 &quot;/ locked&quot;모음을 고려하십시오. &amp;gt;&amp;gt; Request DELETE / locked / member HTTP / 1.1 Host : example.com &amp;gt;&amp;gt; 응답 HTTP / 1.1 423 잠긴 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;콘텐츠 길이 : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : error xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : lock-token-submitted &amp;gt; &amp;lt;D : href&amp;gt; / locked / &amp;lt;/ D : href&amp;gt; &amp;lt;/ D : lock-token-submitted&amp;gt; &amp;lt;/ D : error&amp;gt; 따라서 클라이언트는 잠금 토큰을 요청하여 잠금 토큰을 제출해야합니다. 이를 위해 다양한 형태의 If 헤더 ( &lt;a href=&quot;#section-10.4&quot;&gt;10.4 절&lt;/a&gt; 참조) ) 사용 될수있다. &quot;No-Tag-List&quot;형식 : If : (&amp;lt;urn : uuid : 150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;) &quot;http://example.com/locked/&quot;의 경우 &quot;Tagged-List&quot;형식 : : &amp;lt;http://example.com/locked/&amp;gt; (&amp;lt;urn : uuid : 150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;) &quot;http://example.com/locked/member에 대한&quot;Tagged-List &quot;형식 &quot;: If : &amp;lt;http://example.com/locked/member&amp;gt; (&amp;lt;urn : uuid : 150852e2-3847-42d5-8cbe-0f4f296f26cf&amp;gt;) 잠금 토큰을 제출할 때 실제 형식은 중요하지 않습니다. 잠금 토큰은 If 헤더에 나타나고 If 헤더 자체는 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="85f85970b05a5509092afce550578f210339e815" translate="yes" xml:space="preserve">
          <source>Consider a collection &quot;/specs&quot; that does not contain the member
   &quot;/specs/rfc2518.doc&quot;.  In this case, the If header

     If: &amp;lt;/specs/rfc2518.doc&amp;gt; ([&quot;4217&quot;]) 

   will evaluate to false (the URI isn't mapped, thus the resource
   identified by the URI doesn't have an entity matching the ETag
   &quot;4217&quot;).

   On the other hand, an If header of

     If: &amp;lt;/specs/rfc2518.doc&amp;gt; (Not [&quot;4217&quot;])

   will consequently evaluate to true.

   Note that, as defined above in &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;, the same
   considerations apply to matching state tokens.</source>
          <target state="translated">&quot;/specs/rfc2518.doc&quot;멤버를 포함하지 않는 &quot;/ specs&quot;콜렉션을 고려하십시오. 이 경우 If 헤더 If : &amp;lt;/specs/rfc2518.doc&amp;gt; ([ &quot;4217&quot;])는 false로 평가됩니다 (URI가 맵핑되지 않으므로 URI로 식별 된 자원에 일치하는 엔티티가 없음) ETag &quot;4217&quot;). 반면 If : &amp;lt;/specs/rfc2518.doc&amp;gt;의 If 헤더 ([[4217 &quot;] 아님)는 결과적으로 true로 평가됩니다. 위에서 &lt;a href=&quot;#section-10.4.4&quot;&gt;섹션 10.4.4&lt;/a&gt; 에서 정의한 바와 같이 , 일치하는 상태 토큰에도 동일한 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c23582c32438d3d52d4683ca327de9b64f0a5219" translate="yes" xml:space="preserve">
          <source>Consider a dead property 'author' created by the client as follows:

     &amp;lt;D:prop xml:lang=&quot;en&quot; xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;x:author xmlns:x='http://example.com/ns'&amp;gt;
         &amp;lt;x:name&amp;gt;Jane Doe&amp;lt;/x:name&amp;gt;
         &amp;lt;!-- Jane's contact info --&amp;gt;
         &amp;lt;x:uri type='email'
                added='2005-11-26'&amp;gt;mailto:jane.doe@example.com&amp;lt;/x:uri&amp;gt;
         &amp;lt;x:uri type='web'
                added='2005-11-27'&amp;gt;http://www.example.com&amp;lt;/x:uri&amp;gt;
         &amp;lt;x:notes xmlns:h='http://www.w3.org/1999/xhtml'&amp;gt;
           Jane has been working way &amp;lt;h:em&amp;gt;too&amp;lt;/h:em&amp;gt; long on the
           long-awaited revision of &amp;lt;![CDATA[&amp;lt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;&amp;gt;]]&amp;gt;.
         &amp;lt;/x:notes&amp;gt;
       &amp;lt;/x:author&amp;gt;
     &amp;lt;/D:prop&amp;gt; 

   When this property is requested, a server might return:

     &amp;lt;D:prop xmlns:D='DAV:'&amp;gt;&amp;lt;author
             xml:lang='en'
             xmlns:x='http://example.com/ns'
             xmlns='http://example.com/ns'
             xmlns:h='http://www.w3.org/1999/xhtml'&amp;gt;
         &amp;lt;x:name&amp;gt;Jane Doe&amp;lt;/x:name&amp;gt;
         &amp;lt;x:uri   added=&quot;2005-11-26&quot; type=&quot;email&quot;
           &amp;gt;mailto:jane.doe@example.com&amp;lt;/x:uri&amp;gt;
         &amp;lt;x:uri   added=&quot;2005-11-27&quot; type=&quot;web&quot;
           &amp;gt;http://www.example.com&amp;lt;/x:uri&amp;gt;
         &amp;lt;x:notes&amp;gt;
           Jane has been working way &amp;lt;h:em&amp;gt;too&amp;lt;/h:em&amp;gt; long on the
           long-awaited revision of &amp;amp;lt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;&amp;amp;gt;.
         &amp;lt;/x:notes&amp;gt;
       &amp;lt;/author&amp;gt;
     &amp;lt;/D:prop&amp;gt;

   Note in this example:

   o  The [&lt;a href=&quot;#ref-prefix&quot;&gt;prefix&lt;/a&gt;] for the property name itself was not preserved, being
      non-significant, whereas all other [&lt;a href=&quot;#ref-prefix&quot;&gt;prefix&lt;/a&gt;] values have been
      preserved,

   o  attribute values have been rewritten with double quotes instead of
      single quotes (quoting style is not significant), and attribute
      order has not been preserved,

   o  the xml:lang attribute has been returned on the property name
      element itself (it was in scope when the property was set, but the
      exact position in the response is not considered significant as
      long as it is in scope),

   o  whitespace between tags has been preserved everywhere (whitespace
      between attributes not so),

   o  CDATA encapsulation was replaced with character escaping (the
      reverse would also be legal),

   o  the comment item was stripped (as would have been a processing
      instruction item).

   Implementation note: there are cases such as editing scenarios where
   clients may require that XML content is preserved character by
   character (such as attribute ordering or quoting style).  In this
   case, clients should consider using a text-only property value by
   escaping all characters that have a special meaning in XML parsing.</source>
          <target state="translated">&amp;lt;D : prop xml : lang = &quot;en&quot;xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;x : author xmlns : x = 'http : //example.com 클라이언트가 생성 한 죽은 속성'작성자 '를 고려하십시오. / ns '&amp;gt; &amp;lt;x : name&amp;gt; Jane Doe &amp;lt;/ x : name&amp;gt; &amp;lt;!-Jane의 연락처 정보-&amp;gt; &amp;lt;x : uri type ='email 'added ='2005-11-26 '&amp;gt; mailto : jane. doe@example.com &amp;lt;/ x : uri&amp;gt; &amp;lt;x : uri type = 'web'added = '2005-11-27'&amp;gt; http://www.example.com &amp;lt;/ x : uri&amp;gt; &amp;lt;x : notes xmlns : h = 'http : //www.w3.org/1999/xhtml'&amp;gt; Jane은 오랫동안 기다려온 &amp;lt;! [CDATA [&amp;lt;의 개정판에서 &amp;lt;h : em&amp;gt; 너무 &amp;lt;/ h : em&amp;gt; 방식으로 작업 해 왔습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;&amp;gt;]]&amp;gt;. &amp;lt;/ x : notes&amp;gt; &amp;lt;/ x : author&amp;gt; &amp;lt;/ D : prop&amp;gt;이 특성이 요청되면 서버는 다음을 리턴 할 수 있습니다. &amp;lt;D : prop xmlns : D = 'DAV :'&amp;gt; &amp;lt;author xml : lang = 'en 'xmlns : x ='http : //example.com/ns 'xmlns ='http : //example.com/ns 'xmlns : h ='http : //www.w3.org/1999/xhtml '&amp;gt; &amp;lt; x : name&amp;gt; Jane Doe &amp;lt;/ x : name&amp;gt; &amp;lt;x : uri added = &quot;2005-11-26&quot;type = &quot;email&quot;&amp;gt; mailto : jane.doe@example.com &amp;lt;/ x : uri&amp;gt; &amp;lt;x : uri added = &quot;2005-11-27&quot;type = &quot;web&quot;&amp;gt; http://www.example.com &amp;lt;/ x : uri&amp;gt; &amp;lt;x : notes&amp;gt; Jane은 &amp;lt;h : em&amp;gt; 너무 &amp;lt;/ h : 오랫동안 기다려온 &amp;amp; lt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; &amp;amp; gt ;. &amp;lt;/ x : notes&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;/ D : prop&amp;gt;이 예의 참고 사항 : o [ &lt;a href=&quot;#ref-prefix&quot;&gt;접두사&lt;/a&gt;속성 이름 자체에 대한]는 중요하지 않은 반면 다른 모든 [ &lt;a href=&quot;#ref-prefix&quot;&gt;접두사&lt;/a&gt;] 값이 유지되고 o 속성 값이 작은 따옴표 대신 큰 따옴표로 다시 작성되고 (인용 스타일이 중요하지 않음) 속성 순서가 유지되지 않았습니다. o xml : lang 속성이 특성 이름 요소 자체에 리턴되었습니다 (속성이 설정되었을 때 범위 내에 있었지만 응답에있는 정확한 위치는 범위 내에있는 한 중요하지 않은 것으로 간주 됨) o 태그 사이의 공백이 모든 곳에서 보존되었습니다 (속성 사이의 공백은 그렇지 않음), CDATA 캡슐화 문자 이스케이프로 대체되었습니다 (반대도 가능함). o 주석 항목이 제거되었습니다 (처리 명령 항목처럼). 구현 노트 :클라이언트가 XML 컨텐츠를 문자별로 보존하도록 요구하는 편집 시나리오 (속성 순서 또는 인용 스타일 등)와 같은 경우가 있습니다. 이 경우 클라이언트는 XML 구문 분석에서 특별한 의미가있는 모든 문자를 이스케이프하여 텍스트 전용 특성 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="96c337f19c7a431435fa528ee91669cbeb85a727" translate="yes" xml:space="preserve">
          <source>Consider a resource that is subject to content negotiation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.4&quot;&gt;3.4 of [RFC7231]&lt;/a&gt;), and where the representations sent in response to
   a GET request vary based on the Accept-Encoding request header field
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.4&quot;&gt;Section&amp;nbsp;5.3.4 of [RFC7231]&lt;/a&gt;):

   &amp;gt;&amp;gt; Request:

     GET /index HTTP/1.1
     Host: www.example.com
     Accept-Encoding: gzip


   In this case, the response might or might not use the gzip content
   coding.  If it does not, the response might look like:

   &amp;gt;&amp;gt; Response:

     HTTP/1.1 200 OK
     Date: Fri, 26 Mar 2010 00:05:00 GMT
     ETag: &quot;123-a&quot;
     Content-Length: 70
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World!
     Hello World!
     Hello World!
     Hello World!
     Hello World! 

   An alternative representation that does use gzip content coding would
   be:

   &amp;gt;&amp;gt; Response:

     HTTP/1.1 200 OK
     Date: Fri, 26 Mar 2010 00:05:00 GMT
     ETag: &quot;123-b&quot;
     Content-Length: 43
     Vary: Accept-Encoding
     Content-Type: text/plain
     Content-Encoding: gzip

     ...binary data

      Note: Content codings are a property of the representation data,
      so a strong entity-tag for a content-encoded representation has to
      be distinct from the entity tag of an unencoded representation to
      prevent potential conflicts during cache updates and range
      requests.  In contrast, transfer codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7230]&lt;/a&gt;)
      apply only during message transfer and do not result in distinct
      entity-tags.</source>
          <target state="translated">콘텐츠 협상이 필요한 리소스 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.4&quot;&gt;[RFC7231]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.4&quot;&gt;섹션 &lt;/a&gt;3.4 )와 GET 요청에 대한 응답으로 전송 된 표현이 Accept-Encoding request 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.3.4&quot;&gt;[RFC7231]의 섹션 5.3.4)에 따라 다른 리소스를 고려하십시오.&lt;/a&gt;) : &amp;gt;&amp;gt; 요청 : GET / index HTTP / 1.1 호스트 : www.example.com Accept-Encoding : gzip이 경우 응답은 gzip 컨텐츠 코딩을 사용하거나 사용하지 않을 수 있습니다. 그렇지 않은 경우 응답은 다음과 같습니다. &amp;gt;&amp;gt; 응답 : HTTP / 1.1 200 OK 날짜 : 2010 년 3 월 26 일 금요일 00:05:00 GMT ETag : &quot;123-a&quot;콘텐츠 길이 : 70 다름 : 수락 인코딩 내용 유형 : text / plain Hello World! 안녕하세요 세계! 안녕하세요 세계! 안녕하세요 세계! 안녕하세요 세계! gzip 컨텐츠 코딩을 사용하는 대체 표현은 다음과 같습니다. &amp;gt;&amp;gt; 응답 : HTTP / 1.1 200 OK 날짜 : 2010 년 3 월 26 일 금요일 00:05:00 GMT ETag : &quot;123-b&quot;컨텐츠 길이 : 43 가변 : 수락- 컨텐츠 유형 인코딩 : 텍스트 / 일반 컨텐츠 인코딩 : gzip ...이진 데이터 참고 : 콘텐츠 코딩은 표현 데이터의 속성이므로 캐시 인코딩 및 범위 요청 중 잠재적 충돌을 방지하기 위해 콘텐츠 인코딩 된 표현에 대한 강력한 엔터티 태그는 인코딩되지 않은 표현의 엔터티 태그와 구별되어야합니다. 대조적으로, 전송 코딩 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4&quot;&gt;[RFC7230]의 섹션 4는&lt;/a&gt; 메시지 전송 중에 만 적용되며 별개의 엔티티 태그를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e43a23782a33a985e1bc3186720dae5d4153667" translate="yes" xml:space="preserve">
          <source>Consider the collection http://example.com/sample/ with the internal
   member URL http://example.com/sample/a%20test and the PROPFIND
   request below:

   &amp;gt;&amp;gt;Request:

     PROPFIND /sample/ HTTP/1.1
     Host: example.com
     Depth: 1 

   In this case, the server should return two 'href' elements containing
   either

   o  'http://example.com/sample/' and
      'http://example.com/sample/a%20test', or

   o  '/sample/' and '/sample/a%20test'

   Note that even though the server may be storing the member resource
   internally as 'a test', it has to be percent-encoded when used inside
   a URI reference (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;).  Also note that a
   legal URI may still contain characters that need to be escaped within
   XML character data, such as the ampersand character.</source>
          <target state="translated">내부 구성원 URL이 http://example.com/sample/a%20test 인 http://example.com/sample/ 모음과 아래의 PROPFIND 요청을 고려하십시오. &amp;gt;&amp;gt; Request : PROPFIND / sample / HTTP / 1.1 Host : example.com 깊이 : 1이 경우 서버는 o 'http://example.com/sample/'및 'http://example.com/sample/a%20test'를 포함하는 두 개의 'href'요소를 반환해야합니다. o 또는 '/ sample /'및 '/ sample / a % 20test'서버가 구성원 자원을 내부적으로 '테스트'로 저장하더라도 URI 참조 내부에서 사용될 때는 백분율로 인코딩되어야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986] 섹션 2.1&lt;/a&gt; 참조 ). 또한 유효한 URI에는 여전히 XML 문자 데이터 내에서 이스케이프해야하는 문자가 포함될 수 있습니다.앰퍼샌드 문자와 같은</target>
        </trans-unit>
        <trans-unit id="3ae234f9da44bbb747d248a8b0463849803c2ef9" translate="yes" xml:space="preserve">
          <source>Considerations before using browser detection</source>
          <target state="translated">브라우저 감지를 사용하기 전에 고려해야 할 사항</target>
        </trans-unit>
        <trans-unit id="cc04292338529e168650b1a683b9f7b5faa66b25" translate="yes" xml:space="preserve">
          <source>Considering that a resource could be anything, and that the uniform
   interface provided by HTTP is similar to a window through which one
   can observe and act upon such a thing only through the communication
   of messages to some independent actor on the other side, an
   abstraction is needed to represent (&quot;take the place of&quot;) the current
   or desired state of that thing in our communications.  That
   abstraction is called a representation [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].

   For the purposes of HTTP, a &quot;representation&quot; is information that is
   intended to reflect a past, current, or desired state of a given
   resource, in a format that can be readily communicated via the
   protocol, and that consists of a set of representation metadata and a
   potentially unbounded stream of representation data.

   An origin server might be provided with, or be capable of generating,
   multiple representations that are each intended to reflect the
   current state of a target resource.  In such cases, some algorithm is
   used by the origin server to select one of those representations as
   most applicable to a given request, usually based on content
   negotiation.  This &quot;selected representation&quot; is used to provide the 

   data and metadata for evaluating conditional requests [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] and
   constructing the payload for 200 (OK) and 304 (Not Modified)
   responses to GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;).</source>
          <target state="translated">자원이 무엇이든 될 수 있고 HTTP가 제공하는 균일 한 인터페이스는 다른 쪽의 독립적 인 행위자에게 메시지를 전달하는 것만으로 그러한 것을 관찰하고 행동 할 수있는 창과 유사하다는 것을 고려하면, 추상화는 우리의 의사 소통에서 그 물건의 현재 또는 원하는 상태를 표현 ( &quot;대체&quot;)해야했습니다. 이 추상화를 표현이라고합니다 [ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]. HTTP의 목적 상 &quot;표현&quot;은 주어진 자원의 과거, 현재 또는 원하는 상태를 프로토콜을 통해 쉽게 통신 할 수있는 형식으로 나타 내기위한 정보이며 일련의 표현으로 구성됩니다. 메타 데이터 및 잠재적으로 제한되지 않은 표현 데이터 스트림. 오리진 서버는 각각 목표 자원의 현재 상태를 반영하기위한 다중 표현을 제공하거나 생성 할 수있다. 그러한 경우에, 일부 알고리즘은 일반적으로 컨텐츠 협상에 기초하여 주어진 요청에 가장 적합한 표현 중 하나를 선택하기 위해 오리진 서버에 의해 사용된다. 이 &quot;선택된 표현&quot;조건부 요청을 평가하기위한 데이터 및 메타 데이터를 제공하는 데 사용됩니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] 및 GET에 대한 200 (OK) 및 304 (수정되지 않음) 응답에 대한 페이로드 구성 ( &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="503931284b8b68d6bc14e90b6c4905f14d5db9ea" translate="yes" xml:space="preserve">
          <source>Consultation of the Firefox HSTS preload list : &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/manager/ssl/nsSTSPreloadList.inc&quot;&gt;nsSTSPreloadList.inc&lt;/a&gt;</source>
          <target state="translated">Firefox HSTS 사전로드 목록의 상담 : &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/manager/ssl/nsSTSPreloadList.inc&quot;&gt;nsSTSPreloadList.inc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2a176a49cd00ac69dc42d62f9486553ed667d32" translate="yes" xml:space="preserve">
          <source>Contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent. See also the &lt;a href=&quot;headers/user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;.</source>
          <target state="translated">네트워크 프로토콜 피어가 요청하는 소프트웨어 사용자 에이전트의 응용 프로그램 유형, 운영 체제, 소프트웨어 공급 업체 또는 소프트웨어 버전을 식별 할 수 있도록하는 특성 문자열을 포함합니다. 또한 참조 &lt;a href=&quot;headers/user-agent/firefox&quot;&gt;파이어 폭스 사용자 에이전트 문자열 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678663d831db43602dfe9e9fe92a1082ef2ddcdc" translate="yes" xml:space="preserve">
          <source>Contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">요청하는 사용자 에이전트를 제어하는 ​​휴먼 사용자의 인터넷 이메일 주소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d0ec5fb0cc93b949db34830428879d6e35ebba4f" translate="yes" xml:space="preserve">
          <source>Contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">요청을 처리하기 위해 오리진 서버가 사용하는 소프트웨어에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9443e137eb11efd975a99e7a6baf4f8fefbd6e73" translate="yes" xml:space="preserve">
          <source>Contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">프록시가 요청 경로에 관여 할 때 변경되거나 유실 된 프록시 서버의 클라이언트 쪽 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a01817f2d5174ccee88e198d1a76e36a24cb4116" translate="yes" xml:space="preserve">
          <source>Contains stored &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 서버가 이전에 보낸 저장된 &lt;a href=&quot;cookies&quot;&gt;HTTP 쿠키를&lt;/a&gt; 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="b22154a749d666606c925ef3ace61124ddf37d2d" translate="yes" xml:space="preserve">
          <source>Contains the credentials to authenticate a user agent with a proxy server.</source>
          <target state="translated">프록시 서버로 사용자 에이전트를 인증하기위한 신임 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2d0dd1d4108f089ea071b064909e6365375782a7" translate="yes" xml:space="preserve">
          <source>Contains the credentials to authenticate a user agent with a server.</source>
          <target state="translated">서버로 사용자 에이전트를 인증하기위한 신임 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="646d3ac3228513e4b35e7031f18b79c0c606ba5e" translate="yes" xml:space="preserve">
          <source>Contains the date and time at which the message was originated.</source>
          <target state="translated">메시지가 시작된 날짜와 시간을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c972be02b8446556687c87408ab05f0b8d7ed048" translate="yes" xml:space="preserve">
          <source>Content Negotiation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9467b47a4c1c395a32212b34980c2b8e5ec9fc6f" translate="yes" xml:space="preserve">
          <source>Content Negotiation (RFC 2616)</source>
          <target state="translated">콘텐츠 협상 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="61b75e5aad879ad6ec045903a7957a2840d359e8" translate="yes" xml:space="preserve">
          <source>Content Security Policy 1.0</source>
          <target state="translated">콘텐츠 보안 정책 1.0</target>
        </trans-unit>
        <trans-unit id="744b2e4fde3764da03b4f91ab9ad14b2b88d3dc7" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2</source>
          <target state="translated">콘텐츠 보안 정책 수준 2</target>
        </trans-unit>
        <trans-unit id="de84b0734aa5b5664a072e3bd6ce77277f90ee70" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'base-uri' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'base-uri'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e77ecbcdd05d27677c66c634731a718f7490330e" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'child-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'child-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1efc9bfab09c9137a7131aba5b96d2a65e1bf9d0" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'connect-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'connect-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a215cd212f5c6119c03770dc2d37c4c3f8236c4d" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'default-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'default-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40adb1f918d1e9da2930bd08fad3585af0ae2635" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'font-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'font-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b01d7d0c778dcbb0abffa3e96f74a05b9d9b4eb4" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'form-action' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'form-action'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="64b51b5facd3c7edbc765fa2e61d4b85a228481f" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'frame-ancestors' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 '프레임 조상'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bc50334cda4bae9b1e65a11eb8433d6c0b6affc0" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'frame-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'frame-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6e2ac1f7840e12d8a297ae6f31c3efa1a0f9b5ce" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'img-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'img-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cc311776a76f26d73819991b7454d60674414c69" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'media-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'media-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a96d49b039c8e8aac7d2bcf96bfd8323ea11bb02" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'object-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'object-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3a40acbf8869a5bb62907e52fcf5475974b648c4" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'plugin-types' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 '플러그인 유형'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82763265d692d0689796691aa4161eb86d67d73d" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'report-uri' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'report-uri'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3f80e4089f6e2d795ed9d5eef35e8e6066044dbe" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'sandbox' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 '샌드 박스'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="337615e1189b16d5ec187c77654b4c744a3e74fa" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'script-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'script-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a40362260841fa8d99974c1e734d3db45744108" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 2&lt;br/&gt;&lt;small&gt;The definition of 'style-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 2 &lt;br/&gt;&lt;small&gt;해당 사양에서 'style-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4b466953d7f58f1aa6afa13c5b9a5609db6afa8" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3</source>
          <target state="translated">콘텐츠 보안 정책 수준 3</target>
        </trans-unit>
        <trans-unit id="f0f94b90206e031f041992df3858bc60077885f0" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'base-uri' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'base-uri'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="128279b22442e841128762c19782b182b67635ed" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'child-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'child-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bb5ad27411d401ecd3bbbd31196bf16a2f090bd0" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'connect-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'connect-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eaf68fe192431b63fa5f159e56cdf442e1c61336" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'default-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'default-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d762aa5435ccc61ea607f93ac01b69a3aa902b4d" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'font-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'font-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6087a9c2bd7e3ea78b14dc382a71fb4687205527" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'form-action' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 레벨 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'form-action'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4d79529f1b2623d864d16f2ea09e061cb356c85e" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'frame-ancestors' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 '프레임 조상'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1362e6550bea3c68cb3524922fc5bbb7eeff9d15" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'frame-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'frame-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7902a3f4f99ee4aea2b74436f194eeee64212da4" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'img-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'img-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="db5ce99864043556f235d705cc59c25c20615ba7" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'manifest-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'manifest-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ebcd4ffecb60694953c330e36cd11e280e26a482" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'media-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'media-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7fde3978274adeca0c06e89d861d9f72dfd0fddf" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'object-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'object-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8c32bbb6ed52e84afc0dfa1986157687a0397d84" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'plugin-types' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 '플러그인 유형'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5e75a9cfcc5a5bfcae11548966500c9209f6c138" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'report-uri' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'report-uri'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7a341685199c43bd76301876cdf4c8a2c9e2ca55" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'sandbox' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 '샌드 박스'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3dbc2dfda4d80c713e92eb350cf45d1d751211b4" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'script-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'script-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="11a7ad3d24df15f55a31284d1e4f6d851f50d4b3" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'style-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'style-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="361b4e13b04dfda2a7798ca7524fe7b547c718f8" translate="yes" xml:space="preserve">
          <source>Content Security Policy Level 3&lt;br/&gt;&lt;small&gt;The definition of 'worker-src' in that specification.&lt;/small&gt;</source>
          <target state="translated">콘텐츠 보안 정책 수준 3 &lt;br/&gt;&lt;small&gt;해당 사양에서 'worker-src'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c85a336fb359e2ed47630d1553708bd5584c771e" translate="yes" xml:space="preserve">
          <source>Content Security in WebExtensions</source>
          <target state="translated">WebExtensions의 컨텐츠 보안</target>
        </trans-unit>
        <trans-unit id="0e7c0c2f53cfff2204f61ed692c5ee482ca589fd" translate="yes" xml:space="preserve">
          <source>Content coding registrations MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Names of content codings MUST NOT overlap with names of transfer
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7230]&lt;/a&gt;), unless the encoding transformation
   is identical (as is the case for the compression codings defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).

   Values to be added to this namespace require IETF Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;4.1 of [RFC5226]&lt;/a&gt;) and MUST conform to the purpose of content coding
   defined in this section.</source>
          <target state="translated">콘텐츠 코딩 등록에는 반드시 다음 필드가 포함되어야합니다. o 이름 o 설명 o 사양 텍스트에 대한 포인터 콘텐츠 코딩의 이름은 인코딩 변환이 동일하지 않은 한 전송 코딩 이름 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4&quot;&gt;[RFC7230]의 섹션 4)과 겹치지 않아야합니다. &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]의 섹션 4.2에&lt;/a&gt; 정의 된 압축 코딩의 경우 ). 이 네임 스페이스에 추가되는 값은 IETF 검토 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;섹션 &lt;/a&gt;4.1 참조)가 필요 하며이 섹션에 정의 된 콘텐츠 코딩의 목적을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="17a8c2c57f9cec5c5f1fd4c38177f2f3dcf6c114" translate="yes" xml:space="preserve">
          <source>Content coding values indicate an encoding transformation that has
   been or can be applied to a representation.  Content codings are
   primarily used to allow a representation to be compressed or
   otherwise usefully transformed without losing the identity of its
   underlying media type and without loss of information.  Frequently,
   the representation is stored in coded form, transmitted directly, and
   only decoded by the final recipient.

     content-coding   = token

   All content-coding values are case-insensitive and ought to be
   registered within the &quot;HTTP Content Coding Registry&quot;, as defined in
   &lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;.  They are used in the Accept-Encoding (&lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;)
   and Content-Encoding (&lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt;) header fields. 

   The following content-coding values are defined by this
   specification:

      compress (and x-compress): See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7230]&lt;/a&gt;.

      deflate: See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7230]&lt;/a&gt;.

      gzip (and x-gzip): See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.3&quot;&gt;Section&amp;nbsp;4.2.3 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">컨텐츠 코딩 값은 표현에 적용되었거나 적용 할 수있는 인코딩 변환을 나타냅니다. 컨텐츠 코딩은 기본적으로 미디어 유형의 신원을 잃지 않고 정보를 잃지 않고 표현을 압축하거나 유용하게 변환 할 수 있도록하는 데 주로 사용됩니다. 종종, 표현은 코딩 된 형태로 저장되고, 직접 전송되고, 최종 수신자에 의해서만 디코딩된다. content-coding = token 모든 컨텐츠 코딩 값은 대소 문자를 구분하지 않으며 &lt;a href=&quot;#section-8.4&quot;&gt;섹션 8.4에&lt;/a&gt; 정의 된 &quot;HTTP 컨텐츠 코딩 레지스트리&quot;내에 등록되어야합니다 . 그것들은 Accept-Encoding ( &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; ) 및 Content-Encoding ( &lt;a href=&quot;#section-3.1.2.2&quot;&gt;섹션 3.1.2.2)에서 사용됩니다&lt;/a&gt;) 헤더 필드 다음과 같은 컨텐츠 코딩 값이이 스펙에 의해 정의됩니다. 압축 (및 x- 압축) : &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.1&quot;&gt;[RFC7230]의 4.2.1 절을&lt;/a&gt; 참조하십시오 . 수축 : &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.2&quot;&gt;[RFC7230]의 섹션 4.2.2를&lt;/a&gt; 참조하십시오 . gzip (및 x-gzip) : &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2.3&quot;&gt;[RFC7230]의 4.2.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c17efa818e7d90c017ba8ae7336014b6232bd1" translate="yes" xml:space="preserve">
          <source>Content coding values indicate an encoding transformation that has
   been or can be applied to an entity. Content codings are primarily
   used to allow a document to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the entity is stored in
   coded form, transmitted directly, and only decoded by the recipient.

       content-coding   = token

   All content-coding values are case-insensitive. HTTP/1.1 uses
   content-coding values in the Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;) and
   Content-Encoding (&lt;a href=&quot;#section-14.11&quot;&gt;section 14.11&lt;/a&gt;) header fields. Although the value
   describes the content-coding, what is more important is that it
   indicates what decoding mechanism will be required to remove the
   encoding.

   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   content-coding value tokens. Initially, the registry contains the
   following tokens:

   gzip An encoding format produced by the file compression program
        &quot;gzip&quot; (GNU zip) as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt; [&lt;a href=&quot;#ref-25&quot;&gt;25&lt;/a&gt;]. This format is a
        Lempel-Ziv coding (LZ77) with a 32 bit CRC.

   compress
        The encoding format produced by the common UNIX file compression
        program &quot;compress&quot;. This format is an adaptive Lempel-Ziv-Welch
        coding (LZW).

        Use of program names for the identification of encoding formats
        is not desirable and is discouraged for future encodings. Their
        use here is representative of historical practice, not good
        design. For compatibility with previous implementations of HTTP,
        applications SHOULD consider &quot;x-gzip&quot; and &quot;x-compress&quot; to be
        equivalent to &quot;gzip&quot; and &quot;compress&quot; respectively.

   deflate
        The &quot;zlib&quot; format defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; [&lt;a href=&quot;#ref-31&quot;&gt;31&lt;/a&gt;] in combination with
        the &quot;deflate&quot; compression mechanism described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; [&lt;a href=&quot;#ref-29&quot;&gt;29&lt;/a&gt;]. 

   identity
        The default (identity) encoding; the use of no transformation
        whatsoever. This content-coding is used only in the Accept-
        Encoding header, and SHOULD NOT be used in the Content-Encoding
        header.

   New content-coding value tokens SHOULD be registered; to allow
   interoperability between clients and servers, specifications of the
   content coding algorithms needed to implement a new value SHOULD be
   publicly available and adequate for independent implementation, and
   conform to the purpose of content coding defined in this section.</source>
          <target state="translated">콘텐츠 코딩 값은 엔터티에 적용되었거나 적용 할 수있는 인코딩 변환을 나타냅니다. 컨텐츠 코딩은 주로 기본 미디어 유형의 신원을 잃지 않고 정보를 잃지 않고 문서를 압축하거나 유용하게 변환하는 데 사용됩니다. 종종 엔터티는 코딩 된 형식으로 저장되고 직접 전송되며받는 사람 만 디코딩됩니다. content-coding = token 모든 내용 코딩 값은 대소 문자를 구분합니다. HTTP / 1.1은 Accept-Encoding ( &lt;a href=&quot;#section-14.3&quot;&gt;섹션 14.3&lt;/a&gt; ) 및 Content-Encoding ( &lt;a href=&quot;#section-14.11&quot;&gt;섹션 14.11&lt;/a&gt; ) 에서 컨텐츠 코딩 값을 사용합니다.) 헤더 필드 값이 콘텐츠 코딩을 설명하지만 더 중요한 것은 인코딩을 제거하는 데 필요한 디코딩 메커니즘을 나타내는 것입니다. IANA (Internet Assigned Numbers Authority)는 콘텐츠 코딩 가치 토큰의 레지스트리 역할을합니다. 처음에는 레지스트리에 다음 토큰이 포함되어 있습니다. gzip &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt; [ &lt;a href=&quot;#ref-25&quot;&gt;25에&lt;/a&gt; 설명 된 대로 파일 압축 프로그램 &quot;gzip&quot;(GNU zip)에 의해 생성 된 인코딩 형식]. 이 형식은 32 비트 CRC를 사용하는 Lempel-Ziv 코딩 (LZ77)입니다. compress 공통 UNIX 파일 압축 프로그램 &quot;compress&quot;에 의해 생성 된 인코딩 형식입니다. 이 형식은 LZW (Adaptive Lempel-Ziv-Welch coding)입니다. 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에는 사용하지 않는 것이 좋습니다. 여기에서의 사용은 좋은 디자인이 아니라 역사적인 실천을 대표합니다. 이전 HTTP 구현과의 호환성을 위해 응용 프로그램은 &quot;x-gzip&quot;및 &quot;x-compress&quot;를 각각 &quot;gzip&quot;및 &quot;compress&quot;와 동일하게 고려해야합니다. deflate &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950에&lt;/a&gt; 정의 된 &quot;zlib&quot;형식 [ &lt;a href=&quot;#ref-31&quot;&gt;31&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; [ &lt;a href=&quot;#ref-29&quot;&gt;29&lt;/a&gt; ]에 설명 된 &quot;deflate&quot;압축 메커니즘과 함께 사용 됩니다. identity 기본 (ID) 인코딩입니다. 어떤 변환도 사용하지 않습니다. 이 컨텐츠 코딩은 Accept-Encoding 헤더에서만 사용되며 Content-Encoding 헤더에서는 사용해서는 안됩니다. 새로운 콘텐츠 코딩 가치 토큰을 등록해야한다. 클라이언트와 서버 간의 상호 운용성을 위해 새로운 가치를 구현하는 데 필요한 콘텐츠 코딩 알고리즘의 사양을 공개적으로 사용할 수 있고 독립적 인 구현에 적합해야하며이 섹션에 정의 된 콘텐츠 코딩의 목적을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9a5b02fc5865df6d33b3a0dd8b7b5896602250e" translate="yes" xml:space="preserve">
          <source>Content negotiation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad9e2aa6a776962d54ea0e8266b877ba9808464" translate="yes" xml:space="preserve">
          <source>Content negotiation, including language, encoding, or type, has been introduced, and allows a client and a server to agree on the most adequate content to exchange.</source>
          <target state="translated">언어, 인코딩 또는 유형을 포함한 컨텐츠 협상이 도입되었으며 클라이언트와 서버가 교환하기에 가장 적합한 컨텐츠에 동의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c43819e89750da40b3f249f2a7274028712e51" translate="yes" xml:space="preserve">
          <source>Content negotiation: List of default Accept values</source>
          <target state="translated">내용 협상 : 기본 수락 값 목록</target>
        </trans-unit>
        <trans-unit id="ac9e385e174bfc0fb44fb0f9f1c81c6953fc87a3" translate="yes" xml:space="preserve">
          <source>Content-Disposition</source>
          <target state="translated">Content-Disposition</target>
        </trans-unit>
        <trans-unit id="dc573a47aca875aaa79618871337d7f6c56fa72f" translate="yes" xml:space="preserve">
          <source>Content-Encoding</source>
          <target state="translated">Content-Encoding</target>
        </trans-unit>
        <trans-unit id="d576f32a1637c27920e0aa99b9861b41ea961a2e" translate="yes" xml:space="preserve">
          <source>Content-Encoding (RFC 2616)</source>
          <target state="translated">콘텐츠 인코딩 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="91fd1dfed8364f154a419bb30f47511380d2a0e0" translate="yes" xml:space="preserve">
          <source>Content-Language</source>
          <target state="translated">Content-Language</target>
        </trans-unit>
        <trans-unit id="4616d0365c21d5eec516f5dcd1d027ee04a73143" translate="yes" xml:space="preserve">
          <source>Content-Language (RFC 2616)</source>
          <target state="translated">내용 언어 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="6ba83d8699910039b5b5f1d3bd60b1f43b1c39fa" translate="yes" xml:space="preserve">
          <source>Content-Length</source>
          <target state="translated">Content-Length</target>
        </trans-unit>
        <trans-unit id="6dd6315aed8ec185fa633f204e88a630ad7c1803" translate="yes" xml:space="preserve">
          <source>Content-Length (RFC 2616)</source>
          <target state="translated">콘텐츠 길이 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="be591269e96263fe450ef74421a96c4ad9175eb9" translate="yes" xml:space="preserve">
          <source>Content-Location</source>
          <target state="translated">Content-Location</target>
        </trans-unit>
        <trans-unit id="5e6cb580b31308b4f7473920450456de573bddd2" translate="yes" xml:space="preserve">
          <source>Content-Location (RFC 2616)</source>
          <target state="translated">콘텐츠 위치 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="f7779c8ff02503885588d1fc2857bfaa26cbb5a4" translate="yes" xml:space="preserve">
          <source>Content-MD5 (RFC 2616)</source>
          <target state="translated">Content-MD5 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d8a137c21303d5cdfaf674a6d77269e2b8a33d34" translate="yes" xml:space="preserve">
          <source>Content-Range</source>
          <target state="translated">Content-Range</target>
        </trans-unit>
        <trans-unit id="1efb03f0a3f829cd647788ed88395c1cbb17eecb" translate="yes" xml:space="preserve">
          <source>Content-Range (RFC 2616)</source>
          <target state="translated">컨텐츠 범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9ba9bd7d16f41138d6ef1ee2472e03fa95d898cc" translate="yes" xml:space="preserve">
          <source>Content-Range (RFC 7233)</source>
          <target state="translated">컨텐츠 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f0428e68d9eaf42516ac76fd67879cedb4dc7527" translate="yes" xml:space="preserve">
          <source>Content-Security-Policy</source>
          <target state="translated">Content-Security-Policy</target>
        </trans-unit>
        <trans-unit id="5f1be90e8e76ec51dcb3eb171966e90922c07042" translate="yes" xml:space="preserve">
          <source>Content-Security-Policy-Report-Only</source>
          <target state="translated">Content-Security-Policy-Report-Only</target>
        </trans-unit>
        <trans-unit id="77d12b97ba61ffccb079e0dd2ef6809c1e957255" translate="yes" xml:space="preserve">
          <source>Content-Type</source>
          <target state="translated">Content-Type</target>
        </trans-unit>
        <trans-unit id="d0851aff9fbb6357b097a2a4659c5d0a87fd411c" translate="yes" xml:space="preserve">
          <source>Content-Type (RFC 2616)</source>
          <target state="translated">콘텐츠 유형 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">Contributing</target>
        </trans-unit>
        <trans-unit id="64523d58f5f4352d5b29f271f23a0e87568fd23d" translate="yes" xml:space="preserve">
          <source>Controlling caching</source>
          <target state="translated">캐싱 제어</target>
        </trans-unit>
        <trans-unit id="798bd40b182b5dd7f82bea36f550de4033c8cf8c" translate="yes" xml:space="preserve">
          <source>Controlling the XSS Filter &amp;ndash; Microsoft</source>
          <target state="translated">XSS 필터 제어 &amp;ndash; Microsoft</target>
        </trans-unit>
        <trans-unit id="bee75ca77f753e4846b455441733f6641c4bf287" translate="yes" xml:space="preserve">
          <source>Controls</source>
          <target state="translated">Controls</target>
        </trans-unit>
        <trans-unit id="16b2ba7a8e06814dd8879d419d6bd4a2bf445be1" translate="yes" xml:space="preserve">
          <source>Controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">이미지, CSS, JavaScript 등을 포함하여 문서에서 참조하는 항목의 URL뿐만 아니라 사용자가 따라갈 수있는 두 링크 모두에서 브라우저가 도메인 이름 확인을 사전에 수행하는 기능인 DNS 프리 페치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6b77d88288fa4eaf881c8daf4ca0b484b388e304" translate="yes" xml:space="preserve">
          <source>Controls are request header fields that direct specific handling of
   the request.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Cache-Control     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt; |
   | Expect            | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;            |
   | Host              | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.4&quot;&gt;Section&amp;nbsp;5.4 of [RFC7230]&lt;/a&gt; |
   | Max-Forwards      | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;            |
   | Pragma            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.4&quot;&gt;Section&amp;nbsp;5.4 of [RFC7234]&lt;/a&gt; |
   | Range             | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7233]&lt;/a&gt; |
   | TE                | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7230]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">제어는 요청의 특정 처리를 지시하는 요청 헤더 필드입니다. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | 캐시 제어 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234] 섹션 5.2&lt;/a&gt; | | 기대 | &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; | | 호스트 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.4&quot;&gt;[RFC7230]의 섹션 5.4&lt;/a&gt; | | 맥스 포워드 | &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; | | 프라 그마 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.4&quot;&gt;[RFC7234]의 섹션 5.4&lt;/a&gt; | | 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.1&quot;&gt;[RFC7233] 섹션 3.1&lt;/a&gt; | | TE | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.3&quot;&gt;[RFC7230] 4.3 절&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="9d06120fe46a8c6ac20b8de7e14b6d44333371d9" translate="yes" xml:space="preserve">
          <source>Controls how long a persistent connection should stay open.</source>
          <target state="translated">지속적 연결이 열려 있어야하는 시간을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0cc6dc0f076d68850b51c1e2a31ab3a36167fd05" translate="yes" xml:space="preserve">
          <source>Controls resources the user agent is allowed to load for a given page.</source>
          <target state="translated">주어진 페이지에 대해 사용자 에이전트가로드 할 수있는 자원을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="df3f38a7c5429ea4c2ee3ff6d144a4d13ce4d280" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The autoplay attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 요청 된 미디어를 자동 재생하도록 허용할지 여부를 제어합니다 . 이 정책이 활성화되어 있고 사용자 제스처가 없으면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 으로 거부됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 자동 재생 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="748e7d094a079d99b0802a42160d70909daba7be" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">현재 문서를 설정하도록 허용할지 여부를 제어합니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; 을&lt;/a&gt; . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; 설정 시도 가 실패하고 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d9202005c3fefb7070dc1aada747763c58586ef" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 문서에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5a16fce94be173408927f96a4f686a21d250565" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">현재 문서에서 오디오 입력 장치를 사용할 수 있는지 여부를 조정합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c92efbe775efd4caa0ee38521482152734ab90cb" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">현재 문서가 EME ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API) 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="701785c55f133c899083afb053d95de0933dda9a" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; 인터페이스 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 을 호출하면 해당 함수의 콜백이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; 코드 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="752d091b5728fa4e90146dcd0afbbef74aa2ea04" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;지불 요청 API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; 생성자가 &lt;code&gt;SecurityError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9b27ce47572c5040012ca8991495c5806658d1e6" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae9d9c6793eb58eccf5ef121d0c49fbd7c8a639" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">현재 문서에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea6ab0ebb775b4c68719f38fb0405118793f8dbe" translate="yes" xml:space="preserve">
          <source>Controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">현재 문서에서 비디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53d72dbdfe89f740578ebd46d1f8f6b24c1d1af3" translate="yes" xml:space="preserve">
          <source>Controls whether the network connection stays open after the current transaction finishes.</source>
          <target state="translated">현재 트랜잭션이 완료된 후 네트워크 연결이 열린 상태로 유지되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e4f81994fed009c24d31efd799e2d47a74a60f1f" translate="yes" xml:space="preserve">
          <source>Cookie</source>
          <target state="translated">Cookie</target>
        </trans-unit>
        <trans-unit id="855f1aeb408d41040efd6bbe7a5a5c78896102b3" translate="yes" xml:space="preserve">
          <source>Cookie Prefixes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46e4672dad67b91c720df5978c33bbcda250091" translate="yes" xml:space="preserve">
          <source>Cookie Prefixes, Same-Site Cookies, and Strict Secure Cookies</source>
          <target state="translated">쿠키 접두사, 동일 사이트 쿠키 및 엄격한 보안 쿠키</target>
        </trans-unit>
        <trans-unit id="5226227dfaff67e00d2cefffad8b01e5623c9199" translate="yes" xml:space="preserve">
          <source>Cookie prefixes</source>
          <target state="translated">쿠키 접두사</target>
        </trans-unit>
        <trans-unit id="25b73f03a198c808fd48e167f5e51ed71bf152aa" translate="yes" xml:space="preserve">
          <source>Cookie specification: RFC 6265</source>
          <target state="translated">쿠키 사양 : RFC 6265</target>
        </trans-unit>
        <trans-unit id="c69edf6707c7791d5cad0815a8e3ec1ade501e5e" translate="yes" xml:space="preserve">
          <source>Cookie2</source>
          <target state="translated">Cookie2</target>
        </trans-unit>
        <trans-unit id="524cf50b5df5f29161c0600989922de48abede70" translate="yes" xml:space="preserve">
          <source>Cookies</source>
          <target state="translated">Cookies</target>
        </trans-unit>
        <trans-unit id="91726d4662df032620c2a9c6bee269a6ec9cd611" translate="yes" xml:space="preserve">
          <source>Cookies are mainly used for three purposes:</source>
          <target state="translated">쿠키는 주로 세 가지 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0be35828dda62eab3ec5d2bb08a6078f2394c4ca" translate="yes" xml:space="preserve">
          <source>Cookies are often used in web application to identify a user and their authenticated session, so stealing a cookie can lead to hijacking the authenticated user's session. Common ways to steal cookies include Social Engineering or exploiting an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; vulnerability in the application.</source>
          <target state="translated">쿠키는 종종 웹 응용 프로그램에서 사용자와 인증 된 세션을 식별하는 데 사용되므로 쿠키를 훔치면 인증 된 사용자의 세션을 가로 챌 수 있습니다. 쿠키를 훔치는 일반적인 방법에는 사회 공학 또는 응용 프로그램 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; 취약점 악용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4a309c1073db6339a4d7df640e5378d16ed49f" translate="yes" xml:space="preserve">
          <source>Cookies have a domain associated to them. If this domain is the same as the domain of the page you are on, the cookies is said to be a &lt;em&gt;first-party cookie&lt;/em&gt;. If the domain is different, it is said to be a &lt;em&gt;third-party cookie&lt;/em&gt;. While first-party cookies are sent only to the server setting them, a web page may contain images or other components stored on servers in other domains (like ad banners). Cookies that are sent through these third-party components are called third-party cookies and are mainly used for advertising and tracking across the web. See for example the &lt;a href=&quot;https://www.google.com/policies/technologies/types/&quot;&gt;types of cookies used by Google&lt;/a&gt;. Most browsers allow third-party cookies by default, but there are add-ons available to block them (for example, &lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/privacy-badger-firefox/&quot;&gt;Privacy Badger&lt;/a&gt; by the &lt;a href=&quot;https://www.eff.org/&quot;&gt;EFF&lt;/a&gt;).</source>
          <target state="translated">쿠키에는 도메인이 연결되어 있습니다. 이 도메인이 현재 페이지의 도메인과 동일한 경우 쿠키는 &lt;em&gt;자사 쿠키라고&lt;/em&gt; 합니다. 도메인이 다른 경우 &lt;em&gt;타사 쿠키라고&lt;/em&gt; 합니다. 자사 쿠키는 쿠키를 설정하는 서버로만 전송되지만 웹 페이지에는 이미지 나 다른 도메인 (예 : 광고 배너)의 서버에 저장된 다른 구성 요소가 포함될 수 있습니다. 이러한 타사 구성 요소를 통해 전송되는 쿠키를 타사 쿠키라고하며 주로 웹을 통한 광고 및 추적에 사용됩니다. 예를 들어 &lt;a href=&quot;https://www.google.com/policies/technologies/types/&quot;&gt;Google에서 사용하는 쿠키 유형을&lt;/a&gt; 참조하십시오 . 대부분의 브라우저는 기본적으로 타사 쿠키를 허용하지만 추가 기능을 차단하는 데 사용할 수 (예를 들어, 거기에 &lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/privacy-badger-firefox/&quot;&gt;개인 정보 보호 오소리는&lt;/a&gt; 에 의해&lt;a href=&quot;https://www.eff.org/&quot;&gt;EFF&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c69278be125dc5efc1b72b11d16c28693744e9b5" translate="yes" xml:space="preserve">
          <source>Cookies names with the prefixes &lt;code&gt;__Secure-&lt;/code&gt; and &lt;code&gt;__Host-&lt;/code&gt; can be used only if they are set with the &lt;code&gt;secure&lt;/code&gt; directive from a secure (HTTPS) origin. In addition, cookies with the &lt;code&gt;__Host-&lt;/code&gt; prefix must have a path of &quot;/&quot; (the entire host) and must not have a domain attribute. For clients that don't implement cookie prefixes, you cannot count on having these additional assurances and the cookies will always be accepted.</source>
          <target state="translated">접두사가 &lt;code&gt;__Secure-&lt;/code&gt; 및 &lt;code&gt;__Host-&lt;/code&gt; 인 쿠키 이름 은 보안 (HTTPS) 원본 의 &lt;code&gt;secure&lt;/code&gt; 지시문으로 설정 한 경우에만 사용할 수 있습니다 . 또한 &lt;code&gt;__Host-&lt;/code&gt; 접두사가있는 쿠키 는 &quot;/&quot;(전체 호스트) 경로를 가져야하며 도메인 속성이 없어야합니다. 쿠키 접두사를 구현하지 않는 클라이언트의 경우 이러한 추가 보증을 기대할 수 없으며 쿠키는 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4b213146883434308b211be44163c0d5123aa7" translate="yes" xml:space="preserve">
          <source>Cookies that are used for sensitive actions should have a short lifetime only.</source>
          <target state="translated">민감한 작업에 사용되는 쿠키는 수명이 짧아야합니다.</target>
        </trans-unit>
        <trans-unit id="94a68f999d90e10d874702ce7449ad09e886cc58" translate="yes" xml:space="preserve">
          <source>Cookies were once used for general client-side storage. While this was legitimate when they were the only way to store data on the client, it is recommended nowadays to prefer modern storage APIs. Cookies are sent with every request, so they can worsen performance (especially for mobile data connections). Modern APIs for client storage are the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;Web storage API&lt;/a&gt; (&lt;code&gt;localStorage&lt;/code&gt; and &lt;code&gt;sessionStorage&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt;.</source>
          <target state="translated">쿠키는 한 번 일반적인 클라이언트 측 스토리지에 사용되었습니다. 이것이 클라이언트에 데이터를 저장하는 유일한 방법 일 때는 합법적 인 것이었지만 현재는 최신 스토리지 API를 선호하는 것이 좋습니다. 쿠키는 모든 요청과 함께 전송되므로 성능이 저하 될 수 있습니다 (특히 모바일 데이터 연결의 경우). 클라이언트 스토리지를위한 최신 API는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;웹 스토리지 API&lt;/a&gt; ( &lt;code&gt;localStorage&lt;/code&gt; 및 &lt;code&gt;sessionStorage&lt;/code&gt; ) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d30283e462307cf7cf0e834f8cb357fdc77708b" translate="yes" xml:space="preserve">
          <source>Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   &quot;AS IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Fielding, et al.            Standards Track                   [Page 176]</source>
          <target state="translated">저작권 (C) 인터넷 학회 (1999). 판권 소유. 이 문서와이 문서의 번역본은 다른 사람에게 복사 및 제공 될 수 있으며, 그에 대해 설명하거나 다른 방식으로 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포 될 수 있습니다. 단, 위의 저작권 표시 및이 단락이 모든 해당 사본 및 파생 저작물에 포함되어있는 경우. 그러나이 문서 자체는 인터넷 표준을 개발할 목적으로 필요한 경우를 제외하고는 인터넷 공지 또는 인터넷 협회 또는 기타 인터넷 조직에 대한 저작권 표시 또는 참조를 제거하는 등의 방법으로 수정 될 수 없습니다. 인터넷 표준 프로세스를 따라야합니다.또는 영어 이외의 언어로 번역하는 데 필요합니다. 위에 부여 된 제한된 권한은 영구적이며 인터넷 학회 나 그 후임자 또는 양도인에 의해 취소되지 않습니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며 인터넷 사회와 인터넷 엔지니어링 작업은 강제적이거나 묵시적인 모든 보증을 부인하지만 여기에 포함 된 정보의 사용에 대한 어떠한 보증에도 제한되지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 모든 권리 또는 묵시적 보증을 침해합니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]위에 부여 된 제한된 권한은 영구적이며 인터넷 학회 나 그 후임자 또는 양도인에 의해 취소되지 않습니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며 인터넷 사회와 인터넷 엔지니어링 작업은 강제적이거나 묵시적인 모든 보증을 부인하지만 여기에 포함 된 정보의 사용에 대한 어떠한 보증에도 제한되지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 모든 권리 또는 묵시적 보증을 침해합니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]위에 부여 된 제한된 권한은 영구적이며 인터넷 학회 나 그 후임자 또는 양도인에 의해 취소되지 않습니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며 인터넷 사회와 인터넷 엔지니어링 작업은 강제적이거나 묵시적인 모든 보증을 부인하지만 여기에 포함 된 정보의 사용에 대한 어떠한 보증에도 제한되지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 모든 권리 또는 묵시적 보증을 침해합니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며 인터넷 사회와 인터넷 엔지니어링 작업은 강제적이거나 묵시적인 모든 보증을 부인하지만 여기에 포함 된 정보의 사용에 대한 어떠한 보증에도 제한되지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 모든 권리 또는 묵시적 보증을 침해합니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며 인터넷 사회와 인터넷 엔지니어링 작업은 강제적이거나 묵시적인 모든 보증을 부인하지만 여기에 포함 된 정보의 사용에 대한 어떠한 보증에도 제한되지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 모든 권리 또는 묵시적 보증을 침해합니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]그러나 여기에 포함 된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 어떠한 권리 나 묵시적 보증도 침해하지 않는다는 어떠한 보증도 포함하지 않습니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]그러나 여기에 포함 된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 어떠한 권리 나 묵시적 보증도 침해하지 않는다는 어떠한 보증도 포함하지 않습니다. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Fielding, et al. 표준 트랙 [페이지 176]</target>
        </trans-unit>
        <trans-unit id="ceea4db1706574d34f4d5faeb7d3f3edb1935c88" translate="yes" xml:space="preserve">
          <source>Crawler and bot UA strings</source>
          <target state="translated">크롤러 및 봇 UA 문자열</target>
        </trans-unit>
        <trans-unit id="e86062bc58f269be1dbc0f328e7c90ff13b9e907" translate="yes" xml:space="preserve">
          <source>Creates a conditional range request that is only fulfilled if the given etag or date matches the remote resource. Used to prevent downloading two ranges from incompatible version of the resource.</source>
          <target state="translated">지정된 태그 또는 날짜가 원격 리소스와 일치하는 경우에만 충족되는 조건부 범위 요청을 만듭니다. 호환되지 않는 버전의 리소스에서 두 범위를 다운로드하지 못하게하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76eb9f2d57de8bd2b8c062b8223a88e83fb499fa" translate="yes" xml:space="preserve">
          <source>Creating cookies</source>
          <target state="translated">쿠키 생성</target>
        </trans-unit>
        <trans-unit id="9df7b9c4955c3b374d3da07a58b10444962289d8" translate="yes" xml:space="preserve">
          <source>Credentialed requests</source>
          <target state="translated">자격 증명 요청</target>
        </trans-unit>
        <trans-unit id="8f2c6abb6553670b6ef790150334c72849c2d10f" translate="yes" xml:space="preserve">
          <source>Credentialed requests and wildcards</source>
          <target state="translated">자격 증명 요청 및 와일드 카드</target>
        </trans-unit>
        <trans-unit id="dbab18ad35d9f0a9db06382222fe5ee8bacb518e" translate="yes" xml:space="preserve">
          <source>Credentials are cookies, authorization headers or TLS client certificates.</source>
          <target state="translated">자격 증명은 쿠키, 권한 부여 헤더 또는 TLS 클라이언트 인증서입니다.</target>
        </trans-unit>
        <trans-unit id="5ea3f9a457f64dcc44f448b6b5de50c2d9273cb5" translate="yes" xml:space="preserve">
          <source>Cross-Origin Read Blocking (CORB)</source>
          <target state="translated">Cross-Origin Read Blocking (CORB)</target>
        </trans-unit>
        <trans-unit id="c1b9a88f9edb34ac8c57459a8c292f1807950214" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing</source>
          <target state="translated">원본 간 리소스 공유</target>
        </trans-unit>
        <trans-unit id="e8f6982752260490391736749366d8f03f7cc06a" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;) is a mechanism that uses additional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a &lt;strong&gt;cross-origin HTTP request&lt;/strong&gt; when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; (Cross-Origin Resource Sharing )는 추가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; 헤더를 사용 하여 한 출처 (도메인)에서 실행중인 웹 응용 프로그램이 다른 출처의 서버에서 선택한 리소스에 액세스 할 수 있도록 브라우저에 지시 하는 메커니즘입니다 . 웹 응용 프로그램은 고유 한 출처와 다른 출처 (도메인, 프로토콜 및 포트)를 가진 리소스를 &lt;strong&gt;요청할&lt;/strong&gt; 때 &lt;strong&gt;원본 간 HTTP 요청&lt;/strong&gt; 을합니다.</target>
        </trans-unit>
        <trans-unit id="18fc2f97599c6123f77e230a7df453afa9545e6c" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">CORS (Cross-Origin Resource Sharing)</target>
        </trans-unit>
        <trans-unit id="b49e7291e12824614e74d4daefc78b28f509ce7d" translate="yes" xml:space="preserve">
          <source>Cross-Origin Resource Sharing From a Server-Side Perspective (PHP, etc.)</source>
          <target state="translated">서버 측 관점 (PHP 등)에서 교차 출처 자원 공유</target>
        </trans-unit>
        <trans-unit id="35658dac4ac5e56d5f36e49f34856d93c2523dde" translate="yes" xml:space="preserve">
          <source>Cross-site request forgery (CSRF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039084e72450bd4fe9b884cd413d798482a45b58" translate="yes" xml:space="preserve">
          <source>Custom design is a good thing, in moderation. Feel free to make your 404 page humorous and human, but don't confuse your users.</source>
          <target state="translated">맞춤 디자인은 적당합니다. 404 페이지를 유머러스하고 인간적으로 만들 수 있지만 사용자를 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9e21be22a3254b4156b2e56b573050add0cefc03" translate="yes" xml:space="preserve">
          <source>Custom error pages</source>
          <target state="translated">맞춤 오류 페이지</target>
        </trans-unit>
        <trans-unit id="3930132543dcc21e58398598affcb6d10f1fdded" translate="yes" xml:space="preserve">
          <source>Custom proprietary headers can be added using the 'X-' prefix, but this convention was deprecated in June 2012, because of the inconveniences it caused when non-standard fields became standard in &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt;; others are listed in an &lt;a href=&quot;http://www.iana.org/assignments/message-headers/perm-headers.html&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;http://www.iana.org/assignments/message-headers/prov-headers.html&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">'X-'접두사를 사용하여 사용자 지정 전용 헤더를 추가 할 수 있지만이 규칙은 2012 년 6 월에 &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt; 에서 비표준 필드가 표준이되었을 때 불편을 끼쳐서 더 이상 사용되지 않습니다 . 다른 것들은 &lt;a href=&quot;http://www.iana.org/assignments/message-headers/perm-headers.html&quot;&gt;IANA 레지스트리에&lt;/a&gt; 나열되어 있으며 , 그의 원래 컨텐츠는 &lt;a href=&quot;http://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt; 에 정의되어 있습니다. IANA는 또한 &lt;a href=&quot;http://www.iana.org/assignments/message-headers/prov-headers.html&quot;&gt;제안 된 새로운 HTTP 메시지 헤더&lt;/a&gt; 의 레지스트리를 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="64df6f40d36dc3579a69d70da5a5421dddd930c9" translate="yes" xml:space="preserve">
          <source>D.1.  Guidance for Clients Using LOCK to Create Resources</source>
          <target state="translated">D.1. LOCK을 사용하여 리소스를 생성하는 클라이언트에 대한 지침</target>
        </trans-unit>
        <trans-unit id="ba6a0553575985fd50f55f28ad9e49527c369965" translate="yes" xml:space="preserve">
          <source>DAV              = &quot;DAV&quot; &quot;:&quot; #( compliance-class )
    compliance-class = ( &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | extend )
    extend           = Coded-URL | token
                       ; token is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;RFC 2616, Section&amp;nbsp;2.2&lt;/a&gt;
    Coded-URL        = &quot;&amp;lt;&quot; absolute-URI &quot;&amp;gt;&quot;
                       ; No linear whitespace (LWS) allowed in Coded-URL
                       ; absolute-URI defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;RFC 3986, Section&amp;nbsp;4.3&lt;/a&gt; 

   This general-header appearing in the response indicates that the
   resource supports the DAV schema and protocol as specified.  All DAV-
   compliant resources MUST return the DAV header with compliance-class
   &quot;1&quot; on all OPTIONS responses.  In cases where WebDAV is only
   supported in part of the server namespace, an OPTIONS request to non-
   WebDAV resources (including &quot;/&quot;) SHOULD NOT advertise WebDAV support.

   The value is a comma-separated list of all compliance class
   identifiers that the resource supports.  Class identifiers may be
   Coded-URLs or tokens (as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).  Identifiers can
   appear in any order.  Identifiers that are standardized through the
   IETF RFC process are tokens, but other identifiers SHOULD be Coded-
   URLs to encourage uniqueness.

   A resource must show class 1 compliance if it shows class 2 or 3
   compliance.  In general, support for one compliance class does not
   entail support for any other, and in particular, support for
   compliance class 3 does not require support for compliance class 2.
   Please refer to &lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt; for more details on compliance classes
   defined in this specification.

   Note that many WebDAV servers do not advertise WebDAV support in
   response to &quot;OPTIONS *&quot;.

   As a request header, this header allows the client to advertise
   compliance with named features when the server needs that
   information.  Clients SHOULD NOT send this header unless a standards
   track specification requires it.  Any extension that makes use of
   this as a request header will need to carefully consider caching
   implications.</source>
          <target state="translated">DAV = &quot;DAV&quot; &quot;:&quot;# (Compliance-class) Compliance-class = ( &quot;1&quot;| &quot;2&quot;| &quot;3&quot;| extend) extend = 코딩 된 URL | 토큰; 토큰은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;RFC 2616, 섹션 2.2&lt;/a&gt; Coded-URL = &quot;&amp;lt;&quot;absolute-URI &quot;&amp;gt;&quot;에 정의되어 있습니다. 코딩 된 URL에는 선형 공백 (LWS)이 허용되지 않습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;RFC 3986, 섹션 4.3에&lt;/a&gt; 정의 된 절대 URI 응답에 나타나는이 일반 헤더는 리소스가 지정된대로 DAV 스키마 및 프로토콜을 지원함을 나타냅니다. 모든 DAV 호환 리소스는 모든 OPTIONS 응답에서 준수 클래스가 &quot;1&quot;인 DAV 헤더를 반환해야합니다. WebDAV가 서버 네임 스페이스의 일부에서만 지원되는 경우 WebDAV 이외의 리소스 ( &quot;/&quot;포함)에 대한 OPTIONS 요청은 WebDAV 지원을 광고해서는 안됩니다. 값은 자원이 지원하는 모든 준수 클래스 식별자의 쉼표로 구분 된 목록입니다. 클래스 식별자는 코딩 된 URL 또는 토큰 일 수 있습니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]). 식별자는 어떤 순서로도 나타날 수 있습니다. IETF RFC 프로세스를 통해 표준화 된 식별자는 토큰이지만 다른 식별자는 고유성을 장려하기 위해 코딩 된 URL이어야한다. 리소스가 클래스 2 또는 3 준수를 표시하는 경우 클래스 1 준수를 표시해야합니다. 일반적으로 한 규정 준수 클래스에 대한 지원에는 다른 규정에 대한 지원이 필요하지 않으며, 특히 규정 준수 클래스 3에 대한 지원에는 규정 준수 클래스 2에 대한 지원이 필요하지 않습니다. &lt;a href=&quot;#section-18&quot;&gt;섹션 18을&lt;/a&gt; 참조하십시오.이 사양에 정의 된 준수 클래스에 대한 자세한 내용은 많은 WebDAV 서버는 &quot;OPTIONS *&quot;에 대한 응답으로 WebDAV 지원을 알리지 않습니다. 요청 헤더로서이 헤더를 사용하면 서버에서 해당 정보가 필요할 때 클라이언트가 명명 된 기능의 준수를 알릴 수 있습니다. 표준 트랙 사양에서 요구하지 않는 한 클라이언트는이 헤더를 보내지 않아야합니다. 이를 요청 헤더로 사용하는 확장은 캐싱 관련 사항을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="71d0df144e49808ea5b30cff2e0cfbdfbdfed7a6" translate="yes" xml:space="preserve">
          <source>DELETE (RFC 7231)</source>
          <target state="translated">삭제 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4b0fc5d87b0f45142f270cb1776553749e02e284" translate="yes" xml:space="preserve">
          <source>DELETE /specs/rfc2518.txt HTTP/1.1
     Host: www.example.com
     If: &amp;lt;http://www.example.com/specs/&amp;gt;
       (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)

   For this example, the lock token must be compared to the identified
   resource, which is the 'specs' collection identified by the URL in
   the tagged list production.  If the 'specs' collection is not locked
   by a lock with the specified lock token, the request MUST fail.
   Otherwise, this request could succeed, because the If header
   evaluates to true, and because the lock token for the lock affecting
   the affected resource has been submitted.</source>
          <target state="translated">삭제 /specs/rfc2518.txt HTTP / 1.1 호스트 : www.example.com If : &amp;lt;http://www.example.com/specs/&amp;gt; (&amp;lt;urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;) 이 예에서 잠금 토큰은 식별 된 자원 (태그 된 목록 프로덕션의 URL로 식별되는 'specs'콜렉션)과 비교되어야합니다. 지정된 잠금 토큰을 가진 잠금에 의해 'specs'컬렉션이 잠기지 않으면 요청은 실패해야한다. 그렇지 않으면 If 헤더가 true로 평가되고 영향을받는 자원에 영향을 미치는 잠금에 대한 잠금 토큰이 제출 되었기 때문에이 요청이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f4e42170be0b73687189267ec6aa44fd7fb50dc" translate="yes" xml:space="preserve">
          <source>DELETE is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.7&quot;&gt;[RFC2616], Section&amp;nbsp;9.7&lt;/a&gt;, to &quot;delete the resource
   identified by the Request-URI&quot;.  However, WebDAV changes some DELETE
   handling requirements.

   A server processing a successful DELETE request:

      MUST destroy locks rooted on the deleted resource

      MUST remove the mapping from the Request-URI to any resource.

   Thus, after a successful DELETE operation (and in the absence of
   other actions), a subsequent GET/HEAD/PROPFIND request to the target
   Request-URI MUST return 404 (Not Found).</source>
          <target state="translated">DELETE는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.7&quot;&gt;[RFC2616] 9.7 절에&lt;/a&gt; 정의되어 있으며 &quot;Request-URI로 식별 된 자원을 삭제합니다&quot;. 그러나 WebDAV는 일부 DELETE 처리 요구 사항을 변경합니다. 성공적인 DELETE 요청을 처리하는 서버 : 삭제 된 리소스에 기반한 잠금을 제거해야합니다. 요청 URI에서 리소스로의 매핑을 제거해야합니다. 따라서 DELETE 작업이 성공적으로 수행 된 후 (및 다른 작업이없는 경우) 대상 Request-URI에 대한 후속 GET / HEAD / PROPFIND 요청은 404 (찾을 수 없음)를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="622a6565387c8a9193ab691a610d7533ff392068" translate="yes" xml:space="preserve">
          <source>DIRECT</source>
          <target state="translated">DIRECT</target>
        </trans-unit>
        <trans-unit id="87ede6aa90d5a4c2897ed65eb85b7f66b5b9e4aa" translate="yes" xml:space="preserve">
          <source>DNS Prefetching for Firefox (blog post)</source>
          <target state="translated">Firefox 용 DNS 프리 페치 (블로그 게시물)</target>
        </trans-unit>
        <trans-unit id="5e9a4d54a21c7a39b39b93fd274052b6eea40ba3" translate="yes" xml:space="preserve">
          <source>DNS requests are very small in terms of bandwidth, but latency can be quite high, especially on mobile networks. By speculatively prefetching DNS results, latency can be reduced significantly at certain times, such as when the user clicks the link. In some cases, latency can be reduced by a second.</source>
          <target state="translated">DNS 요청은 대역폭 측면에서 매우 작지만 대기 시간은 특히 모바일 네트워크에서 상당히 높을 수 있습니다. DNS 결과를 추측 적으로 프리 페치하면 사용자가 링크를 클릭 할 때와 같이 특정 시간에 대기 시간이 크게 줄어들 수 있습니다. 경우에 따라 대기 시간이 1 초 단축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a9eac6a1f6b760dd9330fe9781a84bd533acde" translate="yes" xml:space="preserve">
          <source>DNT</source>
          <target state="translated">DNT</target>
        </trans-unit>
        <trans-unit id="b4851340e5f371052dedce4854148247d2d7059f" translate="yes" xml:space="preserve">
          <source>DNT browser settings help:</source>
          <target state="translated">DNT 브라우저 설정 도움말 :</target>
        </trans-unit>
        <trans-unit id="0fb0149117b0787ecd3bdc916006d4cb72a58458" translate="yes" xml:space="preserve">
          <source>DNT header</source>
          <target state="translated">DNT 헤더</target>
        </trans-unit>
        <trans-unit id="6d02a8a39932fc753e1f327a5d18be785a02a400" translate="yes" xml:space="preserve">
          <source>Data URIs</source>
          <target state="translated">데이터 URI</target>
        </trans-unit>
        <trans-unit id="cad3591ce326cc06b7118a498640ac09b0acbc3b" translate="yes" xml:space="preserve">
          <source>Data URLs are composed of four parts: a prefix (&lt;code&gt;data:&lt;/code&gt;), a MIME type indicating the type of data, an optional &lt;code&gt;base64&lt;/code&gt; token if non-textual, and the data itself:</source>
          <target state="translated">데이터 URL은 접두사 ( &lt;code&gt;data:&lt;/code&gt; :), 데이터 유형을 나타내는 MIME 유형, 텍스트가 아닌 경우 선택적인 &lt;code&gt;base64&lt;/code&gt; 토큰 및 데이터 자체 의 네 부분으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd580fd32a456f469a180a09b2377cb1a21d03a6" translate="yes" xml:space="preserve">
          <source>Data is sent in a series of chunks. The &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header is omitted in this case and at the beginning of each chunk you need to add the length of the current chunk in hexadecimal format, followed by '&lt;code&gt;\r\n&lt;/code&gt;' and then the chunk itself, followed by another '&lt;code&gt;\r\n&lt;/code&gt;'. The terminating chunk is a regular chunk, with the exception that its length is zero. It is followed by the trailer, which consists of a (possibly empty) sequence of entity header fields.</source>
          <target state="translated">데이터는 일련의 청크로 전송됩니다. 이 경우 &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더가 생략되고 각 청크의 시작 부분에 현재 청크의 길이를 16 진 형식으로 추가 한 다음 ' &lt;code&gt;\r\n&lt;/code&gt; ', 청크 자체, 다른 ' &lt;code&gt;\r\n&lt;/code&gt; '. 종료 청크는 길이가 0 인 경우를 제외하고 일반 청크입니다. 그 뒤에 트레일러가 오며, 이것은 트레일러의 엔티티 헤더 필드 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="fb6ad00eeb633a9b18034eebfa372bab17fad22d" translate="yes" xml:space="preserve">
          <source>Date (RFC 2616)</source>
          <target state="translated">날짜 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d1a419cf773491778e745bd51f870ec2d08c0233" translate="yes" xml:space="preserve">
          <source>Dealing with scheduled downtime</source>
          <target state="translated">예정된 가동 중지 시간 처리</target>
        </trans-unit>
        <trans-unit id="b5f5d7ac8c0029928dbf3672e84d1b9dee1eca44" translate="yes" xml:space="preserve">
          <source>Dealing with the first upload of a resource</source>
          <target state="translated">자원의 첫 번째 업로드 처리</target>
        </trans-unit>
        <trans-unit id="730b3581cc47dac8cfc7d93febfe61d28b27d4f0" translate="yes" xml:space="preserve">
          <source>Deciding the case</source>
          <target state="translated">사건 결정</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="ab39d71630263cb06de73047fe986abf13013e75" translate="yes" xml:space="preserve">
          <source>Defines &lt;code&gt;connect-src&lt;/code&gt;, &lt;code&gt;default-src&lt;/code&gt;, &lt;code&gt;font-src&lt;/code&gt;, &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;img-src&lt;/code&gt;, &lt;code&gt;media-src&lt;/code&gt;, &lt;code&gt;object-src&lt;/code&gt;, report-uri, &lt;code&gt;sandbox&lt;/code&gt;, &lt;code&gt;script-src,&lt;/code&gt; and &lt;code&gt;style-src&lt;/code&gt;.</source>
          <target state="translated">정의는 &lt;code&gt;connect-src&lt;/code&gt; , &lt;code&gt;default-src&lt;/code&gt; , &lt;code&gt;font-src&lt;/code&gt; , &lt;code&gt;frame-src&lt;/code&gt; , &lt;code&gt;img-src&lt;/code&gt; , &lt;code&gt;media-src&lt;/code&gt; , &lt;code&gt;object-src&lt;/code&gt; , 보고서-URI, &lt;code&gt;sandbox&lt;/code&gt; , &lt;code&gt;script-src,&lt;/code&gt; 및 &lt;code&gt;style-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eacb52986e3e740e8c70b75c3e7482999a612bff" translate="yes" xml:space="preserve">
          <source>Defines the &lt;code&gt;fullscreen&lt;/code&gt; policy.</source>
          <target state="translated">&lt;code&gt;fullscreen&lt;/code&gt; 정책을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="34b169a4830ca101a24b3e67607bce56b1c91720" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource behind a Proxy server.</source>
          <target state="translated">프록시 서버 뒤의 리소스에 액세스하기 위해 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6543a340c8cdd818ac73a63a94d4fd7de57aba8d" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">자원에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f8dcc75b63979f2db11f899a91470adab4ff1cb6" translate="yes" xml:space="preserve">
          <source>Defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여로드 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 중첩 된 브라우징 컨텍스트 의 유효한 소스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b64b866be84f841a370d95030a45025c6a3e04e9" translate="yes" xml:space="preserve">
          <source>Denial-of-service attacks are of special concern to WebDAV servers.
   WebDAV plus HTTP enables denial-of-service attacks on every part of a
   system's resources.

   o  The underlying storage can be attacked by PUTting extremely large
      files.

   o  Asking for recursive operations on large collections can attack
      processing time.

   o  Making multiple pipelined requests on multiple connections can
      attack network connections.

   WebDAV servers need to be aware of the possibility of a denial-of-
   service attack at all levels.  The proper response to such an attack
   MAY be to simply drop the connection.  Or, if the server is able to
   make a response, the server MAY use a 400-level status request such
   as 400 (Bad Request) and indicate why the request was refused (a 500-
   level status response would indicate that the problem is with the
   server, whereas unintentional DoS attacks are something the client is
   capable of remedying).</source>
          <target state="translated">WebDAV 서버에는 서비스 거부 공격이 특히 중요합니다. WebDAV plus HTTP는 시스템 리소스의 모든 부분에 대한 서비스 거부 공격을 가능하게합니다. o 매우 큰 파일을 PUTting하여 기본 스토리지를 공격 할 수 있습니다. o 대규모 컬렉션에서 재귀 작업을 요청하면 처리 시간이 단축 될 수 있습니다. o 여러 연결에서 여러 파이프 라인 요청을하면 네트워크 연결을 공격 할 수 있습니다. WebDAV 서버는 모든 수준에서 서비스 거부 공격의 가능성을 알고 있어야합니다. 이러한 공격에 대한 적절한 대응은 단순히 연결을 끊는 것일 수 있습니다. 또는 서버가 응답 할 수있는 경우서버는 400 (잘못된 요청)과 같은 400 수준 상태 요청을 사용하고 요청이 거부 된 이유를 나타낼 수 있습니다 (500 수준 상태 응답은 서버에 문제가 있음을 나타내는 반면, 의도하지 않은 DoS 공격은 클라이언트가하는 것임) 치료할 수 있음).</target>
        </trans-unit>
        <trans-unit id="89de95bda785091ad4670c2c51c5dd042349d3eb" translate="yes" xml:space="preserve">
          <source>Deprecate modification of 'secure' cookies from non-secure origins</source>
          <target state="translated">비보안 출처의 '보안'쿠키 수정 사용 중단</target>
        </trans-unit>
        <trans-unit id="efb41926689d64456523d9abd88a8e204ff7906a" translate="yes" xml:space="preserve">
          <source>Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; 를 추천하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f0c7b98ab40a4d967b59248a69752d5ae464d4" translate="yes" xml:space="preserve">
          <source>Depth = &quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)

   The Depth request header is used with methods executed on resources
   that could potentially have internal members to indicate whether the
   method is to be applied only to the resource (&quot;Depth: 0&quot;), to the
   resource and its internal members only (&quot;Depth: 1&quot;), or the resource
   and all its members (&quot;Depth: infinity&quot;).

   The Depth header is only supported if a method's definition
   explicitly provides for such support.

   The following rules are the default behavior for any method that
   supports the Depth header.  A method may override these defaults by
   defining different behavior in its definition. 

   Methods that support the Depth header may choose not to support all
   of the header's values and may define, on a case-by-case basis, the
   behavior of the method if a Depth header is not present.  For
   example, the MOVE method only supports &quot;Depth: infinity&quot;, and if a
   Depth header is not present, it will act as if a &quot;Depth: infinity&quot;
   header had been applied.

   Clients MUST NOT rely upon methods executing on members of their
   hierarchies in any particular order or on the execution being atomic
   unless the particular method explicitly provides such guarantees.

   Upon execution, a method with a Depth header will perform as much of
   its assigned task as possible and then return a response specifying
   what it was able to accomplish and what it failed to do.

   So, for example, an attempt to COPY a hierarchy may result in some of
   the members being copied and some not.

   By default, the Depth header does not interact with other headers.
   That is, each header on a request with a Depth header MUST be applied
   only to the Request-URI if it applies to any resource, unless
   specific Depth behavior is defined for that header.

   If a source or destination resource within the scope of the Depth
   header is locked in such a way as to prevent the successful execution
   of the method, then the lock token for that resource MUST be
   submitted with the request in the If request header.

   The Depth header only specifies the behavior of the method with
   regards to internal members.  If a resource does not have internal
   members, then the Depth header MUST be ignored.</source>
          <target state="translated">Depth = &quot;Depth&quot; &quot;:&quot;( &quot;0&quot;| &quot;1&quot;| &quot;infinity&quot;) Depth 요청 헤더는 내부 멤버가있을 수있는 자원에서 실행 된 메소드와 함께 사용되어 메소드가 해당 애플리케이션에만 적용되는지 여부를 표시합니다. 자원 ( &quot;Depth : 0&quot;), 자원 및 내부 구성원 만 ( &quot;Depth : 1&quot;) 또는 자원 및 모든 구성원 ( &quot;Depth : 무한대&quot;). 깊이 헤더는 메소드의 정의가 그러한 지원을 명시 적으로 제공하는 경우에만 지원됩니다. 다음 규칙은 깊이 헤더를 지원하는 모든 메서드의 기본 동작입니다. 메소드는 정의에서 다른 동작을 정의하여 이러한 기본값을 대체 할 수 있습니다. 깊이 헤더를 지원하는 메소드는 모든 헤더를 지원하지 않을 수 있습니다.깊이 헤더가 존재하지 않는 경우, 방법에 따라 값을 정의하고 방법을 정의 할 수 있습니다. 예를 들어 MOVE 메서드는 &quot;Depth : infinity&quot;만 지원하며 Depth 헤더가 없으면 &quot;Depth : infinity&quot;헤더가 적용된 것처럼 작동합니다. 고객은 특정 방법이 명시 적으로 보장을 제공하지 않는 한 특정 순서로 계층 멤버에서 실행되는 메소드 또는 원자적인 실행에 의존해서는 안됩니다. 실행시 Depth 헤더가있는 메소드는 가능한 많은 할당 된 태스크를 수행 한 다음 수행 할 수있는 작업과 수행하지 못한 작업을 지정하는 응답을 리턴합니다. 예를 들어 계층 구조를 복사하려고하면 일부 멤버가 복사되고 일부는 복사되지 않을 수 있습니다. 기본적으로,깊이 헤더는 다른 헤더와 상호 작용하지 않습니다. 즉, Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 대해 특정 Depth 동작이 정의되어 있지 않은 경우 리소스에 적용되는 경우 Request-URI에만 적용해야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 특정 깊이 동작이 정의되어 있지 않은 한 리소스에 적용되는 경우에만 요청 URI에 적용해야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 특정 깊이 동작이 정의되어 있지 않은 한 리소스에 적용되는 경우에만 요청 URI에 적용해야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3f35f2651dfb57ad3dbd2465104d1927bb97b16" translate="yes" xml:space="preserve">
          <source>Describes how Web resources are referenced and how to locate them.</source>
          <target state="translated">웹 리소스를 참조하는 방법과 찾는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="70c9f2b9944695efcc3168d72ca8c97f9659ed15" translate="yes" xml:space="preserve">
          <source>Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">사용자가 선호하는 언어에 따라 차별화 할 수 있도록 청중을위한 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d5ca427b8a632e16915ddd1ca200bfe11ba09ba7" translate="yes" xml:space="preserve">
          <source>Describes the three connection management models available in HTTP/1.x, their strengths, and their weaknesses.</source>
          <target state="translated">HTTP / 1.x에서 사용할 수있는 세 가지 연결 관리 모델, 장단점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a9a26ce3467081341f2f33fd2f385b9b4b5a76b7" translate="yes" xml:space="preserve">
          <source>Describes the type and structure of the different kind of messages of HTTP/1.x and HTTP/2.</source>
          <target state="translated">HTTP / 1.x 및 HTTP / 2의 다른 종류의 메시지 유형 및 구조를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="045b1f4c38aa570756046a04e9ca60247fc160b5" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in the Web architecture, its position in the protocol stack.</source>
          <target state="translated">HTTP가 무엇이며 웹 아키텍처에서의 역할, 프로토콜 스택에서의 위치에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="6011dbf6cfab599fb1f5bc7fc964691bbd1b3180" translate="yes" xml:space="preserve">
          <source>Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;, or over a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.</source>
          <target state="translated">1990 년대 초에 설계된 HTTP는 시간이 지남에 따라 진화 한 확장 가능한 프로토콜입니다. 그것은을 통해 전송되는 애플리케이션 계층 프로토콜 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt; , 또는 이상 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; 신뢰할 수있는 모든 전송 프로토콜은 이론적으로 사용할 수 있지만, TCP 연결을으로 암호화. 확장 성으로 인해 하이퍼 텍스트 문서뿐만 아니라 이미지 및 비디오를 가져 오거나 HTML 양식 결과와 같이 서버에 컨텐츠를 게시하는 데 사용됩니다. HTTP는 요청시 웹 페이지를 업데이트하기 위해 문서의 일부를 가져 오는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="532c67fe1b5afae15d2d08fba7a78de0f63cc4b5" translate="yes" xml:space="preserve">
          <source>Desktop</source>
          <target state="translated">Desktop</target>
        </trans-unit>
        <trans-unit id="dfd0263c11d50bfbcd6f11a03ba9f3544f34bf13" translate="yes" xml:space="preserve">
          <source>Despite &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; being &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;registered with IANA&lt;/a&gt;, it is largely unsupported, and &lt;code&gt;image/x-icon&lt;/code&gt; is being used instead.</source>
          <target state="translated">불구 &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; 되는 &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;IANA 등록&lt;/a&gt; , 그것은 주로 지원되지 않고 &lt;code&gt;image/x-icon&lt;/code&gt; 대신에 사용되고있다.</target>
        </trans-unit>
        <trans-unit id="2c9a54d2465a44e3b40b84b59d11de3a6c0cadc8" translate="yes" xml:space="preserve">
          <source>Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">향후 요청 헤더를 일치시켜 원본 서버에서 새로운 응답을 요청하는 대신 캐시 된 응답을 사용할 수 있는지 여부를 결정하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2e965db93ca2d2ed880afa222771550e11edd88c" translate="yes" xml:space="preserve">
          <source>Device-specific</source>
          <target state="translated">Device-specific</target>
        </trans-unit>
        <trans-unit id="504f16935ab18165c15c8ac0d71a7134e267a656" translate="yes" xml:space="preserve">
          <source>Device-specific user agent strings</source>
          <target state="translated">장치 별 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="ceb4688658b58abe9c95bf427c98e66f4be1e7a3" translate="yes" xml:space="preserve">
          <source>Different kinds of caches</source>
          <target state="translated">다른 종류의 캐시</target>
        </trans-unit>
        <trans-unit id="1ca0ed6389159c54076291dfd79987d9f92fb6b6" translate="yes" xml:space="preserve">
          <source>Directive type</source>
          <target state="translated">지시어 타입</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="f4f4473df8cb59f0a369aebee3d1509adc0151c6" translate="yes" xml:space="preserve">
          <source>Disabled</source>
          <target state="translated">Disabled</target>
        </trans-unit>
        <trans-unit id="b23e78cd51ef4c7696b73e65f06fc0fba687013d" translate="yes" xml:space="preserve">
          <source>Disabled From version 49: this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">Disabled 버전 49부터 :이 기능은 &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="f7790dccb9f3d88c21e6418f32f87789fb463366" translate="yes" xml:space="preserve">
          <source>Disabled From version 52: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 52부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="ad350d06e4ae5e37d57c0405b7c8e1fbfca3f705" translate="yes" xml:space="preserve">
          <source>Disabled From version 53: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 53부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="01d0cf4c918a77e56e449b4d149616907d38849e" translate="yes" xml:space="preserve">
          <source>Disabled From version 55: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 55부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="02423b2163f75291aa5854698bba6b1f6a5052f1" translate="yes" xml:space="preserve">
          <source>Disabled From version 56: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b34d34dcaec154df6181d68e5bec4643debe21c" translate="yes" xml:space="preserve">
          <source>Disabled From version 59: this feature is behind the &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">비활성화 됨 버전 59부터 :이 기능은 &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; 뒤에 있습니다 .http.sendOriginHeader 환경 설정 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="73719b598079cc354ff255d41acbbe0b420ae879" translate="yes" xml:space="preserve">
          <source>Disabled From version 62: this feature is behind the &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">비활성화 됨 버전 62부터 :이 기능은 &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="7847ec1580ce5ad83ab59a78912ccb3ab21e102b" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">사용 중지 버전 65부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="5a54bae2672ba58fd0d7d8cd35ca056cf1ce8f92" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">사용 중지 버전 65부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="726ec65869fe460716d9db41541949cae8c24c4e" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 66부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="aebc6632a71f5502b11ed22ad8c5755ec1c88bfe" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">비활성화 됨 버전 66부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="56705b66ed39339d0a4b894306b2ecabb3efd7c6" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">사용 중지 버전 68부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="2dcbb985ceab20f02611932df74cc051d6062ad2" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">사용 중지 버전 68부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="d28e2d242fc0c32d88a4828425be70d8d4e9386c" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc43adf822f8071bf38b741b4c8b4ff8caa87dd2" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbf731d4f27dd707439b02e0fcf767655467961" translate="yes" xml:space="preserve">
          <source>Disables DNS prefetching. This is useful if you don't control the link on the pages, or know that you don't want to leak information to these domains.</source>
          <target state="translated">DNS 프리 페치를 비활성화합니다. 페이지의 링크를 제어하지 않거나 이러한 도메인에 정보를 유출하지 않으려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="58f5f4ebc16939ddad056d1835f255075e38be52" translate="yes" xml:space="preserve">
          <source>Disables MIME sniffing and forces browser to use the type given in &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">MIME 스니핑을 비활성화하고 브라우저가 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 에&lt;/a&gt; 지정된 유형을 사용하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="4c27076a7d462b5b7f6f1b44922f1242a3e46ba5" translate="yes" xml:space="preserve">
          <source>Disables XSS filtering.</source>
          <target state="translated">XSS 필터링을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="57822983bbd8b7a6c9f3de16f7fe5eab989d06a5" translate="yes" xml:space="preserve">
          <source>Disabling a feature in a policy is a one-way toggle. If a feature has been disabled for a child frame by its parent frame, the child cannot re-enable it, and neither can any of the child's descendants.</source>
          <target state="translated">정책에서 기능을 비활성화하는 것은 단방향 전환입니다. 부모 프레임에 의해 자식 프레임에 대해 기능이 비활성화 된 경우 자식은 기능을 다시 활성화 할 수 없으며 자식의 자손도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b95dd3eb6900d93a418238bf7a5a3a1a746e7c86" translate="yes" xml:space="preserve">
          <source>Disallowing plugins</source>
          <target state="translated">플러그인 금지</target>
        </trans-unit>
        <trans-unit id="93902c2eda1c4f4fa6e24f3a214f7642478627b6" translate="yes" xml:space="preserve">
          <source>Disconnected Operation</source>
          <target state="translated">연결이 끊어진 작업</target>
        </trans-unit>
        <trans-unit id="c5bdaaa9046da0ea03b3b9660b87425b983b09dd" translate="yes" xml:space="preserve">
          <source>Discrete types</source>
          <target state="translated">이산 유형</target>
        </trans-unit>
        <trans-unit id="d69e4d6aad6c625810f7014dfc3dfbd01898d5b3" translate="yes" xml:space="preserve">
          <source>Discussion of HTTP headers</source>
          <target state="translated">HTTP 헤더에 대한 토론</target>
        </trans-unit>
        <trans-unit id="e7414bd7b2a8ae1b4152a32e27208f6ea5703ede" translate="yes" xml:space="preserve">
          <source>Display security and privacy policies In Firefox Developer Tools</source>
          <target state="translated">Firefox 개발자 도구의 보안 및 개인 정보 보호 정책 표시</target>
        </trans-unit>
        <trans-unit id="d78de940f6bf90261043cb8bd08624772df60547" translate="yes" xml:space="preserve">
          <source>Disregarding DNT. The origin server is unable or unwilling to respect a tracking preference received from the requesting user agent.</source>
          <target state="translated">DNT 무시. 오리진 서버가 요청 사용자 에이전트로부터 수신 한 추적 환경 설정을 존중할 수 없거나 존중하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a1de6fc43e38e089c17a80c82ba419f8f473962" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; use this meta element like this for stating a document language:</source>
          <target state="translated">마십시오 &lt;strong&gt;하지&lt;/strong&gt; 문서 언어를 진술이 같은이 메타 요소를 사용 :</target>
        </trans-unit>
        <trans-unit id="2c25376cd1e5d495d8c85d1b29c113dcd4496160" translate="yes" xml:space="preserve">
          <source>Do Not Track</source>
          <target state="translated">추적하지 마십시오</target>
        </trans-unit>
        <trans-unit id="70f963907a2dc441e4078146477cb1ac975253ce" translate="yes" xml:space="preserve">
          <source>Do Not Track on Wikipedia</source>
          <target state="translated">위키 백과를 추적하지 마십시오</target>
        </trans-unit>
        <trans-unit id="5de6d660ffd0c31bb077df9301609dfb8cf69667" translate="yes" xml:space="preserve">
          <source>Do you want to provide different HTML depending on which browser is being used?</source>
          <target state="translated">사용중인 브라우저에 따라 다른 HTML을 제공 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="96d09f4b8e17c5718c2731ce7ab9928e287257a4" translate="yes" xml:space="preserve">
          <source>Do-Not-Track</source>
          <target state="translated">Do-Not-Track</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="54500ed3527305b0f92d5cf278622f552f491a43" translate="yes" xml:space="preserve">
          <source>Document directive</source>
          <target state="translated">문서 지시문</target>
        </trans-unit>
        <trans-unit id="f2213ce4b36d0f4e6e226bd21f16b5d5bf80dcba" translate="yes" xml:space="preserve">
          <source>Document directives</source>
          <target state="translated">문서 지시문</target>
        </trans-unit>
        <trans-unit id="ec6b0754c2e6157428f7e2691227c09de666ec35" translate="yes" xml:space="preserve">
          <source>Document directives govern the properties of a document or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;worker&lt;/a&gt; environment to which a policy applies.</source>
          <target state="translated">문서 지시문 은 정책이 적용되는 문서 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;작업자&lt;/a&gt; 환경 의 속성을 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="5a6dfa8179f4637130555f525186dd9377736169" translate="yes" xml:space="preserve">
          <source>Does not work on Windows 7 and Windows 8.1.</source>
          <target state="translated">Windows 7 및 Windows 8.1에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea664539e7e07c3b3cb2d4e3bb71cc99d18e5b5b" translate="yes" xml:space="preserve">
          <source>Domain aliasing</source>
          <target state="translated">도메인 별칭</target>
        </trans-unit>
        <trans-unit id="3b549bffd9a85f8fa78b065a75e77e845bc42471" translate="yes" xml:space="preserve">
          <source>Domain aliasing can be done for several reasons:</source>
          <target state="translated">도메인 별칭은 여러 가지 이유로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="690d7332b26bc38eab02d6b1abf316a940401914" translate="yes" xml:space="preserve">
          <source>Domain sharding</source>
          <target state="translated">도메인 샤딩</target>
        </trans-unit>
        <trans-unit id="3c61580d55d642952fbec533e8d3f2630a7d8e94" translate="yes" xml:space="preserve">
          <source>Domain=&amp;lt;domain-value&amp;gt; Optional</source>
          <target state="translated">도메인 = &amp;lt;도메인-값&amp;gt; 선택 사항</target>
        </trans-unit>
        <trans-unit id="dc4653bff510cf1118951874eb552343ce4eeea4" translate="yes" xml:space="preserve">
          <source>Download resumption in Internet Explorer</source>
          <target state="translated">Internet Explorer에서 재개 다운로드</target>
        </trans-unit>
        <trans-unit id="a862c2b21b5e1337de2b76d5e43ae1375117d34d" translate="yes" xml:space="preserve">
          <source>Downloads</source>
          <target state="translated">Downloads</target>
        </trans-unit>
        <trans-unit id="23d33e22acfcb9ecddb4a85f10607dc4ff49e23c" translate="yes" xml:space="preserve">
          <source>Draft</source>
          <target state="translated">Draft</target>
        </trans-unit>
        <trans-unit id="13ae8e0a7cb29b1ff62023de94998bfc639787c9" translate="yes" xml:space="preserve">
          <source>Draft document</source>
          <target state="translated">초안 문서</target>
        </trans-unit>
        <trans-unit id="ddc6d4101d699284c4ee49346220f3fb8a444994" translate="yes" xml:space="preserve">
          <source>Draft spec</source>
          <target state="translated">초안 사양</target>
        </trans-unit>
        <trans-unit id="8a8aba5130fcc62311d7ddc3b7380514a11ed8fe" translate="yes" xml:space="preserve">
          <source>Due to the &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;configuration-based entropy&lt;/a&gt; increase, a modified value can be used to fingerprint the user, it is not recommended to change it and a Web site cannot trust this value to reflect the actual wish of the user. Site designers must not be over-zealous by using language detection via this header as it can lead to a poor user experience:</source>
          <target state="translated">받는 인해 &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피의&lt;/a&gt; 증가, 수정 된 값이 사용자 지문 할 수 있습니다, 변경하지 않는 것이 좋습니다 및 웹 사이트는 사용자의 실제 소원을 반영하기 위해이 값을 신뢰할 수 없습니다. 사이트 디자이너는이 헤더를 통해 언어 감지 기능을 사용하여 사용자 경험이 열악해질 수 있으므로 지나치게 열중해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="408eba332fcca84c3bed5ec905d05209bce63d2e" translate="yes" xml:space="preserve">
          <source>Due to their emphasis on authoring, WebDAV servers need to use
   authentication technology to protect not just access to a network
   resource, but the integrity of the resource as well.  Furthermore,
   the introduction of locking functionality requires support for
   authentication.

   A password sent in the clear over an insecure channel is an
   inadequate means for protecting the accessibility and integrity of a
   resource as the password may be intercepted.  Since Basic
   authentication for HTTP/1.1 performs essentially clear text
   transmission of a password, Basic authentication MUST NOT be used to
   authenticate a WebDAV client to a server unless the connection is
   secure.  Furthermore, a WebDAV server MUST NOT send a Basic
   authentication challenge in a WWW-Authenticate header unless the
   connection is secure.  An example of a secure connection would be a
   Transport Layer Security (TLS) connection employing a strong cipher
   suite and server authentication. 

   WebDAV applications MUST support the Digest authentication scheme
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].  Since Digest authentication verifies that both parties to
   a communication know a shared secret, a password, without having to
   send that secret in the clear, Digest authentication avoids the
   security problems inherent in Basic authentication while providing a
   level of authentication that is useful in a wide range of scenarios.</source>
          <target state="translated">저작에 중점을 둔 WebDAV 서버는 인증 기술을 사용하여 네트워크 자원에 대한 액세스뿐만 아니라 자원의 무결성도 보호해야합니다. 또한 잠금 기능을 도입하려면 인증 지원이 필요합니다. 안전하지 않은 채널을 통해 일반 암호를 보내면 암호를 가로 챌 수 있으므로 리소스의 액세스 가능성과 무결성을 보호하기에 부적절한 수단입니다. HTTP / 1.1에 대한 기본 인증은 본질적으로 암호의 일반 텍스트 전송을 수행하므로 연결이 안전하지 않으면 기본 인증을 사용하여 WebDAV 클라이언트를 서버에 인증해서는 안됩니다. 또한 WebDAV 서버는 연결이 안전하지 않으면 WWW-Authenticate 헤더에서 기본 인증 요청을 보내서는 안됩니다.보안 연결의 예로는 강력한 암호 제품군 및 서버 인증을 사용하는 TLS (Transport Layer Security) 연결이 있습니다. WebDAV 응용 프로그램은 다이제스트 인증 체계를 지원해야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]. 다이제스트 인증은 통신 당사자가 비밀을 명확하게 보내지 않고도 공유 비밀, 암호를 알고 있음을 확인하므로 다이제스트 인증은 기본 인증 고유의 보안 문제를 피하면서 광범위하게 유용한 인증 수준을 제공합니다. 시나리오의 범위.</target>
        </trans-unit>
        <trans-unit id="997743d612e18993ff8dc7080968428d093101a4" translate="yes" xml:space="preserve">
          <source>During the same time, the need for an encrypted transport layer raised: the Web left the relative trustiness of a mostly academic network, to a jungle where advertisers, random individuals or criminals compete to get as much private information about people, try to impersonate them or even to replace data transmitted by altered ones. As the applications built over HTTP became more and more powerful, having access to more and more private information like address books, e-mail, or the geographic position of the user, the need to have TLS became ubiquitous even outside the e-commerce use case.</source>
          <target state="translated">동시에 암호화 된 전송 계층에 대한 필요성이 높아졌습니다. 웹은 대부분 학계 네트워크의 상대적 신뢰성을 광고주, 임의의 개인 또는 범죄자가 경쟁하여 사람들에 대한 많은 개인 정보를 얻기 위해 경쟁하는 정글로 떠났습니다. 또는 변경된 데이터로 전송 된 데이터를 대체 할 수도 있습니다. HTTP를 통해 구축 된 응용 프로그램이 점점 더 강력 해져 주소록, 전자 메일 또는 사용자의 지리적 위치와 같은 점점 더 많은 개인 정보에 액세스 할 수있게되면서 전자 상거래 이외의 지역에서도 TLS를 사용할 필요가 없어졌습니다. 케이스.</target>
        </trans-unit>
        <trans-unit id="95b3251ec6e19bc2e780b0b452fffbe79113def2" translate="yes" xml:space="preserve">
          <source>Dynamic serving</source>
          <target state="translated">동적 서빙</target>
        </trans-unit>
        <trans-unit id="57313c5dd0c9956db75ecb6a66db1c8dbb3f5fdf" translate="yes" xml:space="preserve">
          <source>Dynamic. The origin server needs more information to determine tracking status.</source>
          <target state="translated">동적. 오리진 서버는 추적 상태를 판별하기 위해 추가 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="705ecd20fdc7a1a80cbce38adda833a8e258328f" translate="yes" xml:space="preserve">
          <source>ECMAScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">ECMAScript ( &lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; 사양&lt;/em&gt;&lt;/a&gt; ) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 섹션 8.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="11d00f6ed181afbae6281cf892e585dcee85b274" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="a9cf203d9639d2de24fc7e1aabf9a3f1d1b216fd" translate="yes" xml:space="preserve">
          <source>ETag (RFC 2616)</source>
          <target state="translated">ETag (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="c3c187693ac73afbe58b0355bda0f434ddd57b14" translate="yes" xml:space="preserve">
          <source>ETag (RFC 7232)</source>
          <target state="translated">ETag (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2586de7225abd1a31095cd8e2595f05492c55926" translate="yes" xml:space="preserve">
          <source>ETags</source>
          <target state="translated">ETags</target>
        </trans-unit>
        <trans-unit id="91b64bf36619dc548bb6dc82aa7a3172dcb0fa4a" translate="yes" xml:space="preserve">
          <source>EU cookie directive</source>
          <target state="translated">EU 쿠키 지침</target>
        </trans-unit>
        <trans-unit id="aacf5c8fecb249d308c1a10d329efa9aa9c43e95" translate="yes" xml:space="preserve">
          <source>Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   HTTP provides a uniform interface for interacting with a resource
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).

   HTTP semantics include the intentions defined by each request method
   (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), extensions to those semantics that might be described in
   request header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), the meaning of status codes to
   indicate a machine-readable response (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;), and the meaning of
   other control data and resource metadata that might be given in
   response header fields (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as &quot;content
   negotiation&quot; (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).</source>
          <target state="translated">각 HTTP (Hypertext Transfer Protocol) 메시지는 요청 또는 응답입니다. 서버는 요청에 대한 연결을 수신하고 수신 된 각 메시지를 구문 분석하고 식별 된 요청 대상과 관련하여 메시지 의미를 해석하고 하나 이상의 응답 메시지로 해당 요청에 응답합니다. 클라이언트는 요청 메시지를 작성하여 특정 의도를 전달하고 수신 된 응답을 검사하여 의도가 수행되었는지 확인하고 결과 해석 방법을 결정합니다. 이 문서는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처와 관련하여 HTTP / 1.1 요청 및 응답 시맨틱을 정의 합니다. HTTP는 리소스와 상호 작용하기위한 균일 한 인터페이스를 제공합니다 ( &lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt;) 표현의 조작 및 전달을 통해 유형, 성격 또는 구현에 관계없이 ( &lt;a href=&quot;#section-3&quot;&gt;3 항&lt;/a&gt; ). HTTP 시맨틱에는 각 요청 방법 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; )에 의해 정의 된 의도 , 요청 헤더 필드에 설명 될 수있는 시맨틱에 대한 확장 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ), 머신 판독 가능 응답을 나타내는 상태 코드의 의미 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 및 응답 헤더 필드에 제시 될 수있는 다른 제어 데이터 자원의 메타 데이터의 의미 ( &lt;a href=&quot;#section-7&quot;&gt;제 7&lt;/a&gt;). 이 문서는 또한 수신자가 페이로드를 해석하는 방법, 컨텐츠 선택에 영향을 줄 수있는 요청 헤더 필드 및 총괄하여 &quot;컨텐츠 협상&quot;( &lt;a href=&quot;#section-3.4&quot;&gt;3.4 절&lt;/a&gt; ) 이라고하는 다양한 선택 알고리즘을 설명하는 표현 메타 데이터를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="057e4721fb960e50e6bc2f172224db4e1bf70d8b" translate="yes" xml:space="preserve">
          <source>Each Status-Code is described below, including a description of which
   method(s) it can follow and any metainformation required in the
   response.</source>
          <target state="translated">각 상태 코드는 아래에서 설명 할 수있는 방법 및 응답에 필요한 메타 정보에 대한 설명을 포함하여 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bafccf37828f0cf81554847666fb3201e53972e" translate="yes" xml:space="preserve">
          <source>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the &lt;a href=&quot;../headers/x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">각 브라우저는 MIME 스니핑을 다르게 그리고 다른 상황에서 수행합니다. (예를 들어, Safari는 전송 된 MIME 유형이 적합하지 않은 경우 URL에서 파일 확장자를 확인합니다.) 일부 MIME 유형은 실행 가능한 컨텐츠를 나타내므로 보안 문제가 있습니다. 서버는 &lt;a href=&quot;../headers/x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt; 헤더 를 보내 MIME 스니핑을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fa8700dcf214b80fbd4de6e7bf762e538223a6" translate="yes" xml:space="preserve">
          <source>Each client in the request chain may have its own cache, so it is
   common for a cache at an intermediary to receive conditional requests
   from other (outbound) caches.  Likewise, some user agents make use of
   conditional requests to limit data transfers to recently modified
   representations or to complete the transfer of a partially retrieved
   representation.

   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content) responses, the cache
   SHOULD evaluate any applicable conditional header field preconditions
   received in that request with respect to the corresponding validators
   contained within the selected response.  A cache MUST NOT evaluate 

   conditional header fields that are only applicable to an origin
   server, found in a request with semantics that cannot be satisfied
   with a cached response, or applied to a target resource for which it
   has no stored responses; such preconditions are likely intended for
   some other (inbound) server.

   The proper evaluation of conditional requests by a cache depends on
   the received precondition header fields and their precedence, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7232]&lt;/a&gt;.  The If-Match and
   If-Unmodified-Since conditional header fields are not applicable to a
   cache.

   A request containing an If-None-Match header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7232]&lt;/a&gt;) indicates that the client wants to validate one or more of
   its own stored responses in comparison to whichever stored response
   is selected by the cache.  If the field-value is &quot;*&quot;, or if the
   field-value is a list of entity-tags and at least one of them matches
   the entity-tag of the selected stored response, a cache recipient
   SHOULD generate a 304 (Not Modified) response (using the metadata of
   the selected stored response) instead of sending that stored
   response.

   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags, the cache
   MAY combine the received list with a list of entity-tags from its own
   stored set of responses (fresh or stale) and send the union of the
   two lists as a replacement If-None-Match header field value in the
   forwarded request.  If a stored response contains only partial
   content, the cache MUST NOT include its entity-tag in the union
   unless the request is for a range that would be fully satisfied by
   that partial stored response.  If the response to the forwarded
   request is 304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response
   metadata (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;).

   If an If-None-Match header field is not present, a request containing
   an If-Modified-Since header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt;)
   indicates that the client wants to validate one or more of its own
   stored responses by modification date.  A cache recipient SHOULD
   generate a 304 (Not Modified) response (using the metadata of the
   selected stored response) if one of the following cases is true: 1)
   the selected stored response has a Last-Modified field-value that is
   earlier than or equal to the conditional timestamp; 2) no
   Last-Modified field is present in the selected stored response, but
   it has a Date field-value that is earlier than or equal to the
   conditional timestamp; or, 3) neither Last-Modified nor Date is 

   present in the selected stored response, but the cache recorded it as
   having been received at a time earlier than or equal to the
   conditional timestamp.

   A cache that implements partial responses to range requests, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], also needs to evaluate a received If-Range
   header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;) with respect to its selected
   stored response.</source>
          <target state="translated">요청 체인의 각 클라이언트는 자체 캐시를 가질 수 있으므로 중개자의 캐시가 다른 (아웃 바운드) 캐시로부터 조건부 요청을받는 것이 일반적입니다. 마찬가지로 일부 사용자 에이전트는 조건부 요청을 사용하여 데이터 전송을 최근 수정 된 표현으로 제한하거나 부분적으로 검색된 표현의 전송을 완료합니다. 캐시가 저장된 200 (OK) 또는 206 (부분 컨텐츠) 응답 중 하나를 재사용하여 만족할 수있는 요청을 수신하면 캐시는 그 안에 포함 된 해당 유효성 검증기와 관련하여 해당 요청에 수신 된 적용 가능한 조건부 헤더 필드 전제 조건을 평가해야합니다. 선택된 응답. 캐시는 오리진 서버에만 적용되는 조건부 헤더 필드를 평가해서는 안됩니다.시맨틱이있는 요청에서 캐시 된 응답으로 만족할 수 없거나 저장된 응답이없는 대상 자원에 적용될 수 있습니다. 이러한 전제 조건은 다른 (인바운드) 서버를위한 것입니다. 캐시에 의한 조건부 요청의 적절한 평가는 수신 된 사전 조건 헤더 필드와 우선 순위에 따라 달라집니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;[RFC7232] 섹션 6&lt;/a&gt; . If-Match 및 If-Unmodified-Since 조건부 헤더 필드는 캐시에 적용 할 수 없습니다. If-None-Match 헤더 필드를 포함하는 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232] 섹션 3.2&lt;/a&gt;)는 클라이언트가 캐시에 의해 저장된 저장된 응답과 비교하여 하나 이상의 자체 저장된 응답의 유효성을 검증하려고 함을 나타냅니다. 필드 값이 &quot;*&quot;이거나 필드 값이 엔티티 태그 목록이고 그 중 하나 이상이 선택된 저장된 응답의 엔티티 태그와 일치하는 경우 캐시 수신자는 304 (수정되지 않음)를 생성해야합니다 ) 저장된 응답을 전송하는 대신 응답 (선택한 저장된 응답의 메타 데이터 사용) 캐시가 엔티티 태그의 If-None-Match 목록을 포함하는 요청에 대해 자체 저장된 응답을 다시 확인하기로 결정한 경우,캐시는 수신 된 목록을 자체 저장된 응답 세트 (신규 또는 오래된)의 엔티티 태그 목록과 결합하고 전달 된 요청에서 대체 If-None-Match 헤더 필드 값으로 두 목록의 통합을 보낼 수 있습니다. 저장된 응답에 부분 내용 만 포함 된 경우 요청이 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 엔터티에 엔터티 태그를 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시가 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 엔티티 태그를 통합에 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시가 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 엔티티 태그를 통합에 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시는 304 응답 메타 데이터에 의해 업데이트 된대로 대응하는 저장된 응답을 재사용함으로써 클라이언트에 대해 200 (OK) 응답을 생성해야한다 (캐시는 304 응답 메타 데이터에 의해 업데이트 된대로 대응하는 저장된 응답을 재사용함으로써 클라이언트에 대해 200 (OK) 응답을 생성해야한다 (&lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; ). If-None-Match 헤더 필드가 없으면 If-Modified-Since 헤더 필드를 포함하는 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]의 3.3 절&lt;/a&gt;)는 클라이언트가 수정 날짜별로 하나 이상의 자체 저장된 응답의 유효성을 검증하려고 함을 나타냅니다. 캐시 수신자는 다음 중 하나의 경우에 해당하는 경우 (선택된 저장 응답의 메타 데이터를 사용하여) 304 (수정되지 않음) 응답을 생성해야합니다. 1) 선택한 저장 응답의 마지막 수정 된 필드 값이 조건부 타임 스탬프와 같습니다. 2) 선택된 저장된 응답에 Last-Modified 필드가 없지만 조건부 타임 스탬프보다 빠르거나 같은 Date 필드 값이 있습니다. 또는, 3) 선택된 저장된 응답에 Last-Modified 또는 Date가 존재하지 않지만, 캐시는 조건부 타임 스탬프 이전의 시간에 수신 된 것으로 기록했습니다. 범위 요청에 대한 부분 응답을 구현하는 캐시[에 정의 된대로&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]은 또한 선택된 저장된 응답과 관련하여 수신 된 If-Range 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]의 섹션 3.2)&lt;/a&gt; 를 평가할 필요가있다 .</target>
        </trans-unit>
        <trans-unit id="cdfff658f8638be3f51c025575b0ddaed39961ef" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types are taking a lot of space to store and the need to regain this wasted space appeared very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">각 데이터 유형에는 중복성, 즉 &lt;em&gt;공간 낭비&lt;/em&gt; 가 있습니다. 텍스트가 일반적으로 60 %의 중복성을 가질 수있는 경우 오디오 및 비디오와 같은 다른 미디어의 경우이 속도가 훨씬 높아질 수 있습니다. 텍스트와 달리 이러한 다른 미디어 유형은 저장하는 데 많은 공간이 필요하며이 낭비되는 공간을 다시 확보해야 할 필요성이 매우 일찍 나타났습니다. 엔지니어는이 특정 목적을 위해 설계된 파일 형식에서 사용되는 최적화 된 압축 알고리즘을 설계했습니다. 파일에 사용되는 압축 알고리즘은 크게 두 가지 범주로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c418e981dde2783c397a4ab8566b1987e0ddccd" translate="yes" xml:space="preserve">
          <source>Each header field consists of a case-insensitive field name followed
   by a colon (&quot;:&quot;), optional leading whitespace, the field value, and
   optional trailing whitespace. 

     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see &lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;

   The field-name token labels the corresponding field-value as having
   the semantics defined by that header field.  For example, the Date
   header field is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&amp;nbsp;7.1.1.2 of [RFC7231]&lt;/a&gt; as containing
   the origination timestamp for the message in which it appears.</source>
          <target state="translated">각 헤더 필드는 대소 문자를 구분하지 않는 필드 이름 뒤에 콜론 ( &quot;:&quot;), 선택적 선행 공백, 필드 값 및 선택적 후행 공백으로 구성됩니다. header-field = field-name &quot;:&quot;OWS 필드 값 OWS field-name = 토큰 필드 값 = * (field-content / obs-fold) field-content = field-vchar [1 * (SP / HTAB) 필드 -vchar] field-vchar = VCHAR / obs-text obs-fold = CRLF 1 * (SP / HTAB); 쓸모없는 선 접기; &lt;a href=&quot;#section-3.2.4&quot;&gt;섹션 3.2.4&lt;/a&gt; 참조 field-name 토큰은 해당 헤더 필드에 의해 의미가 정의 된 것으로 해당 필드 값에 레이블을 지정합니다. 예를 들어, 날짜 헤더 필드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;[RFC7231]의 7.1.1.2 섹션에&lt;/a&gt; 정의되어 있습니다 . 메시지가 나타나는 메시지의 발신 타임 스탬프를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="caa9777361801f65cdbd5d095a27001848c440f6" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which will handle it and provide an answer, called the &lt;em&gt;response&lt;/em&gt;. Between this request and response there are numerous entities, collectively designated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">각 개별 요청은 서버로 전송되며 서버는이를 처리하고 &lt;em&gt;응답&lt;/em&gt; 이라는 응답을 제공합니다 . 이 요청과 응답 사이에는 집합 적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시로&lt;/a&gt; 지정된 수많은 엔티티가 있으며 , 예를 들어 서로 다른 작업을 수행하고 게이트웨이 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;캐시&lt;/a&gt; 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="4d47e568ac317d800ba83293a6e6b145c10f0e3f" translate="yes" xml:space="preserve">
          <source>Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.

   Registrations happen on a &quot;First Come First Served&quot; basis (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC5226]&lt;/a&gt;) and are subject to the following rules:

   1.  A protocol-name token, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       that token.  Such specifications need not be publicly available.

   5.  The registration SHOULD name a set of expected &quot;protocol-version&quot;
       tokens associated with that token at the time of registration. 

   6.  The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.

   7.  The IESG MAY reassign responsibility for a protocol token.  This
       will normally only be used in the case when a responsible party
       cannot be contacted.

   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">등록 된 각 프로토콜 이름은 연결 정보가 업그레이드 된 후 연결이 처리되는 방법을 자세히 설명하는 연락처 정보 및 옵션 사양과 관련되어 있습니다. 등록은 &quot;선착순&quot;으로 이루어집니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226] 4.1 항&lt;/a&gt; 참조 )) 및 다음 규칙을 따릅니다. 1. 등록 된 프로토콜 이름 토큰은 영원히 등록 된 상태로 유지됩니다. 2. 등록시 등록 담당자를 지정해야합니다. 3. 등록시 반드시 연락 담당자의 이름을 지정해야합니다. 4. 등록시 해당 토큰과 관련된 사양 세트의 이름을 지정할 수 있습니다. 이러한 사양은 공개적으로 사용할 필요는 없습니다. 5. 등록시 등록시 해당 토큰과 관련된 예상 &quot;프로토콜 버전&quot;토큰 세트를 지정해야합니다. 6. 책임 당사자는 언제든지 등록을 변경할 수 있습니다. IANA는 그러한 모든 변경 사항을 기록하고 요청시 변경 사항을 제공합니다. 7. IESG는 프로토콜 토큰에 대한 책임을 재 할당 할 수 있습니다.이는 일반적으로 담당자에게 연락 할 수없는 경우에만 사용됩니다. HTTP 업그레이드 토큰에 대한이 등록 절차는 이전에 정의 된 내용을 대체합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]의 7.2 절&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb1874585ee277130e7dcc804818855ef02a2e2" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: private&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">URL에 대한 각 요청은 고유하고 캐시 할 수없는 요청으로 취급됩니다. 이것을 나타내는 더 좋은 방법은 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: private&lt;/code&gt; 을 사용 하는 것입니다. 이것은보다 명확하게 읽고 객체를 저장해서는 안된다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="083351d889941c99f11bdb7f8dc5b5a5a90e3651" translate="yes" xml:space="preserve">
          <source>Early-Data</source>
          <target state="translated">Early-Data</target>
        </trans-unit>
        <trans-unit id="8440b9eb7d03917b2509b5baeab2a299ce257eb0" translate="yes" xml:space="preserve">
          <source>Edge</source>
          <target state="translated">Edge</target>
        </trans-unit>
        <trans-unit id="aa5e3465605004afca0f330dee1d92d60e4608d6" translate="yes" xml:space="preserve">
          <source>Edge 17 skips the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive (&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;).</source>
          <target state="translated">Edge 17은 &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문 ( &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt; )을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="40943d342558e930e5fd4552c5671ad9d18db865" translate="yes" xml:space="preserve">
          <source>Edge Mobile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add94fac827b3ed02fee4c1b72173331645c25b8" translate="yes" xml:space="preserve">
          <source>Edit this page on MDN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a769fc9fd1bf50a69b3839fd2f92626878d5b626" translate="yes" xml:space="preserve">
          <source>Editor's Draft</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0aaf1ff183fe38a130caadf7977863f8e2a59f3" translate="yes" xml:space="preserve">
          <source>Editor's draft</source>
          <target state="translated">편집자 초안</target>
        </trans-unit>
        <trans-unit id="90b56ed596b137c9da80b986161d0bd1c8d62cba" translate="yes" xml:space="preserve">
          <source>Editor's draft / Candidate recommendation</source>
          <target state="translated">편집자 초안 / 후보 추천</target>
        </trans-unit>
        <trans-unit id="1fcd0c7316a8c31f4e9ceb1db446cf33c197f076" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">어느 쪽의 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 에 따라 여부 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d9968b1d7df53b6e4cf681453c3df54edc30bf" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">어느 쪽의 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 여부에 따라 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa29e4650b1639a98c0c8f55d262398a02155fba" translate="yes" xml:space="preserve">
          <source>Either the string &quot;GMT&quot; for GMT timezone, or not specified, for local timezone.</source>
          <target state="translated">GMT 시간대의 경우 &quot;GMT&quot;문자열이거나 로컬 시간대의 경우 지정되지 않은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="eec5a0a958a1fbddcf0daab821af65ae5b6cc34b" translate="yes" xml:space="preserve">
          <source>Electronic mail address</source>
          <target state="translated">전자 우편 주소</target>
        </trans-unit>
        <trans-unit id="f98f953a2a328bdea00e564fed7dfd322a69cd6d" translate="yes" xml:space="preserve">
          <source>Electronic publication (EPUB)</source>
          <target state="translated">전자 출판물 (EPUB)</target>
        </trans-unit>
        <trans-unit id="70620ad9a50dbab17deb7f1669beeb98b33e7dd5" translate="yes" xml:space="preserve">
          <source>Enable CORS: I want to add CORS support to my server</source>
          <target state="translated">CORS 활성화 : CORS 지원을 서버에 추가하고 싶습니다</target>
        </trans-unit>
        <trans-unit id="7a23cd75e8cc48555a5cc4d39dc5d353f54219c1" translate="yes" xml:space="preserve">
          <source>Enables DNS prefetching. This is what browsers do, if they support the feature, when this header is not present</source>
          <target state="translated">DNS 프리 페치를 활성화합니다. 이 헤더가 존재하지 않을 때 브라우저가 기능을 지원하는 경우 수행하는 작업</target>
        </trans-unit>
        <trans-unit id="15f6f232156085ea4d4637fb11cb65dea424795d" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts).</source>
          <target state="translated">XSS 필터링을 활성화합니다 (일반적으로 브라우저에서 기본값). 사이트 간 스크립팅 공격이 탐지되면 브라우저에서 페이지를 삭제합니다 (안전하지 않은 부분 제거).</target>
        </trans-unit>
        <trans-unit id="2afff7cdf670cfcd98e1bf3804e6db1cd9978584" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive to send a report.</source>
          <target state="translated">XSS 필터링을 활성화합니다. 사이트 간 스크립팅 공격이 탐지되면 브라우저는 페이지를 삭제하고 위반을보고합니다. CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문 의 기능을 사용하여 보고서 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="04c90c3404283e6479b83c3594ac6645fd7a76cf" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected.</source>
          <target state="translated">XSS 필터링을 활성화합니다. 브라우저는 페이지를 삭제하지 않고 공격이 감지되면 페이지 렌더링을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="22ebba1e22e214dfdd20ecfca28bb3fc46c19982" translate="yes" xml:space="preserve">
          <source>Enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="d9c536a9d2dc890eb3a315dacecf7bf8af2ea7a0" translate="yes" xml:space="preserve">
          <source>Enables cross-site scripting filtering.</source>
          <target state="translated">사이트 간 스크립팅 필터링을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="22f217de833d7c0f4da332bd436a93307529d3b5" translate="yes" xml:space="preserve">
          <source>Enabling HPKP</source>
          <target state="translated">HPKP 활성화</target>
        </trans-unit>
        <trans-unit id="bd97d929640fde2abf473682141dfee61b906111" translate="yes" xml:space="preserve">
          <source>Enabling reporting</source>
          <target state="translated">보고 활성화</target>
        </trans-unit>
        <trans-unit id="d51a5760383324ea2ced3708f0c4f21b3b6433db" translate="yes" xml:space="preserve">
          <source>Encoding data into base64 format</source>
          <target state="translated">base64 형식으로 데이터 인코딩</target>
        </trans-unit>
        <trans-unit id="f7b844634b78bbf66c2386fb7400b4efd46ba2fc" translate="yes" xml:space="preserve">
          <source>Encrypted media</source>
          <target state="translated">암호화 된 미디어</target>
        </trans-unit>
        <trans-unit id="bb7917263fb0376ecaaebc6aea8b04a067f36021" translate="yes" xml:space="preserve">
          <source>End-to-end compression</source>
          <target state="translated">엔드 투 엔드 압축</target>
        </trans-unit>
        <trans-unit id="a93b3f3b09d62b69cd48fa61fb8317033f43c87d" translate="yes" xml:space="preserve">
          <source>End-to-end headers</source>
          <target state="translated">엔드 투 엔드 헤더</target>
        </trans-unit>
        <trans-unit id="43a78c23ebe3e022d382e262e5bb0fac3b0c04eb" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례 시행</target>
        </trans-unit>
        <trans-unit id="434a202c7ecffe7d7bd9b742b730a5afd1676889" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences.</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례 시행.</target>
        </trans-unit>
        <trans-unit id="ffa0f5134bbe5f9da939c45f920a197f4634fba1" translate="yes" xml:space="preserve">
          <source>Ensure images are sized properly and are not too big for the viewport.</source>
          <target state="translated">이미지 크기가 적절하고 뷰포트에 비해 너무 크지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2a6cc6b1ec9b8b2e989114255b4da3ce2b2f166e" translate="yes" xml:space="preserve">
          <source>Ensures a resource will disown its opener when navigated to.</source>
          <target state="translated">탐색 할 때 자원이 오프너를 제거하도록합니다.</target>
        </trans-unit>
        <trans-unit id="2f61151d2512a5c88d23bfe8d6fbd9a0947b4f37" translate="yes" xml:space="preserve">
          <source>Entity (RFC 2616)</source>
          <target state="translated">실체 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="234e8581d4bf52bbea04d4ae883867b5f00f2402" translate="yes" xml:space="preserve">
          <source>Entity header</source>
          <target state="translated">엔터티 헤더</target>
        </trans-unit>
        <trans-unit id="9024c46dde9f89740b2171b9280d89a9caba4424" translate="yes" xml:space="preserve">
          <source>Entity tags are used for comparing two or more entities from the same
   requested resource. HTTP/1.1 uses entity tags in the ETag (&lt;a href=&quot;#section-14.19&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;), If-Match (&lt;a href=&quot;#section-14.24&quot;&gt;section 14.24&lt;/a&gt;), If-None-Match (&lt;a href=&quot;#section-14.26&quot;&gt;section 14.26&lt;/a&gt;), and
   If-Range (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) header fields. The definition of how they
   are used and compared as cache validators is in &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;. An
   entity tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.

      entity-tag = [ weak ] opaque-tag
      weak       = &quot;W/&quot;
      opaque-tag = quoted-string

   A &quot;strong entity tag&quot; MAY be shared by two entities of a resource
   only if they are equivalent by octet equality.

   A &quot;weak entity tag,&quot; indicated by the &quot;W/&quot; prefix, MAY be shared by
   two entities of a resource only if the entities are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity tag can only be used for weak comparison.

   An entity tag MUST be unique across all versions of all entities
   associated with a particular resource. A given entity tag value MAY
   be used for entities obtained by requests on different URIs. The use
   of the same entity tag value in conjunction with entities obtained by
   requests on different URIs does not imply the equivalence of those
   entities.</source>
          <target state="translated">엔티티 태그는 요청 된 동일한 자원에서 둘 이상의 엔티티를 비교하는 데 사용됩니다. HTTP / 1.1은 ETag ( &lt;a href=&quot;#section-14.19&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ), If-Match ( &lt;a href=&quot;#section-14.24&quot;&gt;섹션 14.24&lt;/a&gt; ), If-None-Match ( &lt;a href=&quot;#section-14.26&quot;&gt;섹션 14.26&lt;/a&gt; ) 및 If-Range ( &lt;a href=&quot;#section-14.27&quot;&gt;섹션 14.27&lt;/a&gt; ) 헤더 필드 에서 엔티티 태그를 사용 합니다. 캐시 유효성 검사기로 사용 및 비교되는 방법에 대한 정의는 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3 섹션에 있습니다.&lt;/a&gt;. 엔터티 태그는 불투명 인용 문자열로 구성되며 약점 표시기가 접두사로 표시 될 수 있습니다. entity-tag = [weak] opaque-tag weak = &quot;W /&quot;opaque-tag = 인용 된 문자열 &quot;strong entity tag&quot;는 자원의 두 엔티티가 옥텟 동등성에 해당하는 경우에만 공유 될 수 있습니다. &quot;W /&quot;접두사로 표시된 &quot;약한 엔티티 태그&quot;는 엔티티가 동등하고 의미의 큰 변화없이 서로 대체 될 수있는 경우에만 리소스의 두 엔티티에 의해 공유 될 수 있습니다. 약한 엔티티 태그는 약한 비교에만 사용할 수 있습니다. 엔티티 태그는 특정 자원과 연관된 모든 엔티티의 모든 버전에서 고유해야합니다. 주어진 엔티티 태그 값은 다른 URI에 대한 요청으로 얻은 엔티티에 사용될 수 있습니다.다른 URI에 대한 요청으로 얻은 엔티티와 함께 ​​동일한 엔티티 태그 값을 사용한다고해서 해당 엔티티의 동등성을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="843ca4f28f9ce3aa7d78cfc1dd5d180a8db20d61" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used (This is useless with &lt;code&gt;If-None-Match&lt;/code&gt; as it only uses that algorithm).</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에 놓인 ASCII 문자열로 , 약한 비교 알고리즘을 사용해야 함을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 (이것은 사용하는 &lt;code&gt;If-None-Match&lt;/code&gt; 에만 If-None-Match 와 함께 사용할 수 없음) 그 알고리즘).</target>
        </trans-unit>
        <trans-unit id="cb4831ed8a07834c227f88278424a465acad3a5a" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에있는 ASCII 문자 문자열이며 약한 비교 알고리즘을 사용해야 함을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f511403ebe3ad82f8791c9cc50f7078c288954a3" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Oftentimes, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hash of hexadecimal digits of the wiki content.</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에있는 ASCII 문자 문자열입니다 . &lt;code&gt;ETag&lt;/code&gt; 값이 생성 되는 방법 이 지정되지 않았습니다. 종종 콘텐츠의 해시, 마지막 수정 타임 스탬프의 해시 또는 수정 번호 만 사용됩니다. 예를 들어 MDN은 위키 컨텐츠의 16 진 숫자 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e2d3b3c670a7def682fbdd286ebd5fcf01de31d4" translate="yes" xml:space="preserve">
          <source>Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is OPTIONAL; some might be REQUIRED by
   portions of this specification.

       entity-header  = Allow                    ; &lt;a href=&quot;#section-14.7&quot;&gt;Section 14.7&lt;/a&gt;
                      | Content-Encoding         ; &lt;a href=&quot;#section-14.11&quot;&gt;Section 14.11&lt;/a&gt;
                      | Content-Language         ; &lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;
                      | Content-Length           ; &lt;a href=&quot;#section-14.13&quot;&gt;Section 14.13&lt;/a&gt;
                      | Content-Location         ; &lt;a href=&quot;#section-14.14&quot;&gt;Section 14.14&lt;/a&gt;
                      | Content-MD5              ; &lt;a href=&quot;#section-14.15&quot;&gt;Section 14.15&lt;/a&gt;
                      | Content-Range            ; &lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;
                      | Content-Type             ; &lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;
                      | Expires                  ; &lt;a href=&quot;#section-14.21&quot;&gt;Section 14.21&lt;/a&gt;
                      | Last-Modified            ; &lt;a href=&quot;#section-14.29&quot;&gt;Section 14.29&lt;/a&gt;
                      | extension-header

       extension-header = message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and MUST be forwarded by
   transparent proxies.</source>
          <target state="translated">엔티티 헤더 필드는 엔티티 본문 또는 본문이없는 경우 요청에 의해 식별 된 자원에 대한 메타 정보를 정의합니다. 이 메타 정보 중 일부는 선택 사항입니다. 일부는이 사양의 일부에 필요할 수 있습니다. 엔티티 헤더 = 허용; &lt;a href=&quot;#section-14.7&quot;&gt;섹션 14.7&lt;/a&gt; | 콘텐츠 인코딩; &lt;a href=&quot;#section-14.11&quot;&gt;섹션 14.11&lt;/a&gt; | 내용 언어; &lt;a href=&quot;#section-14.12&quot;&gt;섹션 14.12&lt;/a&gt; | 내용 길이; &lt;a href=&quot;#section-14.13&quot;&gt;섹션 14.13&lt;/a&gt; | 콘텐츠 위치; &lt;a href=&quot;#section-14.14&quot;&gt;섹션 14.14&lt;/a&gt; | 내용 MD5; &lt;a href=&quot;#section-14.15&quot;&gt;섹션 14.15&lt;/a&gt; | 콘텐츠 범위;&lt;a href=&quot;#section-14.16&quot;&gt;섹션 14.16&lt;/a&gt; | 컨텐츠 타입 ; &lt;a href=&quot;#section-14.17&quot;&gt;섹션 14.17&lt;/a&gt; | 만료; &lt;a href=&quot;#section-14.21&quot;&gt;섹션 14.21&lt;/a&gt; | 마지막 수정; &lt;a href=&quot;#section-14.29&quot;&gt;섹션 14.29&lt;/a&gt; | extension-header extension-header = message-header extension-header 메커니즘은 프로토콜을 변경하지 않고 추가 엔티티 헤더 필드를 정의 할 수 있지만 이러한 필드는 수신자가 인식 할 수 있다고 가정 할 수 없습니다. 인식 할 수없는 헤더 필드는 수신자에 의해 무시되어야하며 반드시 투명한 프록시에 의해 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc77c92755cf792527e0b3edc88e46b61f8087b7" translate="yes" xml:space="preserve">
          <source>Error responses: a &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; (Not Found) result page.</source>
          <target state="translated">오류 응답 : &lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; (찾을 수 없음) 결과 페이지.</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="ec4322ae064b7f4e2416acd40d4d58f17e5f8f12" translate="yes" xml:space="preserve">
          <source>Errors: CORSAllowOriginNotMatchingOrigin</source>
          <target state="translated">오류 : CORSAllowOriginNotMatchingOrigin</target>
        </trans-unit>
        <trans-unit id="4087c6aa16b5abf1735ae9f8137528c87023309b" translate="yes" xml:space="preserve">
          <source>Errors: CORSDidNotSucceed</source>
          <target state="translated">오류 : CORSDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="1110c379846585f2593a508b8c164b5bd8320b76" translate="yes" xml:space="preserve">
          <source>Errors: CORSDisabled</source>
          <target state="translated">오류 : CORSDisabled</target>
        </trans-unit>
        <trans-unit id="dac4e756c8a76cbef1b33dca607cb3bc5b771e95" translate="yes" xml:space="preserve">
          <source>Errors: CORSExternalRedirectNotAllowed</source>
          <target state="translated">오류 : CORSExternalRedirectNotAllowed</target>
        </trans-unit>
        <trans-unit id="ce973b3c74a1ebbfbbd6d7dec66c6bb20ce1f763" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowHeader</source>
          <target state="translated">오류 : CORSInvalidAllowHeader</target>
        </trans-unit>
        <trans-unit id="a282fd28c28a400d13afa18351e51568b54396d2" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowMethod</source>
          <target state="translated">오류 : CORSInvalidAllowMethod</target>
        </trans-unit>
        <trans-unit id="b8d43e50964c1cfd887f4afc94b47bcdd5d69570" translate="yes" xml:space="preserve">
          <source>Errors: CORSMIssingAllowCredentials</source>
          <target state="translated">오류 : CORSMIssingAllowCredentials</target>
        </trans-unit>
        <trans-unit id="710e0ccb5287b4319b0c5fdee5593e1d13fa6e37" translate="yes" xml:space="preserve">
          <source>Errors: CORSMethodNotFound</source>
          <target state="translated">오류 : CORSMethodNotFound</target>
        </trans-unit>
        <trans-unit id="a307f601e16873b1a5a1472fa793e47e1b28b743" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowHeaderFromPreflight</source>
          <target state="translated">오류 : CORSMissingAllowHeaderFromPreflight</target>
        </trans-unit>
        <trans-unit id="3d47284892dc16fb82eea87c1c413d4b5c528c8b" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowOrigin</source>
          <target state="translated">오류 : CORSMissingAllowOrigin</target>
        </trans-unit>
        <trans-unit id="59e949130b0899712b1a17c6d46a1f58dc1ad38e" translate="yes" xml:space="preserve">
          <source>Errors: CORSMultipleAllowOriginNotAllowed</source>
          <target state="translated">오류 : CORSMultipleAllowOriginNotAllowed</target>
        </trans-unit>
        <trans-unit id="fe11294cab619d12140db3bf906980249f0d9b51" translate="yes" xml:space="preserve">
          <source>Errors: CORSNotSupportingCredentials</source>
          <target state="translated">오류 : CORSNotSupportingCredentials</target>
        </trans-unit>
        <trans-unit id="9d941c8ccc9202a89b0022d5ed88c86d19e065a4" translate="yes" xml:space="preserve">
          <source>Errors: CORSOriginHeaderNotAdded</source>
          <target state="translated">오류 : CORSOriginHeaderNotAdded</target>
        </trans-unit>
        <trans-unit id="4b2583c03a065a201e0c7af7eb778cf128afcc99" translate="yes" xml:space="preserve">
          <source>Errors: CORSPreflightDidNotSucceed</source>
          <target state="translated">오류 : CORSPreflightDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="a43f3bb8e46c7f4d0e112510dc95499734debf0d" translate="yes" xml:space="preserve">
          <source>Errors: CORSRequestNotHttp</source>
          <target state="translated">오류 : CORSRequestNotHttp</target>
        </trans-unit>
        <trans-unit id="76e3d52572cfb5f282f24af08ceb3c93515e0c23" translate="yes" xml:space="preserve">
          <source>Establishing a connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c2c223b0f7d2f2a1d0a4ab149a50dae5eaf1dd" translate="yes" xml:space="preserve">
          <source>Evaluation (RFC 7232)</source>
          <target state="translated">평가 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="016549bb81a6b73cbdac91b27317bed690bbaf39" translate="yes" xml:space="preserve">
          <source>Even if both the client and the server supports the same compression algorithms, the server may choose not to compress the body of a response, if the identity value is also acceptable. Two common cases lead to this:</source>
          <target state="translated">클라이언트와 서버가 모두 동일한 압축 알고리즘을 지원하더라도 ID 값도 허용되는 경우 서버는 응답 본문을 압축하지 않도록 선택할 수 있습니다. 두 가지 일반적인 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39e1dc57ed79bde6d7d9296899ff80637127740c" translate="yes" xml:space="preserve">
          <source>Even if identity and location are both described using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, they are two different concepts and it is useful sometimes to distinguished between them. This article introduces the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">아이덴티티와 위치가 모두 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL을&lt;/a&gt; 사용하여 설명 되더라도 두 가지 다른 개념이며 때로는 서로 구별하는 것이 유용합니다. 이 기사에서는 &lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; 헤더를 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="d11701203cf55bb28a83c78028e1b759782a7ab9" translate="yes" xml:space="preserve">
          <source>Even if server-driven content negotiation is the most common way to agree on a specific representation of a resource, it has several drawbacks:</source>
          <target state="translated">서버 중심의 콘텐츠 협상이 리소스의 특정 표현에 동의하는 가장 일반적인 방법이지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8b58599d2ecd8aca415a34fd71768d962e8e310" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the &lt;code&gt;301&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use the &lt;a href=&quot;308&quot;&gt;&lt;code&gt;308 Permanent Redirect&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; methods instead, as the method change is explicitly prohibited with this status.</source>
          <target state="translated">사양에서 리디렉션을 수행 할 때 방법 (및 본문)을 변경하지 않아도 모든 사용자 에이전트가 해당 방법과 일치하는 것은 아닙니다. 이러한 유형의 버그가있는 소프트웨어는 여전히 찾을 수 있습니다. 따라서이 상태에서는 메소드 변경이 명시 적으로 금지 되므로 &lt;code&gt;301&lt;/code&gt; 코드는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 응답으로 만 사용하고 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 메소드에 대해서는 &lt;a href=&quot;308&quot;&gt; &lt;code&gt;308 Permanent Redirect&lt;/code&gt; &lt;/a&gt; 를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60e9e00953556ca6c857baf9a61ba9002b374a14" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents conform here - you can still find this type of bugged software out there. It is therefore recommended to set the &lt;code&gt;302&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use &lt;a href=&quot;307&quot;&gt;&lt;code&gt;307 Temporary Redirect&lt;/code&gt;&lt;/a&gt; instead, as the method change is explicitly prohibited in that case.</source>
          <target state="translated">사양에서 리디렉션을 수행 할 때 방법 (및 본문)을 변경하지 않아도 모든 사용자 에이전트가 여기에 해당하는 것은 아닙니다. 여전히 이러한 유형의 버그가있는 소프트웨어를 찾을 수 있습니다. 따라서 &lt;code&gt;302&lt;/code&gt; 코드를 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 응답으로 만 설정하고 대신 &lt;a href=&quot;307&quot;&gt; &lt;code&gt;307 Temporary Redirect&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41dab3c71327a38803685ef6e3cebc869962fcfb" translate="yes" xml:space="preserve">
          <source>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs performance, and HTTP has a specific header to avoid this scenario: &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법이 작동하더라도 문서가 변경되면 추가 응답 / 요청 교환을 추가합니다. 성능이 저하되고 HTTP에는이 시나리오를 피하기위한 특정 헤더가 있습니다. &lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b284eb5d595f914af47d2a8c3a9cef82f913efb4" translate="yes" xml:space="preserve">
          <source>Even if this technique also works for internal links, you should try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request is done) and if you can avoid it by correcting internal links, you should fix these links.</source>
          <target state="translated">이 기술이 내부 링크에도 적용 되더라도 내부 리디렉션이 발생하지 않도록해야합니다. 리디렉션은 추가 HTTP 요청이 완료 될 때 상당한 성능 비용이 발생하며 내부 링크를 수정하여이를 피할 수 있으면 이러한 링크를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="58665e4007bca0cad4410abfb11d1a4668903330" translate="yes" xml:space="preserve">
          <source>Even with more complexity, introduced in HTTP/2 by encapsulating HTTP messages into frames, HTTP is generally designed to be simple and human readable. HTTP messages can be read and understood by humans, providing easier developer testing, and reduced complexity for new-comers.</source>
          <target state="translated">HTTP 메시지를 프레임으로 캡슐화하여 HTTP / 2에 도입 된 더 복잡한 경우에도 HTTP는 일반적으로 간단하고 사람이 읽을 수 있도록 설계되었습니다. HTTP 메시지는 사람이 읽고 이해할 수 있으므로 개발자 테스트가 쉬워지고 신규 사용자의 복잡성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8b42fb3b1821d636c208455d3a9009fab5579ed3" translate="yes" xml:space="preserve">
          <source>Evercookie by Samy Kamkar</source>
          <target state="translated">Samy Kamkar의 Evercookie</target>
        </trans-unit>
        <trans-unit id="f7b5a8683f9a1cf2ee2d67f073ba064ecc576032" translate="yes" xml:space="preserve">
          <source>Everyone, really.</source>
          <target state="translated">여러분 정말.</target>
        </trans-unit>
        <trans-unit id="f49a3e37d7614909e74abaad869cfa8d5952bf40" translate="yes" xml:space="preserve">
          <source>Evolution of HTTP</source>
          <target state="translated">HTTP의 진화</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">실시 예 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad75d0ce8eb620d0eb8c90ad36bb1d3ba100630" translate="yes" xml:space="preserve">
          <source>Example HPKP Header</source>
          <target state="translated">HPKP 헤더 예</target>
        </trans-unit>
        <trans-unit id="6f262b0de6886f68de9a7f3020d9645e1a46ad07" translate="yes" xml:space="preserve">
          <source>Example of typical subtypes</source>
          <target state="translated">일반적인 하위 유형의 예</target>
        </trans-unit>
        <trans-unit id="987339acda1c7e11edad694279b3ef232cafa98c" translate="yes" xml:space="preserve">
          <source>Example preflight request</source>
          <target state="translated">프리 플라이트 요청 예</target>
        </trans-unit>
        <trans-unit id="1937f18faac9b560d6b0ad0c27d8e5021d3c2ec8" translate="yes" xml:space="preserve">
          <source>Example requests</source>
          <target state="translated">요청 예</target>
        </trans-unit>
        <trans-unit id="101e766cdf474de8672fa38603435f2c2f88941b" translate="yes" xml:space="preserve">
          <source>Example response</source>
          <target state="translated">응답 예</target>
        </trans-unit>
        <trans-unit id="9e9047fddfc8910797ad5dcc2be127acbfe08b7f" translate="yes" xml:space="preserve">
          <source>Example responses</source>
          <target state="translated">응답 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1391352a916b067bd98f31a68d100a8e123a5170" translate="yes" xml:space="preserve">
          <source>Example: Disable unsafe inline/eval, only allow loading of resources (images, fonts, scripts, etc.) over https:</source>
          <target state="translated">예 : 안전하지 않은 인라인 / 평가판을 비활성화하고 https를 통한 리소스 (이미지, 글꼴, 스크립트 등) 만로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179aebe7be456d632b5d789d99331eede78b73e3" translate="yes" xml:space="preserve">
          <source>Example: Don't implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">예 : 위의 정책을 아직 구현하지 마십시오. 대신 발생한 위반 사항 만보고하십시오.</target>
        </trans-unit>
        <trans-unit id="e17700dcd76dcab4611e46cba8a84a5260c2c790" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over https and disable plugins:</source>
          <target state="translated">예 : 너무 많은 인라인 코드를 사용하여 수정하지만 https를 통해서만 리소스를로드하고 플러그인을 비활성화하려는 기존 사이트 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd077131fc10d919fcb4af0bc52b5d5dc3bff60d" translate="yes" xml:space="preserve">
          <source>Examples of Access Control in Action</source>
          <target state="translated">액세스 제어의 예</target>
        </trans-unit>
        <trans-unit id="42b05d16ad1706c69b98dcd1d0beab7d996df8be" translate="yes" xml:space="preserve">
          <source>Examples of access control scenarios</source>
          <target state="translated">액세스 제어 시나리오의 예</target>
        </trans-unit>
        <trans-unit id="8b6959ab8197d951dfd31c9bfb60d608f8853eea" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above.&lt;/a&gt;</source>
          <target state="translated">이 사용법의 예는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;위에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a7ed9127c8003c7810083e7bbc1569d8b66810" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above&lt;/a&gt;.</source>
          <target state="translated">이 사용법의 예는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;위에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47abb8e5ca6a2e13e7aa85756a29b3a05a3d8d7b" translate="yes" xml:space="preserve">
          <source>Examples of what you can do with Feature Policy:</source>
          <target state="translated">기능 정책으로 수행 할 수있는 작업의 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="57e9b7197782a4e7584bbc9820ab7355aa88a3d3" translate="yes" xml:space="preserve">
          <source>Examples: Common use cases</source>
          <target state="translated">예 : 일반적인 사용 사례</target>
        </trans-unit>
        <trans-unit id="997886ce9b39820b9d7574fbb168082bb6c4cfb9" translate="yes" xml:space="preserve">
          <source>Except for the standard hop-by-hop headers (&lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;), any hop-by-hop headers used by the message must be listed in the &lt;code&gt;Connection&lt;/code&gt; header, so that the first proxy knows it has to consume them and not forward them further. Standard hop-by-hop headers can be listed too (it is often the case of &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, but this is not mandatory).</source>
          <target state="translated">표준 홉-바이-홉 헤더 ( &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; )를 제외하고, 메시지가 사용하는 홉-바이-홉 헤더가 나열되어야합니다. 에 &lt;code&gt;Connection&lt;/code&gt; 헤더, 그래서 첫 번째 프록시는 그들을 소비하고 더 전달할하지가 알고 있다는 것을. 표준 홉별 헤더도 나열 될 수 있습니다 (종종 &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; 의&lt;/a&gt; 경우이지만 필수 사항은 아님).</target>
        </trans-unit>
        <trans-unit id="7233a11fc2426584ed01a173a4d930d34926020b" translate="yes" xml:space="preserve">
          <source>Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully
   performed its normal request checks and just before it would perform
   the action associated with the request method.  A server MUST ignore
   all received preconditions if its response to the same request
   without those conditions would have been a status code other than a
   2xx (Successful) or 412 (Precondition Failed).  In other words,
   redirects and failures take precedence over the evaluation of
   preconditions in conditional requests. 

   A server that is not the origin server for the target resource and
   cannot act as a cache for requests on the target resource MUST NOT
   evaluate the conditional request header fields defined by this
   specification, and it MUST forward them if the request is forwarded,
   since the generating client intends that they be evaluated by a
   server that can provide a current representation.  Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as CONNECT, OPTIONS, or TRACE.

   Conditional request header fields that are defined by extensions to
   HTTP might place conditions on all recipients, on the state of the
   target resource in general, or on a group of resources.  For
   instance, the &quot;If&quot; header field in WebDAV can make a request
   conditional on various aspects of multiple resources, such as locks,
   if the recipient understands and implements that field (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918],
   Section&amp;nbsp;10.4&lt;/a&gt;).

   Although conditional request header fields are defined as being
   usable with the HEAD method (to keep HEAD's semantics consistent with
   those of GET), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a 304 (Not
   Modified) response and more useful than a 412 (Precondition Failed)
   response.</source>
          <target state="translated">아래에서 제외 된 경우를 제외하고, 수신자 캐시 또는 오리진 서버는 정상적인 요청 점검을 성공적으로 수행 한 후 및 요청 방법과 연관된 조치를 수행하기 직전에 수신 된 요청 사전 조건을 평가해야합니다. 조건이없는 동일한 요청에 대한 응답이 2xx (성공) 또는 412 (전제 조건 실패) 이외의 상태 코드 인 경우 서버는 모든 수신 된 전제 조건을 무시해야합니다. 즉, 리디렉션 및 실패는 조건부 요청의 사전 조건 평가보다 우선합니다. 대상 자원에 대한 원래 서버가 아니며 대상 자원에 대한 요청에 대한 캐시 역할을 할 수없는 서버는이 사양에 정의 된 조건부 요청 헤더 필드를 평가해서는 안됩니다.그리고 생성 된 클라이언트가 현재 표현을 제공 할 수있는 서버에 의해 평가되도록하기 때문에 요청이 전달되면 반드시 전달해야합니다. 마찬가지로, 서버는 CONNECT, OPTIONS 또는 TRACE와 같은 선택된 표현의 선택 또는 수정을 포함하지 않는 요청 방법으로 수신 될 때이 스펙에 의해 정의 된 조건부 요청 헤더 필드를 무시해야합니다. HTTP 확장으로 정의 된 조건부 요청 헤더 필드는 모든 수신자, 대상 자원의 상태 또는 자원 그룹에 조건을 둘 수 있습니다. 예를 들어, WebDAV의 &quot;If&quot;헤더 필드는 수신자가 해당 필드를 이해하고 구현하는 경우 잠금과 같은 여러 자원의 다양한 측면에 대해 조건부로 요청을 할 수 있습니다 (수신자가 해당 필드를 이해하고 구현 한 경우 (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918], 섹션 10.4&lt;/a&gt; ). HEAD의 의미를 GET의 의미와 일치하게 유지하기 위해 HEAD 방법으로 조건부 요청 헤더 필드를 사용할 수있는 것으로 정의되었지만 성공적인 응답의 크기가 304와 크기가 같기 때문에 조건부 HEAD를 보낼 때는 아무런 의미가 없습니다 (수정되지 않음). ) 응답이 있으며 412 (사전 조건 실패) 응답보다 유용합니다.</target>
        </trans-unit>
        <trans-unit id="25c9949f0e8e682737f53bb3d3d209c13c6e1d5b" translate="yes" xml:space="preserve">
          <source>Executable script is only allowed from userscripts.example.com.</source>
          <target state="translated">실행 가능한 스크립트는 userscripts.example.com에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d47895b1210b1ebd4fa933059d36aed26cda284" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely.  HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials,
   since the protocol has no awareness of how credentials are obtained 

   or managed by the user agent.  The mechanisms for expiring or
   revoking credentials can be specified as part of an authentication
   scheme definition.

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

   o  Clients that have been idle for an extended period, following
      which the server might wish to cause the client to re-prompt the
      user for credentials.

   o  Applications that include a session termination indication (such
      as a &quot;logout&quot; or &quot;commit&quot; button on a page) after which the server
      side of the application &quot;knows&quot; that there is no further reason
      for the client to retain the credentials.

   User agents that cache credentials are encouraged to provide a
   readily accessible mechanism for discarding cached credentials under
   user control.</source>
          <target state="translated">기존 HTTP 클라이언트 및 사용자 에이전트는 일반적으로 인증 정보를 무기한 보유합니다. 프로토콜은 사용자 에이전트가 자격 증명을 얻거나 관리하는 방법을 인식하지 못하므로 HTTP는 원본 서버가 클라이언트에게 이러한 캐시 된 자격 증명을 삭제하도록 지시하는 메커니즘을 제공하지 않습니다. 자격 증명 만료 또는 취소 메커니즘은 인증 체계 정의의 일부로 지정할 수 있습니다. 자격 증명 캐싱이 응용 프로그램의 보안 모델을 방해 할 수있는 상황에는 다음이 포함 되나 이에 국한되지는 않습니다. o 세션 종료 표시가 포함 된 응용 프로그램 (예 : &quot;로그 아웃&quot;또는 페이지의 &quot;커밋&quot;버튼)을 확인한 후 응용 프로그램의 서버 측에서 클라이언트가 자격 증명을 유지해야 할 추가 이유가 없음을 &quot;인식&quot;합니다. 자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6ccac52b5d4274914636579bf1636b1d5fa966cc" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP/1.1. does not provide a method for a
   server to direct clients to discard these cached credentials. This is
   a significant defect that requires further extensions to HTTP.
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

      - Clients which have been idle for an extended period following
        which the server might wish to cause the client to reprompt the
        user for credentials.

      - Applications which include a session termination indication
        (such as a `logout' or `commit' button on a page) after which
        the server side of the application `knows' that there is no
        further reason for the client to retain the credentials.

   This is currently under separate study. There are a number of work-
   arounds to parts of this problem, and we encourage the use of
   password protection in screen savers, idle time-outs, and other
   methods which mitigate the security problems inherent in this
   problem. In particular, user agents which cache credentials are
   encouraged to provide a readily accessible mechanism for discarding
   cached credentials under user control.</source>
          <target state="translated">기존 HTTP 클라이언트 및 사용자 에이전트는 일반적으로 인증 정보를 무기한 보유합니다. HTTP / 1.1. 서버가 클라이언트에게 이러한 캐시 된 자격 증명을 삭제하도록 지시하는 방법을 제공하지 않습니다. 이는 HTTP에 대한 추가 확장이 필요한 중대한 결함입니다. 자격 증명 캐싱이 응용 프로그램의 보안 모델을 방해 할 수있는 상황에는 다음이 포함 되나 이에 국한되지는 않습니다. -세션 종료 표시를 포함하는 응용 프로그램 (예 : 페이지의 '로그 아웃'또는 '커밋'버튼)은 응용 프로그램의 서버 측이 '알고'클라이언트가 자격 증명을 유지해야 할 추가 이유가 없습니다. 이것은 현재 별도의 연구 중입니다. 이 문제에는 여러 가지 해결 방법이 있으며 화면 보호기, 유휴 시간 제한 및이 문제에 내재 된 보안 문제를 완화시키는 기타 방법에서 암호 보호를 사용하는 것이 좋습니다. 특히, 자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="8a76f4ceddd2c24dfba52fcd6415b4a5d7627655" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site. A common case is when your site resides under the &lt;code&gt;www.example.com&lt;/code&gt; domain and accessing your pages from &lt;code&gt;example.com&lt;/code&gt; should be possible, too. Redirections for &lt;code&gt;example.com&lt;/code&gt; pages to &lt;code&gt;www.example.com&lt;/code&gt; are set up in this case. You might also provide commonly used synonym names or frequent typos of your domain names.</source>
          <target state="translated">사이트의 범위를 넓 힙니다. 귀하의 사이트가 &lt;code&gt;www.example.com&lt;/code&gt; 도메인에 상주하고 &lt;code&gt;example.com&lt;/code&gt; 에서 페이지에 액세스 할 수 있는 경우가 일반적 입니다. 이 경우 &lt;code&gt;example.com&lt;/code&gt; 페이지에 대한 &lt;code&gt;www.example.com&lt;/code&gt; 으로의 리디렉션 이 설정됩니다. 일반적으로 사용되는 동의어 이름이나 도메인 이름을 자주 입력 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="994027919b14e63b028676f8e18f24f8c3412b5f" translate="yes" xml:space="preserve">
          <source>Expect (RFC 2616)</source>
          <target state="translated">기대 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="53f1bb33df8415879d9607269fadc4b08f7884fc" translate="yes" xml:space="preserve">
          <source>Expect (RFC 7231)</source>
          <target state="translated">기대 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="dac7eb9f8e739ef71916b8aa6eabe504d21db9ae" translate="yes" xml:space="preserve">
          <source>Expect-CT</source>
          <target state="translated">Expect-CT</target>
        </trans-unit>
        <trans-unit id="1782a86fff7281c9294c0d3eefa4ab6846695cc2" translate="yes" xml:space="preserve">
          <source>Expect-CT Extension for HTTP</source>
          <target state="translated">HTTP에 대한 Exp-CT 확장</target>
        </trans-unit>
        <trans-unit id="79322ef6edc1926ecbca88fd7e24b3ff46c3ac45" translate="yes" xml:space="preserve">
          <source>Experimental spec</source>
          <target state="translated">실험 사양</target>
        </trans-unit>
        <trans-unit id="549fb9eb005687c11bca9c3462372257a7683df5" translate="yes" xml:space="preserve">
          <source>Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; which builds on UDP to provide a more reliable and efficient transport protocol.</source>
          <target state="translated">HTTP에보다 적합한 전송 프로토콜을 설계하기위한 실험이 진행 중입니다. 예를 들어 Google은 보다 안정적이고 효율적인 전송 프로토콜을 제공하기 위해 UDP를 기반으로하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; 를 실험하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c82119c31678afc6233c719096414eef0fb22b6" translate="yes" xml:space="preserve">
          <source>Expiration</source>
          <target state="translated">Expiration</target>
        </trans-unit>
        <trans-unit id="a99be3da0c9da2f3c64500b5ef8a8e48f503d127" translate="yes" xml:space="preserve">
          <source>Expires</source>
          <target state="translated">Expires</target>
        </trans-unit>
        <trans-unit id="cc75acb2b0ea3b677a15b0b6b818f64332802b2f" translate="yes" xml:space="preserve">
          <source>Expires (RFC 2616)</source>
          <target state="translated">만료 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="668c321a385a7ec5effd27dc4959016e1b54db8c" translate="yes" xml:space="preserve">
          <source>Expires (RFC 7234)</source>
          <target state="translated">만료 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="798d2fe08024167fc3592a3e1fdd8f0482db3150" translate="yes" xml:space="preserve">
          <source>Expires=&amp;lt;date&amp;gt; Optional</source>
          <target state="translated">만료 = &amp;lt;날짜&amp;gt; 옵션</target>
        </trans-unit>
        <trans-unit id="440f936591556c4ab22d4ca93b07905600bf80fc" translate="yes" xml:space="preserve">
          <source>Explains how a client and a server can negotiate a specific HTTP version and eventually upgrade the protocol version used.</source>
          <target state="translated">클라이언트와 서버가 특정 HTTP 버전을 협상하고 사용 된 프로토콜 버전을 업그레이드하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a639e6f336caa1c98ebcd19c35befb40a19c9aca" translate="yes" xml:space="preserve">
          <source>Extending a database through an append operation.</source>
          <target state="translated">추가 작업을 통해 데이터베이스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="a5be9d96e47f86f30faca0b0c0d8cd92b6b591df" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives</source>
          <target state="translated">확장 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="fef92b354ef2777bc846bf834005b52b7dd4a00e" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Be sure to check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support.</source>
          <target state="translated">확장 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문은 핵심 HTTP 캐싱 표준 문서의 일부가 아닙니다. 지원 여부는 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9618205d36acb2ec9a802339b387cf754ed53de" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;) unless it's overwritten via an HTTP header that is set for a CSS stylesheet specifically.</source>
          <target state="translated">CSS 스타일 시트 용으로 특별히 설정된 HTTP 헤더를 통해 덮어 쓰지 않으면 외부 CSS 스타일 시트는 기본 정책 ( &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; )을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="51b4519004830e628fefbfc612f64b245ab37406" translate="yes" xml:space="preserve">
          <source>Extracting the Base64 encoded public key information</source>
          <target state="translated">Base64로 인코딩 된 공개 키 정보 추출</target>
        </trans-unit>
        <trans-unit id="82ca99fbea5a5ea4d775520c3099a29adbd2bbf4" translate="yes" xml:space="preserve">
          <source>F.1.  Changes for Both Client and Server Implementations</source>
          <target state="translated">F.1. 클라이언트 및 서버 구현 모두에 대한 변경 사항</target>
        </trans-unit>
        <trans-unit id="e3444e81a7c395eacc8d894f9505a6b6ec9ed898" translate="yes" xml:space="preserve">
          <source>F.2.  Changes for Server Implementations</source>
          <target state="translated">F.2. 서버 구현에 대한 변경 사항</target>
        </trans-unit>
        <trans-unit id="8d6a58de84dd929ed244644a2cc93d7d20768fb2" translate="yes" xml:space="preserve">
          <source>F.3.  Other Changes</source>
          <target state="translated">F.3. 다른 변화들</target>
        </trans-unit>
        <trans-unit id="22da6d41863afa4c87a7a2a96539883a5b235c05" translate="yes" xml:space="preserve">
          <source>FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.</source>
          <target state="translated">FTP는 브라우저의 URL 표시 줄 또는 링크 대상에 직접 입력하는 것과 같이 최상위 수준에서도 여전히 허용되지만 일부 브라우저는 다른 응용 프로그램에 FTP 내용로드를 위임 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fe61c3f61162d432bcc18c5c3c2721f89c4867" translate="yes" xml:space="preserve">
          <source>Faced with this error, browsers usually either abort the operation (for example, a download will be considered as non-resumable) or ask for the whole document again.</source>
          <target state="translated">이 오류가 발생하면 브라우저는 일반적으로 작업을 중단하거나 (예 : 다운로드가 재개 불가능한 것으로 간주 됨) 전체 문서를 다시 요청합니다.</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="eba72e67a897b4f1538c1c559bf91bf79d26f8df" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;fullscreen&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.는 특정 &amp;lt;iframe&amp;gt;을 제외한 모든 교차 출처 하위 프레임에 대해 &lt;code&gt;fullscreen&lt;/code&gt; 을 비활성화하려고합니다 . 다음 HTTP 응답 헤더를 제공하여 기능 정책을 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="30c4b13be3aa4b1468bedb0d443187e381399c80" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;geolocation&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.는 특정 &amp;lt;iframe&amp;gt;을 제외한 모든 교차 출처 자식 프레임에 대해 &lt;code&gt;geolocation&lt;/code&gt; 를 비활성화하려고합니다 . 다음 HTTP 응답 헤더를 제공하여 기능 정책을 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2b02ecda0275dbc6a16322d0aa2715bb1b0c7f16" translate="yes" xml:space="preserve">
          <source>Feature Policy</source>
          <target state="translated">기능 정책</target>
        </trans-unit>
        <trans-unit id="116ce4ea97fc76a7402a5b9f210f36fadfbb4c2b" translate="yes" xml:space="preserve">
          <source>Feature Policy allows web developers to selectively enable, disable, and modify the behavior of certain features and APIs in the browser. It is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;Content Security Policy&lt;/a&gt; but controls features instead of security behavior.</source>
          <target state="translated">기능 정책을 통해 웹 개발자는 브라우저에서 특정 기능 및 API의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;콘텐츠 보안 정책&lt;/a&gt; 과 유사 하지만 보안 동작 대신 기능을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c53bb4cebead9ce42d5d5eff5bdc667fd91758b5" translate="yes" xml:space="preserve">
          <source>Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins.</source>
          <target state="translated">기능 정책을 사용하면 최상위 페이지와 내장 프레임에서 어느 원본이 어떤 기능을 사용할 수 있는지 제어 할 수 있습니다. 기본적으로 각 기능에 허용되는 원점 목록 인 정책을 작성합니다. 기능 정책에 의해 제어되는 모든 기능에 대해 해당 기능은 해당 원본이 허용 된 원본 목록과 일치하는 경우에만 현재 문서 또는 프레임에서만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="23cd7a78a2dc77e19ba57e025deceab5b480ee5d" translate="yes" xml:space="preserve">
          <source>Feature Policy provides a mechanism to explicitly declare what functionality is used (or not used), throughout your website. This allows you to lock in best practices, even as the codebase evolves over time &amp;mdash; as well as to more safely compose third-party content &amp;mdash; by limiting which features are available.</source>
          <target state="translated">기능 정책은 웹 사이트 전체에서 사용되거나 사용되지 않는 기능을 명시 적으로 선언하는 메커니즘을 제공합니다. 이를 통해 사용 가능한 기능을 제한하여 코드베이스가 시간이 지남에 따라 발전하고 타사 콘텐츠를보다 안전하게 작성할 수있는 모범 사례를 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92799190c0f4fe5ecaee2952ecf286aa6cce9ac3" translate="yes" xml:space="preserve">
          <source>Feature Policy provides two ways to specify policies to control features:</source>
          <target state="translated">기능 정책은 기능을 제어 할 정책을 지정하는 두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0847c40e72979da8866a8e8b3f1f0cc411a2dad3" translate="yes" xml:space="preserve">
          <source>Feature Policy: Using Feature Policy</source>
          <target state="translated">기능 정책 : 기능 정책 사용</target>
        </trans-unit>
        <trans-unit id="fcae4ecf5da500dd00bf9572a09b7e678697d109" translate="yes" xml:space="preserve">
          <source>Feature Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">기능 정책 &lt;br/&gt;&lt;small&gt;해당 사양에서 '기능 정책'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="294d4d9a4eaac5449bf61242940545b797efd4f7" translate="yes" xml:space="preserve">
          <source>Feature detection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfcbb2b685a05f07291909f36952c99a4e2fe7b" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. There are never any rare cases where you should use the user agent string, such as to detect a browser which implements the behavior of an API differently. Rather, in such rare cases, you should implement a test to detect how the browser implements the API and then determine when and how to use it instead. A good current example of feature detection is as follows. Recently, Chrome has added experimental look behind support to regular expressions, but no other browser currently supports this. So, you might incorrectly assume you should do this:</source>
          <target state="translated">기능 감지는 페이지를 렌더링하는 브라우저를 파악하지 않고 필요한 특정 기능을 사용할 수 있는지 확인합니다. 그렇지 않은 경우 대체를 사용합니다. API 동작을 다르게 구현하는 브라우저를 감지하는 등 사용자 에이전트 문자열을 사용해야하는 드문 경우는 없습니다. 오히려 드문 경우이지만 브라우저가 API를 구현하는 방법을 감지하고 대신 사용시기와 방법을 결정하는 테스트를 구현해야합니다. 현재 특징 검출의 좋은 예는 다음과 같다. 최근 Chrome은 정규 표현식에 대한 지원 뒤에 실험적인 모습을 추가했지만 현재 다른 브라우저에서는 지원하지 않습니다. 따라서이 작업을 수행해야한다고 잘못 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c726252d0d002492bfb760d3686808998bb8df" translate="yes" xml:space="preserve">
          <source>Feature policies on www.chromestatus.com</source>
          <target state="translated">www.chromestatus.com의 기능 정책</target>
        </trans-unit>
        <trans-unit id="d7fb77650eb9c4f73d9377f06679ca2cd28df471" translate="yes" xml:space="preserve">
          <source>Feature-Policy</source>
          <target state="translated">Feature-Policy</target>
        </trans-unit>
        <trans-unit id="a6ee4ffa583da7bdf223c2ffed9d85ab239371e0" translate="yes" xml:space="preserve">
          <source>Feature-Policy: autoplay</source>
          <target state="translated">기능 정책 : 자동 재생</target>
        </trans-unit>
        <trans-unit id="31f9ca897eb5c9f44de8842f2516fb02a54faa2e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: camera</source>
          <target state="translated">기능 정책 : 카메라</target>
        </trans-unit>
        <trans-unit id="bf16c6ee691c8e9ca8e2dbe87a3f347fcb570cc7" translate="yes" xml:space="preserve">
          <source>Feature-Policy: document-domain</source>
          <target state="translated">기능 정책 : 문서 도메인</target>
        </trans-unit>
        <trans-unit id="fe796e681d5c63dcc531be776ac43685da71889f" translate="yes" xml:space="preserve">
          <source>Feature-Policy: encrypted-media</source>
          <target state="translated">기능 정책 : 암호화 된 미디어</target>
        </trans-unit>
        <trans-unit id="37767aecde5e9787909f7866d3735071b1ccad3d" translate="yes" xml:space="preserve">
          <source>Feature-Policy: fullscreen</source>
          <target state="translated">기능 정책 : 전체 화면</target>
        </trans-unit>
        <trans-unit id="9488de5430b2b3fc9fd436b5e2d0c394e296837e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: geolocation</source>
          <target state="translated">기능 정책 : 지리적 위치</target>
        </trans-unit>
        <trans-unit id="2c61ebc183f28f44ab1b2b148b5d57942442df26" translate="yes" xml:space="preserve">
          <source>Feature-Policy: microphone</source>
          <target state="translated">기능 정책 : 마이크</target>
        </trans-unit>
        <trans-unit id="596057da4c0cdcb20ea8b614fd43950671e7a493" translate="yes" xml:space="preserve">
          <source>Feature-Policy: midi</source>
          <target state="translated">기능 정책 : 미디</target>
        </trans-unit>
        <trans-unit id="6ae2a5e94ce91f2de51637745788fb01a6ad53dc" translate="yes" xml:space="preserve">
          <source>Feature-Policy: payment</source>
          <target state="translated">기능 정책 : 결제</target>
        </trans-unit>
        <trans-unit id="6392e975cf7e0435d78f4e6d61f8527537c58cfd" translate="yes" xml:space="preserve">
          <source>Feature-Policy: vr</source>
          <target state="translated">기능 정책 : vr</target>
        </trans-unit>
        <trans-unit id="088204f1105dd468d38881f2fd12a0b4aa4c7aab" translate="yes" xml:space="preserve">
          <source>Feature-Policy:fullscreen</source>
          <target state="translated">Feature-Policy:fullscreen</target>
        </trans-unit>
        <trans-unit id="d710338755da08a83c18e218bac6cbaa1e2a4fd1" translate="yes" xml:space="preserve">
          <source>Feature-Policy:geolocation</source>
          <target state="translated">Feature-Policy:geolocation</target>
        </trans-unit>
        <trans-unit id="9d7e13756d87f97651352edd83fe4becad54f376" translate="yes" xml:space="preserve">
          <source>Feature-Policy:microphone</source>
          <target state="translated">Feature-Policy:microphone</target>
        </trans-unit>
        <trans-unit id="e7e6e3dcff550300eec2d95910564a70e893cba4" translate="yes" xml:space="preserve">
          <source>Features are each defined to have a default allowlist, which is one of:</source>
          <target state="translated">기능은 각각 기본 허용 목록을 갖도록 정의되며 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="39e28fef517be6e0fc21d5716c7662e4801ad299" translate="yes" xml:space="preserve">
          <source>Fetch API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c16479e5749d322208146b5b5f7624d72ebd140" translate="yes" xml:space="preserve">
          <source>Fetch directive</source>
          <target state="translated">가져 오기 지시문</target>
        </trans-unit>
        <trans-unit id="e53b45c9af742d503a22c70314dddb7873195091" translate="yes" xml:space="preserve">
          <source>Fetch directives</source>
          <target state="translated">지시문 가져 오기</target>
        </trans-unit>
        <trans-unit id="7a5dfae050f11fd6283650bfb92f289b86d2ac98" translate="yes" xml:space="preserve">
          <source>Fetch directives control locations from which certain resource types may be loaded.</source>
          <target state="translated">가져 오기 지시문은 특정 자원 유형이로드 될 수있는 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="916f35ff813a6743346055125d97c6cbba1aaedc" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Credentials' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Credentials'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0678866e50722f12e36a5dc2fec0748a692fe2ca" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Headers'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2cf87afd008c8c6a087d3cc6f98ba0277b9043b7" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Methods' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Methods'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4f7ed2d1134249b47bfd1f0ca53f80515e1563f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Origin'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b6d65973f43b54eb3f3ef47447a2bae6cff6fe97" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Expose-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Expose-Headers'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8089c31c9e26d8f2db19edbf9e44a130bc5eddd3" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Max-Age' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 사양에서 'Access-Control-Max-Age'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9397823a091bbc18047f30f651f6476462ab4fa8" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Request-Headers'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82f6f83e1801614fce5a5524369fe1de50f85da5" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Method' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Request-Method'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1eb076c3812c097fec7c1be9899bd085c5fbf1" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'CORS' in that specification.&lt;/small&gt;</source>
          <target state="translated">페치 &lt;br/&gt;&lt;small&gt;해당 스펙에서 'CORS'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe63ee35db7f3102d616e69a27e101cdcc18b63a" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Origin header' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Origin header'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1446331a1b71bc30148510fc4d99d0e0ec91086f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'X-Content-Type-Options definition' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'X-Content-Type-Options 정의'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="918815e8513a9d78892a5b82f5db40dddb1a7f3b" translate="yes" xml:space="preserve">
          <source>Fetching the root page of developer.mozilla.org, i.e. &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;, and telling the server that the user-agent would prefer the page in French, if possible:</source>
          <target state="translated">developer.mozilla.org의 루트 페이지 (예 : &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt; )를 가져오고 가능한 경우 사용자 에이전트가 프랑스어로 페이지를 선호한다고 서버에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="3253d0b90d63fd1a7b31fd3494e21aaa52e7e42e" translate="yes" xml:space="preserve">
          <source>File Transfer Protocol</source>
          <target state="translated">파일 전송 프로토콜</target>
        </trans-unit>
        <trans-unit id="4a7b57a8f84d5b2b2d5abb274bb773348457c9ea" translate="yes" xml:space="preserve">
          <source>File format compression</source>
          <target state="translated">파일 형식 압축</target>
        </trans-unit>
        <trans-unit id="57fa91ed93807da407d7147d7099ef87d3eef96c" translate="yes" xml:space="preserve">
          <source>Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct.</source>
          <target state="translated">파일 이름 접미사가 가끔 Microsoft Windows에서 사용되기도합니다. 모든 운영 체제가 이러한 접미어를 의미있는 것으로 간주하는 것은 아니며 (예 : Linux 및 MacOS) 정확한지 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1888d033ef09f73993a1ae6180b384a516770e4" translate="yes" xml:space="preserve">
          <source>Filtration based on &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, if any at all.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; 을&lt;/a&gt; 기준으로 한 여과 .</target>
        </trans-unit>
        <trans-unit id="02b7b1f402f1dad5cba5d5c6f4047891c00d3834" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request. In this case, 86400 seconds is 24 hours. Note that each browser has a &lt;a href=&quot;headers/access-control-max-age&quot;&gt;maximum internal value&lt;/a&gt; that takes precedence when the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; is greater.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; 는 다른 프리 플라이트 요청을 보내지 않고 프리 플라이트 요청에 대한 응답을 캐시 할 수있는 시간 (초)을 제공합니다. 이 경우 86400 초는 24 시간입니다. 각 브라우저의 &lt;a href=&quot;headers/access-control-max-age&quot;&gt;최대 내부 값&lt;/a&gt; 은 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 가 클 때 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="9c162123e6b08c6245b8c567094309cf3046a7d6" translate="yes" xml:space="preserve">
          <source>Finding insecure requests</source>
          <target state="translated">안전하지 않은 요청 찾기</target>
        </trans-unit>
        <trans-unit id="b4ee6522335b033249255b4cc1d572993282aafb" translate="yes" xml:space="preserve">
          <source>Firefox</source>
          <target state="translated">Firefox</target>
        </trans-unit>
        <trans-unit id="3d69145991747b3ff98ca2ac235bf9a2b6c0b22b" translate="yes" xml:space="preserve">
          <source>Firefox 3.6 and later</source>
          <target state="translated">Firefox 3.6 이상</target>
        </trans-unit>
        <trans-unit id="9a053be79e5c0ac7481cbdffd78827759a3ed9f5" translate="yes" xml:space="preserve">
          <source>Firefox 4</source>
          <target state="translated">Firefox 4</target>
        </trans-unit>
        <trans-unit id="e75eacacb146d953aa91455b2699bff5088fb836" translate="yes" xml:space="preserve">
          <source>Firefox 5 handles the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP response header more effectively if both the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; parameters are provided; it looks through all provided names, using the &lt;code&gt;filename*&lt;/code&gt; parameter if one is available, even if a &lt;code&gt;filename&lt;/code&gt; parameter is included first. Previously, the first matching parameter would be used, thereby preventing a more appropriate name from being used. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;bug 588781&lt;/a&gt;.</source>
          <target state="translated">Firefox 5는 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;filename*&lt;/code&gt; 매개 변수가 모두 제공되는 경우 &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP 응답 헤더를보다 효과적으로 처리합니다 . &lt;code&gt;filename&lt;/code&gt; 매개 변수가 먼저 포함되어 있더라도 &lt;code&gt;filename*&lt;/code&gt; 매개 변수를 사용할 수 있으면 filename * 매개 변수를 사용하여 제공된 모든 이름을 찾습니다 . 이전에는 첫 번째 일치 매개 변수가 사용되어보다 적절한 이름이 사용되지 않았습니다. &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;버그 588781을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="389872f22235d2e890d3e24f0e0fb6d81e0c8a59" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds) and Chromium at &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 minutes&lt;/a&gt; (600 seconds). Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;이를 24 시간&lt;/a&gt; (86400 초)에, Chromium을 &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 분&lt;/a&gt; (600 초)에 제한합니다. Chromium은 또한 기본값 5 초를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1444ac74d1094f6f34b49da3ee9966b7b93f1731" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools</source>
          <target state="translated">Firefox 개발자 도구</target>
        </trans-unit>
        <trans-unit id="f300fd41a795a419c45aee9c6cb726e738e71b7e" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools: using a source map</source>
          <target state="translated">Firefox 개발자 도구 : 소스 맵 사용</target>
        </trans-unit>
        <trans-unit id="e4b319de38dd3b5708092c79d821e3e2547bbfeb" translate="yes" xml:space="preserve">
          <source>Firefox OS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b98a32baa6ee15d09f718291f659a3f7d5a387" translate="yes" xml:space="preserve">
          <source>Firefox OS devices identify themselves without any operating system indication; for example: &quot;Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0&quot;. The web is the platform.</source>
          <target state="translated">Firefox OS 장치는 운영 체제 표시없이 자신을 식별합니다. 예 : &quot;Mozilla / 5.0 (Mobile; rv : 15.0) Gecko / 15.0 Firefox / 15.0&quot;. 웹은 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="096d24033e6a963360da3b94208e68f8d97b00a8" translate="yes" xml:space="preserve">
          <source>Firefox OS has a four-digit version number:</source>
          <target state="translated">Firefox OS에는 네 자리 버전 번호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee0b8d61fb018abae298ec4b7eb6bf2ea815cea8" translate="yes" xml:space="preserve">
          <source>Firefox OS version number</source>
          <target state="translated">Firefox OS 버전 번호</target>
        </trans-unit>
        <trans-unit id="0b43f7fedde8c737f31357ef6642b9b7dec844af" translate="yes" xml:space="preserve">
          <source>Firefox UA string</source>
          <target state="translated">Firefox UA 문자열</target>
        </trans-unit>
        <trans-unit id="cd5ecb0a55376afe3b1ad82fbe8b4cecc9e76924" translate="yes" xml:space="preserve">
          <source>Firefox Web Runtime</source>
          <target state="translated">Firefox 웹 런타임</target>
        </trans-unit>
        <trans-unit id="0c516be8bc16e485b9c5dea3cac5637b2be7f8c3" translate="yes" xml:space="preserve">
          <source>Firefox and Chrome&lt;strong&gt; disable pin validation&lt;/strong&gt; for pinned hosts whose validated certificate chain terminates at a &lt;strong&gt;user-defined trust anchor&lt;/strong&gt; (rather than a built-in trust anchor). This means that for users who imported custom root certificates all pinning violations are ignored.</source>
          <target state="translated">Firefox 및 Chrome 은 검증 된 인증서 체인 이 내장 &lt;strong&gt;트러스트 앵커가&lt;/strong&gt; 아닌 &lt;strong&gt;사용자 정의 트러스트 앵커&lt;/strong&gt; 에서 종료되는 고정 된 호스트에 대해 &lt;strong&gt;핀 검증&lt;/strong&gt; 을 &lt;strong&gt;비활성화&lt;/strong&gt; 합니다 . 즉, 사용자 지정 루트 인증서를 가져온 사용자의 경우 모든 고정 위반이 무시됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f46b1448185527825780f84cfe778a2558ec052f" translate="yes" xml:space="preserve">
          <source>Firefox currently only supports the &lt;code&gt;Large-Allocation&lt;/code&gt; header in our 32-bit Windows builds, as memory fragmentation is not an issue in 64-bit builds. If you are running a non-win32 version of Firefox, this error will appear. This check can be disabled with the &quot;dom.largeAllocation.</source>
          <target state="translated">Firefox 는 메모리 조각화가 64 비트 빌드에서 문제가되지 않으므로 현재 32 비트 Windows 빌드에서 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 만 지원 합니다. Win32 이외의 Firefox 버전을 실행중인 경우이 오류가 나타납니다. 이 검사는 &quot;dom.largeAllocation으로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd814d6c03ca30a65e6eae11a110b64dbd4091ec" translate="yes" xml:space="preserve">
          <source>Firefox earlier than 3.6</source>
          <target state="translated">3.6 이전의 Firefox</target>
        </trans-unit>
        <trans-unit id="35e08ebaf6a034e084ac621e4a8de400a08ba9e7" translate="yes" xml:space="preserve">
          <source>Firefox for Android</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3b609703588318cf5eddb907cb036af5b8fa9f" translate="yes" xml:space="preserve">
          <source>Firefox for Echo Show</source>
          <target state="translated">에코 쇼용 Firefox</target>
        </trans-unit>
        <trans-unit id="70bde33b11b3ebf831139347906ee55c0954e773" translate="yes" xml:space="preserve">
          <source>Firefox for Fire TV</source>
          <target state="translated">Fire TV 용 Firefox</target>
        </trans-unit>
        <trans-unit id="aa1b6f07af81be5e73ca90848517f82656d9b533" translate="yes" xml:space="preserve">
          <source>Firefox for Maemo (Nokia N900)</source>
          <target state="translated">Maemo 용 Firefox (Nokia N900)</target>
        </trans-unit>
        <trans-unit id="d796cd118178bed42189a33b56788596ce709a40" translate="yes" xml:space="preserve">
          <source>Firefox for iOS</source>
          <target state="translated">iOS 용 Firefox</target>
        </trans-unit>
        <trans-unit id="4a1947cf48de07acf77d4542c741b3b264b1d589" translate="yes" xml:space="preserve">
          <source>Firefox for iOS user agent string</source>
          <target state="translated">iOS 용 Firefox 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="520f59d4c4564c36ce2dffd8248ed3f436481f50" translate="yes" xml:space="preserve">
          <source>Firefox for iOS uses the default Mobile Safari UA string, with an additional &lt;strong&gt;FxiOS/&amp;lt;version&amp;gt;&lt;/strong&gt; token, similar to how &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS identifies itself&lt;/a&gt;.</source>
          <target state="translated">iOS 용 Firefox는 iOS 용 &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome이 자신을 식별&lt;/a&gt; 하는 방식과 유사한 추가 &lt;strong&gt;FxiOS / &amp;lt;version&amp;gt;&lt;/strong&gt; 토큰 과 함께 기본 Mobile Safari UA 문자열을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="97d9b72ae732fc5ec0d2b8c7b9205f083804989f" translate="yes" xml:space="preserve">
          <source>Firefox has moved to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess architecture&lt;/a&gt;, and this architecture is required in order to support the &lt;code&gt;Large-Allocation&lt;/code&gt; header. Some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;legacy Addons&lt;/a&gt; can prevent Firefox from using this new, faster, multiprocess architecture. If you have one of these Addons installed, then we will continue to use the old single process architecuture for compatibility, and cannot handle the &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;다중 프로세스 아키텍처&lt;/a&gt; 로 이동 했으며이 아키텍처 는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 를 지원하기 위해 필요합니다 . 일부 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;레거시 애드온&lt;/a&gt; 은 Firefox가이 새롭고 빠른 멀티 프로세스 아키텍처를 사용하지 못하게 할 수 있습니다. 이러한 애드온 중 하나를 설치 한 경우 호환성을 위해 이전 단일 프로세스 아키텍처를 계속 사용하므로 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더를 처리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="74fa353bc27c77608b28b6a494fb71634a8d1229" translate="yes" xml:space="preserve">
          <source>Firefox user agent string reference</source>
          <target state="translated">Firefox 사용자 에이전트 문자열 참조</target>
        </trans-unit>
        <trans-unit id="824138edb7e10e6cc870e036060b42fe43828628" translate="yes" xml:space="preserve">
          <source>Firefox's console displays messages in its console when requests fail due to CORS. Part of the error text is a &quot;reason&quot; message that provides added insight into what went wrong. The reason messages are listed below; click the message to open an article explaining the error in more detail and offering possible solutions.</source>
          <target state="translated">CORS로 인해 요청이 실패하면 Firefox 콘솔에 콘솔에 메시지가 표시됩니다. 오류 텍스트의 일부는 무엇이 잘못되었는지에 대한 통찰력을 제공하는 &quot;이유&quot;메시지입니다. 이유 메시지는 다음과 같습니다. 오류를 자세히 설명하고 가능한 해결책을 제공하는 기사를 열려면 메시지를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="7d1c6e60d05a2c5211575867279c806da9425465" translate="yes" xml:space="preserve">
          <source>Firefox, Chrome and Safari do not support multiple origins in the Access-Control-Allow-Origin header.</source>
          <target state="translated">Firefox, Chrome 및 Safari는 Access-Control-Allow-Origin 헤더에서 여러 출처를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be168c2fee1a2d9fa42cc62fef4298c4cbcefbf2" translate="yes" xml:space="preserve">
          <source>Firefox/xyz</source>
          <target state="translated">Firefox/xyz</target>
        </trans-unit>
        <trans-unit id="f614dfafdbd42e06d5c689e2cc52f2820578b824" translate="yes" xml:space="preserve">
          <source>Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;bug 1309358&lt;/a&gt;</source>
          <target state="translated">Firefox : &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;버그 1309358&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0200dffc7bdc64d4a349f323b1653382469567" translate="yes" xml:space="preserve">
          <source>Fires a &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt;.</source>
          <target state="translated">발사 &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="b748324a443374f003fb0c40ffc43547df0d368f" translate="yes" xml:space="preserve">
          <source>First you need to extract the public key information from your certificate or key file and encode them using Base64.</source>
          <target state="translated">먼저 인증서 또는 키 파일에서 공개 키 정보를 추출하고 Base64를 사용하여 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="c56777de18c704b8472efc7f29607549036e406b" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request which includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, such as:</source>
          <target state="translated">먼저 요청입니다. 프리 플라이트 요청은 다음 과 같은 세 가지 프리 플라이트 요청 헤더의 일부 조합 인 &lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 을 포함 하는 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="1856a70ba04296bbf62c2e423de0fbdcfb0f5adf" translate="yes" xml:space="preserve">
          <source>Flow of an HTTP session</source>
          <target state="translated">HTTP 세션의 흐름</target>
        </trans-unit>
        <trans-unit id="bcbad51a46a03dbd80a644d3f941e3c1172162b3" translate="yes" xml:space="preserve">
          <source>Focus Version (Rendering Engine)</source>
          <target state="translated">포커스 버전 (렌더링 엔진)</target>
        </trans-unit>
        <trans-unit id="56c6a4ca5cb7ee3279f46162d43efe44a37848d9" translate="yes" xml:space="preserve">
          <source>Focus for Android</source>
          <target state="translated">안드로이드에 대한 초점</target>
        </trans-unit>
        <trans-unit id="9c96a14d8cf5e47753d46702539d3958d06bb67a" translate="yes" xml:space="preserve">
          <source>Focus for iOS</source>
          <target state="translated">iOS 포커스</target>
        </trans-unit>
        <trans-unit id="aa5bdfcda9154f616d3599ff8019fe359c3f4231" translate="yes" xml:space="preserve">
          <source>Followed by a second connection and request to fetch the image (followed by a response to that request):</source>
          <target state="translated">두 번째 연결이 이어지고 이미지를 가져 오도록 요청합니다 (해당 요청에 대한 응답이 이어짐).</target>
        </trans-unit>
        <trans-unit id="ce1d332ceb92dcde1fcd283f80c52096a5c624f8" translate="yes" xml:space="preserve">
          <source>Footnote 1</source>
          <target state="translated">각주 1</target>
        </trans-unit>
        <trans-unit id="a2e8427dcb2cd9ff2779aa2b38c7e477133f780c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, to update a cached entity that has an associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 방법, 관련이있는 캐시 된 개체 업데이트 할 수 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="523ad4bead51d0b08a4fff5dbbe8221c7a8666b5" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with an &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;(Range Not Satisfiable) response is returned.</source>
          <target state="translated">들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 함께 사용 방법, &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더, 그것은 새로운 범위는 이전보다 동일한 자원에서 오는 요청을 보장 할 수 있습니다. 일치하지 않으면 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; (Range Not Satisfiable) 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65a5e026c5b9f4e6d8669a37e565175368c88cdf" translate="yes" xml:space="preserve">
          <source>For DAV properties, the name of the property is also the same as the
   name of the XML element that contains its value.  In the section
   below, the final line of each section gives the element type
   declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).

   A protected property is one that cannot be changed with a PROPPATCH
   request.  There may be other requests that would result in a change
   to a protected property (as when a LOCK request affects the value of
   DAV:lockdiscovery).  Note that a given property could be protected on
   one type of resource, but not protected on another type of resource.

   A computed property is one with a value defined in terms of a
   computation (based on the content and other properties of that
   resource, or even of some other resource).  A computed property is
   always a protected property.

   COPY and MOVE behavior refers to local COPY and MOVE operations.

   For properties defined based on HTTP GET response headers (DAV:get*),
   the header value could include LWS as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;.  Server implementors SHOULD strip LWS from these values before
   using as WebDAV property values.</source>
          <target state="translated">DAV 특성의 경우 특성 이름은 해당 값을 포함하는 XML 요소의 이름과 동일합니다. 아래 섹션에서 각 섹션의 마지막 줄은 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML에&lt;/a&gt; 정의 된 형식을 사용하여 요소 유형 선언을 제공합니다.]. 존재하는 경우, &quot;값&quot;필드는 BNF를 사용하여 (즉, PCDATA 요소의 값을 추가로 제한하기 위해) XML 요소의 허용 가능한 내용에 대한 추가 제한을 지정한다. 보호 된 속성은 PROPPATCH 요청으로 변경할 수없는 속성입니다. LOCK 요청이 DAV : lockdiscovery 값에 영향을주는 경우와 같이 보호 된 특성이 변경되는 다른 요청이있을 수 있습니다. 지정된 속성은 한 유형의 리소스에서는 보호 할 수 있지만 다른 유형의 리소스에서는 보호 할 수 없습니다. 계산 된 속성은 계산 측면에서 정의 된 값을 가진 속성입니다 (해당 리소스 또는 다른 리소스의 내용 및 기타 속성을 기준으로). 계산 된 속성은 항상 보호 된 속성입니다.COPY and MOVE 동작은 로컬 COPY 및 MOVE 작업을 나타냅니다. HTTP GET 응답 헤더 (DAV : get *)를 기반으로 정의 된 특성의 경우 헤더 값에는 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 서버 구현자는 WebDAV 속성 값으로 사용하기 전에 이러한 값에서 LWS를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="7578507963f5f6a92a4ce0b4b4477e8db695266c" translate="yes" xml:space="preserve">
          <source>For Nginx, the command to set up this header is:</source>
          <target state="translated">Nginx의 경우이 헤더를 설정하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1714ef110b1269230d283611695b8af7bcd041c3" translate="yes" xml:space="preserve">
          <source>For an example of a custom 404 page, see &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN's 404 page&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 404 페이지의 예는 &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN의 404 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da755a1735ea720fcbdf190446a592e95aff7a8" translate="yes" xml:space="preserve">
          <source>For authoring to commence, a client needs to discover the
   capabilities and locations of the available Collections.  Service
   Documents are designed to support this discovery process.

   How Service Documents are discovered is not defined in this
   specification. 

   Service Documents are identified with the &quot;application/atomsvc+xml&quot;
   media type (see &lt;a href=&quot;#section-16.2&quot;&gt;Section 16.2&lt;/a&gt;).</source>
          <target state="translated">제작을 시작하려면 클라이언트가 사용 가능한 컬렉션의 기능과 위치를 검색해야합니다. 서비스 문서는이 발견 프로세스를 지원하도록 설계되었습니다. 서비스 문서를 검색하는 방법은이 사양에 정의되어 있지 않습니다. 서비스 문서는 &quot;application / atomsvc ​​+ xml&quot;매체 유형으로 식별됩니다 ( &lt;a href=&quot;#section-16.2&quot;&gt;16.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5dc6e3c719ad40719899f3731172d36e94077ff2" translate="yes" xml:space="preserve">
          <source>For compression, end-to-end compression is where the largest performance improvements of Web sites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</source>
          <target state="translated">압축의 경우 엔드-투-엔드 압축은 웹 사이트의 성능이 가장 크게 향상되는 곳입니다. 엔드-투-엔드 압축은 서버에서 수행 한 메시지 본문의 압축을 말하며 클라이언트에 도달 할 때까지 변경되지 않습니다. 중간 노드가 무엇이든 그들은 몸을 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="f0f988728409b019db831b62218300a55ac3d394" translate="yes" xml:space="preserve">
          <source>For convenience, this protocol can be referred to as the &quot;Atom
   Protocol&quot; or &quot;AtomPub&quot;.  The following terminology is used by this
   specification:

   o  URI - A Uniform Resource Identifier as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].  In
      this specification, the phrase &quot;the URI of a document&quot; is
      shorthand for &quot;a URI which, when dereferenced, is expected to
      produce that document as a representation&quot;.

   o  IRI - An Internationalized Resource Identifier as defined in
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;].  Before an IRI found in a document is used by HTTP, the
      IRI is first converted to a URI.  See &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;.

   o  Resource - A network-accessible data object or service identified
      by an IRI, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  See [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;] for further
      discussion on Resources.

   o  relation (or &quot;relation of&quot;) - Refers to the &quot;rel&quot; attribute value
      of an atom:link element.

   o  Representation - An entity included with a request or response as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   o  Collection - A Resource that contains a set of Member Resources.
      Collections are represented as Atom Feeds.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;. 

   o  Member (or Member Resource) - A Resource whose IRI is listed in a
      Collection by an atom:link element with a relation of &quot;edit&quot; or
      &quot;edit-media&quot;.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;.  The protocol defines two kinds of
      Members:

      *  Entry Resource - Members of a Collection that are represented
         as Atom Entry Documents, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

      *  Media Resource - Members of a Collection that have
         representations other than Atom Entry Documents.

   o  Media Link Entry - An Entry Resource that contains metadata about
      a Media Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.

   o  Workspace - A named group of Collections.  See &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   o  Service Document - A document that describes the location and
      capabilities of one or more Collections, grouped into Workspaces.
      See &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   o  Category Document - A document that describes the categories
      allowed in a Collection.  See &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">편의상이 프로토콜을 &quot;Atom 프로토콜&quot;또는 &quot;AtomPub&quot;라고합니다. 이 사양에서는 다음 용어가 사용됩니다. o URI-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]에 정의 된 균일 자원 식별자 . 본 명세서에서, &quot;문서의 URI&quot;라는 어구는 &quot;역 참조 될 때 해당 문서를 표현으로서 생성 할 것으로 예상되는 URI&quot;의 약칭이다. o IRI-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]에 정의 된 국제화 된 자원 식별자 . 문서에서 찾은 IRI를 HTTP에서 사용하기 전에 IRI가 먼저 URI로 변환됩니다. &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1을&lt;/a&gt; 참조하십시오 . o 자원-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된대로 IRI로 식별되는 네트워크 액세스 가능 데이터 개체 또는 서비스 .보다 [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ]에 대한 자세한 내용은 참고 자료를 참조하십시오. o relation (또는 &quot;relation of&quot;)-atom : link 요소의 &quot;rel&quot;속성 값을 나타냅니다. o 표현-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된 요청 또는 응답에 포함 된 엔티티 . o 콜렉션-회원 자원 세트를 포함하는 자원. 컬렉션은 Atom Feed로 표시됩니다. &lt;a href=&quot;#section-9&quot;&gt;섹션 9를&lt;/a&gt; 참조하십시오 . o 구성원 (또는 구성원 자원)- &quot;편집&quot;또는 &quot;편집 매체&quot;의 관계를 가진 atom : link 요소에 의해 IRI가 콜렉션에 나열되는 자원. &lt;a href=&quot;#section-9.1&quot;&gt;섹션 9.1&lt;/a&gt; 참조 . 이 프로토콜은 두 가지 종류의 멤버를 정의합니다. * Entry Resource-Atom Entry Documents로 표시되는 Collection 멤버,[에 정의 된대로&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. * 미디어 리소스-Atom Entry Documents 이외의 표현이있는 컬렉션 멤버 o 미디어 링크 항목-미디어 리소스에 대한 메타 데이터가 포함 된 항목 리소스입니다. &lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; 참조 . o 작업 공간-명명 된 컬렉션 그룹. &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; 참조 . o 서비스 문서-하나 이상의 컬렉션의 위치 및 기능을 작업 공간으로 그룹화하여 설명하는 문서. &lt;a href=&quot;#section-8&quot;&gt;섹션 8을&lt;/a&gt; 참조하십시오 . o 카테고리 문서-컬렉션에서 허용되는 카테고리를 설명하는 문서. &lt;a href=&quot;#section-7&quot;&gt;섹션 7을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eef31d3a1350a01572c86bb4dfa3d00e0c975e26" translate="yes" xml:space="preserve">
          <source>For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature.</source>
          <target state="translated">각 정책 제어 기능에 대해 브라우저는 기능이 활성화 된 출처 목록 (허용 목록)을 유지 관리합니다. 기능에 대한 정책을 지정하지 않으면 기본 허용 목록이 사용됩니다. 기본 허용 목록은 각 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bbfd900d40adcb99301092c21f8010e24f933f46" translate="yes" xml:space="preserve">
          <source>For example when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">예를 들어 MDN을 편집 할 때 현재 위키 컨텐츠가 해시 되어 응답에 &lt;code&gt;Etag&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9445e49e152cffd5d9a04a8f80bbd49732b55bc8" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;a script on Browserleaks&lt;/a&gt; highlights what Firefox reveals when queried by a simple script running on the site (you can find the code in &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt;).</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;Browserleaks의 스크립트&lt;/a&gt; 는 사이트에서 실행되는 간단한 스크립트로 쿼리 할 때 Firefox에서 표시하는 내용을 강조 표시합니다 ( &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt; 에서 코드를 찾을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="64b899bc979c38aad573a87de3d6fa69123c484f" translate="yes" xml:space="preserve">
          <source>For example, allow all browsing contexts within this iframe to use fullscreen:</source>
          <target state="translated">예를 들어,이 iframe 내의 모든 탐색 컨텍스트가 전체 화면을 사용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="08b715bba658a875ffba997c7f848a3f6b1c1f7c" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers).</source>
          <target state="translated">예를 들어 &quot; &lt;code&gt;Content-Language: de-DE&lt;/code&gt; &quot;가 설정되어 있으면 해당 문서는 독일어 사용자를위한 것입니다 (단, 문서가 독일어로 작성된다는 의미는 아닙니다). 독일어 사용자를위한 언어 과정의 일부로 영어).</target>
        </trans-unit>
        <trans-unit id="6412826a466b2db302aa194f4e3daf55e5d61efd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are included on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; 가 설정된 경우 쿠키는 &lt;code&gt;developer.mozilla.org&lt;/code&gt; 와 같은 하위 도메인에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c0625b9fc57344582bbde2ab4696157ad3f42eb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths will match:</source>
          <target state="translated">예를 들어, &lt;code&gt;Path=/docs&lt;/code&gt; 를 설정하면 다음 경로가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fa9700b85e0e01538fcca2eb77f677f69026288f" translate="yes" xml:space="preserve">
          <source>For example, if the page &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; were requested, and the HTTP response is &quot;301 Moved Permanently&quot;, &quot;307 Temporary Redirect&quot;, or &quot;308 Permanent Redirect&quot; with a &lt;code&gt;Location&lt;/code&gt; of &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt;, the CORS request will fail in this manner.</source>
          <target state="translated">예를 들어 &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; 페이지 가 요청되었고 HTTP 응답이 &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt; &lt;code&gt;Location&lt;/code&gt; 으로 &quot;301 Permanently Permanently&quot;, &quot;307 Temporary Redirect&quot;또는 &quot;308 Permanent Redirect&quot; 인 경우 .net / getdata , CORS 요청은이 방식으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b87738a4c88c7a7b6a1a09e51a26bf1a734d5d4" translate="yes" xml:space="preserve">
          <source>For example, if the response includes:</source>
          <target state="translated">예를 들어 응답에 다음이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="66e0a70fb691c18fbdd0bd050b60e272a1fe413f" translate="yes" xml:space="preserve">
          <source>For example, in Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">예를 들어, Apache에서 다음과 같은 행을 서버 구성에 추가하십시오 (적절한 &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 섹션 내). 구성은 일반적으로 &lt;code&gt;.conf&lt;/code&gt; 파일 ( &lt;code&gt;httpd.conf&lt;/code&gt; 및 &lt;code&gt;apache.conf&lt;/code&gt; 는 일반적인 이름 임) 또는 &lt;code&gt;.htaccess&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="619f3c064cc0ce3bc00c710809c1ce33e001a212" translate="yes" xml:space="preserve">
          <source>For example, sending the result of a form:</source>
          <target state="translated">예를 들어, 양식 결과를 보내려면 :</target>
        </trans-unit>
        <trans-unit id="b184b5ed58eb6819039876c32250bc43b4bad555" translate="yes" xml:space="preserve">
          <source>For example, suppose web content on domain &lt;code&gt;http://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;http://bar.other&lt;/code&gt;. Code of this sort might be used within JavaScript deployed on foo.example:</source>
          <target state="translated">예를 들어, 도메인 &lt;code&gt;http://foo.example&lt;/code&gt; 의 웹 컨텐츠가 http : //bar.other 도메인의 컨텐츠를 호출하려고 한다고 가정 &lt;code&gt;http://bar.other&lt;/code&gt; . 이러한 종류의 코드는 foo.example에 배포 된 JavaScript 내에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d20e4a9531f0f953723ad2bce29ba67c92820b20" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</source>
          <target state="translated">예를 들어, &lt;code&gt;CONNECT&lt;/code&gt; 메소드를 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; ) 을 사용하는 웹 사이트에 액세스 할 수 있습니다 . 클라이언트는 HTTP 프록시 서버에 TCP 연결을 원하는 대상으로 터널링하도록 요청합니다. 그런 다음 서버는 클라이언트 대신 연결을 진행합니다. 서버가 연결을 설정하면 프록시 서버는 클라이언트와의 TCP 스트림을 계속 프록시합니다.</target>
        </trans-unit>
        <trans-unit id="71916a917e381d9f4baa72eb7d0f481b27298684" translate="yes" xml:space="preserve">
          <source>For example, the following are equivalent:</source>
          <target state="translated">예를 들어 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e32905633351c047f12f27629c2b7dbcbd3258eb" translate="yes" xml:space="preserve">
          <source>For example, the server may reject a request if its &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; is too large.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 가 너무 큰 경우 서버는 요청을 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d63752de4fee204887b96a1631e06acc76c5193f" translate="yes" xml:space="preserve">
          <source>For example, this blocks the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; from using the camera and microphone:</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 이 카메라와 마이크를 사용하지 못하도록 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="667503768ab9f00b3c857611676b705bf222dc50" translate="yes" xml:space="preserve">
          <source>For example, to allow a site at https://amazing.site to access the resource using CORS, the header should be:</source>
          <target state="translated">예를 들어 https://amazing.site의 사이트가 CORS를 사용하여 리소스에 액세스 할 수있게하려면 헤더는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="dc1f722176891e42941f464101332b2ba20f6189" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;http://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">예를 들어, 출처 &lt;code&gt;http://mozilla.org&lt;/code&gt; 의 코드 가 리소스에 액세스 할 수 있도록하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8dcd604f2bec51e5cc439af7d8b146ce60c0ce" translate="yes" xml:space="preserve">
          <source>For example, to block all content from using the Geolocation API across your site:</source>
          <target state="translated">예를 들어 모든 콘텐츠가 사이트에서 Geolocation API를 사용하지 못하도록 차단하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cc7ca2973a124b54e9384bba7dd4138b39eb2ca" translate="yes" xml:space="preserve">
          <source>For images, &lt;code&gt;gif&lt;/code&gt; or &lt;code&gt;png&lt;/code&gt; are using loss-less compression.</source>
          <target state="translated">이미지의 경우 &lt;code&gt;gif&lt;/code&gt; 또는 &lt;code&gt;png&lt;/code&gt; 는 무손실 압축을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f96d0e055aab7967e098e229f35a70f7d0cf4499" translate="yes" xml:space="preserve">
          <source>For inline styles or styles created from APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;HTMLElement.style&lt;/code&gt;&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;HTMLElement.style&lt;/code&gt; &lt;/a&gt; 과 같은 API에서 생성 된 인라인 스타일 또는 스타일의 경우 소유자 문서의 리퍼러 정책이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84bf50840f620c842f8d504aeebea80f2ae78a0a" translate="yes" xml:space="preserve">
          <source>For locking mechanisms, it is the opposite: Web developers need to issue a request with the proper headers, while webmasters can mostly rely on the application to carry out the checks for them.</source>
          <target state="translated">잠금 메커니즘의 경우에는 반대입니다. 웹 개발자는 적절한 헤더를 사용하여 요청을 발행해야하지만 웹 마스터는 대부분이를 확인하기 위해 애플리케이션에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05bc2f18a1040cbebb023b0b22da7d3057050814" translate="yes" xml:space="preserve">
          <source>For more details on Firefox and Gecko based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Firefox 및 Gecko 기반 사용자 에이전트 문자열에 대한 자세한 내용은 &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox 사용자 에이전트 문자열 참조를 참조하십시오&lt;/a&gt; . Firefox 자체의 UA 문자열은 다음과 같은 네 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="d7d24847af6c0b28f664c1b1ecd25eca36f5dc16" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Using Feature Policy&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;기능 정책 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f2fd29856862ed0ab79e6861cc4858f4155a7dc" translate="yes" xml:space="preserve">
          <source>For more details, see also the &lt;a href=&quot;#Freshness&quot;&gt;Freshness&lt;/a&gt; section below.</source>
          <target state="translated">자세한 내용은 아래 의 &lt;a href=&quot;#Freshness&quot;&gt;신선도&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72a6b38e5e421526b3d5933f3b867e718bd90436" translate="yes" xml:space="preserve">
          <source>For more information, see also this article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../csp&quot;&gt;콘텐츠 보안 정책 (CSP)&lt;/a&gt; 에 대한이 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3aa6b680bc6518edc5c36b2eb482864b073f5d2" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP 공개 키 고정&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6388d0122d4c6699e1cf73b26f4fab54e1e4ece" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header reference page and the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 헤더 참조 페이지 및 &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP 공개 키 고정&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16d858e940de2d5add12c93eacce99796fbd8dc3" translate="yes" xml:space="preserve">
          <source>For more information, see the guide on &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../cookies&quot;&gt;HTTP 쿠키&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abf003bb7d49f08a37fe6d4505f868da1702a5d5" translate="yes" xml:space="preserve">
          <source>For more information, see the main &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;Feature Policy&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 주요 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;기능 정책&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c13a01882beedd60ef040f694851d73933cf613" translate="yes" xml:space="preserve">
          <source>For more prevention tips, see the &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;.</source>
          <target state="translated">자세한 예방 정보는 &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF 예방 치트 시트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b991665d6c852df1848b14e1c2237629d3e471a4" translate="yes" xml:space="preserve">
          <source>For more, see &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;this Wikipedia section&lt;/a&gt; and consult state laws for the latest and most accurate information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;이 Wikipedia 섹션&lt;/a&gt; 을 참조하고 최신의 가장 정확한 정보는 주법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16bc316a5e9428e01ce42d164953682ad4eeadaf" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often the header boundary is prepended by two dashes in the body and the final boundary also have a two dashes appended to it.</source>
          <target state="translated">여러 부분으로 구성된 엔터티의 경우 &lt;code&gt;boundary&lt;/code&gt; 지시문이 필요합니다.이 지침은 전자 메일 게이트웨이를 통해 매우 강력하고 공백으로 끝나지 않는 것으로 알려진 문자 집합에서 1 ~ 70 자로 구성됩니다. 메시지의 여러 부분의 경계를 캡슐화하는 데 사용됩니다. 종종 헤더 경계에는 본문에 두 개의 대시가 붙고 마지막 경계에는 두 개의 대시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="093b1094cde6e7f4f4d8f8b971af7a8990963019" translate="yes" xml:space="preserve">
          <source>For new content, you can start developing with a policy that disables all the features. This approach ensures that none of the functionality is introduced. When applying a policy to existing content, testing is likely required to verify it continues to work as expected. This is especially important for embedded or third-party content that you do not control.</source>
          <target state="translated">새로운 콘텐츠의 경우 모든 기능을 비활성화하는 정책으로 개발을 시작할 수 있습니다. 이 접근 방식은 어떤 기능도 도입되지 않도록합니다. 기존 컨텐츠에 정책을 적용 할 때 예상대로 계속 작동하는지 테스트해야합니다. 제어하지 않는 내장 또는 타사 컨텐츠에 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2f39ad9de038e309432fa2abc7e02992cadbd96a" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a .htpasswd file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">nginx의 경우, 보호하려는 위치와 암호로 보호 된 영역에 이름을 제공하는 &lt;code&gt;auth_basic&lt;/code&gt; 지시문을 지정해야합니다. &lt;code&gt;auth_basic_user_file&lt;/code&gt; 의 지시어는 바로 위의 아파치 예에서와 같이 암호화 된 사용자 자격 증명을 포함하는 .htpasswd 파일을 가리키는.</target>
        </trans-unit>
        <trans-unit id="70553b80e8be103814c1eb5f51fa3a904090e239" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Match&lt;/code&gt; can be used to prevent the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) response is returned.</source>
          <target state="translated">다른 방법, 특히 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;If-Match&lt;/code&gt; &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;업데이트 손실 문제&lt;/a&gt; 를 방지하기 위해 If-Match를 사용할 수 있습니다 . 사용자가 업로드하려는 리소스의 수정이 원래 리소스를 가져온 후 수행 된 다른 변경 사항을 무시하지 않는지 확인할 수 있습니다. 요청을 이행 할 수 없으면 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="538225086d2d3b055913158dd5b4c3b9bfc1f097" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; used with the &lt;code&gt;*&lt;/code&gt; value can be used to save a file not known to exist, guaranteeing that another upload didn't happen before, losing the data of the previous put; this problem is a variation of the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;.</source>
          <target state="translated">다른 방법, 특히 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;If-None-Match&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 값 과 함께 사용 된 If-None-Match를 사용 하여 존재하지 않는 파일을 저장하여 이전 업로드의 데이터가 손실되어 이전에 다른 업로드가 발생하지 않았 음을 보장 할 수 있습니다. 이 문제는 &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;손실 된 업데이트 문제&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="89936fcb3c720f2a1e2c92027641b334e9357ffd" translate="yes" xml:space="preserve">
          <source>For other products based on Gecko, the string can take one of two forms, where the tokens have the same meaning except those noted below:</source>
          <target state="translated">Gecko를 기반으로하는 다른 제품의 경우, 문자열은 두 가지 형식 중 하나를 취할 수 있으며, 토큰은 아래에 언급 된 것을 제외하고 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="907135173500e7b45556d497127edb70bd3fb716" translate="yes" xml:space="preserve">
          <source>For reasons of security and privacy, it is necessary to make a
   distinction between &quot;shared&quot; and &quot;non-shared&quot; caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case SHOULD be enforced by appropriate security mechanisms.
   All other caches are considered to be &quot;shared.&quot; Other sections of 

   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.</source>
          <target state="translated">보안 및 개인 정보 보호를 위해 &quot;공유&quot;캐시와 &quot;비공유&quot;캐시를 구분해야합니다. 비공유 캐시는 단일 사용자 만 액세스 할 수있는 캐시입니다. 이 경우 접근성은 적절한 보안 메커니즘에 의해 시행되어야한다. 다른 모든 캐시는 &quot;공유&quot;된 것으로 간주됩니다. 이 사양의 다른 섹션에서는 개인 정보 손실 또는 액세스 제어 실패를 방지하기 위해 공유 캐시의 작동에 특정 제약 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="257548a557c142ce44b1aa876c1f52d0b2cfeb6c" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;*&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;신임 정보&lt;/em&gt; 가 &lt;em&gt;없는&lt;/em&gt; 요청의 경우 리터럴 값 &quot;*&quot;를 와일드 카드로 지정할 수 있습니다. 이 값은 브라우저에게 모든 오리진에서 코드를 요청하여 리소스에 액세스하도록 허용합니다. 자격 증명과 함께 와일드 카드를 사용하려고 &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;하면 오류가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="351e6c404b20eecdc808fd67608ccc7928ea6386" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers.</source>
          <target state="translated">보안상의 이유로 브라우저는 스크립트 내에서 시작된 원본 간 HTTP 요청을 제한합니다. 예를 들어, &lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 출처 정책을&lt;/a&gt; 따릅니다 . 이는 다른 API의 응답에 올바른 CORS 헤더가 포함되어 있지 않으면 해당 API를 사용하는 웹 애플리케이션이 애플리케이션이로드 된 동일한 출처의 HTTP 자원 만 요청할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ee3a9635da3f4811be8395ffd6f2c7c100ed7868" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used.</source>
          <target state="translated">특정 하위 유형이없는 텍스트 문서의 경우 &lt;code&gt;text/plain&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01fd2dd2707385a8305b768f33bb65eb7bcb3f6d" translate="yes" xml:space="preserve">
          <source>For the files in the application that will not change, you can usually add aggressive caching by sending the response header below. This includes static files that are served by the application such as images, CSS files and JavaScript files, for example. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; header.</source>
          <target state="translated">변경되지 않는 응용 프로그램 파일의 경우 일반적으로 아래 응답 헤더를 보내 공격적인 캐싱을 추가 할 수 있습니다. 여기에는 이미지, CSS 파일 및 JavaScript 파일과 같이 응용 프로그램에서 제공하는 정적 파일이 포함됩니다. 또한 &lt;code&gt;Expires&lt;/code&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47f9208ec82cf7fb7519a3acacb255f0ed8d2472" translate="yes" xml:space="preserve">
          <source>For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:

      - End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses MUST be stored as part of a cache entry and MUST be
        transmitted in any response formed from a cache entry.

      - Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.

   The following HTTP/1.1 headers are hop-by-hop headers:

      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade

   All other headers defined by HTTP/1.1 are end-to-end headers.

   Other hop-by-hop headers MUST be listed in a Connection header,
   (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) to be introduced into HTTP/1.1 (or later).</source>
          <target state="translated">캐시 및 비 캐싱 프록시의 동작을 정의하기 위해 HTTP 헤더를 두 가지 범주로 나눕니다.-엔드-투-엔드 헤더-요청 또는 응답의 최종 수신자에게 전송됩니다. 응답의 엔드-투-엔드 헤더는 반드시 캐시 엔트리의 일부로 저장되어야하며 캐시 엔트리로부터 형성된 응답으로 전송되어야합니다. -홉별 헤더 : 단일 전송 수준 연결에만 의미가 있으며 캐시에 의해 저장되거나 프록시에 의해 전달되지 않습니다. 다음 HTTP / 1.1 헤더는 홉별 헤더입니다.-연결-연결 유지-프록시 인증-프록시 인증-TE-트레일러-전송 인코딩-업그레이드 HTTP / 1.1에 의해 정의 된 다른 모든 헤더는 끝이 없습니다 엔드 헤더.다른 홉별 헤더는 반드시 연결 헤더 (&lt;a href=&quot;#section-14.10&quot;&gt;14.10 절은&lt;/a&gt; ) HTTP / 1.1 (또는 그 이상)에 도입한다.</target>
        </trans-unit>
        <trans-unit id="21bafa062922688ae091d5ac581f85b2253ab9b7" translate="yes" xml:space="preserve">
          <source>For these reasons, pipelining has been superseded by a better algorithm, &lt;em&gt;multiplexing&lt;/em&gt;, that is used by HTTP/2.</source>
          <target state="translated">이러한 이유로 파이프 라이닝은 HTTP / 2에서 사용 하는 더 나은 알고리즘 인 &lt;em&gt;멀티플렉싱&lt;/em&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0fe7bfcb91231799d489fc2723d6dd4bbc0c043" translate="yes" xml:space="preserve">
          <source>Forbidden header name</source>
          <target state="translated">금지 된 헤더 이름</target>
        </trans-unit>
        <trans-unit id="b412bc69411dace0d04398d6ef301aa1c667a968" translate="yes" xml:space="preserve">
          <source>Force communication using HTTPS instead of HTTP.</source>
          <target state="translated">HTTP 대신 HTTPS를 사용하여 강제로 통신하십시오.</target>
        </trans-unit>
        <trans-unit id="eef9c57759e4f6a908b3d969fe32e4b1fa5c2a10" translate="yes" xml:space="preserve">
          <source>Forced prefetching of hostnames might be useful, for example, on the homepage of a site to force pre-resolution of domain names that are referenced frequently throughout the site even though they are not used on the home page itself. This will improve the overall performance of site even though the performance of the home page may not be affected.</source>
          <target state="translated">호스트 이름의 강제 프리 페치는 예를 들어, 사이트 자체에서 사용되지 않더라도 사이트 전체에서 자주 참조되는 도메인 이름의 사전 해결을 강제하는 데 유용합니다. 이렇게하면 홈페이지 성능에 영향을 미치지 않더라도 전체 사이트 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="07c90eda5719a0767b7585d1fae63b890d2df734" translate="yes" xml:space="preserve">
          <source>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">캐시 된 사본을 해제하기 전에 캐시가 유효성 검증을 위해 요청을 오리진 서버에 제출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4634694667d40eda0bbe0a5024383a25099b93b8" translate="yes" xml:space="preserve">
          <source>Forcing HTTPS. Requests to the HTTP version of your site will be redirected to the HTTPS version of your site.</source>
          <target state="translated">HTTPS 강제. 사이트의 HTTP 버전에 대한 요청은 사이트의 HTTPS 버전으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="e65113ef7489ad2e3e6bcd61586a5a6e130fc3a1" translate="yes" xml:space="preserve">
          <source>Forcing lookup of specific hostnames</source>
          <target state="translated">특정 호스트 이름을 강제로 조회</target>
        </trans-unit>
        <trans-unit id="ab88e44a21e56a74ea52f9806dd114accfebc6fd" translate="yes" xml:space="preserve">
          <source>Form factor</source>
          <target state="translated">폼 팩터</target>
        </trans-unit>
        <trans-unit id="d4287342eaedf156edc375518b5469130015c5b1" translate="yes" xml:space="preserve">
          <source>Formatting in HTML</source>
          <target state="translated">HTML 형식</target>
        </trans-unit>
        <trans-unit id="72574aaae0c03841c4924b83ccaa181535815a29" translate="yes" xml:space="preserve">
          <source>Fortunately, as long as you have access to the server's configuration, fixing this is easy. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header supports multiple origins, separated by commas, like this:</source>
          <target state="translated">다행히도 서버 구성에 액세스 할 수 있으면이를 쉽게 수정할 수 있습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 이 같은 쉼표로 구분 된 헤더가 지원하는 여러 기원을, :</target>
        </trans-unit>
        <trans-unit id="88300ac449331e8942e45db76cb6c950d0433ba5" translate="yes" xml:space="preserve">
          <source>Forward proxies</source>
          <target state="translated">정방향 프록시</target>
        </trans-unit>
        <trans-unit id="f39bbf5e0d44588e0ee44ca9d11dbdff07723664" translate="yes" xml:space="preserve">
          <source>Forward proxies can also be anonymous proxies and allow users to hide their IP address while browsing the Web or using other Internet services. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (The Onion Router), routes internet traffic through multiple proxies for anonymity.</source>
          <target state="translated">정방향 프록시는 익명 프록시 일 수 있으며 사용자가 웹을 탐색하거나 다른 인터넷 서비스를 사용하는 동안 IP 주소를 숨길 수 있습니다. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (Onion Router)는 익명 성을 위해 여러 프록시를 통해 인터넷 트래픽을 라우팅합니다.</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="879b7cb814cbc842f6566b4b5009e2ae4c5e4256" translate="yes" xml:space="preserve">
          <source>Forwarded HTTP Extension</source>
          <target state="translated">전달 된 HTTP 확장</target>
        </trans-unit>
        <trans-unit id="a751a7c6f5ebc769cdda2c0d60519a9100785f00" translate="yes" xml:space="preserve">
          <source>Forwarding client information through proxies</source>
          <target state="translated">프록시를 통한 고객 정보 전달</target>
        </trans-unit>
        <trans-unit id="3f19d616ab1973eab54443edad1f469f67e51a95" translate="yes" xml:space="preserve">
          <source>Fragment</source>
          <target state="translated">Fragment</target>
        </trans-unit>
        <trans-unit id="7bf6780ba1203e0c37a2bbe6f2b29b2481023856" translate="yes" xml:space="preserve">
          <source>Frame and message structure in HTTP/2</source>
          <target state="translated">HTTP / 2의 프레임 및 메시지 구조</target>
        </trans-unit>
        <trans-unit id="5b968bd2c47b3621328bcde661b5d00bbb234e51" translate="yes" xml:space="preserve">
          <source>Freshness</source>
          <target state="translated">Freshness</target>
        </trans-unit>
        <trans-unit id="71fec796b8ce84752a371f57c6e5fa7e23101e6f" translate="yes" xml:space="preserve">
          <source>Freshness (RFC 7234)</source>
          <target state="translated">신선도 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="061140cd8957c1a20500ec4735145a4823d87854" translate="yes" xml:space="preserve">
          <source>From (RFC 2616)</source>
          <target state="translated">(RFC 2616)부터</target>
        </trans-unit>
        <trans-unit id="ab25ccd00949ff6aec782bce24f64f443ae8183b" translate="yes" xml:space="preserve">
          <source>From (RFC 7231)</source>
          <target state="translated">(RFC 7231)부터</target>
        </trans-unit>
        <trans-unit id="fc8df84d4beeac0f9b5f8d6d828c77f7b287a76a" translate="yes" xml:space="preserve">
          <source>From the beginnings of HTTP, the protocol allowed another negotiation type: &lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;. In this negotiation, when facing an ambiguous request, the server sends back a page containing links to the available alternative resources. The user is presented the resources and choose the one to use.</source>
          <target state="translated">HTTP의 시작부터 프로토콜은 &lt;em&gt;에이전트 협상&lt;/em&gt; 또는 &lt;em&gt;반응 협상 &lt;/em&gt;&lt;em&gt;과 같은&lt;/em&gt; 다른 협상 유형을 허용했습니다 . 이 협상에서 모호한 요청에 직면하면 서버는 사용 가능한 대체 자원에 대한 링크가 포함 된 페이지를 다시 보냅니다. 사용자에게 리소스가 제공되고 사용할 리소스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2a0830997625a669017113736869c02cdf00c6fb" translate="yes" xml:space="preserve">
          <source>From version 1, Focus is powered by Android WebView and uses the following user agent string format:</source>
          <target state="translated">버전 1부터 Focus는 Android WebView로 구동되며 다음과 같은 사용자 에이전트 문자열 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf2dddbd41ffb807d3f91b7c00d45658b62cbe7d" translate="yes" xml:space="preserve">
          <source>From version 1.1, Firefox for Echo Show uses a user agent string with the following format:</source>
          <target state="translated">버전 1.1부터 Echo Show 용 Firefox는 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="634b1e47168d224b18cc5d200468a1a666ff4f5b" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt;&amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">이후 버전 53에서 도마뱀에서 사용할 수있는 현이 &lt;code&gt;about:config&lt;/code&gt; 사용자가 자신의 기본 설정 할 수 있도록 &lt;code&gt;Referrer-Policy&lt;/code&gt; - &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f46e7fd368eae55073e0a8f47aee34fcd932ec29" translate="yes" xml:space="preserve">
          <source>From version 59 onwards (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;#587523&lt;/a&gt;), this has been replaced by &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; and &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt;.</source>
          <target state="translated">버전 59 이상 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;# 587523&lt;/a&gt; 참조 )에서 &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; 및 &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bb08d10b00a6114f53ac03b662cd5c0fa2fadf2c" translate="yes" xml:space="preserve">
          <source>Fullscreen</source>
          <target state="translated">Fullscreen</target>
        </trans-unit>
        <trans-unit id="d1c21c81f5e9278875fd7faba9e8ce5fee900412" translate="yes" xml:space="preserve">
          <source>Fullscreen API&lt;br/&gt;&lt;small&gt;The definition of 'Fullscreen' in that specification.&lt;/small&gt;</source>
          <target state="translated">전체 화면 API &lt;br/&gt;&lt;small&gt;해당 사양에서 '전체 화면'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4076ad8ca1d493e56ac7306efcb34aa07f0cd" translate="yes" xml:space="preserve">
          <source>Fully qualified hostname to match against.</source>
          <target state="translated">일치하는 완전한 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="70e18d39d91b0bb23213a714597ec6ac0a18898d" translate="yes" xml:space="preserve">
          <source>Functional overview</source>
          <target state="translated">기능 개요</target>
        </trans-unit>
        <trans-unit id="859debff3eb6a95e21550e12eaa3e9501db63349" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfill it.</source>
          <target state="translated">서버가 요청을 이행하려면 요청에 대한 추가 확장이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c09cf39e0efd384b99059d76f22ce0c68ab74478" translate="yes" xml:space="preserve">
          <source>Furthermore, some default values of preferences differ between build configurations, such as platform and locale, which means web sites could identify individual users using this information.</source>
          <target state="translated">또한, 기본 설정의 일부 기본값은 플랫폼 및 로케일과 같은 빌드 구성에 따라 다릅니다. 즉, 웹 사이트가이 정보를 사용하여 개별 사용자를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="828d617ffbd78d6822f9aa5a1a25e2e9a6f4041d" translate="yes" xml:space="preserve">
          <source>GET (RFC 7231)</source>
          <target state="translated">GET (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="889241fb06a8d7a9634f3ef3d8c354487e92626b" translate="yes" xml:space="preserve">
          <source>GET: The resource has been fetched and is transmitted in the message body.</source>
          <target state="translated">GET : 자원이 페치되었으며 메시지 본문에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6e940d0a1449c3f043c3a92ac96eacb89d1691" translate="yes" xml:space="preserve">
          <source>GIF images (lossless compression, superseded by PNG)</source>
          <target state="translated">GIF 이미지 (무손실 압축, PNG로 대체)</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="30b0db79f60240a0079907f498493dc26899f285" translate="yes" xml:space="preserve">
          <source>Gateway or multiple parties. The server is acting as a gateway to an exchange involving multiple parties.</source>
          <target state="translated">게이트웨이 또는 여러 당사자. 서버가 여러 당사자를 포함하는 교환에 대한 게이트웨이 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="75402c80a4e4ffb05b2e1744866544933eef7e16" translate="yes" xml:space="preserve">
          <source>Gecko</source>
          <target state="translated">Gecko</target>
        </trans-unit>
        <trans-unit id="d377c8358e2e4b422fb5f7dadb1f64fb8c95cca2" translate="yes" xml:space="preserve">
          <source>Gecko user agent string</source>
          <target state="translated">도마뱀 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="64f2d81db08b8b5b6d065aef938e7abd5e149546" translate="yes" xml:space="preserve">
          <source>Gecko version number</source>
          <target state="translated">게코 버전 번호</target>
        </trans-unit>
        <trans-unit id="ab051d4c4633073d92cf5eecdf9929aa43fd1d4b" translate="yes" xml:space="preserve">
          <source>Gecko/xyz</source>
          <target state="translated">Gecko/xyz</target>
        </trans-unit>
        <trans-unit id="40fe0205052be8e7ff127e8675aa5f542d969bde" translate="yes" xml:space="preserve">
          <source>General example</source>
          <target state="translated">일반적인 예</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e2a5611d6d492bfc81f68a60efadd4f6151c4e" translate="yes" xml:space="preserve">
          <source>General header</source>
          <target state="translated">일반 헤더</target>
        </trans-unit>
        <trans-unit id="ce7515fe427724c3a8ec1e689f1513ade3494a01" translate="yes" xml:space="preserve">
          <source>General structure</source>
          <target state="translated">일반 구조</target>
        </trans-unit>
        <trans-unit id="2ee8f734456eeec6f1528c29e7b9dd676c82ba5c" translate="yes" xml:space="preserve">
          <source>Geolocation</source>
          <target state="translated">Geolocation</target>
        </trans-unit>
        <trans-unit id="85b8d61e7354b7736b7ec8ca91e1105f85435b65" translate="yes" xml:space="preserve">
          <source>Given this CSP header:</source>
          <target state="translated">이 CSP 헤더가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="4e8b70f78453a41b0760bb603aa5281fa0436163" translate="yes" xml:space="preserve">
          <source>Glossary: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</source>
          <target state="translated">용어집 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bad9e9df904c73f497b664b045343bef194565df" translate="yes" xml:space="preserve">
          <source>Google Chrome handles DNS prefetching control</source>
          <target state="translated">Chrome에서 DNS 프리 페칭 제어 처리</target>
        </trans-unit>
        <trans-unit id="3e389ee93fcba3ef467be442186c13f4427744a6" translate="yes" xml:space="preserve">
          <source>Google Webmaster blog: How to deal with planned site downtime</source>
          <target state="translated">Google 웹 마스터 블로그 : 계획된 사이트 중단 시간을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="ea0c0aed6cf9a0c5b577d1e3a89cbf79500b4710" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;은 HSTS 사전로드 서비스를&lt;/a&gt; 유지 관리 합니다 . 지침에 따라 도메인을 성공적으로 제출하면 브라우저는 안전하지 않은 연결을 사용하여 도메인에 연결하지 않습니다. 서비스가 Google에서 호스팅하는 동안 모든 브라우저는 사전로드 목록을 사용하겠다고 선언했습니다. 그러나 이는 HSTS 사양의 일부가 아니므로 공식적으로 취급해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ef239b0e9b523a211062dd9a992489254f2934aa" translate="yes" xml:space="preserve">
          <source>Governs which referrer information sent in the &lt;a href=&quot;headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header should be included with requests made.</source>
          <target state="translated">이는 리퍼러에 전송되는 정보에 적용 &lt;a href=&quot;headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더 된 요청에 포함되어야한다.</target>
        </trans-unit>
        <trans-unit id="360bdb2acc65ada59d8a23e434964675641d9c45" translate="yes" xml:space="preserve">
          <source>Graceful degradation</source>
          <target state="translated">우아한 저하</target>
        </trans-unit>
        <trans-unit id="14d1e14f4035027adcdfb20a1541aae1745796ae" translate="yes" xml:space="preserve">
          <source>Granular control over certain features</source>
          <target state="translated">특정 기능에 대한 세분화 된 제어</target>
        </trans-unit>
        <trans-unit id="94265c1a4efc21014ed0c288b4d4deab23d58e6c" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format (GIF)</source>
          <target state="translated">그래픽 교환 형식 (GIF)</target>
        </trans-unit>
        <trans-unit id="07dad8754dab2f22b2c67d2717531b2161e04c97" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time. HTTP dates are always expressed in GMT, never in local time.</source>
          <target state="translated">그리니치 표준시. HTTP 날짜는 항상 현지 시간이 아닌 GMT로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="82ee9a2ace2ff133591d7f8cb5b72ca9b839fcd4" translate="yes" xml:space="preserve">
          <source>Guides: Basics</source>
          <target state="translated">안내서 : 기본</target>
        </trans-unit>
        <trans-unit id="6e029883c1d4de187688b7e7b2376708429e4061" translate="yes" xml:space="preserve">
          <source>Gyroscope</source>
          <target state="translated">Gyroscope</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="780c90e89bccb7fed5c8548e6fe499017ad97ffb" translate="yes" xml:space="preserve">
          <source>HEAD (RFC 7231)</source>
          <target state="translated">헤드 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="562b472b05f04a6dd479541dc3fcef670a17fed9" translate="yes" xml:space="preserve">
          <source>HEAD: The entity headers are in the message body.</source>
          <target state="translated">HEAD : 엔티티 헤더가 메시지 본문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c194c3625b9314d21fe00e2a5b33960d2235d75a" translate="yes" xml:space="preserve">
          <source>HPACK: Header Compression for HTTP/2</source>
          <target state="translated">HPACK : HTTP / 2를위한 헤더 압축</target>
        </trans-unit>
        <trans-unit id="f4ce8cef0273faa8edf023797bff38c190bc758e" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommend.</source>
          <target state="translated">HPKP는 잘못 사용하면 사용자를 오랫동안 잠글 수 있습니다! 백업 인증서를 사용하거나 CA 인증서를 고정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc0a0d888f6e163542c2141a305027befded2018" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommended.</source>
          <target state="translated">HPKP는 잘못 사용하면 사용자를 오랫동안 잠글 수 있습니다! 백업 인증서를 사용하거나 CA 인증서를 고정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f7a71b290916b9c6df149f326df62ff64346f837" translate="yes" xml:space="preserve">
          <source>HPKP is a &lt;em&gt;Trust on First Use&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;) technique. The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time. When the client visits the server again, it expects at least one certificate in the certificate chain to contain a public key whose fingerprint is already known via HPKP. If the server delivers an unknown public key, the client should present a warning to the user.</source>
          <target state="translated">HPKP는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt; ( &lt;em&gt;Trust on First Use&lt;/em&gt; ) 기술입니다. 웹 서버가 특수한 HTTP 헤더를 통해 클라이언트에게 어떤 공개 키가 속하는지를 처음 알리면 클라이언트는이 정보를 주어진 기간 동안 저장합니다. 클라이언트가 서버를 다시 방문하면 인증서 체인에있는 하나 이상의 인증서에 HPKP를 통해 지문이 이미 알려진 공개 키가 포함될 것으로 예상됩니다. 서버가 알 수없는 공개 키를 전달하면 클라이언트는 사용자에게 경고를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="57b74ec0b3fb709ed009e59e071a8ce0a9039c38" translate="yes" xml:space="preserve">
          <source>HTML Forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abbe4c282803f8a491f6e980e7fc519bd5a7483" translate="yes" xml:space="preserve">
          <source>HTML Living Standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7098c07bc2151e34df998ef11bad7237b20c9ba" translate="yes" xml:space="preserve">
          <source>HTML Living Standard&lt;br/&gt;&lt;small&gt;The definition of 'document-domain' in that specification.&lt;/small&gt;</source>
          <target state="translated">HTML Living Standard &lt;br/&gt;&lt;small&gt;해당 사양에서 '문서 도메인'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="18d5d7015a5c0d8f94531cdc381221d904d7cbf2" translate="yes" xml:space="preserve">
          <source>HTML files</source>
          <target state="translated">HTML 파일</target>
        </trans-unit>
        <trans-unit id="6390be00d32679564fc38130d4ea8471a4d82c91" translate="yes" xml:space="preserve">
          <source>HTML redirections</source>
          <target state="translated">HTML 리디렉션</target>
        </trans-unit>
        <trans-unit id="7508e59dac25653bfafc78c94cdfff1f91c75f89" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) are executed if there weren't any HTTP redirects.</source>
          <target state="translated">HTTP 리디렉션이없는 경우 HTML 리디렉션 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; )이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="83ef326d5040783a2304cd9c3d4b2741d50432d8" translate="yes" xml:space="preserve">
          <source>HTTP 1.1 recommends the use of ETags rather than modification dates,
   for cache control, and there are even stronger reasons to prefer
   ETags for authoring.  Correct use of ETags is even more important in
   a distributed authoring environment, because ETags are necessary
   along with locks to avoid the lost-update problem.  A client might
   fail to renew a lock, for example, when the lock times out and the
   client is accidentally offline or in the middle of a long upload.
   When a client fails to renew the lock, it's quite possible the
   resource can still be relocked and the user can go on editing, as
   long as no changes were made in the meantime.  ETags are required for
   the client to be able to distinguish this case.  Otherwise, the 

   client is forced to ask the user whether to overwrite the resource on
   the server without even being able to tell the user if it has
   changed.  Timestamps do not solve this problem nearly as well as
   ETags.

   Strong ETags are much more useful for authoring use cases than weak
   ETags (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of [RFC2616]&lt;/a&gt;).  Semantic equivalence can be
   a useful concept but that depends on the document type and the
   application type, and interoperability might require some agreement
   or standard outside the scope of this specification and HTTP.  Note
   also that weak ETags have certain restrictions in HTTP, e.g., these
   cannot be used in If-Match headers.

   Note that the meaning of an ETag in a PUT response is not clearly
   defined either in this document or in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; (i.e., whether the
   ETag means that the resource is octet-for-octet equivalent to the
   body of the PUT request, or whether the server could have made minor
   changes in the formatting or content of the document upon storage).
   This is an HTTP issue, not purely a WebDAV issue.

   Because clients may be forced to prompt users or throw away changed
   content if the ETag changes, a WebDAV server SHOULD NOT change the
   ETag (or the Last-Modified time) for a resource that has an unchanged
   body and location.  The ETag represents the state of the body or
   contents of the resource.  There is no similar way to tell if
   properties have changed.</source>
          <target state="translated">HTTP 1.1은 캐시 제어를 위해 수정 날짜 대신 ETag를 사용하도록 권장하며, 작성을 위해 ETag를 선호해야하는 더 강력한 이유가 있습니다. ETag가 업데이트 손실 문제를 피하기 위해 잠금과 함께 필요하기 때문에 분산 작성 환경에서는 ETag를 올바르게 사용하는 것이 더욱 중요합니다. 예를 들어 잠금 시간이 초과되어 클라이언트가 실수로 오프라인 상태이거나 긴 업로드 도중에 클라이언트가 잠금을 갱신하지 못할 수 있습니다. 클라이언트가 잠금을 갱신하지 못하면 그 동안 변경 사항이없는 한 여전히 리소스를 다시 잠글 수 있고 사용자가 편집을 계속할 수 있습니다. 클라이언트가이 사례를 구별 할 수 있으려면 ETag가 필요합니다. 그렇지 않으면,클라이언트는 변경 여부를 사용자에게 알리지 않고도 서버의 리소스를 덮어 쓸지 여부를 사용자에게 묻습니다. 타임 스탬프는 ETag와 마찬가지로이 문제를 해결하지 못합니다. 강력한 ETag는 약한 ETag보다 사용 사례를 작성하는 데 훨씬 유용합니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;[RFC2616]의 섹션 13.3.3&lt;/a&gt; ). 시맨틱 등가는 유용한 개념이 될 수 있지만 문서 유형 및 애플리케이션 유형에 따라 다르며 상호 운용성을 위해서는이 스펙 및 HTTP의 범위를 벗어나는 일부 계약 또는 표준이 필요할 수 있습니다. 약한 ETag는 HTTP에 특정 제한이 있습니다. 예를 들어 If-Match 헤더에는 사용할 수 없습니다. PUT 응답에서 ETag의 의미는이 문서 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 에 명확하게 정의되어 있지 않습니다.(즉, ETag가 자원이 PUT 요청의 본문과 동일한 옥텟 단위 옥텟인지 또는 서버가 저장시 문서의 형식이나 내용을 약간 변경했는지 여부). 이것은 순수한 WebDAV 문제가 아닌 HTTP 문제입니다. ETag가 변경되면 클라이언트가 사용자에게 프롬프트를 표시하거나 변경된 컨텐츠를 버릴 수 있기 때문에 WebDAV 서버는 변경되지 않는 본문과 위치가있는 자원의 ETag (또는 마지막 수정 시간)를 변경해서는 안됩니다. ETag는 본문의 상태 또는 자원의 내용을 나타냅니다. 속성이 변경되었는지 확인하는 비슷한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="056cc5e9a537351fb174e8ebbb3ca2b1700c2d47" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;</source>
          <target state="translated">HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="392079fd3fa793eb6c0e1335885b8cddafea9ef8" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt;, like those for requests.</source>
          <target state="translated">요청 &lt;a href=&quot;headers&quot;&gt;헤더&lt;/a&gt; 와 같은 HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="7a2ed3fe8a3093e057602abdf74477e83473a214" translate="yes" xml:space="preserve">
          <source>HTTP &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTP &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae47637ce45f4b16c54404dff4cb129bfbe68800" translate="yes" xml:space="preserve">
          <source>HTTP Access Control covering the HTTP headers</source>
          <target state="translated">HTTP 헤더를 다루는 HTTP 액세스 제어</target>
        </trans-unit>
        <trans-unit id="d601b5bb2c1cad46bb9aa46a3ee39b64315236e7" translate="yes" xml:space="preserve">
          <source>HTTP Alternative Services</source>
          <target state="translated">HTTP 대체 서비스</target>
        </trans-unit>
        <trans-unit id="965e2184c8e7927a43f2bee90d3f5ececba434b6" translate="yes" xml:space="preserve">
          <source>HTTP Cache</source>
          <target state="translated">HTTP 캐시</target>
        </trans-unit>
        <trans-unit id="f54d56b271b9875e48fe27b600b0dc067a9f284e" translate="yes" xml:space="preserve">
          <source>HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">오래된 컨텐츠를위한 HTTP 캐시 제어 확장</target>
        </trans-unit>
        <trans-unit id="6c1e735662c0178e6f3fe960f4930ffeabb6f7fe" translate="yes" xml:space="preserve">
          <source>HTTP Caching FAQ</source>
          <target state="translated">HTTP 캐싱 FAQ</target>
        </trans-unit>
        <trans-unit id="0b0260299fa380d7d3a7ccc7edbf8a208c829f61" translate="yes" xml:space="preserve">
          <source>HTTP Client Hints</source>
          <target state="translated">HTTP 클라이언트 힌트</target>
        </trans-unit>
        <trans-unit id="17e0afd9e45a02ae60f6b6aed60a68bef13f3af0" translate="yes" xml:space="preserve">
          <source>HTTP Conditional Requests</source>
          <target state="translated">HTTP 조건부 요청</target>
        </trans-unit>
        <trans-unit id="186213537e6fba63d1dd994c6c9b358b6f840caf" translate="yes" xml:space="preserve">
          <source>HTTP Cookies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2fa3648597031d5a833b5724263dbfd920c241" translate="yes" xml:space="preserve">
          <source>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</source>
          <target state="translated">WebDAV (Web Distributed Authoring and Versioning)를위한 HTTP 확장</target>
        </trans-unit>
        <trans-unit id="6cee8a3bc57d158b257c68ed73852449cb27b716" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options</source>
          <target state="translated">HTTP 헤더 필드 X- 프레임 옵션</target>
        </trans-unit>
        <trans-unit id="f88eb2164f3dbd137bca83f451898992e6e6b039" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options - RFC 7034</source>
          <target state="translated">HTTP 헤더 필드 X- 프레임 옵션-RFC 7034</target>
        </trans-unit>
        <trans-unit id="cc46670cd995848df63f3703c3400f81060dd482" translate="yes" xml:space="preserve">
          <source>HTTP Headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d09479cf8d4e2b8c35798b4a19c06e1f5461b3" translate="yes" xml:space="preserve">
          <source>HTTP Immutable Responses</source>
          <target state="translated">HTTP 불변의 응답</target>
        </trans-unit>
        <trans-unit id="dc68b45ed9f862b4a9cd7aa0be2cfbc7e016a6ef" translate="yes" xml:space="preserve">
          <source>HTTP Message (RFC 2616)</source>
          <target state="translated">HTTP 메시지 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="645acbbc29e90c2c68542670b051cdcea02987bc" translate="yes" xml:space="preserve">
          <source>HTTP Messages</source>
          <target state="translated">HTTP 메시지</target>
        </trans-unit>
        <trans-unit id="583d9f510824dc860b8faad49ebe7579ffd29c0b" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure; this introductory article describes this structure, its purpose and its possibilities.</source>
          <target state="translated">요청 또는 응답 중에 전송 된 HTTP 메시지는 매우 명확한 구조를 갖습니다. 이 기사에서는이 구조, 목적 및 가능성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="94fdc3e6f5c751d82295ac7ade9d715a4814c0d4" translate="yes" xml:space="preserve">
          <source>HTTP Request Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7402660b7ec42f5008e637f7d416a9463ae2ce2f" translate="yes" xml:space="preserve">
          <source>HTTP Responses</source>
          <target state="translated">HTTP 응답</target>
        </trans-unit>
        <trans-unit id="1e3c49a8c708be92f5037401d92246426a46dc11" translate="yes" xml:space="preserve">
          <source>HTTP State Management Mechanism</source>
          <target state="translated">HTTP 상태 관리 메커니즘</target>
        </trans-unit>
        <trans-unit id="a5fc269de1ce9034a5e3e1936288b84520462ea3" translate="yes" xml:space="preserve">
          <source>HTTP Status Response Codes</source>
          <target state="translated">HTTP 상태 응답 코드</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HSTS (HTTP Strict Transport Security)</target>
        </trans-unit>
        <trans-unit id="cbc09a66647a44074ee04da1ac1771e8479c9d8b" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to a communicate with different &lt;em&gt;resources&lt;/em&gt; on Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTP를 사용하면 브라우저 또는 다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 인터넷의 다른 &lt;em&gt;자원&lt;/em&gt; 과 통신 할 수 &lt;em&gt;있습니다&lt;/em&gt; .이를 수행하려면 브라우저 에 자원 의 &lt;em&gt;ID&lt;/em&gt; 와 &lt;em&gt;위치&lt;/em&gt; 가 모두 필요 합니다. 이 두 비트 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt; 로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d82f24e44e689920296a131052df78d102bbaff" translate="yes" xml:space="preserve">
          <source>HTTP and WebDAV did not use the bodies of most error responses for
   machine-parsable information until the specification for Versioning
   Extensions to WebDAV introduced a mechanism to include more specific
   information in the body of an error response (&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;Section&amp;nbsp;1.6 of
   [RFC3253]&lt;/a&gt;).  The error body mechanism is appropriate to use with any
   error response that may take a body but does not already have a body
   defined.  The mechanism is particularly appropriate when a status
   code can mean many things (for example, 400 Bad Request can mean
   required headers are missing, headers are incorrectly formatted, or
   much more).  This error body mechanism is covered in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;.</source>
          <target state="translated">HTTP 및 WebDAV는 WebDAV에 대한 버전 화 확장 스펙에서 오류 응답 본문에보다 구체적인 정보를 포함하는 메커니즘을 도입 할 때까지 기계 구문 분석 가능한 정보에 대해 대부분의 오류 응답 본문을 사용하지 않았습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;[RFC3253]의 1.6 절&lt;/a&gt; ). 오류 본문 메커니즘은 본문을 취할 수 있지만 아직 본문이 정의되지 않은 오류 응답과 함께 사용하기에 적합합니다. 이 메커니즘은 상태 코드가 많은 것을 의미 할 때 특히 적합합니다 (예 : 400 잘못된 요청은 필요한 헤더가 누락되었거나 헤더의 형식이 잘못되었거나 더 많음을 의미 할 수 있음). 이 오류 본문 메커니즘은 &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="170502bb0d853c3d72e45f0eef9c00311f2253c6" translate="yes" xml:space="preserve">
          <source>HTTP and connections</source>
          <target state="translated">HTTP 및 연결</target>
        </trans-unit>
        <trans-unit id="70e2789624d7913484672252eb44130b859ad66a" translate="yes" xml:space="preserve">
          <source>HTTP applications have historically allowed three different formats
   for the representation of date/time stamps:

      Sun, 06 Nov 1994 08:49:37 GMT  ; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;
      Sunday, 06-Nov-94 08:49:37 GMT ; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

   The first format is preferred as an Internet standard and represents
   a fixed-length subset of that defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;] (an update to
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]). The second format is in common use, but is based on the
   obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [&lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] date format and lacks a four-digit year.
   HTTP/1.1 clients and servers that parse the date value MUST accept
   all three formats (for compatibility with HTTP/1.0), though they MUST
   only generate the &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; format for representing HTTP-date values
   in header fields. See &lt;a href=&quot;#section-19.3&quot;&gt;section 19.3&lt;/a&gt; for further information.

      Note: Recipients of date values are encouraged to be robust in
      accepting date values that may have been sent by non-HTTP
      applications, as is sometimes the case when retrieving or posting
      messages via proxies/gateways to SMTP or NNTP. 

   All HTTP date/time stamps MUST be represented in Greenwich Mean Time
   (GMT), without exception. For the purposes of HTTP, GMT is exactly
   equal to UTC (Coordinated Universal Time). This is indicated in the
   first two formats by the inclusion of &quot;GMT&quot; as the three-letter
   abbreviation for time zone, and MUST be assumed when reading the
   asctime format. HTTP-date is case sensitive and MUST NOT include
   additional LWS beyond that specifically included as SP in the
   grammar.

       HTTP-date    = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date | &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date | asctime-date
       &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                    | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
       weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                    | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
       month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                    | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                    | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream. Clients and servers are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">HTTP 응용 프로그램은 역사적으로 날짜 / 시간 스탬프를 표시하기 위해 세 가지 다른 형식을 허용했습니다. Sun, 06 Nov 1994 08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123에&lt;/a&gt; 의해 업데이트 됨 06-Nov-94 08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;1036에&lt;/a&gt; 의해 폐기 된 RFC 850 Sun Nov 6 08:49:37 1994; ANSI C의 asctime () 형식 첫 번째 형식은 인터넷 표준으로 선호되며 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ] ( &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]에 대한 업데이트)에서 정의한 고정 길이 하위 집합을 나타냅니다 . 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [ &lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] 날짜 형식이며 4 자리 연도가 없습니다. 날짜 값을 구문 분석하는 HTTP / 1.1 클라이언트 및 서버는 세 가지 형식 (HTTP / 1.0과의 호환성을 위해)을 모두 수용해야하지만 헤더 필드에 HTTP 날짜 값을 표시하기위한 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 형식 만 생성해야 합니다. &lt;a href=&quot;#section-19.3&quot;&gt;섹션 19.3&lt;/a&gt; 참조자세한 내용은. 참고 : 프록시 / 게이트웨이를 통해 SMTP 또는 NNTP로 메시지를 검색하거나 게시 할 때와 같이 날짜 값을받는 사람은 HTTP가 아닌 응용 프로그램에서 보낸 날짜 값을 받아들이는 것이 좋습니다. 모든 HTTP 날짜 / 시간 스탬프는 예외없이 그리니치 표준시 (GMT)로 표시되어야합니다. HTTP의 목적으로 GMT는 UTC (협정 세계시)와 정확히 같습니다. 이것은 표준 시간대의 3 자리 약어로 &quot;GMT&quot;를 포함하여 처음 두 형식으로 표시되며 asctime 형식을 읽을 때 가정해야합니다. HTTP- 날짜는 대소 문자를 구분하며 문법에 SP로 포함 된 것 이외의 추가 LWS를 포함해서는 안됩니다.HTTP- 날짜 = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date |&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850-날짜&lt;/a&gt; | asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date = wkday &quot;,&quot;SP 날짜 1 SP 시간 SP &quot;GMT&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = weekday &quot;,&quot;SP date2 SP 시간 SP &quot;GMT&quot;asctime-date = wkday SP 날짜 3 SP 시간 SP 4DIGIT 날짜 1 = 2DIGIT SP 월 SP 4DIGIT; 일 월 년도 (예 : 1982 년 6 월 02 일) date2 = 2DIGIT &quot;-&quot;month &quot;-&quot;2DIGIT; 일-월-년 (예 : 02-Jun-82) date3 = 월 SP (2DIGIT | (SP 1DIGIT)); 월 일 (예 : 6 월 2 일) time = 2DIGIT &quot;:&quot;2DIGIT &quot;:&quot;2DIGIT; 00:00:00-23:59:59 wkday = &quot;월&quot;| &quot;화&quot;| &quot;수&quot;| &quot;목&quot;| &quot;금&quot;| &quot;토&quot;| &quot;일&quot;주중 = &quot;월요일&quot;| &quot;화요일&quot;| &quot;수요일&quot;| &quot;목요일 &quot;|&quot;금요일 &quot;|&quot;토요일 &quot;|&quot;일요일 &quot;월 =&quot;1 월 &quot;|&quot;2 월 &quot;|&quot;3 월 &quot;|&quot;4 월 &quot;|&quot;5 월 &quot;|&quot;6 월 &quot;|&quot;7 월 &quot;|&quot;8 월 &quot;|&quot;9 월 &quot;|&quot;Oct &quot;|&quot;Nov &quot;|&quot;Dec &quot;참고 : 날짜 / 시간 소인 형식의 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 사용자 표시, 요청 로깅에 이러한 형식을 사용할 필요가 없습니다. 등| &quot;9 월&quot;| &quot;10 월&quot;| &quot;11 월&quot;| &quot;12 월&quot;참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 이러한 형식을 사용자 프리젠 테이션, 요청 로깅 등에 사용할 필요가 없습니다.| &quot;9 월&quot;| &quot;10 월&quot;| &quot;11 월&quot;| &quot;12 월&quot;참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 이러한 형식을 사용자 프리젠 테이션, 요청 로깅 등에 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cd45603fb781257153f9081597101ece177c7d0" translate="yes" xml:space="preserve">
          <source>HTTP authentication</source>
          <target state="translated">HTTP 인증</target>
        </trans-unit>
        <trans-unit id="ab4ed2ef5f3094275f004bff5889feddcf0ad10a" translate="yes" xml:space="preserve">
          <source>HTTP caching &amp;ndash; Ilya Grigorik</source>
          <target state="translated">HTTP 캐싱 &amp;ndash; Ilya Grigorik</target>
        </trans-unit>
        <trans-unit id="bc0f4dfb9b0a4bec403f49cd2c2239e560902813" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</source>
          <target state="translated">HTTP 캐싱은 선택 사항이지만 일반적으로 캐시 된 리소스를 재사용하는 것이 좋습니다. 그러나 일반적인 HTTP 캐시는 일반적으로 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 에&lt;/a&gt; 대한 응답 캐싱으로 제한되며 다른 방법을 거부 할 수 있습니다. 기본 캐시 키는 요청 방법과 대상 URI로 구성됩니다 (종종 GET 요청 만 대상을 캐시하므로 URI 만 사용됨). 캐싱 항목의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64f23433ac676ea06e9a1900351a7ac4a13f68a1" translate="yes" xml:space="preserve">
          <source>HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response MAY be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.

   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen. 

   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.

   If an origin server wishes to force a semantically transparent cache
   to validate every request, it MAY assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache SHOULD validate it before using it for subsequent requests. See
   &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt; for a more restrictive way to force revalidation.

   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it SHOULD use the &quot;must-
   revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.

   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See &lt;a href=&quot;#section-13.13&quot;&gt;section 13.13&lt;/a&gt; for an explanation of the difference between caches
   and history mechanisms.</source>
          <target state="translated">HTTP 캐싱은 캐시가 오리진 서버에 대한 요청을 완전히 피할 수있을 때 가장 잘 작동합니다. 요청을 피하기위한 기본 메커니즘은 오리진 서버가 미래에 명시적인 만료 시간을 제공하여 후속 요청을 충족시키기 위해 응답을 사용할 수 있음을 나타냅니다. 다시 말해, 캐시는 먼저 서버에 접속하지 않고도 새로운 응답을 반환 할 수 있습니다. 우리는 서버가 만료 시간에 도달하기 전에 의미 적으로 중요한 방식으로 변경되지 않을 것이라는 믿음으로 서버가 미래의 명시적인 만료 시간을 응답에 할당 할 것으로 기대합니다. 일반적으로 서버의 만료 시간을 신중하게 선택하는 한 의미 적 투명성을 유지합니다.만기 메커니즘은 캐시에서 가져온 응답에만 적용되며 요청 클라이언트에게 즉시 전달되는 직접 응답에는 적용되지 않습니다. 오리진 서버가 의미 적으로 투명한 캐시가 모든 요청의 유효성을 검사하도록하려면 과거에 명시적인 만료 시간을 할당 할 수 있습니다. 이는 응답이 항상 유효하지 않기 때문에 캐시는 후속 요청에 응답을 사용하기 전에 응답을 확인해야한다는 것을 의미합니다. 보다 &lt;a href=&quot;#section-14.9.4&quot;&gt;&lt;/a&gt;재 검증을 강제하는보다 제한적인 방법에 대해서는 14.9.4 절을 참조하십시오 . 오리진 서버가 HTTP / 1.1 캐시를 강제로 구성하려는 경우, 모든 요청의 유효성을 검사하기 위해 구성 방식에 관계없이 &quot;must-revaldate&quot;캐시 제어 지시문을 사용해야합니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; 참조 ). 서버는 Expires 헤더 또는 Cache-Control 헤더의 max-age 지시문을 사용하여 명시적인 만료 시간을 지정합니다. 사용자 에이전트가 표시를 새로 고치거나 자원을 다시로드하도록 만료 시간을 사용할 수 없습니다. 시맨틱은 캐싱 메커니즘에만 적용되며 이러한 메커니즘은 해당 자원에 대한 새 요청이 시작될 때 자원의 만료 상태 만 확인하면됩니다. &lt;a href=&quot;#section-13.13&quot;&gt;섹션 13.13&lt;/a&gt; 참조 캐시와 히스토리 메커니즘의 차이점에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="7f76c971673910b6c1b10deaca8522002aada40e" translate="yes" xml:space="preserve">
          <source>HTTP clients are often privy to large amounts of personal information
   (e.g. the user's name, location, mail address, passwords, encryption
   keys, etc.), and SHOULD be very careful to prevent unintentional
   leakage of this information via the HTTP protocol to other sources.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.</source>
          <target state="translated">HTTP 클라이언트는 많은 양의 개인 정보 (예 : 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등)에 대해 독점적이며, HTTP 프로토콜을 통해 다른 소스로이 정보가 의도하지 않게 유출되지 않도록주의해야합니다. . 사용자가 그러한 정보의 보급을 제어 할 수있는 편리한 인터페이스를 제공 할 것을 강력히 권장하며, 설계자와 구현자는이 영역에 특히주의해야합니다. 역사에 따르면이 영역의 오류로 인해 심각한 보안 및 / 또는 개인 정보 보호 문제가 발생하고 구현 자 회사에 대한 부정적인 평판이 높아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0593fb953516cec3cb50e486b7c0cd80aa7ff135" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests</source>
          <target state="translated">HTTP 조건부 요청</target>
        </trans-unit>
        <trans-unit id="a24d61eed6303644578268bb7ece0c747329e619" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.</source>
          <target state="translated">HTTP 조건부 요청은 특정 헤더 값에 따라 다르게 실행되는 요청입니다. 이 헤더는 전제 조건을 정의하며 전제 조건이 일치하는지 여부에 따라 요청 결과가 달라집니다.</target>
        </trans-unit>
        <trans-unit id="7cb9523b16d3c9a97f6ddd095333da9f953ccd3f" translate="yes" xml:space="preserve">
          <source>HTTP content negotiation (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) uses short &quot;floating point&quot;
   numbers to indicate the relative importance (&quot;weight&quot;) of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications MUST NOT generate more than three digits after the
   decimal point. User configuration of these values SHOULD also be
   limited in this fashion.

       qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                      | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   &quot;Quality values&quot; is a misnomer, since these values merely represent
   relative degradation in desired quality.</source>
          <target state="translated">HTTP 컨텐츠 협상 ( &lt;a href=&quot;#section-12&quot;&gt;섹션 12&lt;/a&gt; )은 짧은 &quot;부동 소수점&quot;숫자를 사용하여 다양한 협상 가능한 매개 변수의 상대적 중요도 ( &quot;무게&quot;)를 나타냅니다. 가중치는 0에서 1 사이의 실수로 정규화되며, 여기서 0은 최소값이고 1은 최대 값입니다. 매개 변수의 품질 값이 0이면이 매개 변수를 가진 컨텐츠는 클라이언트에 대해 '허용되지 않습니다'. HTTP / 1.1 응용 프로그램은 소수점 뒤에 세 자리 이상을 생성해서는 안됩니다 (MUST NOT). 이러한 값의 사용자 구성도이 방식으로 제한해야합니다. qvalue = ( &quot;0&quot;[ &quot;.&quot;0 * 3DIGIT]) | ( &quot;1&quot;[ &quot;.&quot;0 * 3 ( &quot;0&quot;)]) &quot;품질 값&quot;은 잘못된 이름입니다.이들 값은 단지 원하는 품질에서의 상대적 열화를 나타 내기 때문이다.</target>
        </trans-unit>
        <trans-unit id="7b89b9e50093443d13f8d95c6b289f93dce89159" translate="yes" xml:space="preserve">
          <source>HTTP cookie</source>
          <target state="translated">HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="49bceea2f43dd4ce87f70babc4ac786f9373fb9b" translate="yes" xml:space="preserve">
          <source>HTTP cookie on Wikipedia</source>
          <target state="translated">Wikipedia의 HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="d913ef28f4b5c9d1334d825b1c91fdfabe426299" translate="yes" xml:space="preserve">
          <source>HTTP cookies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d449bb5c3598a5a64c8ae94493892b59bad9bafe" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;a href=&quot;methods&quot;&gt;request methods&lt;/a&gt; indicating the desired action to be performed upon a resource. Although they can also be nouns, these requests methods are sometimes referred as HTTP verbs. The most common requests are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;:</source>
          <target state="translated">HTTP는 자원에 대해 수행 할 원하는 조치를 나타내는 &lt;a href=&quot;methods&quot;&gt;요청 메소드&lt;/a&gt; 세트를 정의 합니다. 또한 명사 일 수도 있지만 이러한 요청 메소드를 HTTP 동사라고도합니다. 가장 일반적인 요청은 &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;POST&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="30ad447e6db12c17885856bdde1f5bd54513584a" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTP는 주어진 자원에 대해 수행 할 원하는 조치를 표시 &lt;strong&gt;하기&lt;/strong&gt; 위해 &lt;strong&gt;요청 메소드&lt;/strong&gt; 세트를 정의 합니다. 그것들은 또한 명사 일 수 있지만, 이러한 요청 메소드는 때때로 &lt;em&gt;HTTP 동사&lt;/em&gt; 라고도 합니다. 그들 각각은 서로 다른 의미를 구현하지만, 몇 가지 공통적 인 특징은 그 그룹에 의해 공유 : 할 수 있습니다 예를 들어, 요청 방법 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;나무 등&lt;/a&gt; , 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;캐시&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b3823907860c4fbcb228c6adf9d8a7633b5e997" translate="yes" xml:space="preserve">
          <source>HTTP defines many headers that can be used in WebDAV requests and
   responses.  Not all of these are appropriate in all situations and
   some interactions may be undefined.  Note that HTTP 1.1 requires the
   Date header in all responses if possible (see &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).

   The server MUST do authorization checks before checking any HTTP
   conditional header.</source>
          <target state="translated">HTTP는 WebDAV 요청 및 응답에 사용할 수있는 많은 헤더를 정의합니다. 이러한 상황이 모든 상황에 적합한 것은 아니며 일부 상호 작용이 정의되지 않을 수 있습니다. HTTP 1.1은 가능한 경우 모든 응답에 Date 헤더가 필요합니다 ( &lt;a href=&quot;#section-14.18&quot;&gt;14.18 절&lt;/a&gt; , [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 참조). 서버는 HTTP 조건부 헤더를 확인하기 전에 권한 확인을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a133de8128e059a1d8a37cda84e730f09f27e2d" translate="yes" xml:space="preserve">
          <source>HTTP defines the Location header to indicate a preferred URL for the
   resource that was addressed in the Request-URI (e.g., in response to
   successful PUT requests or in redirect responses).  However, use of
   this header creates ambiguity when there are URLs in the body of the
   response, as with Multi-Status.  Thus, use of the Location header
   with the Multi-Status response is intentionally undefined.</source>
          <target state="translated">HTTP는 Location 헤더를 정의하여 Request-URI에서 주소가 지정된 리소스에 대한 선호 URL을 나타냅니다 (예 : 성공적인 PUT 요청에 대한 응답 또는 리디렉션 응답). 그러나이 헤더를 사용하면 다중 상태와 같이 응답 본문에 URL이있을 때 모호성이 생깁니다. 따라서 다중 상태 응답과 함께 위치 헤더를 사용하는 것은 의도적으로 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a87bd3891b7e9c3d201f6e5eb6fa13e129baa69" translate="yes" xml:space="preserve">
          <source>HTTP didn't stop evolving upon the release of HTTP/2. Like with HTTP/1.x previously, HTTP's extensibility is still being used to add new features. Notably, we can cite new extensions of the HTTP protocol appearing in 2016:</source>
          <target state="translated">HTTP / 2가 릴리스 될 때 HTTP의 발전이 멈추지 않았습니다. HTTP / 1.x와 마찬가지로 HTTP의 확장 성은 여전히 ​​새로운 기능을 추가하는 데 사용되고 있습니다. 특히 2016 년에 등장하는 새로운 HTTP 프로토콜 확장을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b88a5eff6f325b12d08c43e0aa22f6a60e181d3d" translate="yes" xml:space="preserve">
          <source>HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completeness.  Additional integrity
   mechanisms, such as hash functions or digital signatures applied to
   the content, can be selectively added to messages via extensible 

   metadata header fields.  Historically, the lack of a single integrity
   mechanism has been justified by the informal nature of most HTTP
   communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within
   environments where verification of message integrity is crucial.

   User agents are encouraged to implement configurable means for
   detecting and reporting failures of message integrity such that those
   means can be enabled within environments for which integrity is
   necessary.  For example, a browser being used to view medical history
   or drug interaction information needs to indicate to the user when
   such information is detected by the protocol to be incomplete,
   expired, or corrupted during transfer.  Such mechanisms might be
   selectively enabled via user agent extensions or the presence of
   message integrity metadata in a response.  At a minimum, user agents
   ought to provide some indication that allows a user to distinguish
   between a complete and incomplete response message (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;) when
   such verification is desired.</source>
          <target state="translated">HTTP는 메시지 무결성을 보장하기위한 특정 메커니즘을 정의하지 않고 기본 전송 프로토콜의 오류 감지 기능과 길이 또는 청크로 구분 된 프레이밍을 사용하여 완전성을 감지합니다. 컨텐츠에 적용된 해시 함수 또는 디지털 서명과 같은 추가 무결성 메커니즘은 확장 가능한 메타 데이터 헤더 필드를 통해 메시지에 선택적으로 추가 될 수 있습니다. 역사적으로 단일 무결성 메커니즘의 부재는 대부분의 HTTP 통신의 비공식적 특성에 의해 정당화되었습니다. 그러나 정보 액세스 메커니즘으로서 HTTP의 보급으로 인해 메시지 무결성 검증이 중요한 환경에서 사용이 증가하고 있습니다.사용자 에이전트는 메시지 무결성 오류를 감지하고보고하기 위해 구성 가능한 수단을 구현하여 무결성이 필요한 환경 내에서 이러한 수단을 사용할 수 있도록하는 것이 좋습니다. 예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료되거나 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 표시를 제공해야합니다 (예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료되거나 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 표시를 제공해야합니다 (예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료되거나 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 표시를 제공해야합니다 (이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 표시를 제공해야합니다 (이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 표시를 제공해야합니다 (&lt;a href=&quot;#section-3.4&quot;&gt;&lt;/a&gt;그러한 검증이 필요한 경우 섹션 3.4 ).</target>
        </trans-unit>
        <trans-unit id="87d2894d742e24a75af2f1ab57c0987684b7ec4b" translate="yes" xml:space="preserve">
          <source>HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond
   exactly to the order in which requests are made on the same
   connection.  More than one response message per request only occurs
   when one or more informational responses (1xx, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Section&amp;nbsp;6.2 of
   [RFC7231]&lt;/a&gt;) precede a final response to the same request. 

   A client that has more than one outstanding request on a connection
   MUST maintain a list of outstanding requests in the order sent and
   MUST associate each received response message on that connection to
   the highest ordered request that has not yet received a final
   (non-1xx) response.</source>
          <target state="translated">HTTP는 주어진 요청 메시지를 해당하는 하나 이상의 응답 메시지와 연관시키기위한 요청 식별자를 포함하지 않습니다. 따라서 동일한 연결에서 요청이 이루어진 순서와 정확히 일치하도록 응답 도착 순서에 의존합니다. 요청 당 하나 이상의 응답 메시지는 하나 이상의 정보 응답 (1xx, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231]의 섹션 6.2&lt;/a&gt; 참조 )이 동일한 요청에 대한 최종 응답 앞에 오는 경우에만 발생합니다 . 연결에서 미해결 요청이 둘 이상인 클라이언트는 전송 된 미해결 요청 목록을 전송 된 순서대로 유지해야하며 해당 연결에서 수신 된 각 응답 메시지를 아직 최종 (1xx 아님)을받지 않은 최상위 주문 요청과 연결해야합니다. 응답.</target>
        </trans-unit>
        <trans-unit id="125fe50c360004e5dcd111f8af56cce35d120574" translate="yes" xml:space="preserve">
          <source>HTTP does not place a predefined limit on the length of each header
   field or on the length of the header section as a whole, as described
   in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  Various ad hoc limitations on individual header
   field length are found in practice, often depending on the specific
   field semantics.

   A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   A client MAY discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are
   such that the dropped value(s) can be safely ignored without changing
   the message framing or response semantics.</source>
          <target state="translated">HTTP는 &lt;a href=&quot;#section-2.5&quot;&gt;2.5 절&lt;/a&gt; 에서 설명한 것처럼 각 헤더 필드의 길이 또는 헤더 섹션의 길이에 미리 정의 된 제한을 두지 않습니다 . 개별 헤더 필드 길이에 대한 다양한 임시 제한은 실제로 특정 필드 의미에 따라 실제로 발견됩니다. 처리하고자하는 것보다 큰 요청 헤더 필드 또는 필드 세트를 수신하는 서버는 반드시 적절한 4xx (클라이언트 오류) 상태 코드로 응답해야합니다. 이러한 헤더 필드를 무시하면 밀수 공격을 요청하는 서버의 취약성이 증가합니다 ( &lt;a href=&quot;#section-9.5&quot;&gt;9.5 절&lt;/a&gt;). 필드 시맨틱이 메시지 프레이밍 또는 응답 시맨틱을 변경하지 않고 드롭 된 값 (들)을 안전하게 무시할 수있는 경우, 클라이언트는 처리하고자하는 것보다 큰 수신 된 헤더 필드를 폐기 또는 절단 할 수있다 (MAY).</target>
        </trans-unit>
        <trans-unit id="7af78e2e7197dc15cd8324e0e4f1f29b3b33d7e4" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding (CTE) field of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways from MIME-compliant protocols to HTTP MUST
   remove any non-identity CTE (&quot;quoted-printable&quot; or &quot;base64&quot;) encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe 

   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway SHOULD label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.</source>
          <target state="translated">HTTP는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; 의 CTE (Content-Transfer-Encoding) 필드를 사용하지 않습니다 . MIME 호환 프로토콜에서 HTTP 로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 ID가 아닌 CTE ( &quot;인쇄 가능&quot;또는 &quot;base64&quot;) 인코딩을 제거해야합니다. HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을위한 올바른 형식 및 인코딩인지 확인해야합니다. 여기서 &quot;안전한 전송&quot;은 사용중인 프로토콜의 한계에 의해 정의됩니다. 그러한 프록시 또는 게이트웨이는 데이터를 적절한 콘텐츠 전송 인코딩으로 라벨링해야 목적지 프로토콜을 통한 안전한 전송 가능성을 향상시켜야한다.</target>
        </trans-unit>
        <trans-unit id="983fa6dde64a744fecec4d6eaeb6ead62114677a" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe
   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.</source>
          <target state="translated">HTTP는 MIME의 Content-Transfer-Encoding 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP 로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 모든 컨텐츠 전송 인코딩을 제거해야합니다. HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을위한 올바른 형식 및 인코딩인지 확인해야합니다. 여기서 &quot;안전한 전송&quot;은 사용중인 프로토콜의 한계에 의해 정의됩니다. 이러한 프록시 또는 게이트웨이는 데이터를 적절한 Content-Transfer-Encoding으로 변환하고 레이블을 지정해야 목적지 프로토콜을 통한 안전한 전송 가능성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="b9046bf180bf7e78db825b7e37fce06636dac2f9" translate="yes" xml:space="preserve">
          <source>HTTP enables the use of intermediaries to satisfy requests through a
   chain of connections.  There are three common forms of HTTP
   intermediary: proxy, gateway, and tunnel.  In some cases, a single
   intermediary might act as an origin server, proxy, gateway, or
   tunnel, switching behavior based on the nature of each request.

            &amp;gt;             &amp;gt;             &amp;gt;             &amp;gt;
       UA =========== A =========== B =========== C =========== O
                  &amp;lt;             &amp;lt;             &amp;lt;             &amp;lt;

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server.  A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options might apply only to the connection
   with the nearest, non-tunnel neighbor, only to the endpoints of the
   chain, or to all connections along the chain.  Although the diagram
   is linear, each participant might be engaged in multiple,
   simultaneous communications.  For example, B might be receiving
   requests from many clients other than A, and/or forwarding requests
   to servers other than C, at the same time that it is handling A's 

   request.  Likewise, later requests might be sent through a different
   path of connections, often based on dynamic configuration for load
   balancing.

   The terms &quot;upstream&quot; and &quot;downstream&quot; are used to describe
   directional requirements in relation to the message flow: all
   messages flow from upstream to downstream.  The terms &quot;inbound&quot; and
   &quot;outbound&quot; are used to describe directional requirements in relation
   to the request route: &quot;inbound&quot; means toward the origin server and
   &quot;outbound&quot; means toward the user agent.

   A &quot;proxy&quot; is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some
   translations are minimal, such as for proxy requests for &quot;http&quot; URIs,
   whereas other requests might require translation to and from entirely
   different application-level protocols.  Proxies are often used to
   group an organization's HTTP requests through a common intermediary
   for the sake of security, annotation services, or shared caching.
   Some proxies are designed to apply transformations to selected
   messages or payloads while they are being forwarded, as described in
   &lt;a href=&quot;#section-5.7.2&quot;&gt;Section 5.7.2&lt;/a&gt;.

   A &quot;gateway&quot; (a.k.a. &quot;reverse proxy&quot;) is an intermediary that acts as
   an origin server for the outbound connection but translates received
   requests and forwards them inbound to another server or servers.
   Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   &quot;accelerator&quot; caching, and to enable partitioning or load balancing
   of HTTP services across multiple machines.

   All HTTP requirements applicable to an origin server also apply to
   the outbound communication of a gateway.  A gateway communicates with
   inbound servers using any protocol that it desires, including private
   extensions to HTTP that are outside the scope of this specification.
   However, an HTTP-to-HTTP gateway that wishes to interoperate with
   third-party HTTP servers ought to conform to user agent requirements
   on the gateway's inbound connection.

   A &quot;tunnel&quot; acts as a blind relay between two connections without
   changing the messages.  Once active, a tunnel is not considered a
   party to the HTTP communication, though the tunnel might have been
   initiated by an HTTP request.  A tunnel ceases to exist when both
   ends of the relayed connection are closed.  Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) is used to establish
   confidential communication through a shared firewall proxy. 

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also
   intermediaries that can act on lower layers of the network protocol
   stack, filtering or redirecting HTTP traffic without the knowledge or
   permission of message senders.  Network intermediaries are
   indistinguishable (at a protocol level) from a man-in-the-middle
   attack, often introducing security flaws or interoperability problems
   due to mistakenly violating HTTP semantics.

   For example, an &quot;interception proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt;] (also commonly known
   as a &quot;transparent proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] or &quot;captive portal&quot;) differs from
   an HTTP proxy because it is not selected by the client.  Instead, an
   interception proxy filters or redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic).  Interception proxies
   are commonly found on public network access points, as a means of
   enforcing account subscription prior to allowing use of non-local
   Internet services, and within corporate firewalls to enforce network
   usage policies.

   HTTP is defined as a stateless protocol, meaning that each request
   message can be understood in isolation.  Many implementations depend
   on HTTP's stateless design in order to reuse proxied connections or
   dynamically load balance requests across multiple servers.  Hence, a
   server MUST NOT assume that two requests on the same connection are
   from the same user agent unless the connection is secured and
   specific to that agent.  Some non-standard HTTP extensions (e.g.,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt;]) have been known to violate this requirement, resulting in
   security and interoperability problems.</source>
          <target state="translated">HTTP를 사용하면 중개자가 연결 체인을 통해 요청을 충족시킬 수 있습니다. HTTP 중개에는 프록시, 게이트웨이 및 터널의 세 가지 일반적인 형태가 있습니다. 경우에 따라 단일 중개자가 오리진 서버, 프록시, 게이트웨이 또는 터널로 작동하여 각 요청의 특성에 따라 동작을 전환 할 수 있습니다. &amp;gt;&amp;gt;&amp;gt;&amp;gt; UA =========== A =========== B =========== C ========== == O &amp;lt;&amp;lt;&amp;lt;&amp;lt;위의 그림은 사용자 에이전트와 오리진 서버 사이의 세 가지 중개자 (A, B 및 C)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4 개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 연결,비 터널 인접, 체인의 끝점 또는 체인을 따라 모든 연결에. 다이어그램은 선형이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A의 요청을 처리하는 동시에 A 이외의 많은 클라이언트로부터 요청을 수신하거나 C 이외의 서버로 요청을 전달할 수 있습니다. 마찬가지로 나중에 요청은 종종로드 밸런싱을위한 동적 구성을 기반으로 다른 연결 경로를 통해 전송 될 수 있습니다. &quot;업스트림&quot;및 &quot;다운 스트림&quot;이라는 용어는 메시지 흐름과 관련하여 방향 요구 사항을 설명하는 데 사용됩니다. 모든 메시지는 업스트림에서 다운 스트림으로 흐릅니다. &quot;인바운드&quot;및 &quot;아웃 바운드&quot;라는 용어요청 경로와 관련하여 방향 요구 사항을 설명하는 데 사용됩니다. &quot;인바운드&quot;는 오리진 서버를 의미하고 &quot;아웃 바운드&quot;는 사용자 에이전트를 의미합니다. &quot;프록시&quot;는 클라이언트가 일반적으로 로컬 구성 규칙을 통해 선택하여 절대 URI의 일부 유형에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 해당 요청을 충족 시키려고하는 메시지 전달 에이전트입니다. &quot;http&quot;URI에 대한 프록시 요청과 같은 일부 변환은 최소 수준이지만 다른 요청은 완전히 다른 응용 프로그램 수준 프로토콜과의 변환이 필요할 수 있습니다. 프록시는 종종 보안, 주석 서비스 또는 공유 캐싱을 위해 공통 중개자를 통해 조직의 HTTP 요청을 그룹화하는 데 사용됩니다.일부 프록시는 다음에 설명 된대로 전달되는 동안 선택된 메시지 또는 페이로드에 변환을 적용하도록 설계되었습니다. &lt;a href=&quot;#section-5.7.2&quot;&gt;섹션 5.7.2&lt;/a&gt;. &quot;게이트웨이&quot;(일명 &quot;리버스 프록시&quot;)는 아웃 바운드 연결을위한 오리진 서버 역할을하지만 수신 된 요청을 변환하고 인바운드를 다른 서버로 전달하는 중개자입니다. 게이트웨이는 종종 레거시 또는 신뢰할 수없는 정보 서비스를 캡슐화하고, &quot;가속기&quot;캐싱을 통해 서버 성능을 향상시키고, 여러 시스템에서 HTTP 서비스의 분할 또는로드 밸런싱을 가능하게하는 데 사용됩니다. 오리진 서버에 적용 가능한 모든 HTTP 요구 사항은 게이트웨이의 아웃 바운드 통신에도 적용됩니다. 게이트웨이는이 사양의 범위를 벗어난 HTTP에 대한 개인 확장을 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신합니다. 하나,타사 HTTP 서버와 상호 운용하려는 HTTP-to-HTTP 게이트웨이는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구 사항을 준수해야합니다. &quot;터널&quot;은 메시지를 변경하지 않고 두 연결 간의 블라인드 릴레이 역할을합니다. 터널이 HTTP 요청에 의해 시작되었을 수 있지만 터널이 활성화되면 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.터널은 HTTP 요청에 의해 시작되었을 수 있지만 터널은 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.터널은 HTTP 요청에 의해 시작되었을 수 있지만 터널은 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ])는 공유 방화벽 프록시를 통해 기밀 통신을 설정하는 데 사용됩니다. 중개자에 대한 위의 범주는 HTTP 통신의 참여자 역할 만 고려합니다. 메시지 발신자의 지식이나 허가없이 HTTP 트래픽을 필터링하거나 리디렉션하여 네트워크 프로토콜 스택의 하위 계층에서 작동 할 수있는 중개자도 있습니다. 네트워크 중개자는 중간자 (man-in-the-middle) 공격과 구별 할 수 없으며 (프로토콜 수준에서) HTTP 의미를 잘못 위반하여 보안 결함이나 상호 운용성 문제가 발생하는 경우가 많습니다. 예를 들어 &quot;차단 프록시&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ] (일반적으로 &quot;투명 프록시&quot;라고도 함 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] 또는 &quot;캡 티브 포털&quot;)은 클라이언트가 선택하지 않으므로 HTTP 프록시와 다릅니다. 대신 인터 셉션 프록시는 발신 TCP 포트 80 패킷 (및 때때로 다른 공통 포트 트래픽)을 필터링하거나 리디렉션합니다. 가로 채기 프록시는 일반적으로 공용 네트워크 액세스 지점에서 로컬이 아닌 인터넷 서비스를 사용하기 전에 계정 가입을 적용하고 회사 방화벽 내에서 네트워크 사용 정책을 시행하기위한 수단으로 사용됩니다. HTTP는 상태 비 저장 프로토콜로 정의되므로 각 요청 메시지를 개별적으로 이해할 수 있습니다. 많은 구현은 프록시 연결을 재사용하거나 여러 서버에서 요청을 동적으로로드 밸런스하기 위해 HTTP의 상태 비 저장 디자인에 의존합니다. 그 후,서버는 연결이 보안되어 있고 해당 에이전트에 특정하지 않는 한 동일한 연결의 두 요청이 동일한 사용자 에이전트의 요청이라고 가정해서는 안됩니다 (MUST NOT). 비표준 HTTP 확장 (예 : [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt; ])는이 요구 사항을 위반하여 보안 및 상호 운용성 문제를 일으키는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="8db8a2b5c25cf2c27eaf8a47b284cc3768fbc846" translate="yes" xml:space="preserve">
          <source>HTTP flow</source>
          <target state="translated">HTTP 흐름</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
