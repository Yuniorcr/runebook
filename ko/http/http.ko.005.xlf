<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="19c302998f4d6efe64dd1c686f52a585d7c21081" translate="yes" xml:space="preserve">
          <source>Over the years, other content negotiation proposals, like &lt;em&gt;transparent content negotiation&lt;/em&gt; and the &lt;code&gt;Alternates&lt;/code&gt; header, have been proposed. They failed to get traction and got abandoned.</source>
          <target state="translated">수년에 걸쳐 &lt;em&gt;투명한 콘텐츠 협상&lt;/em&gt; 및 &lt;code&gt;Alternates&lt;/code&gt; 헤더 와 같은 다른 콘텐츠 협상 제안 이 제안되었습니다. 그들은 견인력을 얻지 못하고 버려졌습니다.</target>
        </trans-unit>
        <trans-unit id="7f9ad0ce2f0cf21b5dfc499a3b4f0f957c8096a5" translate="yes" xml:space="preserve">
          <source>Overly long and detailed Server values should be avoided as they potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.</source>
          <target state="translated">공격자가 알려진 보안 허점을 쉽게 찾고 악용 할 수있는 내부 구현 세부 정보가 노출 될 수 있으므로 지나치게 길고 자세한 서버 값은 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="beb0cd26d81ea98884c5a97cec9c4a4060035ed7" translate="yes" xml:space="preserve">
          <source>Oversized images</source>
          <target state="translated">대형 이미지</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0645cc9f4662b405fbaab5741ba96115472ea2cb" translate="yes" xml:space="preserve">
          <source>Overview of HTTP</source>
          <target state="translated">HTTP 개요</target>
        </trans-unit>
        <trans-unit id="a29ee7bead9d5253143ec2eef09801f9444b6c47" translate="yes" xml:space="preserve">
          <source>Overwrite = &quot;Overwrite&quot; &quot;:&quot; (&quot;T&quot; | &quot;F&quot;)

   The Overwrite request header specifies whether the server should
   overwrite a resource mapped to the destination URL during a COPY or
   MOVE.  A value of &quot;F&quot; states that the server must not perform the
   COPY or MOVE operation if the destination URL does map to a resource.
   If the overwrite header is not included in a COPY or MOVE request,
   then the resource MUST treat the request as if it has an overwrite
   header of value &quot;T&quot;.  While the Overwrite header appears to duplicate
   the functionality of using an &quot;If-Match: *&quot; header (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]),
   If-Match applies only to the Request-URI, and not to the Destination
   of a COPY or MOVE.

   If a COPY or MOVE is not performed due to the value of the Overwrite
   header, the method MUST fail with a 412 (Precondition Failed) status
   code.  The server MUST do authorization checks before checking this
   or any conditional header.

   All DAV-compliant resources MUST support the Overwrite header.</source>
          <target state="translated">Overwrite = &quot;Overwrite&quot; &quot;:&quot;( &quot;T&quot;| &quot;F&quot;) 덮어 쓰기 요청 헤더는 서버가 COPY 또는 MOVE 중에 대상 URL에 매핑 된 리소스를 덮어 쓸지 여부를 지정합니다. &quot;F&quot;값은 대상 URL이 자원에 맵핑되는 경우 서버가 COPY 또는 MOVE 조작을 수행하지 않아야 함을 나타냅니다. 덮어 쓰기 헤더가 COPY 또는 MOVE 요청에 포함되지 않은 경우 리소스는 &quot;T&quot;값의 덮어 쓰기 헤더가있는 것처럼 요청을 처리해야합니다. 덮어 쓰기 헤더가 &quot;If-Match : *&quot;헤더를 사용하는 기능을 복제 한 것으로 보이지만 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; 참조)]), If-Match는 Request-URI에만 적용되며 COPY 또는 MOVE의 대상에는 적용되지 않습니다. 덮어 쓰기 헤더 값으로 인해 COPY 또는 MOVE가 수행되지 않으면 메소드는 반드시 412 (사전 조건 실패) 상태 코드와 함께 실패해야합니다. 서버는이 헤더 나 조건부 헤더를 확인하기 전에 권한 확인을 수행해야합니다. 모든 DAV 호환 리소스는 반드시 덮어 쓰기 헤더를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="c99402ab3125986c0ca9abd7662212d27d04d993" translate="yes" xml:space="preserve">
          <source>PATCH Method for HTTP</source>
          <target state="translated">HTTP를위한 패치 방법</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="66f5d95b9fad1f059666798a47511aaa0f200506" translate="yes" xml:space="preserve">
          <source>PNG images</source>
          <target state="translated">PNG 이미지</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="6b173f05e4044209594e89f3311ea2f97dca21f1" translate="yes" xml:space="preserve">
          <source>POST (RFC 7231)</source>
          <target state="translated">POST (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="488ec3314bc3136b6691a9c6089c33cd1a5abbf3" translate="yes" xml:space="preserve">
          <source>PROXY &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">프록시 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c3deba075c547e0c36e4da79277a2a8123501f3" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081</target>
        </trans-unit>
        <trans-unit id="be192bb000cdde229b85d161ac3cfc592a7def61" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081; DIRECT</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081; 곧장</target>
        </trans-unit>
        <trans-unit id="40d8b8bf9d93a5c96e1ad0585cf3ecb0348a6124" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; SOCKS socks:1080</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; 양말 양말 : 1080</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="180e2ba0d63f280e2a2789d7b31a1bc767301f2c" translate="yes" xml:space="preserve">
          <source>PUT (RFC 7231)</source>
          <target state="translated">PUT (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="5fc49191b72cdf03f625715123378e822ea8e609" translate="yes" xml:space="preserve">
          <source>PUT or POST: The resource describing the result of the action is transmitted in the message body.</source>
          <target state="translated">PUT 또는 POST : 조치 결과를 설명하는 자원이 메시지 본문으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fb06270f7c212baabc8749ffc36e49dc8f321548" translate="yes" xml:space="preserve">
          <source>Page</source>
          <target state="translated">Page</target>
        </trans-unit>
        <trans-unit id="acfde7c66817888e160ae3de7578ebfa76ce2e4f" translate="yes" xml:space="preserve">
          <source>Page load times &amp;ndash; especially on mobile networks &amp;ndash; can be measurably improved in this way. If the domain names for images can be resolved in advance of the images being requested, pages that load many images can see an improvement of 5% or more in the time of loading images.</source>
          <target state="translated">이러한 방식으로 특히 모바일 네트워크에서 페이지로드 시간을 크게 개선 할 수 있습니다. 이미지를 요청하기 전에 이미지의 도메인 이름을 확인할 수 있으면 이미지를로드 할 때 많은 이미지를로드하는 페이지가 5 % 이상 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="65de2e2a3bcb36da6b50fd9e19f9ca0b9466de27" translate="yes" xml:space="preserve">
          <source>Partial</source>
          <target state="translated">Partial</target>
        </trans-unit>
        <trans-unit id="a67f67302851a5d276a1f332c570a4d5d70beb91" translate="yes" xml:space="preserve">
          <source>Partial downloading of files is a functionality of HTTP that allows to resume previous operations, saving bandwidth and time, by keeping the already obtained information:</source>
          <target state="translated">파일의 부분 다운로드는 이미 얻은 정보를 유지하여 대역폭과 시간을 절약하면서 이전 작업을 재개 할 수있는 HTTP 기능입니다.</target>
        </trans-unit>
        <trans-unit id="9f2456547341d382c0cd8969634e15222fd42072" translate="yes" xml:space="preserve">
          <source>Partial request responses</source>
          <target state="translated">부분 요청 응답</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="d4cda508dc92e955d0dec90998defe31c1ce56cf" translate="yes" xml:space="preserve">
          <source>Path=&amp;lt;path-value&amp;gt; Optional</source>
          <target state="translated">경로 = &amp;lt;경로-값&amp;gt; 선택 사항</target>
        </trans-unit>
        <trans-unit id="43ce9e87fb78ff08bc898add73bc386a08eb801f" translate="yes" xml:space="preserve">
          <source>Pattern and mask specification is done the same way as for SOCKS configuration.</source>
          <target state="translated">패턴 및 마스크 지정은 SOCKS 구성과 동일한 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d1017f12ba79770bd35235205861747d3cccb1" translate="yes" xml:space="preserve">
          <source>Pay attention, WebKit browsers add a 'like Gecko' string that may trigger false positive for Gecko if the detection is not careful.</source>
          <target state="translated">주의를 기울여 WebKit 브라우저는 감지가주의하지 않으면 Gecko에 대해 오 탐지를 유발할 수있는 'like Gecko'문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="780f221907c7e38cdae635cfb6208478f88eb8ec" translate="yes" xml:space="preserve">
          <source>PaymentRequest</source>
          <target state="translated">PaymentRequest</target>
        </trans-unit>
        <trans-unit id="bb61a5741ee32ef6278d4f74c423d2cefcb01967" translate="yes" xml:space="preserve">
          <source>PerformanceServerTiming interface</source>
          <target state="translated">PerformanceServerTiming 인터페이스</target>
        </trans-unit>
        <trans-unit id="fd322b604a88d923b9699e4da5ad2d407a5bedf9" translate="yes" xml:space="preserve">
          <source>Permanent cookie</source>
          <target state="translated">영구 쿠키</target>
        </trans-unit>
        <trans-unit id="17658b356485ef7673c3b03ceae3fa6e6d7d88c4" translate="yes" xml:space="preserve">
          <source>Permanent cookies</source>
          <target state="translated">영구 쿠키</target>
        </trans-unit>
        <trans-unit id="92094144583e1bf1b4f762c12765fda6b3839671" translate="yes" xml:space="preserve">
          <source>Permanent redirections</source>
          <target state="translated">영구적 인 리디렉션</target>
        </trans-unit>
        <trans-unit id="4011d0826747060e5a5028b76b99f62d679b7124" translate="yes" xml:space="preserve">
          <source>Permanent redirects: a &lt;a href=&quot;status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; (Moved Permanently) response.</source>
          <target state="translated">영구 리디렉션 : &lt;a href=&quot;status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; (영구적으로 이동) 응답.</target>
        </trans-unit>
        <trans-unit id="7a346cd10ffe699546f235f362a53bac9f81fa99" translate="yes" xml:space="preserve">
          <source>Persistent connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6227d5230a252c6748af027af4a46a12c547c313" translate="yes" xml:space="preserve">
          <source>Persistent connections also have drawbacks; even when idling they consume server resources, and under heavy load, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack&quot;&gt;DoS attacks&lt;/a&gt; can be conducted. In such cases, using non-persistent connections, which are closed as soon as they are idle, can provide better performance.</source>
          <target state="translated">지속적인 연결에도 단점이 있습니다. 유휴 상태 일 때도 서버 리소스를 소비하고 부하가 많은 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack&quot;&gt;DoS 공격&lt;/a&gt; 을 수행 할 수 있습니다. 이러한 경우 유휴 상태가 되 자마자 닫히는 비 지속적 연결을 사용하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f203458ed70f830ecf62ab5ec4fd43db183fc0d2" translate="yes" xml:space="preserve">
          <source>Personalization</source>
          <target state="translated">Personalization</target>
        </trans-unit>
        <trans-unit id="77064d5265236e0ac252f3fc4a5ba7b274b6a583" translate="yes" xml:space="preserve">
          <source>Phone</source>
          <target state="translated">Phone</target>
        </trans-unit>
        <trans-unit id="43da85c5b84903575ac8c5ca1f55d28acabfcad2" translate="yes" xml:space="preserve">
          <source>Picture-in-picture</source>
          <target state="translated">Picture-in-picture</target>
        </trans-unit>
        <trans-unit id="27d5b461f6a4ec4744648e6c2d52e8a49e82d7ee" translate="yes" xml:space="preserve">
          <source>Pin validation failures are reported to the given URL. This directive should be used with this header, otherwise this header will be a no-op.</source>
          <target state="translated">핀 유효성 검사 실패가 지정된 URL에보고됩니다. 이 지시문은이 헤더와 함께 사용해야합니다. 그렇지 않으면이 헤더는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d9063d0ea16517f0dd2cf264a23d07a4fa9e003" translate="yes" xml:space="preserve">
          <source>Pipelining has been added, allowing to send a second request before the answer for the first one is fully transmitted, lowering the latency of the communication.</source>
          <target state="translated">파이프 라이닝이 추가되어 첫 번째 요청에 대한 응답이 완전히 전송되기 전에 두 번째 요청을 보내 통신 지연 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cb97787c320d9b01d77fc365f1658b4a6cbcfdcc" translate="yes" xml:space="preserve">
          <source>Pipelining is complex to implement correctly: the size of the resource being transferred, the effective &lt;a href=&quot;https://en.wikipedia.org/wiki/Round-trip_delay_time&quot;&gt;RTT&lt;/a&gt; that will be used, as well as the effective bandwidth, have a direct incidence on the improvement provided by the pipeline. Without knowing these, important messages may be delayed behind unimportant ones. The notion of important even evolves during page layout! HTTP pipelining therefore brings a marginal improvement in most cases only.</source>
          <target state="translated">파이프 라이닝은 올바르게 구현하기가 복잡합니다. 전송되는 리소스의 크기, 사용될 유효 &lt;a href=&quot;https://en.wikipedia.org/wiki/Round-trip_delay_time&quot;&gt;RTT&lt;/a&gt; 및 유효 대역폭은 파이프 라인이 제공하는 개선에 직접적인 영향을 미칩니다. 이러한 정보를 모르면 중요하지 않은 메시지보다 중요한 메시지가 지연 될 수 있습니다. 중요한 개념은 페이지 레이아웃 중에도 진화합니다! 따라서 HTTP 파이프 라이닝은 대부분의 경우에만 약간의 향상을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="32334bbf0ea4cc9dcd714f1f6fb56e7a4dd68d47" translate="yes" xml:space="preserve">
          <source>Pipelining is subject to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;HOL&lt;/a&gt; problem.</source>
          <target state="translated">파이프 라이닝에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;HOL&lt;/a&gt; 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e93906befafc2d436be2b0cefd447ae95a998ca" translate="yes" xml:space="preserve">
          <source>Pipelining is the process to send successive requests, over the same persistent connection, without waiting for the answer. This avoids latency of the connection. Theoretically, performance could also be improved if two HTTP requests were to be packed into the same TCP message. The typical &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_size&quot;&gt;MSS&lt;/a&gt; (Maximum Segment Size), is big enough to contain several simple requests, although the demand in size of HTTP requests continues to grow.</source>
          <target state="translated">파이프 라이닝은 응답을 기다리지 않고 동일한 영구 연결을 통해 연속 요청을 보내는 프로세스입니다. 이렇게하면 연결 대기 시간이 줄어 듭니다. 이론적으로 두 개의 HTTP 요청을 동일한 TCP 메시지로 묶어야하는 경우 성능도 향상 될 수 있습니다. 일반적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_size&quot;&gt;MSS&lt;/a&gt; (Maximum Segment Size)는 몇 가지 간단한 요청을 포함 할 수있을만큼 크지 만 HTTP 요청의 크기 요구는 계속 증가하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e9877233fd71bd443ebff82f1c96d10d967e95" translate="yes" xml:space="preserve">
          <source>Please note the security issues in the &lt;a href=&quot;cookies#Security&quot;&gt;Security&lt;/a&gt; section below. Cookies available to JavaScript can get stolen through XSS.</source>
          <target state="translated">아래 &lt;a href=&quot;cookies#Security&quot;&gt;보안&lt;/a&gt; 섹션 의 보안 문제를 참고하십시오 . JavaScript에 사용 가능한 쿠키는 XSS를 통해 도난 당할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e391655ea50eeb58d944cd6acd5f681479ecd3" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;Browser detection using the user agent&lt;/a&gt; and why serving different Web pages or services to different browsers is usually a bad idea.</source>
          <target state="translated">&lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트를 사용하여 브라우저 감지를&lt;/a&gt; 읽고 다른 웹 페이지 또는 서비스를 다른 브라우저에 제공하는 것이 일반적으로 나쁜 이유입니다.</target>
        </trans-unit>
        <trans-unit id="629043b0037778d804878a71a96a9e025cdaa239" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;identifying_resources_on_the_web&quot;&gt;Identifying resources on the web&lt;/a&gt; for more general details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;identifying_resources_on_the_web&quot;&gt;은 웹&lt;/a&gt; 에서 리소스 식별을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="77b3807a5e9d74793daef3f288350f785f3901bf" translate="yes" xml:space="preserve">
          <source>Please see the PostScript version of this RFC for the INDEX.</source>
          <target state="translated">INDEX에 대해서는이 RFC의 PostScript 버전을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f6b013e07f3ae6cf0eaeb620a07e55e63cca281" translate="yes" xml:space="preserve">
          <source>Plugin data (Flash via &lt;code&gt;&lt;a href=&quot;https://wiki.mozilla.org/NPAPI:ClearSiteData&quot;&gt;NPP_ClearSiteData&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">플러그인 데이터 ( &lt;code&gt;&lt;a href=&quot;https://wiki.mozilla.org/NPAPI:ClearSiteData&quot;&gt;NPP_ClearSiteData&lt;/a&gt;&lt;/code&gt; 를 통한 플래시 ).</target>
        </trans-unit>
        <trans-unit id="a03996fc28512c866d09144f03735be3035b474c" translate="yes" xml:space="preserve">
          <source>Pointing to a new document (HTTP 201 Created)</source>
          <target state="translated">새 문서를 가리킴 (HTTP 201 작성)</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="0655d96b4660aed951fededfbd01c7c59119ecd3" translate="yes" xml:space="preserve">
          <source>Portable Network Graphics</source>
          <target state="translated">휴대용 네트워크 그래픽</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e34a1abaef7642eb5e47dc90b1f78aded974e1e0" translate="yes" xml:space="preserve">
          <source>Post-HTTP/2 evolution</source>
          <target state="translated">HTTP / 2 이후의 진화</target>
        </trans-unit>
        <trans-unit id="5d2f1e6af4f0dd384a2135f597a35d76c716ff9d" translate="yes" xml:space="preserve">
          <source>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</source>
          <target state="translated">게시판, 뉴스 그룹, 메일 링리스트 또는 유사한 기사 그룹에 메시지 게시;</target>
        </trans-unit>
        <trans-unit id="e13c21f016090c02b61ff5c85484271e1f63607d" translate="yes" xml:space="preserve">
          <source>Potential consent. The origin server does not know, in real-time, whether it has received prior consent for tracking this user, user agent, or device, but promises not to use or share any &lt;code&gt;DNT:1&lt;/code&gt; data until such consent has been determined, and further promises to delete or permanently de-identify within 48 hours any &lt;code&gt;DNT:1&lt;/code&gt; data received for which such consent has not been received.</source>
          <target state="translated">잠재적 동의. 오리진 서버는이 사용자, 사용자 에이전트 또는 장치 추적에 대한 사전 동의를 받았는지 여부를 실시간으로 알지 못하지만 그러한 동의가 결정될 때까지 &lt;code&gt;DNT:1&lt;/code&gt; 데이터 를 사용하거나 공유하지 않을 것을 약속합니다 . 그러한 동의를받지 않은 &lt;code&gt;DNT:1&lt;/code&gt; 데이터를 48 시간 이내에 삭제하거나 영구적으로 비 식별 화할 것을 약속합니다 .</target>
        </trans-unit>
        <trans-unit id="38f93d32853eca4603a582eb7a404079e10b855d" translate="yes" xml:space="preserve">
          <source>Pragma</source>
          <target state="translated">Pragma</target>
        </trans-unit>
        <trans-unit id="10ce1b9f5fcb548c88be796c5413226a631f6779" translate="yes" xml:space="preserve">
          <source>Pragma (RFC 2616)</source>
          <target state="translated">프라 그마 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="222e9fe7a000f712ce64e611ad0d20ff65f49274" translate="yes" xml:space="preserve">
          <source>Pragma (RFC 7234)</source>
          <target state="translated">프라 그마 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7e6daac261d33e269d833bf63b3f2d2599eb567b" translate="yes" xml:space="preserve">
          <source>Precedence (RFC 7232)</source>
          <target state="translated">우선 순위 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="48fd0b0a455b1b9c9691a25e0993d7569fd92ed9" translate="yes" xml:space="preserve">
          <source>Predefined functions and environment</source>
          <target state="translated">사전 정의 된 기능 및 환경</target>
        </trans-unit>
        <trans-unit id="a35f2c6e9b4b4c78a58f550b27e02de590437603" translate="yes" xml:space="preserve">
          <source>Prefixed</source>
          <target state="translated">Prefixed</target>
        </trans-unit>
        <trans-unit id="77b7a912ad8a10b7555f0037f76831bb79e6719e" translate="yes" xml:space="preserve">
          <source>Prefixed Requires the vendor prefix: X-</source>
          <target state="translated">접두사 공급 업체 접두사 필요 : X-</target>
        </trans-unit>
        <trans-unit id="8f021bd03245cb33021400555bb85f605a2d45ff" translate="yes" xml:space="preserve">
          <source>Preflighted requests</source>
          <target state="translated">사전 요청</target>
        </trans-unit>
        <trans-unit id="cb65254a3d067d0956eed2852e254776d77cf4e1" translate="yes" xml:space="preserve">
          <source>Preflighted requests and redirects</source>
          <target state="translated">사전 요청 및 리디렉션</target>
        </trans-unit>
        <trans-unit id="d52d63f2f757eeb2fc2650d8e15f7889b573acf5" translate="yes" xml:space="preserve">
          <source>Preflighted requests in CORS</source>
          <target state="translated">CORS의 사전 요청</target>
        </trans-unit>
        <trans-unit id="26f1bf2383aa9871dd78193ab9149c3299ac14a5" translate="yes" xml:space="preserve">
          <source>Preloading Strict Transport Security</source>
          <target state="translated">엄격한 운송 보안 사전로드</target>
        </trans-unit>
        <trans-unit id="b13ad30fcddd7db2811d43c38bc157e0545a41de" translate="yes" xml:space="preserve">
          <source>Presto</source>
          <target state="translated">Presto</target>
        </trans-unit>
        <trans-unit id="6c064d906f8b1472fbe5172226fc023fb60b16b5" translate="yes" xml:space="preserve">
          <source>Presto-based (Opera 12-)</source>
          <target state="translated">프레스토 기반 (오페라 12-)</target>
        </trans-unit>
        <trans-unit id="0ca5c4f0da38bae9df91250a22a3aaec7b983517" translate="yes" xml:space="preserve">
          <source>Preventing caching</source>
          <target state="translated">캐싱 방지</target>
        </trans-unit>
        <trans-unit id="7a6ccc3e86565d9ca3c8a38ca45e95b4e5425569" translate="yes" xml:space="preserve">
          <source>Prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="36839770a07bef6a664420cba7543ec9676f091a" translate="yes" xml:space="preserve">
          <source>Primary proxy is w3proxy:8080; if that goes down start using mozilla:8081 until the primary proxy comes up again.</source>
          <target state="translated">기본 프록시는 w3proxy : 8080입니다. 중단되면 기본 프록시가 다시 나타날 때까지 mozilla : 8081을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fffd7d8534beaec770e000c8dc679dce544e8728" translate="yes" xml:space="preserve">
          <source>Principle</source>
          <target state="translated">Principle</target>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="8626bc3a69aaf8345688242139241ffe2cd1037a" translate="yes" xml:space="preserve">
          <source>Principles of content negotiation</source>
          <target state="translated">콘텐츠 협상의 원칙</target>
        </trans-unit>
        <trans-unit id="606354f7552e244079dc46f9624e7497309e75ba" translate="yes" xml:space="preserve">
          <source>Prior to 1995, there were three different formats commonly used by
   servers to communicate timestamps.  For compatibility with old
   implementations, all three are defined here.  The preferred format is
   a fixed-length and single-zone subset of the date and time
   specification used by the Internet Message Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;].

     HTTP-date    = IMF-fixdate / obs-date

   An example of the preferred format is

     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

   Examples of the two obsolete formats are

     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; format
     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format

   A recipient that parses a timestamp value in an HTTP header field
   MUST accept all three HTTP-date formats.  When a sender generates a
   header field that contains one or more timestamps defined as
   HTTP-date, the sender MUST generate those timestamps in the
   IMF-fixdate format.

   An HTTP-date value represents time as an instance of Coordinated
   Universal Time (UTC).  The first two formats indicate UTC by the
   three-letter abbreviation for Greenwich Mean Time, &quot;GMT&quot;, a
   predecessor of the UTC name; values in the asctime format are assumed
   to be in UTC.  A sender that generates HTTP-date values from a local
   clock ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) or some similar protocol to
   synchronize its clock to UTC.

   Preferred format:

     IMF-fixdate  = day-name &quot;,&quot; SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC5322]&lt;/a&gt;

     day-name     = %x4D.6F.6E ; &quot;Mon&quot;, case-sensitive
                  / %x54.75.65 ; &quot;Tue&quot;, case-sensitive
                  / %x57.65.64 ; &quot;Wed&quot;, case-sensitive
                  / %x54.68.75 ; &quot;Thu&quot;, case-sensitive
                  / %x46.72.69 ; &quot;Fri&quot;, case-sensitive
                  / %x53.61.74 ; &quot;Sat&quot;, case-sensitive
                  / %x53.75.6E ; &quot;Sun&quot;, case-sensitive 

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; &quot;Jan&quot;, case-sensitive
                  / %x46.65.62 ; &quot;Feb&quot;, case-sensitive
                  / %x4D.61.72 ; &quot;Mar&quot;, case-sensitive
                  / %x41.70.72 ; &quot;Apr&quot;, case-sensitive
                  / %x4D.61.79 ; &quot;May&quot;, case-sensitive
                  / %x4A.75.6E ; &quot;Jun&quot;, case-sensitive
                  / %x4A.75.6C ; &quot;Jul&quot;, case-sensitive
                  / %x41.75.67 ; &quot;Aug&quot;, case-sensitive
                  / %x53.65.70 ; &quot;Sep&quot;, case-sensitive
                  / %x4F.63.74 ; &quot;Oct&quot;, case-sensitive
                  / %x4E.6F.76 ; &quot;Nov&quot;, case-sensitive
                  / %x44.65.63 ; &quot;Dec&quot;, case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; &quot;GMT&quot;, case-sensitive

     time-of-day  = hour &quot;:&quot; minute &quot;:&quot; second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

   Obsolete formats:

     obs-date     = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date / asctime-date

     &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT
     date2        = day &quot;-&quot; month &quot;-&quot; 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; &quot;Monday&quot;, case-sensitive
            / %x54.75.65.73.64.61.79       ; &quot;Tuesday&quot;, case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; &quot;Wednesday&quot;, case-sensitive
            / %x54.68.75.72.73.64.61.79    ; &quot;Thursday&quot;, case-sensitive
            / %x46.72.69.64.61.79          ; &quot;Friday&quot;, case-sensitive
            / %x53.61.74.75.72.64.61.79    ; &quot;Saturday&quot;, case-sensitive
            / %x53.75.6E.64.61.79          ; &quot;Sunday&quot;, case-sensitive


     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2 

   HTTP-date is case sensitive.  A sender MUST NOT generate additional
   whitespace in an HTTP-date beyond that specifically included as SP in
   the grammar.  The semantics of day-name, day, month, year, and
   time-of-day are the same as those defined for the Internet Message
   Format constructs with the corresponding name ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;], &lt;a href=&quot;#section-3.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;).

   Recipients of a timestamp value in &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date format, which uses a
   two-digit year, MUST interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in
   the past that had the same last two digits.

   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.  For
   example, messages are occasionally forwarded over HTTP from a
   non-HTTP source that might generate any of the date and time
   specifications defined by the Internet Message Format.

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream.  Implementations are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">1995 년 이전에는 서버가 타임 스탬프를 통신하기 위해 일반적으로 사용하는 세 가지 형식이있었습니다. 이전 구현과의 호환성을 위해 세 가지가 모두 여기에 정의되어 있습니다. 기본 형식은 인터넷 메시지 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 에서 사용하는 날짜 및 시간 사양의 고정 길이 및 단일 영역 하위 집합입니다 . HTTP-date = IMF-fixdate / obs-date 선호하는 형식의 예는 Sun, 1994 년 11 월 6 일 08:49:37 GMT입니다. IMF-fixdate 사용되지 않는 두 가지 형식의 예는 일요일, 06-Nov-94 08:49:37 GMT입니다. 더 이상 사용되지 않는 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;형식 일요일 11 월 6 일 08:49:37 1994; ANSI C의 asctime () 형식 HTTP 헤더 필드에서 타임 스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP- 날짜 형식을 모두 수락해야합니다. 발신자가 HTTP- 날짜로 정의 된 하나 이상의 타임 스탬프를 포함하는 헤더 필드를 생성 할 때, 발신자는 해당 타임 스탬프를 IMF-fixdate 형식으로 생성해야합니다. HTTP 날짜 값은 UTC (협정 세계시)의 인스턴스로 시간을 나타냅니다. 처음 두 형식은 UTC 이름의 전신 인 &quot;GMT&quot;인 그리니치 표준시의 3 자리 약어로 UTC를 나타냅니다. asctime 형식의 값은 UTC로 가정합니다. 로컬 시계에서 HTTP 날짜 값을 생성하는 발신자는 NTP를 사용해야합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) 또는 유사한 프로토콜을 사용하여 시계를 UTC와 동기화합니다. 권장 형식 : IMF-fixdate = day-name &quot;,&quot;SP 날짜 1 SP 시간 SP GMT; 포맷의 고정 길이 / 구역 / 자본 부분 집합; &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.3&quot;&gt;[RFC5322] 섹션 3.3&lt;/a&gt; 참조 요일 이름 = % x4D.6F.6E; &quot;Mon&quot;, 대소 문자 구분 / % x54.75.65; &quot;화&quot;, 대소 문자 구분 / % x57.65.64; &quot;수&quot;, 대소 문자 구분 / % x54.68.75; &quot;목&quot;, 대소 문자 구분 / % x46.72.69; &quot;금&quot;, 대소 문자 구분 / % x53.61.74; &quot;토&quot;, 대소 문자 구분 / % x53.75.6E; &quot;일&quot;, 대소 문자 구분 date1 = 일 SP 월 SP 년; 예를 들어, 1982 년 6 월 2 일 = 2DIGIT 월 = % x4A.61.6E; &quot;Jan&quot;, 대소 문자 구분 / % x46.65.62; &quot;2 월&quot;, 대소 문자 구분 / % x4D.61.72; &quot;Mar&quot;, 대소 문자 구분 / % x41.70.72; &quot;4 월&quot;, 대소 문자 구분 / % x4D.61.79;&quot;5 월&quot;, 대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850-&lt;/a&gt; 날짜 / asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = day-name-l &quot;,&quot;SP date2 SP SP 시간 (time-of-day) SP GMT date2 = 일 &quot;-&quot;월 &quot;-&quot;2DIGIT; 예를 들어, 02-06-82 일명 -1 = % x4D.6F.6E.64.61.79; &quot;월요일&quot;, 대소 문자 구분 / % x54.75.65.73.64.61.79; &quot;화요일&quot;, 대소 문자 구분 / % x57.65.64.6E.65.73.64.61.79; &quot;수요일&quot;, 대소 문자 구분 / % x54.68.75.72.73.64.61.79; &quot;목요일&quot;, 대소 문자 구분 / % x46.72.69.64.61.79; &quot;금요일&quot;, 대소 문자 구분 / % x53.61.74.75.72.64.61.79; &quot;토요일&quot;, 대소 문자 구분 / % x53.75.6E.64.61.79; &quot;일요일&quot;,대소 문자 구분 asctime-date = 요일 이름 SP date3 SP 시간 SP 연도 date3 = 월 SP (2DIGIT / (SP 1DIGIT)); 예를 들어, Jun 2 HTTP-date는 대소 문자를 구분합니다. 발신자는 문법에 SP로 특별히 포함 된 것보다 HTTP 날짜에 추가 공백을 생성해서는 안됩니다 (MUST NOT). 요일, 요일, 월, 년 및 시간의 의미는 해당 이름을 가진 인터넷 메시지 형식 구성에 정의 된 것과 동일합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ], &lt;a href=&quot;#section-3.3&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; ). &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; 의 타임 스탬프 값 수신자두 자리 연도를 사용하는 -date 형식은 미래의 50 년 이상인 것으로 보이는 타임 스탬프를 과거의 마지막 두 자리가 같은 과거의 가장 최근 연도를 나타내는 것으로 해석해야합니다. 필드 정의에 의해 달리 제한되지 않는 한 타임 스탬프 값의 수신자는 타임 스탬프 구문 분석에 강력해야합니다. 예를 들어, 인터넷 메시지 형식으로 정의 된 날짜 및 시간 사양을 생성 할 수있는 비 HTTP 소스에서 HTTP를 통해 메시지가 전달되는 경우가 있습니다. 참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 사용자 프리젠 테이션, 요청 로깅 등에 이러한 형식을 사용하도록 구현할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b062cd147b0942de87c57e0c733a01809ece854" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 23, &lt;code&gt;xhr-src&lt;/code&gt; was used in place of the &lt;code&gt;connect-src&lt;/code&gt; directive and only restricted the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Firefox 23 이전에는 &lt;code&gt;connect-src&lt;/code&gt; 지시문 대신 &lt;code&gt;xhr-src&lt;/code&gt; 가 사용되었으며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 의 사용 만 제한했습니다 .</target>
        </trans-unit>
        <trans-unit id="d57d5feaa25422cc7cc558713f8921abe6d1b2f7" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 4 and Gecko 2.0, it was possible for extensions to add user agent parts through the &lt;code&gt;general.useragent.extra.&lt;em&gt;identifier&lt;/em&gt;&lt;/code&gt; preferences, (see the &lt;a href=&quot;https://developer.mozilla.org/En/User_Agent_Strings_Reference&quot;&gt;obsolete User Agent Strings Reference&lt;/a&gt;). But that has not been possible since &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=581008&quot;&gt;bug 581008&lt;/a&gt;.</source>
          <target state="translated">Firefox 4 및 Gecko 2.0 이전에는 확장 프로그램에서 &lt;code&gt;general.useragent.extra.&lt;em&gt;identifier&lt;/em&gt;&lt;/code&gt; 통해 사용자 에이전트 부분을 추가 할 수있었습니다 . &lt;em&gt;식별자&lt;/em&gt; 기본 설정 ( &lt;a href=&quot;https://developer.mozilla.org/En/User_Agent_Strings_Reference&quot;&gt;사용되지 않는 User Agent Strings Reference 참조&lt;/a&gt; ) 그러나 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=581008&quot;&gt;버그 581008&lt;/a&gt; 이후로는 불가능 했습니다 .</target>
        </trans-unit>
        <trans-unit id="c00bbbbf7eb977220c49fd643d1d96935e146d46" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 50, ping attributes of &amp;lt;a&amp;gt; elements weren't covered by connect-src.</source>
          <target state="translated">Firefox 50 이전에는 &amp;lt;a&amp;gt; 요소의 ping 속성에 connect-src가 포함되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6f0f6ee6e2fc7ee924f7d60f93cca17ee4751601" translate="yes" xml:space="preserve">
          <source>Prior to persistent connections, a separate TCP connection was
   established to fetch each URL, increasing the load on HTTP servers
   and causing congestion on the Internet. The use of inline images and
   other associated data often require a client to make multiple
   requests of the same server in a short amount of time. Analysis of
   these performance problems and results from a prototype
   implementation are available [&lt;a href=&quot;#ref-26&quot;&gt;26&lt;/a&gt;] [&lt;a href=&quot;#ref-30&quot;&gt;30&lt;/a&gt;]. Implementation experience and
   measurements of actual HTTP/1.1 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;) implementations show good
   results [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. Alternatives have also been explored, for example,
   T/TCP [&lt;a href=&quot;#ref-27&quot;&gt;27&lt;/a&gt;].

   Persistent HTTP connections have a number of advantages:

      - By opening and closing fewer TCP connections, CPU time is saved
        in routers and hosts (clients, servers, proxies, gateways,
        tunnels, or caches), and memory used for TCP protocol control
        blocks can be saved in hosts.

      - HTTP requests and responses can be pipelined on a connection.
        Pipelining allows a client to make multiple requests without
        waiting for each response, allowing a single TCP connection to
        be used much more efficiently, with much lower elapsed time.

      - Network congestion is reduced by reducing the number of packets
        caused by TCP opens, and by allowing TCP sufficient time to
        determine the congestion state of the network.

      - Latency on subsequent requests is reduced since there is no time
        spent in TCP's connection opening handshake.

      - HTTP can evolve more gracefully, since errors can be reported
        without the penalty of closing the TCP connection. Clients using
        future versions of HTTP might optimistically try a new feature,
        but if communicating with an older server, retry with old
        semantics after an error is reported.

   HTTP implementations SHOULD implement persistent connections.</source>
          <target state="translated">지속적인 연결 이전에는 각 URL을 가져 오기 위해 별도의 TCP 연결이 설정되어 HTTP 서버의로드가 증가하고 인터넷 정체가 발생했습니다. 인라인 이미지 및 기타 관련 데이터를 사용하려면 클라이언트가 짧은 시간 내에 동일한 서버에 대해 여러 번 요청해야합니다. 이러한 성능 문제와 프로토 타입 구현 결과를 분석 할 수 있습니다 [ &lt;a href=&quot;#ref-26&quot;&gt;26&lt;/a&gt; ] [ &lt;a href=&quot;#ref-30&quot;&gt;30&lt;/a&gt; ]. 실제 HTTP / 1.1 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; ) 구현 의 구현 경험과 측정 결과는 좋은 결과를 보여줍니다 [ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]. 대안들, 예를 들어 T / TCP [ &lt;a href=&quot;#ref-27&quot;&gt;27&lt;/a&gt;]. 지속적인 HTTP 연결에는 많은 장점이 있습니다.-적은 TCP 연결을 열고 닫으면 라우터 및 호스트 (클라이언트, 서버, 프록시, 게이트웨이, 터널 또는 캐시)에 CPU 시간이 절약되고 TCP 프로토콜 제어 블록에 사용되는 메모리는 호스트에 저장됩니다. -연결에서 HTTP 요청 및 응답을 파이프 라인 할 수 있습니다. 파이프 라이닝을 사용하면 클라이언트가 각 응답을 기다리지 않고 여러 요청을 할 수 있으므로 단일 TCP 연결을 훨씬 더 효율적으로 사용할 수 있으며 경과 시간이 훨씬 줄어 듭니다. -TCP 개방으로 인한 패킷 수를 줄이고 TCP가 네트워크의 혼잡 상태를 결정하기에 충분한 시간을 허용함으로써 네트워크 혼잡이 줄어 듭니다.-TCP의 연결 열기 핸드 셰이크에 시간이 걸리지 않기 때문에 후속 요청의 대기 시간이 줄어 듭니다. -TCP 연결을 종료하지 않고도 오류를보고 할 수 있으므로 HTTP가보다 정교하게 발전 할 수 있습니다. 이후 버전의 HTTP를 사용하는 클라이언트는 새 기능을 낙관적으로 시도 할 수 있지만 이전 서버와 통신하는 경우 오류가보고 된 후 이전 시맨틱으로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.오류가보고 된 후 오래된 의미로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.오류가보고 된 후 오래된 의미로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.</target>
        </trans-unit>
        <trans-unit id="48f4bbdda03dd3d60abd9b0625517bb4f9e03c60" translate="yes" xml:space="preserve">
          <source>Privacy and security</source>
          <target state="translated">개인 정보 및 보안</target>
        </trans-unit>
        <trans-unit id="e142ec9e0f6fa82bbf90633fcce2ae639984a559" translate="yes" xml:space="preserve">
          <source>Private and public caches</source>
          <target state="translated">개인 및 공개 캐시</target>
        </trans-unit>
        <trans-unit id="b1319505ddbfe3c5d91b4e791afac59bd01e7636" translate="yes" xml:space="preserve">
          <source>Private browser caches</source>
          <target state="translated">개인 브라우저 캐시</target>
        </trans-unit>
        <trans-unit id="41e627b20e59eecdf41ecb162cc910e00b4e3ba5" translate="yes" xml:space="preserve">
          <source>Proactive content negotiation headers include:</source>
          <target state="translated">사전 컨텐츠 협상 헤더에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="087c7190faf5e2b716771946a752c1b33c0f18a0" translate="yes" xml:space="preserve">
          <source>Product tokens are used to allow communicating applications to
   identify themselves by software name and version. Most fields using
   product tokens also allow sub-products which form a significant part
   of the application to be listed, separated by white space. By
   convention, the products are listed in order of their significance
   for identifying the application.

       product         = token [&quot;/&quot; product-version]
       product-version = token

   Examples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
       Server: Apache/0.8.4 

   Product tokens SHOULD be short and to the point. They MUST NOT be
   used for advertising or other non-essential information. Although any
   token character MAY appear in a product-version, this token SHOULD
   only be used for a version identifier (i.e., successive versions of
   the same product SHOULD only differ in the product-version portion of
   the product value).</source>
          <target state="translated">제품 토큰은 통신 응용 프로그램이 소프트웨어 이름 및 버전으로 자신을 식별 할 수 있도록하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 응용 프로그램의 중요한 부분을 구성하는 하위 제품을 공백으로 구분하여 나열 할 수도 있습니다. 일반적으로 제품은 응용 프로그램을 식별하는 데있어 중요한 순서대로 나열됩니다. product = token [ &quot;/&quot;product-version] product-version = token 예 : 사용자 에이전트 : CERN-LineMode / 2.15 libwww / 2.17b3 서버 : Apache / 0.8.4 제품 토큰은 짧아야합니다. 광고 또는 기타 중요하지 않은 정보에 사용해서는 안됩니다. 토큰 버전이 제품 버전에 나타날 수 있지만이 토큰은 버전 식별자 (예 :동일한 제품의 연속 버전은 제품 가치의 제품 버전 부분에서만 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="3418c299ab2f552ddf1770d269bc4a148956b6eb" translate="yes" xml:space="preserve">
          <source>Progressive enhancement</source>
          <target state="translated">진보적 인 향상</target>
        </trans-unit>
        <trans-unit id="b53e75d9632b419f01390beb8bf5b4225366d8b3" translate="yes" xml:space="preserve">
          <source>Proper cache operation preserves the semantics of HTTP transfers
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]) while eliminating the transfer of information already
   held in the cache.  Although caching is an entirely OPTIONAL feature
   of HTTP, it can be assumed that reusing a cached response is
   desirable and that such reuse is the default behavior when no
   requirement or local configuration prevents it.  Therefore, HTTP
   cache requirements are focused on preventing a cache from either
   storing a non-reusable response or reusing a stored response
   inappropriately, rather than mandating that caches always store and
   reuse particular responses.

   Each cache entry consists of a cache key and one or more HTTP
   responses corresponding to prior requests that used the same key.
   The most common form of cache entry is a successful result of a
   retrieval request: i.e., a 200 (OK) response to a GET request, which
   contains a representation of the resource identified by the request
   target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;).  However, it is also possible to
   cache permanent redirects, negative results (e.g., 404 (Not Found)), 

   incomplete results (e.g., 206 (Partial Content)), and responses to
   methods other than GET if the method's definition allows such caching
   and defines something suitable for use as a cache key.

   The primary cache key consists of the request method and target URI.
   However, since HTTP caches in common use today are typically limited
   to caching responses to GET, many caches simply decline other methods
   and use only the URI as the primary cache key.

   If a request target is subject to content negotiation, its cache
   entry might consist of multiple stored responses, each differentiated
   by a secondary key for the values of the original request's selecting
   header fields (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).</source>
          <target state="translated">적절한 캐시 작업은 HTTP 전송의 의미를 유지합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]) 이미 캐시에 보유한 정보의 전송을 제거합니다. 캐싱은 HTTP의 전적으로 선택적인 기능이지만 캐시 된 응답을 재사용하는 것이 바람직하며 요구 사항이나 로컬 구성으로이를 방지하지 않는 경우 이러한 재사용이 기본 동작이라고 가정 할 수 있습니다. 따라서 HTTP 캐시 요구 사항은 캐시가 항상 특정 응답을 저장하고 재사용하도록 강제하는 대신 캐시가 재사용 불가능한 응답을 저장하거나 저장된 응답을 부적절하게 재사용하지 못하도록하는 데 중점을 둡니다. 각 캐시 항목은 캐시 키와 동일한 키를 사용한 이전 요청에 해당하는 하나 이상의 HTTP 응답으로 구성됩니다. 가장 일반적인 형태의 캐시 엔트리는 검색 요청의 성공적인 결과입니다. 즉, GET 요청에 대한 200 (OK) 응답,요청 대상에 의해 식별 된 리소스의 표현을 포함합니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]의 섹션 4.3.1&lt;/a&gt;). 그러나 방법의 정의가 캐싱을 허용하는 경우 영구 리디렉션, 부정적인 결과 (예 : 404 (찾을 수 없음)), 불완전한 결과 (예 : 206 (부분 내용)) 및 GET 이외의 방법에 대한 응답을 캐시 할 수도 있습니다. 캐시 키로 사용하기에 적합한 것을 정의합니다. 기본 캐시 키는 요청 방법과 대상 URI로 구성됩니다. 그러나 오늘날 일반적으로 사용되는 HTTP 캐시는 일반적으로 GET에 대한 응답 캐싱으로 제한되므로 많은 캐시는 단순히 다른 방법을 거부하고 URI 만 기본 캐시 키로 사용합니다. 요청 대상이 콘텐츠 협상의 대상이되는 경우 캐시 항목은 여러 개의 저장된 응답으로 구성 될 수 있으며 각 요청은 원래 요청의 선택 헤더 필드 값에 대한 보조 키로 구분됩니다 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="b9fbc1e3c42cd5403dbaa2b56fde8f98ce0f1904" translate="yes" xml:space="preserve">
          <source>Properly configuring server MIME types</source>
          <target state="translated">서버 MIME 유형을 올바르게 구성</target>
        </trans-unit>
        <trans-unit id="c7f500a0888429d2c8e89835562929df19e1c741" translate="yes" xml:space="preserve">
          <source>Properties already exist, in a limited sense, in HTTP message
   headers.  However, in distributed authoring environments, a
   relatively large number of properties are needed to describe the
   state of a resource, and setting/returning them all through HTTP
   headers is inefficient.  Thus, a mechanism is needed that allows a
   principal to identify a set of properties in which the principal is
   interested and to set or retrieve just those properties.</source>
          <target state="translated">HTTP 메시지 헤더에는 이미 제한된 의미로 속성이 있습니다. 그러나 분산 작성 환경에서는 리소스 상태를 설명하기 위해 비교적 많은 속성이 필요하며 HTTP 헤더를 통해 모든 속성을 설정 / 반환하는 것은 비효율적입니다. 따라서, 주체가 주체가 관심을 갖는 특성 세트를 식별하고 해당 특성 만 설정하거나 검색 할 수있는 메커니즘이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4c8925f6237eb1d7afbb04e595799795cd419670" translate="yes" xml:space="preserve">
          <source>Properties are pieces of data that describe the state of a resource.
   Properties are data about data.

   Properties are used in distributed authoring environments to provide
   for efficient discovery and management of resources.  For example, a
   'subject' property might allow for the indexing of all resources by
   their subject, and an 'author' property might allow for the discovery
   of what authors have written which documents.

   The DAV property model consists of name/value pairs.  The name of a
   property identifies the property's syntax and semantics, and provides
   an address by which to refer to its syntax and semantics.

   There are two categories of properties: &quot;live&quot; and &quot;dead&quot;.  A live
   property has its syntax and semantics enforced by the server.  Live
   properties include cases where a) the value of a property is
   protected and maintained by the server, and b) the value of the
   property is maintained by the client, but the server performs syntax
   checking on submitted values.  All instances of a given live property
   MUST comply with the definition associated with that property name.
   A dead property has its syntax and semantics enforced by the client;
   the server merely records the value of the property verbatim.</source>
          <target state="translated">속성은 리소스의 상태를 설명하는 데이터 조각입니다. 속성은 데이터에 대한 데이터입니다. 분산 저작 환경에서 속성을 사용하여 리소스를 효율적으로 검색하고 관리 할 수 ​​있습니다. 예를 들어, 'subject'속성은 주제별로 모든 리소스의 색인을 생성 할 수 있으며 'author'속성은 작성자가 어떤 문서를 작성했는지 확인할 수 있습니다. DAV 속성 모델은 이름 / 값 쌍으로 구성됩니다. 속성 이름은 속성의 구문과 의미를 식별하고 해당 구문과 의미를 참조 할 주소를 제공합니다. 속성은 &quot;live&quot;와 &quot;dead&quot;의 두 가지 범주가 있습니다. 라이브 속성에는 서버에 의해 적용되는 구문과 의미가 있습니다.라이브 속성에는 a) 속성 값이 서버에 의해 보호 및 유지 관리되고 b) 속성 값이 클라이언트에 의해 유지 관리되지만 제출 된 값에 대해 구문 검사를 수행하는 경우가 포함됩니다. 지정된 라이브 속성의 모든 인스턴스는 해당 속성 이름과 관련된 정의를 준수해야합니다. 죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bc233ecf22c9f1db23c365e4a2642bb8cba6a816" translate="yes" xml:space="preserve">
          <source>Proposed Standard</source>
          <target state="translated">제안 된 표준</target>
        </trans-unit>
        <trans-unit id="bf009ce8a837a5209a379d6adc4c70a76703ec19" translate="yes" xml:space="preserve">
          <source>Proprietary file types. Avoid using &lt;code&gt;application/octet-stream&lt;/code&gt; as most browsers do not allow defining a default behavior (like &quot;Open in Word&quot;) for this generic MIME type. A specific type like &lt;code&gt;application/vnd.mspowerpoint&lt;/code&gt; lets users open such files automatically in the presentation software of their choice.</source>
          <target state="translated">독점 파일 형식. 대부분의 브라우저는이 일반 MIME 유형에 대한 기본 동작 (예 : &quot;Open in Word&quot;)을 정의 할 수 없으므로 &lt;code&gt;application/octet-stream&lt;/code&gt; 을 사용하지 마십시오 . &lt;code&gt;application/vnd.mspowerpoint&lt;/code&gt; 와 같은 특정 유형을 사용하면 선택한 프레젠테이션 소프트웨어에서 해당 파일을 자동으로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd33e932fe6859eb640384bc6909307c3f08b41" translate="yes" xml:space="preserve">
          <source>Protocol Parameters (RFC 2616)</source>
          <target state="translated">프로토콜 매개 변수 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="923c328c14b08b33713e5d95d3fe51b88c0e5ddf" translate="yes" xml:space="preserve">
          <source>Protocol upgrade mechanism</source>
          <target state="translated">프로토콜 업그레이드 메커니즘</target>
        </trans-unit>
        <trans-unit id="d296cfe938e4cb136e0d8482641c0b8111e49c1c" translate="yes" xml:space="preserve">
          <source>Protocol upgrades are always requested by the client; there is no mechanism provided for the server to request a protocol change. When the client wishes to upgrade to a new protocol, it does so by sending a normal request of any type to the server (&lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, etc.). The request needs to be configured specially to include the upgrade request, however.</source>
          <target state="translated">프로토콜 업그레이드는 항상 클라이언트가 요청합니다. 서버가 프로토콜 변경을 요청하는 메커니즘은 없습니다. 클라이언트가 새 프로토콜로 업그레이드하려는 경우 모든 유형의 일반 요청을 서버 ( &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 등) 로 보내면 됩니다. 그러나 업그레이드 요청을 포함하도록 요청을 특별히 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f624685bc2b146442ac162d357d3d682338bac4" translate="yes" xml:space="preserve">
          <source>Provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">자체 프레임과 iframe에 포함 된 브라우저 기능의 사용을 허용 및 거부하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="11968b9c181aaf96f57288610c04f25c02a09d23" translate="yes" xml:space="preserve">
          <source>Provides information to the server which is needed in order to confirm that the client is entitled to request an upgrade to WebSocket. This header can be used when insecure (HTTP) clients wish to upgrade, in order to offer some degree of protection against abuse. The value of the key is computed using an algorithm defined in the WebSocket specification, so this &lt;em&gt;does not provide security&lt;/em&gt;. Instead, it helps to prevent non-WebSocket clients from inadvertently, or through misuse, requesting a WebSocket connection. In essence, then, this key simply confirms that &quot;Yes, I really mean to open a WebSocket connection.&quot;</source>
          <target state="translated">클라이언트가 WebSocket으로의 업그레이드를 요청할 권한이 있는지 확인하기 위해 필요한 정보를 서버에 제공합니다. 이 헤더는 안전하지 않은 (HTTP) 클라이언트가 업그레이드를 원하는 경우 남용에 대해 어느 정도의 보호를 제공하기 위해 사용할 수 있습니다. 키의 값은 WebSocket 사양에 정의 된 알고리즘을 사용하여 계산되므로 &lt;em&gt;보안을 제공하지 않습니다&lt;/em&gt; . 대신, WebSocket 이외의 클라이언트가 실수로 또는 오용하여 WebSocket 연결을 요청하는 것을 방지합니다. 본질적으로이 키는 단순히 &quot;예, WebSocket 연결을 여는 것을 의미합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="018c3e9378282caf36585ac2bcc9f60f3a4154de" translate="yes" xml:space="preserve">
          <source>Providing a block of data, such as the result of submitting a form, to a data-handling process;</source>
          <target state="translated">양식 제출 결과와 같은 데이터 블록을 데이터 처리 프로세스에 제공하는 단계;</target>
        </trans-unit>
        <trans-unit id="c3d8b749aec91d94ef9ced533c0007fb5b034097" translate="yes" xml:space="preserve">
          <source>Providing granular control over sensitive or powerful features.</source>
          <target state="translated">민감하거나 강력한 기능을 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9db0b745b6fa2951c35528cc5a431b74d851a2e8" translate="yes" xml:space="preserve">
          <source>Proxies</source>
          <target state="translated">Proxies</target>
        </trans-unit>
        <trans-unit id="9d27f7bb5ddd3b0e18ffdf81d878bca715670b1b" translate="yes" xml:space="preserve">
          <source>Proxies can make requests appear as if they originated from the proxy's IP address. This can be useful if a proxy is used to provide client anonymity, but in other cases information from the original request is lost. The IP address of the original client is often used for debugging, statistics, or generating location-dependent content. A common way to disclose this information is by using the following HTTP headers:</source>
          <target state="translated">프록시는 프록시 IP 주소에서 시작된 것처럼 요청을 표시 할 수 있습니다. 프록시가 클라이언트 익명 성을 제공하는 데 사용되지만 다른 경우 원래 요청의 정보가 손실되는 경우에 유용합니다. 원래 클라이언트의 IP 주소는 종종 디버깅, 통계 또는 위치 종속 컨텐츠 생성에 사용됩니다. 이 정보를 공개하는 일반적인 방법은 다음 HTTP 헤더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="b3a1b86c68a3aa7f85f81802d2ba3d99659e9b35" translate="yes" xml:space="preserve">
          <source>Proxy Auto-Configuration (PAC)</source>
          <target state="translated">프록시 자동 구성 (PAC)</target>
        </trans-unit>
        <trans-unit id="8f9917cc3f9134204105024635f01325cce0c9c8" translate="yes" xml:space="preserve">
          <source>Proxy authentication</source>
          <target state="translated">프록시 인증</target>
        </trans-unit>
        <trans-unit id="2e280b44f81cc19be751f7835b895d284950da7a" translate="yes" xml:space="preserve">
          <source>Proxy server</source>
          <target state="translated">프록시 서버</target>
        </trans-unit>
        <trans-unit id="dfabf4ef5828660426d5401fdbab484b651cc6c1" translate="yes" xml:space="preserve">
          <source>Proxy server on Wikipedia</source>
          <target state="translated">Wikipedia의 프록시 서버</target>
        </trans-unit>
        <trans-unit id="22bb93eb9e863e2d12b4f0e8bb170a48e48c57e2" translate="yes" xml:space="preserve">
          <source>Proxy servers and tunneling</source>
          <target state="translated">프록시 서버 및 터널링</target>
        </trans-unit>
        <trans-unit id="13246650dfbf91f6f1cdea79edc1ad0b687ad10c" translate="yes" xml:space="preserve">
          <source>Proxy servers and tunneling: Proxy Auto-Configuration (PAC) file</source>
          <target state="translated">프록시 서버 및 터널링 : PAC (Proxy Auto-Configuration) 파일</target>
        </trans-unit>
        <trans-unit id="0ce13782e9ac74ef50b0f764c0721de2a4ae3187" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate</source>
          <target state="translated">Proxy-Authenticate</target>
        </trans-unit>
        <trans-unit id="dbf9a1785268a0b4ce911682fdc989177a1db77f" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate (RFC 2616)</source>
          <target state="translated">프록시 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="bfe187da3075a7c7a3d496648a7de30904fd1d98" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate (RFC 7235)</source>
          <target state="translated">프록시 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d2fd2a50c1a375beb79e19ec25e0a1496b8c4176" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization</source>
          <target state="translated">Proxy-Authorization</target>
        </trans-unit>
        <trans-unit id="9f1648755bd86ad38e590216d8154c160568d1f5" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization (RFC 2616)</source>
          <target state="translated">프록시 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="38b8e04d0e1db5b505f96dc23f9f03af30df9e82" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization (RFC 7235)</source>
          <target state="translated">프록시 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d061beeadf90bd540f44d26bf398aa1093494c9c" translate="yes" xml:space="preserve">
          <source>ProxyConfig.bindings</source>
          <target state="translated">ProxyConfig.bindings</target>
        </trans-unit>
        <trans-unit id="6d8b0bc17b7cee3232acc6bbd4f3bf089a9fa15f" translate="yes" xml:space="preserve">
          <source>Public Key Pinning</source>
          <target state="translated">공개 키 고정</target>
        </trans-unit>
        <trans-unit id="734b13d8d37920cbfae35c8554333fc716efe37f" translate="yes" xml:space="preserve">
          <source>Public Key Pinning Extension for HTTP</source>
          <target state="translated">HTTP 용 공개 키 고정 확장</target>
        </trans-unit>
        <trans-unit id="a1e6c8c10beb332571d741b2f1bd1ba0cb86677b" translate="yes" xml:space="preserve">
          <source>Public proxy URL and port.</source>
          <target state="translated">공용 프록시 URL 및 포트</target>
        </trans-unit>
        <trans-unit id="2587a4c5043acc3269a6c7635c5ecb4186dfdc64" translate="yes" xml:space="preserve">
          <source>Public-Key-Pins</source>
          <target state="translated">Public-Key-Pins</target>
        </trans-unit>
        <trans-unit id="00532d766c7988ed952d7de699ce49faa049871d" translate="yes" xml:space="preserve">
          <source>Public-Key-Pins-Report-Only</source>
          <target state="translated">Public-Key-Pins-Report-Only</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="95b741bb15ce7a7be678af41321b1cefa2fe0ef4" translate="yes" xml:space="preserve">
          <source>Quality Values (RFC 7231)</source>
          <target state="translated">품질 가치 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="6bac12c79b364171a7e2113696dc2f7c8e069dd1" translate="yes" xml:space="preserve">
          <source>RAR archive</source>
          <target state="translated">RAR 아카이브</target>
        </trans-unit>
        <trans-unit id="ce001c290e2d02b3c73d5fb8aff7b19ff59cbebd" translate="yes" xml:space="preserve">
          <source>RAR-compressed files. In this case, the ideal would be the true type of the original files; this is often impossible as .RAR files can hold several resources of different types. In this case, configure the server to send &lt;code&gt;application/x-rar-compressed&lt;/code&gt;.</source>
          <target state="translated">RAR 압축 파일. 이 경우 원본 파일의 실제 유형이 이상적입니다. .RAR 파일이 다른 유형의 여러 리소스를 보유 할 수 있기 때문에 종종 불가능합니다. 이 경우 &lt;code&gt;application/x-rar-compressed&lt;/code&gt; 를 보내도록 서버를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e620fb8a8e1f067cba2c5c8b33cfeae91df101f2" translate="yes" xml:space="preserve">
          <source>RFC 2145</source>
          <target state="translated">RFC 2145</target>
        </trans-unit>
        <trans-unit id="54cf6a79d95c46bece225f0a9f0ff2c8d940f6d5" translate="yes" xml:space="preserve">
          <source>RFC 2183</source>
          <target state="translated">RFC 2183</target>
        </trans-unit>
        <trans-unit id="eab5986519d8c2f1d79d71fd31bc88f8c184ee68" translate="yes" xml:space="preserve">
          <source>RFC 2324</source>
          <target state="translated">RFC 2324</target>
        </trans-unit>
        <trans-unit id="e8b932b7389942e2684df25c4fc9bca8d4aec36b" translate="yes" xml:space="preserve">
          <source>RFC 2324, section 2.3.2: 418 I'm a teapot</source>
          <target state="translated">RFC 2324, 섹션 2.3.2 : 418 나는 주전자입니다</target>
        </trans-unit>
        <trans-unit id="00c7481edfb50dd9346b5b61ce99268f3a5a80ee" translate="yes" xml:space="preserve">
          <source>RFC 2397</source>
          <target state="translated">RFC 2397</target>
        </trans-unit>
        <trans-unit id="362f9d5706319e0d27ec9dcc6bff4ed91891f763" translate="yes" xml:space="preserve">
          <source>RFC 2616</source>
          <target state="translated">RFC 2616</target>
        </trans-unit>
        <trans-unit id="558ad0a006347c19da6f6e01c8f14905903534af" translate="yes" xml:space="preserve">
          <source>RFC 2616: HTTP/1.1</source>
          <target state="translated">RFC 2616 : HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="d347b8838ab74754f6c3546ed6688f3c4345b1b3" translate="yes" xml:space="preserve">
          <source>RFC 2817</source>
          <target state="translated">RFC 2817</target>
        </trans-unit>
        <trans-unit id="c20beb689b5f6e7d8768449ffecf7f98f2b7e0fb" translate="yes" xml:space="preserve">
          <source>RFC 2965: Cookie2</source>
          <target state="translated">RFC 2965 : 쿠키 2</target>
        </trans-unit>
        <trans-unit id="f248a43f6e88982bb238b56b5c0187432e4f1efd" translate="yes" xml:space="preserve">
          <source>RFC 2965: Set-Cookie2</source>
          <target state="translated">RFC 2965 : 세트 쿠키 2</target>
        </trans-unit>
        <trans-unit id="cf48f3d5bf7ea08ce5e6f45d9f362f9581e8b3b2" translate="yes" xml:space="preserve">
          <source>RFC 3986</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84942944fb40a5234b5c2f832866564d5791a061" translate="yes" xml:space="preserve">
          <source>RFC 4918, section 11.2: 422 Unprocessable Entity</source>
          <target state="translated">RFC 4918, 섹션 11.2 : 422 처리 할 수없는 엔티티</target>
        </trans-unit>
        <trans-unit id="fd476ad209927e0e2319f1bd76afddbea0ba44e2" translate="yes" xml:space="preserve">
          <source>RFC 4918: WebDAV</source>
          <target state="translated">RFC 4918 : WebDAV</target>
        </trans-unit>
        <trans-unit id="afb128171db7b00f0fd933b36cae908b332f6db4" translate="yes" xml:space="preserve">
          <source>RFC 5023: The Atom Publishing Protocol</source>
          <target state="translated">RFC 5023 : 원자 게시 프로토콜</target>
        </trans-unit>
        <trans-unit id="fb8a5055f684c82eb4a643f0d2d5fc702e7e8f0a" translate="yes" xml:space="preserve">
          <source>RFC 5246</source>
          <target state="translated">RFC 5246</target>
        </trans-unit>
        <trans-unit id="2f6b2f6ce5e3b4277d0a646055843e6477f381b9" translate="yes" xml:space="preserve">
          <source>RFC 5689</source>
          <target state="translated">RFC 5689</target>
        </trans-unit>
        <trans-unit id="bf1f2785d8f6ee0235d694fd6179a1a3ebce5bba" translate="yes" xml:space="preserve">
          <source>RFC 5789, section 2: Patch method</source>
          <target state="translated">RFC 5789, 섹션 2 : 패치 방법</target>
        </trans-unit>
        <trans-unit id="fcb38f9a6380d714f3aa4aa1f4201bc7bc90649d" translate="yes" xml:space="preserve">
          <source>RFC 5789: PATCH</source>
          <target state="translated">RFC 5789 : 패치</target>
        </trans-unit>
        <trans-unit id="435cdf88638b49c1ce4749b77a33a7b13603777d" translate="yes" xml:space="preserve">
          <source>RFC 5861</source>
          <target state="translated">RFC 5861</target>
        </trans-unit>
        <trans-unit id="48dc1f7525cc2cf74db930d6713d686f2df34d50" translate="yes" xml:space="preserve">
          <source>RFC 5988</source>
          <target state="translated">RFC 5988</target>
        </trans-unit>
        <trans-unit id="2b11e388477bae4eb7798fb62c83b47e1cbed253" translate="yes" xml:space="preserve">
          <source>RFC 6265</source>
          <target state="translated">RFC 6265</target>
        </trans-unit>
        <trans-unit id="b5eb31f373a0763462f319db509a52b6efca5715" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 4.1: Set-Cookie</source>
          <target state="translated">RFC 6265, 섹션 4.1 : 쿠키 설정</target>
        </trans-unit>
        <trans-unit id="15c9cf4fea3d42ffcec6eb1b94d408b0e19bb14e" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 5.4: Cookie</source>
          <target state="translated">RFC 6265, 섹션 5.4 : 쿠키</target>
        </trans-unit>
        <trans-unit id="613865a71a94220a6a1341819550a78bc1fc41ef" translate="yes" xml:space="preserve">
          <source>RFC 6266</source>
          <target state="translated">RFC 6266</target>
        </trans-unit>
        <trans-unit id="d3105d90012e53abd5db2c45d15c178159422497" translate="yes" xml:space="preserve">
          <source>RFC 6454</source>
          <target state="translated">RFC 6454</target>
        </trans-unit>
        <trans-unit id="fd51012d090b8c63c11d5dd6844e9f25685bef76" translate="yes" xml:space="preserve">
          <source>RFC 6454, section 7: Origin</source>
          <target state="translated">RFC 6454, 섹션 7 : 원산지</target>
        </trans-unit>
        <trans-unit id="2e1c3bd109055e3c75b85953fe0738a169565c42" translate="yes" xml:space="preserve">
          <source>RFC 6455</source>
          <target state="translated">RFC 6455</target>
        </trans-unit>
        <trans-unit id="19d36fc539eae3719343f4e94df0ac87431a15c5" translate="yes" xml:space="preserve">
          <source>RFC 6585</source>
          <target state="translated">RFC 6585</target>
        </trans-unit>
        <trans-unit id="45d634e5b12466ed4cc193d856d4e4c08256a283" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 3: 428 Precondition Required</source>
          <target state="translated">RFC 6585, 섹션 3 : 428 사전 요구 사항</target>
        </trans-unit>
        <trans-unit id="07a86b3bb5912601c3ae8de2ec856a047e1a4207" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 4: 429 Too Many Requests</source>
          <target state="translated">RFC 6585, 섹션 4 : 429 너무 많은 요청</target>
        </trans-unit>
        <trans-unit id="bae288b759aab289a7b722340a6c68ada2a24664" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 5: 431 Request Header Fields Too Large</source>
          <target state="translated">RFC 6585, 섹션 5 : 431 요청 헤더 필드가 너무 큼</target>
        </trans-unit>
        <trans-unit id="f0550ad6cfb7431d8de64660db24e5adfdd0f1cd" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 6: 511 Network Authentication Required</source>
          <target state="translated">RFC 6585, 섹션 6 : 511 네트워크 인증 필요</target>
        </trans-unit>
        <trans-unit id="f59f441f51a2a15aab903870156075198c21cdcd" translate="yes" xml:space="preserve">
          <source>RFC 6797</source>
          <target state="translated">RFC 6797</target>
        </trans-unit>
        <trans-unit id="0f65e4b9ea5170ccf77ae139b024de2922225370" translate="yes" xml:space="preserve">
          <source>RFC 7034</source>
          <target state="translated">RFC 7034</target>
        </trans-unit>
        <trans-unit id="6b67e7dae86a60ad1a1b1df8824dc9553710faf9" translate="yes" xml:space="preserve">
          <source>RFC 7168</source>
          <target state="translated">RFC 7168</target>
        </trans-unit>
        <trans-unit id="0c5e351b2c4935f263fb4a48d2a5973b96f162c0" translate="yes" xml:space="preserve">
          <source>RFC 7230</source>
          <target state="translated">RFC 7230</target>
        </trans-unit>
        <trans-unit id="05085ef8bae59f857a83a325ca8b5cb7c95f7a86" translate="yes" xml:space="preserve">
          <source>RFC 7230, appendix A.1.2: Keep-Alive</source>
          <target state="translated">RFC 7230, 부록 A.1.2 : 연결 유지</target>
        </trans-unit>
        <trans-unit id="0e5d3d164e7dba93b9411bbfb503f35bd97bc36f" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 2.7: Uniform Resource Identifiers</source>
          <target state="translated">RFC 7230, 섹션 2.7 : 균일 자원 식별자</target>
        </trans-unit>
        <trans-unit id="747d53c19ff7b93c55d4b76ad86eb7700475d3b8" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.1: Transfer-Encoding</source>
          <target state="translated">RFC 7230, 섹션 3.3.1 : 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="f0a41fabfd014b8b41ea52076f5ba499d7cab7cc" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.2: Content-Length</source>
          <target state="translated">RFC 7230, 섹션 3.3.2 : 내용 길이</target>
        </trans-unit>
        <trans-unit id="ce15bb0ced28e642094a4b2e10552a5a260c63c6" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.1.2: Chunked trailer part</source>
          <target state="translated">RFC 7230, 섹션 4.1.2 : 청크 트레일러 부품</target>
        </trans-unit>
        <trans-unit id="dc4a36d13fa8deb7e75049f8717535024790d01d" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.3: TE</source>
          <target state="translated">RFC 7230, 섹션 4.3 : TE</target>
        </trans-unit>
        <trans-unit id="d01fd56ebeb831ef7c0ec347cc56581ef2c37a02" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.4: Trailer</source>
          <target state="translated">RFC 7230, 섹션 4.4 : 트레일러</target>
        </trans-unit>
        <trans-unit id="ce720dca2d38fd8ebd182748949f09c36140d1ba" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.4: Host</source>
          <target state="translated">RFC 7230, 섹션 5.4 : 호스트</target>
        </trans-unit>
        <trans-unit id="72b7097053626ce619fadddb8fd07f185dcb00c0" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.7.1: Via</source>
          <target state="translated">RFC 7230, 섹션 5.7.1 : Via</target>
        </trans-unit>
        <trans-unit id="ce9e01aff0adf150803198bb232477284f281a17" translate="yes" xml:space="preserve">
          <source>RFC 7230: Message Syntax and Routing</source>
          <target state="translated">RFC 7230 : 메시지 구문 및 라우팅</target>
        </trans-unit>
        <trans-unit id="caea547a0cf9d64aba6043b091dc5eb22f58c313" translate="yes" xml:space="preserve">
          <source>RFC 7231</source>
          <target state="translated">RFC 7231</target>
        </trans-unit>
        <trans-unit id="08e4bb7d474ebf9b4dd37dbb5dfb6ad9f1018a66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.1.5: Content-Type</source>
          <target state="translated">RFC 7231, 섹션 3.1.1.5 : 내용 유형</target>
        </trans-unit>
        <trans-unit id="845eed76936a3d924d01b333e9f1eb88f65e9b0f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.2.2: Content-Encoding</source>
          <target state="translated">RFC 7231, 섹션 3.1.2.2 : 내용 인코딩</target>
        </trans-unit>
        <trans-unit id="ea53991de97033c504914c78c87f5ffed390f149" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.3.2: Content-Language</source>
          <target state="translated">RFC 7231, 섹션 3.1.3.2 : 내용 언어</target>
        </trans-unit>
        <trans-unit id="c63e7fc6e081defb92fe9ecf5164796bcbd6a746" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.4.2: Content-Location</source>
          <target state="translated">RFC 7231, 섹션 3.1.4.2 : 컨텐츠 위치</target>
        </trans-unit>
        <trans-unit id="d4fb8e8cb57094e1102d5ce3bdd8cff5312ab200" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.1: GET</source>
          <target state="translated">RFC 7231, 섹션 4.3.1 : GET</target>
        </trans-unit>
        <trans-unit id="beb916c6c25dc7649f8c49842ab7dcda780a0246" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.2: HEAD</source>
          <target state="translated">RFC 7231, 섹션 4.3.2 : HEAD</target>
        </trans-unit>
        <trans-unit id="396a77b857e79049fe6031ef49d21a0effb58e9a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.3: POST</source>
          <target state="translated">RFC 7231, 섹션 4.3.3 : POST</target>
        </trans-unit>
        <trans-unit id="be438af5d1a292f596f21a801b7d9603f1cab40b" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.4: PUT</source>
          <target state="translated">RFC 7231, 섹션 4.3.4 : PUT</target>
        </trans-unit>
        <trans-unit id="f107039cbadc5f826dae91dd218c725e9d18d841" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.5: DELETE</source>
          <target state="translated">RFC 7231, 섹션 4.3.5 : 삭제</target>
        </trans-unit>
        <trans-unit id="1dc7248ccd888336bd82b884b087f4b3f4f4679d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.6: CONNECT</source>
          <target state="translated">RFC 7231, 섹션 4.3.6 : 연결</target>
        </trans-unit>
        <trans-unit id="5ef875b188d1b54f345842c090e95ae722453dbd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.7: OPTIONS</source>
          <target state="translated">RFC 7231, 섹션 4.3.7 : 옵션</target>
        </trans-unit>
        <trans-unit id="332f9c31f0f5c275ad307d53cca2499a9459de39" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.8: TRACE</source>
          <target state="translated">RFC 7231, 섹션 4.3.8 : TRACE</target>
        </trans-unit>
        <trans-unit id="23ec2e6bb03069a7e2356906fa0861e5c5f31298" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4: Request methods</source>
          <target state="translated">RFC 7231, 섹션 4 : 요청 방법</target>
        </trans-unit>
        <trans-unit id="ca01a74d4319434dec806f81b435f5ef7fe00cac" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.1.1: Expect</source>
          <target state="translated">RFC 7231, 섹션 5.1.1 : 예상</target>
        </trans-unit>
        <trans-unit id="482924da4508aa7f733bf03dc780a68aae52445c" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.2: Accept</source>
          <target state="translated">RFC 7231, 섹션 5.3.2 : 수락</target>
        </trans-unit>
        <trans-unit id="35accde19d283e519f8ec1ed2362fcc85f24a93d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.3: Accept-Charset</source>
          <target state="translated">RFC 7231, 섹션 5.3.3 : 수락 문자</target>
        </trans-unit>
        <trans-unit id="ad6e29ab51fd42d62fbcdb472acfb4ac84a2a268" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.4: Accept-Encoding</source>
          <target state="translated">RFC 7231, 섹션 5.3.4 : 수락 인코딩</target>
        </trans-unit>
        <trans-unit id="807a7c74e7037b7f5abd66cfb4a79ff6ae43d3b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.5: Accept-Language</source>
          <target state="translated">RFC 7231, 섹션 5.3.5 : 수락 언어</target>
        </trans-unit>
        <trans-unit id="e193dba38f7e55035b47ef2c109569e16479cf69" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.1: From</source>
          <target state="translated">RFC 7231, 섹션 5.5.1 : 시작</target>
        </trans-unit>
        <trans-unit id="b509df34815d389002b3401e3af6b97ec17a4637" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.2: Referer</source>
          <target state="translated">RFC 7231, 섹션 5.5.2 : 참조 자</target>
        </trans-unit>
        <trans-unit id="1741ea24040d407102645a5261e3be49a42c9d36" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.3: User-Agent</source>
          <target state="translated">RFC 7231, 섹션 5.5.3 : User-Agent</target>
        </trans-unit>
        <trans-unit id="12fc41e4605afa8a835cf818819d37d8835a9501" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.1: 100 Continue</source>
          <target state="translated">RFC 7231, 섹션 6.2.1 : 100 계속</target>
        </trans-unit>
        <trans-unit id="6153c15954bc862a70895fbc431bad2da954c971" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.2: 101 Switching Protocol</source>
          <target state="translated">RFC 7231, 섹션 6.2.2 : 101 스위칭 프로토콜</target>
        </trans-unit>
        <trans-unit id="bbfde0e52731d4e9dc93932249da61bebf73a1a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.1: 200 OK</source>
          <target state="translated">RFC 7231, 섹션 6.3.1 : 200 OK</target>
        </trans-unit>
        <trans-unit id="1fc7e03406eaa40d727064f1b1bc3e08b2b14fd4" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.2: 201 Created</source>
          <target state="translated">RFC 7231, 섹션 6.3.2 : 201 생성됨</target>
        </trans-unit>
        <trans-unit id="c97971bcf5eac84ad103104d1e5f58bc875207a1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.3: 202 Accepted</source>
          <target state="translated">RFC 7231, 섹션 6.3.3 : 202 허용</target>
        </trans-unit>
        <trans-unit id="5429f5aaa896873c3bed767ca81e26df2c7d4715" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.4: 203 Non-Authoritative Information</source>
          <target state="translated">RFC 7231, 섹션 6.3.4 : 203 신뢰할 수없는 정보</target>
        </trans-unit>
        <trans-unit id="c87d7f32f1d541fc3b4a3f52e5b74b91132ee59a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.5: 204 No Content</source>
          <target state="translated">RFC 7231, 섹션 6.3.5 : 204 내용 없음</target>
        </trans-unit>
        <trans-unit id="88a53ddfea1c8ca509da6b5a44b1c7abe59a44fd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.6: 205 Reset Content</source>
          <target state="translated">RFC 7231, 섹션 6.3.6 : 205 내용 재설정</target>
        </trans-unit>
        <trans-unit id="4ccda537000db21782a1059815056fc5839e13c3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.1: 300 Multiple Choices</source>
          <target state="translated">RFC 7231, 섹션 6.4.1 : 300 다중 선택</target>
        </trans-unit>
        <trans-unit id="8d103f2e9ff04ca2a770ac0401e07c62e79f89aa" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.2: 301 Redirect Permanently</source>
          <target state="translated">RFC 7231, 섹션 6.4.2 : 301 영구적으로 리디렉션</target>
        </trans-unit>
        <trans-unit id="80c5d21b755a5e2b263018667896cddc904c5323" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.3: 302 Found</source>
          <target state="translated">RFC 7231, 섹션 6.4.3 : 302 발견</target>
        </trans-unit>
        <trans-unit id="23d636dfadbfc167109f5734f6597b0cef5487e5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.4: 303 See Other</source>
          <target state="translated">RFC 7231, 섹션 6.4.4 : 303 기타 참조</target>
        </trans-unit>
        <trans-unit id="e5ee708c3ca4bdea3c8e87cba0d3aeae2df304a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.7: 307 Temporary Redirect</source>
          <target state="translated">RFC 7231, 섹션 6.4.7 : 307 임시 리디렉션</target>
        </trans-unit>
        <trans-unit id="dee8c16141db46bb418511c175d2eec007fefeed" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.10: 411 Length Required</source>
          <target state="translated">RFC 7231, 섹션 6.5.10 : 411 길이 필요</target>
        </trans-unit>
        <trans-unit id="26171f5c8cb59ffc020457ea938b7ec236d9ea28" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.11: 413 Payload Too Large</source>
          <target state="translated">RFC 7231, 섹션 6.5.11 : 413 페이로드가 너무 큼</target>
        </trans-unit>
        <trans-unit id="cee9c7a8574968783fae740117c4c07af062c5f8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.12: 414 URI Too Long</source>
          <target state="translated">RFC 7231, 섹션 6.5.12 : 414 URI가 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="58c6fc79debfdeea6e272e99df4c1743e620d756" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.13: 415 Unsupported Media Type</source>
          <target state="translated">RFC 7231, 섹션 6.5.13 : 415 지원되지 않는 미디어 유형</target>
        </trans-unit>
        <trans-unit id="0392d0e21a03c252a2bf41dd4d443c3d6b9104c7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.14: 417 Expectation Failed</source>
          <target state="translated">RFC 7231, 섹션 6.5.14 : 417 예상 실패</target>
        </trans-unit>
        <trans-unit id="57441c8550e44a304af1a569e4e597ea1887e91a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.15: 426 Upgrade Required</source>
          <target state="translated">RFC 7231, 섹션 6.5.15 : 426 업그레이드 필요</target>
        </trans-unit>
        <trans-unit id="6dd8faeaf11eb0bd52552958e7ae54b11b10b57f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.1: 400 Bad Request</source>
          <target state="translated">RFC 7231, 섹션 6.5.1 : 400 잘못된 요청</target>
        </trans-unit>
        <trans-unit id="e163a78f9330d6741a5bd6e7cdbb8e3fec5ffe5f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.3: 403 Forbidden</source>
          <target state="translated">RFC 7231, 섹션 6.5.3 : 403 금지</target>
        </trans-unit>
        <trans-unit id="b6bc1661f3cf5de1c14ac6be35b1910851cacaaf" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.4: 404 Not Found</source>
          <target state="translated">RFC 7231, 섹션 6.5.4 : 404를 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="a9844f8c14db25ad38c4cfe8d0f0b736510c9fb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.5: 405 Method Not Allowed</source>
          <target state="translated">RFC 7231, 섹션 6.5.5 : 405 방법이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fc4efdb5f2dc5dc6d424604880e980cb82e94103" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.6: 406 Not Acceptable</source>
          <target state="translated">RFC 7231, 섹션 6.5.6 : 406 허용되지 않음</target>
        </trans-unit>
        <trans-unit id="43b35d1f584a1c0099592c15ae91827db7dc94b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.7: 408 Request Timeout</source>
          <target state="translated">RFC 7231, 섹션 6.5.7 : 408 요청 시간 초과</target>
        </trans-unit>
        <trans-unit id="1b0d3945f363c33827abe747256729c99c9037c6" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.8: 409 Conflict</source>
          <target state="translated">RFC 7231, 섹션 6.5.8 : 409 충돌</target>
        </trans-unit>
        <trans-unit id="fd998823588377f38984c686c556f3bcfc09dc66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.9: 410 Gone</source>
          <target state="translated">RFC 7231, 섹션 6.5.9 : 410 사라짐</target>
        </trans-unit>
        <trans-unit id="e020731d0df0b23d948c30ebaf118d17f15bafb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.1: 500 Internal Server Error</source>
          <target state="translated">RFC 7231, 섹션 6.6.1 : 500 내부 서버 오류</target>
        </trans-unit>
        <trans-unit id="0123b7de98a247141787a487b5e238ce6e98a7c2" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.2: 501 Not Implemented</source>
          <target state="translated">RFC 7231, 섹션 6.6.2 : 501은 구현되지 않음</target>
        </trans-unit>
        <trans-unit id="d8ade00b1145627ea23139c44dc6c9c4c9e6e5b1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.3: 502 Bad Gateway</source>
          <target state="translated">RFC 7231, 섹션 6.6.3 : 502 잘못된 게이트웨이</target>
        </trans-unit>
        <trans-unit id="beb22556b06eef638a44ed63d5c6ad4adb9b6b33" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 503 Service Unavailable</source>
          <target state="translated">RFC 7231, 섹션 6.6.4 : 503 서비스를 사용할 수 없음</target>
        </trans-unit>
        <trans-unit id="f08bdf6a75d66bf8a9bbf1045e44b8379123db51" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 504 Gateway Timeout</source>
          <target state="translated">RFC 7231, 섹션 6.6.4 : 504 게이트웨이 시간 초과</target>
        </trans-unit>
        <trans-unit id="3e6e09aea7bfdaaf0dd1e985137eee45520431d3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.6: 505 HTTP Version Not Supported</source>
          <target state="translated">RFC 7231, 섹션 6.6.6 : 505 HTTP 버전이 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="b3ba7c2a99f80e2130967ae0193aa90dfc01cbe3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.1.2: Date</source>
          <target state="translated">RFC 7231, 섹션 7.1.1.2 : 날짜</target>
        </trans-unit>
        <trans-unit id="4cd70f93c86793f098a850ee9a15dfed514d641f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.2: Location</source>
          <target state="translated">RFC 7231, 섹션 7.1.2 : 위치</target>
        </trans-unit>
        <trans-unit id="b605ee3c8c03aa07e4aba2513a66cca3bddaa02a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.3: Retry-After</source>
          <target state="translated">RFC 7231, 섹션 7.1.3 : 재시도 후</target>
        </trans-unit>
        <trans-unit id="453d48122df892243f46b4738824f126f915dd76" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.4: Vary</source>
          <target state="translated">RFC 7231, 섹션 7.1.4 : 가변</target>
        </trans-unit>
        <trans-unit id="7db55929216f08581bb0f9a961b79184aed41a16" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.1: Allow</source>
          <target state="translated">RFC 7231, 섹션 7.4.1 : 허용</target>
        </trans-unit>
        <trans-unit id="9acad768df0dbe6c37cba16cbfd5595d6bc92ab0" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.2: Server</source>
          <target state="translated">RFC 7231, 섹션 7.4.2 : 서버</target>
        </trans-unit>
        <trans-unit id="c13136120d6f8f6ddbce80914e170e5f5ba98e4e" translate="yes" xml:space="preserve">
          <source>RFC 7231: Semantics and Content</source>
          <target state="translated">RFC 7231 : 의미 및 내용</target>
        </trans-unit>
        <trans-unit id="a63def99ce2877d2732ea2cc7396d5f537db97a4" translate="yes" xml:space="preserve">
          <source>RFC 7232</source>
          <target state="translated">RFC 7232</target>
        </trans-unit>
        <trans-unit id="295d565b0fec0216825a3e8cb65a1446aa3ed8b2" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.2: Last-Modified</source>
          <target state="translated">RFC 7232, 섹션 2.2 : 마지막 수정</target>
        </trans-unit>
        <trans-unit id="e2e4bc35caa4058f5fac16569cf63c21cb420386" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.3: ETag</source>
          <target state="translated">RFC 7232, 섹션 2.3 : ETag</target>
        </trans-unit>
        <trans-unit id="9bcc0918bdc69773f66aa681a671407cbdd4b5bb" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.1: If-Match</source>
          <target state="translated">RFC 7232, 섹션 3.1 : 일치하는 경우</target>
        </trans-unit>
        <trans-unit id="73bd2578dcbed6d7d7505e11efb11c61cda96b36" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.2: If-None-Match</source>
          <target state="translated">RFC 7232, 섹션 3.2 : 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="d0cfec8ff7070bfbde6decdb05c41ab3d5b5e60d" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.3: If-Modified-Since</source>
          <target state="translated">RFC 7232, 섹션 3.3 : If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="83ababad8d137088ebfa02c4cfad17ffdbaa6cb9" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.4: If-Unmodified-Since</source>
          <target state="translated">RFC 7232, 섹션 3.4 : 수정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8c6b803aef1ae0cbc7963494f52a6e2d1221aa72" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.1: 304 Not Modified</source>
          <target state="translated">RFC 7232, 섹션 4.1 : 304 수정되지 않음</target>
        </trans-unit>
        <trans-unit id="c6371edfa3fd6545f1ed9b50760abaa5432d23c6" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.2: 412 Precondition Failed</source>
          <target state="translated">RFC 7232, 섹션 4.2 : 412 사전 조건 실패</target>
        </trans-unit>
        <trans-unit id="85fcffc8931e515561355807b30267e41fd6036c" translate="yes" xml:space="preserve">
          <source>RFC 7232: Conditional Requests</source>
          <target state="translated">RFC 7232 : 조건부 요청</target>
        </trans-unit>
        <trans-unit id="0220cee7fbe573d22b712a263403a869c71ee9dd" translate="yes" xml:space="preserve">
          <source>RFC 7233</source>
          <target state="translated">RFC 7233</target>
        </trans-unit>
        <trans-unit id="24b52ae865d6573f42daca9e9ba3d5d371687dd9" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 2.3: Accept-Ranges</source>
          <target state="translated">RFC 7233, 섹션 2.3 : 수락 범위</target>
        </trans-unit>
        <trans-unit id="217e0bf69b2117ab58b4e0362c97f19fa1befd75" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.1: Range</source>
          <target state="translated">RFC 7233, 섹션 3.1 : 범위</target>
        </trans-unit>
        <trans-unit id="60ffdc5927f45232551eeaf6f5b683a4c7108395" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.2: If-Range</source>
          <target state="translated">RFC 7233, 섹션 3.2 : 범위</target>
        </trans-unit>
        <trans-unit id="60f87acc5e83708a238fe44d6d995662a04d25cb" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: 206 Partial Content</source>
          <target state="translated">RFC 7233, 섹션 4.1 : 206 부분 내용</target>
        </trans-unit>
        <trans-unit id="c97dc325c5a2c56a80141bafdec4776ec6494289" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: Content-Type in multipart</source>
          <target state="translated">RFC 7233, 섹션 4.1 : 멀티 파트의 컨텐츠 유형</target>
        </trans-unit>
        <trans-unit id="b2f0b42f9b254f4e75cc959dec9a41424191299d" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.2: Content-Range</source>
          <target state="translated">RFC 7233, 섹션 4.2 : 내용 범위</target>
        </trans-unit>
        <trans-unit id="17ab846647e11ad24dd7cae43b5b7ba50f8d5783" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.4: 416 Request Not Satisfiable</source>
          <target state="translated">RFC 7233, 섹션 4.4 : 416 요청이 만족스럽지 않음</target>
        </trans-unit>
        <trans-unit id="39280b50b8604fb2c52645b83bb68d63d5aea084" translate="yes" xml:space="preserve">
          <source>RFC 7233: Range Requests</source>
          <target state="translated">RFC 7233 : 범위 요청</target>
        </trans-unit>
        <trans-unit id="d73ca14480035f6afc269fff0b2cbd5e7a9d5226" translate="yes" xml:space="preserve">
          <source>RFC 7234</source>
          <target state="translated">RFC 7234</target>
        </trans-unit>
        <trans-unit id="b7b8fb4415d92cc12caa06d3116834044fd58735" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.1: Age</source>
          <target state="translated">RFC 7234, 섹션 5.1 : 연령</target>
        </trans-unit>
        <trans-unit id="8f0ec2babea29f2d75d8b6c1eeefe35f6783a262" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.3: Expires</source>
          <target state="translated">RFC 7234, 섹션 5.3 : 만료</target>
        </trans-unit>
        <trans-unit id="b61069d359f94e29544f46f37732668c2e0dc488" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.4: Pragma</source>
          <target state="translated">RFC 7234, 섹션 5.4 : Pragma</target>
        </trans-unit>
        <trans-unit id="e5b281777a588dfebb9e4f33147f9393c44ff9d5" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.5: Warning</source>
          <target state="translated">RFC 7234, 섹션 5.5 : 경고</target>
        </trans-unit>
        <trans-unit id="15c277735dd7ab9d554b55649227872a7a319b2e" translate="yes" xml:space="preserve">
          <source>RFC 7234: Caching</source>
          <target state="translated">RFC 7234 : 캐싱</target>
        </trans-unit>
        <trans-unit id="95e2fdb4338d98c3460a6ba511c8317ede846646" translate="yes" xml:space="preserve">
          <source>RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">RFC 7234 : 하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱</target>
        </trans-unit>
        <trans-unit id="7f05efb06e3e1509abf29d93ad4e47416b9ccc82" translate="yes" xml:space="preserve">
          <source>RFC 7235</source>
          <target state="translated">RFC 7235</target>
        </trans-unit>
        <trans-unit id="11160b7b94c66c72e517d2361647cbfe55fa56cb" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.1: 401 Unauthorized</source>
          <target state="translated">RFC 7235, 섹션 3.1 : 401 무단</target>
        </trans-unit>
        <trans-unit id="8d8532df2f09e49337c4c44dc682d4d79601e9b4" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.2: 407 Proxy Authentication Required</source>
          <target state="translated">RFC 7235, 섹션 3.2 : 407 프록시 인증 필요</target>
        </trans-unit>
        <trans-unit id="614dc9841e719e4ac1a80ff45d19cd0f0c9471e6" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.1: WWW-Authenticate</source>
          <target state="translated">RFC 7235, 섹션 4.1 : WWW 인증</target>
        </trans-unit>
        <trans-unit id="a2b8a63336dfcfbb148fd489dd97af9d7523c4c5" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.2: Authorization</source>
          <target state="translated">RFC 7235, 섹션 4.2 : 인증</target>
        </trans-unit>
        <trans-unit id="ad222d9356ff1738b54e88377024fa368f6aa997" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.3: Proxy-Authenticate</source>
          <target state="translated">RFC 7235, 섹션 4.3 : 프록시 인증</target>
        </trans-unit>
        <trans-unit id="ce095e11e9ac5123f50e10205d7a968f6a419fbd" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.4: Proxy-Authorization</source>
          <target state="translated">RFC 7235, 섹션 4.4 : 프록시 인증</target>
        </trans-unit>
        <trans-unit id="92acef83d821fd2467bc28bd2fd60d10ec1c7cc9" translate="yes" xml:space="preserve">
          <source>RFC 7235: Authentication</source>
          <target state="translated">RFC 7235 : 인증</target>
        </trans-unit>
        <trans-unit id="39253ac4ebddd236a15a85088849c6a80583c2fe" translate="yes" xml:space="preserve">
          <source>RFC 7239</source>
          <target state="translated">RFC 7239</target>
        </trans-unit>
        <trans-unit id="6123756e88cf4a45823e0759687abb9c00f566cc" translate="yes" xml:space="preserve">
          <source>RFC 7239, section 4: Forwarded</source>
          <target state="translated">RFC 7239, 섹션 4 : 전달</target>
        </trans-unit>
        <trans-unit id="2513b2cc7a8731819cb7304e73f8bd0c92970573" translate="yes" xml:space="preserve">
          <source>RFC 7301</source>
          <target state="translated">RFC 7301</target>
        </trans-unit>
        <trans-unit id="e53ba536932ce8bea18cc606f0e1b867a58004cf" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins</source>
          <target state="translated">RFC 7469, 섹션 2.1 : 공개 키 핀</target>
        </trans-unit>
        <trans-unit id="f73866d0b27647fd51170d239bc52eb95cc3fa80" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins-Report-Only</source>
          <target state="translated">RFC 7469, 섹션 2.1 : 공개 키 핀 보고서 만</target>
        </trans-unit>
        <trans-unit id="7d33083b52d3c2f5c0c6e4555c83f4c7a93666d3" translate="yes" xml:space="preserve">
          <source>RFC 7538</source>
          <target state="translated">RFC 7538</target>
        </trans-unit>
        <trans-unit id="c18f1a9e84a66e50185533b4e1d6c5b801e53f75" translate="yes" xml:space="preserve">
          <source>RFC 7538, section 3: 308 Permanent Redirect</source>
          <target state="translated">RFC 7538, 섹션 3 : 308 영구 리디렉션</target>
        </trans-unit>
        <trans-unit id="381a51e0e8724bb0e7528dce36a046520ef83310" translate="yes" xml:space="preserve">
          <source>RFC 7540</source>
          <target state="translated">RFC 7540</target>
        </trans-unit>
        <trans-unit id="52f90fdebc595d706e0153547db03d37bcb956f4" translate="yes" xml:space="preserve">
          <source>RFC 7541</source>
          <target state="translated">RFC 7541</target>
        </trans-unit>
        <trans-unit id="16fe2f0e9c1d829ee3481e9a51d563391aac14b0" translate="yes" xml:space="preserve">
          <source>RFC 7578</source>
          <target state="translated">RFC 7578</target>
        </trans-unit>
        <trans-unit id="60d6f8ab48b07523a864373ca4d1105c601e0a56" translate="yes" xml:space="preserve">
          <source>RFC 7617</source>
          <target state="translated">RFC 7617</target>
        </trans-unit>
        <trans-unit id="16bb582fedfa8c1bed21cfd9a33eb35b67ce48ef" translate="yes" xml:space="preserve">
          <source>RFC 7725</source>
          <target state="translated">RFC 7725</target>
        </trans-unit>
        <trans-unit id="b3c12a54619425f8c7eeee0564e7f9c3445ee5e2" translate="yes" xml:space="preserve">
          <source>RFC 7725: 451 Unavailable For Legal Reasons</source>
          <target state="translated">RFC 7725 : 법적 사유로 451을 사용할 수 없음</target>
        </trans-unit>
        <trans-unit id="4c3ce0e7d6d5e6d33d64ba958f7a104cfc60ffd0" translate="yes" xml:space="preserve">
          <source>RFC 7838</source>
          <target state="translated">RFC 7838</target>
        </trans-unit>
        <trans-unit id="98a96516560a300a5745bcfe44d56d86a7703616" translate="yes" xml:space="preserve">
          <source>RFC 7932: Brotli Compressed Data Format</source>
          <target state="translated">RFC 7932 : Brotli 압축 데이터 형식</target>
        </trans-unit>
        <trans-unit id="72d8ba28c60c4ceca4316e723297a3f77d3efdaa" translate="yes" xml:space="preserve">
          <source>RFC 8246</source>
          <target state="translated">RFC 8246</target>
        </trans-unit>
        <trans-unit id="f103f5fd279c09f20f0c5ca89184d4caecaccd28" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.1: The Early-Data Header Field</source>
          <target state="translated">RFC 8470, 섹션 5.1 : 초기 데이터 헤더 필드</target>
        </trans-unit>
        <trans-unit id="a0eebba627153a93ef3a322033c309ca579202f0" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.2: 425: Early Data</source>
          <target state="translated">RFC 8470, 섹션 5.2 : 425 : 초기 데이터</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="9b88ba0fe4aa1b0d39f03df49c05115f581fef09" translate="yes" xml:space="preserve">
          <source>Range (RFC 2616)</source>
          <target state="translated">범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5039997fc0613071590aceb1ddcbf09f19902112" translate="yes" xml:space="preserve">
          <source>Range (RFC 7233)</source>
          <target state="translated">범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="75e5476d2fa33e515b99ac682187fa29b2de5aea" translate="yes" xml:space="preserve">
          <source>Range requests</source>
          <target state="translated">범위 요청</target>
        </trans-unit>
        <trans-unit id="cbd19be28e80eee61c6befb6a6a0e0189a81e54b" translate="yes" xml:space="preserve">
          <source>Range units are intended to be extensible.  New range units ought to
   be registered with IANA, as defined in &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;.

     other-range-unit = token</source>
          <target state="translated">범위 단위는 확장 가능하도록 고안되었습니다. 새로운 범위 단위는 &lt;a href=&quot;#section-5.1&quot;&gt;5.1 절에&lt;/a&gt; 정의 된대로 IANA에 등록해야합니다 . other-range-unit = 토큰</target>
        </trans-unit>
        <trans-unit id="ed40b9d6cc0d0cb3ce7a7ad02dba7338812a8080" translate="yes" xml:space="preserve">
          <source>Read the response sent by the server:</source>
          <target state="translated">서버가 보낸 응답을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7877f60e00a2d773f57c4014d0a738ad9861667e" translate="yes" xml:space="preserve">
          <source>Reading Do Not Track status from JavaScript</source>
          <target state="translated">JavaScript에서 상태를 추적하지 않음 읽기</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="ed3274e667a68705864a7876442c08c9a0c89279" translate="yes" xml:space="preserve">
          <source>Reason: CORS disabled</source>
          <target state="translated">이유 : CORS 비활성화</target>
        </trans-unit>
        <trans-unit id="f5163ddcca584feb16b95fbbfa91c4d7d0260331" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; does not match &amp;lsquo;xyz&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 'xyz'와 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="5bdd6c0c5118a6b13076b0be624dd329902e18ef" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; missing</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1658865d36eb134fe7d46709a144c1d565865930" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Origin&amp;rsquo; cannot be added</source>
          <target state="translated">이유 : CORS 헤더 'Origin'을 추가 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="aef82a650f94d9766311469581926f1ed57a82f8" translate="yes" xml:space="preserve">
          <source>Reason: CORS preflight channel did not succeed</source>
          <target state="translated">이유 : CORS 프리 플라이트 채널이 성공하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="07e1781531cc98f0e96de22d1192b8d4d3333825" translate="yes" xml:space="preserve">
          <source>Reason: CORS request did not succeed</source>
          <target state="translated">이유 : CORS 요청이 실패했습니다</target>
        </trans-unit>
        <trans-unit id="09c9cb183a85be0b3b6cde7b88314ddcd37427b3" translate="yes" xml:space="preserve">
          <source>Reason: CORS request external redirect not allowed</source>
          <target state="translated">이유 : CORS 요청 외부 리디렉션이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="868608d4173aba486e510c1993aebd1346b28581" translate="yes" xml:space="preserve">
          <source>Reason: CORS request not http</source>
          <target state="translated">이유 : CORS가 http가 아닌 요청</target>
        </trans-unit>
        <trans-unit id="756ce5c83972090dfd18afc09136a9721594344b" translate="yes" xml:space="preserve">
          <source>Reason: Credential is not supported if the CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; is &amp;lsquo;*&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 '*'인 경우 신임 정보가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61897273348d9502ac4a9cbfc6912d021a1fdadc" translate="yes" xml:space="preserve">
          <source>Reason: Did not find method in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Methods'에서 메소드를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="cde3fd2f65e458b45dfb439c839198bdc521c6f3" translate="yes" xml:space="preserve">
          <source>Reason: Multiple CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; not allowed</source>
          <target state="translated">이유 : 여러 CORS 헤더 'Access-Control-Allow-Origin'이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8f5f20e78993baa10a1b749e10443f8fcd3944" translate="yes" xml:space="preserve">
          <source>Reason: expected &amp;lsquo;true&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Credentials&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Credentials'에 예상되는 'true'</target>
        </trans-unit>
        <trans-unit id="50a43b6e0fb5601d24499970d71432793694c9ad" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Headers'의 유효하지 않은 토큰 'xyz'</target>
        </trans-unit>
        <trans-unit id="b8cfc9f82a605294184410b4a2e649b6e93163c6" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Methods'의 유효하지 않은 토큰 'xyz'</target>
        </trans-unit>
        <trans-unit id="ceb18ef27a39563d15f30fc87ea5ec94ceb819ce" translate="yes" xml:space="preserve">
          <source>Reason: missing token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo; from CORS preflight channel</source>
          <target state="translated">이유 : CORS 프리 플라이트 채널의 CORS 헤더 'Access-Control-Allow-Headers'에 토큰 'xyz'가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea166a8dce951acdcb755ee27ef556a370c2d19d" translate="yes" xml:space="preserve">
          <source>Recent versions of Firefox support as well:</source>
          <target state="translated">최신 버전의 Firefox도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6422fcc967f452634a501ffeeec039bbb50d3cbc" translate="yes" xml:space="preserve">
          <source>Recommendation</source>
          <target state="translated">Recommendation</target>
        </trans-unit>
        <trans-unit id="bd1aceb143f071d874bbc123b72264a36a503ab4" translate="yes" xml:space="preserve">
          <source>Recommendations on &lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;sniffing the UA string for cross-browser support&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;크로스 브라우저 지원을 위해 UA 문자열 스니핑에 대한&lt;/a&gt; 권장 사항</target>
        </trans-unit>
        <trans-unit id="cfa5b8af1af0a8bb6eedbb724cbc97011a905b75" translate="yes" xml:space="preserve">
          <source>Recording and analyzing user behavior</source>
          <target state="translated">사용자 행동 기록 및 분석</target>
        </trans-unit>
        <trans-unit id="7c8d8fc9cfc5aced3cb8d64bdef12d562b42debf" translate="yes" xml:space="preserve">
          <source>RedBot</source>
          <target state="translated">RedBot</target>
        </trans-unit>
        <trans-unit id="637dfb39d3c34e08850ea6f3b5b6369d2f7469e2" translate="yes" xml:space="preserve">
          <source>Redirect responses (300-303, 305, and 307) defined in HTTP 1.1
   normally take a Location header to indicate the new URI for the
   single resource redirected from the Request-URI.  Multi-Status
   responses contain many resource addresses, but the original
   definition in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] did not have any place for the server to
   provide the new URI for redirected resources.  This specification
   does define a 'location' element for this information (see
   &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;).  Servers MUST use this new element with redirect
   responses in Multi-Status.

   Clients encountering redirected resources in Multi-Status MUST NOT
   rely on the 'location' element being present with a new URI.  If the
   element is not present, the client MAY reissue the request to the
   individual redirected resource, because the response to that request
   can be redirected with a Location header containing the new URI.</source>
          <target state="translated">HTTP 1.1에 정의 된 리디렉션 응답 (300-303, 305 및 307)은 일반적으로 Location 헤더를 사용하여 Request-URI에서 리디렉션 된 단일 리소스의 새 URI를 나타냅니다. 다중 상태 응답에는 많은 리소스 주소가 포함되어 있지만 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 의 원래 정의 에는 서버가 리디렉션 된 리소스에 대한 새 URI를 제공 할 위치가 없었습니다. 이 규격은이 정보에 대한 'location'요소를 정의한다 ( &lt;a href=&quot;#section-14.9&quot;&gt;14.9 절&lt;/a&gt; 참조) ). 서버는 다중 상태에서 리디렉션 응답과 함께이 새로운 요소를 사용해야합니다. 다중 상태에서 리디렉션 된 리소스가 발생한 클라이언트는 새 URI가있는 'location'요소에 의존해서는 안됩니다. 요소가 존재하지 않는 경우, 클라이언트는 요청을 개별 URI로 포함하는 Location 헤더로 리디렉션 할 수 있기 때문에 개별 리디렉션 된 리소스에 요청을 재발행 할 수있다.</target>
        </trans-unit>
        <trans-unit id="629ead9203c19213fba2446477411c8ec459423b" translate="yes" xml:space="preserve">
          <source>Redirection loops</source>
          <target state="translated">리디렉션 루프</target>
        </trans-unit>
        <trans-unit id="1fb2905c36033fc913fb566ea3c5bcb1318a9e57" translate="yes" xml:space="preserve">
          <source>Redirection loops happen when successive redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will be found ultimately.</source>
          <target state="translated">재 지정 루프는 연속 된 재 지정이 이미 수행 된 재 지정을 따르는 경우에 발생합니다. 다시 말해, 완료되지 않은 루프가 있으며 궁극적으로 페이지를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7dd5917ae785b261fda27b44b5ec5a2d680b36d" translate="yes" xml:space="preserve">
          <source>Redirection messages</source>
          <target state="translated">리디렉션 메시지</target>
        </trans-unit>
        <trans-unit id="eeb9caefdf646c7a0ccceccdf48dd3a42d43224b" translate="yes" xml:space="preserve">
          <source>Redirections</source>
          <target state="translated">Redirections</target>
        </trans-unit>
        <trans-unit id="e3bba96caf77bd92cd7d8b0c96235d33da0b22c4" translate="yes" xml:space="preserve">
          <source>Redirections in JavaScript are created by setting a value to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt; property and the new page is loaded.</source>
          <target state="translated">JavaScript에서 리디렉션은 값을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt; 속성 으로 설정하여 만들어지며 새 페이지가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="37dc3110ba191c2d77df0cde3470992c711d2947" translate="yes" xml:space="preserve">
          <source>Redirects can be set either in the server config file or in the &lt;code&gt;.htaccess&lt;/code&gt; of each directory.</source>
          <target state="translated">리디렉션은 서버 구성 파일 또는 각 디렉토리 의 &lt;code&gt;.htaccess&lt;/code&gt; 에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="699b2fb0910ccc7c0854d17a2041a907709ed3c1" translate="yes" xml:space="preserve">
          <source>Referer</source>
          <target state="translated">Referer</target>
        </trans-unit>
        <trans-unit id="7d600afde85bf128bed4081c176fe7edf403b856" translate="yes" xml:space="preserve">
          <source>Referer (RFC 2616)</source>
          <target state="translated">레퍼러 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="b1bb97f5316cdb3a06386f7cb3cc6564f44f772d" translate="yes" xml:space="preserve">
          <source>Referer (RFC 7231)</source>
          <target state="translated">레퍼러 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="548b0b909e2d1062b7de321059c220fba862be3b" translate="yes" xml:space="preserve">
          <source>Referrer</source>
          <target state="translated">Referrer</target>
        </trans-unit>
        <trans-unit id="e9085bde7a7780a48ca2a79ea2ef1b8e36c397ae" translate="yes" xml:space="preserve">
          <source>Referrer Policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d6a82203aab19c5732c260c1b17608ee8ddd53" translate="yes" xml:space="preserve">
          <source>Referrer-Policy</source>
          <target state="translated">Referrer-Policy</target>
        </trans-unit>
        <trans-unit id="81812b5ae7e147b994882094bc1bfac513c944bc" translate="yes" xml:space="preserve">
          <source>Refers to the empty set; that is, no URLs match. The single quotes are required.</source>
          <target state="translated">빈 세트를 나타냅니다. 즉, 일치하는 URL이 없습니다. 작은 따옴표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5c14c5b41372e5f4d7d2284be0cef39d021c62d6" translate="yes" xml:space="preserve">
          <source>Refers to the origin from which the protected document is being served, including the same URL scheme and port number. You must include the single quotes. Some browsers specifically exclude &lt;code&gt;blob&lt;/code&gt; and &lt;code&gt;filesystem&lt;/code&gt; from source directives. Sites needing to allow these content types can specify them using the Data attribute.</source>
          <target state="translated">동일한 URL 체계 및 포트 번호를 포함하여 보호 된 문서가 제공되는 출처를 나타냅니다. 작은 따옴표를 포함해야합니다. 일부 브라우저는 특히 소스 지시문에서 &lt;code&gt;blob&lt;/code&gt; 및 &lt;code&gt;filesystem&lt;/code&gt; 을 제외 합니다. 이러한 컨텐츠 유형을 허용해야하는 사이트는 데이터 속성을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="666b2fc5e19b42683e17cd8e2c18048b27596c23" translate="yes" xml:space="preserve">
          <source>Registration of an HTTP Range Unit MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 범위 단위의 등록에는 다음 필드가 포함되어야합니다. o 이름 o 설명 o 사양 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( [RFC5226], 4.1 항 참조 ).</target>
        </trans-unit>
        <trans-unit id="072544a89921ea204166220b6ecbe57052aede21" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Authentication Scheme Name

   o  Pointer to specification text

   o  Notes (optional)

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 인증 체계 이름 o 사양 텍스트에 대한 포인터 o 참고 (선택 사항)이 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], 섹션 4.1 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3900f3dae5507cbea7f7a037aa9cc17206c5b409" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Names of transfer codings MUST NOT overlap with names of content
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;) unless the encoding
   transformation is identical, as is the case for the compression
   codings defined in &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.

   Values to be added to this namespace require IETF Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;4.1 of [RFC5226]&lt;/a&gt;), and MUST conform to the purpose of transfer coding
   defined in this specification.

   Use of program names for the identification of encoding formats is
   not desirable and is discouraged for future encodings.</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 이름 o 설명 o 사양 텍스트에 대한 포인터 전송 코딩의 이름은 인코딩 변환이 동일한 경우가 아니라면 콘텐츠 코딩의 이름 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]의 3.1.2.1 섹션)&lt;/a&gt; 과 겹치지 않아야 합니다. 정의 압축 코딩 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 이 네임 스페이스에 추가되는 값은 IETF 검토 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;섹션 &lt;/a&gt;4.1 참조)가 필요 하며이 사양에 정의 된 전송 코딩의 목적을 준수해야합니다. 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d151bc7b242db455dafecdde98d424a7fbe5826b" translate="yes" xml:space="preserve">
          <source>Related headers: &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관련 헤더 : &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a02133d506baccd9607b7a86c4dbb504734c4a1" translate="yes" xml:space="preserve">
          <source>Related status codes &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관련 상태 코드 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2034c07c455dea528b5c044f32d891f3327323d4" translate="yes" xml:space="preserve">
          <source>Related utility functions</source>
          <target state="translated">관련 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e0239139fec07795176258d50edee26a1aa0c492" translate="yes" xml:space="preserve">
          <source>Relaxing the security-model of the Web</source>
          <target state="translated">웹 보안 모델 완화</target>
        </trans-unit>
        <trans-unit id="6924dcad4d5ebf6c89d8fdf2adb56994263c7fe3" translate="yes" xml:space="preserve">
          <source>Rendering engine</source>
          <target state="translated">렌더링 엔진</target>
        </trans-unit>
        <trans-unit id="048baaee6737f98c6e3617392ee0aa92a328acc5" translate="yes" xml:space="preserve">
          <source>Rendering engine version</source>
          <target state="translated">렌더링 엔진 버전</target>
        </trans-unit>
        <trans-unit id="f5a55dcde49099910df9c704e7c97c70be2ccc80" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site, with non-GET links/operations.</source>
          <target state="translated">비 GET 링크 / 작업으로 웹 사이트 재구성</target>
        </trans-unit>
        <trans-unit id="6069aff506484cfe4ca0e6dc53acad55e6682b1e" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site.</source>
          <target state="translated">웹 사이트의 재구성.</target>
        </trans-unit>
        <trans-unit id="d67bc0e6c0c6dc1b32fa80aa1a759051dbd62d55" translate="yes" xml:space="preserve">
          <source>Report-Only header</source>
          <target state="translated">보고서 전용 헤더</target>
        </trans-unit>
        <trans-unit id="06d6c29bfb10b8b70b6c5a76ac8a545632073eb1" translate="yes" xml:space="preserve">
          <source>Reporting API</source>
          <target state="translated">보고 API</target>
        </trans-unit>
        <trans-unit id="e0ff584859d7c7f3e165e23c136c2c4b65edc9dc" translate="yes" xml:space="preserve">
          <source>Reporting directive</source>
          <target state="translated">보고 지시어</target>
        </trans-unit>
        <trans-unit id="49734955482cddad14d7d6086f6396c10758c821" translate="yes" xml:space="preserve">
          <source>Reporting directives</source>
          <target state="translated">보고 지시문</target>
        </trans-unit>
        <trans-unit id="6e53788c8a0b65951ac470b7cdcba8ef12feb88d" translate="yes" xml:space="preserve">
          <source>Reporting directives control the reporting process of CSP violations. See also the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">보고 지시문은 CSP 위반의보고 프로세스를 제어합니다. &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="faafcc65691f4495ef2dd9f54e8f8dbc76133274" translate="yes" xml:space="preserve">
          <source>Representation header fields provide metadata about the
   representation.  When a message includes a payload body, the
   representation header fields describe how to interpret the
   representation data enclosed in the payload body.  In a response to a
   HEAD request, the representation header fields describe the
   representation data that would have been enclosed in the payload body
   if the same request had been a GET.

   The following header fields convey representation metadata:

   +-------------------+-----------------+
   | Header Field Name | Defined in...   |
   +-------------------+-----------------+
   | Content-Type      | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Content-Encoding  | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   +-------------------+-----------------+</source>
          <target state="translated">표현 헤더 필드는 표현에 대한 메타 데이터를 제공합니다. 메시지에 페이로드 본문이 포함 된 경우 표현 헤더 필드는 페이로드 본문에 포함 된 표현 데이터를 해석하는 방법을 설명합니다. HEAD 요청에 대한 응답으로, 표현 헤더 필드는 동일한 요청이 GET 인 경우 페이로드 본문에 포함 된 표현 데이터를 설명합니다. 다음 헤더 필드는 표현 메타 데이터를 전달합니다. + ------------------- + ----------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + ----------------- + | 컨텐츠 유형 | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5 절&lt;/a&gt; | | 콘텐츠 인코딩 | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;3.1.2.2 절&lt;/a&gt; | | 콘텐츠 언어 | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;3.1.3.2 절&lt;/a&gt;| | 컨텐츠 위치 | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; | + ------------------- + ----------------- +</target>
        </trans-unit>
        <trans-unit id="e405e17158b8b239987e79f57e2f7771ef0097af" translate="yes" xml:space="preserve">
          <source>Representations (RFC 7231)</source>
          <target state="translated">표현 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4aed03cac49d5e43da4e855a967286931a4d621a" translate="yes" xml:space="preserve">
          <source>Request</source>
          <target state="translated">Request</target>
        </trans-unit>
        <trans-unit id="92f88e2c8e9bb975a09d205785b581b72223d69c" translate="yes" xml:space="preserve">
          <source>Request (RFC 2616)</source>
          <target state="translated">요청 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="209107c4e6e87baa9562058df6689267d77f72ab" translate="yes" xml:space="preserve">
          <source>Request and Response messages MAY transfer an entity if not otherwise
   restricted by the request method or response status code. An entity
   consists of entity-header fields and an entity-body, although some
   responses will only include the entity-headers.

   In this section, both sender and recipient refer to either the client
   or the server, depending on who sends and who receives the entity.</source>
          <target state="translated">요청 및 응답 메시지는 요청 방법 또는 응답 상태 코드에 의해 달리 제한되지 않는 경우 엔티티를 전송할 수 있습니다. 엔터티는 엔터티 헤더 필드와 엔터티 본문으로 구성되지만 일부 응답에는 엔터티 헤더 만 포함됩니다. 이 섹션에서 보낸 사람과받는 사람은 모두 엔터티를 보내고받는 사람에 따라 클라이언트 또는 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b4ccb0ae69ff9044ffa521ca4c16ab4e8a2bb624" translate="yes" xml:space="preserve">
          <source>Request context</source>
          <target state="translated">요청 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6ee7b5c7d1970d29bd49eb9d029bff7b4b9637c8" translate="yes" xml:space="preserve">
          <source>Request entity is larger than limits defined by server; the server might close the connection or return an &lt;code&gt;Retry-After&lt;/code&gt; header field.</source>
          <target state="translated">요청 엔터티가 서버에서 정의한 제한보다 큽니다. 서버가 연결을 닫거나 &lt;code&gt;Retry-After&lt;/code&gt; 헤더 필드를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3e3eaae6a46abf6af6e09d0d998a3ceec713b2" translate="yes" xml:space="preserve">
          <source>Request has body</source>
          <target state="translated">요청에 본문이 있음</target>
        </trans-unit>
        <trans-unit id="a9528878e11c1033e6bd63ba8721a8f88c91e374" translate="yes" xml:space="preserve">
          <source>Request header</source>
          <target state="translated">요청 헤더</target>
        </trans-unit>
        <trans-unit id="30eaa32f64dd1274f348ded1be63b905756fabff" translate="yes" xml:space="preserve">
          <source>Request methods</source>
          <target state="translated">요청 방법</target>
        </trans-unit>
        <trans-unit id="3437c4d523fcec9c5dbe6ca25b313e8b0c9faa07" translate="yes" xml:space="preserve">
          <source>Request methods are considered &quot;safe&quot; if their defined semantics are
   essentially read-only; i.e., the client does not request, and does
   not expect, any state change on the origin server as a result of
   applying a safe method to a target resource.  Likewise, reasonable
   use of a safe method is not expected to cause any harm, loss of
   property, or unusual burden on the origin server. 

   This definition of safe methods does not prevent an implementation
   from including behavior that is potentially harmful, that is not
   entirely read-only, or that causes side effects while invoking a safe
   method.  What is important, however, is that the client did not
   request that additional behavior and cannot be held accountable for
   it.  For example, most servers append request information to access
   log files at the completion of every response, regardless of the
   method, and that is considered safe even though the log storage might
   become full and crash the server.  Likewise, a safe request initiated
   by selecting an advertisement on the Web will often have the side
   effect of charging an advertising account.

   Of the request methods defined by this specification, the GET, HEAD,
   OPTIONS, and TRACE methods are defined to be safe.

   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.  In
   addition, it allows a user agent to apply appropriate constraints on
   the automated use of unsafe methods when processing potentially
   untrusted content.

   A user agent SHOULD distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be
   made aware of an unsafe action before it is requested.

   When a resource is constructed such that parameters within the
   effective request URI have the effect of selecting an action, it is
   the resource owner's responsibility to ensure that the action is
   consistent with the request method semantics.  For example, it is
   common for Web-based content editing software to use actions within
   query parameters, such as &quot;page?do=delete&quot;.  If the purpose of such a
   resource is to perform an unsafe action, then the resource owner MUST
   disable or disallow that action when it is accessed using a safe
   request method.  Failure to do so will result in unfortunate side
   effects when automated processes perform a GET on every URI reference
   for the sake of link maintenance, pre-fetching, building a search
   index, etc.</source>
          <target state="translated">정의 된 의미론이 본질적으로 읽기 전용 인 경우 요청 메소드는 &quot;안전한&quot;것으로 간주됩니다. 즉, 클라이언트는 안전한 방법을 대상 자원에 적용한 결과로 오리진 서버에서 상태 변경을 요청하지 않으며 예상하지 않습니다. 마찬가지로, 안전한 방법을 합리적으로 사용한다고해서 원산지 서버에 해를 입거나 재산 손실 또는 비정상적인 부담이 발생하지는 않습니다. 안전한 메소드에 대한이 정의는 구현이 잠재적으로 유해하거나, 완전히 읽기 전용이 아니거나, 안전한 메소드를 호출하는 동안 부작용을 일으키는 동작을 포함하는 것을 막지 않습니다. 그러나 중요한 것은 고객이 추가 행동을 요청하지 않았으며 이에 대한 책임을 질 수 없다는 것입니다. 예를 들어대부분의 서버는 방법에 관계없이 모든 응답이 완료 될 때마다 로그 파일에 액세스하기 위해 요청 정보를 추가하며, 로그 스토리지가 가득 차서 서버에 충돌이 발생하더라도 안전하다고 간주됩니다. 마찬가지로, 웹에서 광고를 선택하여 시작된 안전한 요청은 종종 광고 계정을 청구하는 부작용이 있습니다. 이 사양에서 정의한 요청 방법 중 GET, HEAD, OPTIONS 및 TRACE 방법은 안전하도록 정의되어 있습니다. 안전한 방법과 안전하지 않은 방법을 구별하는 목적은 자동화 된 검색 프로세스 (스파이더)와 캐시 성능 최적화 (프리 페치)가 피해를 입을 염려없이 작동하도록하는 것입니다. 게다가,신뢰할 수없는 내용을 처리 할 때 안전하지 않은 방법의 자동화 된 사용에 사용자 에이전트가 적절한 제한을 적용 할 수 있습니다. 사용자 에이전트는 잠재적 조치를 사용자에게 제시 할 때 안전 및 안전하지 않은 방법을 구별하여 요청되기 전에 사용자가 안전하지 않은 조치를 인식하도록해야합니다. 유효 요청 URI 내의 매개 변수가 조치를 선택하는 효과를 갖도록 자원이 구성된 경우, 조치가 요청 메소드 시맨틱과 일치하는지 확인하는 것은 자원 소유자의 책임입니다. 예를 들어, 웹 기반 컨텐츠 편집 소프트웨어는 &quot;page? do = delete&quot;와 같은 쿼리 매개 변수 내에서 조치를 사용하는 것이 일반적입니다. 그러한 자원의 목적이 안전하지 않은 조치를 수행하는 것이라면,그런 다음 리소스 소유자는 안전한 요청 방법을 사용하여 액세스 할 때 해당 작업을 비활성화하거나 허용하지 않아야합니다. 그렇지 않으면 자동화 된 프로세스가 링크 유지 보수, 프리 페치, 검색 색인 작성 등을 위해 모든 URI 참조에서 GET을 수행 할 때 부작용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9b6ad5f3d071161c8b3a3dfe4a105628b443960" translate="yes" xml:space="preserve">
          <source>Request methods can be defined as &quot;cacheable&quot; to indicate that
   responses to them are allowed to be stored for future reuse; for
   specific requirements see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  In general, safe methods that
   do not depend on a current or authoritative response are defined as
   cacheable; this specification defines GET, HEAD, and POST as
   cacheable, although the overwhelming majority of cache
   implementations only support GET and HEAD.</source>
          <target state="translated">요청 방법은 &quot;캐시 블 가능&quot;으로 정의되어 향후 재사용을 위해 응답을 저장할 수 있음을 나타냅니다. 특정 요구 사항은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]를 참조하십시오 . 일반적으로 현재 또는 신뢰할 수있는 응답에 의존하지 않는 안전한 방법은 캐시 가능으로 정의됩니다. 이 사양은 GET, HEAD 및 POST를 캐시 가능한 것으로 정의하지만 압도적 인 대다수의 캐시 구현은 GET 및 HEAD 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0fe2385cde5e7e860a739c3f7a915be25d6759e0" translate="yes" xml:space="preserve">
          <source>Request requires preflight, which is disallowed to follow cross-origin redirect</source>
          <target state="translated">요청에 프리 플라이트가 필요합니다. 프리 플라이트는 교차 출처 리디렉션을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="503b534d1cc7a82dc13ef87bb3f5b88cfd30bfc5" translate="yes" xml:space="preserve">
          <source>Request smuggling ([&lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]) is a technique that exploits
   differences in protocol parsing among various recipients to hide
   additional requests (which might otherwise be blocked or disabled by
   policy) within an apparently harmless request.  Like response
   splitting, request smuggling can lead to a variety of attacks on HTTP
   usage.

   This specification has introduced new requirements on request
   parsing, particularly with regard to message framing in
   &lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;, to reduce the effectiveness of request smuggling.</source>
          <target state="translated">요청 밀수 ([ &lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ])는 명백히 무해한 요청 내에서 추가 요청 (정책에 의해 차단되거나 비활성화 될 수 있음)을 숨기기 위해 다양한 수신자 간의 프로토콜 구문 분석의 차이점을 이용하는 기술입니다. 응답 분할과 마찬가지로 요청 밀수는 HTTP 사용에 대한 다양한 공격으로 이어질 수 있습니다. 이 스펙은 요청 스 머글 링의 효과를 줄이기 위해 요청 구문 분석, 특히 &lt;a href=&quot;#section-3.3.3&quot;&gt;3.3.3 절의&lt;/a&gt; 메시지 프레이밍과 관련하여 새로운 요구 사항을 도입 했다.</target>
        </trans-unit>
        <trans-unit id="4f2b78b6c4f7e212360888da9e743888ae19dbfe" translate="yes" xml:space="preserve">
          <source>Requesting a specific range from a server</source>
          <target state="translated">서버에서 특정 범위 요청</target>
        </trans-unit>
        <trans-unit id="3e1c4325f552db0dd41e8ebaad689edea63a1814" translate="yes" xml:space="preserve">
          <source>Requesting data from a server in different formats</source>
          <target state="translated">다른 형식의 서버에서 데이터 요청</target>
        </trans-unit>
        <trans-unit id="f7194e6a0d0b838382b202853e7c198d693fbabc" translate="yes" xml:space="preserve">
          <source>Requests</source>
          <target state="translated">Requests</target>
        </trans-unit>
        <trans-unit id="42f2929bd33823bdf38ee7942319e10575f276bb" translate="yes" xml:space="preserve">
          <source>Requests consists of the following elements:</source>
          <target state="translated">요청은 다음 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e82d9e92edcff98536ce51f4852910ccc962b156" translate="yes" xml:space="preserve">
          <source>Requests with credentials</source>
          <target state="translated">자격 증명이있는 요청</target>
        </trans-unit>
        <trans-unit id="896b8e09c2c51403430f397ed2a914d36c173299" translate="yes" xml:space="preserve">
          <source>Requirements for cookies across the EU are defined in &lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;Directive 2009/136/EC&lt;/a&gt; of the European Parliament and came into effect on 25 May 2011. A directive is not a law by itself, but a requirement for EU member states to put laws in place that meet the requirements of the directive. The actual laws can differ from country to country.</source>
          <target state="translated">EU 전역의 쿠키에 대한 요구 사항 은 유럽 의회의 &lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;지침 2009 / 136 / EC&lt;/a&gt; 에 정의되어 있으며 2011 년 5 월 25 일에 발효되었습니다. 지침은 자체적으로 법이 아니라 EU 회원국이 다음과 같은 법률을 시행하도록 요구합니다. 지침의 요구 사항을 충족시킵니다. 실제 법률은 국가마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58efddfc035f1f01ebc5a45ea6ef85eae9088fde" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for both, scripts and style sheets.</source>
          <target state="translated">스크립트와 스타일 시트 모두에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="33eafda8cd41b807493e212a681cb068a92c17e4" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts.</source>
          <target state="translated">스크립트에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a71171ac0001f4cd89b14fa7a98d39f88be17a2d" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for style sheets.</source>
          <target state="translated">스타일 시트에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1c018354f46e0590ba0dbb9b1c4723dd35f22f66" translate="yes" xml:space="preserve">
          <source>Requires a sample of the violating code to be included in the violation report.</source>
          <target state="translated">위반 코드 샘플을 위반 보고서에 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a775f4a3f060d56b00223f3382dbb2cdc761a0e" translate="yes" xml:space="preserve">
          <source>Requires the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">페이지에서 스크립트 또는 스타일에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="54f4777a2c07551392e54e261d880e24efe04a2b" translate="yes" xml:space="preserve">
          <source>Resolves the given DNS hostname into an IP address, and returns it in the dot-separated format as a string.</source>
          <target state="translated">지정된 DNS 호스트 이름을 IP 주소로 확인하고 점으로 구분 된 형식으로 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54d7b16d6f25ff228207d06007bc79d8c49dabb8" translate="yes" xml:space="preserve">
          <source>Resource Timing API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64022b8c69b24949fe20baf510c31745fe844e9" translate="yes" xml:space="preserve">
          <source>Resource Timing Level 3&lt;br/&gt;&lt;small&gt;The definition of 'Timing-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">리소스 타이밍 레벨 3 &lt;small&gt;해당 사양에서 '타이밍 허용&lt;/small&gt; 소스 &lt;br/&gt;&lt;small&gt;'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="798dcb46eb38b768887b1e2f745c95d93e85e984" translate="yes" xml:space="preserve">
          <source>Resource URLs</source>
          <target state="translated">리소스 URL</target>
        </trans-unit>
        <trans-unit id="7de6ba1f289521322fe08eee24de6e4e8832b3bf" translate="yes" xml:space="preserve">
          <source>Resource URLs are composed of two parts: a prefix (&lt;code&gt;resource:&lt;/code&gt;), and a URL pointing to the resource you want to load:</source>
          <target state="translated">리소스 URL은 접두사 ( &lt;code&gt;resource:&lt;/code&gt; :) 와로드하려는 리소스를 가리키는 URL 의 두 부분으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad91d18e5dc789f46a10914125180d778fe1dd92" translate="yes" xml:space="preserve">
          <source>Resource URLs, URLs prefixed with the &lt;code&gt;resource:&lt;/code&gt; scheme, are used by Firefox and Firefox browser extensions to load resources internally, but some of the information is available to sites the browser connects to as well.</source>
          <target state="translated">접두사 &lt;code&gt;resource:&lt;/code&gt; 구성표가 붙은 URL 인 리소스 URL 은 Firefox 및 Firefox 브라우저 확장 프로그램에서 내부적으로 리소스를로드하는 데 사용되지만 일부 정보는 브라우저가 연결된 사이트에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9dad94a76fa176febfa455dbb8cce0fd95a809" translate="yes" xml:space="preserve">
          <source>Resources and URIs</source>
          <target state="translated">자원 및 URI</target>
        </trans-unit>
        <trans-unit id="aeb4705a43eda0152e9211513d37d2ebc74577ed" translate="yes" xml:space="preserve">
          <source>Resources and specifications</source>
          <target state="translated">리소스 및 사양</target>
        </trans-unit>
        <trans-unit id="6e617e4fc9da3de9693eac5990613543b86c63f9" translate="yes" xml:space="preserve">
          <source>Response</source>
          <target state="translated">Response</target>
        </trans-unit>
        <trans-unit id="b91c0a7d61c2a326eb2fb877b8d8d75077f4c7c5" translate="yes" xml:space="preserve">
          <source>Response (RFC 2616)</source>
          <target state="translated">응답 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="62bca1e6a1a2f5863671a7fa9d7845857288f9e2" translate="yes" xml:space="preserve">
          <source>Response codes</source>
          <target state="translated">응답 코드</target>
        </trans-unit>
        <trans-unit id="f84e739be38db39024655ad83fa5e6bb72e53942" translate="yes" xml:space="preserve">
          <source>Response context</source>
          <target state="translated">응답 컨텍스트</target>
        </trans-unit>
        <trans-unit id="7b398df4add831e6b05ee4c0b368c39fd3f5bc77" translate="yes" xml:space="preserve">
          <source>Response header</source>
          <target state="translated">응답 헤더</target>
        </trans-unit>
        <trans-unit id="9b7e02a5516eb784c59460a7b87383f30bdd1c7d" translate="yes" xml:space="preserve">
          <source>Response header fields can supply control data that supplements the
   status code, directs caching, or instructs the client where to go
   next.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Age               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;Section&amp;nbsp;5.1 of [RFC7234]&lt;/a&gt; |
   | Cache-Control     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt; |
   | Expires           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7234]&lt;/a&gt; |
   | Date              | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;          |
   | Location          | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;            |
   | Retry-After       | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;            |
   | Vary              | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;            |
   | Warning           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">응답 헤더 필드는 상태 코드를 보완하거나 캐싱을 지시하거나 클라이언트에게 다음 단계를 지시하는 제어 데이터를 제공 할 수 있습니다. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | 나이 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;[RFC7234] 5.1 절&lt;/a&gt; | | 캐시 제어 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234] 섹션 5.2&lt;/a&gt; | | 만료 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;[RFC7234]의 섹션 5.3&lt;/a&gt; | | 날짜 | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 절&lt;/a&gt; | | 위치 | &lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; | | 재시도 후 | &lt;a href=&quot;#section-7.1.3&quot;&gt;섹션 7.1.3&lt;/a&gt; | | 다름 | &lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; | | 경고 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]의 섹션 5.5&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="c8aa6a36289563928821fce4669ae4ff1ccded70" translate="yes" xml:space="preserve">
          <source>Response is Stale</source>
          <target state="translated">응답이 오래되었습니다</target>
        </trans-unit>
        <trans-unit id="5633194dd26604f7ddba594d72f55184513f1b60" translate="yes" xml:space="preserve">
          <source>Response splitting (a.k.a, CRLF injection) is a common technique,
   used in various attacks on Web usage, that exploits the line-based
   nature of HTTP message framing and the ordered association of
   requests to responses on persistent connections [&lt;a href=&quot;#ref-Klein&quot;&gt;Klein&lt;/a&gt;].  This
   technique can be particularly damaging when the requests pass through
   a shared cache.

   Response splitting exploits a vulnerability in servers (usually
   within an application server) where an attacker can send encoded data
   within some parameter of the request that is later decoded and echoed
   within any of the response header fields of the response.  If the
   decoded data is crafted to look like the response has ended and a 

   subsequent response has begun, the response has been split and the
   content within the apparent second response is controlled by the
   attacker.  The attacker can then make any other request on the same
   persistent connection and trick the recipients (including
   intermediaries) into believing that the second half of the split is
   an authoritative answer to the second request.

   For example, a parameter within the request-target might be read by
   an application server and reused within a redirect, resulting in the
   same parameter being echoed in the Location header field of the
   response.  If the parameter is decoded by the application and not
   properly encoded when placed in the response field, the attacker can
   send encoded CRLF octets and other content that will make the
   application's single response look like two or more responses.

   A common defense against response splitting is to filter requests for
   data that looks like encoded CR and LF (e.g., &quot;%0D&quot; and &quot;%0A&quot;).
   However, that assumes the application server is only performing URI
   decoding, rather than more obscure data transformations like charset
   transcoding, XML entity translation, base64 decoding, sprintf
   reformatting, etc.  A more effective mitigation is to prevent
   anything other than the server's core protocol libraries from sending
   a CR or LF within the header section, which means restricting the
   output of header fields to APIs that filter for bad octets and not
   allowing application servers to write directly to the protocol
   stream.</source>
          <target state="translated">응답 분할 (일명 CRLF 주입)은 HTTP 메시지 프레이밍의 라인 기반 특성과 지속적인 연결에 대한 응답에 대한 요청의 정렬 된 연관성을 활용하는 웹 사용에 대한 다양한 공격에 사용되는 일반적인 기술입니다 [ &lt;a href=&quot;#ref-Klein&quot;&gt;Klein&lt;/a&gt;]. 이 기술은 요청이 공유 캐시를 통과 할 때 특히 손상 될 수 있습니다. 응답 분할은 공격자가 요청의 일부 매개 변수 내에서 인코딩 된 데이터를 보낼 수있는 서버 (일반적으로 응용 프로그램 서버 내)의 취약점을 악용합니다.이 경우 나중에 응답의 응답 헤더 필드 내에서 디코딩 및 에코됩니다. 디코딩 된 데이터가 응답이 종료 된 것처럼 보이고 후속 응답이 시작된 경우 응답이 분할되고 명백한 두 번째 응답 내의 내용이 공격자에 의해 제어됩니다. 그런 다음 공격자는 동일한 영구 연결에서 다른 요청을하고받는 사람 (중개자 포함)이 분할의 후반이 두 번째 요청에 대한 정식 응답이라고 믿도록 속일 수 있습니다.예를 들어, 요청 대상 내의 매개 변수는 애플리케이션 서버에 의해 읽히고 경로 재 지정 내에서 재사용되어 동일한 매개 변수가 응답의 위치 헤더 필드에 에코됩니다. 매개 변수가 응용 프로그램에서 디코딩되고 응답 필드에 배치 될 때 올바르게 인코딩되지 않은 경우 공격자는 인코딩 된 CRLF 옥텟 및 응용 프로그램의 단일 응답을 두 개 이상의 응답처럼 보이게하는 기타 콘텐츠를 보낼 수 있습니다. 응답 분할에 대한 일반적인 방어 방법은 인코딩 된 CR 및 LF처럼 보이는 데이터에 대한 요청을 필터링하는 것입니다 (예 : &quot;% 0D&quot;및 &quot;% 0A&quot;). 그러나 이는 애플리케이션 서버가 문자 세트 코드 변환, XML 엔티티 변환, base64 디코딩과 같은 모호한 데이터 변환보다는 URI 디코딩 만 수행한다고 가정합니다.sprintf 재 포맷 등보다 효과적인 완화 방법은 서버의 핵심 프로토콜 라이브러리 이외의 항목이 헤더 섹션 내에서 CR 또는 LF를 전송하지 못하게하는 것입니다. 이는 헤더 필드의 출력을 잘못된 옥텟을 필터링하고 애플리케이션을 허용하지 않는 API로 제한하는 것을 의미합니다. 프로토콜 스트림에 직접 쓸 서버.</target>
        </trans-unit>
        <trans-unit id="d4c531a6385991e6bb4b7c4878657728c7803131" translate="yes" xml:space="preserve">
          <source>Response status codes</source>
          <target state="translated">응답 상태 코드</target>
        </trans-unit>
        <trans-unit id="3de7a37046e38dd56ec505ba9650a90475b3ca79" translate="yes" xml:space="preserve">
          <source>Response status codes beginning with the digit &quot;5&quot; indicate cases in
   which the server is aware that it has erred or is incapable of
   performing the request. Except when responding to a HEAD request, the
   server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. User agents SHOULD display any included entity to the
   user. These response codes are applicable to any request method.</source>
          <target state="translated">숫자 &quot;5&quot;로 시작하는 응답 상태 코드는 서버가 서버에 오류가 있거나 요청을 수행 할 수 없음을 인식하는 경우를 나타냅니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다. 사용자 에이전트는 포함 된 엔티티를 사용자에게 표시해야합니다. 이 응답 코드는 모든 요청 방법에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83bdd15fd3efbd39156bcb4a7d8c4cbc95551582" translate="yes" xml:space="preserve">
          <source>Response to an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request (which is the preflight request), including sending necessary values with &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; (if any additional headers are needed in order for the application to work), and, if credentials are necessary for this resource, &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; (응용 프로그램이 작동하기 위해 추가 헤더가 필요한 경우 )를 사용하여 필요한 값을 보내는 것을 포함 하여 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 (사전 비행 요청) 에 대한 응답 자격 증명이 자원에 필요한 경우, &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dadf3ea7de46798a782a6a436390eec73bf559b0" translate="yes" xml:space="preserve">
          <source>Response to the actual request, including handling &lt;code&gt;POST&lt;/code&gt; data, etc.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 데이터 처리 등 실제 요청에 대한 응답</target>
        </trans-unit>
        <trans-unit id="eca3a297d123fc40900d58016705e489702b5ebd" translate="yes" xml:space="preserve">
          <source>Response-only headers</source>
          <target state="translated">응답 전용 헤더</target>
        </trans-unit>
        <trans-unit id="633f6e8b851aad01759e04e23cfe5188859a4d5b" translate="yes" xml:space="preserve">
          <source>Responses</source>
          <target state="translated">Responses</target>
        </trans-unit>
        <trans-unit id="d8af98670003f4df54578c7641a8970d7403de87" translate="yes" xml:space="preserve">
          <source>Responses consist of the following elements:</source>
          <target state="translated">응답은 다음 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1f5e9b4019ed86ef95e3eb735acf435207ec4e" translate="yes" xml:space="preserve">
          <source>Responses other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; if something suitable for use as a cache key is defined.</source>
          <target state="translated">캐시 키로 사용하기에 적합한 것이 정의 된 경우 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 이외의 응답 .</target>
        </trans-unit>
        <trans-unit id="03a2ed7eea8ee322b3125e461709f17a765da78d" translate="yes" xml:space="preserve">
          <source>Restrict a site from using sensitive APIs like camera or microphone.</source>
          <target state="translated">카메라 나 마이크와 같은 민감한 API를 사용하지 않도록 사이트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="a7df26a7033a2ab83d3ca306e3a5d1318fad2e5a" translate="yes" xml:space="preserve">
          <source>Restrict access to certain URIs</source>
          <target state="translated">특정 URI에 대한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="4117c2bf4d89b600064f4f9d06f852ac1a3ae10f" translate="yes" xml:space="preserve">
          <source>Restricting access with Apache and basic authentication</source>
          <target state="translated">Apache 및 기본 인증을 통한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="461bffebbe59da668a737629925f899f93ff2412" translate="yes" xml:space="preserve">
          <source>Restricting access with nginx and basic authentication</source>
          <target state="translated">nginx 및 기본 인증을 통한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="764a16b3f8fb29997b690d201939e38d6d70edd4" translate="yes" xml:space="preserve">
          <source>Restricts the URLs to which a document can navigate by any means (a, form, window.location, window.open, etc.)</source>
          <target state="translated">어떤 방법 으로든 문서를 탐색 할 수있는 URL을 제한합니다 (a, 양식, window.location, window.open 등).</target>
        </trans-unit>
        <trans-unit id="a6b9ea9002b18b6b31923bd6067c94ff74e5664b" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be loaded using script interfaces</source>
          <target state="translated">스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다</target>
        </trans-unit>
        <trans-unit id="a088abbeea65fe12b4006ee4be76da1a0764ac75" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">지정된 컨텍스트에서 양식 제출 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4222ed3b88e187751d0f547eca5261acc886b9c0" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="7afcc35a5e47466a95fb1a0c4cf65338cc5b6518" translate="yes" xml:space="preserve">
          <source>Restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">로드 할 수있는 자원 유형을 제한하여 문서에 임베드 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="dedece9fd5695df933056cbe96d25f6b3069f79b" translate="yes" xml:space="preserve">
          <source>Retry-After</source>
          <target state="translated">Retry-After</target>
        </trans-unit>
        <trans-unit id="0c9f6f19959bb087b887f8153dbc882bf36b5be0" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 2616)</source>
          <target state="translated">재시도 후 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="4bbd975267207d617ce8ac55243c4e2435f8d973" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 7231)</source>
          <target state="translated">재시도 후 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="b3d51d173748120ed51dbedce115ff294ba9c89e" translate="yes" xml:space="preserve">
          <source>Return &quot;permission denied&quot; for JavaScript APIs that require user permission grants.</source>
          <target state="translated">사용자 권한 부여가 필요한 JavaScript API에 대해서는 &quot;permission denied&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="927efd592a21c92cfe7587e9cfb7e85413562cbe" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;false&lt;/code&gt; or error from an existing JavaScript API that provides access to feature.</source>
          <target state="translated">기능에 대한 액세스를 제공하는 기존 JavaScript API에서 &lt;code&gt;false&lt;/code&gt; 또는 오류를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="846e30137de34dc6b54690d1b47a21341be03ee6" translate="yes" xml:space="preserve">
          <source>Return value format</source>
          <target state="translated">반환 값 형식</target>
        </trans-unit>
        <trans-unit id="0ecdf9bf4172ac40a4c998cc081e4e01cca34349" translate="yes" xml:space="preserve">
          <source>Returning Values from Forms: multipart/form-data</source>
          <target state="translated">양식에서 값 반환 : multipart / form-data</target>
        </trans-unit>
        <trans-unit id="a5275c587d1874bd04ab3b907533a732dac13af3" translate="yes" xml:space="preserve">
          <source>Returns a string describing the configuration. The format of this string is defined in &lt;strong&gt;return value format&lt;/strong&gt; below.</source>
          <target state="translated">구성을 설명하는 문자열을 반환합니다. 이 문자열의 형식은 아래 &lt;strong&gt;반환 값 형식으로&lt;/strong&gt; 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="779f1a52816d71bc238af2dd263cf807ba014f89" translate="yes" xml:space="preserve">
          <source>Returns the number (integer) of DNS domain levels (number of dots) in the hostname.</source>
          <target state="translated">호스트 이름에있는 DNS 도메인 수준 (점 수)의 수 (정수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="796056bd8233f1877d339efcb4a7fa1c33b0b3f3" translate="yes" xml:space="preserve">
          <source>Returns the server IP address of the machine Firefox is running on, as a string in the dot-separated integer format.</source>
          <target state="translated">Firefox가 실행중인 시스템의 서버 IP 주소를 점으로 구분 된 정수 형식의 문자열로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bfcce7002a9eb058fd0c082f413c844164d4b026" translate="yes" xml:space="preserve">
          <source>Returns true if and only if the domain of hostname matches.</source>
          <target state="translated">호스트 이름 도메인이 일치하는 경우에만 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6b72b7530ef6814ea7c835506c7a8c08546f1ec7" translate="yes" xml:space="preserve">
          <source>Returns true if the string matches the specified shell expression.</source>
          <target state="translated">문자열이 지정된 쉘 표현식과 일치하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9249ca2743c193852a67d54d8e0ccd8dc000dc23" translate="yes" xml:space="preserve">
          <source>Revalidation Failed</source>
          <target state="translated">재확인 실패</target>
        </trans-unit>
        <trans-unit id="4129a88770ac061fd8f7b04f0aaf90217987ad97" translate="yes" xml:space="preserve">
          <source>Revalidation and reloading</source>
          <target state="translated">재확인 및 재로드</target>
        </trans-unit>
        <trans-unit id="e6cc272c56bbafbde0f3dbd9f6482ab1d74f3f7f" translate="yes" xml:space="preserve">
          <source>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot;&lt;code&gt;Cache-control: must-revalidate&lt;/code&gt;&quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</source>
          <target state="translated">재확인은 사용자가 다시로드 버튼을 누르면 트리거됩니다. 캐시 된 응답에 &quot; &lt;code&gt;Cache-control: must-revalidate&lt;/code&gt; &quot;헤더가 포함 된 경우 일반 브라우징에서도 트리거됩니다 . 또 다른 요인은 &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; 환경 설정 패널 의 캐시 유효성 검증 환경 설정입니다 . 문서를로드 할 때마다 유효성을 검사하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c78cb0809c7ea82ab0ddb940bd222d197180540" translate="yes" xml:space="preserve">
          <source>Reverse proxies</source>
          <target state="translated">리버스 프록시</target>
        </trans-unit>
        <trans-unit id="f23dd650ab0a4fd135ac0102e4263dfefabf8c25" translate="yes" xml:space="preserve">
          <source>Revved resources</source>
          <target state="translated">밝혀진 자원</target>
        </trans-unit>
        <trans-unit id="c53ad24c321bdfc1ea4aa408ce3ddb04feb1fadd" translate="yes" xml:space="preserve">
          <source>Rich Text Format (RTF)</source>
          <target state="translated">서식있는 텍스트 (RTF)</target>
        </trans-unit>
        <trans-unit id="6e119a5751c88c7d53ad4f9a517a2b4fe5bf070c" translate="yes" xml:space="preserve">
          <source>Right after sending the &lt;code&gt;101&lt;/code&gt; status code, an eventual handshake for the new protocol happens, if the new protocol requires it, then the server sends the answer requested for the original request (the one that included the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header), following the new protocol rules.</source>
          <target state="translated">&lt;code&gt;101&lt;/code&gt; 상태 코드를 보낸 직후 , 새 프로토콜에 필요한 경우 새로운 프로토콜에 대한 최종 핸드 셰이크가 발생하고 서버는 새로운 요청에 따라 원래 요청 ( &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 헤더 가 포함 된 요청)에 대해 요청 된 응답을 보냅니다. 프로토콜 규칙.</target>
        </trans-unit>
        <trans-unit id="4cb54ee36d7572d85675120ff80c6f572b6e22f0" translate="yes" xml:space="preserve">
          <source>Roy T. Fielding
   Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425, USA

   Fax: +1 (949) 824-1715
   EMail: fielding@ics.uci.edu


   James Gettys
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: jg@w3.org


   Jeffrey C. Mogul
   Western Research Laboratory
   Compaq Computer Corporation
   250 University Avenue
   Palo Alto, California, 94305, USA

   EMail: mogul@wrl.dec.com


   Henrik Frystyk Nielsen
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org


   Larry Masinter
   Xerox Corporation
   3333 Coyote Hill Road
   Palo Alto, CA 94034, USA

   EMail: masinter@parc.xerox.com 

   Paul J. Leach
   Microsoft Corporation
   1 Microsoft Way
   Redmond, WA 98052, USA

   EMail: paulle@microsoft.com


   Tim Berners-Lee
   Director, World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: timbl@w3.org</source>
          <target state="translated">Roy T. Fielding Information and Computer Science University of California, Irvine Irvine, CA 92697-3425, USA 팩스 : +1 (949) 824-1715 이메일 : fielding@ics.uci.edu James Gettys 월드 와이드 웹 컨소시엄 MIT 컴퓨터 연구소 Science 545 Technology Square Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : jg@w3.org Jeffrey C. Mogul Western Research Laboratory Compaq Computer Corporation 250 University Avenue Palo Alto, California, 94305, USA 이메일 : mogul @ wrl.dec.com Henrik Frystyk Nielsen 컴퓨터 과학을위한 월드 와이드 웹 컨소시엄 MIT 연구소 545 Technology Square Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : frystyk@w3.org Larry Masinter Xerox Corporation 3333 Coyote Hill Palo Alto, CA 94034, USA 이메일 : masinter @ parc.xerox.com Paul J. Leach Microsoft Corporation 1 Microsoft Way Redmond, WA 98052, USA 전자 메일 : paulle@microsoft.com Tim Berners-Lee, 컴퓨터 과학을위한 월드 와이드 웹 컨소시엄 MIT 연구소 545 기술 스퀘어 Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : timbl@w3.org</target>
        </trans-unit>
        <trans-unit id="155381cbc7c74d0a3b58b7dec055fb15f9da1321" translate="yes" xml:space="preserve">
          <source>Ruby on Rails</source>
          <target state="translated">루비 온 레일즈</target>
        </trans-unit>
        <trans-unit id="78e1790e29a5541b6d02348fc3f45f18445709f4" translate="yes" xml:space="preserve">
          <source>Rule</source>
          <target state="translated">Rule</target>
        </trans-unit>
        <trans-unit id="6e5110b99817ab97188b2fb5c0432e88694c5cb6" translate="yes" xml:space="preserve">
          <source>SAMEORIGIN</source>
          <target state="translated">SAMEORIGIN</target>
        </trans-unit>
        <trans-unit id="051b852d3e1434bf269741e55246b092c01b6d34" translate="yes" xml:space="preserve">
          <source>SOCKS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">양말 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1b9bb67b06df044e5b52d49df71e5762865e669" translate="yes" xml:space="preserve">
          <source>SOCKS4 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS4 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d498327ded8eb1659cbddc3b98307c46f04e966" translate="yes" xml:space="preserve">
          <source>SOCKS5 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS5 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c3907fd9fbfd04403be1ea246413102cae5626" translate="yes" xml:space="preserve">
          <source>SVG images (vector images)</source>
          <target state="translated">SVG 이미지 (벡터 이미지)</target>
        </trans-unit>
        <trans-unit id="424dd4565e3b50faee0307759cb623a23456af2c" translate="yes" xml:space="preserve">
          <source>Safari</source>
          <target state="translated">Safari</target>
        </trans-unit>
        <trans-unit id="23c032140d272311e29c5ca2687a75ad09e37d16" translate="yes" xml:space="preserve">
          <source>Safari 5</source>
          <target state="translated">사파리 5</target>
        </trans-unit>
        <trans-unit id="cd29382cb0678144991e40cb67f0f26309c178fe" translate="yes" xml:space="preserve">
          <source>Safari UA string</source>
          <target state="translated">사파리 UA 문자열</target>
        </trans-unit>
        <trans-unit id="914ddefb3bd0af36387638e5098a5bfccd9d2330" translate="yes" xml:space="preserve">
          <source>Safari gives two version number, one technical in the Safari/xyz token, one user-friendly in a Version/xyz token</source>
          <target state="translated">Safari는 Safari / xyz 토큰의 기술 버전과 Version / xyz 토큰의 사용자 친화적 버전 두 가지 버전 번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3baae9bdafb1777b0a8c4b42ca014a3e672bf89a" translate="yes" xml:space="preserve">
          <source>Safari, Chrome</source>
          <target state="translated">사파리, 크롬</target>
        </trans-unit>
        <trans-unit id="56f9a9116285e2e1d5aefe02e9bf2490ed9cc219" translate="yes" xml:space="preserve">
          <source>Safari/xyz</source>
          <target state="translated">Safari/xyz</target>
        </trans-unit>
        <trans-unit id="9525ae1781bb71fc767a9bab4b6f299ac5cc8c5d" translate="yes" xml:space="preserve">
          <source>Safe</source>
          <target state="translated">Safe</target>
        </trans-unit>
        <trans-unit id="63a5b93ecc868de623f240bfbb9e61bbbc4b6c6f" translate="yes" xml:space="preserve">
          <source>Safe Methods (RFC 7231)</source>
          <target state="translated">안전한 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="5a9e598295fe6016bddfb7db200367d70f068e41" translate="yes" xml:space="preserve">
          <source>Same as 199, but indicating a persistent warning</source>
          <target state="translated">199와 동일하지만 지속적인 경고 표시</target>
        </trans-unit>
        <trans-unit id="6fd24bb83d525c0587904be6d9063b5b2f9040cb" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;Cache-Control: no-cache&lt;/code&gt;. Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">&lt;code&gt;Cache-Control: no-cache&lt;/code&gt; 와 동일 합니다 . 캐시 된 사본을 해제하기 전에 캐시가 유효성 검증을 위해 요청을 오리진 서버에 제출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b26302dd3a3fa55489b0e7f786324aa2ecf9cc5c" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;must-revalidate&lt;/code&gt;, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">&lt;code&gt;must-revalidate&lt;/code&gt; 와 동일 하지만 공유 캐시 (예 : 프록시)에만 적용되며 개인 캐시에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="987997d0d6bfde96290ace26118012807c52f8f3" translate="yes" xml:space="preserve">
          <source>Same as above, but if both proxies go down, automatically start making direct connections. (In the first example above, Netscape will ask user confirmation about making direct connections; in this case, there is no user intervention.)</source>
          <target state="translated">위와 동일하지만 두 프록시가 모두 다운되면 자동으로 직접 연결을 시작합니다. (위의 첫 번째 예에서 Netscape는 사용자에게 직접 연결에 대한 확인을 요청합니다.이 경우 사용자 개입이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="ccf511a0061f086d955d97477343668d80c1a041" translate="yes" xml:space="preserve">
          <source>Same-Site Cookies</source>
          <target state="translated">동일 사이트 쿠키</target>
        </trans-unit>
        <trans-unit id="bee25962095abc626fad400750f39f70602bb29d" translate="yes" xml:space="preserve">
          <source>Same-origin policy</source>
          <target state="translated">동일 출처 정책</target>
        </trans-unit>
        <trans-unit id="7dccf8be165cd7e805358a12ead73def5ccd7ead" translate="yes" xml:space="preserve">
          <source>SameSite=Lax Optional</source>
          <target state="translated">SameSite = Lax 옵션</target>
        </trans-unit>
        <trans-unit id="0cbd84ce60ee0f574919dfa4e0c7b76c8a94f8da" translate="yes" xml:space="preserve">
          <source>SameSite=Strict</source>
          <target state="translated">SameSite=Strict</target>
        </trans-unit>
        <trans-unit id="873f5bd8ca409a7986de0e5309bd3885c3eab798" translate="yes" xml:space="preserve">
          <source>Sample violation report</source>
          <target state="translated">샘플 위반 보고서</target>
        </trans-unit>
        <trans-unit id="da8abd7408a5aa336cbde8d4920f8da276e7b302" translate="yes" xml:space="preserve">
          <source>Samsung Internet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a68f8a275363cb5dc0e990d5ee7f023559d8d8e" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; for sending money to another user of a site.</source>
          <target state="translated">사이트의 다른 사용자에게 돈을 보내기위한 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; 이 있다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="d56d9c1ccf0bc0f33130fff7850c2e5871fca835" translate="yes" xml:space="preserve">
          <source>Say you're creating a new blog post through a site's API:</source>
          <target state="translated">사이트의 API를 통해 새 블로그 게시물을 작성한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="16e6004376e3926149328610370037caae151443" translate="yes" xml:space="preserve">
          <source>Scalable Vector Graphics (SVG)</source>
          <target state="translated">SVG (Scalable Vector Graphics)</target>
        </trans-unit>
        <trans-unit id="990897a59f17d4deac662966307b456e376c6c6d" translate="yes" xml:space="preserve">
          <source>Scheme</source>
          <target state="translated">Scheme</target>
        </trans-unit>
        <trans-unit id="59731c699d056f30b458a35ac2e1c7b49f928594" translate="yes" xml:space="preserve">
          <source>Scheme or protocol</source>
          <target state="translated">체계 또는 프로토콜</target>
        </trans-unit>
        <trans-unit id="94231fed0cda7afbf08bbfc9ad6ef2692cc59645" translate="yes" xml:space="preserve">
          <source>Scope of cookies</source>
          <target state="translated">쿠키의 범위</target>
        </trans-unit>
        <trans-unit id="6c3ca47c0105fab811cf07258c4b16efcfe40f19" translate="yes" xml:space="preserve">
          <source>Scripts inherit the policy of their browsing context, regardless of their origin. That means that top-level scripts inherit the policy from the main document.</source>
          <target state="translated">스크립트는 출처에 관계없이 탐색 컨텍스트의 정책을 상속합니다. 즉, 최상위 스크립트는 기본 문서에서 정책을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="dfc1b60d94fdbf10534406b7762e8b6f2bae9145" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Linux</source>
          <target state="translated">Linux의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="1a3b80710cd0d8991477261291ca25204ce328b9" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Mac</source>
          <target state="translated">Mac의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="9c623420fdda2ac570aef52b55489d15c0471e7a" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Windows</source>
          <target state="translated">Windows의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="011fd1651703d76cf60df261ca3f1fef579b6047" translate="yes" xml:space="preserve">
          <source>Seamonkey</source>
          <target state="translated">Seamonkey</target>
        </trans-unit>
        <trans-unit id="56f35b4502f3ec45082c5dc335c7795a1a7c26e3" translate="yes" xml:space="preserve">
          <source>Seamonkey/xyz</source>
          <target state="translated">Seamonkey/xyz</target>
        </trans-unit>
        <trans-unit id="7eca79871c6f6fc4c47ae676de3882a8679ff650" translate="yes" xml:space="preserve">
          <source>Sec-WebSocket-Accept</source>
          <target state="translated">Sec-WebSocket-Accept</target>
        </trans-unit>
        <trans-unit id="bb412cf0745496a29d28a7ea9c242da8e4682209" translate="yes" xml:space="preserve">
          <source>Seconds from 0 to 59.</source>
          <target state="translated">0에서 59까지의 초</target>
        </trans-unit>
        <trans-unit id="306c19b887ddc8fe31f3651e18b08dc05bd8f651" translate="yes" xml:space="preserve">
          <source>Sections &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;, &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;, &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;, &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;, and &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; define various status
   codes used in Multi-Status responses.  This specification does not
   define the meaning of other status codes that could appear in these
   responses.</source>
          <target state="translated">섹션 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; , &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; , &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; , &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt; 및 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; 는 다중 상태 응답에 사용되는 다양한 상태 코드를 정의합니다. 이 사양에서는 이러한 응답에 나타날 수있는 다른 상태 코드의 의미를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337cbd0bcbed8973159ebf2f991fe72b8939d1af" translate="yes" xml:space="preserve">
          <source>Secure Optional</source>
          <target state="translated">안전한 선택</target>
        </trans-unit>
        <trans-unit id="b506ddb82a08407cd1fd3be6e6ac4aedfd2cc08e" translate="yes" xml:space="preserve">
          <source>Secure shell</source>
          <target state="translated">보안 쉘</target>
        </trans-unit>
        <trans-unit id="51fa0a986148790e5e39c3246996e0d27d164ab3" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable Vibration and Geolocation APIs in their application. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 애플리케이션에서 진동 및 지리적 위치 API를 비활성화하려고합니다. 다음 HTTP 응답 헤더를 제공하여 기능 정책을 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="be1ba146ec015129cdc87a6b6cda0c810fea5fc6" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Fullscreen API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 자체 출처와 출처가 &lt;code&gt;https://example.com&lt;/code&gt; 인 컨텍스트를 제외한 모든 브라우징 컨텍스트에서 전체 화면 API를 비활성화하려고합니다 . 다음 HTTP 응답 헤더를 제공하여 기능 정책을 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a159b732490e876325bf141a42c816091555db2e" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Geolocation API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 자체 출처 및 출처가 &lt;code&gt;https://example.com&lt;/code&gt; 인 컨텍스트를 제외한 모든 브라우징 컨텍스트 내에서 Geolocation API를 비활성화하려고합니다 . 다음 HTTP 응답 헤더를 제공하여 기능 정책을 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="1dfc995fa62a8e188eccdd322ddb4edbdbfea306" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 2616)</source>
          <target state="translated">보안 고려 사항 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="3b8fdb84152d7745f62dd2987944fe2bde984275" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7230)</source>
          <target state="translated">보안 고려 사항 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="45b64918d523e29e2ec840fd10d70a111ad02104" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7231)</source>
          <target state="translated">보안 고려 사항 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="d16e94f2024ae95fb74f63d4a34619f9aa28b96f" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7232)</source>
          <target state="translated">보안 고려 사항 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ed09df6c082dc378c2be105d88f0f7c6b27744b3" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7233)</source>
          <target state="translated">보안 고려 사항 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="634a5436cba76ad187076b3442bdc2183b8a02c5" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7234)</source>
          <target state="translated">보안 고려 사항 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a2965824c87409925878841116315b190450c0c6" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7235)</source>
          <target state="translated">보안 고려 사항 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="0b0a72a60bc2726643d7f43f73beedf4d9eedacc" translate="yes" xml:space="preserve">
          <source>Security issues</source>
          <target state="translated">보안 문제들</target>
        </trans-unit>
        <trans-unit id="45b4812d50d88e88b1448bd0da22f03283ec4833" translate="yes" xml:space="preserve">
          <source>Security of basic authentication</source>
          <target state="translated">기본 인증의 보안</target>
        </trans-unit>
        <trans-unit id="1adc2d2821ca3f28bdeda8b691ca76c312913404" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;Preloading Strict Transport Security&lt;/a&gt; for details. Not part of the specification.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;엄격한 전송 보안 사전로드&lt;/a&gt; 를 참조하십시오. 사양의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef97e870c01e8eaff7ad366cfd23acefa50ec984" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; for more information and examples.</source>
          <target state="translated">자세한 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 과 예는 Content-Security-Policy-Report-Only 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="412e3d00c269ec4cc7cc918810af03116020d0cd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;Fiddler is better with Internet Explorer 9 (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;피들러는 인터넷 익스플로러 9 (IEInternals 'MSDN 블로그)와 더&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8eecda09ccd7acf7d1d416036629474295d0816" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE 및 Accept Header (IEInternals의 MSDN 블로그)를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99877507a4f0dfd21502cd193c8da53cfbacbaa8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE 및 Accept Header (IEInternals의 MSDN 블로그)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71f12e2140ada9e4648ccf95079dbf16c469780e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;Feature Policy Demos&lt;/a&gt; for example usage of many policies.</source>
          <target state="translated">여러 정책의 사용 예는 &lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;기능 정책 데모&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c7daa470035fb38b92a42a6527e06b374c583b4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;bug 1045899&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;버그 1045899를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f53727915d1a1596e99008ed6acb77d2dffba29b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;bug 1091176&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;버그 1091176을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2366d6aff36b6ca45b9473d29a4cbd2a60c64bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;bug 1091177&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;버그 1091177을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c90dfb9eb96a4f291cdf4c61516336af7ea3f56c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/230260&quot;&gt;bug 230260&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/230260&quot;&gt;버그 230260을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34a15d1f8d3edecfef3664e49f7ade5b2cde8cc0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;bug 1158011&lt;/a&gt; for implementation status in Firefox.</source>
          <target state="translated">Firefox의 구현 상태는 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;버그 1158011&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9389f0b53643699ff8b3d81c472dfa931ebda59e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;버그 170789&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4c022826199be858adbb57b661f330364fb2d979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;버그 170789 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="828f60dc446fd652055bcdb734c92c3074411fad" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;버그 489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="03fd2bfeff3aff3c7b402bd3707da7d160456f52" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;버그 489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="444cfb8c4f30e29f1714c2f9e4bf5ebdaa5c09ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]의 섹션 10을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="291a54a8499dd01f0491fc82c8048f328a7ee51d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla Web Security Guidelines&lt;/a&gt; for more examples.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla 웹 보안 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7624f91831549a9940eddbb0f3488a2e93402df5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;Proxy Auto-Configuration (PAC)&lt;/a&gt; for more examples.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;PAC (Proxy Auto-Configuration)&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="0a20b2ffdf62590791187b6d4381fc1759c9535a" translate="yes" xml:space="preserve">
          <source>See Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;bug 995651&lt;/a&gt;.</source>
          <target state="translated">Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;버그 995651을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="719539956ee13b958d9391b4bf7cb27f3c489c59" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;bug 348877&lt;/a&gt;.</source>
          <target state="translated">Chromium &lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;버그 348877을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="1c725ffcd1660304fd5bf29e747aa6869c6d886b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../authentication&quot;&gt;HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site your HTTP basic authentication.</source>
          <target state="translated">HTTP 기본 인증으로 사이트를 비밀번호로 보호하도록 Apache 또는 nginx 서버를 구성하는 방법에 대한 예제 는 &lt;a href=&quot;../authentication&quot;&gt;HTTP 인증&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42f531717be60bcfcad04f46fda0152e3247b29b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;HTTP tunnel article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;Wikipedia&lt;/a&gt; 의 HTTP 터널 기사 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2355891f6471b5e6f9a15ded06e4a709c5b0c70" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; response header for more details on transfer encodings. Note that &lt;code&gt;chunked&lt;/code&gt; is always acceptable for HTTP/1.1 recipients and you that don't have to specify &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; using the &lt;code&gt;TE&lt;/code&gt; header. However, it is useful for setting if the client is accepting trailer fields in a chunked transfer coding using the &quot;trailers&quot; value.</source>
          <target state="translated">또한 참조 &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 전송 인코딩에 대한 자세한 내용은 응답 헤더를. 참고 &lt;code&gt;chunked&lt;/code&gt; 항상 HTTP / 1.1받는 사람에 대한 허용 및 지정하지 않아도 당신은 &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; 은 Using &lt;code&gt;TE&lt;/code&gt; 의 헤더를. 그러나 클라이언트가 &quot;트레일러&quot;값을 사용하여 청크 분할 전송 코딩에서 트레일러 필드를 허용하는지 여부를 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d355a7461d6831a917b2782c88db837671b7bc91" translate="yes" xml:space="preserve">
          <source>See also&lt;a href=&quot;../authentication&quot;&gt; HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site with HTTP basic authentication.</source>
          <target state="translated">HTTP 기본 인증으로 사이트를 비밀번호로 보호하도록 Apache 또는 nginx 서버를 구성하는 방법에 대한 예제 는 &lt;a href=&quot;../authentication&quot;&gt;HTTP 인증&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e0b79753ca98622d76b2e5d4b5394a6888d631c" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; 헤더를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a2d69655ef270db2516384f7be4ebe39aca6629" translate="yes" xml:space="preserve">
          <source>Semi-colon separated list of service definitions in the format of &lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt; 형식으로 세미콜론으로 구분 된 서비스 정의 목록 .</target>
        </trans-unit>
        <trans-unit id="62f118d4abc9935767d93c466a37b1b6575960d3" translate="yes" xml:space="preserve">
          <source>Send a full URL (stripped from parameters) when performing a a same-origin or cross-origin request. This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">동일한 출처 또는 교차 출처 요청을 수행 할 때 전체 매개 변수 (매개 변수에서 가져온)를 보냅니다. 이 정책은 TLS로 보호되는 리소스에서 안전하지 않은 오리진으로 오리진 및 경로를 유출합니다. 이 설정의 영향을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="114ceefa2c0a72367781ffc8a33b8cc5edfb2e16" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin or cross-origin request.</source>
          <target state="translated">동일한 출처 또는 교차 출처 요청을 수행 할 때 전체 URL을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="da546431c50ca7518407c8dd75000ab5f95b3605" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, but only send the origin of the document for other cases.</source>
          <target state="translated">동일한 출처 요청을 수행 할 때는 전체 URL을 보내 되 다른 경우에는 문서의 출처 만 보내십시오.</target>
        </trans-unit>
        <trans-unit id="aae12fc53d3fc50d9faa00eec22cbfcdb054e1a7" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, only send the origin when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), and send no header to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">동일한 출처 요청을 수행 할 때 전체 URL을 전송하고 프로토콜 보안 수준이 동일하게 유지 될 때만 (HTTPS &amp;rarr; HTTPS) 원본을 전송하고 덜 안전한 대상 (HTTPS &amp;rarr; HTTP)으로 헤더를 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ca19fda9303b34183c6fc68556b76910f44fdefc" translate="yes" xml:space="preserve">
          <source>Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same.</source>
          <target state="translated">HTTP 메시지 보내기 : HTTP 메시지 (HTTP / 2 이전)는 사람이 읽을 수 있습니다. HTTP / 2에서는 이러한 간단한 메시지가 프레임으로 캡슐화되어 직접 읽을 수 없지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6b5e6da1d334dfb11080a80304a4f099d91dc28f" translate="yes" xml:space="preserve">
          <source>Send cookies from the server to the user agent.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0c1a7617111c5a0b7fa3ff5d33aa9600f608b1ce" translate="yes" xml:space="preserve">
          <source>Send the following the HTTP header:</source>
          <target state="translated">다음 HTTP 헤더를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="18b9f60168add4dcbe2cfa97830141467c596249" translate="yes" xml:space="preserve">
          <source>Sending a client request</source>
          <target state="translated">클라이언트 요청 보내기</target>
        </trans-unit>
        <trans-unit id="f042f0da173aa47e7ae908a0354193a6b152284d" translate="yes" xml:space="preserve">
          <source>Sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">암호화되고 인증 된 응답에 대한 클라이언트의 기본 설정을 나타내는 신호를 서버에 전송하고 &lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시문을 성공적으로 처리 할 수 ​​있다는 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c8fbea665ea8f09e42b93cbe3fbddf6b3752bacf" translate="yes" xml:space="preserve">
          <source>Sends reports to the report-uri specified in the header and does still allow clients to connect to the server even if the pinning is violated.</source>
          <target state="translated">헤더에 지정된 report-uri로 보고서를 보내고 고정이 위반 된 경우에도 클라이언트가 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c37a6ca7548802cf34b6b1b6a53f217ac82b89c" translate="yes" xml:space="preserve">
          <source>Sent If a cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.</source>
          <target state="translated">보냄 캐시가 24 시간보다 긴 신선도 수명을 경험적으로 선택한 경우 응답 기간이 24 시간보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="c462e8134588f6d1f23e364585abed05a09525c2" translate="yes" xml:space="preserve">
          <source>Sent with non-CORS requests since Fx59, unless they are &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 가 아닌 한 Fx59 이후 비 CORS 요청과 함께 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbc7c79d44a40669267832b336453bd4fee39146" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc HTTP header</source>
          <target state="translated">자원의 ID 및 위치 분리 : Alt-Svc HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="337c903d5597e6947298720f2bc9b6de433ca480" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc header</source>
          <target state="translated">자원의 ID와 위치 분리 : Alt-Svc 헤더</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="30407aa127bbc27f6c900a61dc59d209b7261df6" translate="yes" xml:space="preserve">
          <source>Server (RFC 2616)</source>
          <target state="translated">서버 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="067d8d46c7af148801a57e53fc8b7dfdc58619b7" translate="yes" xml:space="preserve">
          <source>Server (RFC 7231)</source>
          <target state="translated">서버 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="0c9b2a002adf639991e245e57e64715e0102f09f" translate="yes" xml:space="preserve">
          <source>Server Timing&lt;br/&gt;&lt;small&gt;The definition of 'Server-Timing Header Field' in that specification.&lt;/small&gt;</source>
          <target state="translated">서버 타이밍 &lt;br/&gt;&lt;small&gt;해당 사양에서 '서버 타이밍 헤더 필드'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="144c703ba42db111e61eac225abbe629b8a298f5" translate="yes" xml:space="preserve">
          <source>Server error responses</source>
          <target state="translated">서버 오류 응답</target>
        </trans-unit>
        <trans-unit id="a4418c7f82dfa6a5eb45c872b1b4c3a9ec7ed04c" translate="yes" xml:space="preserve">
          <source>Server rejected the request because the &lt;code&gt;Content-Length&lt;/code&gt; header field is not defined and the server requires it.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; 헤더 필드가 정의되지 않아서 서버가 요구하기 때문에 서버가 요청을 거부 했습니다.</target>
        </trans-unit>
        <trans-unit id="223a3cd967a61f2a3071650ced2def4903361d55" translate="yes" xml:space="preserve">
          <source>Server response</source>
          <target state="translated">서버 응답</target>
        </trans-unit>
        <trans-unit id="ca286c1254a3056614d73687d3f1ef4b4a44a8ec" translate="yes" xml:space="preserve">
          <source>Server-Side Access Control</source>
          <target state="translated">서버 측 액세스 제어</target>
        </trans-unit>
        <trans-unit id="6792a77076aa3b8284916c74946cf72675363ce8" translate="yes" xml:space="preserve">
          <source>Server-Timing</source>
          <target state="translated">Server-Timing</target>
        </trans-unit>
        <trans-unit id="da6cf01a8ddc149fef30875f9a63615768b06254" translate="yes" xml:space="preserve">
          <source>Server-driven content negotiation</source>
          <target state="translated">서버 중심의 콘텐츠 협상</target>
        </trans-unit>
        <trans-unit id="fd7b73c63b10788b6bed0cef0a6ec6764b254c1d" translate="yes" xml:space="preserve">
          <source>Server-driven negotiation suffers from a few downsides: it doesn't scale well. There is one header per feature used in the negotiation. If you want to use screen size, resolution or other dimensions, a new HTTP header must be created. Sending of the headers must be done on every request. This is not too problematic with few headers, but with the eventual multiplications of them, the message size would lead to a decrease in performance. The more precise headers are sent, the more entropy is sent, allowing for more HTTP fingerprinting and corresponding privacy concern.</source>
          <target state="translated">서버 중심 협상에는 몇 가지 단점이 있습니다. 협상에 사용 된 기능 당 하나의 헤더가 있습니다. 화면 크기, 해상도 또는 기타 차원을 사용하려면 새 HTTP 헤더를 작성해야합니다. 헤더를 보낼 때마다 요청을 보내야합니다. 헤더 수가 적 으면 문제가되지 않지만 결과적으로 곱하면 메시지 크기가 성능 저하로 이어집니다. 더 정확한 헤더가 전송 될수록 더 많은 엔트로피가 전송되므로 더 많은 HTTP 지문 및 해당 개인 정보 보호 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="280ea515a8b112db582b1e7620e99f0f92dcb530" translate="yes" xml:space="preserve">
          <source>Server-initiated upgrade to TLS</source>
          <target state="translated">TLS로 서버 시작 업그레이드</target>
        </trans-unit>
        <trans-unit id="79d9bb2304b19b76e2157ed20e7da4030dc91a26" translate="yes" xml:space="preserve">
          <source>Server-sent events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67de8093f1524a9bccacf1c09f2b166b248d1aa6" translate="yes" xml:space="preserve">
          <source>Server-side CORS settings</source>
          <target state="translated">서버 측 CORS 설정</target>
        </trans-unit>
        <trans-unit id="8da24e9a194030de05562477bacb0f99c55e7dbd" translate="yes" xml:space="preserve">
          <source>Servers MUST return authorization errors in preference to other
   errors.  This avoids leaking information about protected resources
   (e.g., a client that finds that a hidden resource exists by seeing a
   423 Locked response to an anonymous request to the resource).</source>
          <target state="translated">서버는 다른 오류보다 권한 부여 오류를 우선적으로 반환해야합니다. 이렇게하면 보호 된 리소스 (예 : 리소스에 대한 익명 요청에 대한 423 잠금 응답을 확인하여 숨겨진 리소스가 있음을 발견 한 클라이언트)에 대한 정보가 유출되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4c682d1668898494c7dc1297fbbd4673d8bc287" translate="yes" xml:space="preserve">
          <source>Servers and/or clients are often located on intranets and hide their true IP address to others. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Others, like ftp, can be handled by these proxies.</source>
          <target state="translated">서버 및 / 또는 클라이언트는 종종 인트라넷에 있으며 실제 IP 주소를 다른 사람에게 숨 깁니다. 그런 다음 HTTP 요청은이 네트워크 장벽을 넘어 프록시를 통과합니다. 모든 프록시가 HTTP 프록시는 아닙니다. 예를 들어, SOCKS 프로토콜은 낮은 수준에서 작동합니다. ftp와 같은 다른 것들은이 프록시에 의해 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a801c2bb279262c7911502691c1290ae71c1452" translate="yes" xml:space="preserve">
          <source>Servers are given more leeway in how they respond to a range request,
   in order to mitigate abuse by malicious (or just greedy) clients.
   (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   A weak validator cannot be used in a 206 response.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The Content-Range header field only has meaning when the status code
   explicitly defines its use.  (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;)

   This specification introduces a Range Unit Registry.  (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)

   multipart/byteranges can consist of a single part.  (Appendix A)</source>
          <target state="translated">서버는 악의적 인 (또는 욕심 많은) 클라이언트에 의한 악용을 완화하기 위해 범위 요청에 응답하는 방법에 대해 더 많은 여유가 있습니다. ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; ) 약한 유효성 검사기는 206 응답에 사용할 수 없습니다. ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; ) Content-Range 헤더 필드는 상태 코드가 명시 적으로 사용을 정의 할 때만 의미가 있습니다. ( &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; )이 사양은 Range Unit Registry를 소개합니다. ( &lt;a href=&quot;#section-5.1&quot;&gt;5.1 절&lt;/a&gt; ) 멀티 파트 / 바이트 범위는 단일 파트로 구성 될 수 있습니다. (부록)</target>
        </trans-unit>
        <trans-unit id="40104b8f8c1bae810fb11635b90972e11a6d19a7" translate="yes" xml:space="preserve">
          <source>Servers send the &quot;Retry-After&quot; header field to indicate how long the
   user agent ought to wait before making a follow-up request.  When
   sent with a 503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any 3xx (Redirection) response, Retry-After indicates
   the minimum time that the user agent is asked to wait before issuing
   the redirected request.

   The value of this field can be either an HTTP-date or a number of
   seconds to delay after the response is received.

     Retry-After = HTTP-date / delay-seconds

   A delay-seconds value is a non-negative decimal integer, representing
   time in seconds.

     delay-seconds  = 1*DIGIT 

   Two examples of its use are

     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">서버는 &quot;다시 시도&quot;헤더 필드를 보내 후속 요청을하기 전에 사용자 에이전트가 대기해야하는 시간을 나타냅니다. 503 (Service Unavailable) 응답과 함께 전송되면 Retry-After는 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타냅니다. 3xx (리디렉션) 응답으로 전송되면 Retry-After는 리디렉션 된 요청을 발행하기 전에 사용자 에이전트가 대기하도록 요청 된 최소 시간을 나타냅니다. 이 필드의 값은 응답이 수신 된 후 HTTP- 날짜 또는 지연 시간 (초) 일 수 있습니다. Retry-After = HTTP-date / delay-seconds 지연 시간 값은 음이 아닌 10 진수이며 시간을 초 단위로 나타냅니다. delay-seconds = 1 * DIGIT 사용의 두 가지 예는 Retry-After : 1999 년 12 월 31 일 금요일 23:59:59 GMT Retry-After :후자의 예에서 지연은 2 분입니다.</target>
        </trans-unit>
        <trans-unit id="b11bd40d94eed6743e5942032063a30b385e293b" translate="yes" xml:space="preserve">
          <source>Servers will usually have some time-out value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same server. The use of persistent
   connections places no requirements on the length (or existence) of
   this time-out for either the client or the server. 

   When a client or server wishes to time-out it SHOULD issue a graceful
   close on the transport connection. Clients and servers SHOULD both
   constantly watch for the other side of the transport close, and
   respond to it as appropriate. If a client or server does not detect
   the other side's close promptly it could cause unnecessary resource
   drain on the network.

   A client, server, or proxy MAY close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   This means that clients, servers, and proxies MUST be able to recover
   from asynchronous close events. Client software SHOULD reopen the
   transport connection and retransmit the aborted sequence of requests
   without user interaction so long as the request sequence is
   idempotent (see &lt;a href=&quot;#section-9.1.2&quot;&gt;section 9.1.2&lt;/a&gt;). Non-idempotent methods or sequences
   MUST NOT be automatically retried, although user agents MAY offer a
   human operator the choice of retrying the request(s). Confirmation by
   user-agent software with semantic understanding of the application
   MAY substitute for user confirmation. The automatic retry SHOULD NOT
   be repeated if the second sequence of requests fails.

   Servers SHOULD always respond to at least one request per connection,
   if at all possible. Servers SHOULD NOT close a connection in the
   middle of transmitting a response, unless a network or client failure
   is suspected.

   Clients that use persistent connections SHOULD limit the number of
   simultaneous connections that they maintain to a given server. A
   single-user client SHOULD NOT maintain more than 2 connections with
   any server or proxy. A proxy SHOULD use up to 2*N connections to
   another server or proxy, where N is the number of simultaneously
   active users. These guidelines are intended to improve HTTP response
   times and avoid congestion.</source>
          <target state="translated">서버는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값을 갖습니다. 프록시 서버는 클라이언트가 동일한 서버를 통해 더 많은 연결을 만들 가능성이 높으므로이 값을 더 높게 만들 수 있습니다. 영구 연결을 사용하면 클라이언트 또는 서버에 대한이 시간 제한의 길이 (또는 존재)에 대한 요구 사항이 없습니다. 클라이언트 또는 서버가 시간 초과를 원할 때 전송 연결에서 정상적으로 종료해야합니다. 클라이언트와 서버는 전송의 반대편을 지속적으로 감시하고 적절하게 대응해야합니다. 클라이언트 나 서버가 상대방의 닫기를 즉시 감지하지 못하면 네트워크에서 불필요한 리소스가 낭비 될 수 있습니다. 클라이언트, 서버,또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어, 서버가 &quot;유휴&quot;연결을 종료하기로 결정한 것과 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버의 관점에서 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 즉, 클라이언트, 서버 및 프록시는 비동기 닫기 이벤트에서 복구 할 수 있어야합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).관점에서, 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트 관점에서 요청이 진행 중입니다. 즉, 클라이언트, 서버 및 프록시는 비동기 닫기 이벤트에서 복구 할 수 있어야합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).관점에서, 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트 관점에서 요청이 진행 중입니다. 즉, 클라이언트, 서버 및 프록시는 비동기 닫기 이벤트에서 복구 할 수 있어야합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).&lt;a href=&quot;#section-9.1.2&quot;&gt;섹션 9.1.2&lt;/a&gt;). 사용자 에이전트가 휴먼 오퍼레이터에게 요청을 재 시도 할 수있는 선택권을 제공 할 수도 있지만, 비등 전성 메소드 나 시퀀스는 자동으로 재 시도해서는 안됩니다 (MUST NOT). 애플리케이션을 의미 적으로 이해 한 사용자 에이전트 소프트웨어에 의한 확인은 사용자 확인을 대체 할 수 있습니다. 두 번째 요청 순서가 실패하면 자동 재 시도를 반복해서는 안됩니다. 서버는 가능하면 항상 연결 당 하나 이상의 요청에 응답해야합니다. 네트워크 또는 클라이언트 장애가 의심되지 않는 한 서버는 응답을 전송하는 도중에 연결을 닫지 말아야합니다. 영구 연결을 사용하는 클라이언트는 주어진 서버에 대해 유지 관리하는 동시 연결 수를 제한해야합니다. 단일 사용자 클라이언트는 서버 또는 프록시와 2 개 이상의 연결을 유지해서는 안됩니다.프록시는 다른 서버 나 프록시에 최대 2 * N 연결을 사용해야합니다. 여기서 N은 동시에 활동중인 사용자 수입니다. 이 지침은 HTTP 응답 시간을 개선하고 혼잡을 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a64cc38406e1e6e386cf9a33c8c4a86744f295f" translate="yes" xml:space="preserve">
          <source>Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection.  Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same proxy server.  The use of
   persistent connections places no requirements on the length (or
   existence) of this timeout for either the client or the server.

   A client or server that wishes to time out SHOULD issue a graceful
   close on the connection.  Implementations SHOULD constantly monitor
   open connections for a received closure signal and respond to it as
   appropriate, since prompt closure of both sides of a connection
   enables allocated system resources to be reclaimed. 

   A client, server, or proxy MAY close the transport connection at any
   time.  For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection.  From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   A server SHOULD sustain persistent connections, when possible, and
   allow the underlying transport's flow-control mechanisms to resolve
   temporary overloads, rather than terminate connections with the
   expectation that clients will retry.  The latter technique can
   exacerbate network congestion.

   A client sending a message body SHOULD monitor the network connection
   for an error response while it is transmitting the request.  If the
   client sees a response that indicates the server does not wish to
   receive the message body and is closing the connection, the client
   SHOULD immediately cease transmitting the body and close its side of
   the connection.</source>
          <target state="translated">서버는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값을 갖습니다. 클라이언트가 동일한 프록시 서버를 통해 더 많은 연결을 할 수 있기 때문에 프록시 서버는이 값을 더 높게 만들 수 있습니다. 영구 연결을 사용하면 클라이언트 또는 서버에 대한이 시간 초과 길이 (또는 존재)에 대한 요구 사항이 없습니다. 시간을 초과하려는 클라이언트 또는 서버는 연결을 정상적으로 종료해야합니다. 구현은 수신 된 폐쇄 신호에 대한 개방형 연결을 지속적으로 모니터링하고 적절하게 응답해야한다. 연결의 양쪽을 신속하게 폐쇄하면 할당 된 시스템 자원을 회수 할 수 있기 때문이다. 클라이언트, 서버 또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어서버가 &quot;유휴&quot;연결을 종료하기로 결정한 것과 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버의 관점에서 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 서버는 가능하면 지속적 연결을 유지해야하며 기본 전송의 흐름 제어 메커니즘이 클라이언트가 재 시도 할 것으로 예상되는 연결을 종료하지 않고 임시 과부하를 해결하도록해야합니다. 후자의 기술은 네트워크 혼잡을 악화시킬 수 있습니다. 메시지 본문을 보내는 클라이언트는 요청을 전송하는 동안 오류 응답이 있는지 네트워크 연결을 모니터링해야합니다.클라이언트가 서버가 메시지 본문을 수신하지 않음을 나타내는 응답을보고 연결을 닫는 경우 클라이언트는 즉시 본문 전송을 중단하고 연결 측면을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="f5124c99e159587ebe507b56369f65760748f150" translate="yes" xml:space="preserve">
          <source>Serves as a fallback for the other &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;fetch directives&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;페치 지시문에&lt;/a&gt; 대한 폴백으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c993592eb184660ed131503e2e6e4c8ebc6710fd" translate="yes" xml:space="preserve">
          <source>Service worker registrations (for each service worker registration, execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt;&lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">서비스 근로자 등록 (각 서비스 근로자 등록에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt; &lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt; 를&lt;/a&gt; 실행 )</target>
        </trans-unit>
        <trans-unit id="53dfe70871da64dc7cc73082fd91fc0d67395965" translate="yes" xml:space="preserve">
          <source>Serving different Web pages or services to different browsers is usually a bad idea. The Web is meant to be accessible to everyone, regardless of which browser or device they're using. There are ways to develop your website to progressively enhance itself based on the availability of features rather than by targeting specific browsers.</source>
          <target state="translated">다른 웹 페이지 나 서비스를 다른 브라우저에 제공하는 것은 일반적으로 나쁜 생각입니다. 웹은 사용중인 브라우저 나 장치에 관계없이 모든 사람이 액세스 할 수 있도록 만들어졌습니다. 특정 브라우저를 대상으로하지 않고 기능의 가용성에 따라 점진적으로 향상되도록 웹 사이트를 개발하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a0eba4a8c4bcb092cc3e5ed3ca481b331e2273" translate="yes" xml:space="preserve">
          <source>Servo: &lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;Issue 13283&lt;/a&gt;</source>
          <target state="translated">서보 : &lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;문제 13283&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7f1997c6cd1aa051279675742272a956e7db628" translate="yes" xml:space="preserve">
          <source>Session</source>
          <target state="translated">Session</target>
        </trans-unit>
        <trans-unit id="8fa2a80f7a4a01bb4a4049a65f2e8ab40639ca19" translate="yes" xml:space="preserve">
          <source>Session cookie</source>
          <target state="translated">세션 쿠키</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">세션 쿠키</target>
        </trans-unit>
        <trans-unit id="c22669a0c2011d70ebc816a2c115645d58f8ea3a" translate="yes" xml:space="preserve">
          <source>Session cookies will get removed when the client is shut down. They don't specify the &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directives. Note that web browser have often enabled session restoring.</source>
          <target state="translated">클라이언트가 종료되면 세션 쿠키가 제거됩니다. &lt;code&gt;Expires&lt;/code&gt; 또는 &lt;code&gt;Max-Age&lt;/code&gt; 지시문을 지정하지 않습니다 . 웹 브라우저는 종종 세션 복원을 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="0383ce6cf519828e20e353eff1d36e08f759636b" translate="yes" xml:space="preserve">
          <source>Session hijacking and XSS</source>
          <target state="translated">세션 하이재킹 및 XSS</target>
        </trans-unit>
        <trans-unit id="4d1a0ebf42ea7726af9fc0d443c4219ad98f0b66" translate="yes" xml:space="preserve">
          <source>Session management</source>
          <target state="translated">세션 관리</target>
        </trans-unit>
        <trans-unit id="da18d02d9a384ec87b2924aa70bb99b190dfa12c" translate="yes" xml:space="preserve">
          <source>Set-Cookie</source>
          <target state="translated">Set-Cookie</target>
        </trans-unit>
        <trans-unit id="e9cace35e90b037b0140e79e5bff9090459aef6c" translate="yes" xml:space="preserve">
          <source>Set-Cookie2</source>
          <target state="translated">Set-Cookie2</target>
        </trans-unit>
        <trans-unit id="ca4cfc1c5db67629db097698126f262a8ff0efa4" translate="yes" xml:space="preserve">
          <source>Setting a proxy for a specific protocol</source>
          <target state="translated">특정 프로토콜에 대한 프록시 설정</target>
        </trans-unit>
        <trans-unit id="0a19969b97beb1798bb95f65f7732ae561c43ab8" translate="yes" xml:space="preserve">
          <source>Setting this directive to &lt;code&gt;'none'&lt;/code&gt; is similar to &lt;a href=&quot;../x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: DENY&lt;/code&gt; (which is also supported in older browers).</source>
          <target state="translated">이 지시어를 &lt;code&gt;'none'&lt;/code&gt; 으로 설정하는 것은 &lt;a href=&quot;../x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: DENY&lt;/code&gt; 와 비슷합니다 (이전 브라우저에서도 지원됨).</target>
        </trans-unit>
        <trans-unit id="e21c065049ff05b60c6a9ac39caff520e04569d8" translate="yes" xml:space="preserve">
          <source>Setting up your webserver to include the HPKP header</source>
          <target state="translated">HPKP 헤더를 포함하도록 웹 서버 설정</target>
        </trans-unit>
        <trans-unit id="32a560a86e92c09f3625944269ea6a7159c1e2c8" translate="yes" xml:space="preserve">
          <source>Several HTTP headers, called conditional headers, lead to conditional requests. These are:</source>
          <target state="translated">조건부 헤더라고하는 여러 HTTP 헤더는 조건부 요청으로 이어집니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="329eb594c20733b1f610e7cab58a3336e04332ce" translate="yes" xml:space="preserve">
          <source>Several features can be controlled at the same time by sending the HTTP header with a semicolon-separated list of policy directives, or by sending a separate header for each policy.</source>
          <target state="translated">세미콜론으로 구분 된 정책 지시문 목록과 함께 HTTP 헤더를 보내거나 각 정책에 대해 별도의 헤더를 보내 여러 기능을 동시에 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81acc188ecb44fe2b0ca66c680ba970231e66c83" translate="yes" xml:space="preserve">
          <source>Shared proxy caches</source>
          <target state="translated">공유 프록시 캐시</target>
        </trans-unit>
        <trans-unit id="78f6156a2ead82a3ca398616fa6f9e17dfb530a7" translate="yes" xml:space="preserve">
          <source>Short-lived connections</source>
          <target state="translated">수명이 짧은 연결</target>
        </trans-unit>
        <trans-unit id="f47fe4cbc4ecdf7b89058813c34af535ace87ae1" translate="yes" xml:space="preserve">
          <source>Short-lived connections have two major hitches: the time taken to establish a new connection is significant, and performance of the underlying TCP connection gets better only when this connection has been in use for some time (warm connection). To ease these problems, the concept of a &lt;em&gt;persistent connection&lt;/em&gt; has been designed, even prior to HTTP/1.1. Alternatively this may be called a &lt;em&gt;keep-alive connection&lt;/em&gt;.</source>
          <target state="translated">수명이 짧은 연결에는 두 가지 주요 문제가 있습니다. 새 연결을 설정하는 데 걸리는 시간이 상당하며이 연결이 일정 시간 동안 사용 된 경우에만 기본 TCP 연결 성능이 향상됩니다 (웜 연결). 이러한 문제를 해결 하기 위해 HTTP / 1.1 이전에도 &lt;em&gt;지속적인 연결&lt;/em&gt; 개념 이 설계되었습니다. 또는 이것을 &lt;em&gt;연결 유지 연결&lt;/em&gt; 이라고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c537d8356fd7f996e8605aa03e51f47390d4d7a8" translate="yes" xml:space="preserve">
          <source>Shows and explains the flow of a usual HTTP session.</source>
          <target state="translated">일반적인 HTTP 세션의 흐름을 보여주고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="41efbf8a181438e8fc19ee9def30f3ef38ba127a" translate="yes" xml:space="preserve">
          <source>Sign-out</source>
          <target state="translated">Sign-out</target>
        </trans-unit>
        <trans-unit id="49ea2b0538dc5d77e0f7d9a719fad7e94390af26" translate="yes" xml:space="preserve">
          <source>Signals to the user agent that compliance with the Certificate Transparency policy should be enforced (rather than only reporting compliance) and that the user agent should refuse future connections that violate its Certificate Transparency policy.</source>
          <target state="translated">인증서 투명성 정책을 준수해야한다는 것이 아니라 인증서 투명성 정책을 준수해야하며 사용자 에이전트는 인증서 투명성 정책을 위반하는 향후 연결을 거부해야한다는 사용자 에이전트에 알립니다.</target>
        </trans-unit>
        <trans-unit id="d8e8cee5872465deb3080e8822404564c2c7c96c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, but can have only one single etag, or one date. If it fails, the range request fails, and instead of a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; response, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; is sent with the complete resource.</source>
          <target state="translated">유사에 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; ,하지만 하나의 ETAG, 또는 하나의 일을 할 수 있습니다. 실패하면 범위 요청이 실패하고 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 응답 대신 완전한 자원과 함께 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e46dbd8cd6429badd706773975b6b00d0b709805" translate="yes" xml:space="preserve">
          <source>Similar to the HTTP header, several features can be controlled at the same time by specifying a semicolon-separated list of policy directives.</source>
          <target state="translated">HTTP 헤더와 유사하게 세미콜론으로 구분 된 정책 지시문 목록을 지정하여 여러 기능을 동시에 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1d80cfcc4676e37337cc4f5d6a84bedb5462d2" translate="yes" xml:space="preserve">
          <source>Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="translated">마찬가지로 특정 또는 알려진 하위 유형이없는 이진 문서의 경우 &lt;code&gt;application/octet-stream&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0a5bca6adaca9564e0b94bdaad3a91197512ef9" translate="yes" xml:space="preserve">
          <source>Similarly, the link element can be used to resolve hostnames without providing a complete URL, but only, by preceding the hostname with two slashes:</source>
          <target state="translated">마찬가지로 링크 요소를 사용하여 완전한 URL을 제공하지 않고 호스트 이름 앞에 두 개의 슬래시를 붙여야 호스트 이름을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3bdb2d208400327aac2b623589a8a18ecdfc8d" translate="yes" xml:space="preserve">
          <source>Simple cross-site requests</source>
          <target state="translated">간단한 크로스 사이트 요청</target>
        </trans-unit>
        <trans-unit id="2c183543e074fb1a91056f30dcfaf12aabc8df68" translate="yes" xml:space="preserve">
          <source>Simple requests</source>
          <target state="translated">간단한 요청</target>
        </trans-unit>
        <trans-unit id="8093dd58a33027a1dce2c902fa777fafd90c9a4e" translate="yes" xml:space="preserve">
          <source>Simple text/plain data</source>
          <target state="translated">간단한 텍스트 / 일반 데이터</target>
        </trans-unit>
        <trans-unit id="28ea2b82bad9055a11bf6b84d9f7527a0f5e40f3" translate="yes" xml:space="preserve">
          <source>Simply put, the origin making the request does not match any of the origins permitted by the &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">간단히 말해, 요청하는 원점이 &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더에 의해 허용 된 원점과 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="113900181c81db75435ae6243c0c7016d22cda73" translate="yes" xml:space="preserve">
          <source>Since 2005, the set of APIs available to Web pages greatly increased and several of these APIs created extensions, mostly new specific HTTP headers, to the HTTP protocol for specific purposes:</source>
          <target state="translated">2005 년 이후 웹 페이지에서 사용 가능한 API 세트가 크게 증가했으며 이러한 API 중 일부는 특정 목적을 위해 HTTP 프로토콜에 대한 확장 (주로 새로운 특정 HTTP 헤더)을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="99fb1a5dd25ea500036c8caefba3949cfbcb90c0" translate="yes" xml:space="preserve">
          <source>Since HTTP/1.0, different types of content can be transmitted. This article explains how this is done using the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header and the MIME standard.</source>
          <target state="translated">HTTP / 1.0부터 다른 유형의 컨텐츠를 전송할 수 있습니다. 이 문서에서는 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더와 MIME 표준을 사용하여이 작업을 수행하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1c0077fb81ec47c18951a65d81853f40257980" translate="yes" xml:space="preserve">
          <source>Since all HTTP entities are represented in HTTP messages as sequences
   of bytes, the concept of a byte range is meaningful for any HTTP
   entity. (However, not all clients and servers need to support byte-
   range operations.)

   Byte range specifications in HTTP apply to the sequence of bytes in
   the entity-body (not necessarily the same as the message-body).

   A byte range operation MAY specify a single range of bytes, or a set
   of ranges within a single entity.

       ranges-specifier = byte-ranges-specifier
       byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
       byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]
       first-byte-pos  = 1*DIGIT
       last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range. The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive. Byte offsets start at zero.

   If the last-byte-pos value is present, it MUST be greater than or
   equal to the first-byte-pos in that byte-range-spec, or the byte-
   range-spec is syntactically invalid. The recipient of a byte-range-
   set that includes one or more syntactically invalid byte-range-spec
   values MUST ignore the header field that includes that byte-range-
   set.

   If the last-byte-pos value is absent, or if the value is greater than
   or equal to the current length of the entity-body, last-byte-pos is
   taken to be equal to one less than the current length of the entity-
   body in bytes.

   By its choice of last-byte-pos, a client can limit the number of
   bytes retrieved without knowing the size of the entity. 

       suffix-byte-range-spec = &quot;-&quot; suffix-length
       suffix-length = 1*DIGIT

   A suffix-byte-range-spec is used to specify the suffix of the
   entity-body, of a length given by the suffix-length value. (That is,
   this form specifies the last N bytes of an entity-body.) If the
   entity is shorter than the specified suffix-length, the entire
   entity-body is used.

   If a syntactically valid byte-range-set includes at least one byte-
   range-spec whose first-byte-pos is less than the current length of
   the entity-body, or at least one suffix-byte-range-spec with a non-
   zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set
   is unsatisfiable, the server SHOULD return a response with a status
   of 416 (Requested range not satisfiable). Otherwise, the server
   SHOULD return a response with a status of 206 (Partial Content)
   containing the satisfiable ranges of the entity-body.

   Examples of byte-ranges-specifier values (assuming an entity-body of
   length 10000):

      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-
        499

      - The second 500 bytes (byte offsets 500-999, inclusive):
        bytes=500-999

      - The final 500 bytes (byte offsets 9500-9999, inclusive):
        bytes=-500

      - Or bytes=9500-

      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1

      - Several legal but not canonical specifications of the second 500
        bytes (byte offsets 500-999, inclusive):
         bytes=500-600,601-999
         bytes=500-700,601-999</source>
          <target state="translated">모든 HTTP 엔티티는 HTTP 메시지에 바이트 시퀀스로 표시되므로 바이트 범위의 개념은 모든 HTTP 엔티티에 의미가 있습니다. 그러나 모든 클라이언트와 서버가 바이트 범위 작업을 지원할 필요는 없습니다. HTTP의 바이트 범위 사양은 엔터티 본문의 바이트 시퀀스에 적용됩니다 (메시지 본문과 반드시 ​​같을 필요는 없음). 바이트 범위 연산은 단일 바이트 범위 또는 단일 엔티티 내 범위 세트를 지정할 수 있습니다. 범위 지정자 = 바이트 범위 지정자 바이트 범위 지정자 = 바이트 단위 &quot;=&quot;바이트 범위 설정 바이트 범위 설정 = 1 # (byte-range-spec | suffix-byte-range-spec) 바이트 -range-spec = 첫 바이트 위치 &quot;-&quot;[last-byte-pos] first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT byte-range-spec의 first-byte-pos 값은 첫 번째 바이트의 바이트 오프셋을 범위. last-byte-pos 값은 범위 내에서 마지막 바이트의 바이트 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0에서 시작합니다. 마지막 바이트 위치 값이 존재하는 경우 해당 바이트 범위 스펙의 첫 번째 바이트 위치보다 크거나 같아야합니다. 그렇지 않으면 바이트 범위 스펙이 구문 상 유효하지 않습니다. 하나 이상의 구문 상 유효하지 않은 바이트 범위 스펙 값을 포함하는 바이트 범위 세트의 수신자는 해당 바이트 범위 세트를 포함하는 헤더 필드를 무시해야합니다. 마지막 바이트 위치 값이 없거나 값이 엔티티 본문의 현재 길이보다 크거나 같은 경우,last-byte-pos는 엔티티 본문의 현재 길이보다 1 바이트 작습니다. last-byte-pos를 선택함으로써 클라이언트는 엔티티의 크기를 몰라도 검색된 바이트 수를 제한 할 수 있습니다. suffix-byte-range-spec = &quot;-&quot;접미사 길이 suffix-length = 1 * DIGIT suffix-byte-range-spec은 엔티티 본문의 접미사를 접미사 길이로 지정된 길이로 지정하는 데 사용됩니다. 값. 즉,이 형식은 엔터티 본문의 마지막 N 바이트를 지정합니다. 엔터티가 지정된 접미사 길이보다 짧은 경우 전체 엔터티 본문이 사용됩니다. 구문 적으로 유효한 바이트 범위 세트에 첫 번째 바이트 위치가 엔티티 본문의 현재 길이보다 작은 하나 이상의 바이트 범위 스펙이 포함되거나 그렇지 않은 경우 하나 이상의 접미사 바이트 범위 스펙이 포함 된 경우 -접미사 길이가 0 인 경우바이트 범위 세트는 만족할 만하다. 그렇지 않으면 바이트 범위 세트가 만족스럽지 않습니다. 바이트 범위 세트가 만족스럽지 않으면 서버는 상태 416 (요청한 범위가 만족스럽지 않음) 인 응답을 리턴해야합니다. 그렇지 않으면, 서버는 만족할만한 엔터티-바디 범위를 포함하는 206 (부분 컨텐츠) 상태의 응답을 반환해야합니다. 바이트 범위 지정자 값의 예 (길이 10000의 엔티티-본체를 가정) :-첫 500 바이트 (바이트 오프셋 0-499 포함) : bytes = 0-499-두 번째 500 바이트 (바이트 오프셋 500-999) ) : bytes = 500-999-마지막 500 바이트 (바이트 오프셋 9500-9999 포함) : bytes = -500-또는 bytes = 9500--첫 번째와 마지막 바이트 만 (바이트 0 및 9999) : bytes = 0-0,-1-두 번째 500 바이트의 몇 가지 법적이지만 표준이 아닌 사양 (바이트 오프셋 500-999 포함) : bytes = 500-600,601-999 bytes = 500-700,601-999</target>
        </trans-unit>
        <trans-unit id="6477522ed9958316dd956b0c178201d047372002" translate="yes" xml:space="preserve">
          <source>Since both origin servers and caches will compare two validators to
   decide if they represent the same or different entities, one normally
   would expect that if the entity (the entity-body or any entity-
   headers) changes in any way, then the associated validator would
   change as well. If this is true, then we call this validator a
   &quot;strong validator.&quot;

   However, there might be cases when a server prefers to change the
   validator only on semantically significant changes, and not when
   insignificant aspects of the entity change. A validator that does not
   always change when the resource changes is a &quot;weak validator.&quot;

   Entity tags are normally &quot;strong validators,&quot; but the protocol
   provides a mechanism to tag an entity tag as &quot;weak.&quot; One can think of
   a strong validator as one that changes whenever the bits of an entity
   changes, while a weak value changes whenever the meaning of an entity
   changes. Alternatively, one can think of a strong validator as part
   of an identifier for a specific entity, while a weak validator is
   part of an identifier for a set of semantically equivalent entities.

      Note: One example of a strong validator is an integer that is
      incremented in stable storage every time an entity is changed. 

      An entity's modification time, if represented with one-second
      resolution, could be a weak validator, since it is possible that
      the resource might be modified twice during a single second.

      Support for weak validators is optional. However, weak validators
      allow for more efficient caching of equivalent objects; for
      example, a hit counter on a site is probably good enough if it is
      updated every few days or weeks, and any value during that period
      is likely &quot;good enough&quot; to be equivalent.

   A &quot;use&quot; of a validator is either when a client generates a request
   and includes the validator in a validating header field, or when a
   server compares two validators.

   Strong validators are usable in any context. Weak validators are only
   usable in contexts that do not depend on exact equality of an entity.
   For example, either kind is usable for a conditional GET of a full
   entity. However, only a strong validator is usable for a sub-range
   retrieval, since otherwise the client might end up with an internally
   inconsistent entity.

   Clients MAY issue simple (non-subrange) GET requests with either weak
   validators or strong validators. Clients MUST NOT use weak validators
   in other forms of request.

   The only function that the HTTP/1.1 protocol defines on validators is
   comparison. There are two validator comparison functions, depending
   on whether the comparison context allows the use of weak validators
   or not:

      - The strong comparison function: in order to be considered equal,
        both validators MUST be identical in every way, and both MUST
        NOT be weak.

      - The weak comparison function: in order to be considered equal,
        both validators MUST be identical in every way, but either or
        both of them MAY be tagged as &quot;weak&quot; without affecting the
        result.

   An entity tag is strong unless it is explicitly tagged as weak.
   &lt;a href=&quot;#section-3.11&quot;&gt;Section 3.11&lt;/a&gt; gives the syntax for entity tags.

   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:

      - The validator is being compared by an origin server to the
        actual current validator for the entity and, 

      - That origin server reliably knows that the associated entity did
        not change twice during the second covered by the presented
        validator.

   or

      - The validator is about to be used by a client in an If-
        Modified-Since or If-Unmodified-Since header, because the client
        has a cache entry for the associated entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   or

      - The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time. The arbitrary 60-
   second limit guards against the possibility that the Date and Last-
   Modified values are generated from different clocks, or at somewhat
   different times during the preparation of the response. An
   implementation MAY use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.

   If a client wishes to perform a sub-range retrieval on a value for
   which it has only a Last-Modified time and no opaque validator, it
   MAY do this only if the Last-Modified time is strong in the sense
   described here.

   A cache or origin server receiving a conditional request, other than
   a full-body GET request, MUST use the strong comparison function to
   evaluate the condition.

   These rules allow HTTP/1.1 caches and clients to safely perform sub-
   range retrievals on values that have been obtained from HTTP/1.0 

   servers.</source>
          <target state="translated">오리진 서버와 캐시는 두 개의 유효성 검사기를 비교하여 동일하거나 다른 엔티티를 나타내는 지 여부를 결정하므로 일반적으로 엔티티 (엔티티-본체 또는 엔티티 헤더)가 어떤 방식 으로든 변경 될 경우 연결된 유효성 검사기가 또한 변경하십시오. 이것이 사실이라면, 우리는이 검증자를 &quot;강력한 검증 자&quot;라고 부릅니다. 그러나 서버가 의미 적으로 중요한 변경에 대해서만 유효성 검사기를 변경하는 것을 선호하고 엔티티의 중요하지 않은 측면이 변경되지 않는 경우가 있습니다. 리소스가 변경 될 때 항상 변경되지 않는 유효성 검사기는 &quot;약한 유효성 검사기&quot;입니다. 엔티티 태그는 일반적으로 &quot;강력한 유효성 검사기&quot;이지만 프로토콜은 엔티티 태그에 &quot;약한&quot;태그를 지정하는 메커니즘을 제공합니다.강력한 유효성 검사기는 엔터티의 비트가 변경 될 때마다 변경되는 반면, 약한 값은 엔터티의 의미가 변경 될 때마다 변경되는 것으로 생각할 수 있습니다. 대안 적으로, 강한 검증자는 특정 엔티티에 대한 식별자의 일부로서 생각할 수있는 반면, 취약한 검증자는 의미 적으로 동등한 엔티티 세트에 대한 식별자의 일부이다. 참고 : 강력한 유효성 검사기의 한 예는 엔터티가 변경 될 때마다 안정적인 저장소에서 증가하는 정수입니다. 1 초의 해상도로 표시되는 엔터티의 수정 시간은 약 1 초 동안 리소스가 두 번 수정 될 수 있기 때문에 약한 유효성 검사기가 될 수 있습니다. 약한 유효성 검사기 지원은 선택 사항입니다. 그러나 약한 유효성 검사기는 동등한 개체를보다 효율적으로 캐싱 할 수 있습니다.예를 들어, 사이트의 적중 카운터는 며칠 또는 몇 주마다 업데이트되는 경우 충분할 수 있으며 해당 기간 동안의 값은 &quot;충분히 충분&quot;할 수 있습니다. 유효성 검사기의 &quot;사용&quot;은 클라이언트가 요청을 생성하고 유효성 검사 헤더 필드에 유효성 검사기를 포함하거나 서버가 두 유효성 검사기를 비교할 때입니다. 어떤 상황에서도 강력한 유효성 검사기를 사용할 수 있습니다. 약한 유효성 검사기는 엔터티의 정확한 동등성에 의존하지 않는 컨텍스트에서만 사용할 수 있습니다. 예를 들어, 두 종류 모두 전체 엔티티의 조건부 GET에 사용할 수 있습니다. 그러나 하위 범위 검색에는 강력한 유효성 검사기 만 사용할 수 있습니다. 그렇지 않으면 클라이언트가 내부적으로 일치하지 않는 엔터티로 끝날 수 있기 때문입니다.클라이언트는 약한 유효성 검사기 또는 강력한 유효성 검사기와 함께 간단한 (하위 범위가 아닌) GET 요청을 발행 할 수 있습니다. 고객은 다른 형식의 요청에 약한 유효성 검사기를 사용해서는 안됩니다. HTTP / 1.1 프로토콜이 유효성 검증기에서 정의하는 유일한 기능은 비교입니다. 비교 컨텍스트가 약한 유효성 검사기의 사용을 허용하는지 여부에 따라 두 가지 유효성 검사기 비교 함수가 있습니다.-강력한 비교 기능 : 동일한 것으로 간주 되려면 두 유효성 검사기가 모든면에서 동일해야하며 두 가지 모두 약해야합니다. . 약한 비교 기능 : 동일하게 간주 되려면 두 가지 유효성 검사기가 모든면에서 동일해야하지만 결과에 영향을주지 않으면 서 두 가지 중 하나 또는 모두가 &quot;약한&quot;태그를 지정할 수 있습니다.엔터티 태그는 명시 적으로 약한 태그가없는 한 강력합니다. &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11&lt;/a&gt;엔티티 태그의 구문을 제공합니다. 요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론 할 수 없으면 암시 적으로 약합니다.-원본 서버에서 유효성 검사기의 실제 유효성 검사기와 비교합니다. 실체 서버,-그 오리진 서버는 제시된 검증자가 다루는 두 번째 동안 연관된 실체가 두 번 변하지 않았다는 것을 확실하게 알고있다. 또는-클라이언트에 연결된 엔터티에 대한 캐시 항목이 있기 때문에 유효성 검사기가 If- Modified-Since 또는 If-Unmodified-Since 헤더에서 클라이언트가 사용하려고합니다. 오리진 서버가 원래 응답을 보낸 시간을 제공합니다.-제시된 마지막 수정 시간은 날짜 값보다 60 초 전입니다. 또는-유효성 검사기가 중간 캐시에 의해 엔티티에 대한 캐시 항목에 저장된 유효성 검사기와 비교되고 있으며,-이 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다. 마지막으로 수정 한 시간은 날짜 값보다 적어도 60 초 전입니다. 이 방법은 동일한 초 동안 두 개의 서로 다른 응답이 오리진 서버에 의해 전송되었지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 하나 이상이 Last-Modified와 동일한 Date 값을 가질 것이라는 사실에 의존합니다. 시각.임의의 60 초 제한은 Date 및 Last-Modified 값이 다른 클럭에서 생성되거나 응답 준비 중에 약간 다른 시간에 생성 될 가능성을 방지합니다. 구현에 60 초가 너무 짧은 경우 60 초보다 큰 값을 사용할 수 있습니다. 클라이언트가 Last-Modified 시간 만 있고 불투명 유효성 검사기가없는 값에 대해 하위 범위 검색을 수행하려는 경우 여기에 설명 된 의미에서 Last-Modified 시간이 강한 경우에만이를 수행 할 수 있습니다. 전신 GET 요청 이외의 조건부 요청을 수신하는 캐시 또는 오리진 서버는 강력한 비교 기능을 사용하여 조건을 평가해야합니다. 이 규칙은 HTTP / 1을 허용합니다.HTTP / 1.0 서버에서 얻은 값에 대해 하위 범위 검색을 안전하게 수행하기위한 1 개의 캐시 및 클라이언트.</target>
        </trans-unit>
        <trans-unit id="b5e7d8ecc2e2bfd0337480eba5175d544e816618" translate="yes" xml:space="preserve">
          <source>Since by definition the actual function performed by POST is
   determined by the server and often depends on the particular
   resource, the behavior of POST when applied to collections cannot be
   meaningfully modified because it is largely undefined.  Thus, the
   semantics of POST are unmodified when applied to a collection.</source>
          <target state="translated">정의에 따라 POST에 의해 수행되는 실제 기능은 서버에 의해 결정되며 종종 특정 리소스에 의존하기 때문에 컬렉션에 적용될 때 POST의 동작은 크게 정의되지 않기 때문에 의미있게 수정할 수 없습니다. 따라서 POST의 의미는 컬렉션에 적용될 때 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b8845c337661637cd002489923ad6132dc450c6" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   HTTP caches typically assign heuristic expiration times, employing
   algorithms that use other header values (such as the Last-Modified
   time) to estimate a plausible expiration time. The HTTP/1.1
   specification does not provide specific algorithms, but does impose
   worst-case constraints on their results. Since heuristic expiration
   times might compromise semantic transparency, they ought to used
   cautiously, and we encourage origin servers to provide explicit
   expiration times as much as possible.</source>
          <target state="translated">오리진 서버가 항상 명시적인 만료 시간을 제공하지는 않기 때문에 HTTP 캐시는 일반적으로 휴리스틱 만료 시간을 지정하고 다른 헤더 값 (예 : Last-Modified 시간)을 사용하여 그럴듯한 만료 시간을 추정하는 알고리즘을 사용합니다. HTTP / 1.1 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약 조건을 부과합니다. 휴리스틱 만료 시간은 의미 투명성을 손상시킬 수 있으므로 신중하게 사용해야하며 원본 서버가 가능한 한 명시적인 만료 시간을 제공하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="28a6db603d3e3f168ecb1f550fddcf24914727e1" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   a cache MAY assign a heuristic expiration time when an explicit time
   is not specified, employing algorithms that use other header field
   values (such as the Last-Modified time) to estimate a plausible
   expiration time.  This specification does not provide specific
   algorithms, but does impose worst-case constraints on their results.

   A cache MUST NOT use heuristics to determine freshness when an
   explicit expiration time is present in the stored response.  Because
   of the requirements in &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;, this means that, effectively,
   heuristics can only be used on responses without explicit freshness
   whose status codes are defined as cacheable by default (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;6.1 of [RFC7231]&lt;/a&gt;), and those responses without explicit freshness
   that have been marked as explicitly cacheable (e.g., with a &quot;public&quot;
   response directive).

   If the response has a Last-Modified header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of
   [RFC7232]&lt;/a&gt;), caches are encouraged to use a heuristic expiration value
   that is no more than some fraction of the interval since that time.
   A typical setting of this fraction might be 10%.

   When a heuristic is used to calculate freshness lifetime, a cache
   SHOULD generate a Warning header field with a 113 warn-code (see
   &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt;) in the response if its current_age is more than 24
   hours and such a warning is not already present.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;Section&amp;nbsp;13.9 of [RFC2616]&lt;/a&gt; prohibited caches from calculating
      heuristic freshness for URIs with query components (i.e., those
      containing '?').  In practice, this has not been widely
      implemented.  Therefore, origin servers are encouraged to send
      explicit directives (e.g., Cache-Control: no-cache) if they wish
      to preclude caching.</source>
          <target state="translated">오리진 서버가 항상 명시적인 만료 시간을 제공하지는 않기 때문에 캐시는 명시적인 시간이 지정되지 않은 경우 휴리스틱 만료 시간을 할당하고 다른 헤더 필드 값 (예 : Last-Modified 시간)을 사용하여 그럴듯한 만료 시간을 추정하는 알고리즘을 사용합니다. . 이 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약 조건을 부과합니다. 캐시는 명시 적 만료 시간이 저장된 응답에 존재할 때 휴리스틱을 사용하여 최신 성을 결정해서는 안됩니다. &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; 의 요구 사항으로 인해 휴리스틱은 상태 코드가 기본적으로 캐시 가능으로 정의 된 명시 적 최신 정보가없는 응답에만 효과적으로 사용할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;[RFC7231] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;섹션 &lt;/a&gt;6.1 참조) .) 및 명시 적으로 캐시 할 수있는 것으로 표시된 (예 : &quot;공개&quot;응답 지시문이있는) 명시 적 최신 정보가없는 응답 응답에 Last-Modified 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]의 섹션 2.2&lt;/a&gt; )가있는 경우 캐시는 해당 시간 이후 간격의 일부에 불과한 휴리스틱 만료 값을 사용하도록 권장됩니다. 이 분수의 일반적인 설정은 10 % 일 수 있습니다. 휴리스틱이 신선도 수명을 계산하는 데 사용될 때 캐시는 current_age가 24 시간 이상이고 이러한 경고가 아직 존재하지 않으면 응답에 113 경고 코드 ( &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4 절&lt;/a&gt; 참조)와 함께 경고 헤더 필드를 생성해야합니다 (SHOULD ). . 참고 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;[RFC2616]의 섹션 13.9&lt;/a&gt;캐시가 쿼리 구성 요소가있는 URI (예 : '?'가 포함 된 URI)의 휴리스틱 신선도를 계산하지 못하도록 금지 실제로 이것은 널리 구현되지 않았습니다. 따라서 원본 서버는 캐싱을 금지하려는 경우 명시 적 지시문 (예 : Cache-Control : no-cache)을 보내도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="509ec028b2372cca14a02773e4ddea3d5e0dcfb9" translate="yes" xml:space="preserve">
          <source>Since property values are typically used to hold information such as
   the author of a document, there is the possibility that privacy
   concerns could arise stemming from widespread access to a resource's
   property data.  To reduce the risk of inadvertent release of private
   information via properties, servers are encouraged to develop access
   control mechanisms that separate read access to the resource body and
   read access to the resource's properties.  This allows a user to
   control the dissemination of their property data without overly
   restricting access to the resource's contents.</source>
          <target state="translated">속성 값은 일반적으로 문서 작성자와 같은 정보를 보유하는 데 사용되므로 리소스 속성 데이터에 대한 광범위한 액세스로 인해 개인 정보 보호 문제가 발생할 수 있습니다. 속성을 통한 개인 정보의 우발적 인 릴리스 위험을 줄이기 위해 서버는 리소스 본문에 대한 읽기 액세스와 리소스 속성에 대한 읽기 액세스를 분리하는 액세스 제어 메커니즘을 개발하는 것이 좋습니다. 이를 통해 사용자는 리소스 내용에 대한 액세스를 지나치게 제한하지 않고 속성 데이터의 배포를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc586157b2e078cf31d317a4f20a745527f123b" translate="yes" xml:space="preserve">
          <source>Since representation data is transferred in payloads as a sequence of
   octets, a byte range is a meaningful substructure for any
   representation transferable over HTTP (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).  The
   &quot;bytes&quot; range unit is defined for expressing subranges of the data's
   octet sequence.

     bytes-unit       = &quot;bytes&quot;

   A byte-range request can specify a single range of bytes or a set of
   ranges within a single representation.

     byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
     byte-range-set  = 1#( byte-range-spec / suffix-byte-range-spec )
     byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
     first-byte-pos  = 1*DIGIT
     last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range.  The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive.  Byte offsets start at zero.

   Examples of byte-ranges-specifier values:

   o  The first 500 bytes (byte offsets 0-499, inclusive):

        bytes=0-499

   o  The second 500 bytes (byte offsets 500-999, inclusive):

        bytes=500-999 

   A byte-range-spec is invalid if the last-byte-pos value is present
   and less than the first-byte-pos.

   A client can limit the number of bytes requested without knowing the
   size of the selected representation.  If the last-byte-pos value is
   absent, or if the value is greater than or equal to the current
   length of the representation data, the byte range is interpreted as
   the remainder of the representation (i.e., the server replaces the
   value of last-byte-pos with a value that is one less than the current
   length of the selected representation).

   A client can request the last N bytes of the selected representation
   using a suffix-byte-range-spec.

     suffix-byte-range-spec = &quot;-&quot; suffix-length
     suffix-length = 1*DIGIT

   If the selected representation is shorter than the specified
   suffix-length, the entire representation is used.

   Additional examples, assuming a representation of length 10000:

   o  The final 500 bytes (byte offsets 9500-9999, inclusive):

        bytes=-500

   Or:

        bytes=9500-

   o  The first and last bytes only (bytes 0 and 9999):

        bytes=0-0,-1

   o  Other valid (but not canonical) specifications of the second 500
      bytes (byte offsets 500-999, inclusive):

        bytes=500-600,601-999
        bytes=500-700,601-999

   If a valid byte-range-set includes at least one byte-range-spec with
   a first-byte-pos that is less than the current length of the
   representation, or at least one suffix-byte-range-spec with a
   non-zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. 

   In the byte-range syntax, first-byte-pos, last-byte-pos, and
   suffix-length are expressed as decimal number of octets.  Since there
   is no predefined limit to the length of a payload, recipients MUST
   anticipate potentially large decimal numerals and prevent parsing
   errors due to integer conversion overflows.</source>
          <target state="translated">표현 데이터는 일련의 8 진수로 페이로드로 전송되므로 바이트 범위는 HTTP를 통해 전송할 수있는 표현의 의미있는 하위 구조입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;섹션 3 [RFC7231]&lt;/a&gt;). &quot;바이트&quot;범위 단위는 데이터 옥텟 시퀀스의 하위 범위를 표현하기 위해 정의됩니다. bytes-unit = &quot;bytes&quot;바이트 범위 요청은 단일 표현 내에서 단일 바이트 범위 또는 범위 세트를 지정할 수 있습니다. 바이트 범위 지정자 = 바이트 단위 &quot;=&quot;바이트 범위 설정 바이트 범위 설정 = 1 # (바이트 범위 범위 / 접미사 바이트 범위 범위) 바이트 범위 범위 = 첫 번째 바이트- pos &quot;-&quot;[last-byte-pos] first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT byte-range-spec의 first-byte-pos 값은 바이트 오프셋을 제공합니다. 범위의 첫 번째 바이트. last-byte-pos 값은 범위 내에서 마지막 바이트의 바이트 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0에서 시작합니다. 바이트 범위 지정자 값의 예 :o 첫 번째 500 바이트 (바이트 오프셋 0-499 포함) : bytes = 0-499 o 두 번째 500 바이트 (바이트 오프셋 500-999 포함) : bytes = 500-999 바이트 범위 스펙은 last-byte-pos 값이 있으며 첫 번째 byte-pos보다 작습니다. 클라이언트는 선택된 표현의 크기를 몰라도 요청 된 바이트 수를 제한 할 수 있습니다. 마지막 바이트 위치 값이 없거나 값이 현재 표현 데이터 길이보다 크거나 같은 경우 바이트 범위는 나머지 표현으로 해석됩니다 (즉, 서버가 마지막 값을 대체 함). -byte-pos는 선택된 표현의 현재 길이보다 1보다 작은 값을가집니다). 클라이언트는 접미사-바이트-범위-사양을 사용하여 선택된 표현의 마지막 N 바이트를 요청할 수 있습니다.suffix-byte-range-spec = &quot;-&quot;접미사 길이 suffix-length = 1 * DIGIT 선택한 표현이 지정된 접미사 길이보다 짧은 경우 전체 표현이 사용됩니다. 길이 10000의 표현을 가정 한 추가 예제 : o 마지막 500 바이트 (바이트 오프셋 9500-9999 포함) : bytes = -500 또는 : bytes = 9500- o 첫 번째와 마지막 바이트 만 (바이트 0 및 9999) : 바이트 = 0-0, -1 o 두 번째 500 바이트의 다른 유효한 (표준이 아닌) 사양 (바이트 오프셋 500-999 포함) : bytes = 500-600,601-999 bytes = 500-700,601-999 유효한 바이트 범위 세트는 표현의 현재 길이보다 작은 첫 번째 바이트 위치를 갖는 하나 이상의 바이트 범위 스펙을 포함합니다.또는 0이 아닌 접미사 길이를 갖는 적어도 하나의 접미사-바이트-범위-사양이면, 바이트-범위-세트가 만족 가능하다. 그렇지 않으면 바이트 범위 세트가 만족스럽지 않습니다. 바이트 범위 구문에서 first-byte-pos, last-byte-pos 및 suffix-length는 10 진수의 10 진수로 표시됩니다. 페이로드의 길이에는 사전 정의 된 제한이 없으므로 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="774d5768b3cb89b1969b07ba3f6b81f799741b41" translate="yes" xml:space="preserve">
          <source>Since server lock support is optional, a client trying to lock a
   resource on a server can either try the lock and hope for the best,
   or perform some form of discovery to determine what lock capabilities
   the server supports.  This is known as lock capability discovery.  A
   client can determine what lock types the server supports by
   retrieving the DAV:supportedlock property.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:supportedlock property.</source>
          <target state="translated">서버 잠금 지원은 선택 사항이므로 서버에서 리소스를 잠그려고하는 클라이언트는 잠금을 시도하고 최선을 다하거나 서버가 어떤 잠금 기능을 지원하는지 파악하기 위해 검색을 수행 할 수 있습니다. 이것을 잠금 기능 발견이라고합니다. 클라이언트는 DAV : supportedlock 특성을 검색하여 서버가 지원하는 잠금 유형을 판별 할 수 있습니다. LOCK 메소드를 지원하는 모든 DAV 호환 자원은 DAV : supportedlock 특성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="94a8f31f5d75fba5bea69bbed106207fdc98fadf" translate="yes" xml:space="preserve">
          <source>Since the &quot;http&quot; and &quot;https&quot; schemes conform to the URI generic
   syntax, such URIs are normalized and compared according to the
   algorithm defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC3986]&lt;/a&gt;, using the defaults
   described above for each scheme.

   If the port is equal to the default port for a scheme, the normal
   form is to omit the port subcomponent.  When not being used in
   absolute form as the request target of an OPTIONS request, an empty
   path component is equivalent to an absolute path of &quot;/&quot;, so the
   normal form is to provide a path of &quot;/&quot; instead.  The scheme and host
   are case-insensitive and normally provided in lowercase; all other
   components are compared in a case-sensitive manner.  Characters other
   than those in the &quot;reserved&quot; set are equivalent to their
   percent-encoded octets: the normal form is to not encode them (see
   Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]).

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http://example.com:80/~smith/home.html&lt;/a&gt;
      http://EXAMPLE.com/%7Esmith/home.html
      &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;http://EXAMPLE.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">&quot;http&quot;및 &quot;https&quot;체계는 URI 일반 구문을 따르므로 이러한 URI는 정규화되어 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;[RFC3986]의 6 절에&lt;/a&gt; 정의 된 알고리즘에 따라 비교됩니다 .각 구성표에 대해 위에서 설명한 기본값을 사용합니다. 포트가 구성표의 기본 포트와 같은 경우 일반적인 형식은 포트 하위 구성 요소를 생략하는 것입니다. OPTIONS 요청의 요청 대상으로 절대 형식으로 사용되지 않는 경우 빈 경로 구성 요소는 &quot;/&quot;의 절대 경로와 동일하므로 일반 형식은 대신 &quot;/&quot;의 경로를 제공하는 것입니다. 체계와 호스트는 대소 문자를 구분하지 않으며 일반적으로 소문자로 제공됩니다. 다른 모든 구성 요소는 대소 문자를 구분하여 비교됩니다. &quot;예약 된&quot;세트의 문자 이외의 문자는 퍼센트로 인코딩 된 8 진수와 같습니다. 일반적인 형식은 해당 문자를 인코딩하지 않는 것입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; 의 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 및 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 단원 참조).]). 예를 들어 다음 세 가지 URI는 동일합니다. &lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http://example.com:80/~smith/home.html&lt;/a&gt; http://EXAMPLE.com/%7Esmith/home.html &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;http://EXAMPLE.com:/% 7esmith / home.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3878be391d0341c64c35b2c3bb2ccfa884cc0a3f" translate="yes" xml:space="preserve">
          <source>Since the request-target often contains only part of the user agent's
   target URI, a server reconstructs the intended target as an
   &quot;effective request URI&quot; to properly service the request.  This
   reconstruction involves both the server's local configuration and
   information communicated in the request-target, Host header field,
   and connection context.

   For a user agent, the effective request URI is the target URI.

   If the request-target is in absolute-form, the effective request URI
   is the same as the request-target.  Otherwise, the effective request
   URI is constructed as follows:

      If the server's configuration (or outbound gateway) provides a
      fixed URI scheme, that scheme is used for the effective request
      URI.  Otherwise, if the request is received over a TLS-secured TCP
      connection, the effective request URI's scheme is &quot;https&quot;; if not,
      the scheme is &quot;http&quot;.

      If the server's configuration (or outbound gateway) provides a
      fixed URI authority component, that authority is used for the
      effective request URI.  If not, then if the request-target is in
      authority-form, the effective request URI's authority component is
      the same as the request-target.  If not, then if a Host header
      field is supplied with a non-empty field-value, the authority
      component is the same as the Host field-value.  Otherwise, the
      authority component is assigned the default name configured for
      the server and, if the connection's incoming TCP port number
      differs from the default port for the effective request URI's
      scheme, then a colon (&quot;:&quot;) and the incoming port number (in
      decimal form) are appended to the authority component.

      If the request-target is in authority-form or asterisk-form, the
      effective request URI's combined path and query component is
      empty.  Otherwise, the combined path and query component is the
      same as the request-target.

      The components of the effective request URI, once determined as
      above, can be combined into absolute-URI form by concatenating the
      scheme, &quot;://&quot;, authority, and combined path and query component. 

   Example 1: the following message received over an insecure TCP
   connection

     GET /pub/WWW/TheProject.html HTTP/1.1
     Host: www.example.org:8080

   has an effective request URI of

     &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt;

   Example 2: the following message received over a TLS-secured TCP
   connection

     OPTIONS * HTTP/1.1
     Host: www.example.org

   has an effective request URI of

     https://www.example.org

   Recipients of an HTTP/1.0 request that lacks a Host header field
   might need to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.

   Once the effective request URI has been constructed, an origin server
   needs to decide whether or not to provide service for that URI via
   the connection in which the request was received.  For example, the
   request might have been misdirected, deliberately or accidentally,
   such that the information within a received request-target or Host
   header field differs from the host or port upon which the connection
   has been made.  If the connection is from a trusted gateway, that
   inconsistency might be expected; otherwise, it might indicate an
   attempt to bypass security filters, trick the server into delivering
   non-public content, or poison a cache.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt; for security
   considerations regarding message routing.</source>
          <target state="translated">요청 대상에는 종종 사용자 에이전트 대상 URI의 일부만 포함되므로 서버는 요청을 올바르게 서비스하기 위해 의도 된 대상을 &quot;유효 요청 URI&quot;로 재구성합니다. 이 재구성에는 서버의 로컬 구성과 요청 대상, 호스트 헤더 필드 및 연결 컨텍스트에서 통신되는 정보가 모두 포함됩니다. 사용자 에이전트의 경우 유효 요청 URI는 대상 URI입니다. 요청 대상이 절대 형식 인 경우 유효 요청 URI는 요청 대상과 동일합니다. 그렇지 않으면 유효 요청 URI는 다음과 같이 구성됩니다. 서버 구성 (또는 아웃 바운드 게이트웨이)이 고정 URI 스킴을 제공하면 해당 스킴이 유효 요청 URI에 사용됩니다. 그렇지 않으면,요청이 TLS 보안 TCP 연결을 통해 수신되면 유효 요청 URI의 체계는 &quot;https&quot;입니다. 그렇지 않은 경우 체계는 &quot;http&quot;입니다. 서버 구성 (또는 아웃 바운드 게이트웨이)이 고정 URI 권한 구성 요소를 제공하는 경우 해당 권한은 유효 요청 URI에 사용됩니다. 그렇지 않은 경우 요청 대상이 권한 양식 인 경우 유효 요청 URI의 권한 구성 요소는 요청 대상과 동일합니다. 그렇지 않은 경우 호스트 헤더 필드에 비어 있지 않은 필드 값이 제공되면 권한 구성 요소는 호스트 필드 값과 동일합니다. 그렇지 않으면, 권한 구성 요소에 서버에 대해 구성된 기본 이름이 지정되며 연결의 경우수신 TCP 포트 번호가 유효 요청 URI 체계의 기본 포트와 다르면 콜론 ( &quot;:&quot;) 및 수신 포트 번호 (10 진수 형식)가 권한 구성 요소에 추가됩니다. 요청 대상이 권한 양식 또는 별표 양식 인 경우 유효 요청 URI의 결합 된 경로 및 조회 구성 요소가 비어 있습니다. 그렇지 않으면 결합 된 경로 및 쿼리 구성 요소는 요청 대상과 동일합니다. 위와 같이 결정된 유효 요청 URI의 구성 요소는 &quot;: //&quot;체계, 권한 및 결합 된 경로 및 쿼리 구성 요소를 연결하여 절대 URI 형식으로 결합 될 수 있습니다. 예 1 : 다음 메시지가 안전하지 않은 TCP 연결 GET /pub/WWW/TheProject.html HTTP / 1.1 호스트를 통해 수신되었습니다 : www.example.org : 8080의 유효 요청 URI는 다음과 같습니다. &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt; 예 2 : TLS 보안 TCP 연결을 통해 수신 된 다음 메시지 옵션 * HTTP / 1.1 호스트 : www.example.org의 유효 요청 URI는 https://www.example.org입니다. HTTP / 1.0 요청의 수신자가 부족합니다. 호스트 헤더 필드는 효과적인 요청 URI의 권한 구성 요소를 추측하기 위해 휴리스틱 (예 : 특정 호스트에 고유 한 URI 경로 검사)을 사용해야합니다. 유효 요청 URI가 구성되면 오리진 서버는 요청이 수신 된 연결을 통해 해당 URI에 서비스를 제공할지 여부를 결정해야합니다. 예를 들어 요청이 고의적으로 또는 실수로 잘못 전송되었을 수 있습니다.수신 된 요청 대상 또는 호스트 헤더 필드 내의 정보가 연결이 이루어진 호스트 또는 포트와 다르도록. 신뢰할 수있는 게이트웨이에서 연결 한 경우 해당 불일치가 예상 될 수 있습니다. 그렇지 않으면 보안 필터를 우회하거나 서버가 비 공용 컨텐츠를 전달하도록 속이거나 캐시를 감염시키려는 시도 일 수 있습니다. 보다&lt;a href=&quot;#section-9&quot;&gt;&lt;/a&gt;메시지 라우팅과 관련된 보안 고려 사항 은 9 절 .</target>
        </trans-unit>
        <trans-unit id="a531f36cb52973a36d35f55d654a8d428773bf1d" translate="yes" xml:space="preserve">
          <source>Since this document describes a set of extensions to the HTTP/1.1
   protocol, the augmented BNF used herein to describe protocol elements
   is exactly the same as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;,
   including the rules about implied linear whitespace.  Since this
   augmented BNF uses the basic production rules provided in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2
   of [RFC2616]&lt;/a&gt;, these rules apply to this document as well.  Note this
   is not the standard BNF syntax used in other RFCs.

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Note that in natural language, a property like the &quot;creationdate&quot;
   property in the &quot;DAV:&quot; XML namespace is sometimes referred to as
   &quot;DAV:creationdate&quot; for brevity.</source>
          <target state="translated">이 문서는 HTTP / 1.1 프로토콜에 대한 일련의 확장을 설명하므로, 프로토콜 요소를 설명하기 위해 여기에 사용 된 증강 BNF 는 암시 적 선형 공백에 대한 규칙을 포함하여 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]의 2.1 절에&lt;/a&gt; 설명 된 것과 정확히 동일 합니다. 이 보강 된 BNF는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]의 2.2 절에&lt;/a&gt; 제공된 기본 생산 규칙을 ​​사용하므로 이러한 규칙도이 문서에도 적용됩니다. 이것은 다른 RFC에 사용되는 표준 BNF 구문이 아닙니다. 이 문서에서 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119에&lt;/a&gt; 설명 된대로 해석]. 자연어에서 &quot;DAV :&quot;XML 네임 스페이스의 &quot;creationdate&quot;속성과 같은 속성은 간결성을 위해 &quot;DAV : creationdate&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="6ed1ccbe5b50342757a2d3ea53224582ca419bad" translate="yes" xml:space="preserve">
          <source>Since version 4.1, Klar for Android uses the same UA string as &lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus for Android&lt;/a&gt;. Before version 4.1, it sent a &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt;&lt;var&gt;product/version&lt;/var&gt; token.</source>
          <target state="translated">버전 4.1부터 Android 용 Klar는 Android 용 &lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus&lt;/a&gt; 와 동일한 UA 문자열을 사용합니다 . 버전 4.1 이전에는 &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt; &lt;var&gt;product/version&lt;/var&gt; 토큰을 보냈습니다 .</target>
        </trans-unit>
        <trans-unit id="f2e4d9b56d7689a1ae584bddcddb038ff0772c38" translate="yes" xml:space="preserve">
          <source>Since your domain isn't &lt;code&gt;example.com&lt;/code&gt;, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;href&lt;/code&gt; set to &lt;code&gt;https://example.com&lt;/code&gt; will result in a CSP violation.</source>
          <target state="translated">도메인이 아니기 때문에 &lt;code&gt;example.com&lt;/code&gt; 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 그와 요소 &lt;code&gt;href&lt;/code&gt; 로 설정 &lt;code&gt;https://example.com&lt;/code&gt; 은 CSP를 위반이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a9315f35220268432d25d79a4154c7f1eccd789" translate="yes" xml:space="preserve">
          <source>Single part ranges</source>
          <target state="translated">단일 부품 범위</target>
        </trans-unit>
        <trans-unit id="6e08a5615f12f6057b7ff9d9ceecce7b3562aacc" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of known length, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알려진 길이의 단일 파일로 구성된 단일 리소스 본문 ( &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; )으로&lt;/a&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f99f82fdece07fba6789c9308f7b0c3bc7a0e91" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of unknown length, encoded by chunks with &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;chunked&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;chunked&lt;/code&gt; 로 설정된 청크로 인코딩 된 알 수없는 길이의 단일 파일로 구성된 단일 리소스 본문 .</target>
        </trans-unit>
        <trans-unit id="d60483a13a434ebf8efec0b71ca52e651ce1040b" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of one single file, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 의 두 헤더로 정의 된 하나의 단일 파일로 구성된 단일 자원 본문 .</target>
        </trans-unit>
        <trans-unit id="762d05cd3ee1357a02893672cf750fd1659a4eed" translate="yes" xml:space="preserve">
          <source>Site security testers usually expect this header to be set.</source>
          <target state="translated">사이트 보안 테스터는 일반적으로이 헤더가 설정 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="88a34e382ce47cacc14889b5eb99b2deb9447680" translate="yes" xml:space="preserve">
          <source>Slug is an HTTP entity-header whose presence in a POST to a
   Collection constitutes a request by the client to use the header's
   value as part of any URIs that would normally be used to retrieve the
   to-be-created Entry or Media Resources.

   Servers MAY use the value of the Slug header when creating the Member
   URI of the newly created Resource, for instance, by using some or all
   of the words in the value for the last URI segment.  Servers MAY also
   use the value when creating the atom:id, or as the title of a Media
   Link Entry (see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;). 

   Servers MAY choose to ignore the Slug entity-header.  Servers MAY
   alter the header value before using it.  For instance, a server might
   filter out some characters or replace accented letters with non-
   accented ones, replace spaces with underscores, change case, and so
   on.</source>
          <target state="translated">슬러그 (Slug)는 컬렉션에 대한 POST에서의 존재가 클라이언트가 헤더의 값을 생성 할 엔트리 또는 미디어 리소스를 검색하는 데 일반적으로 사용되는 URI의 일부로 사용하도록 요청하는 HTTP 엔티티 헤더입니다. 서버는 예를 들어 마지막 URI 세그먼트 값의 일부 또는 모든 단어를 사용하여 새로 작성된 자원의 멤버 URI를 작성할 때 Slug 헤더의 값을 사용할 수 있습니다. 서버는 또한 atom : id를 만들 때 또는 미디어 링크 항목의 제목으로 값을 사용할 수도 있습니다 ( &lt;a href=&quot;#section-9.6&quot;&gt;9.6 절&lt;/a&gt; 참조).). 서버는 Slug 엔티티 헤더를 무시하도록 선택할 수 있습니다. 서버는 사용하기 전에 헤더 값을 변경할 수 있습니다. 예를 들어, 서버는 일부 문자를 필터링하거나 악센트 문자를 악센트 부호가없는 문자로 바꾸거나, 공백을 밑줄로 바꾸거나 대소 문자를 바꾸는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc575596897043101f8f28bb8d15019ccb43ccd" translate="yes" xml:space="preserve">
          <source>So until all browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="translated">따라서 모든 브라우저가 사양을 따라 잡을 때까지 다음 중 하나 또는 둘 다를 수행하여이 제한을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="037a3b178c5c3fa1e2c3af1bd926bf5f5c93704e" translate="yes" xml:space="preserve">
          <source>So, choose one of your domains as your canonical one! There are two techniques below to allow the non-canonical domain to work still.</source>
          <target state="translated">따라서 도메인 중 하나를 정식 도메인으로 선택하십시오! 비정규 도메인이 여전히 작동하도록하기위한 두 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7373eebfb9bfd956b54104ec328820e66fdfe6" translate="yes" xml:space="preserve">
          <source>So, do I have to choose one or the other for my web site?</source>
          <target state="translated">내 웹 사이트에 대해 하나를 선택해야합니까?</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="e0f0c555c38a97116b738fdc4ec2d35f3f2aa384" translate="yes" xml:space="preserve">
          <source>Some HTTP header fields allow a time value to be specified as an
   integer number of seconds, represented in decimal, after the time
   that the message was received.

       delta-seconds  = 1*DIGIT</source>
          <target state="translated">일부 HTTP 헤더 필드에서는 시간 값을 메시지 수신 후 10 초로 표시되는 정수 초로 지정할 수 있습니다. 델타 초 = 1 * DIGIT</target>
        </trans-unit>
        <trans-unit id="d62acecb772d2af811fb679ffb025605d29919d2" translate="yes" xml:space="preserve">
          <source>Some HTTP messages transfer a complete or partial representation as
   the message &quot;payload&quot;.  In some cases, a payload might contain only
   the associated representation's header fields (e.g., responses to
   HEAD) or only some part(s) of the representation data (e.g., the 206
   (Partial Content) status code).

   The purpose of a payload in a request is defined by the method
   semantics.  For example, a representation in the payload of a PUT
   request (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) represents the desired state of the target
   resource if the request is successfully applied, whereas a
   representation in the payload of a POST request (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;)
   represents information to be processed by the target resource. 

   In a response, the payload's purpose is defined by both the request
   method and the response status code.  For example, the payload of a
   200 (OK) response to GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) represents the current state
   of the target resource, as observed at the time of the message
   origination date (&lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;), whereas the payload of the same
   status code in a response to POST might represent either the
   processing result or the new state of the target resource after
   applying the processing.  Response messages with an error status code
   usually contain a payload that represents the error condition, such
   that it describes the error state and what next steps are suggested
   for resolving it.

   Header fields that specifically describe the payload, rather than the
   associated representation, are referred to as &quot;payload header
   fields&quot;.  Payload header fields are defined in other parts of this
   specification, due to their impact on message parsing.

   +-------------------+----------------------------+
   | Header Field Name | Defined in...              |
   +-------------------+----------------------------+
   | Content-Length    | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt; |
   | Content-Range     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;   |
   | Trailer           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7230]&lt;/a&gt;   |
   | Transfer-Encoding | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt; |
   +-------------------+----------------------------+</source>
          <target state="translated">일부 HTTP 메시지는 메시지 &quot;페이로드&quot;로 전체 또는 부분 표현을 전송합니다. 일부 경우에, 페이로드는 관련된 표현의 헤더 필드 (예를 들어, HEAD에 대한 응답) 또는 표현 데이터의 일부 (예를 들어, 206 (부분 컨텐츠) 상태 코드)만을 포함 할 수있다. 요청에서 페이로드의 목적은 메소드 시맨틱에 의해 정의됩니다. 예를 들어, PUT 요청의 페이로드 표현 ( &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; )은 요청이 성공적으로 적용된 경우 대상 자원의 원하는 상태를 나타내고 POST 요청의 페이로드 ( &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3)를&lt;/a&gt; 나타냅니다.)은 대상 자원이 처리 할 정보를 나타냅니다. 응답에서 페이로드의 목적은 요청 방법과 응답 상태 코드 모두에 의해 정의됩니다. 예를 들어, GET에 대한 200 (OK) 응답의 페이로드 ( &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; )는 메시지 시작 날짜 ( &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 단원)&lt;/a&gt; 에서 관찰 된 대상 자원의 현재 상태를 나타냅니다.POST에 대한 응답에서 동일한 상태 코드의 페이로드는 처리 결과를 적용한 후 처리 결과 또는 대상 자원의 새로운 상태를 나타낼 수 있습니다. 오류 상태 코드가 포함 된 응답 메시지에는 일반적으로 오류 상태를 나타내는 페이로드가 포함되어있어 오류 상태와이를 해결하기 위해 다음 단계가 제안됩니다. 연관된 표현이 아닌 페이로드를 구체적으로 설명하는 헤더 필드를 &quot;페이로드 헤더 필드&quot;라고합니다. 페이로드 헤더 필드는 메시지 구문 분석에 미치는 영향으로 인해이 사양의 다른 부분에서 정의됩니다. + ------------------- + ---------------------------- + | 헤더 필드 이름 | 에 정의 된 ...| + ------------------- + ---------------------------- + | 콘텐츠 길이 |&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]의 섹션 3.3.2&lt;/a&gt; | | 컨텐츠 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233] 4.2 절&lt;/a&gt; | | 트레일러 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;[RFC7230] 4.4 절&lt;/a&gt; | | 전송 인코딩 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]의 섹션 3.3.1&lt;/a&gt; | + ------------------- + ---------------------------- +</target>
        </trans-unit>
        <trans-unit id="96f4cfa3a2435470f520822a7a281fd09a7abe90" translate="yes" xml:space="preserve">
          <source>Some HTTP resources are dynamically generated by the server.  For
   these resources, there presumably exists source code somewhere
   governing how that resource is generated.  The relationship of source
   files to output HTTP resources may be one to one, one to many, many
   to one, or many to many.  There is no mechanism in HTTP to determine
   whether a resource is even dynamic, let alone where its source files
   exist or how to author them.  Although this problem would usefully be
   solved, interoperable WebDAV implementations have been widely
   deployed without actually solving this problem, by dealing only with
   static resources.  Thus, the source vs. output problem is not solved
   in this specification and has been deferred to a separate document.</source>
          <target state="translated">일부 HTTP 리소스는 서버에서 동적으로 생성됩니다. 이러한 리소스의 경우 해당 리소스 생성 방법을 관리하는 소스 코드가있을 수 있습니다. 소스 파일과 출력 HTTP 자원의 관계는 일대일, 일대 다, 다 대일 또는 다 대다 일 수 있습니다. HTTP에는 소스 파일이 존재하는 위치 나 제작 방법을 제외하고 리소스가 동적인지 여부를 결정하는 메커니즘이 없습니다. 이 문제는 유용하게 해결되지만 정적 자원 만 처리하여 실제로이 문제를 해결하지 않고도 상호 운용 가능한 WebDAV 구현이 광범위하게 배포되었습니다. 따라서 소스 대 출력 문제는이 사양에서 해결되지 않았으며 별도의 문서로 연기되었습니다.</target>
        </trans-unit>
        <trans-unit id="9edae38f81cc4e1676b63507df63fb416ecd279a" translate="yes" xml:space="preserve">
          <source>Some HTTP/1.0 software has interpreted a Content-Type header without
   charset parameter incorrectly to mean &quot;recipient should guess.&quot;
   Senders wishing to defeat this behavior MAY include a charset
   parameter even when the charset is ISO-8859-1 and SHOULD do so when
   it is known that it will not confuse the recipient.

   Unfortunately, some older HTTP/1.0 clients did not deal properly with
   an explicit charset parameter. HTTP/1.1 recipients MUST respect the
   charset label provided by the sender; and those user agents that have
   a provision to &quot;guess&quot; a charset MUST use the charset from the 

   content-type field if they support that charset, rather than the
   recipient's preference, when initially displaying a document. See
   &lt;a href=&quot;#section-3.7.1&quot;&gt;section 3.7.1&lt;/a&gt;.</source>
          <target state="translated">일부 HTTP / 1.0 소프트웨어는 문자 수신자 매개 변수가없는 Content-Type 헤더를 잘못 해석하여 &quot;수신자가 추측해야 함&quot;을 의미합니다. 이 동작을 막으려는 발신자는 문자셋이 ISO-8859-1 인 경우에도 문자셋 매개 변수를 포함 할 수 있으며 수신자를 혼동하지 않는 것으로 알려진 경우에는 그렇게해야합니다 (SHOULD). 불행히도 일부 이전 HTTP / 1.0 클라이언트는 명시 적 문자 집합 매개 변수를 제대로 처리하지 못했습니다. HTTP / 1.1 수신자는 발신자가 제공 한 문자 세트 레이블을 준수해야합니다. 문자셋을 &quot;추측&quot;할 수있는 사용자 에이전트는 문서를 처음 표시 할 때 수신자의 선호도가 아니라 해당 문자셋을 지원하는 경우 반드시 컨텐츠 유형 필드의 문자셋을 사용해야합니다. &lt;a href=&quot;#section-3.7.1&quot;&gt;섹션 3.7.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="76ff9a23340030e08177c96f6cd25b9e75cd64eb" translate="yes" xml:space="preserve">
          <source>Some clients and servers might wish to be compatible with some
   previous implementations of persistent connections in HTTP/1.0
   clients and servers. Persistent connections in HTTP/1.0 are
   explicitly negotiated as they are not the default behavior. HTTP/1.0
   experimental implementations of persistent connections are faulty,
   and the new facilities in HTTP/1.1 are designed to rectify these
   problems. The problem was that some existing 1.0 clients may be
   sending Keep-Alive to a proxy server that doesn't understand
   Connection, which would then erroneously forward it to the next
   inbound server, which would establish the Keep-Alive connection and
   result in a hung HTTP/1.0 proxy waiting for the close on the
   response. The result is that HTTP/1.0 clients must be prevented from
   using Keep-Alive when talking to proxies.

   However, talking to proxies is the most important use of persistent
   connections, so that prohibition is clearly unacceptable. Therefore,
   we need some other mechanism for indicating a persistent connection
   is desired, which is safe to use even when talking to an old proxy
   that ignores Connection. Persistent connections are the default for
   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for
   declaring non-persistence. See &lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;.

   The original HTTP/1.0 form of persistent connections (the Connection:
   Keep-Alive and Keep-Alive header) is documented in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;. [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]</source>
          <target state="translated">일부 클라이언트 및 서버는 HTTP / 1.0 클라이언트 및 서버에서 지속적으로 구현 된 일부 이전 연결과 호환되기를 원할 수 있습니다. HTTP / 1.0의 영구 연결은 기본 동작이 아니므로 명시 적으로 협상됩니다. 지속적 연결의 HTTP / 1.0 실험 구현에는 결함이 있으며 HTTP / 1.1의 새로운 기능은 이러한 문제를 해결하도록 설계되었습니다. 문제는 기존의 일부 1.0 클라이언트가 연결을 이해하지 못하는 프록시 서버로 Keep-Alive를 전송하는 경우 다음 인바운드 서버로 잘못 전달하여 Keep-Alive 연결을 설정하고 중단되는 결과를 초래한다는 것입니다 응답 종료를 기다리는 HTTP / 1.0 프록시. 결과적으로 프록시와 통신 할 때 HTTP / 1.0 클라이언트가 Keep-Alive를 사용하지 못하도록해야합니다.그러나 프록시와 대화하는 것이 지속적인 연결을 사용하는 가장 중요한 용도이므로 금지를 분명히 받아 들일 수 없습니다. 따라서 지속적인 연결이 필요하다는 것을 나타내는 다른 메커니즘이 필요합니다. 이는 Connection을 무시하는 오래된 프록시와 대화 할 때도 안전하게 사용할 수 있습니다. 영구 연결은 HTTP / 1.1 메시지의 기본값입니다. 비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다&lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10&lt;/a&gt; . 영구 연결의 원래 HTTP / 1.0 형식 (연결 : 연결 유지 및 연결 유지 헤더)은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068에&lt;/a&gt; 문서화되어 있습니다. [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="66a43f342d6b50a7175f69c935c3406eba5914f1" translate="yes" xml:space="preserve">
          <source>Some common incorrect server configurations:</source>
          <target state="translated">몇 가지 일반적인 잘못된 서버 구성 :</target>
        </trans-unit>
        <trans-unit id="9270b0f5d6139d14ce495519a232664c8d2acd88" translate="yes" xml:space="preserve">
          <source>Some features of the HTTP/1.1 protocol, such as Digest
   Authentication, depend on the value of certain end-to-end headers. A
   transparent proxy SHOULD NOT modify an end-to-end header unless the
   definition of that header requires or specifically allows that. 

   A transparent proxy MUST NOT modify any of the following fields in a
   request or response, and it MUST NOT add any of these fields if not
   already present:

      - Content-Location

      - Content-MD5

      - ETag

      - Last-Modified

   A transparent proxy MUST NOT modify any of the following fields in a
   response:

      - Expires

   but it MAY add any of these fields if not already present. If an
   Expires header is added, it MUST be given a field-value identical to
   that of the Date header in that response.

   A  proxy MUST NOT modify or add any of the following fields in a
   message that contains the no-transform cache-control directive, or in
   any request:

      - Content-Encoding

      - Content-Range

      - Content-Type

   A non-transparent proxy MAY modify or add these fields to a message
   that does not include no-transform, but if it does so, it MUST add a
   Warning 214 (Transformation applied) if one does not already appear
   in the message (see &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;).

      Warning: unnecessary modification of end-to-end headers might
      cause authentication failures if stronger authentication
      mechanisms are introduced in later versions of HTTP. Such
      authentication mechanisms MAY rely on the values of header fields
      not listed here.

   The Content-Length field of a request or response is added or deleted
   according to the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;. A transparent proxy MUST
   preserve the entity-length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;) of the entity-body,
   although it MAY change the transfer-length (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).</source>
          <target state="translated">다이제스트 인증과 같은 HTTP / 1.1 프로토콜의 일부 기능은 특정 엔드 투 엔드 헤더의 값에 따라 다릅니다. 투명한 프록시는 그 헤더의 정의가 요구하거나 구체적으로 허용하지 않는 한 엔드 투 엔드 헤더를 수정해서는 안됩니다. 투명 프록시는 요청 또는 응답에서 다음 필드를 수정해서는 안되며 아직 존재하지 않는 경우 이러한 필드를 추가해서는 안됩니다.-Content-Location-Content-MD5-ETag-Last-Modified 투명 프록시는 NOT 응답에서 다음 필드 중 하나를 수정하십시오.-만료되지만이 필드 중 하나가 아직없는 경우 추가 할 수 있습니다. Expires 헤더가 추가되면 해당 응답의 Date 헤더와 동일한 필드 값이 제공되어야합니다.프록시는 트랜스 폼 없음 캐시 제어 지시문이 포함 된 메시지 또는 요청에서 다음 필드를 수정하거나 추가해서는 안됩니다.-Content-Encoding-Content-Range-Content-Type 투명하지 않은 프록시는 수정 될 수 있습니다. 또는 트랜스 폼 없음을 포함하지 않는 메시지에 이러한 필드를 추가하십시오. 그렇지 않은 경우 메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조&lt;a href=&quot;#section-14.46&quot;&gt;섹션 14.46&lt;/a&gt; ). 경고 : 이후 버전의 HTTP에 강력한 인증 메커니즘이 도입 된 경우 엔드 투 엔드 헤더를 불필요하게 수정하면 인증이 실패 할 수 있습니다. 이러한 인증 메커니즘은 여기에 나열되지 않은 헤더 필드의 값에 의존 할 수 있습니다. 요청 또는 응답의 Content-Length 필드는 &lt;a href=&quot;#section-4.4&quot;&gt;4.4 섹션&lt;/a&gt; 의 규칙에 따라 추가 또는 삭제됩니다 . 투명한 프록시는 엔티티 길이 ( &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; )를 유지해야 하지만 전송 길이 ( &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; )를 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08d40ce154c5b61338b36a1b4a7b8fc44f8f33e3" translate="yes" xml:space="preserve">
          <source>Some formats can be used for both loss-less or lossy compression, like &lt;code&gt;webp&lt;/code&gt;, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a Web site, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are &lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;numerous tools&lt;/a&gt; that are specialized for this.</source>
          <target state="translated">일부 형식은 &lt;code&gt;webp&lt;/code&gt; 와 같이 무손실 또는 무손실 압축에 모두 사용될 수 있으며 일반적으로 손실 알고리즘은 다소 압축되도록 구성 할 수 있으며, 그 결과 품질은 다소 떨어집니다. 웹 사이트의 성능을 향상 시키려면 허용 가능한 수준의 품질을 유지하면서 최대한 압축하는 것이 좋습니다. 이미지의 경우 도구로 생성 된 이미지는 웹에 충분히 최적화되지 않을 수 있습니다. 필요한 품질로 최대한 압축하는 도구를 사용하는 것이 좋습니다. 이에 특화된 &lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;수많은 도구&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ac20f104a927276bcef1c71021955f476f1866" translate="yes" xml:space="preserve">
          <source>Some intermediaries include features for transforming messages and
   their payloads.  A proxy might, for example, convert between image
   formats in order to save cache space or to reduce the amount of
   traffic on a slow link.  However, operational problems might occur
   when these transformations are applied to payloads intended for
   critical applications, such as medical imaging or scientific data
   analysis, particularly when integrity checks or digital signatures
   are used to ensure that the payload received is identical to the
   original.

   An HTTP-to-HTTP proxy is called a &quot;transforming proxy&quot; if it is
   designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter.  Such transformations are
   presumed to be desired by whichever client (or client organization)
   selected the proxy.

   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it MAY add its own domain to the host
   name it received when forwarding the request.  A proxy MUST NOT
   change the host name if the request-target contains a fully qualified
   domain name. 

   A proxy MUST NOT modify the &quot;absolute-path&quot; and &quot;query&quot; parts of the
   received request-target when forwarding it to the next inbound
   server, except as noted above to replace an empty path with &quot;/&quot; or
   &quot;*&quot;.

   A proxy MAY modify the message body through application or removal of
   a transfer coding (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).

   A proxy MUST NOT transform the payload (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7231]&lt;/a&gt;) of
   a message that contains a no-transform cache-control directive
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).

   A proxy MAY transform the payload of a message that does not contain
   a no-transform cache-control directive.  A proxy that transforms a
   payload MUST add a Warning header field with the warn-code of 214
   (&quot;Transformation Applied&quot;) if one is not already in the message (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;).  A proxy that transforms the payload of a
   200 (OK) response can further inform downstream recipients that a
   transformation has been applied by changing the response status code
   to 203 (Non-Authoritative Information) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;Section&amp;nbsp;6.3.4 of [RFC7231]&lt;/a&gt;).

   A proxy SHOULD NOT modify header fields that provide information
   about the endpoints of the communication chain, the resource state,
   or the selected representation (other than the payload) unless the
   field's definition specifically allows such modification or the
   modification is deemed necessary for privacy or security.</source>
          <target state="translated">일부 중개자에는 메시지 및 해당 페이로드를 변환하는 기능이 있습니다. 예를 들어 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 그러나 이러한 변환이 의료 이미징 또는 과학적 데이터 분석과 같은 중요한 응용 프로그램을위한 페이로드에 적용될 때, 특히 무결성 검사 또는 디지털 서명을 사용하여 수신 된 페이로드가 원본과 동일한 지 확인하는 경우 작동 문제가 발생할 수 있습니다. HTTP-to-HTTP 프록시는 의미 적으로 의미있는 방식으로 메시지를 수정하도록 설계 또는 구성된 경우 (예 : 일반 HTTP 처리에 필요한 것 이외의 수정)원래 발신자에게 중요하거나 다운 스트림 수신자에게 중요 할 수있는 방식으로 메시지를 변경합니다. 예를 들어, 변환 프록시는 공유 주석 서버 (로컬 주석 데이터베이스에 대한 참조를 포함하도록 응답 수정), 맬웨어 필터, 형식 트랜스 코더 또는 개인 정보 필터 역할을 할 수 있습니다. 이러한 변환은 어느 클라이언트 (또는 클라이언트 조직)가 프록시를 선택했는지에 따라 원하는 것으로 추정됩니다. 프록시가 정규화 된 도메인 이름이 아닌 호스트 이름으로 요청 대상을 수신하면 요청을 전달할 때받은 호스트 이름에 자체 도메인을 추가 할 수 있습니다. 요청 대상에 정규화 된 도메인 이름이 포함 된 경우 프록시는 호스트 이름을 변경해서는 안됩니다. 프록시는 &quot;절대 경로&quot;와 &quot;빈 경로를 &quot;/&quot;또는 &quot;*&quot;로 대체하기 위해 위에서 언급 한 것을 제외하고, 다음 인바운드 서버로 전달할 때 수신 된 요청 대상의 query &quot;부분. 프록시는 응용 프로그램 또는 전송 제거를 통해 메시지 본문을 수정할 수 있습니다. 코딩 (&lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ). 프록시는 트랜스 폼이 없는 캐시 제어 지시문을 포함하는 메시지 의 페이로드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;[RFC7231]의 3.3 절)를&lt;/a&gt; 변환해서는 안됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절&lt;/a&gt; ). 프록시는 트랜스 폼이없는 캐시 제어 지시어를 포함하지 않는 메시지의 페이로드를 변환 할 수있다. 페이로드를 변환하는 프록시는 경고 코드가 214 인 경고 헤더 필드 ( &quot;변환 적용됨&quot;)를 아직 메시지에없는 경우 추가해야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]의 5.5 절&lt;/a&gt; 참조 ). 200 (OK) 응답의 페이로드를 변환하는 프록시는 응답 상태 코드를 203 (비 정식 정보)으로 변경하여 다운 스트림 수신자에게 변환이 적용되었음을 알릴 수 있습니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;[RFC7231]의 섹션 6.3.4&lt;/a&gt; ). 필드의 정의가 특별히 그러한 수정을 허용하거나 수정이 개인 정보 보호 또는 보안에 필요한 것으로 간주되지 않는 한, 프록시는 통신 체인의 끝점, 자원 상태 또는 선택된 표현 (페이로드 이외)에 대한 정보를 제공하는 헤더 필드를 수정해서는 안됩니다. .</target>
        </trans-unit>
        <trans-unit id="eac57a1de8acde9c46e58fb564a5c63eef8c02df" translate="yes" xml:space="preserve">
          <source>Some of these new methods do not define bodies.  Servers MUST examine
   all requests for a body, even when a body was not expected.  In cases
   where a request body is present but would be ignored by a server, the
   server MUST reject the request with 415 (Unsupported Media Type).
   This informs the client (which may have been attempting to use an
   extension) that the body could not be processed as the client
   intended.</source>
          <target state="translated">이러한 새로운 방법 중 일부는 본문을 정의하지 않습니다. 서버는 본문이 예상되지 않은 경우에도 본문에 대한 모든 요청을 검사해야합니다. 요청 본문이 있지만 서버에서 무시되는 경우 서버는 415 (지원되지 않는 미디어 유형)로 요청을 거부해야합니다. 이것은 클라이언트 (확장자를 사용하려고 시도했을 수도 있음)에게 클라이언트가 의도 한대로 본문을 처리 할 수 ​​없음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4e4cf2038e1894371084626084a37cd3855e9122" translate="yes" xml:space="preserve">
          <source>Some origin server implementations might not have a clock available.
   An origin server without a clock MUST NOT assign Expires or Last-
   Modified values to a response, unless these values were associated
   with the resource by a system or user with a reliable clock. It MAY
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows &quot;pre-expiration&quot;
   of responses without storing separate Expires values for each
   resource).</source>
          <target state="translated">일부 오리진 서버 구현에는 사용 가능한 시계가 없을 수 있습니다. 클럭이없는 오리진 서버는 신뢰할 수있는 클럭을 가진 시스템이나 사용자가이 값을 리소스와 연관시키지 않는 한 만료 또는 마지막 수정 값을 응답에 할당해서는 안됩니다 (MUST NOT). 서버 구성 시간 또는 이전에 알려진 Expires 값을 과거로 지정할 수 있습니다 (각 자원에 대해 별도의 Expires 값을 저장하지 않고 응답의 &quot;사전 만료&quot;를 허용 함).</target>
        </trans-unit>
        <trans-unit id="03c3e50ec8cb12cf3acddc31b3a981323a1ddf6c" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so only specific users can access it. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">일부 페이지는 보호되어 특정 사용자 만 액세스 할 수 있습니다. 기본 인증은 &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 유사한 헤더를 사용하거나 &lt;a href=&quot;cookies&quot;&gt;HTTP 쿠키를&lt;/a&gt; 사용하여 특정 세션을 설정 하여 HTTP를 통해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a7d1f4b13e76bd620feb3c514de20a064d7ef93" translate="yes" xml:space="preserve">
          <source>Some proxy servers might need authority to create a tunnel. See also the &lt;a href=&quot;../headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">일부 프록시 서버는 터널을 만들 권한이 필요할 수 있습니다. &lt;a href=&quot;../headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0fe168232211ebb71557e7e371b951b8fb141f8" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &amp;ldquo;simple requests&amp;rdquo; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A request that doesn&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;&amp;mdash;a so-called &amp;ldquo;simple request&amp;rdquo; &amp;mdash; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">일부 요청은 &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight를&lt;/a&gt; 트리거하지 않습니다 . &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; 스펙 (CORS를 정의 함) 은이 용어를 사용하지 않지만 이 기사에서는이를 &quot;간단한 요청&quot;이라고 합니다. &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS 프리 플라이트를&lt;/a&gt; 트리거하지 않는 요청 ( 소위 &quot;단순 요청&quot;) &lt;strong&gt;은 다음 조건을 모두 충족&lt;/strong&gt; 하는 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="9b7772fe71270600ccf3a3236874e99cde15c3a7" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server like sometimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about the progress, or allows to cancel it.</source>
          <target state="translated">나중에 처리하도록 예약 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 요청 과 같이 일부 요청은 서버에서 더 많은 시간이 필요할 수 있습니다 . 이 경우 응답은 작업이 예약되었음을 나타내는 페이지로 연결 되는 &lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (기타 참조) 리디렉션이며 결과적으로 진행 상황을 알리거나 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932d714aa9986fefde686199be3c38ba8d61e288" translate="yes" xml:space="preserve">
          <source>Some sections of this specification are illustrated with fragments of
   a non-normative RELAX NG Compact schema [&lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt;].  However, the text of
   this specification provides the definition of conformance.  Complete
   schemas appear in &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;.</source>
          <target state="translated">이 사양의 일부 섹션은 비표준 RELAX NG Compact 스키마 [ &lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt; ]의 단편으로 설명되어 있습니다. 그러나이 사양의 텍스트는 적합성의 정의를 제공합니다. 완전한 스키마가 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B에&lt;/a&gt; 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="bf1960a9dab8a69c52ce013a2615773d1727df49" translate="yes" xml:space="preserve">
          <source>Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.

   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   &quot;unspecified end-to-end revalidation&quot;, or when the client does have a
   local cached copy, in which case we call it &quot;specific end-to-end
   revalidation.&quot;

   The client can specify these three kinds of action using Cache-
   Control request directives:

   End-to-end reload
      The request includes a &quot;no-cache&quot; cache-control directive or, for
      compatibility with HTTP/1.0 clients, &quot;Pragma: no-cache&quot;. Field
      names MUST NOT be included with the no-cache directive in a
      request. The server MUST NOT use a cached copy when responding to
      such a request.

   Specific end-to-end revalidation
      The request includes a &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.

   Unspecified end-to-end revalidation
      The request includes &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating 

      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.

   max-age
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache MAY use either validator in making
      its own request without affecting semantic transparency.

      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.

      If a request includes the no-cache directive, it SHOULD NOT
      include min-fresh, max-stale, or max-age.

   only-if-cached
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache SHOULD either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request MAY be forwarded within that group of
      caches.

   must-revalidate
      Because a cache MAY be configured to ignore a server's specified
      expiration time, and because a client request MAY include a max-
      stale directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      MUST NOT use the entry after it becomes stale to respond to a 

      subsequent request without first revalidating it with the origin
      server. (I.e., the cache MUST do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)

      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache MUST obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it MUST generate a 504 (Gateway Timeout) response.

      Servers SHOULD send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients MUST NOT take any automated action that
      violates this directive, and MUST NOT automatically provide an
      unvalidated copy of the entity if revalidation fails.

      Although this is not recommended, user agents operating under
      severe connectivity constraints MAY violate this directive but, if
      so, MUST explicitly warn the user that an unvalidated response has
      been provided. The warning MUST be provided on each unvalidated
      access, and SHOULD require explicit user confirmation.

   proxy-revalidate
      The proxy-revalidate directive has the same meaning as the must-
      revalidate directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.</source>
          <target state="translated">때때로 사용자 에이전트는 캐시가 캐시 항목을 원래 서버로 재확인하거나 (원본 서버에 대한 경로를 따라 다음 캐시가 아닌) 원래 서버에서 캐시 항목을 다시로드하도록 요구하거나 요구할 수 있습니다. 캐시 또는 오리진 서버가 캐시 된 응답의 만료 시간을 과대 평가 한 경우 엔드 투 엔드 유효성 재확인이 필요할 수 있습니다. 캐시 항목이 어떤 이유로 손상된 경우 엔드 투 엔드 재로드가 필요할 수 있습니다. 엔드 투 엔드 재확인은 클라이언트에 자체 로컬 캐시 사본이 없거나 &quot;지정되지 않은 엔드 투 엔드 재확인&quot;이라고하거나 클라이언트에 로컬 캐시 사본이있을 때 요청 될 수 있습니다. 어떤 경우에는 &quot;특정 종단 간 재확인&quot;이라고합니다.클라이언트는 캐시 제어 요청 지시문을 사용하여 이러한 세 가지 조치를 지정할 수 있습니다. 엔드 투 엔드 재로드 요청에 &quot;비 캐시&quot;캐시 제어 지시문이 포함되어 있거나 HTTP / 1.0 클라이언트와의 호환성을 위해 &quot;Pragma : no- 은닉처&quot;. 요청시 필드 이름을 no-cache 지시문에 포함해서는 안됩니다 (MUST NOT). 서버는 그러한 요청에 응답 할 때 캐시 된 사본을 사용해서는 안됩니다. 특정 엔드-투-엔드 재 검증 요청에는 &quot;max-age = 0&quot;캐시 제어 지시문이 포함되는데,이 캐시 제어 지시문은 원래 캐시에 대한 경로를 따라 각 캐시가 다음 캐시 또는 서버로 자신의 항목을 재확인하도록합니다. 초기 요청에는 클라이언트의 현재 유효성 검사기와 함께 캐시 유효성 검사 조건이 포함됩니다.지정되지 않은 엔드-투-엔드 재확인 요청에 &quot;max-age = 0&quot;캐시 제어 지시문이 포함되어 있습니다.이 명령은 원 서버로의 경로를 따라 각 캐시가 다음 캐시 또는 서버로 자신의 항목을 재확인하도록합니다. 초기 요청에는 캐시 유효성 검사 조건이 포함되지 않습니다. 이 자원에 대한 캐시 항목을 보유하는 경로 (있는 경우)를 따르는 첫 번째 캐시에는 현재 유효성 검증 기와의 조건에 따른 캐시 유효성 검증이 포함됩니다. max-age max-age = 0 지시문을 사용하여 자체 캐시 항목을 재확인하도록 중간 캐시를 강제 실행하고 클라이언트가 요청에서 자체 유효성 검증기를 제공 한 경우 제공된 유효성 검증 기가 현재 저장된 유효성 검증기와 다를 수 있습니다. 캐시 항목과 함께. 이 경우캐시는 의미 투명성에 영향을 미치지 않고 자체 요청을 수행하는 데 유효성 검사기를 사용할 수 있습니다. 그러나 유효성 검사기를 선택하면 성능에 영향을 줄 수 있습니다. 가장 좋은 방법은 중간 캐시가 요청을 할 때 자체 유효성 검사기를 사용하는 것입니다. 서버가 304 (수정되지 않음)로 응답하면 캐시는 현재 확인 된 사본을 200 (OK) 응답으로 클라이언트에 반환 할 수 있습니다. 그러나 서버가 새 엔티티 및 캐시 유효성 검증기로 응답하는 경우 중간 캐시는 강력한 비교 기능을 사용하여 리턴 된 유효성 검증기를 클라이언트 요청에 제공된 유효성 검증기와 비교할 수 있습니다. 클라이언트의 유효성 검사기가 원본 서버의 유효성 검사기와 같으면 중간 캐시가 단순히 304 (수정되지 않음)를 반환합니다. 그렇지 않으면,200 (OK) 응답으로 새 엔터티를 반환합니다. 요청에 no-cache 지시문이 포함 된 경우 min-fresh, max-stale 또는 max-age를 포함해서는 안됩니다. 캐시 된 경우 네트워크 연결이 매우 나쁜 시간과 같은 경우에 따라 클라이언트는 캐시에 현재 저장된 응답 만 반환하고 원본 서버로 다시로드하거나 다시 확인하지 않기를 원할 수 있습니다. 이를 위해 클라이언트는 요청에 캐시 전용 지시문을 포함시킬 수 있습니다. 이 지시문을 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 캐시 된 항목을 사용하여 응답하거나 504 (게이트웨이 시간 초과) 상태로 응답해야합니다. 그러나 캐시 그룹이 내부 연결이 양호한 통합 시스템으로 작동하는 경우,이러한 요청은 해당 캐시 그룹 내에서 전달 될 수 있습니다. must-revalidate 캐시가 서버의 지정된 만료 시간을 무시하도록 구성 될 수 있고 클라이언트 요청에 max-stle 지시문 (유사한 영향을 미침)이 포함될 수 있기 때문에 프로토콜에는 원래 서버의 유효성을 다시 확인하는 메커니즘도 포함됩니다. 이후 사용시 캐시 항목 캐시가 수신 한 응답에 must-revalidate 지시문이있는 경우, 해당 캐시는 원래 서버로 먼저 유효성을 재확인하지 않고 후속 요청에 응답 할 수 없게 된 후에는 항목을 사용해서는 안됩니다. 즉, 원래 서버의 만기 또는 최대 연령 값만을 기반으로 캐시 된 응답이 오래되면 캐시는 반드시 엔드 투 엔드 유효성 재확인을 수행해야합니다.) 특정 프로토콜 기능에 대한 안정적인 작동을 지원하려면 반드시 재확인 명령이 필요합니다. 모든 상황에서 HTTP / 1.1 캐시는 must-revalidate 지시문을 준수해야합니다. 특히 캐시가 어떤 이유로 든 오리진 서버에 도달 할 수없는 경우 반드시 504 (게이트웨이 타임 아웃) 응답을 생성해야합니다. 서버는 엔터티에 대한 요청을 다시 확인하지 못하면 자동으로 실행되지 않는 금융 거래와 같은 잘못된 작업이 발생할 수있는 경우에만 반드시 다시 확인 지시문을 보내야합니다. 수령인은이 지침을 위반하는 자동화 된 조치를 취해서는 안되며, 유효성 재확인에 실패한 경우 유효하지 않은 엔티티의 사본을 자동으로 제공해서는 안됩니다. 권장하지는 않지만심각한 연결 제약 조건 하에서 작동하는 사용자 에이전트는이 지시문을 위반할 수 있지만, 유효하지 않은 응답이 제공되었음을 사용자에게 명시 적으로 경고해야합니다. 확인되지 않은 각 액세스마다 경고를 제공해야하며 명시적인 사용자 확인이 필요합니다. proxy-revalidate proxy-revalidate 지시문은 비공유 사용자 에이전트 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 지시문과 의미가 동일합니다. 인증 된 요청에 대한 응답에 사용되어 사용자 캐시가 응답을 다시 저장하지 않고도 저장하고 나중에 응답을 반환하도록 허용 할 수 있습니다 (사용자가 이미 한 번 인증 했으므로).각 사용자가 인증되었는지 확인하기 위해 매번 재확인하는 많은 사용자를 지원하는 프록시가 여전히 필요합니다. 이러한 인증 된 응답에는 캐시를 전혀 캐시하지 않으려면 공용 캐시 제어 지시문도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f0f13543920ce2519c90532c2d9391d9d564cd65" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource cannot be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used. Search engine robots don't memorize the new, temporary link. Temporary redirections are also used when creating, updating and deleting resources to present temporary progress pages.</source>
          <target state="translated">요청 된 리소스는 정식 위치에서 액세스 할 수 없지만 다른 곳에서는 액세스 할 수 있습니다. 이 경우 임시 리디렉션을 사용할 수 있습니다. 검색 엔진 로봇은 새로운 임시 링크를 기억하지 않습니다. 임시 진행 재 지정은 자원을 작성, 업데이트 및 삭제하여 임시 진행률 페이지를 표시 할 때도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f8875e5296a70a5c55485d7837e9b58660f6869" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and post an error message. Firefox will display:</source>
          <target state="translated">경우에 따라 서버에서이를 감지하지 못할 수도 있습니다. 리디렉션 루프는 전체 그림이없는 여러 서버에 분산 될 수 있습니다. 이 경우 브라우저는이를 감지하여 오류 메시지를 게시합니다. Firefox가 표시됩니다 :</target>
        </trans-unit>
        <trans-unit id="461f6249960b9f5e0adb518e83fe6728e5a1aa14" translate="yes" xml:space="preserve">
          <source>Source Map Revision 3 Proposal</source>
          <target state="translated">소스 맵 개정 3 제안</target>
        </trans-unit>
        <trans-unit id="48a37d9cb6f83141d7762830d6d9b21396138f77" translate="yes" xml:space="preserve">
          <source>Source code of the resource</source>
          <target state="translated">자원의 소스 코드</target>
        </trans-unit>
        <trans-unit id="eddadabaed64a1c9704679bf2c71541b37a9a200" translate="yes" xml:space="preserve">
          <source>SourceMap</source>
          <target state="translated">SourceMap</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="7c23b0d99698b57c5cb21fafcb8a8daf127386c6" translate="yes" xml:space="preserve">
          <source>Speaker</source>
          <target state="translated">Speaker</target>
        </trans-unit>
        <trans-unit id="65fa5e6b8d558cde85a3a07a4e444c679377961e" translate="yes" xml:space="preserve">
          <source>Special redirections</source>
          <target state="translated">특수 리디렉션</target>
        </trans-unit>
        <trans-unit id="1432da84229d762b613e72e68e00057a594449c8" translate="yes" xml:space="preserve">
          <source>Specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; by the client (&lt;em&gt;server-driven negotiation&lt;/em&gt; or &lt;em&gt;proactive negotiation&lt;/em&gt;), which is the standard way of negotiating a specific kind of resource.</source>
          <target state="translated">특정 종류의 리소스를 협상하는 표준 방법 인 클라이언트의 특정 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; ( &lt;em&gt;서버 중심 협상&lt;/em&gt; 또는 &lt;em&gt;사전 협상&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="1ccf5d25dfedda0749e3abb6685b56a5fed8013a" translate="yes" xml:space="preserve">
          <source>Specification</source>
          <target state="translated">Specification</target>
        </trans-unit>
        <trans-unit id="0c709f9886c34419d95252da6707fd3dc704a220" translate="yes" xml:space="preserve">
          <source>Specifications</source>
          <target state="translated">Specifications</target>
        </trans-unit>
        <trans-unit id="30d32085a077fd1f486b08c98f4d346c5a6b17fc" translate="yes" xml:space="preserve">
          <source>Specifications and RFCs:</source>
          <target state="translated">사양 및 RFC :</target>
        </trans-unit>
        <trans-unit id="07b2551feb0b78f2ae3f0674493bd2ba4c495576" translate="yes" xml:space="preserve">
          <source>Specifies GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.</source>
          <target state="translated">GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c58c8c11265fc2163fd1c23b0043a730d6d564bd" translate="yes" xml:space="preserve">
          <source>Specifies PATCH.</source>
          <target state="translated">PATCH를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="99d3f27b2e59be204c52c5c9fc1e3fd32e5425f2" translate="yes" xml:space="preserve">
          <source>Specifies a URI that may see the timing resources. You can specify multiple origins, separated by commas.</source>
          <target state="translated">타이밍 자원을 볼 수있는 URI를 지정합니다. 쉼표로 구분하여 여러 원점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dc214da21e1ecdb977da6e15c1694d398e424b" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified.</source>
          <target state="translated">원점을 지정합니다. 단일 원점 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08522ebb29d8c09aa8e3393f359476bbe00317a0" translate="yes" xml:space="preserve">
          <source>Specifies directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">요청 및 응답 모두에서 캐싱 메커니즘에 대한 지시문을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ac472e4fe7931170e92aa9f011df74fb8e68f3a" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy-file (XML) is allowed. The file may define a policy to grant web clients, such as Adobe Flash Player or Adobe Acrobat (e.g. PDF), permission to handle data across domains.</source>
          <target state="translated">도메인 간 정책 파일 (XML)이 허용되는지 여부를 지정합니다. 이 파일은 Adobe Flash Player 또는 Adobe Acrobat (예 : PDF)과 같은 웹 클라이언트에 도메인 간 데이터를 처리 할 수있는 권한을 부여하는 정책을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">서버에서 사용하도록 요청할 하나 이상의 프로토콜 레벨 WebSocket 확장을 지정합니다. 요청에 둘 이상의 &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; 헤더를 사용하는 것이 허용됩니다. 결과는 나열된 헤더를 모두 하나의 헤더에 포함한 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;자원 타이밍 API의&lt;/a&gt; 기능을 통해 검색된 속성 값을 볼 수있는 출처를 지정합니다. 그렇지 않으면 교차 출처 제한으로 인해 0으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">사용자 에이전트가 Expect-CT 실패를보고해야하는 URI를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">클라이언트가 사용하려는 WebSocket 프로토콜 버전을 지정하여 서버가 해당 버전이 지원되는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">서버의 도메인 이름 (가상 호스팅 용) 및 서버가 수신중인 TCP 포트 번호 (선택 사항)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">리소스가 최신 상태로 간주되는 최대 시간을 지정합니다. &lt;code&gt;Expires&lt;/code&gt; 와 달리이 지시문은 요청 시간과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답으로 리소스에 액세스 할 때 허용되는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">사용자 에이전트가 메시지를 수신 한 호스트를 알려진 Expect-CT 호스트로 간주해야하는 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더 필드를 수신 한 후의 시간 (초)을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">엔터티를 사용자에게 안전하게 전송하는 데 사용되는 인코딩 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">사용자 에이전트가 수락 할 전송 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">쿠키가 전송 될 호스트를 지정합니다. 지정하지 않으면 기본적으로 현재 문서 위치의 호스트 부분 (하위 도메인 제외)으로 설정됩니다. 이전 사양과 달리 도메인 이름의 선행 점은 무시됩니다. 도메인을 지정하면 하위 도메인이 항상 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; 연결에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">JavaScript의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">스타일 시트에 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">유효한 응용 프로그램 매니페스트 파일 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">유효한 이미지 및 파비콘 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">프리 페치 또는 사전 렌더링 할 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">레거시 문서 모드 지정 *</target>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">정책 지정</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">클라이언트가 HTTP 요청에서 사용할 수있는 표준 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문.</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">HTTP 응답에서 서버가 사용할 수있는 표준 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문.</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">표준화 된 방법은 일반적입니다. 즉, 하나의 특정 미디어 유형, 종류의 리소스 또는 응용 프로그램뿐만 아니라 모든 리소스에 적용 할 수 있습니다. 이와 같이, 직교 기술은 직교 사양을 가질 가치가 있기 때문에 단일 방법 또는 데이터 형식에 국한되지 않은 문서에 새로운 방법을 등록하는 것이 바람직하다. 메시지 파싱 이후 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230]의 3.3 절&lt;/a&gt;)는 메소드 의미론 (HEAD에 대한 응답 제외)과 독립적이어야하며, 새로운 메소드의 정의는 구문 분석 알고리즘을 변경하거나 요청 또는 응답 메시지에서 메시지 본문의 존재를 금지 할 수 없습니다. 새 메소드의 정의는 값이 &quot;0&quot;인 Content-Length 헤더 필드를 요구하여 길이가 0 인 메시지 본문 만 허용되도록 지정할 수 있습니다. 새로운 분석법 정의는 안전한지 ( &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; ), dem 등성 ( &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ), 캐시 가능 ( &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; ) 여부를 표시해야합니다.), 요청에 존재하는 경우 페이로드 본문과 연관되는 의미 및 메소드가 헤더 필드 또는 상태 코드 의미를 개선하는 것. 새로운 방법이 캐시 가능한 경우, 그 정의는 캐시가 어떻게 그리고 어떤 조건에서 응답을 저장하고 후속 요청을 만족시키는 데 사용할 수 있는지를 설명해야합니다. 새로운 방법은 조건부로 작성 될 수 있는지 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; ), 그렇다면 조건이 거짓 일 때 서버가 어떻게 응답하는지 설명해야한다. 마찬가지로, 새로운 방법이 부분 응답 의미론을 사용할 수있는 경우 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), 이것도 문서화해야합니다. 참고 : 접두어가 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ]에 의해 지정된 의미가있는 것으로 잘못 해석 될 수 있으므로 &quot;M-&quot;으로 시작하는 메소드 이름을 정의하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">출발 선</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">Chrome 61부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">Firefox 59부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">Opera 48부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">버전 6부터 사용자는 숨겨진 기본 설정으로 Android 용 GeckoView 기반 Focus를 사용하도록 선택할 수 있습니다. GeckoView UA 문자열을 사용하여 Gecko 호환성을 알립니다.</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">Chrome 52 및 Firefox 52부터는 안전하지 않은 사이트 ( &lt;code&gt;http:&lt;/code&gt; :)가 더 이상 &quot;보안&quot;지시문으로 쿠키를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">상태 코드 정의 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">상태 표시 줄</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. Abstract AtomPub (Atom Publishing Protocol)는 웹 리소스를 게시하고 편집하기위한 응용 프로그램 수준 프로토콜입니다. 프로토콜은 Atom 형식 표현의 HTTP 전송을 기반으로합니다. Atom 형식은 Atom Syndication Format에 문서화되어 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 표기법 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . XML 관련 규칙 &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt; . 정보 항목 참조 &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt; . RELAX NG 스키마 &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt; . &quot;xml : base&quot;및 &quot;xml : lang&quot;사용 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 용어 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 프로토콜 모델 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 아이디와 이름 지정 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 문서 및 자원 분류 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 컨트롤과 퍼블리싱 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 클라이언트 구현 고려 사항 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . 프로토콜 운영 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . 서비스 문서 검색 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 컬렉션 멤버 나열 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 리소스 생성 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. 자원 편집 &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt; . 리소스 검색 &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt; . 자원 편집 &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt; . 자원 삭제 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . HTTP 응답 코드 사용 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 프로토콜 문서 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 문서 유형 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 문서 확장 성 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 카테고리 문서 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 예 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 요소 정의 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; . &quot;app : categories&quot;요소 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 서비스 문서 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 작업 공간 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . 예 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. 요소 정의 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . &quot;app : service&quot;요소 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . &quot;app : workspace&quot;요소 &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt; . &quot;app : collection&quot;요소 &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt; . &quot;app : accept&quot;요소 &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt; . Atom Feed Documents에서의 사용법 &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt; . &quot;app : categories&quot;요소 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 자원 작성 및 편집 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . 멤버 URI &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . POST와 자원 작성 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . 예 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . PUT을 사용하여 리소스 편집 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . DELETE를 사용하여 리소스 삭제&lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . 캐싱 및 엔터티 태그 &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt; . 예 ................................................................ &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 미디어 리소스 및 미디어 링크 항목 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . 실시 예 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . 슬러그 헤더 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . 슬러그 헤더 구문 &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt; . 실시 예 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 컬렉션 나열 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . 컬렉션 부분 목록 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . &quot;app : edited&quot;요소 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . 원자 형식 링크 관계 확장 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . &quot;편집&quot;링크 관계 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . &quot;편집 미디어&quot;링크 관계 &lt;a href=&quot;#section-12&quot;&gt;도 12&lt;/a&gt; . 원자 형식 유형 매개 변수 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . &quot;type&quot;매개 변수 &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt; . 적합성 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . 아톰 퍼블리싱 컨트롤 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . &quot;app : control&quot;요소 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; . &quot;app : draft&quot;요소 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . Atom 게시 프로토콜 보안 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; . 서비스 거부 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; . 리플레이 공격 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; . 스푸핑 공격 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; . 링크 된 리소스 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; . 디지털 서명 및 암호화 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; . URI 및 IRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; . 코드 삽입 및 크로스 사이트 스크립팅 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt; . 'application / atomcat + xml'의 컨텐츠 유형 등록 ..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt; . 'application / atomsvc ​​+ xml'의 컨텐츠 유형 등록 ..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt; . 'SLUG'에 대한 헤더 필드 등록 &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt; . 링크 관계 등록 &quot;편집&quot; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt; . 링크 관계 등록 &quot;편집 매체&quot; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt; . 원자 형식 매체 유형 매개 변수 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . 참고 문헌 &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt; . 유익한 참고 자료 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt;. 참여자 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . RELAX NG 컴팩트 스키마 ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. 저작권 공지 저작권 (C) IETF 트러스트 (2007). WebDAV (Web Distributed Authoring and Versioning)는 자원 등록 정보 관리, 자원 콜렉션 작성 및 관리, URL 네임 스페이스 조작 및 자원 잠금 (충돌)을 위해 HTTP / 1.1에 부가되는 일련의 메소드, 헤더 및 컨텐츠 유형으로 구성됩니다. 기피). &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;1999 년 2 월에 발표 된이 사양 은 상호 운용성 경험으로 인해 약간 수정 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 을 더 이상 사용하지 않습니다 . 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 표기법 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 용어 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 자원 등록 정보의 데이터 모델 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 자원 속성 모델 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 등록 정보 및 HTTP 헤더 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 속성 값 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . 예-내용이 혼합 된 속성 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 속성 이름 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; . 소스 리소스 및 출력 리소스 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. 웹 자료 모음 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . HTTP URL 네임 스페이스 모델 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 수집 자료 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 잠금 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 모델 잠금 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 배타적 잠금과 공유 잠금 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . 필요한 지원 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . 잠금 생성기 및 권한 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . 잠금 토큰 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . 잠금 시간 종료 &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt; . 잠금 기능 발견 &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt; . 활성 잠금 발견 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 쓰기 잠금 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 쓰기 잠금 및 속성 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 손실 된 업데이트 방지 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. 쓰기 잠금 및 매핑되지 않은 URL &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt; . 쓰기 잠금 및 모음 &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt; . 쓰기 잠금 및 If 요청 헤더 &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt; . 예-쓰기 잠금 및 복사 7.5.2. 예-잠긴 컬렉션의 멤버 삭제 &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt; . 쓰기 잠금 및 복사 / 이동 &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt; . 쓰기 잠금 새로 고침 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 일반적인 요청 및 응답 처리 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 에러 처리의 우선 순위 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . XML 사용 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . URL 처리 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . 예-올바른 URL 처리 &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. 요청에 필요한 기관 &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt; . WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt; 에서 사용하기위한 HTTP 헤더 . ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt; . 에러 응답 바디 포함 &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt; . 캐시 유효성 검사기에 대한 네임 스페이스 작업의 영향 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 분산 저작을위한 HTTP 메소드 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . PROPFIND 방법 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; . PROPFIND 상태 코드 .............................. &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; . 'propstat'요소에 사용하기위한 상태 코드 &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt; . 예-명명 된 속성 검색 9.1.4. 예- 'propname'을 사용하여 모든 속성 이름 검색 &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. 예-소위 'allprop'사용 &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt; . 예- 'include'와 함께 'allprop'사용 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . PROPPATCH 방법 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . 'propstat'요소에 사용하기위한 상태 코드 &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt; . 예-PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . MKCOL 방법 &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt; . MKCOL 상태 코드 &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt; . 예-MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . 컬렉션 헤드 가져 오기 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . 컬렉션을위한 POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 삭제 요구 사항 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . 컬렉션 삭제 &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt; . 예 - DELETE &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT 요구 사항 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . 비 수집 자원에 대한 PUT &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt; . 컬렉션을위한 PUT &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; . 복사 방법 &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt; . 비 수집 자료의 복사 &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt; . 재산을위한 사본 &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt; . 컬렉션 복사 &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt; . 복사 및 대상 리소스 덮어 쓰기 &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt; . 상태 코드 &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt; . 예-덮어 쓰기를 &lt;a href=&quot;#section-9.8.7&quot;&gt;사용한&lt;/a&gt; 복사 9.8.7 . 예-덮어 쓰기 &lt;a href=&quot;#section-9.8.8&quot;&gt;없는&lt;/a&gt; 복사 9.8.8 . 예-컬렉션 복사 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. 이동 방법 &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt; . 등록 정보 이동 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; . 컬렉션을위한 이동 &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt; . MOVE 및 덮어 쓰기 헤더 &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt; . 상태 코드 &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt; . 예-비 컬렉션의 이동 &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt; . 예-컬렉션의 이동 &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt; . 잠금 방법 &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt; . 기존 자원에 대한 잠금 작성 &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt; . 상쾌한 잠금 &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt; . 깊이와 잠금 &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt; . 매핑되지 않은 URL 잠금 &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. 잠금 호환성 표 &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt; . 잠금 응답 &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt; . 예-단순 잠금 요청 &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt; . 예-쓰기 잠금 새로 고침 &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt; . 예-다중 리소스 잠금 요청 &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt; . 잠금 해제 방법 &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt; . 상태 코드 .............................................. &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt; . 예-잠금 해제 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 분산 작성을위한 HTTP 헤더 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . DAV 헤더 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . 깊이 헤더 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; . 대상 헤더 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; . 헤더 인 경우 &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; . 목적 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; . 구문 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; . 목록 평가 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; . 일치하는 토큰 및 ETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; . 헤더 및 비 DAV 인식 프록시의 경우 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; . 예-태그없는 생산 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; . 예-태그없는 생산에 &quot;Not&quot;사용 10.4.8. 예-조건을 항상 참으로 평가하기 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; . 예-COPY 10.4.10의 헤더 인 경우 태그가 지정된 목록 예-수집 잠금 장치와 잠금 토큰 일치 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; . 예-매핑되지 않은 URL에서 ETag 일치 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; . 잠금 토큰 헤더 &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt; . 헤더 덮어 쓰기 &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt; . 타임 아웃 요청 헤더 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . HTTP / 1.1에 대한 상태 코드 확장 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . 207 다중 상태 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . 422 처리 할 수없는 엔티티 &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt; . 423 잠김 &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt; . 424 종속성 실패 &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt; . 507 저장 공간 부족 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; . HTTP 상태 코드 사용 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . 412 사전 조건 실패 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; . 414 요청 URI가 너무 길다 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . 다중 상태 응답 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . 응답 헤더 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. 리디렉션 된 자식 리소스 처리 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; . 내부 상태 코드 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . XML 요소 정의 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; . activelock XML 요소 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; . allprop XML 요소 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; . 컬렉션 XML 요소 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; . 깊이 XML 요소 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; . 오류 XML 요소 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; . 배타적 XML 요소 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; . href XML 요소 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; . XML 요소가 포함 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; . 위치 XML 요소 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; . lockentry XML 요소 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; . lockinfo XML 요소 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML 요소 ............................................. &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; . lockscope XML 요소 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; . 락토 큰 XML 요소 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; . 록 타입 XML 요소 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; . 다중 상태 XML 요소 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; . 소유자 XML 요소 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; . prop XML 요소 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; . propertyupdate XML 요소 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; . propfind XML 요소 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; . propname XML 요소 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; . propstat XML 요소 &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; . XML 요소 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; 제거 . 응답 XML 요소 &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML 요소 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . XML 요소 설정 &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; . 공유 XML 요소 &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; . 상태 XML 요소 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; . 타임 아웃 XML 요소 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; . XML 요소 작성 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . DAV 속성 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . 전제 조건 / 사후 조건 XML 요소 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . DAV의 XML 확장 성 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; . DAV 준수 클래스 &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt; . 클래스 1 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt; . 클래스 2 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; . 종류 3 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; . 국제화 고려 사항 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt; . 클라이언트 인증 &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt; . 서비스 거부 &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt; . 모호성을 통한 보안 &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt; . 잠금 장치에 연결된 개인 정보 문제 &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt; . 속성에 연결된 개인 정보 문제 &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt; . XML 엔티티의 의미 &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt; . 잠금 토큰과 관련된 위험 &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt; . 악성 콘텐츠 호스팅 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt; . 새로운 URI 스킴 &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt; . XML 네임 스페이스 &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt; . 메시지 헤더 필드 &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt; . DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. 깊이 &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt; . 목적지 &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt; . 만약 &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt; . 잠금 토큰 &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6을&lt;/a&gt; . 덮어 쓰기 &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt; . 타임 아웃 &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt; . HTTP 상태 코드 &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt; . 승인 ............................................. &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt; . 이 규격에 기여한 사람 &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518의&lt;/a&gt; 저자 &lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . XML 요소 처리에 대한 참고 사항 &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. 빈 XML 요소에 대한 참고 사항 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt; . 잘못된 XML 처리에 대한 참고 사항 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt; . 예-XML 구문 오류 &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt; . 예 - 예기치 않은 XML 요소 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . HTTP 클라이언트 호환성에 대한 참고 사항 &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 'opaquelocktoken'제도와 URI를 &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; . 락 널 리소스 &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt; . 자원 만들기 LOCK을 사용하여 클라이언트에 대한 지침 &lt;a href=&quot;#appendix-E&quot;&gt;은 부록 E를&lt;/a&gt; . 인증하기를 희망 클라이언트에 대한 지침 &lt;a href=&quot;#appendix-F&quot;&gt;부록 F&lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt; 의 변경 사항 요약 . 클라이언트 및 서버 구현 모두에 대한 변경 사항 &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. 서버 구현에 대한 변경 사항 &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt; . 기타 변경 사항 ............................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A 이하의 응답 상태 &lt;code&gt;Location&lt;/code&gt; 헤더 : &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. 저작권 공지 저작권 (C) The Internet Society (1999). 판권 소유. Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 미디어 정보 시스템을위한 응용 프로그램 수준 프로토콜입니다. 이는 네임 서버 및 분산 객체 관리 시스템과 같은 하이퍼 텍스트에 대한 사용을 넘어서 요청 방법의 확장을 통해 많은 작업에 사용할 수있는 일반적인 상태 비 저장 프로토콜입니다.오류 코드 및 헤더 [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. HTTP의 특징은 데이터 표현의 타이핑 및 협상으로, 전송되는 데이터와 독립적으로 시스템을 구축 할 수 있습니다. HTTP는 1990 년 이후 전세계 웹 글로벌 정보 이니셔티브에 의해 사용되어 왔습니다.이 사양은 &quot;HTTP / 1.1&quot;이라는 프로토콜을 정의하며 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068에&lt;/a&gt; 대한 업데이트입니다 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; 목적 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; 요구 사항 &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; 용어 &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; 전반적인 운영 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; 표기법 및 일반 문법 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 증강 된 BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 기본 규칙 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; 프로토콜 매개 변수 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTP 버전 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; 통일 리소스 식별자 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; 일반 구문 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; http URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; URI 비교 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 날짜 / 시간 형식 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 전체 날짜 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; 델타 초 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; 문자 집합 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; 누락 된 문자 집합 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; 내용 코딩 &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; 전송 코딩 &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt; 코딩 청크 분할 전송 &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; 미디어 유형 &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; 정규화 및 텍스트 기본값 &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2 멀티&lt;/a&gt; 파트 유형 &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; 제품 토큰 &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; 품질 값 &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; 언어 태그 &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; 엔티티 태그 &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; 범위 단위 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTP 메시지 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; 메시지 유형 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; 메시지 헤더 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; 메시지 본문 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; 메시지 길이 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; 일반 헤더 필드 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 요청 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; 요청 라인 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; 방법 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; 요청 URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 요청으로 식별 된 리소스 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; 요청 헤더 필드 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; 응답 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; 상태 행 &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; 상태 코드 및 이유 문구 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 응답 헤더 필드 ............ ................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; 엔터티 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 엔터티 헤더 필드 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; 엔터티 본문 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; 유형 &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; 엔터티 길이 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; 연결 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; 영구 연결 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; 목적 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; 전체 작업 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 .삼&lt;/a&gt; 프록시 서버 &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; 실제 고려 사항 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; 메시지 전송 요구 사항 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; 영구 연결 및 흐름 제어 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; 오류 상태 메시지에 대한 연결 모니터링 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; 100 (계속) 상태 사용 &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; 서버가 연결을 조기에 종료하면 클라이언트 동작. .50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; 방법 정의 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 안전 및 등전위 방법 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; 안전한 방법 &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; 등전위 방법 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; 옵션 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; GET &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; 상태 코드 정의 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 정보 1xx &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100 계속 &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101 스위칭 프로토콜 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; 성공 2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201 생성됨 &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202 허용 &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203 신뢰할 수없는 정보 &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204 콘텐츠 없음 &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205 콘텐츠 재설정 &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt; 206 일부 내용 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; 리디렉션 3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300 객관식 선택 &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301 영구적으로 이동 됨 &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302 발견 &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303 기타 &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304 참조 수정되지 않음 &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt; 305 프록시 사용 &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306 (미사용) .. ........................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307 임시 리디렉션 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; 클라이언트 오류 4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400 잘못된 요청 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401 무단 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402 지불 필요 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403 금지됨 &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404 찾을 수 없음 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; 405 허용되지 않는 방법 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; 406 허용 되지 않음 &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407 프록시 인증 필요 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; 408 요청 시간 초과 &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; 409 충돌 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410 사라짐 &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411 길이 필요 &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412 전제 조건 실패 &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413 요청 엔티티가 너무 큼 &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt; 414 요청 URI가 너무 &lt;a href=&quot;#section-10.4.16&quot;&gt;깁니다 10.4.16&lt;/a&gt; 415 지원되지 않는 미디어 유형 &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416 요청 된 범위를 충족시킬 수 없음 &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; 417 예상 실패 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; 서버 오류 5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; 500 내부 서버 오류 &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501 구현되지 않음 &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt; 502 불량 게이트웨이 &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; 503 서비스를 사용할 수 없음 &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt; 504 게이트웨이 시간 초과 &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; 505 HTTP 버전이 지원되지 않음 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; 액세스 인증 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; 내용 협상 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; 서버 중심 협상 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; 에이전트 중심 협상 &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; 투명 협상 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; HTTP 캐싱 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; 캐시 정확성 &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt; 경고 &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; 캐시 제어 메커니즘 &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt; 명시 적 사용자 에이전트 경고 &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; 규칙 및 경고 예외 &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; 클라이언트 제어 동작 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 만료 모델 &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; 서버 지정 만료 &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; 휴리스틱 만료 &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; 연령 계산 &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; 만료 계산 &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; 명확성 만료 값 &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; 여러 응답 명확화 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; 유효성 검사 모델 &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; 최종 수정 날짜 ...................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; 엔터티 태그 캐시 유효성 검사기 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 약하고 강력한 유효성 검사기 13.3.4 엔터티 태그 및 최종 수정 날짜 사용시기 규칙 89 &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt; 유효성 검사 조건 없음 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; 응답 캐시 가능성 &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; 캐시에서 응답 구성 &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt; 종단 간 및 &lt;a href=&quot;#section-13.5.2&quot;&gt;홉별&lt;/a&gt; 헤더 13.5.2 수정할 수없는 헤더 &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt; 헤더 결합 &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; 바이트 범위 결합 &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; 협상 된 응답 캐싱 &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt; 공유 및 비 공유 캐시 &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; 에러 또는 불완전한 응답 캐시 동작 &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt; 부작용의 GET 및 HEAD &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt; 업데이트 또는 삭제 후 무효 &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt; 쓰기를 통해 필수 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; 캐시 교체 &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; 히스토리 목록 &lt;a href=&quot;#section-14&quot;&gt;(14)&lt;/a&gt; 헤더 필드 정의가 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; 수락 &lt;a href=&quot;#section-14.2&quot;&gt;14.2을&lt;/a&gt; 수락-캐릭터 세트 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; 용납하는 인코딩 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; 수용 언어 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; 수용 범위 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; 연령 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; 허용 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; 권한 부여 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; 캐시 제어 &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1은&lt;/a&gt; 캐시 할 무엇 &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; 캐시로 저장 될 수 무엇 &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 기본 만료 메커니즘의 수정 &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt; 캐시 재확인하고 다시로드 컨트롤 &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt; 무 변환 지침 &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; 캐시 제어 확장 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; 연결 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; 컨텐트 인코딩 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; 컨텐트 언어 &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; 컨텐트 길이 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; 컨텐트 위치 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; 컨텐트 MD5 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; Content-Range &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; Content-Type &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; Date &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; Clockless Origin Server 작동 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ETag &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; 예상 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; 만료 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; From .......................... ........................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 호스트 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If-None-Match &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; 수정되지 않은 경우 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; 마지막으로 수정 한 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; 위치 &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; 맥스는 감 &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt; 에서 Pragma &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt; 프록시 인증합니다 &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt; 프록시 인증 &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; 범위 &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; 바이트 범위 &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; 범위 검색이 요청 &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt; 리퍼러 &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt; 재시도 - 후 &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt; 서버 &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt; 예고편 &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; 전송 인코딩 &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt; 업그레이드 &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt; 사용자 에이전트 &lt;a href=&quot;#section-14.44&quot;&gt;14.44가&lt;/a&gt; 다름 &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; 통해 &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; 경고 &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW 인증 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; 보안 고려 사항 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; 개인 정보 &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; 서버 로그 정보의 남용 &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt; 중요한 정보의 전송 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; URI의 민감한 정보 인코딩 &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; 헤더를 수락하기 위해 연결된 개인 정보 문제 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; 파일 및 경로 기반 공격 이름 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; DNS 스푸핑 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; 위치 헤더 및 스푸핑 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; 콘텐츠 처리 문제 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; 인증 자격 증명 및 유휴 클라이언트 &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; 프록시 및 캐싱 &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; 프록시에 대한 서비스 거부 공격 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; 승인 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; 참조 &lt;a href=&quot;#section-18&quot;&gt;17&lt;/a&gt; 작성자 주소 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; 부록 &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; 인터넷 미디어 유형 메시지 / http 및 응용 프로그램 / http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; 인터넷 미디어 유형 멀티 파트 / 바이트 범위 &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; 허용 응용 프로그램 &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; HTTP 엔티티와 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC의&lt;/a&gt; 차이점 2045 엔터티 .... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME 버전 &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; 정식 형식으로 변환 &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt; 날짜 형식 변환 &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; 콘텐츠 인코딩의 소개 &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; 아니오 내용 전송 인코딩 &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt; 전송 인코딩 소개 &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTML 및 라인 길이 제한 &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; 추가 기능 &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; 내용 - 처리 &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; 이전 버전과의 호환성 &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1을&lt;/a&gt; HTTP / 1.0의 변경 사항 &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; HTTP / 1.0 영구 연결과의 호환성 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068의&lt;/a&gt; 변경 사항 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; 색인 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; 전체 저작권 정보</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">캐시에 응답 저장 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">엄격한 전송 보안은이 문제를 해결합니다. HTTPS를 사용하여 은행 웹 사이트에 한 번 액세스하고 은행 웹 사이트가 Strict Transport Security를 ​​사용하는 경우 브라우저는 HTTPS 만 자동으로 사용하므로 해커가 이러한 종류의 중간자 (man-in-the-middle)를 수행하지 못하게됩니다. 공격.</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">강력한 검증</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">강력한 유효성 검사는 리소스가 비교되는 리소스와 동일하다는 것을 보증합니다. 일부 조건부 헤더의 경우 필수이고 다른 조건부 헤더의 경우 기본값입니다. 강력한 유효성 검사는 매우 엄격하며 서버 수준에서 보장하기 어려울 수 있지만 때로는 성능 저하로 인해 데이터 손실을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">서버 응답의 구조</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">서브넷 기반 결정</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">하위 자원 무결성</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">하위 자원 무결성 &lt;br/&gt;&lt;small&gt;해당 사양에서 '요구-스리-포'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">후속 행은 HTTP 헤더를 나타내며 서버에 어떤 유형의 데이터가 적합한 지 (예 : 언어, MIME 유형) 또는 그 동작을 변경하는 다른 데이터 (예 : 이미 캐시 된 경우 응답을 보내지 않음)에 대한 정보를 제공합니다. 이 HTTP 헤더는 빈 줄로 끝나는 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">후속 행은 특정 HTTP 헤더를 나타내며, 클라이언트에게 전송 된 데이터에 대한 정보 (예 : 유형, 데이터 크기, 사용 된 압축 알고리즘, 캐싱에 대한 힌트)를 제공합니다. 클라이언트 요청에 대한 HTTP 헤더 블록과 마찬가지로이 HTTP 헤더는 빈 줄로 끝나는 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">다음 섹션에서는 시나리오에 대해 설명하고 사용 된 HTTP 헤더를 분석합니다.</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가이 헤더에 나열된 각각과 다른 경우에 성공합니다 . 기본적으로 etag 앞에 &lt;code&gt;'W/'&lt;/code&gt; 가 붙지 않으면 강력한 유효성 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가이 헤더에 나열된 것과 동일 하면 성공합니다 . 기본적으로 etag 앞에 &lt;code&gt;'W/'&lt;/code&gt; 가 붙지 않으면 강력한 유효성 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 날짜가이 헤더에 제공된 것보다 최신 인 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 날짜가이 헤더에 제공된 날짜보다 오래되었거나 같은 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">성공적인 응답에는 신체가 있습니다</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">성공적인 응답</target>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">검색 요청의 성공적인 결과 : HTML 문서, 이미지 또는 파일과 같은 자원을 포함하는 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청에 대한 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; (OK) 응답 .</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">성공적인 웹 페이지 응답 :</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">RFC6454에 정의 된대로 &lt;code&gt;Origin&lt;/code&gt; 헤더를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">클라이언트와 서버 모두 에서 &lt;code&gt;Retry-After&lt;/code&gt; 헤더에 대한 지원 이 여전히 일치하지 않습니다. 그러나 Googlebot과 같은 일부 크롤러 및 스파이더는 &lt;code&gt;Retry-After&lt;/code&gt; 헤더를 존중합니다 . 다운 타임이 끝날 때 검색 엔진이 사이트 색인을 유지하도록 &lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt; (Service Unavailable) 응답 과 함께 전송하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; 를&lt;/a&gt; 지원 하면 식별 및 지정된 리소스의 위치를 ​​분리 할 수있어보다 스마트 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; 캐싱 메커니즘이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">스위칭 프로토콜은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSocket&lt;/a&gt; 과 함께 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">동기 XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">동기 XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">동기식 스크립트</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">URI (Uniform Resource Identifier)의 구문</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">서버가 청취중인 TCP 포트 번호</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">서버가 청취중인 TCP 포트 번호 포트가 제공되지 않으면 요청 된 서비스의 기본 포트 (예 : HTTP URL의 경우 &quot;80&quot;)가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">TE (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">트랙 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE : 메시지 본문에 서버가 수신 한 요청 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">WebView의 태블릿 버전은 모바일을 미러링하지만 &lt;code&gt;Mobile&lt;/code&gt; 토큰 은 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">태그가 지정된 이미지 파일 형식 (TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">태그 및 요약</target>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">&lt;code&gt;max-age&lt;/code&gt; 또는 &lt;code&gt;Expires&lt;/code&gt; 헤더 보다 우선 하지만 공유 캐시 (예 : 프록시)에만 적용되며 개인 캐시에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">테이프 아카이브 (TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">캐싱 작업의 대상</target>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">표준 URL에 대한 기술</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">로드중인 페이지가 큰 할당을 수행하려고한다는 것을 브라우저에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">사용자 이름과 비밀번호를 제출할 때 클라이언트에게 서버가 선호하는 인코딩 체계를 알려줍니다. 허용되는 유일한 값은 대소 문자를 구분하지 않는 문자열 &quot;UTF-8&quot;입니다. 이것은 영역 문자열의 인코딩과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">임시 리디렉션</target>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">긴 요청에 대한 임시 응답</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">안전하지 않은 요청에 대한 임시 응답</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">정책 테스트</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">텍스트 (일반적으로 ASCII 또는 ISO 8859- &lt;em&gt;n&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">확장 성 (새 헤더 또는 메소드 작성이 용이함)으로 인해 HTTP / 1.1 프로토콜이 두 가지 개정으로 수정 된 경우에도 1999 년 6 월에 발행 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 및 2014 년 6 월에 발행 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; 시리즈 HTTP / 2 릴리스에서이 프로토콜은 15 년 이상 동안 매우 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 헤더 덕분에 동일한 IP 주소에서 다른 도메인을 호스트 할 수있어 서버 배치가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">이렇게하면 보안 사이트에서 안전하지 않은 요청을 계속 업그레이드 할 수 있지만 유일한 모니터링 정책을 위반하고 안전하지 않은 리소스를 엔드 포인트에보고합니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">&quot;Accept&quot;헤더 필드는 사용자 에이전트가 사용 가능한 응답 매체 유형을 지정하는 데 사용할 수 있습니다. 수락 헤더 필드는 인라인 이미지에 대한 요청과 같이 요청이 원하는 유형의 작은 세트로 특별히 제한됨을 나타내는 데 사용될 수 있습니다. 수락 = # (미디어 범위 [accept-params]) 미디어 범위 = ( &quot;* / *&quot;/ (유형 &quot;/&quot; &quot;*&quot;) / (유형 &quot;/&quot;하위 유형)) * (OWS &quot;;&quot;OWS 매개 변수 ) accept-params = weight * (accept-ext) accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot;(token / quoted-string)] 별표 &quot;*&quot;문자는 미디어 유형을 범위로 그룹화하는 데 사용되며, &quot;* / *&quot;는 모든 미디어 유형 및 &quot;type / *&quot;을 나타냅니다.해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위에는 해당 범위에 적용 가능한 미디어 유형 매개 변수가 포함될 수 있습니다. 각 용지 범위 뒤에는 0 또는 그 이상의 적용 가능한 용지 유형 매개 변수 (예 : 문자 세트)가있을 수 있습니다. 이는 상대 중량을 나타내는 선택적 &quot;q&quot;매개 변수 (&lt;a href=&quot;#section-5.3.1&quot;&gt;섹션 5.3.1&lt;/a&gt;)를 누른 다음 확장 매개 변수가 0 개 이상입니다. &quot;q&quot;매개 변수는 확장 (accept-ext)이있는 경우 필요합니다. 두 매개 변수 세트 사이의 분리기 역할을하기 때문입니다. 참고 : &quot;q&quot;매개 변수 이름을 사용하여 미디어 유형 매개 변수를 확장 확장 매개 변수 허용과 분리하는 것은 과거의 관행 때문입니다. 이렇게하면 &quot;q&quot;라는 매체 유형 매개 변수가 매체 범위와 함께 사용되지 않지만, 이러한 이벤트는 IANA 매체 유형 레지스트리에 &quot;q&quot;매개 변수가없고 매체 유형이 거의 사용되지 않는 것으로 간주됩니다. 수락의 매개 변수. 향후 미디어 유형은 &quot;q&quot;라는 매개 변수를 등록하지 않는 것이 좋습니다. 수락 예 : audio / *; q = 0.2, 오디오 / 기본은 &quot;오디오 / 기본을 선호하지만 80 % 품질 저하 후 최상의 오디오를 얻으려면 모든 오디오 유형을 보내십시오. &quot;헤더 헤더 필드가없는 요청은 사용자 에이전트가 미디어 유형을 응답으로 수락 함을 의미합니다. 필드가 요청에 있고 응답에 사용 가능한 표현 중 허용 가능한 것으로 표시된 미디어 유형이없는 경우, 오리진 서버는 406 (Not Acceptable) 응답을 보내서 헤더 필드를 인식하거나 처리하여 헤더 필드를 무시할 수 있습니다. 내용 협상의 대상이 아닌 것처럼 응답 더 복잡한 예는 수락 : text / plain; q = 0.5, text / html, text / x-dvi; q = 0.8, text / xc 구두로, 이것은 해석됩니다 &quot;text / html 및 text / xc도 마찬가지로 선호되는 미디어 유형이지만 존재하지 않는 경우그런 다음 text / x-dvi 표현을 보내십시오. 존재하지 않는 경우 text / plain 표현을 보내십시오. &quot;미디어 범위는보다 구체적인 미디어 범위 또는 특정 미디어 유형에 의해 재정의 될 수 있습니다. 예를 들어 수락 : text / *, text / plain, text / plain; format = flowed, * / *는 다음과 같은 우선 순위를 갖습니다. 1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / * 주어진 유형과 관련된 매체 유형 품질 계수는 유형과 일치하는 우선 순위가 가장 높은 매체 범위를 찾아서 결정됩니다 (예 : Accept : text / *; q = 0.3). , text / html; q = 0.7, text / html; level = 1, text / html; level = 2; q = 0.4, * / *; q = 0.5로 인해 다음 값이 연결됩니다.+ ------------------- + --------------- + | 미디어 타입 | 품질 가치 | + ------------------- + --------------- + | text / html; level = 1 | 1 | | 텍스트 / html | 0.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">&quot;Accept-Charset&quot;헤더 필드는 텍스트 응답 컨텐츠에서 허용되는 문자 세트를 표시하기 위해 사용자 에이전트에 의해 전송 될 수 있습니다. 이 필드를 사용하면보다 포괄적이거나 특수한 목적의 문자 집합을 이해할 수있는 사용자 에이전트가 해당 문자 집합의 정보를 나타낼 수있는 원본 서버에 해당 기능을 알릴 수 있습니다. Accept-Charset = 1 # ((charset / &quot;*&quot;) [weight]) 문자셋 이름은 &lt;a href=&quot;#section-3.1.1.2&quot;&gt;3.1.1.2 절에&lt;/a&gt; 정의되어 있습니다. 사용자 에이전트는 &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 품질 값을 각 문자 세트와 연관시켜 해당 문자 세트에 대한 사용자의 상대적 선호도를 표시 할 수 있습니다.. 예는 Accept-Charset입니다. iso-8859-5, unicode-1-1; q = 0.8 Accept-Charset 필드에있는 특수 값 &quot;*&quot;는 Accept-Charset의 다른 곳에 언급되지 않은 모든 문자 세트와 일치합니다. 문자셋 필드. Accept-Charset 필드에 &quot;*&quot;가 없으면 필드에 명시 적으로 언급되지 않은 모든 문자 세트가 클라이언트에 &quot;허용되지 않는&quot;것으로 간주됩니다. Accept-Charset 헤더 필드가없는 요청은 사용자 에이전트가 응답으로 모든 문자 세트를 승인 함을 의미합니다. 지원되는 문자 세트의 세부 목록이 사용자 에이전트의 요청 특성으로 인해 서버가 개인을 쉽게 식별 할 수 있기 때문에 특별히 구성된 경우가 아니면 대부분의 범용 사용자 에이전트는 Accept-Charset을 보내지 않습니다 ( &lt;a href=&quot;#section-9.7&quot;&gt;9.7 절).&lt;/a&gt;). Accept-Charset 헤더 필드가 요청에 있고 응답에 사용 가능한 표현 중 허용 가능한 것으로 표시된 문자 집합이없는 경우, 오리진 서버는 406 (Not Acceptable) 응답을 보내 헤더 필드를 사용할 수 있습니다. 또는 컨텐츠 협상이 적용되지 않는 것처럼 리소스를 처리하여 헤더 필드를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">사용자 에이전트는 &quot;Accept-Encoding&quot;헤더 필드를 사용하여 응답 에 허용되는 응답 내용 코딩 ( &lt;a href=&quot;#section-3.1.2.1&quot;&gt;3.1.2.1&lt;/a&gt; ) 을 표시 할 수 있습니다 . &quot;식별&quot;토큰은 인코딩이 선호되지 않을 때 통신하기 위해 &quot;인코딩 없음&quot;의 동의어로 사용됩니다. Accept-Encoding = # (codings [weight]) codings = content-coding / &quot;identity&quot;/ &quot;*&quot; &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 각 코딩 값에는 해당 인코딩에 대한 선호도를 나타내는 관련 품질 값이 주어질 수있다. . Accept-Encoding 필드의 별표 &quot;*&quot;기호는 헤더 필드에 명시 적으로 나열되지 않은 사용 가능한 모든 컨텐츠 코딩과 일치합니다. 예를 들어, Accept-Encoding : compress, gzip Accept-Encoding : Accept-Encoding : * Accept-Encoding : compress; q = 0.5, gzip; q = 1.0 Accept-Encoding : gzip; q = 1.0, identity; q = 0.5, *; q = 0 Accept-Encoding 헤더 필드가없는 요청은 사용자 에이전트에 컨텐츠 코딩에 대한 기본 설정이 없음을 의미합니다. 이렇게하면 서버가 응답으로 컨텐츠 코딩을 사용할 수 있지만 사용자 에이전트가 모든 인코딩을 올바르게 처리 할 수 ​​있음을 의미하지는 않습니다. 서버는 다음 규칙을 사용하여 지정된 표현의 컨텐츠 코딩이 허용되는지 여부를 테스트합니다. 1. 요청에 Accept-Encoding 필드가없는 경우,모든 콘텐츠 코딩은 사용자 에이전트에 의해 허용되는 것으로 간주됩니다. 2. 표현에 컨텐츠 코딩이없는 경우, &quot;identity; q = 0&quot;또는 &quot;*; q = 0&quot;을 나타내는 Accept-Encoding 필드에서 특별히 제외하지 않으면 &quot; 정체&quot;. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&quot;신분&quot;에 대한 더 구체적인 항목이 없습니다. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&quot;신분&quot;에 대한 더 구체적인 항목이 없습니다. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&lt;a href=&quot;#section-5.3.1&quot;&gt;섹션 5.3.1&lt;/a&gt; 에서 qvalue 0은 &quot;허용되지 않음&quot;을 의미합니다. 4. 여러 컨텐츠 코딩이 허용 가능한 경우, 0이 아닌 qvalue가 가장 높은 허용 컨텐츠 코딩이 선호됩니다. 필드 값이 결합 된 Accept-Encoding 헤더 필드는 사용자 에이전트가 응답하는 컨텐츠 코딩을 원하지 않음을 의미합니다. Accept-Encoding 헤더 필드가 요청에 있고 응답에 사용 가능한 표현 중 수용 가능한 것으로 표시된 내용 코딩이없는 경우, 오리진 서버는 내용 코딩없이 응답을 보내야합니다. 참고 : 대부분의 HTTP / 1.0 응용 프로그램은 컨텐츠 코딩과 관련된 q 값을 인식하거나 따르지 않습니다. 이것은 qvalues가 작동하지 않을 수 있고 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">&quot;Accept-Language&quot;헤더 필드는 사용자 에이전트가 응답에서 선호되는 자연어 세트를 표시하는 데 사용할 수 있습니다. 언어 태그는 &lt;a href=&quot;#section-3.1.3.1&quot;&gt;3.1.3.1 절&lt;/a&gt; 에서 정의됩니다 . Accept-Language = 1 # (language-range [weight]) language-range = &amp;lt;language-range, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], 섹션 2.1 참조&lt;/a&gt; &amp;gt; 각 언어 범위에는 사용자 선호도 추정치를 나타내는 관련 품질 값이 주어질 수 있습니다. &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 해당 범위에 의해 지정된 언어. 예를 들어 Accept-Language : da, en-gb; q = 0.8, en; q = 0.7은 &quot;나는 덴마크어를 선호하지만 영국 영어 및 기타 유형의 영어는 허용합니다&quot;를 의미합니다. Accept-Language 헤더 필드가없는 요청은 사용자 에이전트가 응답으로 모든 언어를 수락 함을 의미합니다. 요청에 헤더 필드가 있고 응답에 사용 가능한 표현 중 일치하는 언어 태그가없는 경우, 오리진 서버는 응답을 컨텐츠 협상 대상이 아닌 것처럼 처리하여 헤더 필드를 무시하거나 헤더를 존중할 수 있습니다 406 (Not Acceptable) 응답을 보내서 그러나 후자는 권장하지 않습니다. 이렇게하면 사용자가 사용할 수있는 콘텐츠 (예 : 번역 소프트웨어)에 액세스하지 못할 수 있습니다.일부 수신자는 특히 품질 값이 동일한 태그 (값이 q = 1과 같지 않음)에 대해 언어 태그가 나열되는 순서를 내림차순으로 표시합니다. 그러나이 동작은 신뢰할 수 없습니다. 일관성을 유지하고 상호 운용성을 극대화하기 위해 많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;[RFC4647]의 2.3 절&lt;/a&gt; . 매칭을 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;[RFC4647]의 섹션 3&lt;/a&gt; 은 몇 가지 매칭 방식을 정의합니다. 구현은 요구 사항에 가장 적합한 일치 체계를 제공 할 수 있습니다. &quot;기본 필터링&quot;체계 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], 3.3.1 절&lt;/a&gt; )는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;[RFC2616]의 14.4 절&lt;/a&gt; 에서 HTTP에 대해 이전에 정의 된 일치 체계와 동일합니다 . 모든 요청에서 사용자의 완전한 언어 적 선호와 함께 Accept-Language 헤더 필드를 전송하는 것은 사용자의 개인 정보 보호 기대와 상충 될 수 있습니다 ( &lt;a href=&quot;#section-9.7&quot;&gt;섹션 9.7).&lt;/a&gt;). 명료성은 개별 사용자에 따라 크게 달라 지므로 사용자 에이전트는 사용자 에이전트 자체의 구성을 통해 또는 사용자 제어 가능한 시스템 설정을 기본값으로하여 언어 선호도에 대한 사용자 제어를 허용해야합니다. 사용자에게 그러한 제어를 제공하지 않는 사용자 에이전트는 Accept-Language 헤더 필드를 보내서는 안됩니다. 참고 : 사용자 에이전트는 환경 설정시 사용자에게 지침을 제공해야합니다. 사용자는 위에서 설명한대로 언어 일치에 대한 세부 사항에 거의 익숙하지 않기 때문입니다. 예를 들어, 사용자는 &quot;en-gb&quot;를 선택할 때 영국 영어를 사용할 수없는 경우 모든 종류의 영어 문서가 제공된다고 가정 할 수 있습니다. 이 경우 사용자 에이전트는 더 나은 일치 동작을 위해 목록에 &quot;en&quot;을 추가 할 것을 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">&quot;Accept-Ranges&quot;헤더 필드를 통해 서버는 대상 자원에 대한 범위 요청을 지원함을 표시 할 수 있습니다. 수락 범위 = 수용 가능 범위 수용 가능 범위 = 1 # range-unit / &quot;없음&quot;특정 대상 리소스에 대한 바이트 범위 요청을 지원하는 원 서버는 Accept-Ranges : 바이트를 전송하여 지원되는 범위 단위를 나타냅니다. 클라이언트는 관련된 자원에 대한이 헤더 필드를받지 않고 범위 요청을 생성 할 수있다. 범위 단위는 &lt;a href=&quot;#section-2&quot;&gt;섹션 2에&lt;/a&gt; 정의되어 있습니다. 대상 리소스에 대해 어떤 종류의 범위 요청도 지원하지 않는 서버는 Accept-Ranges : none을 전송하여 클라이언트에게 범위 요청을 시도하지 않도록 조언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">&quot;나이&quot;헤더 필드는 발신자 서버에서 응답이 생성되거나 성공적으로 검증 된 이후 발신자의 예상 시간을 전달합니다. 연령 값은 &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3에&lt;/a&gt; 지정된대로 계산됩니다 . Age = delta-seconds Age 필드 값은 시간을 초 단위로 나타내는 음이 아닌 정수입니다 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 단원&lt;/a&gt; 참조 ). Age 헤더 필드가 존재한다는 것은이 요청에 대한 오리진 서버가 응답을 생성 또는 검증하지 않았 음을 의미합니다. 그러나 Age 헤더 필드가 없다고해서 Age를 구현하지 않는 HTTP / 1.0 캐시에서 응답이 수신되었을 수 있기 때문에 오리진에 접속 한 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">&quot;허용&quot;헤더 필드는 대상 자원이 지원하는 것으로 보급 된 메소드 세트를 나열합니다. 이 필드의 목적은 수신자에게 리소스와 관련된 유효한 요청 방법을 알리는 것입니다. Allow = #method 사용 예 : Allow : GET, HEAD, PUT 실제 허용되는 메소드 세트는 각 요청시 오리진 서버에 의해 정의됩니다. 오리진 서버는 반드시 405 (Method Not Allowed) 응답에서 Allow 필드를 생성해야하며 다른 응답에서는 그렇게 할 수 있습니다. 비어있는 허용 필드 값은 리소스가 구성에 의해 일시적으로 비활성화 된 경우 405 응답에서 발생할 수있는 메서드를 허용하지 않음을 나타냅니다.프록시는 헤더 허용 필드를 수정해서는 안됩니다. 일반 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 방법을 이해할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">&quot;Authorization&quot;헤더 필드를 통해 사용자 에이전트는 401 (Unauthorized) 응답을받은 후 일반적으로 오리진 서버로 자체 인증 할 수 있습니다. 그 값은 요청되는 자원 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 신임 정보로 구성됩니다. 권한 부여 = 신임 정보 요청이 인증되고 영역이 지정된 경우, 인증 영역 자체가 달리 요구하지 않는 경우 (예 : 챌린지 값에 따라 다른 신임 정보) 가정하면 동일한 영역의 자격 증명이이 영역 내의 다른 모든 요청에 ​​유효한 것으로 간주됩니다. 또는 동기화 된 시계 사용). 요청을 전달하는 프록시는 해당 요청의 인증 필드를 수정해서는 안됩니다 (MUST NOT). &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;[RFC7234] 3.2 절&lt;/a&gt; 참조 HTTP 캐시에 의한 권한 부여 필드 처리와 관련된 세부 사항 및 요구 사항</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">&quot;기본&quot;HTTP 인증 체계는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617에&lt;/a&gt; 정의되어 있으며 , 자격 증명을 base64를 사용하여 인코딩 된 사용자 ID / 암호 쌍으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">&quot;Cache-Control&quot;헤더 필드는 요청 / 응답 체인을 따라 캐시에 대한 지시문을 지정하는 데 사용됩니다. 이러한 캐시 지시문은 요청에 지시문이 있다고해서 동일한 지시문이 응답에 제공되는 것을 의미하지 않는다는 점에서 단방향입니다. 캐시는이 섹션에 정의 된 Cache-Control 지시문의 요구 사항을 준수해야합니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조다른 곳에 정의 된 Cache-Control 지시문을 처리하는 방법에 대한 정보 참고 : 일부 HTTP / 1.0 캐시는 Cache-Control을 구현하지 않을 수 있습니다. 프록시가 캐시를 구현하는지 여부에 관계없이 프록시는 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있기 때문에 해당 애플리케이션에 대한 중요성에 관계없이 전달 된 메시지를 통해 캐시 지시문을 전달해야합니다. 지시문을 특정 캐시에 대상으로 지정할 수 없습니다. 캐시 지시문은 토큰으로 식별되며 대소 ​​문자를 구분하지 않고 비교되며 선택적 인수는 토큰과 따옴표로 묶은 문자열 구문을 모두 사용할 수 있습니다. 인수를 정의하는 아래 정의 된 지시문의 경우 수신자는 선호되는 것으로 문서화 된 경우에도 두 양식을 모두 수락해야합니다. 이 사양으로 정의되지 않은 지시문의 경우수취인은 반드시 두 양식을 모두 수락해야합니다. Cache-Control = 1 # cache-directive cache-directive = token [ &quot;=&quot;(token / quoted-string)] 아래에 정의 된 캐시 지시문에 대해 달리 명시되지 않는 한 인수가 정의되지 않습니다 (또는 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">&quot;연결&quot;헤더 필드를 사용하면 발신자가 현재 연결에 원하는 제어 옵션을 표시 할 수 있습니다. 다운 스트림 수신자를 혼동하지 않으려면 프록시 또는 게이트웨이는 메시지를 전달하기 전에 수신 된 연결 옵션을 제거하거나 바꿔야합니다. Connection을 제외한 헤더 필드를 사용하여 현재 연결에 대한 제어 정보를 제공하는 경우 보낸 사람은 Connection 헤더 필드에 해당 필드 이름을 나열해야합니다. 프록시 또는 게이트웨이는 메시지가 전달되기 전에 수신 된 연결 헤더 필드를 구문 분석해야하며이 필드의 각 연결 옵션에 대해 연결 옵션과 동일한 이름을 가진 메시지에서 헤더 필드를 제거한 다음 제거하십시오. 연결 헤더 필드 자체 (또는 중개자로 대체)전달 된 메시지에 대한 자체 연결 옵션). 따라서 연결 헤더 필드는 체인의 모든 수신자를위한 필드 ( &quot;end-to-end&quot;)와 직접적인 수신자 ( &quot;hop-by-hop&quot;)만을 대상으로하는 헤더 필드를 구별하는 선언적인 방법을 제공합니다. &quot;)를 사용하여 메시지를 자기 설명 할 수있게하고 향후 연결 별 확장을 이전 중개자가 맹목적으로 전달할 것이라는 두려움없이 배포 할 수 있습니다. 연결 헤더 필드의 값은 다음과 같은 문법을 갖습니다. Connection = 1 # connection-option connection-option = token 연결 옵션은 대소 문자를 구분하지 않습니다. 발신자는 페이로드의 모든 수신자를 대상으로하는 헤더 필드에 해당하는 연결 옵션을 보내서는 안됩니다.예를 들어, Cache-Control은 연결 옵션 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234] 섹션 5.2&lt;/a&gt;). 연결 옵션과 연관된 매개 변수가없는 경우 연결 별 헤더 필드가 필요하지 않을 수 있으므로 연결 옵션이 메시지에 존재하는 헤더 필드와 항상 일치하는 것은 아닙니다. 대조적으로, 해당 연결 옵션없이 수신 된 연결 특정 헤더 필드는 일반적으로 필드가 중개자에 의해 부적절하게 전달되었고 수신자에 의해 무시되어야 함을 나타냅니다. 새 연결 옵션을 정의 할 때 사양 작성자는 기존 헤더 필드 이름을 조사하고 새 연결 옵션이 이미 배포 된 헤더 필드와 동일한 이름을 공유하지 않아야합니다. 새 연결 옵션을 정의하면 기본적으로 연결 옵션과 관련된 추가 정보를 전달할 수있는 해당 필드 이름이 예약됩니다.발신자가 필드 이름을 다른 용도로 사용하는 것은 현명하지 않기 때문입니다. &quot;닫기&quot;연결 옵션은 발신자가 응답이 완료된 후이 연결이 닫히 겠다는 신호를 보내기 위해 정의됩니다. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (요청 또는 응답 헤더 필드에서 닫기는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (요청 또는 응답 헤더 필드에서 닫기는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (&lt;a href=&quot;#section-6.6&quot;&gt;섹션 6.6&lt;/a&gt; ). 영구 연결을 지원하지 않는 클라이언트는 모든 요청 메시지에 &quot;닫기&quot;연결 옵션을 보내야합니다. 영구 연결을 지원하지 않는 서버는 1xx (정보) 상태 코드가없는 모든 응답 메시지에 &quot;닫기&quot;연결 옵션을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">&quot;콘텐츠 인코딩&quot;헤더 필드는 미디어 유형 고유의 것 이외의 표현에 적용된 콘텐츠 코딩을 나타내며, 따라서 콘텐츠가 참조하는 미디어 유형의 데이터를 얻기 위해 어떤 디코딩 메커니즘이 적용되어야하는지 표시한다. 헤더 필드를 입력하십시오. 컨텐츠 인코딩은 주로 기본 미디어 유형의 ID를 유지하면서 표현의 데이터를 압축 할 수 있도록하는 데 사용됩니다. Content-Encoding = 1 # content-coding 사용 예는 Content-Encoding입니다. gzip 하나 이상의 인코딩이 표현에 적용된 경우 인코딩을 적용한 발신인은 반드시 내용을 나열하는 Content-Encoding 헤더 필드를 생성해야합니다. 적용된 순서대로 코딩합니다.인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 헤더 필드에서 제공 할 수 있습니다. 전송 인코딩과 달리&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]의 섹션 3.3.1&lt;/a&gt;), Content-Encoding에 나열된 코딩은 표현의 특성이다. 표현은 코딩 된 형태로 정의되고, 표현에 관한 다른 모든 메타 데이터는 메타 데이터 정의에서 달리 언급되지 않는 한 코딩 된 형태에 관한 것이다. 일반적으로 표현은 렌더링 또는 유사한 사용 직전에 디코딩됩니다. 미디어 유형에 항상 압축되는 데이터 형식과 같은 고유 인코딩이 포함 된 경우 해당 인코딩은 콘텐츠 코딩 중 하나와 동일한 알고리즘이더라도 콘텐츠 인코딩에서 복원되지 않습니다. 이러한 콘텐츠 코딩은 기괴한 이유로 표현을 형성하기 위해 두 번째로 적용되는 경우에만 나열됩니다. 마찬가지로,오리진 서버는 코딩이 Content-Type 또는 Content-Encoding의 일부로 정의되는지 여부 만 다른 여러 표현과 동일한 데이터를 게시하도록 선택할 수 있습니다. 일부 사용자 에이전트는 각 응답을 처리 할 때 다르게 동작하기 때문입니다 (예 : 열기 자동 압축 풀기 및 컨텐츠 렌더링 대신 &quot;다른 이름으로 저장 ...&quot;대화 상자). 요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">&quot;Content-Language&quot;헤더 필드는 표현 대상 독자의 자연어를 설명합니다. 이는 표현에 사용 된 모든 언어와 같지 않을 수도 있습니다. Content-Language = 1 # language-tag 언어 태그는 &lt;a href=&quot;#section-3.1.3.1&quot;&gt;3.1.3.1 절에&lt;/a&gt; 정의되어 있습니다.. Content-Language의 주요 목적은 사용자가 선호하는 언어에 따라 표현을 식별하고 구별 할 수 있도록하는 것입니다. 따라서 컨텐츠가 덴마크어 언어 사용자 만 대상으로하는 경우 해당 필드는 컨텐츠 언어입니다. da 컨텐츠 언어가 지정되지 않은 경우 기본적으로 컨텐츠는 모든 언어 사용자를 대상으로합니다. 이는 발신자가 자연 언어에 고유 한 것으로 간주하지 않거나 발신자가 어떤 언어를 사용하는지 알지 못했음을 의미 할 수 있습니다. 여러 사용자를 대상으로하는 콘텐츠에 대해 여러 언어가 나열 될 수 있습니다. 예를 들어, 원래 마오리어와 영어 버전에서 동시에 제시된 &quot;와이 탕이의 보물&quot;을 번역하려면 Content-Language : mi,jw.org ko 그러나 표현 내에 여러 언어가 존재한다고해서 여러 언어 사용자를 대상으로한다는 의미는 아닙니다. 예를 들어 &quot;Latin의 첫 수업&quot;과 같은 초보자의 언어 입문서가 영어를 사용하는 청중이 사용하도록 명확하게 고안되었습니다. 이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">&quot;Content-Location&quot;헤더 필드는이 메시지의 페이로드의 표현에 해당하는 특정 자원의 식별자로 사용할 수있는 URI를 참조합니다. 즉,이 메시지 생성시이 URI에서 GET 요청을 수행하려는 경우 200 (OK) 응답에는이 메시지에서 페이로드로 묶인 동일한 표시가 포함됩니다. Content-Location = absolute-URI / partial-URI Content-Location 값은 유효 요청 URI를 대체하지 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; ). 표현 메타 데이터입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;[RFC2557]의 섹션 4&lt;/a&gt; 에서 MIME 본문 부분에 대해 정의 된 동일한 이름의 헤더 필드와 동일한 구문 및 의미가 있습니다 .. 그러나 HTTP 메시지에 나타나는 것은 HTTP 수신자에게 특별한 영향을 미칩니다. Content-Location이 2xx (성공) 응답 메시지에 포함되어 있고 그 값이 (절대 형식으로 변환 한 후) 유효 요청 URI와 동일한 URI를 참조하는 경우 수신자는 페이로드를 현재 표현으로 간주 할 수 있습니다. 메시지 시작 날짜로 표시된 시간에 해당 자원의 GET ( &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; ) 또는 HEAD ( &lt;a href=&quot;#section-4.3.2&quot;&gt;섹션 4.3.2&lt;/a&gt; ) 요청의 경우 서버에서 Content-Location을 제공하지 않은 경우 기본 시맨틱과 동일합니다. PUT ( &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; ) 또는 POST ( &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3&lt;/a&gt; ) 와 같은 상태 변경 요청), 서버의 응답에 해당 리소스의 새로운 표현이 포함되어있어 해당 작업에 대해서만보고 할 수있는 표현 (예 : &quot;작동했습니다!&quot;)과 구분됩니다. 이를 통해 제작 응용 프로그램은 후속 GET 요청없이 로컬 복사본을 업데이트 할 수 있습니다. Content-Location이 2xx (성공) 응답 메시지에 포함되고 해당 필드 값이 유효 요청 URI와 다른 URI를 참조하는 경우, 오리진 서버는 URI가 동봉 된 해당 자원에 대한 다른 자원의 식별자라고 주장합니다. 대표. 이러한 주장은 두 식별자가 모두 동일한 리소스 소유자를 공유하는 경우에만 신뢰할 수 있으며, 이는 HTTP를 통해 프로그래밍 방식으로 확인할 수 없습니다. o GET 또는 HEAD 요청에 대한 응답이는 유효 요청 URI가 컨텐츠 협상의 대상이되는 자원을 나타내며 Content-Location 필드-값이 선택된 표현에 대한보다 구체적인 식별자임을 나타냅니다. o 상태 변경 방법에 대한 201 (작성) 응답의 경우 위치 필드 값과 동일한 컨텐츠 위치 필드 값은이 페이로드가 새로 작성된 자원의 현재 표시임을 나타냅니다. o 그렇지 않으면, 그러한 컨텐츠 위치는이 페이로드가 요청 된 조치의 상태를보고하는 표시이며 주어진 URI에서 동일한 보고서를 사용할 수 있음 (나중에 GET으로 액세스 할 수 있음)을 나타냅니다. 예를 들어POST 요청을 통해 이루어진 구매 거래는 200 (OK) 응답의 페이로드로 영수증 문서를 포함 할 수 있습니다. Content-Location 필드-값은 나중에 동일한 영수증의 사본을 검색하기위한 식별자를 제공합니다. 요청 메시지에서 Content-Location을 전송하는 사용자 에이전트는 해당 값이 사용자 에이전트가 원래 동봉 된 표현의 컨텐츠를 얻은 위치를 나타냅니다 (해당 사용자 에이전트가 수정하기 전에). 다시 말해, 사용자 에이전트는 원래 표현의 소스에 대한 백 링크를 제공하고 있습니다. 요청 메시지에서 Content-Location 필드를 수신하는 오리진 서버는 정보를 표현의 일부로 그대로 저장할 메타 데이터가 아닌 일시적인 요청 컨텍스트로 취급해야합니다.오리진 서버는 해당 컨텍스트를 사용하여 요청을 처리하거나 소스 링크 또는 버전 관리 메타 데이터와 같은 다른 용도로 저장하도록 할 수 있습니다. 그러나 오리진 서버는 그러한 의미 정보를 사용하여 요청 의미를 변경해서는 안됩니다. 예를 들어, 클라이언트가 협상 된 자원에 대해 PUT 요청을하고 오리진 서버가 해당 PUT을 경로 재 지정없이 승인하면 해당 자원의 새로운 상태는 해당 PUT에 제공된 표현과 일치해야합니다. Content-Location은 협상 된 표현 중 하나만 업데이트하기 위해 리버스 컨텐츠 선택 식별자의 형태로 사용될 수 없습니다. 사용자 에이전트가 후자의 의미를 원한다면 PUT을 Content-Location URI에 직접 적용했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">&quot;컨텐츠 범위&quot;헤더 필드는 단일 파트 (206) (부분 컨텐츠) 응답으로 전송되어 메시지 페이로드로 묶인 선택된 표현의 부분 범위를 나타내며, 멀티 파트 (206) 응답의 각 파트로 전송되어 범위를 나타냅니다. 각 신체 부위를 선택하고 선택한 표현에 대한 정보를 제공하기 위해 416 (Range Not Satisfiable) 응답으로 전송됩니다. 내용 범위 = 바이트 내용 범위 / 기타 내용 범위 바이트 내용 범위 = 바이트 단위 SP (바이트 범위 해상도 / 불만족 범위) 바이트 범위 해상도 = 바이트 범위 &quot;/&quot;(완료 -length / &quot;*&quot;) 바이트 범위 = 첫 번째 바이트 위치 &quot;-&quot;마지막 바이트 위치 만족되지 않은 범위 = &quot;* /&quot;complete-length complete-length = 1 * DIGIT other-content-range = other-range-unit SP other-range-resp other-range-resp = * CHAR 206 (부분 컨텐츠) 응답에 Content-Range 헤더 필드가 포함 된 경우 범위 단위 (&lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt;) 수령인이 이해하지 못하는 경우, 수령인은 저장된 표현과 함께 재결합을 시도해서는 안됩니다. 그러한 메시지를받는 프록시는 그것을 다운 스트림으로 전달해야한다. 바이트 범위의 경우, 발신인은 전체 길이를 알 수 없거나 결정하기 어려운 경우가 아니라면 범위가 추출 된 표현의 전체 길이를 표시해야한다. 전체 길이 대신 별표 문자 ( &quot;*&quot;)는 헤더 필드가 생성 될 때 표시 길이를 알 수 없음을 나타냅니다. 다음 예는 발신자가 선택한 표현의 전체 길이를 1234 바이트로 알고있는 경우를 보여줍니다. Content-Range : bytes 42-1233 / 1234 및이 두 번째 예는 전체 길이를 알 수없는 경우를 보여줍니다. Content-Range :bytes 42-1233 / * Content-Range 필드 값에 첫 번째 바이트 위치 값보다 작은 마지막 바이트 위치 값 또는 전체 길이 값보다 작은 바이트 범위 범위 값이 포함 된 경우 유효하지 않은 필드 범위 값 또는 마지막 바이트 위치 값과 같습니다. 유효하지 않은 Content-Range의 수신자는 수신 된 컨텐츠를 저장된 표현과 재결합하려고 시도해서는 안됩니다 (MUST NOT). 바이트 범위 요청에 대해 416 (Range Not Satisfiable) 응답을 생성하는 서버는 다음 예와 같이 만족하지 않은 범위 값으로 Content-Range 헤더 필드를 보내야합니다. Content-Range : bytes * / 1234 전체 길이 416 응답에서 선택한 표현의 현재 길이를 나타냅니다. Content-Range 헤더 필드는 의미를 명시 적으로 설명하지 않는 상태 코드에는 의미가 없습니다. 이 사양에서는206 (부분 내용) 및 416 (범위가 만족스럽지 않음) 상태 코드 만이 내용 범위의 의미를 설명합니다. 다음은 선택한 표현에 총 1234 바이트가 포함 된 Content-Range 값의 예입니다. o 첫 500 바이트 : Content-Range : bytes 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500- 999/1234 o 처음 500 바이트를 제외한 모두 : 내용 범위 : 바이트 500-1233 / 1234 o 마지막 500 바이트 : 내용 범위 : 바이트 734-1233 / 1234바이트 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500-999 / 1234 o 처음 500 바이트를 제외한 모두 : Content-Range : bytes 500-1233 / 1234 o 마지막 500 바이트 : Content-Range : 바이트 734-1233 / 1234바이트 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500-999 / 1234 o 처음 500 바이트를 제외한 모두 : Content-Range : bytes 500-1233 / 1234 o 마지막 500 바이트 : Content-Range : 바이트 734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">&quot;컨텐츠 유형&quot;헤더 필드는 메시지 표현에 의해 결정된 메시지 페이로드에 포함 된 표현 또는 선택된 표현 중 하나와 관련된 표현의 미디어 유형을 나타낸다. 지시 된 미디어 타입은 데이터 인코딩에 의해 지시 된 임의의 컨텐츠 코딩이 디코딩 된 후, 수신 된 메시지 시맨틱의 범위 내에서, 수신자에 의해 데이터 포맷 및 데이터가 어떻게 처리되도록 의도되는지를 정의한다. 콘텐츠 유형 = 미디어 유형 미디어 유형은 &lt;a href=&quot;#section-3.1.1.1&quot;&gt;3.1.1.1 절에&lt;/a&gt; 정의되어 있습니다.. 이 필드의 예는 Content-Type입니다. text / html; charset = ISO-8859-4 페이로드 본문을 포함하는 메시지를 생성하는 발신인은 동봉 된 표현의 의도 된 미디어 유형이 발신자에게 알려지지 않은 경우가 아니라면 해당 메시지에 Content-Type 헤더 필드를 생성해야합니다 (SHOULD). Content-Type 헤더 필드가 존재하지 않는 경우, 수신자는 미디어 타입이 &quot;application / octet-stream&quot;( &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], 4.5.1 절)&lt;/a&gt; 라고 가정 할 수있다.) 또는 데이터를 검사하여 유형을 확인하십시오. 실제로, 자원 소유자는 주어진 표현에 대해 올바른 컨텐츠 유형을 제공하도록 항상 오리진 서버를 올바르게 구성하지는 않으며, 그 결과 일부 클라이언트가 페이로드의 컨텐츠를 검사하고 지정된 유형을 대체합니다. 그렇게하는 클라이언트는 잘못된 결론을 도출하여 추가적인 보안 위험이 발생할 수 있습니다 (예 : &quot;권한 에스컬레이션&quot;). 또한 데이터 형식을 검사하여 보낸 사람의 의도를 확인하는 것은 불가능합니다. 많은 데이터 형식이 처리 의미론 만 다른 여러 미디어 유형과 일치합니다. 구현자는 이러한 &quot;컨텐츠 스니핑&quot;을 사용할 때이를 비활성화하는 수단을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">&quot;날짜&quot;헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;[RFC5322]의 3.6.1 절에&lt;/a&gt; 정의 된 시작 날짜 필드 (원래 날짜)와 동일한 의미를 갖습니다 . 필드 값은 &lt;a href=&quot;#section-7.1.1.1&quot;&gt;7.1.1.1 절에&lt;/a&gt; 정의 된 HTTP 날짜입니다.. Date = HTTP-date 예는 Date : Tue, 1994 년 11 월 15 일 08:12:31 GMT입니다. Date 헤더 필드가 생성되면 발신인은 메시지 생성 날짜 및 시간의 근사값으로 필드 값을 생성해야합니다 (SHOULD). 이론적으로 날짜는 페이로드가 생성되기 직전의 순간을 나타내야합니다. 실제로 날짜는 메시지가 생성되는 동안 언제든지 생성 될 수 있습니다. 오리진 서버는 협정 세계시로 현재 인스턴스의 합리적인 근사치를 제공 할 수있는 시계가없는 경우 날짜 헤더 필드를 보내서는 안됩니다. 응답이 상태 코드의 1xx (정보) 또는 5xx (서버 오류) 클래스 인 경우 오리진 서버는 날짜 헤더 필드를 보낼 수 있습니다. 오리진 서버는 다른 모든 경우에 날짜 헤더 필드를 보내야합니다.날짜 헤더 필드가없는 응답 메시지를 수신하는 시계를 가진 수신자는 수신 한 시간을 기록하고 메시지가 다운 스트림에 캐시되거나 전달 될 경우 해당 날짜 헤더 필드를 메시지의 헤더 섹션에 추가해야합니다. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.다운 스트림에 캐시되거나 전달 된 경우 헤더 섹션. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.다운 스트림에 캐시되거나 전달 된 경우 헤더 섹션. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">응답의 &quot;ETag&quot;헤더 필드는 요청 처리 결론에 따라 선택된 표현에 대한 현재 엔티티 태그를 제공합니다. 엔티티 태그는 시간이 지남에 따라 자원 상태가 변경되는지, 컨텐츠 협상을 통해 여러 표현이 동시에 유효한지 또는 두 가지 모두에 관계없이 동일한 자원의 여러 표현을 구별하기위한 불투명 한 유효성 검사기입니다. 엔티티 태그는 불투명 인용 문자열로 구성되며 약점 표시기가 접두사로 표시 될 수 있습니다. ETag = 엔티티 태그 엔티티 태그 = [약한] 불투명 태그 약한 = % x57.2F; &quot;W /&quot;, 대소 문자 구분 불투명 태그 = DQUOTE * etagc DQUOTE etagc = % x21 / % x23-7E / obs-text; 큰 따옴표를 제외한 VCHAR,plus obs-text 참고 : 이전에는 불투명 태그가 인용 문자열 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], 섹션 3.11&lt;/a&gt; ); 따라서 일부 수신자는 백 슬래시 이스케이프를 수행 할 수 있습니다. 따라서 서버는 엔티티 태그에서 백 슬래시 문자를 사용하지 않아야합니다. 엔터티 태그는 수정 날짜를 저장하는 것이 불편하거나 HTTP 날짜 값의 1 초 해상도가 충분하지 않거나 수정 날짜가 일관되게 유지되지 않는 경우 수정 날짜보다 유효성 검증에 더 안정적 일 수 있습니다. 예 : ETag : &quot;xyzzy&quot;ETag : W / &quot;xyzzy&quot;ETag : &quot;&quot;엔티티 태그는 약하거나 강력한 유효성 검사기 일 수 있으며 기본값은 strong입니다.오리진 서버가 표현을 위해 엔티티 태그를 제공하고 해당 엔티티 태그 생성이 강력한 유효성 검증기의 모든 특성을 충족시키지 못하는 경우 ( &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1)&lt;/a&gt;), 원 서버는 불투명 한 값 앞에 &quot;W /&quot;(대소 문자 구분)를 붙여 엔티티 태그를 약한 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">요청의 &quot;예상&quot;헤더 필드는이 요청을 올바르게 처리하기 위해 서버에서 지원해야하는 특정 동작 (예상)을 나타냅니다. 이 규격에 의해 정의 된 유일한 기대는 100- 연속이다. Expect = &quot;100-continue&quot;Expect 필드 값은 대소 문자를 구분하지 않습니다. 100-continue 이외의 Expect 필드 값을 수신하는 서버는 417 (예상 실패) 상태 코드로 응답하여 예상치 못한 기대를 충족 할 수 없음을 나타낼 수 있습니다. 100-continue 기대는 수신자에게 클라이언트가이 요청에서 (아마도 큰) 메시지 본문을 보내려고하고 요청 라인 및 헤더 필드가 즉각적인 원인이되기에 충분하지 않은 경우 100 (계속) 중간 응답을 수신하려고 함을 알립니다. 성공, 리디렉션,또는 오류 응답. 이를 통해 클라이언트는 실제로 전송하기 전에 메시지 본문을 전송하는 것이 가치가 있다는 표시를 기다릴 수 있으므로 메시지 본문이 크거나 클라이언트가 오류가 발생할 것으로 예상 될 때 (예 : 상태를 보낼 때) 효율성을 향상시킬 수 있습니다. -이전에 확인 된 인증 자격 증명없이 변경 방법). 예를 들어 PUT / somewhere / fun HTTP / 1.1 호스트로 시작하는 요청 : origin.example.com Content-Type : video / h264 Content-Length : 1234567890987 예상 : 100-continue를 사용하면 오리진 서버가 즉시 오류로 응답 할 수 있습니다. 클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 401 (권한 없음) 또는 405 (방법이 허용되지 않음)와 같은 메시지가 표시됩니다. 고객을위한 요구 사항 :o 클라이언트는 메시지 본문을 포함하지 않는 요청에서 100- 연속 기대치를 생성해서는 안됩니다 (MUST NOT). o 요청 메시지 본문을 보내기 전에 100 (계속) 응답을 기다리는 클라이언트는 100- 연속 예상을 포함하는 Expect 헤더 필드를 보내야합니다. o 100- 연속 기대 값을 보내는 클라이언트는 특정 시간 동안 기다릴 필요가 없습니다. 이러한 클라이언트는 아직 응답을받지 않은 경우에도 메시지 본문을 계속 전송할 수 있습니다. 더욱이, 100 (Continue) 응답은 HTTP / 1.0 중개자를 통해 전송 될 수 없으므로 그러한 클라이언트는 메시지 본문을 보내기 전에 무기한 대기해야합니다.o 100- 연속 예상을 포함하는 요청에 대한 응답으로 417 (예상 실패) 상태 코드를 수신하는 클라이언트는 417 응답이 응답 체인이 기대를 지원하지 않음을 나타 내기 때문에 100- 연속 기대없이 요청을 반복해야합니다 ( 예를 들어, HTTP / 1.0 서버를 통과합니다). 서버 요구 사항 : o HTTP / 1.0 요청에서 100- 연속 예상을받는 서버는 해당 기대를 무시해야합니다. o 서버가 해당 요청에 대해 메시지 본문의 일부 또는 전부를 이미 수신했거나 프레임이 메시지 본문이 없음을 나타내는 경우 100 (계속) 응답 전송을 생략 할 수 있습니다. o 100 (계속) 응답을 보내는 서버는 궁극적으로 최종 상태 코드를 보내야합니다.연결이 너무 일찍 닫히지 않는 한, 메시지 본문이 수신되고 처리되면 o 전체 메시지 본문을 읽기 전에 최종 상태 코드로 응답하는 서버는 해당 연결에서 연결을 닫을 것인지 또는 계속해서 요청 메시지를 읽고 버릴 것인지를 표시해야합니다 (참조).&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;). 오리진 서버는 반드시 HTTP / 1.1 (또는 그 이후) 요청 라인과 100- 연속 예상을 포함하고 요청 메시지 본문이 뒤 따르고 있음을 나타내는 완전한 헤더 섹션을 수신해야합니다. 요청 상태와 헤더 필드 만 검사하여 해당 상태를 확인할 수 있거나 즉시 100 (계속) 응답을 보내 클라이언트가 요청의 메시지 본문을 보내도록 권장합니다. 오리진 서버는 100 (Continue) 응답을 보내기 전에 메시지 본문을 기다리지 않아야합니다. 프록시는 반드시 HTTP / 1.1 (또는 그 이후) 요청 라인과 100- 연속 예상을 포함하고 요청 메시지 본문이 따르도록 지시하는 완전한 헤더 섹션을 수신해야합니다.요청 라인 및 헤더 필드 만 검사하여 해당 상태를 판별하거나 해당 요청 라인 및 헤더 섹션을 다음 인바운드 서버로 전송하여 요청을 오리진 서버로 전달하기 시작하십시오. 프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 프록시는 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ]은 중간 100 (계속) 응답을 요청하는 수단과 반드시 ​​이해해야하는 확장을 나타내는 일반적인 메커니즘입니다. 그러나 클라이언트는 확장 메커니즘을 사용하지 않았으며 많은 서버에서 필수 이해 요구 사항을 구현하지 않아 확장 메커니즘을 사용할 수 없게되었습니다. 이 사양에서는 100- 연속의 정의 및 처리를 단순화하기 위해 확장 메커니즘을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">&quot;만료&quot;헤더 필드에는 응답이 오래되었다고 간주 된 날짜 / 시간이 표시됩니다. 신선도 모델에 대한 자세한 내용 &lt;a href=&quot;#section-4.2&quot;&gt;은 4.2 절을&lt;/a&gt; 참조하십시오 . 만료 필드가 있다고해서 원래 리소스가 해당 시간 전, 후 또는 그 이후에 존재하지 않거나 변경되는 것을 의미하지는 않습니다. Expires 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]의 7.1.1.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;섹션에&lt;/a&gt; 정의 된 HTTP- 날짜 타임 스탬프 입니다. Expires = HTTP-date 예 : Expires : Thu, 1994 년 12 월 01 일 16:00:00 GMT 캐시 수신자는 유효하지 않은 날짜 형식, 특히 &quot;0&quot;값을 과거의 시간을 나타내는 것으로 해석해야합니다 (예 : &quot;이미 만료 됨&quot; ). 응답에 max-age 지시문이있는 Cache-Control 필드가 포함 된 경우 ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;5.2.2.8 단원)&lt;/a&gt;) 수신자는 반드시 만료 필드를 무시해야합니다. 마찬가지로 응답에 s-maxage 지시문이 포함 된 경우 ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;섹션 5.2.2.9)&lt;/a&gt;) 공유 캐시 수신자는 반드시 만료 필드를 무시해야합니다. 이 두 가지 경우 모두 Expires의 값은 아직 Cache-Control 필드를 구현하지 않은 수신자만을위한 것입니다. 시계가없는 오리진 서버는 값이 과거의 고정 시간을 나타내거나 (항상 만료 됨) 신뢰할 수있는 시계를 가진 시스템이나 사용자가 해당 값을 리소스와 연결하지 않은 경우 만료 필드를 생성해서는 안됩니다 (MUST NOT). 역사적으로 HTTP는 Expires 필드 값이 향후 1 년을 넘지 않아야했습니다. 더 긴 신선도 수명이 더 이상 금지되지 않지만, 매우 큰 값은 문제를 유발하는 것으로 입증되었습니다 (예 : 시간 값에 32 비트 정수를 사용하여 클럭 오버플로). 많은 캐시가 그보다 훨씬 빠른 응답을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">&quot;보낸 사람&quot;헤더 필드에는 요청하는 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소가 포함됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]의 섹션 3.4&lt;/a&gt; 에서 &quot;사서함&quot;으로 정의 된대로 주소는 기계로 사용 가능해야합니다 . From = mailbox mailbox = &amp;lt;mailbox &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;, 섹션 3.4를&lt;/a&gt; 참조하십시오 .&amp;gt; 예 : From : webmaster@example.org From 헤더 필드는 거의 로봇이 아닌 사용자 에이전트에 의해 전송되지 않습니다. 사용자 에이전트는 사용자의 명시적인 구성 없이는 From 헤더 필드를 보내지 않아야합니다. 사용자 헤더는 사용자의 개인 정보 보호 또는 사이트의 보안 정책과 충돌 할 수 있기 때문입니다. 로봇 사용자 에이전트는 서버에서 문제가 발생하는 경우 (예 : 로봇이 과도하거나 원치 않거나 잘못된 요청을 보내는 경우) 로봇 실행 담당자에게 연락 할 수 있도록 유효한 From 헤더 필드를 보내야합니다. 대부분의 수신자는 필드 값이 공개 정보라고 가정하므로 서버는 액세스 제어 또는 인증에 From 헤더 필드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 컨텐츠 코딩 레지스트리&quot;는 컨텐츠 코딩 이름의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]의 4.2 절&lt;/a&gt; ). 콘텐츠 코딩 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">&quot;HTTP 컨텐츠 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ---------- + ----------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ---------- + -------------------------------------- -+ --------------- + | 정체성 | 예약 ( &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; | &quot; 허용 인코딩&quot;의 &quot;인코딩 없음&quot;의 동의어 ) | | + ---------- + -------------------------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 범위 단위 레지스트리&quot;는 범위 단위 이름의 네임 스페이스를 정의하고 해당 스펙을 나타냅니다. 레지스트리가 작성되었으며 이제 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 전송 코딩 레지스트리&quot;는 전송 코딩 이름의 네임 스페이스를 정의합니다. &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">&quot;HTTP 전송 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ------------ + --------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ------------ + ------------------------------------ -+ --------------- + | 청크 | 일련의 덩어리로 전송 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 압축 | UNIX &quot;압축&quot;데이터 형식 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | 수축하다 | 압축 된 데이터 &quot;delate&quot;| &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; | | | &quot;zlib&quot;데이터 내부의 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) | | | | 형식 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | GZIP 파일 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | | x- 압축 | 더 이상 사용되지 않음 (압축 별명) | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | x-gzip | 더 이상 사용되지 않음 (gzip의 별명) | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">업그레이드 토큰 레지스트리의 &quot;HTTP&quot;항목이 아래 등록으로 업데이트되었습니다 : + ------- + ---------------------- + ---------------------- + ------------- + | 가치 | 설명 | 예상 버전 | 참조 | | | | 토큰 | | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP | 하이퍼 텍스트 전송 | 모든 DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt; | | | 프로토콜 | (예 : &quot;2.0&quot;) | | + ------- + ---------------------- + ------------------ ---- + ------------- + 담당 당사자는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">요청의 &quot;호스트&quot;헤더 필드는 대상 URI에서 호스트 및 포트 정보를 제공하여 단일 IP 주소에서 여러 호스트 이름에 대한 요청을 처리하는 동안 오리진 서버가 자원을 구별 할 수있게합니다. 호스트 = uri-host [ &quot;:&quot;port]; &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; 클라이언트는 모든 HTTP / 1.1 요청 메시지에서 호스트 헤더 필드를 보내야한다. 대상 URI에 권한 구성 요소가 포함 된 경우, 클라이언트는 userinfo 하위 구성 요소 및 &quot;@&quot;분리 문자를 제외하고 해당 권한 구성 요소와 동일한 호스트에 대한 필드 값을 보내야합니다 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1).&lt;/a&gt;). 권한 URI 구성 요소가 대상 URI에 대해 누락되었거나 정의되지 않은 경우 클라이언트는 빈 필드 값으로 호스트 헤더 필드를 보내야합니다. 호스트 필드 값은 요청을 처리하기위한 중요한 정보이므로, 사용자 에이전트는 요청 라인 다음에 오는 첫 번째 헤더 필드로 호스트를 생성해야합니다 (SHOULD). 예를 들어, &amp;lt;http://www.example.org/pub/WWW/&amp;gt;에 대한 오리진 서버에 대한 GET 요청은 다음과 같이 시작합니다. GET / pub / WWW / HTTP / 1.1 호스트 : www.example.org 클라이언트는 반드시 있어야합니다. request-target이 절대 형식 인 경우에도 HTTP / 1.1 요청에서 Host header 필드를 보냅니다. 이렇게하면 Host를 구현하지 않았을 수있는 고대 HTTP / 1.0 프록시를 통해 Host 정보를 전달할 수 있습니다. 프록시가 절대 형식의 요청 대상으로 요청을 받으면,프록시는 수신 된 호스트 헤더 필드 (있는 경우)를 무시하고 대신 요청 대상의 호스트 정보로 대체해야합니다. 이러한 요청을 전달하는 프록시는 수신 된 호스트 필드 값을 전달하기보다는 수신 된 요청 대상을 기반으로 새 호스트 필드 값을 생성해야합니다. 호스트 헤더 필드는 응용 프로그램 수준 라우팅 메커니즘의 역할을하므로 공유 캐시를 감염 시키거나 의도하지 않은 서버로 요청을 리디렉션하려는 맬웨어의 대상이됩니다. 인터셉트 프록시는 인터셉트 된 연결이 해당 호스트의 유효한 IP 주소를 대상으로하는지 먼저 확인하지 않고 요청을 내부 서버로 리디렉션하거나 공유 캐시에서 캐시 키로 사용하기 위해 호스트 필드 값에 의존하는 경우 특히 취약합니다. .서버는 호스트 헤더 필드가없는 HTTP / 1.1 요청 메시지와 유효하지 않은 필드 값을 가진 호스트 헤더 필드 또는 둘 이상의 호스트 헤더 필드를 포함하는 모든 요청 메시지에 대해 400 (잘못된 요청) 상태 코드로 응답해야합니다. .</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 인증 체계 레지스트리&quot;는 인증 체계의 네임 스페이스를 도전 과제 및 자격 증명으로 정의합니다. &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt; 에서 작성되어 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 캐시 지시문 레지스트리&quot;는 캐시 지시문의 네임 스페이스를 정의합니다. 작성되었으며 현재 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 메소드 레지스트리&quot;는 요청 메소드 토큰의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ). 메소드 레지스트리가 작성되었으며 이제 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">&quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot;는 아래 등록으로 채워져 있습니다. + --------- + ------ + ------------ + --------------- + | 방법 | 안전 | dem 등원 | 참조 | + --------- + ------ + ------------ + --------------- + | 연결 | 아니요 | 아니요 | &lt;a href=&quot;#section-4.3.6&quot;&gt;섹션 4.3.6&lt;/a&gt; | | 삭제 | 아니요 | 예 | &lt;a href=&quot;#section-4.3.5&quot;&gt;섹션 4.3.5&lt;/a&gt; | | GET | 예 | 예 | &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; | | 헤드 | 예 | 예 | &lt;a href=&quot;#section-4.3.2&quot;&gt;섹션 4.3.2&lt;/a&gt; | | 옵션 | 예 | 예 | &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7 절&lt;/a&gt; | | POST | 아니요 | 아니요 | &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3&lt;/a&gt; | | 퍼팅 | 아니요 | 예 | &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; | | 트랙 | 예 | 예 |&lt;a href=&quot;#section-4.3.8&quot;&gt;섹션 4.3.8&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot;는 응답 상태 코드 토큰의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ). 상태 코드 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 유지됩니다 . 이 섹션은 이전 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;에 [RFC2817] 섹션 7.1&lt;/a&gt; 에서 정의 된 HTTP 상태 코드의 등록 절차를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록을 포함하도록 업데이트되었습니다. + ------- + ----------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + ----------------------- + ------------- + | 206 | 부분 내용 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 416 | 범위가 만족스럽지 않음 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록으로 업데이트되었습니다. + ------- + --------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + --------------------- + ------------- + | 304 | 수정되지 않음 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 412 | 전제 조건 실패 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록으로 업데이트되었습니다. + ------- + ------------------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + ------------------------------- + --------- ---- + | 401 | 무단 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | | 407 | 프록시 인증 필요 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 업그레이드 토큰 레지스트리&quot;는 업그레이드 헤더 필드에서 프로토콜을 식별하는 데 사용되는 프로토콜 이름 토큰의 네임 스페이스를 정의합니다. 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 경고 코드&quot;레지스트리는 경고 코드의 네임 스페이스를 정의합니다. 작성되었으며 현재 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">&quot;If-Match&quot;헤더 필드는 필드 값이 &quot;*&quot;인 경우 대상 자원의 현재 표현이 하나 이상 있거나 대상 자원의 현재 표현이있는 수신자 원 서버에서 요청 메소드를 조건부로 만듭니다. 필드 값에 제공된 엔티티 태그 목록의 멤버와 일치하는 엔티티 태그가 있습니다. 오리진 서버는 If-Match에 대한 엔티티 태그를 비교할 때 강력한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-2.3.2&quot;&gt;섹션 2.3.2).&lt;/a&gt;), 클라이언트는 표현 데이터에 변경이있는 경우 메소드가 적용되지 않도록이 전제 조건을 의도합니다. If-Match = &quot;*&quot;/ 1 # entity-tag 예 : If-Match : &quot;xyzzy&quot;If-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-Match : * If-Match는 가장 자주 사용됩니다 상태 변경 방법 (예 : POST, PUT, DELETE)은 여러 사용자 에이전트가 동일한 자원에서 병렬로 작동 할 때 우발적 인 덮어 쓰기를 방지합니다 (예 : &quot;손실 된 업데이트&quot;문제 방지). 선택한 표현이 이전 요청에서 이미 저장된 (또는 부분적으로 저장된) 것과 일치하지 않는 경우 요청을 중단하기 위해 안전한 방법과 함께 사용할 수도 있습니다.If-Match 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 (&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 필드 값이 &quot;*&quot;인 경우, 오리진 서버에 대상 자원에 대한 현재 표시가없는 경우 조건은 false입니다. 필드 값이 엔티티 태그 목록 인 경우 나열된 태그 중 선택된 표현의 엔티티 태그와 일치하는 태그가 없으면 조건이 false입니다. 수신 된 If-Match 조건이 false로 평가되면 오리진 서버는 요청 된 메소드를 수행해서는 안됩니다. 대신에, 오리진 서버는 a) 412 (전제 조건 실패) 상태 코드 또는 b) 오리진 서버가 상태 변경이 요청되고 최종 상태가 이미 있음을 확인한 경우 2xx (성공) 상태 코드 중 하나로 응답해야합니다. 대상 리소스의 현재 상태에 반영됩니다 (예 : 사용자 에이전트가 요청한 변경이 이미 성공했습니다.그러나 사전 응답이 유실되었거나 다른 사용자 에이전트가 호환 가능한 변경을 수행했기 때문에 사용자 에이전트가이를 인식하지 못할 수 있습니다. 후자의 경우, 오리진 서버는 요청이 동일한 사용자 에이전트가 수행 한 바로 이전 변경의 복제본임을 확인할 수 없다면 응답에 유효성 검사기 헤더 필드를 보내서는 안됩니다. If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-Modified-Since&quot;헤더 필드는 선택된 표현의 수정 날짜에 대한 GET 또는 HEAD 요청 방법을 필드 값에 제공된 날짜보다 최신 상태로 만듭니다. 데이터가 변경되지 않은 경우 선택한 표현의 데이터 전송을 피할 수 있습니다. If-Modified-Since = HTTP-date 필드의 예는 다음과 같습니다. If-Modified-Since : 토요일, 1994 년 10 월 29 일 19:43:31 GMT 수신자는 요청에 If-None이 포함 된 경우 If-Modified-Since를 무시해야합니다. 일치하는 헤더 필드; If-None-Match의 조건은 If-Modified-Since의 조건을 더 정확하게 대체하는 것으로 간주되며,이 둘은 If-None-Match를 구현하지 않을 수있는 구형 중개자와의 상호 운용을 위해 결합됩니다.수신 된 필드 값이 유효한 HTTP 날짜가 아니거나 요청 방법이 GET 또는 HEAD가 아닌 경우 수신자는 If-Modified-Since 헤더 필드를 무시해야합니다. 수신자는 If-Modified-Since 필드-값의 타임 스탬프를 오리진 서버의 시계로 해석해야합니다. If-Modified-Since는 일반적으로 다음 두 가지 목적으로 사용됩니다. 1) 엔티티 태그가없는 캐시 된 표현의 효율적인 업데이트 허용 및 2) 웹 탐색의 범위를 최근 변경된 자원으로 제한합니다. 캐시 업데이트에 사용될 때 캐시는 일반적으로 캐시 된 메시지의 Last-Modified 필드 값을 사용하여 If-Modified-Since의 필드 값을 생성합니다.이 동작은 시계가 제대로 동기화되지 않거나 서버가 정확한 타임 스탬프 일치 만 준수하도록 선택한 경우 (원래 서버의 시계가 수정 될 때 &quot;시간이 지남&quot;으로 보이는 마지막 수정 날짜의 문제로 인해) 가장 상호 운용성이 있습니다. 또는 아카이브 된 백업에서 표현이 복원됩니다). 그러나 캐시는 캐시 된 메시지의 날짜 헤더 필드 또는 메시지가 수신 된 로컬 클록 시간과 같은 다른 데이터, 특히 캐시 된 메시지에 Last-Modified 필드가없는 경우에 따라 필드 값을 생성하는 경우가 있습니다. 검색 범위를 최근 시간 창으로 제한하는 데 사용되는 경우,사용자 에이전트는 자신의 로컬 시계 또는 이전 응답으로 서버에서 수신 한 날짜 헤더 필드를 기반으로 If-Modified-Since 필드 값을 생성합니다. 선택한 표현의 Last-Modified 필드를 기반으로 정확한 타임 스탬프 일치를 선택하는 오리진 서버는 사용자 에이전트가 데이터 전송을 지정된 창에서 변경된 것만으로 제한하도록 도울 수 없습니다. If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다.If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다.If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다.&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ). 선택된 표현의 마지막 수정 날짜가 필드-값에 제공된 날짜보다 빠르거나 같으면 오리진 서버는 요청 된 방법을 수행해서는 안된다. 대신에, 오리진 서버는 이전에 캐시 된 응답을 식별하거나 업데이트하는데 유용한 메타 데이터만을 포함하여 304 (수정되지 않음) 응답을 생성해야한다 (SHOULD). 수신 된 If-Modified-Since 헤더 필드의 캐시 처리에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;은 [RFC7234] 4.3.2 절에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-None-Match&quot;헤더 필드는 필드 값이 &quot;*&quot;인 경우 대상 자원의 현재 표현이 없거나 수신자 값이 &quot;*&quot;인 경우 수신자 캐시 또는 오리진 서버에서 요청 메소드를 조건부로 만듭니다. 필드-값에 나열된 것과 일치하지 않는 엔티티 태그. 수신자는 If-None-Match에 대한 엔티티 태그를 비교할 때 약한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-2.3.2&quot;&gt;섹션 2.3.2).&lt;/a&gt;), 표현 데이터가 변경된 경우에도 약한 엔티티 태그를 캐시 유효성 검증에 사용할 수 있습니다. If-None-Match = &quot;*&quot;/ 1 # entity-tag 예 : If-None-Match : &quot;xyzzy&quot;If-None-Match : W / &quot;xyzzy&quot;If-None-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot; , &quot;c3piozzzz&quot;If-None-Match : W / &quot;xyzzy&quot;, W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot;If-None-Match : * If-None-Match는 주로 효율적인 업데이트를 위해 조건부 GET 요청에 사용됩니다. 최소한의 트랜잭션 오버 헤드로 캐시 된 정보 클라이언트가 엔티티 태그가있는 하나 이상의 저장된 응답을 업데이트하고자 할 때, 클라이언트는 GET 요청을 할 때 해당 엔티티 태그 목록을 포함하는 If-None-Match 헤더 필드를 생성해야합니다.이를 통해 수신자 서버는 304 (수정되지 않음) 응답을 보내 저장된 응답 중 하나가 선택된 표현과 일치하는시기를 표시 할 수 있습니다. If-None-Match를 &quot;*&quot;값과 함께 사용하여 클라이언트에 리소스에 현재 표현이 없다고 판단 될 때 안전하지 않은 요청 방법 (예 : PUT)이 대상 리소스의 기존 표현을 실수로 수정하지 못하게 할 수 있습니다. (클라이언트가 자원에 현재 표현이 없다고 판단 될 때 대상 자원의 기존 표현을 실수로 수정하지 않음클라이언트가 자원에 현재 표현이 없다고 판단 될 때 대상 자원의 기존 표현을 실수로 수정하지 않음&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; ). 이는 둘 이상의 클라이언트가 대상 자원에 대한 초기 표현을 작성하려고 시도 할 때 발생할 수있는 &quot;업데이트 손실&quot;문제의 변형입니다. If-None-Match 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 필드 값이 &quot;*&quot;인 경우, 오리진 서버에 대상 자원에 대한 현재 표시가 있으면 조건이 false입니다. 필드-값이 엔티티 태그 목록 인 경우, 나열된 태그 중 하나가 선택한 표현의 엔티티 태그와 일치하면 조건이 false입니다. 조건이 거짓으로 평가되면, 원 서버는 요청 된 방법을 수행해서는 안된다; 대신에, 오리진 서버는 반드시 a) 요청 방법이 GET 또는 HEAD 인 경우 304 (수정되지 않음) 상태 코드 또는 b) 다른 모든 요청 방법에 대한 412 (전제 조건 실패) 상태 코드로 응답해야합니다. 수신 된 If-None-Match 헤더 필드의 캐시 처리에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;은 [RFC7234] 4.3.2 절에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-Range&quot;헤더 필드는 If-Match 및 If-Unmodified-Since 헤더 필드와 유사하지만 유효성 검사기가 일치하지 않으면 수신자가 Range 헤더 필드를 무시하도록 지시하는 특수 조건부 요청 메커니즘을 제공합니다. 412 (사전 조건 실패) 응답 대신 새로 선택한 표현을 전송합니다. If-Range는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]의 섹션 3.2에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">&quot;If-Unmodified-Since&quot;헤더 필드는 선택된 표현의 마지막 수정 날짜에 대한 요청 방법을 필드 값에 제공된 날짜보다 빠르거나 같게 만듭니다. 이 필드는 사용자 에이전트에 표시 할 엔티티 태그가없는 경우 If-Match와 동일한 목적을 달성합니다. If-Unmodified-Since = HTTP-date 필드의 예는 다음과 같습니다. If-Unmodified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT 수신자는 요청에 If-Match가 포함 된 경우 If-Unmodified-Since를 무시해야합니다. 헤더 필드; If-Match의 조건은 If-Unmodified-Since의 조건을 더 정확하게 대체하는 것으로 간주되며,이 둘은 If-Match를 구현하지 않을 수있는 구 중개자와의 상호 운용을 위해서만 결합됩니다.수신 된 필드 값이 유효한 HTTP 날짜가 아닌 경우 수신자는 반드시 If-Unmodified-Since 헤더 필드를 무시해야합니다. 수신자는 If-Unmodified-Since 필드-값의 타임 스탬프를 오리진 서버의 시계로 해석해야합니다. If-Unmodified-Since는 상태 변경 방법 (예 : POST, PUT, DELETE)과 함께 여러 사용자 에이전트가 엔티티 태그에 해당 표현을 제공하지 않는 자원에 대해 병렬로 작동 할 때 우발적 인 덮어 쓰기를 방지하기 위해 가장 자주 사용됩니다 ( 즉, &quot;손실 된 업데이트&quot;문제를 방지하기 위해). 선택한 표현이 이전 요청에서 이미 저장된 (또는 부분적으로 저장된) 것과 일치하지 않는 경우 요청을 중단하기 위해 안전한 방법과 함께 사용할 수도 있습니다.If-Unmodified-Since 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 (&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 선택된 표현의 마지막 수정 날짜가 필드-값에 제공된 날짜보다 최신 인 경우, 원 서버는 요청 된 방법을 수행해서는 안된다; 대신 오리진 서버는 a) 412 (사전 조건 실패) 상태 코드 또는 b) 오리진 서버가 상태 변경이 요청되고 최종 상태가 이미 반영되었음을 확인한 경우 2xx (성공) 상태 코드 중 하나로 응답해야합니다. 대상 자원의 현재 상태 (예 : 사용자 에이전트가 요청한 변경이 이미 성공했지만 사용자 에이전트는 이전 응답 메시지가 유실되었거나 일부 다른 사용자 에이전트가 호환 가능한 변경을했기 때문에이를 인식하지 못할 수 있음) ). 후자의 경우에,오리진 서버는 요청이 동일한 사용자 에이전트가 변경 한 바로 이전의 복제본임을 확인할 수 없으면 응답에 유효성 검증기 헤더 필드를 보내서는 안됩니다. If-Unmodified-Since 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">응답의 &quot;Last-Modified&quot;헤더 필드는 요청 처리의 결론에 따라 원본 서버가 선택된 표현이 마지막으로 수정 된 것으로 생각한 날짜 및 시간을 나타내는 타임 스탬프를 제공합니다. Last-Modified = HTTP-date 사용 예는 Last-Modified : Tue, 1994 년 11 월 15 일 12:45:26 GMT</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">&quot;위치&quot;헤더 필드는 응답과 관련하여 특정 자원을 참조하기 위해 일부 응답에서 사용됩니다. 관계 유형은 요청 방법과 상태 코드 의미의 조합으로 정의됩니다. Location = URI-reference 필드 값은 단일 URI 참조로 구성됩니다. 상대 참조 형식 인 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], 섹션 4.2&lt;/a&gt; ), 최종 값은 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], 섹션 5)에&lt;/a&gt; 대해이를 해결하여 계산됩니다.). 201 (작성 됨) 응답의 경우 위치 값은 요청으로 작성된 1 차 자원을 나타냅니다. 3xx (리디렉션) 응답의 경우 Location 값은 요청을 자동으로 리디렉션하기위한 기본 대상 리소스를 나타냅니다. 3xx (리디렉션) 응답으로 제공된 Location 값에 프래그먼트 컴포넌트가없는 경우, 사용자 에이전트는 값이 요청 대상을 생성하는 데 사용 된 URI 참조의 프래그먼트 컴포넌트를 상속하는 것처럼 리디렉션을 처리해야합니다 (예 : 리디렉션이 상속 함) 원래 참조의 조각 (있는 경우). 예를 들어, URI 참조 &quot;http://www.example.org/~tim&quot;에 대해 생성 된 GET 요청은 헤더 필드 Location : / People을 포함하는 303 (기타 참조) 응답을 초래할 수 있습니다.html # tim은 사용자 에이전트가 &quot;http://www.example.org/People.html#tim&quot;으로 리디렉션하도록 제안합니다. 마찬가지로 URI 참조 &quot;http://www.example.org/index에 대해 GET 요청이 생성됩니다. .html # larry &quot;는 헤더 필드 Location : http://www.example.net/index.html을 포함하는 301 (영구적으로 이동) 응답으로 사용자 에이전트가&quot;http : // www. example.net/index.html#larry &quot;(원래 조각 식별자 유지) Location 값의 조각 식별자가 적절하지 않은 상황이 있습니다. 예를 들어, 201 (작성 됨) 응답의 위치 헤더 필드는 작성된 자원에 고유 한 URI를 제공해야합니다. 노트 :일부 수신자는 유효한 URI 참조가 아닌 위치 필드에서 복구를 시도합니다. 이 사양은 그러한 처리를 요구하거나 정의하지는 않지만 견고성을 위해 허용합니다. 참고 : Content-Location 헤더 필드 (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; )는 Content-Location이 동봉 된 표현에 해당하는 가장 구체적인 리소스를 참조한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 헤더 필드가 모두 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">&quot;Max-Forwards&quot;헤더 필드는 TRACE ( &lt;a href=&quot;#section-4.3.8&quot;&gt;섹션 4.3.8&lt;/a&gt; ) 및 OPTIONS ( &lt;a href=&quot;#section-4.3.7&quot;&gt;섹션 4.3.7&lt;/a&gt; )와 함께 메커니즘을 제공합니다.) 요청 메소드가 프록시가 요청을 전달하는 횟수를 제한합니다. 클라이언트가 실패하거나 중간 체인을 루핑하는 것처럼 보이는 요청을 추적하려고 할 때 유용 할 수 있습니다. Max-Forwards = 1 * DIGIT Max-Forwards 값은이 요청 메시지를 전달할 수있는 남은 횟수를 나타내는 십진 정수입니다. Max-Forwards 헤더 필드를 포함하는 TRACE 또는 OPTIONS 요청을받는 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야합니다. 수신 된 값이 영 (0)이면 중개자는 요청을 전달해서는 안됩니다. 대신 중개자는 반드시 최종 수령인으로 응답해야합니다. 수신 된 Max-Forwards 값이 0보다 큰 경우중개자는 전달 된 메시지에 업데이트 된 Max-Forwards 필드를 생성해야합니다. 수신자는 다른 요청 방법으로받은 Max-Forwards 헤더 필드를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">&quot;메시지 헤더&quot;레지스트리가 다음과 같은 영구 등록으로 업데이트되었습니다. + ------------------- + ---------- + --- ------- + ----------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ---------- + | 수락 | http | 표준 | &lt;a href=&quot;#section-5.3.2&quot;&gt;섹션 5.3.2&lt;/a&gt; | | 수락 문자 | http | 표준 | &lt;a href=&quot;#section-5.3.3&quot;&gt;섹션 5.3.3&lt;/a&gt; | | 수락 인코딩 | http | 표준 | &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; | | 수락 언어 | http | 표준 | &lt;a href=&quot;#section-5.3.5&quot;&gt;섹션 5.3.5&lt;/a&gt; | | 허용 | http | 표준 | &lt;a href=&quot;#section-7.4.1&quot;&gt;섹션 7.4.1&lt;/a&gt; | | 콘텐츠 인코딩 | http | 표준 | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;3.1.2.2 항&lt;/a&gt;| | 콘텐츠 언어 | http | 표준 | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;3.1.3.2 절&lt;/a&gt; | | 컨텐츠 위치 | http | 표준 | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; | | 컨텐츠 유형 | http | 표준 | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5 절&lt;/a&gt; | | 날짜 | http | 표준 | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 절&lt;/a&gt; | | 기대 | http | 표준 | &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; | | 보낸 사람 | http | 표준 | &lt;a href=&quot;#section-5.5.1&quot;&gt;섹션 5.5.1&lt;/a&gt; | | 위치 | http | 표준 | &lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; | | 맥스 포워드 | http | 표준 | &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; | | MIME 버전 | http | 표준 | &lt;a href=&quot;#appendix-A.1&quot;&gt;부록 A.1&lt;/a&gt; | | 리퍼러 | http | 표준 | &lt;a href=&quot;#section-5.5.2&quot;&gt;섹션 5.5.2&lt;/a&gt; | | 재시도 후 | http | 표준 | &lt;a href=&quot;#section-7.1.3&quot;&gt;섹션 7.1.3&lt;/a&gt; | | 서버 | http | 표준 | &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2 절&lt;/a&gt; | | 사용자 에이전트 | http | 표준 | &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; | | 다름 | http | 표준 | &lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- + 위의 등록을위한 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">&quot;Pragma&quot;헤더 필드는 HTTP / 1.0 캐시와의 역 호환성을 허용하므로 클라이언트는 이해할 수있는 &quot;캐시 없음&quot;요청을 지정할 수 있습니다 (Cache-Control이 HTTP / 1.1까지 정의되지 않았기 때문에). Cache-Control 헤더 필드가 존재하고 요청에 이해되면 Pragma는 무시됩니다. HTTP / 1.0에서 Pragma는 수신자에 대한 구현 지정 지시문의 확장 가능한 필드로 정의되었습니다. 이 사양에서는 상호 운용성을 향상시키기 위해 이러한 확장을 더 이상 사용하지 않습니다. Pragma = 1 # pragma-directive pragma-directive = &quot;no-cache&quot;/ extension-pragma extension-pragma = token [ &quot;=&quot;(token / quoted-string)] 요청에 Cache-Control 헤더 필드가없는 경우 ,캐시는 &quot;캐시 제어 : no-cache&quot;가 존재하는 것과 동일한 효과를 갖는 것으로 캐시없는 요청 pragma-directive를 고려해야합니다 (참조 &lt;a href=&quot;#section-5.2.1&quot;&gt;섹션 5.2.1&lt;/a&gt; ). 캐시없는 요청을 보낼 때, Cache-Control : no-cache가 HTTP / 1.1 캐시에서 다른 Cache-Control 응답 지시문을 대상으로하기 위해 의도적으로 생략되지 않는 한 클라이언트는 pragma 및 cache-control 지시문을 모두 포함해야합니다. 예 : GET / HTTP / 1.1 호스트 : www.example.com Cache-Control : max-age = 30 Pragma : no-cache는 HTTP / 1.1 캐시가 30 초 이하의 응답을 제공하도록 제한하고, 그렇지 않은 구현은 제외합니다. Cache-Control이 캐시 된 응답을 제공하는 것을 이해하지 못합니다. 참고 : 응답에서 &quot;Pragma : no-cache&quot;의 의미가 지정되어 있지 않기 때문에 &quot;Cache-Control : no-cache&quot;를 안정적으로 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">&quot;프록시 인증&quot;헤더 필드는이 유효 요청 URI에 대한 프록시에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 하나 이상의 시도로 구성됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt;). 프록시는 생성하는 각 407 (프록시 인증 필요) 응답에서 하나 이상의 프록시 인증 헤더 필드를 보내야합니다. Proxy-Authenticate = 1 # challenge WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 응답 체인의 다음 아웃 바운드 클라이언트에만 적용됩니다. 지정된 프록시를 선택한 클라이언트 만 인증에 필요한 자격 증명을 가지고 있기 때문입니다. 그러나 대기업 네트워크 내의 사무실 및 지역 캐싱 프록시와 같은 동일한 관리 도메인 내에서 여러 프록시를 사용하는 경우 사용자 에이전트가 자격 증명을 생성하여 소비 될 때까지 계층 구조를 통과하는 것이 일반적입니다. 따라서 이러한 구성에서는각 프록시가 동일한 챌린지 세트를 보내므로 프록시 인증이 전달되는 것처럼 나타납니다. WWW-Authenticate에 대한 구문 분석 고려 사항은이 헤더 필드에도 적용됩니다. 보다&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;자세한 내용 은 4.1 절 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">&quot;프록시 인증&quot;헤더 필드를 통해 클라이언트는 인증이 필요한 프록시로 자신 (또는 사용자)을 식별 할 수 있습니다. 이 값은 프록시 및 / 또는 요청되는 리소스 영역에 대한 클라이언트의 인증 정보를 포함하는 자격 증명으로 구성됩니다. Proxy-Authorization = 자격 증명 Authorization과 달리 Proxy-Authorization 헤더 필드는 Proxy-Authenticate 필드를 사용하여 인증을 요구 한 다음 인바운드 프록시에만 적용됩니다. 체인에서 여러 프록시를 사용하는 경우 프록시 인증 헤더 필드는 자격 증명을받을 것으로 예상되는 첫 번째 인바운드 프록시에서 사용됩니다.프록시가 프록시가 주어진 요청을 협력 적으로 인증하는 메커니즘 인 경우 프록시는 클라이언트 요청에서 다음 프록시로 자격 증명을 릴레이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">GET 요청의 &quot;범위&quot;헤더 필드는 전체 선택된 표현 데이터가 아닌 선택된 표현 데이터의 하나 이상의 하위 범위의 전송을 요청하도록 메소드 시맨틱을 수정합니다. Range = byte-ranges-specifier / other-ranges-specifier other-ranges-specifier = other-range-unit &quot;=&quot;other-range-set other-range-set = 1 * VCHAR 서버는 Range 헤더 필드를 무시할 수 있습니다. 그러나 Range는 부분적으로 실패한 전송 및 큰 표현의 부분 검색에서 효율적인 복구를 지원하므로 원 서버와 중간 캐시는 가능한 경우 바이트 범위를 지원해야합니다. 서버는 GET 이외의 요청 방법으로 수신 된 Range 헤더 필드를 무시해야합니다.오리진 서버는 이해하지 못하는 범위 단위를 포함하는 범위 헤더 필드를 무시해야합니다. 프록시는 이해하지 못하는 범위 단위를 포함하는 범위 헤더 필드를 폐기 할 수 있습니다. 범위 요청을 지원하는 서버는 둘 이상의 겹치는 범위 또는 오름차순으로 나열되지 않은 많은 작은 범위 세트로 구성된 범위 헤더 필드를 무시하거나 거부 할 수 있습니다. 둘 다 깨진 클라이언트 또는 의도적 인 표시이므로 서비스 거부 공격 (둘 다 클라이언트가 고장 났거나 고의적 인 서비스 거부 공격 (둘 다 클라이언트가 고장 났거나 고의적 인 서비스 거부 공격 (&lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ). 클라이언트는 동일한 데이터를 포함하는 단일 범위보다 본질적으로 처리 및 전송 효율성이 낮은 여러 범위를 요청해서는 안됩니다. 여러 범위를 요청하는 클라이언트는 이후 부분을 미리 요청해야하는 특별한 요구가없는 한 해당 범위를 오름차순으로 나열해야합니다 (일반적으로 전체 표현으로 수신되는 순서). 예를 들어, 내부 부품 카탈로그로 큰 표현을 처리하는 사용자 에이전트는 특히 표현이 역순으로 저장된 페이지로 구성되고 사용자 에이전트가 한 번에 한 페이지를 전송하려는 경우 나중에 부품을 요청해야 할 수 있습니다. 범위 헤더 필드는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232에&lt;/a&gt; 정의 된 전제 조건 헤더 필드를 평가 한 후 평가됩니다.]이며 범위 헤더 필드가없는 경우에만 200 (확인) 응답입니다. 즉, 조건부 GET으로 인해 304 (수정되지 않음) 응답이 발생하면 범위가 무시됩니다. If-Range 헤더 필드 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; )는 Range 헤더 필드를 적용하기위한 전제 조건으로 사용할 수 있습니다. 모든 전제 조건이 참이면, 서버는 대상 자원에 대한 범위 헤더 필드를 지원하고 지정된 범위가 유효하고 만족할 수 있고 ( &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1에&lt;/a&gt; 정의 된대로 ), 서버는 206 (부분 컨텐츠) 응답을 보내야합니다 &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의 된 바와 같이 요청 된 만족스러운 범위에 해당하는 하나 이상의 부분 표현을 포함하는 페이로드. 모든 전제 조건이 true이고 서버가 대상 자원에 대한 Range 헤더 필드를 지원하고 지정된 범위가 유효하지 않거나 만족할 수없는 경우 서버는 416 (Range Not Satisfiable) 응답을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">&quot;참조 자&quot;[sic] 헤더 필드를 사용하면 사용자 에이전트가 대상 URI를 확보 한 자원에 대한 URI 참조를 지정할 수 있습니다 (예 : 필드 이름의 철자가 틀리더라도 &quot;참조 자&quot;). 사용자 에이전트는 URI 참조의 프래그먼트 및 userinfo 구성 요소를 포함해서는 안된다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] (있는 경우) 참조 필드 값을 생성 할 때. Referer = absolute-URI / partial-URI Referer 헤더 필드를 통해 서버는 간단한 분석, 로깅, 최적화 된 캐싱 등을 위해 다른 리소스에 대한 백 링크를 생성 할 수 있습니다. 또한 유지 관리를 위해 더 이상 사용되지 않거나 잘못 입력 된 링크를 찾을 수 있습니다. 일부 서버는 다른 사이트의 링크 ( &quot;딥 링크&quot;라고 함)를 거부하거나 CSRF (Cross-Site Request Forgery)를 제한하는 수단으로 Referer 헤더 필드를 사용하지만 모든 요청에 ​​포함하지는 않습니다. 예 : 참조 자 : http://www.example.org/hypertext/Overview.html 대상 URI가 고유 URI가없는 소스 (예 : 사용자 키보드에서 입력 또는 사용자의 항목)에서 얻은 경우 북마크 / 즐겨 찾기),사용자 에이전트는 Referer 필드를 제외하거나 &quot;about : blank&quot;값으로 보내야합니다. Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 자원의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 자원 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 자원의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 자원 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 자원의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 자원 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다식별자는 개인 정보 (예 : 계정 이름) 또는 기밀 정보 (예 : 방화벽 뒤 또는 보안 서비스 내부)를 나타냅니다. 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다식별자는 개인 정보 (예 : 계정 이름) 또는 기밀 정보 (예 : 방화벽 뒤 또는 보안 서비스 내부)를 나타냅니다. 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다&lt;a href=&quot;#section-9.4&quot;&gt;&lt;/a&gt;추가적인 보안 고려 사항 은 9.4 절 . 일부 중개자는 발신 요청에서 Referer 헤더 필드를 무차별 적으로 제거하는 것으로 알려져 있습니다. 이는 CSRF 공격에 대한 보호 기능을 방해하여 사용자에게 훨씬 더 해로울 수있는 불행한 부작용이 있습니다. Referer에서 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및 / 또는 경로 구성 요소를 자르는 등 특정 편집으로 변경 사항을 제한해야합니다. 필드 값이 요청 대상과 동일한 체계 및 호스트를 공유하는 경우 중개자는 참조 헤더 필드를 수정하거나 삭제해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">&quot;서버&quot;헤더 필드에는 요청을 처리하기 위해 오리진 서버가 사용하는 소프트웨어에 대한 정보가 포함됩니다.이 정보는 클라이언트가보고 된 상호 운용성 문제의 범위를 식별하고 특정 서버 제한을 ​​피하기 위해 요청을 해결하거나 조정하기 위해 종종 사용합니다. 서버 또는 운영 체제 사용에 관한 분석 용. 오리진 서버는 응답에서 서버 필드를 생성 할 수 있습니다. 서버 = product * (RWS (product / comment)) 서버 필드 값은 하나 이상의 제품 식별자로 구성되며 각각 뒤에 0 개 이상의 주석이 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt;), 원본 서버 소프트웨어 및 주요 하위 제품을 함께 식별합니다. 일반적으로 제품 식별자는 원본 서버 소프트웨어를 식별하는 데있어 중요도에 따라 내림차순으로 나열됩니다. 각 제품 식별자는 &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3 절에&lt;/a&gt; 정의 된대로 이름과 선택적 버전으로 구성됩니다 . 예 : 서버 : CERN / 3.0 libwww / 2.17 오리진 서버는 불필요하게 세분화 된 세부 사항을 포함하는 서버 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 지나치게 길고 상세한 서버 필드 값은 응답 대기 시간을 증가시키고 잠재적으로 공격자가 알려진 보안 허점을 쉽게 찾고 이용할 수 있도록하는 내부 구현 세부 정보를 공개합니다.</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">요청의 &quot;TE&quot;헤더 필드는 청크 된 것 외에, 클라이언트가 응답으로 수락 할 의사가있는 것 및 클라이언트가 청크 된 전송 코딩에서 트레일러 필드를 허용 할 것인지의 여부를 나타낸다. TE 필드-값은 쉼표로 구분 된 전송 코딩 이름 목록으로 구성되며, 각각은 선택적 매개 변수를 허용합니다 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 설명 됨) ) 및 / 또는 키워드 &quot;예고편&quot; 클라이언트는 청크 된 전송 코딩 이름을 TE로 보내서는 안된다. 청크는 항상 HTTP / 1.1 수신자에게 허용됩니다. TE = # t- 코딩 t- 코딩 = &quot;트레일러&quot;/ (전송 코딩 [t- 순위]) t- 순위 = OWS &quot;;&quot; OWS &quot;q =&quot;rank rank = ( &quot;0&quot;[ &quot;.&quot;0 * 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;0 * 3 ( &quot;0&quot;)]) TE 사용의 세 가지 예는 다음과 같습니다. TE : deflate TE : TE : 트레일러, deflate; q = 0.5 &quot;트레일러&quot;라는 키워드가 있으면 고객이 &lt;a href=&quot;#section-4.1.2&quot;&gt;섹션 4.1.2에&lt;/a&gt; 정의 된대로 청크 분할 전송 코딩에서 트레일러 필드를 허용 할 것임을 나타냅니다.자체 및 다운 스트림 클라이언트를 대신하여 중개자 요청의 경우 이는 다음 중 하나를 의미합니다. (a) 모든 다운 스트림 클라이언트가 전달 된 응답에서 트레일러 필드를 기꺼이 수락합니다. 또는 (b) 중개자는 다운 스트림 수신자를 대신하여 응답을 버퍼링하려고 시도 할 것이다. HTTP / 1.1은 중개자가 전체 응답을 버퍼링 할 수 있도록 청크 응답의 크기를 제한하는 수단을 정의하지 않습니다. 다중 전송 코딩이 수용 가능한 경우, 클라이언트는 대소 문자를 구분하지 않는 &quot;q&quot;매개 변수를 사용하여 선호도에 따라 코딩 순위를 매길 수 있습니다 (콘텐츠 협상 필드에 사용 된 qvalue와 유사, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231의&lt;/a&gt; 섹션 5.3.1).]). 순위 값은 0에서 1 사이의 실수이며, 0.001이 가장 바람직하지 않고 1이 가장 선호됩니다. 0 값은 &quot;허용되지 않음&quot;을 의미합니다. TE 필드 값이 비어 있거나 TE 필드가 존재하지 않는 경우, 허용되는 전송 코드 만이 청크됩니다. 전송 코딩이없는 메시지는 항상 허용됩니다. TE 헤더 필드는 즉각적인 연결에만 적용되기 때문에 TE를 보낸 사람은 TE 필드가 지원하지 않는 중개자에 의해 전달되지 않도록하기 위해 Connection 헤더 필드 ( &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ) 내에 &quot;TE&quot;연결 옵션을 보내야합니다. 그것의 의미론.</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">&quot;업그레이드&quot;헤더 필드는 동일한 연결에서 HTTP / 1.1에서 다른 프로토콜로 전환하기위한 간단한 메커니즘을 제공하기위한 것입니다. 클라이언트는 요청의 업그레이드 헤더 필드에 프로토콜 목록을 전송하여 최종 응답을 보내기 전에 서버가 선호도의 내림차순으로 하나 이상의 프로토콜로 전환하도록 초대 할 수 있습니다. 해당 연결에서 현재 프로토콜을 계속 사용하려는 경우 서버는 수신 한 업그레이드 헤더 필드를 무시할 수 있습니다. 프로토콜 변경을 주장하는 데 업그레이드를 사용할 수 없습니다. 업그레이드 = 1 # 프로토콜 프로토콜 = 프로토콜 이름 [ &quot;/&quot;protocol-version] protocol-name = token protocol-version = token 101 (스위칭 프로토콜) 응답을 보내는 서버는 반드시 업그레이드 헤더 필드를 보내서 연결이 전환되는 새로운 프로토콜을 나타냅니다. 여러 프로토콜 계층이 전환되는 경우 발신자는 반드시 프로토콜을 계층 오름차순으로 나열해야합니다. 서버는 해당 요청의 업그레이드 헤더 필드에 클라이언트가 표시하지 않은 프로토콜로 전환해서는 안됩니다 (MUST NOT). 서버는 클라이언트가 나타내는 우선 순위를 무시하고 요청의 성격 또는 서버의 현재 부하와 같은 다른 요인에 따라 새 프로토콜을 선택할 수 있습니다. 426 (업그레이드 필요) 응답을 보내는 서버는 반드시 허용 가능한 프로토콜을 나타 내기 위해 업그레이드 헤더 필드를 보내야합니다.내림차순으로. 서버는 다른 요청에 업그레이드 헤더 필드를 보내 향후 요청에 적합 할 경우 나열된 프로토콜로의 업그레이드 지원을 내림차순으로 구현할 수 있음을 알릴 수 있습니다. 다음은 클라이언트가 보낸 가상의 예입니다. GET /hello.txt HTTP / 1.1 호스트 : www.example.com 연결 : 업그레이드 업그레이드 : HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 기능 및 특성 프로토콜 변경 후 애플리케이션 레벨 통신의 선택은 전적으로 선택된 새로운 프로토콜 (들)에 의존한다. 그러나 101 (Switching Protocols) 응답을 보낸 직후 서버는 마치 새 프로토콜 내에서 동등한 요청을받은 것처럼 원래 요청에 계속 응답해야합니다 (예 :프로토콜이 변경된 후에도 서버는 여전히 충족해야 할 미해결 요청을 가지고 있으며 요청을 반복하지 않고도 그렇게 할 것으로 예상됩니다). 예를 들어, 업그레이드 헤더 필드가 GET 요청에서 수신되고 서버가 프로토콜을 전환하기로 결정한 경우, 먼저 HTTP / 1.1에서 101 (스위칭 프로토콜) 메시지로 응답 한 다음 새 프로토콜의 응답에 해당하는 것을 즉시 따릅니다. 대상 자원의 GET에. 이를 통해 추가 왕복의 대기 시간 비용없이 HTTP와 동일한 의미를 가진 프로토콜로 연결을 업그레이드 할 수 있습니다. 수신 된 메시지 시맨틱이 새로운 프로토콜에 의해 존중 될 수 없다면 서버는 프로토콜을 전환해서는 안된다; 모든 프로토콜에서 OPTIONS 요청을 처리 할 수 ​​있습니다.다음은 위의 가상 요청에 대한 응답 예입니다. HTTP / 1.1 101 스위칭 프로토콜 연결 : 업그레이드 업그레이드 : HTTP / 2.0 [... 데이터 스트림은 적절한 프로토콜 (새 프로토콜에 정의 된대로)을 사용하여 HTTP / 2.0으로 전환합니다. &quot;GET /hello.txt&quot;request ...] 업그레이드가 전송되면 발신자는 반드시 연결 헤더 필드 (&lt;a href=&quot;#section-6.1&quot;&gt;&lt;/a&gt;나열된 프로토콜을 구현하지 않을 수있는 중개자가 업그레이드를 실수로 전달하지 못하도록하기 위해 &quot;업그레이드&quot;연결 옵션이 포함 된 섹션 6.1 ). 서버는 HTTP / 1.0 요청에서 수신 된 업그레이드 헤더 필드를 무시해야합니다. 클라이언트는 요청 메시지를 완전히 보낼 때까지 연결에서 업그레이드 된 프로토콜을 사용할 수 없습니다 (예 : 클라이언트는 메시지 중간에 보내는 프로토콜을 변경할 수 없음). 서버가 &quot;100-continue&quot;예상으로 업그레이드 및 Expect 헤더 필드를 모두 수신하는 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;[RFC7231]의 5.1.1 절&lt;/a&gt;) 서버는 반드시 101 (Switching Protocols) 응답을 보내기 전에 100 (Continue) 응답을 보내야합니다. 업그레이드 헤더 필드는 기존 연결 위에있는 프로토콜 전환에만 적용됩니다. 기본 연결 (전송) 프로토콜을 전환하거나 기존 통신을 다른 연결로 전환하는 데 사용할 수 없습니다. 이러한 목적으로 3xx (리디렉션) 응답을 사용하는 것이 더 적절합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;[RFC7231]의 섹션 6.4&lt;/a&gt; ). 이 사양은 &lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt; 의 HTTP 버전 규칙 과이 사양에 대한 향후 업데이트에 정의 된대로 하이퍼 텍스트 전송 프로토콜 제품군에서 사용할 프로토콜 이름 &quot;HTTP&quot;만 정의합니다 . 추가 토큰은에 정의 된 등록 절차를 사용하여 IANA에 등록해야합니다.&lt;a href=&quot;#section-8.6&quot;&gt;섹션 8.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">&quot;사용자 에이전트&quot;헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함됩니다.이 에이전트는 종종 서버에서보고 된 상호 운용성 문제의 범위를 식별하고 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하거나 조정하여 분석에 사용합니다. 브라우저 또는 운영 체제 사용과 관련하여. 사용자 에이전트는 특별히 요청하지 않는 한 각 요청마다 사용자 에이전트 필드를 보내야합니다. User-Agent = product * (RWS (product / comment)) User-Agent 필드 값은 하나 이상의 제품 식별자로 구성되며 각각 뒤에 0 개 이상의 주석이 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt;)는 사용자 에이전트 소프트웨어 및 중요한 하위 제품을 함께 식별합니다. 일반적으로 제품 식별자는 사용자 에이전트 소프트웨어를 식별하는 데있어 중요도에 따라 내림차순으로 나열됩니다. 각 제품 식별자는 이름과 선택적 버전으로 구성됩니다. product = token [ &quot;/&quot;product-version] product-version = token 발신자는 생성 된 제품 식별자를 제품을 식별하는 데 필요한 것으로 제한해야합니다. 발신자는 제품 식별자 내에 광고 또는 기타 중요하지 않은 정보를 생성해서는 안됩니다. 발신자는 버전 식별자가 아닌 제품 버전의 정보를 생성하지 않아야합니다 (즉, 동일한 제품 이름의 연속 버전은 제품 식별자의 제품 버전 부분에서만 달라야 함). 예:사용자 에이전트 : CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에서 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로보고 싶어한다고 가정 할 수 있습니다.CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에서 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로보고 싶어한다고 가정 할 수 있습니다.CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에서 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로보고 싶어한다고 가정 할 수 있습니다.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에서 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로보고 싶어한다고 가정 할 수 있습니다.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에서 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로보고 싶어한다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">응답의 &quot;Vary&quot;헤더 필드는 메소드, 호스트 헤더 필드 및 요청 대상 외에 요청 메시지의 어떤 부분이이 응답을 선택하고 나타내는 오리진 서버의 프로세스에 영향을 줄 수 있는지를 설명합니다. 값은 단일 별표 ( &quot;*&quot;) 또는 헤더 필드 이름 목록 (대소 문자 구분)으로 구성됩니다. Vary = &quot;*&quot;/ 1 # field-name &quot;*&quot;의 Vary 필드 값은 요청에 대한 모든 것이 메시지 표현 외부의 요소 (예 : 클라이언트의 네트워크 주소)를 포함하여 응답 표현을 선택하는 데 역할을 할 수 있음을 나타냅니다. . 수신자는 요청을 오리진 서버로 전달하지 않고이 응답이 이후 요청에 적합한 지 여부를 결정할 수 없습니다.프록시는 &quot;*&quot;값을 가진 Vary 필드를 생성해서는 안됩니다 (MUST NOT). 쉼표로 구분 된 이름 목록으로 구성된 Vary 필드 값은 선택 헤더 필드라고하는 명명 된 요청 헤더 필드가 표현 선택에 역할을 할 수 있음을 나타냅니다. 잠재적 인 선택 헤더 필드는 본 명세서에 의해 정의 된 것으로 제한되지 않는다. 예를 들어 Vary : accept-encoding, accept-language가 포함 된 응답은 오리진 서버가이 응답에 대한 컨텐츠를 선택하는 동안 요청의 Accept-Encoding 및 Accept-Language 필드 (또는 결여)를 결정 요인으로 사용했음을 나타냅니다. 오리진 서버는 다음 두 가지 목적으로 Vary를 필드 목록과 함께 보낼 수 있습니다.이후 요청이 원래 요청과 나열된 필드에 대해 동일한 값을 가지지 않는 한 이후 요청을 만족시키기 위해이 응답을 사용해서는 안된다는 것을 캐시 수신자에게 알리기 위해 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;[RFC7234] 섹션 4.1&lt;/a&gt; ). 즉, Vary는 새 요청을 저장된 캐시 항목과 일치시키는 데 필요한 캐시 키를 확장합니다. 2. 사용자 에이전트 수신자에게이 응답에 콘텐츠 협상이 적용됨을 알리기 위해 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;) 및 추가 헤더가 나열된 헤더 필드에 제공되면 (사전 협상) 다른 요청이 후속 요청에서 전송 될 수 있습니다. 분산을 넘길 수 없거나 캐시 투명성을 방지하기 위해 의도적으로 오리진 서버가 구성되지 않은 한, 표현을 선택하기위한 알고리즘이 방법 및 요청 대상 이외의 요청 메시지의 측면에 기초하여 변할 때 오리진 서버는 Vary 헤더 필드를 보내야한다 (SHOULD). . 예를 들어, 사용자 간 재사용이 필드 정의에 의해 제한되므로 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235] 섹션 4.2)&lt;/a&gt; Vary에서 Authorization 필드 이름을 보낼 필요가 없습니다 . 마찬가지로 오리진 서버는 캐시 제어 지시문을 사용할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절&lt;/a&gt;Vary가 캐싱에 미치는 영향의 성능 비용보다 차이가 덜 중요하다고 판단되는 경우 Vary를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">&quot;Via&quot;헤더 필드는 이메일의 &quot;수신 된&quot;헤더 필드와 유사하게 사용자 에이전트와 서버 사이 (요청시) 또는 오리진 서버와 클라이언트 사이 (응답시)에 중간 프로토콜과 수신자가 있음을 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;섹션 [RFC5322]의 3.6.7&lt;/a&gt; ). Via는 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 발신자의 프로토콜 기능을 식별하는 데 사용할 수 있습니다. Via = 1 # (수신 된 프로토콜 RWS에 의해 수신 된 RWS) received-protocol = [프로토콜 이름 &quot;/&quot;] protocol-version; &lt;a href=&quot;#section-6.7&quot;&gt;섹션 6.7&lt;/a&gt; 참조 received-by = (uri-host [ &quot;:&quot;port]) / pseudonym pseudonym = token 다중 Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다. 각 중개자는 메시지 수신 방법에 대한 자체 정보를 추가하여 최종 결과가 전달 수신자 순서에 따라 정렬되도록합니다. 프록시는 아래에 설명 된대로 전달하는 각 메시지에 적절한 Via 헤더 필드를 보내야합니다. HTTP-to-HTTP 게이트웨이는 각 인바운드 요청 메시지에서 적절한 Via 헤더 필드를 보내야하고 전달 된 응답 메시지에서 Via 헤더 필드를 보낼 수 있습니다. 각 중개자에 대해 수신 된 프로토콜은 메시지의 업스트림 발신자가 사용하는 프로토콜 및 프로토콜 버전을 나타냅니다. 그 후,Via 필드 값은 요청 / 응답 체인의 알려진 프로토콜 기능을 다운 스트림 수신자가 볼 수 있도록 기록합니다. 이는 이전 버전과 호환되지 않는 기능이 응답 또는 나중에 요청에서 사용하기에 안전한지 확인하는 데 유용 할 수 있습니다.&lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt;. 간결하게하기 위해 수신 된 프로토콜이 HTTP 인 경우 protocol-name이 생략됩니다. 필드 값의 수신 한 부분은 일반적으로 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되면 발신인은이를 가명으로 대체 할 수 있습니다. 포트가 제공되지 않으면, 수신자는 수신 된 프로토콜에 대해 기본 TCP 포트 (있는 경우)에서 수신되었음을 의미하는 것으로 해석 할 수 있습니다. 발신자는 사용자 헤더 및 서버 헤더 필드와 유사하게 각 수신자의 소프트웨어를 식별하기 위해 Via 헤더 필드에 주석을 생성 할 수 있습니다. 그러나 Via 필드의 모든 주석은 선택 사항이며 수신자는 메시지를 전달하기 전에 주석을 제거 할 수 있습니다. 예를 들어요청 메시지는 HTTP / 1.0 사용자 에이전트에서 내부 프록시 코드 이름 &quot;fred&quot;로 전송 될 수 있습니다.이 프록시는 HTTP / 1.1을 사용하여 p.example.net의 공개 프록시로 요청을 전달합니다. www.example.com의 오리진 서버로 연결하십시오. www.example.com이 수신 한 요청에는 다음 Via 헤더 필드가 있습니다. Via : 1.0 fred, 1.1 p.example.net 네트워크 방화벽을 통해 포털로 사용되는 중개자는 호스트 이름과 포트를 전달해서는 안됩니다. 방화벽 영역이 명시 적으로 활성화되지 않은 경우 방화벽 영역 활성화되지 않은 경우, 그러한 중개자는 방화벽 뒤에있는 호스트의 각 수신 호스트를 해당 호스트에 대한 적절한 가명으로 교체해야합니다.항목이 동일한 수신 프로토콜 값을 갖는 경우 중개자는 Via 헤더 필드 항목의 순서가 지정된 서브 시퀀스를 단일 항목으로 결합 할 수있다. 예를 들어, Via : 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy는 Via : 1.0 ricky, 1.1 mertz, 1.0 lucy로 축소 될 수 있습니다. 발송인은 모두 같은 조직 제어하에 있지 않고 호스트가 이미 가명으로 대체되었습니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).0 lucy 발신자는 모두 같은 조직 통제하에 있고 호스트가 이미 가명으로 대체되지 않는 한 여러 항목을 결합해서는 안됩니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).0 lucy 발신자는 모두 같은 조직 통제하에 있고 호스트가 이미 가명으로 대체되지 않는 한 여러 항목을 결합해서는 안됩니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">&quot;WWW-Authenticate&quot;헤더 필드는 대상 자원에 적용 가능한 인증 체계 및 매개 변수를 나타냅니다. WWW-Authenticate = 1 # challenge 401 (무단) 응답을 생성하는 서버는 적어도 하나의 시도를 포함하는 WWW-Authenticate 헤더 필드를 보내야합니다. 서버는 다른 응답 메시지에 WWW-Authenticate 헤더 필드를 생성하여 자격 증명 (또는 다른 자격 증명)을 제공하면 응답에 영향을 줄 수 있음을 나타낼 수 있습니다. 응답을 전달하는 프록시는 해당 응답의 WWW 인증 필드를 수정해서는 안됩니다. 사용자 에이전트는 필드 값을 구문 분석 할 때 특히주의해야합니다. 필드 값은 둘 이상의 시도를 포함 할 수 있으며 각 시도는 쉼표로 구분 된 인증 매개 변수 목록을 포함 할 수 있습니다. 더욱이,헤더 필드 자체는 여러 번 발생할 수 있습니다. 예 : WWW-Authenticate : Newauth realm = &quot;apps&quot;, type = 1, title = &quot;\&quot;apps \ &quot;&quot;에 로그인, 기본 realm = &quot;simple&quot;이 헤더 필드에는 두 가지 과제가 있습니다. 하나는 영역 값이 &quot;apps&quot;인 &quot;Newauth&quot;체계를위한 것이고 두 개의 추가 매개 변수는 &quot;type&quot;과 &quot;title&quot;이고 다른 하나는 영역 값이 &quot;simple&quot;인 &quot;Basic&quot;체계를위한 것입니다. 참고 : 챌린지 문법 제작은 목록 구문도 사용합니다. 따라서 쉼표, 공백 및 쉼표 시퀀스는 이전 챌린지에 적용되거나 챌린지 목록의 빈 항목으로 간주 될 수 있습니다. 실제로,이 모호성은 헤더 필드 값의 의미론에 영향을 미치지 않으므로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">&quot;경고&quot;헤더 필드는 상태 코드에 반영되지 않을 수있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용됩니다. 이 정보는 일반적으로 메시지의 페이로드에 적용된 캐싱 조작 또는 변환으로 인해 발생할 수있는 부정확성을 경고하는 데 사용됩니다. 캐시 관련 및 기타 다른 목적으로 경고를 사용할 수 있습니다. 오류 상태 코드 대신 경고를 사용하면 이러한 응답이 실제 실패와 구분됩니다. 경고 헤더 필드는 일반적으로 모든 메시지에 적용 할 수 있지만 일부 경고 코드는 캐시에만 적용되며 응답 메시지에만 적용 할 수 있습니다.경고 = 1 # 경고 값 경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트 [SP 경고 날짜] 경고 코드 = 3DIGIT 경고 에이전트 = (uri-host [ &quot;:&quot;포트]) / 가명 ; 추가하는 서버의 이름 또는 가명; 디버깅에 사용되는 경고 헤더 필드; 에이전트가 알려지지 않은 경우 단일 &quot;-&quot;가 권장됩니다. 경고 텍스트 만 다른 동일한 경고 코드 번호 하나 이상의 경고 헤더 필드를받는 사용자 에이전트는 가능한 많은 필드를 사용자에게 알려야합니다.응답에 나타나는 순서대로. 여러 경고 헤더 필드를 생성하는 발신인은이 사용자 에이전트 동작을 염두에두고 주문하는 것이 좋습니다. 새로운 경고 헤더 필드를 생성하는 발신자는 기존 경고 헤더 필드 뒤에 추가해야합니다. 경고에는 세 자리 경고 코드가 할당됩니다. 첫 번째 숫자는 유효성 검증 후 저장된 응답에서 경고를 삭제해야하는지 여부를 나타냅니다. o 1xx 경고 코드는 응답의 최신 성 또는 유효성 검증 상태를 설명하므로 유효성 검증 후 캐시에 의해 삭제되어야합니다. 캐시 된 항목의 유효성을 검사 할 때 캐시에 의해서만 생성 될 수 있으며 다른 상황에서는 생성되지 않아야합니다.o 2xx 경고 코드는 유효성 검증에 의해 수정되지 않은 표현의 일부 측면을 설명하며 (예를 들어, 표현의 손실 압축) 전체 응답이 전송되지 않는 한 유효성 검증 후 캐시에 의해 삭제되지 않아야합니다. 경우에 따라야합니다. 발신자가 메시지에 HTTP / 1.0 만 구현하는 것으로 알려진 수신자에게 전송 될 하나 이상의 1xx 경고 코드를 생성하는 경우 발신자는 각 해당 경고 값에 경고의 날짜 헤더 필드와 일치하는 경고 날짜를 포함해야합니다. 메시지. 예 : HTTP / 1.1 200 OK 날짜 : 2012 년 8 월 25 일 토요일 23:34:45 GMT 경고 : 112- &quot;네트워크 중단&quot; &quot;2012 년 8 월 25 일 토요일 23:34:45 GMT&quot;경고에는 경고 텍스트가 포함되어 있습니다. 예를 들어 로깅과 같은 오류. 자문 일뿐입니다그 내용은 경고 코드의 해석에 영향을 미치지 않습니다. 경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는또는 경고 헤더 필드에 동일한 메시지의 날짜 값과 다른 경고 날짜가 표시되면 수신자는 메시지를 저장, 전달 또는 사용하기 전에 경고 날짜가 포함 된 경고 값을 제외해야합니다. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는또는 경고 헤더 필드에 동일한 메시지의 날짜 값과 다른 경고 날짜가 표시되면 수신자는 메시지를 저장, 전달 또는 사용하기 전에 경고 날짜가 포함 된 경고 값을 제외해야합니다. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는 &lt;a href=&quot;#section-7.2.1&quot;&gt;섹션 7.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">&quot;app : categories&quot;요소는 Collection의 멤버에 적용 할 수있는 카테고리 목록을 제공합니다. app : categories의 자세한 정의는 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1 절을&lt;/a&gt; 참조하십시오 . 서버는 범주 목록에 범주가없는 구성원을 만들거나 저장하려는 시도를 거부 할 수 있습니다. 카테고리 세트가 열려 있음을 나타내는 컬렉션은 카테고리가 카테고리 목록에없는 다른 허용 가능한 멤버를 거부해서는 안됩니다 (SHOULD NOT). app : categories 요소가 없다는 것은 Collection의 카테고리 처리가 지정되지 않았 음을 의미합니다. 범주가 0 인 &quot;고정&quot;범주 목록은 컬렉션이 범주 데이터를 허용하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">&quot;app : collection&quot;요소는 Collection을 설명합니다. app : collection 요소는 atom : title 요소를 포함해야합니다. app : collection 요소는 Collection에 의해 허용되는 표현의 유형을 나타내는 app : accept 요소를 얼마든지 포함 할 수 있습니다. 이러한 요소의 순서는 중요하지 않습니다. app : collection 요소는 app : categories 요소를 포함 할 수 있습니다. appCollection = 요소 app : collection {appCommonAttributes, 속성 href {atomURI}, (atomTitle &amp;amp; appAccept * &amp;amp; appCategories * &amp;amp; extensionSansTitleElement *)}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">&quot;app : edited&quot;요소는 날짜 구성 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 의해 정의 됨 )이며, 해당 내용은 항목이 마지막으로 편집 된 시간을 나타냅니다. 항목이 아직 편집되지 않은 경우 내용은 생성 된 시간을 나타냅니다. 컬렉션 문서의 원자 엔트리 요소는 하나의 app : edited 요소를 포함해야하며, 둘 이상의 요소를 포함해서는 안됩니다. appEdited = element app : edited (atomDateConstruct) 서버는 Entry Resource 또는 관련 Media Resource가 편집 될 때마다이 요소의 값을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">&quot;atom : title&quot;요소는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 정의되어 있으며, 사람이 읽을 수있는 컬렉션 제목을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">&quot;압축&quot;코딩은 UNIX 파일 압축 프로그램 &quot;압축&quot;에 의해 일반적으로 생성되는 LZW (Adaptive Lempel-Ziv-Welch) 코딩 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ]입니다. 수신자는 &quot;x-compress&quot;를 &quot;compress&quot;와 동등한 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">&quot;데이터&quot;URL 체계</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">&quot;deflate&quot;코딩은 Lempel-Ziv (LZ77) 압축 알고리즘과 Huffman 코딩의 조합을 사용하는 &quot;deflate&quot;압축 데이터 스트림 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]을 포함 하는 &quot;zlib&quot;데이터 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ] 입니다. 참고 : 일부 부적합한 구현에서는 zlib 래퍼없이 &quot;deflate&quot;압축 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">&quot;gzip&quot;코딩은 gzip 파일 압축 프로그램 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ]에 의해 일반적으로 생성되는 32 비트 CRC (Cyclic Redundancy Check)를 사용하는 LZ77 코딩입니다 . 수신자는 &quot;x-gzip&quot;을 &quot;gzip&quot;과 동등한 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">&quot;http&quot;URI 스킴은 주어진 포트에서 TCP ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt; ]) 연결을 청취하는 잠재적 HTTP 오리진 서버에 의해 관리되는 계층 적 네임 스페이스와의 연관성에 따라 식별 식별자를 작성하기 위해 정의됩니다 . http-URI = &quot;http :&quot; &quot;//&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;#&quot;fragment] &quot;http&quot;URI의 오리진 서버는 권한 구성 요소로 식별되며 여기에는 호스트 ID 및 선택적 TCP 포트가 포함되어 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], 섹션 3.2.2&lt;/a&gt;). 계층 적 경로 구성 요소 및 선택적 쿼리 구성 요소는 해당 원본 서버의 네임 스페이스 내에서 잠재적 인 대상 리소스의 식별자로 사용됩니다. 선택적 프래그먼트 컴포넌트는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]의 3.5 절에&lt;/a&gt; 정의 된대로 URI 체계와 무관하게 보조 리소스를 간접적으로 식별 할 수 있습니다 .. 발신자는 빈 호스트 식별자로 &quot;http&quot;URI를 생성해서는 안됩니다 (MUST NOT). 이러한 URI 참조를 처리하는 수신자는이를 무효로 거부해야합니다. 호스트 ID가 IP 주소로 제공되는 경우, 오리진 서버는 해당 IP 주소에서 표시된 TCP 포트의 리스너 (있는 경우)입니다. 호스트가 등록 된 이름 인 경우 등록 된 이름은 DNS와 같은 이름 확인 서비스에서 해당 원본 서버의 주소를 찾기위한 간접 식별자입니다. 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 TCP 포트 80 (WWW 서비스 용 예약 포트)이 기본값입니다. 지정된 권한 구성 요소가있는 URI가 있다고해서 해당 호스트 및 포트에서 연결을 청취하는 HTTP 서버가 항상 있음을 의미하지는 않습니다. 누구나 URI를 작성할 수 있습니다.권한 구성 요소가 판별하는 것은 식별 된 자원을 대상으로하는 요청에 정식으로 응답 할 권한이있는 사람입니다. 등록 된 이름 및 IP 주소의 위임 된 특성은 HTTP 서버의 존재 여부에 관계없이 표시된 호스트 및 포트에 대한 제어를 기반으로 연합 네임 스페이스를 만듭니다. 보다&lt;a href=&quot;#section-9.1&quot;&gt;&lt;/a&gt;권한 설정과 관련된 보안 고려 사항에 대한 섹션 9.1 . &quot;http&quot;URI가 표시된 리소스에 대한 액세스를 요청하는 컨텍스트 내에서 사용될 경우 클라이언트는 호스트를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 TCP 연결을 설정하고 HTTP를 전송하여 액세스를 시도 할 수 있습니다. 서버에 URI의 식별 데이터를 포함하는 요청 메시지 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; ) ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ). &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]의 6 절에&lt;/a&gt; 설명 된 것처럼 서버가 임시가 아닌 HTTP 응답 메시지로 해당 요청에 응답하는 경우이 응답은 고객의 요청에 대한 정식 답변으로 간주됩니다. HTTP는 전송 프로토콜과 독립적이지만 &quot;http&quot;체계는 이름 위임 프로세스가 권한을 설정하기 위해 TCP에 의존하기 때문에 TCP 기반 서비스에만 적용됩니다. &quot;https&quot;체계 (아래)가 종단 간 보안 연결이 필요한 자원에 사용되는 것처럼 다른 기본 연결 프로토콜을 기반으로하는 HTTP 서비스는 다른 URI 체계를 사용하여 식별 될 수 있습니다. &quot;http&quot;로 식별 된 리소스에 대한 액세스를 제공하기 위해 다른 프로토콜이 사용될 수도 있습니다. TCP와 관련된 권한있는 인터페이스 일뿐입니다. 권한에 대한 URI 일반 구문에는 더 이상 사용되지 않는 userinfo 하위 구성 요소 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], 섹션 3.2&lt;/a&gt; 도 포함됩니다 .1URI에 사용자 인증 정보를 포함합니다. 일부 구현에서는 명령 호출 옵션, 구성 파일 또는 책갈피 목록 내에서와 같이 인증 정보의 내부 구성에 userinfo 구성 요소를 사용하지만 이러한 사용법으로 인해 사용자 ID 또는 비밀번호가 노출 될 수 있습니다. 발신인은 &quot;http&quot;URI 참조가 요청 대상 또는 헤더 필드 값으로 메시지 내에 생성 될 때 userinfo 하위 구성 요소 (및 &quot;@&quot;분리 문자)를 생성해서는 안됩니다 (MUST NOT). 신뢰할 수없는 출처로부터받은 &quot;http&quot;URI 참조를 사용하기 전에 수신자는 userinfo를 구문 분석하고 그 존재를 오류로 처리해야합니다. 피싱 공격에 대한 권한을 가릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">&quot;http&quot;체계는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL에 대한 체계 별 구문과 의미를 정의합니다. http_URL = &quot;http :&quot; &quot;//&quot;호스트 [ &quot;:&quot;port] [abs_path [ &quot;?&quot; query]] 포트가 비어 있거나 제공되지 않으면 포트 80이 사용됩니다. 시맨틱은 식별 된 자원이 해당 호스트의 해당 포트에서 TCP 연결을 청취하는 서버에 위치하고 자원의 Request-URI가 abs_path ( &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2 절&lt;/a&gt; )라는 것입니다. URL에서 IP 주소 사용은 가능하면 피해야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ] 참조). 만약 abs_path가 URL에 존재하지 않는다면, 리소스의 Request-URI로 사용될 때 반드시 &quot;/&quot;로 주어져야한다 &lt;a href=&quot;#section-5.1.2&quot;&gt;(5.1 절).2&lt;/a&gt;). 프록시가 정규화 된 도메인 이름이 아닌 호스트 이름을 수신하면 수신 한 호스트 이름에 도메인을 추가 할 수 있습니다. 프록시가 정규화 된 도메인 이름을 수신하면 프록시는 호스트 이름을 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">&quot;https&quot;URI 스킴은 TLS 보안 연결을 위해 주어진 TCP 포트를 수신하는 잠재적 HTTP 오리진 서버에 의해 관리되는 계층 적 네임 스페이스와의 연관성에 따라 식별 식별자를 작성하기 위해 정의됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246).&lt;/a&gt;]). 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 TCP 포트 443이 기본값이고 사용자 에이전트가 반드시 연결을 확인해야한다는 점을 제외하고, &quot;http&quot;체계에 대해 위에 나열된 모든 요구 사항은 &quot;https&quot;체계에 대한 요구 사항이기도합니다. 오리진 서버는 첫 번째 HTTP 요청을 보내기 전에 엔드 투 엔드 (end-to-end) 강력한 암호화를 통해 보안됩니다. https-URI = &quot;https :&quot; &quot;//&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;# fragment fragment]&quot;https &quot;URI 스킴은 권한 설정을 위해 TLS와 TCP에 따라 다릅니다. &quot;https&quot;체계를 통해 사용 가능한 자원은 &quot;http&quot;와 공유 ID가 없습니다.자원 식별자가 동일한 권한 (같은 TCP 포트를 수신하는 동일한 호스트)을 나타내는 경우에도 그것들은 별개의 네임 스페이스이며 별개의 오리진 서버로 간주됩니다. 그러나 쿠키 프로토콜과 같은 전체 호스트 도메인에 적용되도록 정의 된 HTTP 확장&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]는 하나의 서비스에 의해 설정된 정보가 일치하는 호스트 도메인 그룹 내의 다른 서비스와의 통신에 영향을 줄 수있게한다. &quot;https&quot;로 식별 된 리소스에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;정식&lt;/a&gt; 액세스 프로세스는 [ RFC2818 ]에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">&quot;must-revalidate&quot;응답 지시문은 일단 효력이 상실되면 캐시가 원본 서버에서 성공적인 유효성 검증없이 후속 요청을 만족시키기 위해 응답을 사용해서는 안됨을 나타냅니다. 특정 프로토콜 기능의 안정적인 작동을 지원하려면 must-revalidate 지시문이 필요합니다. 모든 상황에서 캐시는 must-revalidate 지시문을 따라야합니다. 특히 캐시가 어떤 이유로 든 오리진 서버에 도달 할 수없는 경우 반드시 504 (게이트웨이 타임 아웃) 응답을 생성해야합니다. must-revalidate 지시문은 표현에 대한 요청의 유효성을 검증하지 못하면 자동으로 실행되지 않는 금융 거래와 같은 잘못된 조작이 발생할 수있는 경우에만 서버에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">&quot;캐시 없음&quot;요청 지시문은 캐시가 원래 서버에 대한 유효성 검증없이 요청을 만족시키기 위해 저장된 응답을 사용해서는 안됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">&quot;no-store&quot;요청 지시문은 캐시가이 요청의 일부 나 응답을 저장해서는 안됨을 나타냅니다. 이 지정 문은 개인용 캐시와 공유 캐시 모두에 적용됩니다. 이러한 맥락에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 저장소에 정보를 저장해서는 안되며, 정보를 전달한 후 가능한 한 빨리 휘발성 저장소에서 정보를 제거하기 위해 최선의 노력을 다해야 함을 의미합니다. 이 지침은 개인 정보 보호를위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히 악의적이거나 손상된 캐시는이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다. 이 지시문을 포함하는 요청이 캐시에서 충족되면비 저장 요청 지시문은 이미 저장된 응답에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">&quot;no-store&quot;응답 지시문은 캐시가 즉각적인 요청 또는 응답의 일부를 저장해서는 안됨을 나타냅니다. 이 지정 문은 개인용 캐시와 공유 캐시 모두에 적용됩니다. 이러한 맥락에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 저장소에 정보를 저장해서는 안되며, 정보를 전달한 후 가능한 한 빨리 휘발성 저장소에서 정보를 제거하기 위해 최선의 노력을 다해야 함을 의미합니다. 이 지침은 개인 정보 보호를위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히 악의적이거나 손상된 캐시는이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&quot;변환 없음&quot;요청 지시문 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;은 [RFC7230]의 5.7.2 절에&lt;/a&gt; 정의 된대로 중개자 (캐시 구현 여부에 관계없이)가 페이로드를 변환하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&quot;변환 없음&quot;응답 지시문 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;은 [RFC7230]의 5.7.2 섹션에&lt;/a&gt; 정의 된대로 (캐시 구현 여부와 상관없이) 중개자가 페이로드를 변환하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">&quot;캐시 전용&quot;요청 지시문은 클라이언트가 저장된 응답 만 얻으려고 함을 나타냅니다. 이 지시문을 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 저장된 응답을 사용하여 응답하거나 504 (게이트웨이 타임 아웃) 상태 코드로 응답해야합니다. 캐시 그룹이 내부 연결 상태가 좋은 통합 시스템으로 작동하는 경우 멤버 캐시는 해당 캐시 그룹 내에서 이러한 요청을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">&quot;proxy-revalidate&quot;응답 지시문은 개인 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 응답 지시문과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public&quot;지시문은 캐시가 응답을 캐시 할 수 있음을 나타냅니다. 일반적으로 캐시 할 수없는 HTTP 인증 또는 응답 상태 코드가있는 페이지를 캐시해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">&quot;public&quot;응답 지시문은 응답이 일반적으로 캐시 할 수 없거나 개인 캐시 내에서만 캐시 할 수있는 경우에도 캐시가 응답을 저장할 수 있음을 나타냅니다. ( 권한을 포함하는 요청에 응답하여 공개 사용에 관한 추가 세부 사항 &lt;a href=&quot;#section-3.2&quot;&gt;은 3.2 절을&lt;/a&gt; 참조 하고 , 기본적으로 상태 코드가 기본적으로 캐시 가능으로 정의되지 않은 상태로 인해 공개되지 않은 응답에 공개가 영향을 미치는 방식에 대한 세부 사항은 &lt;a href=&quot;#section-3&quot;&gt;3 절&lt;/a&gt; 을 참조하십시오. &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">&quot;영역&quot;인증 매개 변수는 보호 범위를 나타내려는 인증 체계에서 사용하도록 예약되어 있습니다. 보호 공간은 표준 루트 URI (실제 요청 URI의 체계 및 권한 구성 요소)에 의해 정의됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 5.5 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;절을&lt;/a&gt; 참조하십시오 .)이있는 경우 영역 값과 함께 액세스중인 서버의 이러한 영역을 사용하면 서버의 보호 된 자원을 각각 자체 인증 체계 및 / 또는 권한 부여 데이터베이스가있는 일련의 보호 공간으로 분할 할 수 있습니다. 영역 값은 일반적으로 오리진 서버에 의해 할당 된 문자열로, 인증 체계에 특정한 추가 의미를 가질 수 있습니다. 응답에는 인증 체계가 동일하지만 영역이 다른 여러 가지 문제가있을 수 있습니다. 보호 공간에 따라 자격 증명을 자동으로 적용 할 수있는 도메인이 결정됩니다. 이전 요청이 승인 된 경우, 사용자 에이전트는 인증 체계, 매개 변수,및 / 또는 사용자 기본 설정 (예 : 구성 가능한 비활성 시간 초과). 인증 체계에서 특별히 허용하지 않는 한 단일 보호 공간은 서버 범위 밖으로 확장 할 수 없습니다. 역사적 이유로, 발신자는 인용 문자열 구문 만 생성해야합니다. 받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">'기본'HTTP 인증 체계</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">잠금 토큰으로 사용되며 모든 리소스에서 고유하도록 UUID에서 구문 상 정확하고 생성하기 쉬운 URI를 생성하기 위해 'opaquelocktoken'URI 체계가 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] (및 IANA에 의해 등록됨)에 정의되었습니다. 항상. opaquelocktoken URI는 'opaquelocktoken'스킴을 UUID와 옵션 확장과 연결하여 구성됩니다. 서버는 각각의 새로운 잠금 토큰마다 새로운 UUID를 만들 수 있습니다. 서버가 UUID를 재사용하려면 확장을 추가해야하며 확장을 생성하는 알고리즘은 동일한 확장이 연결된 UUID와 함께 두 번 사용되지 않아야합니다. OpaqueLockToken-URI = &quot;opaquelocktoken :&quot;UUID [확장]; UUID는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;[RFC4122]의 섹션 3에&lt;/a&gt; 정의되어 있습니다 .. LWS; 의 요소 사이에는 허용되지 않습니다. 이 생산. 확장 = 경로; 경로는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986] 섹션 3.3에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">100 (계속) 상태 코드는 요청의 초기 부분이 수신되었고 아직 서버에 의해 거부되지 않았 음을 나타냅니다. 서버는 요청이 완전히 수신되고 실행 된 후 최종 응답을 보내려고합니다. 요청에 100- 연속 예상을 포함하는 Expect 헤더 필드가 포함 된 경우 100 응답은 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1 절&lt;/a&gt; 에서 설명한대로 서버가 요청 페이로드 본문을 수신하려고 함을 나타냅니다 . 클라이언트는 요청을 계속 보내고 100 응답을 삭제해야합니다. 요청에 100- 연속 기대 값이 포함 된 Expect 헤더 필드가 포함되어 있지 않은 경우 클라이언트는이 임시 응답을 간단히 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">101 (Switching Protocols) 상태 코드는 이 연결에서 사용되는 응용 프로그램 프로토콜의 변경에 대해 서버가 업그레이드 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]의 6.7 절)&lt;/a&gt; 를 통해 서버가 클라이언트 요청을 이해하고 준수 할 의사가 있음을 나타냅니다 . 서버는 101 응답을 종료하는 빈 줄 바로 다음에 어떤 프로토콜이 전환 될 것인지를 나타내는 업그레이드 헤더 필드를 응답에 생성해야합니다. 서버는 프로토콜을 전환하는 것이 유리할 때만 프로토콜 전환에 동의한다고 가정합니다. 예를 들어, 최신 버전의 HTTP로 전환하면 이전 버전보다 유리할 수 있으며 실시간 동기 프로토콜로 전환하면 이러한 기능을 사용하는 리소스를 제공 할 때 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101 상태 코드</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">1xx (정보) 상태 코드 클래스는 요청 된 조치를 완료하고 최종 응답을 보내기 전에 연결 상태 또는 요청 진행 상황을 전달하기위한 임시 응답을 나타냅니다. 1xx 응답은 상태 행 뒤의 첫 번째 빈 줄 (헤더 섹션의 끝을 나타내는 빈 줄)로 종료됩니다. HTTP / 1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 1xx 응답을 HTTP / 1.0 클라이언트에 보내서는 안됩니다. 클라이언트는 하나의 응답을 기대하지 않더라도 최종 응답 전에받은 하나 이상의 1xx 응답을 구문 분석 할 수 있어야합니다. 사용자 에이전트는 예기치 않은 1xx 응답을 무시할 수 있습니다. 프록시 자체가 1xx 응답의 생성을 요청하지 않는 한 프록시는 반드시 1xx 응답을 전달해야합니다. 예를 들어, 프록시가 &quot;예상 : 100- 연속&quot;을 추가하는 경우필드가 요청을 전달할 때 해당 100 (계속) 응답을 전달할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">200 (확인) 상태 코드는 요청이 성공했음을 나타냅니다. 200 응답으로 전송되는 페이로드는 요청 방법에 따라 다릅니다. 본 명세서에 의해 정의 된 방법들에 대해, 페이로드의 의도 된 의미는 다음과 같이 요약 될 수있다 : 목표 자원의 표현을 GET; GET과 동일하지만 표현 데이터가없는 표현; 조치의 상태 또는 조치 결과를 POST로 표시합니다. PUT, 작업 상태의 표현을 삭제합니다. 옵션은 통신 옵션을 나타냅니다. 최종 서버가 수신 한 요청 메시지 표시를 추적하십시오. CONNECT에 대한 응답 외에도 200 응답에는 항상 페이로드가 있지만 오리진 서버는 길이가 0 인 페이로드 본문을 생성 할 수 있습니다. 페이로드를 원하지 않으면오리진 서버는 대신 204 (No Content)를 보내야합니다. CONNECT의 경우 성공적인 결과는 터널이며 200 응답 헤더 섹션 바로 다음부터 시작되므로 페이로드가 허용되지 않습니다. 200 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">201 (작성 됨) 상태 코드는 요청이 이행되었으며 하나 이상의 새로운 자원이 작성되었음을 나타냅니다. 요청에 의해 생성 된 기본 리소스는 응답의 Location 헤더 필드 또는 Location 필드가 수신되지 않은 경우 유효 요청 URI에 의해 식별됩니다. 201 응답 페이로드는 일반적으로 생성 된 리소스를 설명하고 링크합니다. 201 응답에서 ETag 및 Last-Modified와 같은 유효성 검사기 헤더 필드의 의미와 목적에 대한 설명은 &lt;a href=&quot;#section-7.2&quot;&gt;7.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">202 (Accepted) 상태 코드는 요청이 처리를 위해 수락되었지만 처리가 완료되지 않았 음을 나타냅니다. 처리가 실제로 수행 될 때 허용되지 않을 수 있기 때문에 요청이 결국 수행 될 수도 있고 수행되지 않을 수도 있습니다. HTTP에는 비동기 작업에서 상태 코드를 다시 보내는 기능이 없습니다. 202 응답은 의도적으로 비 커밋입니다. 이 프로세스의 목적은 프로세스가 완료 될 때까지 서버에 대한 사용자 에이전트의 연결이 유지되도록 요구하지 않고 서버가 다른 프로세스 (아마 하루에 한 번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락하도록하는 것입니다. 이 응답과 함께 전송 된 표현은 요청을 설명해야합니다.s 현재 상태 및 요청이 이행 될시기를 사용자에게 제공 할 수있는 상태 모니터를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">203 (비 정식 정보) 상태 코드는 요청이 성공했지만 동봉 된 페이로드가 변환 프록시에 의해 오리진 서버의 200 (OK) 응답의 페이로드에서 수정되었음을 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]의 5.7.2 섹션&lt;/a&gt; ). 이 상태 코드를 사용하면 변환이 적용될 때 프록시가 수신자에게이를 알릴 수 있습니다. 그 지식은 내용에 대한 이후의 결정에 영향을 줄 수 있기 때문입니다. 예를 들어, 콘텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 프록시를 통해 동일한 요청 경로를 통해서만 적용 할 수 있습니다. 203 응답은 214 변환 적용 경고 코드와 유사합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234] 섹션 5.5&lt;/a&gt;)는 상태 코드가있는 응답에 적용 할 수있는 장점이 있습니다. 203 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">204 (No Content) 상태 코드는 서버가 요청을 성공적으로 이행했으며 응답 페이로드 본문에 전송할 추가 컨텐츠가 없음을 나타냅니다. 응답 헤더 필드의 메타 데이터는 요청 된 조치가 적용된 후 대상 자원 및 선택된 표시를 나타냅니다. 예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 ETag 헤더 필드가 포함 된 경우 PUT이 성공했으며 ETag 필드 값에 해당 대상 자원의 새 표현에 대한 엔티티 태그가 포함됩니다. 204 응답은 서버가 조치가 대상 자원에 성공적으로 적용되었음을 표시하면서 사용자 에이전트가 현재 &quot;문서보기&quot;(있는 경우)를 가로 질러 이동할 필요가 없음을 암시합니다.서버는 사용자 에이전트가 자체 인터페이스에 따라 사용자에게 성공 표시를 제공하고 활성 표현에 대한 응답으로 새로운 또는 업데이트 된 메타 데이터를 적용한다고 가정합니다. 예를 들어, 204 상태 코드는 &quot;저장&quot;액션에 대응하는 문서 편집 인터페이스와 함께 일반적으로 사용되므로, 저장되는 문서는 사용자가 편집 할 수 있도록 유지된다. 또한 분산 버전 제어 시스템과 같이 자동화 된 데이터 전송이 널리 보급 될 것으로 예상되는 인터페이스와 함께 자주 사용됩니다. 204 응답은 메시지 본문을 포함 할 수 없으므로 헤더 필드 다음의 첫 번째 빈 줄로 종료됩니다. 204 응답은 기본적으로 캐시 가능합니다. 즉,메소드 정의 또는 명시 적 캐시 제어에 의해 다르게 표시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">205 (콘텐츠 재설정) 상태 코드는 서버가 요청을 이행했음을 나타내며 사용자 에이전트가 요청을 전송 한 &quot;문서보기&quot;를 원래 서버로부터 수신 한 원래 상태로 재설정하기를 원합니다. 이 응답은 사용자가 데이터 입력을 지원하는 컨텐츠 (양식, 메모장, 캔버스 등)를 수신하고 해당 공간에서 데이터를 입력 또는 조작하여 입력 된 데이터를 제출하는 일반적인 데이터 입력 사용 사례를 지원하기위한 것입니다. 사용자가 다른 입력 동작을 쉽게 시작할 수 있도록 다음 항목에 대한 데이터 입력 메커니즘이 재설정됩니다. 205 상태 코드는 추가 컨텐츠가 제공되지 않음을 의미하므로 서버는 205 응답으로 페이로드를 생성해서는 안됩니다. 다시 말해,서버는 205 응답에 대해 다음 중 하나를 수행해야한다. a) 값이 0 인 Content-Length 헤더 필드를 포함하여 응답에 대한 길이가 0 인 본문을 표시한다. b) chunked 값을 갖는 Transfer-Encoding 헤더 필드와 길이가 0 인 단일 청크로 구성된 메시지 본문을 포함하여 응답에 대한 길이가 0 인 페이로드를 나타냅니다. 또는 c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">206 (부분 컨텐츠) 상태 코드는 요청 범위 헤더 필드에있는 만족스러운 범위에 해당하는 선택된 표현의 하나 이상의 부분을 전송하여 서버가 대상 자원에 대한 범위 요청을 성공적으로 수행하고 있음을 나타냅니다 ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1).&lt;/a&gt;). 단일 부품이 전송되는 경우, 206 응답을 생성하는 서버는 선택된 표현의 범위가 포함 된 범위와 그 범위로 구성된 페이로드를 설명하는 Content-Range 헤더 필드를 생성해야합니다. 예 : HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 컨텐츠 범위 : 바이트 21010-47021 / 47022 컨텐츠 길이 : 26012 Content-Type : image / gif ... 26012 바이트의 부분 이미지 데이터 여러 부분이 전송되는 경우 206 응답을 생성하는 서버는 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A에&lt;/a&gt; 정의 된대로 &quot;다중 부분 / 바이트 범위&quot;페이로드를 생성해야합니다.및 multipart / byteranges 미디어 유형 및 필수 경계 매개 변수를 포함하는 Content-Type 헤더 필드입니다. 단일 파트 응답과 혼동을 피하기 위해 서버는 다중 파트 응답의 HTTP 헤더 섹션에 Content-Range 헤더 필드를 생성해서는 안됩니다 (이 필드는 각 파트로 대신 전송 됨). 멀티 파트 페이로드에서 각 본문 부분의 헤더 영역 내에서 서버는 해당 본문 부분으로 둘러싸인 범위에 해당하는 Content-Range 헤더 필드를 생성해야합니다. 선택된 표현이 200 (OK) 응답으로 Content-Type 헤더 필드를 가졌다면, 서버는 각 본문 부분의 헤더 영역에서 동일한 Content-Type 필드를 생성해야합니다. 예 : HTTP / 1.1 206 부분 콘텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 수요일,1995 년 11 월 15 일 04:58:08 GMT 내용 길이 : 1741 내용 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 여러 범위가 요청되면 서버는 순서에 관계없이 겹치거나 여러 부품을 보내는 오버 헤드보다 작은 간격으로 분리 된 범위를 통합 할 수 있습니다. 해당 바이트 범위 스펙이 수신 된 Range 헤더 필드에 나타납니다. 멀티 파트 / 바이트 범위 페이로드의 부분 간의 일반적인 오버 헤드는 약 80 바이트이므로선택한 표현의 미디어 유형 및 선택된 경계 매개 변수 길이에 따라, 선택된 전체 표현을 전송하는 것보다 많은 작은 분리 된 부분을 전송하는 것이 덜 효율적일 수 있습니다. 다중 파트를 요청하지 않는 클라이언트가 다중 파트 응답을 지원하지 않을 수 있으므로 서버는 단일 범위 요청에 대한 다중 파트 응답을 생성해서는 안됩니다 (MUST NOT). 그러나 서버는 여러 범위가 요청되고 하나의 범위 만 만족할 수 있거나 통합 후 하나의 범위 만 남아있는 경우 단일 본문 부분만으로 멀티 파트 / 바이트 범위 페이로드를 생성 할 수 있습니다 (MAY). 멀티 파트 / 바이트 범위 응답을 처리 할 수없는 클라이언트는 여러 범위를 요청하는 요청을 생성해서는 안됩니다 (MUST NOT). 멀티 파트 응답 페이로드가 생성되면서버는 만족할 수없는 것으로 간주되거나 다른 범위로 통합 된 범위를 제외하고 수신 된 범위 헤더 필드에 해당 바이트 범위 사양이 나타난 것과 동일한 순서로 부품을 전송해야합니다. 멀티 파트 응답을받는 클라이언트는 해당 본문 부분에 포함 된 범위를 결정하기 위해 각 본문 부분에있는 Content-Range 헤더 필드를 검사해야합니다. 클라이언트는 요청한 것과 동일한 범위 또는 요청한 것과 동일한 범위를받는 것에 의존 할 수 없습니다. 206 응답이 생성 될 때 필드가 동일한 요청에 대해 200 (OK) 응답으로 전송 된 경우 서버는 위에서 요구 한 것 외에 다음 헤더 필드를 생성해야합니다. Date, Cache-Control, ETag, 만료, 컨텐츠 위치 및 가변.If-Range 헤더 필드를 가진 요청에 대한 응답으로 206이 생성되면, 발신자는 위에서 요구 된 것 이외의 다른 표현 헤더 필드를 생성하지 않아야한다. 그렇지 않으면 발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">207 (Multi-Status) 상태 코드는 여러 개의 독립적 인 작업에 대한 상태를 제공합니다 ( 자세한 내용 은 &lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">2xx (성공) 상태 코드 클래스는 클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">300 (Multiple Choices) 상태 코드는 대상 자원에 각각 고유의 고유 식별자가있는 둘 이상의 표시가 있으며 대체에 대한 정보가 제공되어 사용자 (또는 사용자 에이전트)가 다음과 같이 선호 표시를 선택할 수 있음을 나타냅니다. 요청을 하나 이상의 해당 식별자로 리디렉션합니다. 다시 말해, 서버는 사용자 에이전트가 요구에 가장 적합한 표현을 선택하기 위해 사후 협상에 참여하기를 원합니다 ( &lt;a href=&quot;#section-3.4&quot;&gt;3.4 절).&lt;/a&gt;). 서버가 선호하는 선택을하는 경우, 서버는 선호하는 선택의 URI 참조를 포함하는 Location 헤더 필드를 생성해야합니다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. HEAD 이외의 요청 방법에 대해, 서버는 사용자 또는 사용자 에이전트가 가장 선호하는 것을 선택할 수있는 표현 메타 데이터 및 URI 참조의리스트를 포함하는 300 응답으로 페이로드를 생성해야한다 (SHOULD). 사용자 에이전트는 제공된 미디어 유형을 이해하면 해당 목록에서 자동으로 선택할 수 있습니다. HTTP는 페이로드 정의와 직교를 유지하기 때문에 자동 선택을위한 특정 형식은이 사양에서 정의되지 않습니다. 실제로,공유 설계 또는 컨텐츠 협상에 의해 결정되는 바와 같이, 사용자 에이전트가 수용 할 수있는 것으로 쉽게 해석 될 수있는 일부 형식으로, 또는 일반적으로 허용되는 하이퍼 텍스트 형식으로 표현이 제공된다. 기본적으로 300 응답은 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ). 참고 : 300 상태 코드에 대한 원래 제안은 대체 헤더의 목록을 제공하는 것으로 URI 헤더 필드를 정의하여 200, 300 및 406 응답에 사용 가능하고 HEAD 메소드에 대한 응답으로 전송됩니다. 그러나 구문에 대한 배포 및 의견 불일치로 인해 URI와 Alternates (이후 제안)가이 사양에서 삭제되었습니다. 배치는 닭과 계란 문제이지만 각각 &quot;대체&quot;관계를 갖는 링크 헤더 필드 세트 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988)를&lt;/a&gt; 사용하여 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">301 (영구적으로 이동 됨) 상태 코드는 대상 자원에 새로운 영구 URI가 지정되었으며이 자원에 대한 이후의 참조는 동봉 된 URI 중 하나를 사용해야 함을 나타냅니다. 링크 편집 기능이있는 클라이언트는 유효 요청 URI에 대한 참조를 가능한 경우 서버에서 전송 한 하나 이상의 새로운 참조에 자동으로 다시 링크해야합니다. 서버는 새로운 영구 URI에 대한 선호 URI 참조를 포함하는 응답에서 위치 헤더 필드를 생성해야한다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 : 역사적 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다.이 동작이 원치 않으면 307 (Temporary Redirect) 상태 코드를 대신 사용할 수 있습니다. 301 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">302 (발견 된) 상태 코드는 대상 자원이 일시적으로 다른 URI에 있음을 나타냅니다. 경우에 따라 리디렉션이 변경 될 수 있으므로 클라이언트는 향후 요청에 효과적인 요청 URI를 계속 사용해야합니다. 서버는 다른 URI에 대한 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야합니다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 : 역사적 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다. 이 동작이 원치 않으면 307 (Temporary Redirect) 상태 코드를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">303 (기타 참조) 상태 코드는 위치 헤더 필드에 URI로 표시된대로 서버가 사용자 에이전트를 다른 자원으로 경로 재지 정하고 있음을 나타냅니다. 이는 원래 요청에 대한 간접 응답을 제공하기위한 것입니다. 사용자 에이전트는 해당 URI (HTTP를 사용하는 경우 GET 또는 HEAD 요청)를 대상으로하는 검색 요청을 수행 할 수 있으며, 이는 리디렉션 될 수도 있으며 최종 결과를 원래 요청에 대한 응답으로 제공합니다. 위치 헤더 필드의 새 URI는 유효 요청 URI와 동등한 것으로 간주되지 않습니다. 이 상태 코드는 모든 HTTP 메소드에 적용 가능합니다. 주로 POST 작업의 출력이 사용자 에이전트를 선택된 리소스로 리디렉션하도록 허용하는 데 사용됩니다.그렇게하면 원래 요청과 상관없이 POST 응답에 해당하는 정보가 별도로 식별, 책갈피 및 캐시 될 수있는 양식으로 제공됩니다. GET 요청에 대한 303 응답은 오리진 서버에 HTTP를 통해 서버가 전송할 수있는 대상 자원의 표현이 없음을 나타냅니다. 그러나 Location (위치) 필드 값은 대상 리소스를 설명하는 리소스를 나타내므로 해당 다른 리소스에 대한 검색 요청을하면 원래 대상 리소스를 나타내지 않고받는 사람에게 유용한 표현이 될 수 있습니다. 표현할 수있는 내용, 적절한 표현 및 유용한 설명에 대한 질문에 대한 답변은 HTTP 범위를 벗어납니다.HEAD 요청에 대한 응답을 제외하고, 303 응답의 표현은 위치 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">304 (수정되지 않음) 상태 코드는 조건부 GET 또는 HEAD 요청이 수신되었으며 조건이 false로 평가 된 사실이 아닌 경우 200 (OK) 응답을 초래했음을 나타냅니다. 즉, 요청을 조건부로 만든 클라이언트가 이미 유효한 표현을 가지고 있음을 나타 내기 때문에 서버가 대상 자원의 표현을 전송할 필요가 없습니다. 따라서 서버는 200 (OK) 응답의 페이로드 인 것처럼 저장된 표현을 사용하도록 클라이언트를 리디렉션합니다. 304 응답을 생성하는 서버는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 Cache-Control, Content-Location, Date, ETag, Expires 및 Vary와 같은 헤더 필드를 생성해야합니다.304 응답의 목표는 수신자가 이미 하나 이상의 캐시 된 표현을 가질 때 정보 전송을 최소화하는 것이므로, 발신자는 캐시 업데이트를 안내하기 위해 상기 메타 데이터가 존재하지 않는 한 상기 열거 된 필드 이외의 표현 메타 데이터를 생성하지 않아야한다 (예를 들어, 응답에 ETag 필드가없는 경우 Last-Modified가 유용 할 수 있습니다. 304 응답을받는 캐시에 대한 요구 사항은304 응답을받는 캐시에 대한 요구 사항은304 응답을받는 캐시에 대한 요구 사항은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;[RFC7234] 섹션 4.3.4&lt;/a&gt; . 조건부 요청이 자신의 캐시를 가진 사용자 에이전트와 같은 아웃 바운드 클라이언트에서 시작하여 조건부 GET을 공유 프록시에 보내는 경우 프록시는 해당 클라이언트에 304 응답을 전달해야합니다. 304 응답은 메시지 본문을 포함 할 수 없습니다. 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">305 (프록시 사용) 상태 코드는이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않습니다 (부록 B).</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306 상태 코드는이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않으며 코드는 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306 상태 코드는 이전 버전의 사양에서 사용되었으며 더 이상 사용되지 않으며 코드는 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">307 (Temporary Redirect) 상태 코드는 대상 리소스가 다른 URI에 일시적으로 상주하고 사용자 에이전트가 해당 URI로 자동 리디렉션을 수행하는 경우 요청 방법을 변경해서는 안된다는 것을 나타냅니다. 리디렉션은 시간이 지남에 따라 변경 될 수 있으므로 클라이언트는 향후 요청에 원래 유효 요청 URI를 계속 사용해야합니다. 서버는 다른 URI에 대한 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야합니다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 :이 상태 코드는 요청 방법을 POST에서 GET으로 변경할 수 없다는 점을 제외하고 302 (발견)와 유사합니다.이 사양은 301 (영구적으로 이동)에 해당하는 내용을 정의하지 않습니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;&lt;/a&gt;그러나 RFC7238 ]은 이러한 목적을위한 상태 코드 308 (영구적 리디렉션)을 정의한다.</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">상태 코드의 3xx (리디렉션) 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. Location 헤더 필드 ( &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt; )가 제공되면, 사용자 에이전트는 특정 상태 코드가 이해되지 않더라도 요청을 Location 필드 값이 참조하는 URI로 자동 리디렉션 할 수 있습니다. &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1에&lt;/a&gt; 정의 된대로 안전하지 않은 방법을주의해서 자동 리디렉션해야합니다.안전하지 않은 요청을 리디렉션하지 않기를 원할 수 있습니다. 리디렉션 유형에는 여러 가지가 있습니다. 1. 상태 코드 301 (영구적으로 이동), 302 (발견) 및 307 (임시 리디렉션)에서와 같이 위치 필드에서 제공 한대로 다른 URI에서 리소스를 사용할 수 있음을 나타내는 리디렉션 ). 2. 300 (Multiple Choices) 상태 코드에서와 같이 각각 원래 요청 대상을 나타낼 수있는 일치하는 리소스를 선택할 수있는 리디렉션. 3. 위치 필드로 식별되는 303 (기타 참조) 상태 코드와 같이 요청에 대한 간접 응답을 나타낼 수있는 다른 리소스로의 리디렉션. 4. 304 (수정되지 않음) 상태 코드에서와 같이 이전에 캐시 된 결과로 리디렉션. 참고 : HTTP / 1.0에서상태 코드 301 (영구적으로 이동) 및 302 (발견)는 첫 번째 유형의 리디렉션 (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], 섹션 9.3&lt;/a&gt;). 초기 사용자 에이전트는 경로 재 지정 대상에 적용된 메소드가 원래 요청과 동일한 지 GET으로 다시 작성되는지에 따라 분리됩니다. HTTP는 원래 301 및 302에 대한 이전 의미를 정의하고 (CERN에서의 원래 구현과 일치하도록) 303 (기타 참조)을 정의했지만, 후자의 의미와 일치하도록 일반적인 관행이 점차 301 및 302에 대한 후자의 의미에 수렴되었습니다. HTTP / 1.1의 첫 번째 개정판은 307 (Temporary Redirect)을 추가하여 분기 관행에 영향을받지 않고 이전 의미를 표시했습니다. 10 년이 지난 후에도 대부분의 사용자 에이전트는 여전히 301 및 302에 대해 메소드 재 작성을 수행합니다. 따라서이 사양은 원래 요청이 POST 일 때 해당 동작을 준수합니다.클라이언트는 주기적 리디렉션 (즉, &quot;무한&quot;리디렉션 루프)을 감지하고 개입해야합니다. 참고 :이 사양의 이전 버전에서는 최대 5 개의 리디렉션을 권장했습니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], 섹션 10.3&lt;/a&gt; ). 컨텐츠 개발자는 일부 클라이언트가 이러한 고정 된 제한을 구현할 수 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">400 (잘못된 요청) 상태 코드는 클라이언트 오류 (예 : 잘못된 요청 구문, 잘못된 요청 메시지 프레이밍 또는 사기성 요청 라우팅)로 인식되는 것으로 인해 서버가 요청을 처리 할 수 ​​없거나 처리하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">401 (인증되지 않음) 상태 코드는 요청이 대상 리소스에 대한 유효한 인증 자격 증명이 없기 때문에 적용되지 않았 음을 나타냅니다. 401 응답을 생성하는 서버 는 대상 자원에 적용 가능한 하나 이상의 챌린지를 포함 하는 WWW-Authenticate 헤더 필드 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; )를 보내야 합니다. 요청에 인증 자격 증명이 포함 된 경우 401 응답은 해당 자격 증명에 대한 권한 부여가 거부되었음을 나타냅니다. 사용자 에이전트는 새로운 또는 교체 된 Authorization 헤더 필드로 요청을 반복 할 수있다 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2)&lt;/a&gt;). 401 응답에 이전 응답과 동일한 시도가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 일반적으로 관련 진단 정보가 포함되어 있으므로 사용자 에이전트는 동봉 된 표현을 사용자에게 제시해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">402 (결제 필요) 상태 코드는 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">403 (금지됨) 상태 코드는 서버가 요청을 이해했지만 승인을 거부 함을 나타냅니다. 요청이 금지 된 이유를 공개하려는 서버는 응답 페이로드에 해당 이유를 설명 할 수 있습니다 (있는 경우). 요청에 인증 자격 증명이 제공된 경우 서버는 자격 증명이 액세스 권한을 부여하기에 충분하지 않은 것으로 간주합니다. 클라이언트는 동일한 자격 증명으로 요청을 자동으로 반복해서는 안됩니다. 클라이언트는 새로운 자격 증명이나 다른 자격 증명으로 요청을 반복 할 수 있습니다. 그러나 신임 정보와 관련이없는 이유로 요청이 금지 될 수 있습니다. 금지 된 대상 자원의 현재 존재를 &quot;숨기기&quot;하려는 원 서버는 대신 상태 코드 404 (찾을 수 없음)로 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">404 (찾을 수 없음) 상태 코드는 원본 서버가 대상 자원에 대한 현재 표현을 찾지 못했거나 존재한다는 것을 공개하지 않을 것임을 나타냅니다. 404 상태 코드는 이러한 표현 부족이 일시적인지 영구적인지를 나타내지 않습니다. 410 (Gone) 상태 코드는 원래 서버가 구성 가능한 일부 수단을 통해 조건이 영구적 일 가능성을 알고있는 경우 404보다 선호됩니다. 404 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">405 (Method Not Allowed) 상태 코드는 요청 라인에서 수신 된 메소드가 오리진 서버에 알려져 있지만 대상 자원에 의해 지원되지 않음을 나타냅니다. 오리진 서버는 대상 리소스의 현재 지원되는 메소드 목록을 포함하는 405 응답에 Allow header 필드를 생성해야합니다. 405 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">406 (Not Acceptable) 상태 코드는 요청에서 수신 한 사전 협상 헤더 필드 ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; ) 에 따라 대상 자원에 사용자 에이전트가 수용 할 수있는 현재 표현이없고 서버가 기본 표현을 제공하십시오. 서버는 사용 가능한 표현 특성 목록과 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수있는 해당 자원 식별자를 포함하는 페이로드를 생성해야합니다. 사용자 에이전트는 해당 목록에서 가장 적합한 선택을 자동으로 선택할 수 있습니다. 그러나이 사양은 &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1 절에&lt;/a&gt; 설명 된대로 자동 선택에 대한 표준을 정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">407 (프록시 인증 필요) 상태 코드는 401 (무단)과 유사하지만 프록시를 사용하려면 클라이언트가 자신을 인증해야 함을 나타냅니다. 프록시는 반드시 대상 자원에 대해 해당 프록시에 적용 가능한 챌린지를 포함 하는 프록시 인증 헤더 필드 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 절&lt;/a&gt; )를 보내야 합니다. 클라이언트는 새로운 프록시 대체 헤더 필드 ( &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; ) 로 요청을 반복 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">408 (요청 제한 시간) 상태 코드는 서버가 대기 준비 시간 내에 완전한 요청 메시지를 수신하지 않았 음을 나타냅니다. 408은 서버가 대기를 계속하기보다는 연결을 종료하기로 결정 했으므로 서버는 응답에 &quot;닫기&quot;연결 옵션 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]의 6.1 절&lt;/a&gt; )을 보내야 한다. 클라이언트가 전송중인 미해결 요청을 가지고있는 경우 클라이언트는 새 연결에서 해당 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">409 (충돌) 상태 코드는 대상 자원의 현재 상태와 충돌하여 요청을 완료 할 수 없음을 나타냅니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수있는 상황에서 사용됩니다. 서버는 사용자가 충돌의 원인을 인식하기에 충분한 정보를 포함하는 페이로드를 생성해야합니다. PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 높습니다. 예를 들어, 버전 관리를 사용 중이고 PUT 표시에 이전 (타사) 요청에 의해 작성된 자원과 충돌하는 자원에 대한 변경 사항이 포함 된 경우, 오리진 서버는 409 응답을 사용하여 완료 할 수 없음을 표시 할 수 있습니다. 의뢰. 이 경우응답 표현에는 수정 내역에 따라 차이를 병합하는 데 유용한 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">410 (Gone) 상태 코드는 대상 자원에 대한 액세스를 더 이상 원래 서버에서 사용할 수 없으며이 조건이 영구적 일 수 있음을 나타냅니다. 원래 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 기능이없는 경우 상태 코드 404 (찾을 수 없음)가 대신 사용되어야합니다. 410 응답은 기본적으로 수신자에게 자원을 의도적으로 사용할 수 없으며 서버 소유자가 해당 자원에 대한 원격 링크를 제거하기를 원한다는 것을 통지하여 웹 유지 보수 작업을 지원하기위한 것입니다. 이러한 이벤트는 제한된 기간의 판촉 서비스 및 더 이상 원본 서버 사이트와 관련이없는 개인의 리소스에 공통적입니다. 영구적으로 사용할 수없는 모든 리소스를 &quot;&amp;rdquo;응답은 서버 소유자의 재량에 따라 남은 기간 동안 마크를 유지합니다. 410 응답은 기본적으로 캐시 가능합니다 (예 : 메소드 정의 또는 명시 적 캐시 제어에 의해 다르게 표시되지 않는 한). &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">411 (Length Required) 상태 코드는 서버가 정의 된 Content-Length ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]의 섹션 3.3.2)&lt;/a&gt; 없이 요청을 수락하지 않음을 나타냅니다 . 클라이언트는 요청 메시지에 메시지 본문의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하면 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">412 (전제 조건 실패) 상태 코드는 서버에서 테스트 할 때 요청 헤더 필드에 지정된 하나 이상의 조건이 false로 평가되었음을 나타냅니다. 이 응답 코드를 통해 클라이언트는 현재 자원 상태 (현재 표현 및 메타 데이터)에 사전 조건을 배치 할 수 있으므로 대상 자원이 예상치 못한 상태 인 경우 요청 메소드가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">413 (Payload Too Large) 상태 코드는 요청 페이로드가 서버가 처리 할 수 ​​있거나 처리 할 수있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있음을 나타냅니다. 서버는 클라이언트가 요청을 계속하지 못하도록 연결을 닫을 수 있습니다. 조건이 일시적인 경우 서버는 Retry-After 헤더 필드를 생성하여 일시적이고 클라이언트가 다시 시도 할 수있는 시간을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">414 (URI Too Long) 상태 코드는 요청 대상 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 5.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;절&lt;/a&gt; )이 서버가 해석하려는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있음을 나타냅니다 . 클라이언트가 리디렉션의 &quot;블랙홀&quot;로 내림 된 경우 (예를 들어 리디렉션 된 URI 접두사) 클라이언트가 POST 요청을 긴 쿼리 정보와 함께 GET 요청으로 잘못 변환 한 경우에만이 드문 조건이 발생할 수 있습니다. 접미사 자체) 또는 잠재적 보안 허점을 악용하려는 클라이언트가 서버를 공격하는 경우. 414 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">415 (지원되지 않는 매체 유형) 상태 코드는 페이로드가 대상 자원에서이 메소드가 지원하지 않는 형식이므로 오리진 서버가 요청 서비스를 거부하고 있음을 나타냅니다. 형식 문제는 요청에 표시된 Content-Type 또는 Content-Encoding 또는 데이터를 직접 검사 한 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">416 (Range Not Satisfiable) 상태 코드는 요청의 Range 헤더 필드 ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; )의 범위가 선택한 자원의 현재 범위와 겹치지 않거나 유효하지 않은 범위 또는 과도한 범위로 인해 요청 된 범위 세트가 거부되었음을 나타냅니다. 작거나 겹치는 범위의 요청. 바이트 범위의 경우 현재 범위와 겹치지 않으면 모든 바이트 범위 스펙 값의 첫 번째 바이트 위치가 선택한 표현의 현재 길이보다 큼을 의미합니다. 바이트 상태 요청에 대한 응답으로이 상태 코드가 생성되면 발신자는 선택된 표현의 현재 길이를 지정하는 Content-Range 헤더 필드를 생성해야한다 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2).&lt;/a&gt;). 예 : HTTP / 1.1 416 범위를 만족할 수 없음 날짜 : 2012 년 1 월 20 일 금요일 15:41:54 GMT 콘텐츠 범위 : bytes * / 47022 참고 : 서버는 범위를 무시할 수 없으므로 많은 구현은 선택한 전체로 간단히 응답합니다. 200 (OK) 응답으로 표현. 그 이유는 대부분의 클라이언트가 작업을 완료하기 위해 200 (OK)을받을 준비가 되었기 때문에 (비효율적이지만) 클라이언트가 완전한 표현을받을 때까지 유효하지 않은 부분 요청을 중단하지 않을 수 있기 때문입니다. 따라서 클라이언트는 가장 적합한 경우에도 416 (Range Not Satisfiable) 응답 수신에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">417 (예상 실패) 상태 코드는 요청의 Expect 헤더 필드 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; )에 제공된 기대치를 하나 이상의 인바운드 서버에서 충족시킬 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">422 (처리 할 수없는 엔티티) 상태 코드는 서버가 요청 엔티티의 컨텐츠 유형을 이해하고 (따라서 415 (지원되지 않는 매체 유형) 상태 코드가 부적절 함) 요청 엔티티의 구문이 올바르다는 것을 의미합니다 (따라서 400 (잘못된 요청) ) 상태 코드는 부적절하지만 포함 된 지침을 처리 할 수 ​​없습니다. 예를 들어, XML 요청 본문에 올바른 형식 (구문 적으로 올바른)이지만 의미 상 잘못된 XML 명령어가 포함 된 경우이 오류 조건이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">423 (Locked) 상태 코드는 메소드의 소스 또는 대상 자원이 잠겨 있음을 의미합니다. 이 응답에는 '잠금 토큰 제출'또는 '충돌 방지 잠금'과 같은 적절한 사전 조건 또는 사후 조건 코드가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">424 (실패 종속성) 상태 코드는 요청 된 조치가 다른 조치에 의존하고 해당 조치가 실패했기 때문에 자원에서 메소드를 수행 할 수 없음을 의미합니다. 예를 들어, PROPPATCH 메소드의 명령이 실패하면 최소한 나머지 명령도 424 (실패 종속성)로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">426 (업그레이드 필요) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드 한 후 기꺼이 할 수 있음을 나타냅니다. 서버는 필수 프로토콜을 표시하기 위해 426 응답으로 업그레이드 헤더 필드를 보내야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]의 6.7 절&lt;/a&gt; ). 예 : HTTP / 1.1 426 업그레이드 필요 업그레이드 : HTTP / 3.0 연결 : 업그레이드 Content-Length : 53 Content-Type : text / plain이 서비스는 HTTP / 3.0 프로토콜을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">상태 코드의 4xx (클라이언트 오류) 클래스는 클라이언트가 오류가 발생한 것 같습니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 나타내는 표현을 보내야합니다. 이 상태 코드는 모든 요청 방법에 적용 할 수 있습니다. 사용자 에이전트는 사용자에게 포함 된 표현을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">4xx 등급의 상태 코드는 클라이언트가 오류가 발생한 것처럼 보입니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다. 이 상태 코드는 모든 요청 방법에 적용 할 수 있습니다. 사용자 에이전트는 포함 된 엔티티를 사용자에게 표시해야합니다. 클라이언트가 데이터를 전송하는 경우 TCP를 사용하는 서버 구현은 서버가 입력 연결을 닫기 전에 클라이언트가 응답을 포함하는 패킷의 수신을 확인하도록주의해야합니다. 클라이언트가 닫은 후에도 계속 서버로 데이터를 보내면 서버의 TCP 스택이 클라이언트로 재설정 패킷을 보내 클라이언트를 지울 수 있습니다.승인되지 않은 입력 버퍼는 HTTP 응용 프로그램에서 읽고 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">500 (내부 서버 오류) 상태 코드는 서버에서 요청을 수행하지 못하게하는 예기치 않은 조건이 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">501 (구현되지 않음) 상태 코드는 서버가 요청을 수행하는 데 필요한 기능을 지원하지 않음을 나타냅니다. 서버가 요청 방법을 인식하지 못하고 자원을 지원할 수없는 경우 적절한 응답입니다. 501 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">502 (잘못된 게이트웨이) 상태 코드는 게이트웨이 또는 프록시 역할을하는 서버가 요청을 수행하는 동안 액세스 한 인바운드 서버로부터 유효하지 않은 응답을 수신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">503 (Service Unavailable) 상태 코드는 서버가 일시적 과부하 또는 예정된 유지 보수로 인해 현재 요청을 처리 할 수 ​​없음을 나타냅니다.이 지연은 약간의 지연 후에 완화 될 수 있습니다. 서버는 Retry-After 헤더 필드 ( &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3 절&lt;/a&gt; )를 전송하여 요청을 재 시도하기 전에 클라이언트가 대기 할 적절한 시간을 제안 할 수 있습니다. 참고 : 503 상태 코드가 존재한다고해서 서버가 오버로드 될 때 서버가이를 사용해야한다는 것을 의미하지는 않습니다. 일부 서버는 단순히 연결을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">505 (HTTP 버전 지원되지 않음) 상태 코드는 서버가 요청 메시지에 사용 된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부 함을 나타냅니다. 서버는 이 오류 메시지 외에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;[RFC7230]의 2.6 절에&lt;/a&gt; 설명 된대로 클라이언트와 동일한 주 버전을 사용하여 요청을 완료 할 수 없거나 수행하지 않을 것임을 나타냅니다 . 서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">5xx (서버 오류) 상태 코드 클래스는 서버가 서버가 요청 된 메소드를 잘못했거나 수행 할 수 없음을 인식하고 있음을 나타냅니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 나타내는 표현을 보내야합니다. 사용자 에이전트는 포함 된 표현을 사용자에게 표시해야한다. 이 응답 코드는 모든 요청 방법에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">자원 또는 데이터 의 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더는 전체적으로 생략된다. 요청과 함께 리퍼러 정보가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">이 헤더가 의미를 가지려면 &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더를 &quot;keep-alive&quot;로 설정해야합니다. 또한 &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 및 연결 &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; 는 HTTP / 2에서 무시됩니다. 연결 관리는 다른 메커니즘에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 멀티 파트 몸의 경계를 정의.</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">는 &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; 헤더가 브라우저 또는 다른 사용자 에이전트에 의해 정의되며, HTML 페이지 또는 이미지, 비디오, 또는 스크립트를 가져 오는 것처럼, 상황에 따라 달라질 수 있습니다 문서가 입력 가져올 때 그것은 다른 주소 표시 줄 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 통해 연결된 요소 브라우저는 가장 적절하다고 생각되는 헤더 값을 자유롭게 사용할 수 있습니다. &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;공통 브라우저에 대한&lt;/a&gt; 전체 기본값 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">는 &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; 에이전트가 프로세스 용의가 있음을 헤더 나열 미디어 자원의 MIME 유형을. 쉼표로 구분 된 MIME 유형 목록으로, 각 MIME 유형 사이의 상대적 선호도를 나타내는 매개 변수 인 품질 요소와 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; 헤더는 문자 인코딩의 종류는 사용자 에이전트에 의해 이해되는 것을 서버에 나타냅니다. 전통적으로 브라우저의 각 로케일마다 &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; 과 같이 서유럽 로케일의 경우 서로 다른 값으로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 허용되는 콘텐츠 부호화 (지원 압박)을 정의한다. 값은 인코딩 값의 우선 순위를 나타내는 &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; 인자 목록 (예 : br, gzip; q = 0.8 )입니다. 기본적으로 &lt;code&gt;identity&lt;/code&gt; 되지 않은 경우를 제외하고 기본값 ID 가 가장 낮은 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; 헤더는 사용자의 언어 설정을 표시하는 데 사용됩니다. 품질 요소가있는 값의 목록입니다 (예 : &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &quot;). 기본값은 종종 사용자 에이전트의 그래픽 인터페이스 언어에 따라 설정되지만 대부분의 브라우저는 다른 언어 환경 설정을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; 헤더는 경우 요청에 대한 응답이 노출 될 수 있는지 여부를 나타냅니다 &lt;code&gt;credentials&lt;/code&gt; 플래그는 사실이다. 프리 플라이트 요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지 여부를 나타냅니다. 간단한 &lt;code&gt;GET&lt;/code&gt; 요청은 프리 플라이트되지 않으므로 자격 증명이있는 리소스를 요청하면이 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 응답에 사용되는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;프리 플라이트 요청&lt;/a&gt; 실제 요청을 할 때 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 헤더는 자원에 액세스 할 때 허용 된 방법 또는 방법을 지정한다. 프리 플라이트 요청에 대한 응답으로 사용됩니다. 요청이 프리 플라이트되는 조건은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 브라우저가 액세스 할 수 있는지 화이트리스트 헤더 서버를 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; 헤더는 프리 플라이트 요청의 결과를 캐시 할 수있는 기간을 나타냅니다. 프리 플라이트 요청의 예는 위의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 실제 요청이있을 때 사용됩니다 어떤 HTTP 헤더 서버 노하우를 할 수있는 프리 플라이트 요청을 발행 할 때 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때,은에 전송 될 것이라는 플라이트 요청의 일부로서 서버 &lt;code&gt;POST&lt;/code&gt; 의 요청 방법. &lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때, 그것이로 전송됩니다 서버 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 및 &lt;code&gt;Content-Type&lt;/code&gt; 사용자 정의 헤더. 이제 서버는 이러한 상황에서 요청을 수락할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 실제 요청이있을 때 사용됩니다 어떤 HTTP 방법 서버 노하우를 할 수있는 프리 플라이트 요청을 발행 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 요청 헤더는 (프록시) 서버와 사용자 에이전트를 인증하는 인증 정보를 포함한다. 여기서는 인증 유형이 다시 필요하며,이 인증 유형은 사용되는 인증 체계에 따라 인코딩되거나 암호화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1 일반 헤더 필드는 요청과 응답 모두 메커니즘을 캐싱에 대한 지시자를 표시하는 데 사용한다. 이 헤더를 사용하여 제공하는 다양한 지시문으로 캐싱 정책을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더는 이제 요청 범위 (그리고 이미지의 전체 크기)의 크기를 나타냅니다. &lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 전체 자원이 부분 메시지가 속한 곳 응답 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 응답 헤더 필드는 사용자 에이전트가 해당 페이지에 대한 부하에 허용되는 제어 자원 웹 사이트 관리자를 할 수 있습니다. 몇 가지 예외를 제외하고 정책에는 주로 서버 원본 및 스크립트 끝점 지정이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 응답 헤더는 인 &lt;em&gt;불투명 - 투 - 사용자 에이전트&lt;/em&gt; 강한 검증로서 사용될 수있다 값. 즉, 브라우저와 같은 HTTP 사용자 에이전트는이 문자열이 무엇을 나타내는 지 알지 못하며 그 값이 무엇인지 예측할 수 없습니다. 는 IF &lt;code&gt;ETag&lt;/code&gt; 헤더가 리소스에 대한 응답의 일부, 클라이언트는 발행 할 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 캐시 된 자원을 검증하기 위해 - 미래의 요청의 헤더에.</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; HTTP 요청 헤더는 다양한 요구 조건합니다 : 조건이 충족되는 경우, 범위 요청이 발행되고 서버가 다시 전송 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 해당하는 몸 대답을. 조건이 충족되지 않으면 전체 자원이 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 반송 됩니다. 이 헤더는 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 유효성 검사기 또는 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있지만 둘 다와 함께 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 응답 헤더는 약한 검증로서 사용될 수있다. 해상도는 1 초이므로 약한 것으로 간주됩니다. 는 IF &lt;code&gt;Last-Modified&lt;/code&gt; 헤더가 응답에 존재하고 클라이언트는이 발행 할 수 &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 요청 헤더 캐시 된 문서의 유효성을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더는 크로스 사이트 접속 요청 또는 프리 플라이트 요청의 출처를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더는 또한 당신이 다중 문서에서 한 번에 여러 범위를 얻을 수 있습니다. 범위는 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTP 응답 헤더는 사용자 에이전트 서버에서 쿠키를 보냅니다. 간단한 쿠키는 다음과 같이 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 더 많은 양의 데이터가 클라이언트에 상기 요구가 완전히 처리 될 때까지 알려지지 않은 응답의 전체 크기에 전송 유용한 청크 인코딩을 허용한다. 서버는 응답을 버퍼링하거나 정확한 길이를 결정하지 않고 바로 클라이언트에 데이터를 전송하므로 대기 시간이 향상됩니다. 범위 요청과 청킹은 호환되며 서로 사용하거나 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 헤더는 요청을 보내는 브라우저를 식별합니다. 이 문자열에는 공백으로 구분 된 &lt;em&gt;제품 토큰&lt;/em&gt; 및 &lt;em&gt;주석&lt;/em&gt; 목록이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">(가) &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP를 응답 헤더는 캐시 된 응답이 원본 서버에서 새로운 하나를 요청하는 대신 사용할 수 있는지 여부를 결정하는 미래의 요청 헤더와 일치하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 응답 헤더는 리소스에 액세스하기 위해 사용되어야하는 인증 방법을 정의한다. 인증하려는 클라이언트가 자격 증명을 제공하는 방법을 알 수 있도록 사용되는 인증 체계를 지정해야합니다. 이 헤더의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 요청 헤더 필드로 프록시에 의해 수신.</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;을 mod_rewrite&lt;/a&gt; 모듈은 리디렉션을 만드는 데 사용할 수 있습니다. 더 유연하지만 사용하기가 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org&lt;/a&gt; 의 HTTP 경고 코드 레지스트리는 경고 코드 의 네임 스페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">Microsoft에 의한 X-Content-Type-Options 의 &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;원래 정의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청을 수행 할 수 없습니다 프리 플라이트, 프리 플라이트가 필요합니다. 프리 플라이트가 실패 할 수있는 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청은 서버 자격 증명의 사용을 허용해야하지만 서버의 &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; 헤더의 값으로 설정되지 않은 &lt;code&gt;true&lt;/code&gt; 의 사용을 가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청이 자격 증명 플래그가 설정 시도했지만, 서버는 와일드 카드 (사용하여 구성됩니다 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 의 값으로) &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 증명의 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청은 CORS 요청시 허용되지 않는 원래의 요청이 아닌 다른 출처에서 URL에 HTTP 리디렉션으로 서버가 응답했다.</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP의&lt;/a&gt; HTTP 연결은 네트워크 또는 프로토콜 수준에서 실패했기 때문에 CORS를 사용합니다 요청이 실패했습니다. 이 오류는 CORS와 직접 관련이 없지만 일종의 근본적인 네트워크 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;간단한 헤더&lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 중 하나의 (하지만 그 구문 분석 된 값의 MIME 타입 (무시 매개 변수) &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; , 또는 &lt;code&gt;text/plain&lt;/code&gt; )을 항상 사용할 수 있으며이 헤더로 나열 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트는&lt;/a&gt; 요구되는 추가 할 수 없습니다 &lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 받는 헤더를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP의&lt;/a&gt; 요청. 모든 CORS 요청에는 &lt;code&gt;Origin&lt;/code&gt; 헤더 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; 의&lt;/a&gt; 인터페이스에서 사용하기 위해 양식 데이터를 조작하는 데 사용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API.</target>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt; 생성자는 모든 후 초기 HTTP / 1.1 연결을 만드는 당신을 위해 핸드 쉐이크 및 업그레이드 프로세스를 처리하는 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">iframe 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 속성</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;허용&lt;/a&gt; 에 대한 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 들.</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt; 헤더는 함께 사용되는 &lt;code&gt;Device-Memory&lt;/code&gt; 의 값이 &lt;code&gt;Accept-CH&lt;/code&gt; 헤더 및 장치가 옵트해야하는 서버와 장치 메모리의 양을 공유하는 시간을 나타낸다. 값은 밀리 초 단위로 제공되며 사용은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP 프로토콜은&lt;/a&gt; 이미 설정된 연결은 새로운 호환되지 않는 프로토콜로 업그레이드 할 수 있도록 특별한 메커니즘을 제공합니다. 이 안내서는 이것이 어떻게 작동하는지 다루고 사용 된 시나리오의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;크로스 원점 자원 정책&lt;/a&gt; 헤더 방지 자원을로드에서 다른 도메인.</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias가의&lt;/a&gt; 모듈은이 &lt;code&gt;Redirect&lt;/code&gt; 및 &lt;code&gt;RedirectMatch&lt;/code&gt; 에 셋업 것을 지시 &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; (기본적으로) 응답 :</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">&lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;모질라 전망대&lt;/a&gt; 안전과 보안을위한 웹 사이트 (이 헤더 포함) 구성을 테스트 도구</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url의&lt;/a&gt; 포맷은 표준 Base64 인코딩과 동일하지 않다. 이것은 표준 Base64와 거의 동일하지는 않습니다. 유일한 차이점은 결과 문자열이 URL과 파일 이름 모두에서 안전하게 사용할 수 있도록하기 위해 알파벳의 62 번째 및 63 번째 문자가 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 에서 &lt;code&gt;&quot;-&quot;&lt;/code&gt; (빼기) 및 &lt;code&gt;&quot;_&quot;&lt;/code&gt; (밑줄)입니다.</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/&quot;&gt;인터넷 할당 번호 관리 기관 (IANA)는&lt;/a&gt; 모든 공식 MIME 유형에 대한 책임이있다, 당신은 자신의 가장 최신 목록을 찾을 수 있습니다 &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;미디어 유형의&lt;/a&gt; 페이지를.</target>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 의&lt;/a&gt; 방법은 지정된 자원의 데이터 표현을 요청합니다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 그것의 상태를 변경할 수 있도록 방법은 서버로 데이터를 전송한다. 이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식에&lt;/a&gt; 자주 사용되는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더는 전체적으로 생략된다. 요청과 함께 리퍼러 정보가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; &lt;/a&gt; 상태 코드가 포함하는 요청에 대한 응답으로서 송신된다 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 는 요청의 수신자가 원하는 프로토콜 중 하나를 업그레이드 할 의사가 있는지 신호 헤더. 는 IF &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 상태 코드가 반환되고, 헤더도 포함해야 &lt;code&gt;Connection&lt;/code&gt; 및 &lt;code&gt;Upgrade&lt;/code&gt; 선택한 프로토콜을 설명하는 헤더를. 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;이 메커니즘의 일반적인 사용&lt;/a&gt; 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (복수 선택) 또는 &lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (불가) &lt;a href=&quot;status&quot;&gt;HTTP 응답 코드를&lt;/a&gt; 서버 (기준 &lt;em&gt;에이전트가 주도하는 협상&lt;/em&gt; 이나 &lt;em&gt;반응 협상&lt;/em&gt; 대체 메커니즘으로 사용된다).</target>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; 의&lt;/a&gt; 요청 헤더 트레일러 필드를 허용하는 &quot;트레일러&quot;로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시자는 이전에 평가 &lt;code&gt;block-all-mixed-content&lt;/code&gt; 과 전이 설정되어있는 경우, 후자는 효과적으로 조작은 행해지 지 않습니다. HTTP로 리디렉션 한 후 강제하지 않는 이전 브라우저에서 HTTPS를 강제 실행하지 않는 한 하나의 지시어 또는 다른 지시어를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">&lt;code&gt;'strict-dynamic&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 것을'원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 화이트리스트 또는 소스 표현식 은 무시됩니다. 예를 들어 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 과 같은 정책 을 사용하면 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 루트 스크립트를로드 할 수 있습니다. src = &quot;https : // example.com/loader.js &quot;&amp;gt; 및 &lt;code&gt;loader.js&lt;/code&gt; 에 의해로드 된 스크립트에 신뢰를 전파 하지만 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 에서 스크립트를로드 할 수는 없습니다 .//whitelisted.com/ nonce를 동반하거나 신뢰할 수있는 스크립트에서로드하지 않는 한</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; 원본 식 제어 문자열에서 코드를 생성 할 몇 가지 스크립트 실행 방법. 경우 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 로 지정되지 않은 &lt;code&gt;script-src&lt;/code&gt; 지시, 다음과 같은 방법이 차단되어 영향을주지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; 원본 식 제어 문자열에서 스타일 선언을 만들어 여러 스타일의 방법. 경우 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 로 지정되지 않은 &lt;code&gt;style-src&lt;/code&gt; 지시, 다음과 같은 방법이 차단되어 영향을주지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 파일 참조합니다 &lt;code&gt;.htpasswd&lt;/code&gt; 각 행은 사용자 이름이 들어있는 파일과 암호는 콜론으로 구분 ( &quot;&quot;). &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;암호화 된&lt;/a&gt; 실제 비밀번호 (이 경우에는 md5)를 볼 수 없습니다 . 원하는 경우 &lt;code&gt;.htpasswd&lt;/code&gt; 파일의 이름을 다르게 지정할 수 있지만이 파일에 액세스 할 수 없다는 점에 유의하십시오. Apache는 일반적으로 &lt;code&gt;.ht*&lt;/code&gt; 파일에 액세스하지 못하도록 구성되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 파일은 일반적으로 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">&lt;code&gt;203&lt;/code&gt; 응답 값과 유사하다 &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; 즉, &lt;code&gt;Transformation Applied&lt;/code&gt; 의, &lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 모든 상태 코드 응답에 적용되는 추가적인 장점을 갖는다 헤더 코드.</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;416&lt;/code&gt; 응답 메시지가 포함 된 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; (a 불만 인 범위를 나타내는 &lt;code&gt;'*'&lt;/code&gt; a로 하였다) &lt;code&gt;'/'&lt;/code&gt; 와 자원의 현재 길이. 예 : &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 몇 초에게 브라우저를 나타내는 숫자와 속성의 시작은 주어진 URL로 리디렉션하기 전에 기다려야합니다. 더 나은 접근성을 위해 항상 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 엔터티 헤더 필드는 HTTP 헤더에 하나 개 이상의 링크를 serialising하는 수단을 제공합니다. 의미 적으로 HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; 헤더 필드는 교환의 권한을 결정하고 그 서명을 갱신하는 방법에 대한 자세한 내용과 함께 각각에 대해 서명의 목록을 전달한다.</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; 헤더 필드는 서명에 포함 응답 헤더 필드의 정렬 된 목록을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; 응답 HTTP 헤더 부분 요청의 지원을 광고 서버에 의해 사용되는 마커입니다. 이 필드의 값은 범위를 정의하는 데 사용할 수있는 단위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 응답이 주어진에서 코드를 요청과 공유 할 수 있는지 여부를 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;원&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; 헤더는 객체가 프록시 캐시되었습니다 시간 (초)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">이 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 자원에 의해 지원 헤더 나열 방법의 세트.</target>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 요청이 반송된다는 것을 의미 헤더 중간으로 설정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS 이른 데이터&lt;/a&gt; 와 별도로 중개자가 이해하는 것을 나타낸다 &lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt; 상태 코드. &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 헤더 (즉, 브라우저) 요청의 송신자에 의해 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">이 &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; 헤더는 응답이 부실 간주되는 날짜 / 시간이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 요청 사용자 에이전트를 통제하는 인간 사용자의 인터넷 전자 메일 주소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 요청 헤더 (가상 호스팅) 서버의 도메인 이름을 지정하고 (선택 사항) TCP 포트 번호가있는 서버가 듣고있다.</target>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 제한 시간 및 요청의 최대 금액을 설정하는 데 사용할 수있는 방법 연결 및 대한 힌트를 보낸 사람을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 연결이 타임 아웃 요청의 최대 금액을 설정하는 데 사용할 수있는 방법에 대한 힌트를 보낸 사람을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP는 / 1.0 일반 헤더 요청 - 응답 체인을 따라 다양한 효과를 가질 수있는 특정 구현 헤더이다. &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1 헤더가 아직없는 HTTP / 1.0 캐시와의 하위 호환성을 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 현재 요청 된 페이지에 대한 링크가 이어졌습니다있는 이전 웹 페이지의 주소를 포함합니다. &lt;code&gt;Referer&lt;/code&gt; 헤더는 서버가 사람들이 그들을 방문하는 곳 확인하고 예를 들어, 분석, 로깅 또는 최적화 된 캐싱 데이터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 헤더는 요청을 처리하는 원 서버가 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; 의 요청 헤더는 사용자 에이전트가 받아 들일 용의가 전송 인코딩을 지정합니다. (비공식적으로 &lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt; 이라고 부를 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 의 기능을 통해 검색 속성의 값을 볼 수 있습니다 응답 헤더를 지정 기원 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;자원 타이밍 API&lt;/a&gt; 그렇지 않으면 때문에 출처 간 제한 0으로보고 될 것이다.</target>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 순방향 및 역방향 프록시 프록시에 의해 첨가하고, 요청 헤더 및 응답 헤더에 표시 할 수있다. 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 보낸 사람의 프로토콜 기능을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; HTTP 헤더는 것을 나타 내기 위해 서버에서 사용되는 마커은 응답 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; 에 광고 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 변경되지 않아야하고 따라야 헤더. 이를 통해 &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME 유형 스니핑&lt;/a&gt; 을 거부 할 수 있습니다. 즉, 웹 마스터가 자신이하는 일을 알고 있다고 말하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분은 Firefox가 전화 크기 또는 태블릿 장치에서 실행 중인지 나타냅니다. Firefox가 전화 폼 팩터가있는 장치에서 실행되면 &lt;code&gt;Mobile;&lt;/code&gt; UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분에있는 토큰 . Firefox가 태블릿 장치에서 실행될 때 &lt;code&gt;Tablet;&lt;/code&gt; 대신 UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분에 토큰을 추가하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; HTTP 헤더이 광고를 클라이언트가 이해할 수있는 문자 집합을 요청합니다. 그런 다음 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 서버는 제안 중 하나를 선택하고이를 사용하여 클라이언트에게 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 응답 헤더 내에서 선택한 것을 알립니다 . 브라우저는 일반적으로이 헤더를 각 컨텐츠 유형의 기본값이 올바른 것으로 설정하지 않으며이를 전송하면 더 쉬운 지문 인식이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; 요청 HTTP 헤더이 광고를 콘텐츠 된 인코딩, 일반적으로 압축 알고리즘, 클라이언트가 이해 할 수 있습니다. 서버는 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 제안 중 하나를 선택하고이를 사용하여 클라이언트에게 &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; HTTP 헤더이 광고를 클라이언트가 이해할 수있는 언어로, 어느 로케일 변형하는 것이 바람직하고 요청합니다. (언어로, 우리는 프로그래밍 언어가 아닌 영어와 같은 자연어를 의미합니다.) &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 서버는 제안 중 하나를 선택하여 사용하고 클라이언트에게 &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 . 브라우저는 사용자 인터페이스 언어에 따라이 헤더에 대한 적절한 값을 설정하며 사용자가 변경할 수있는 경우에도 거의 발생하지 않으며 지문이 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; 로 표현 내용 유형, 요청 HTTP 헤더이 광고를 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; , 클라이언트가 이해 할 수 있습니다. 서버는 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 제안서 중 하나를 선택하여 사용하고 클라이언트에게 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 . 브라우저는 요청이 수행되는 컨텍스트에 따라이 헤더에 적절한 값을 설정합니다. CSS 스타일 시트를 가져올 때 이미지, 비디오 또는 스크립트를 가져올 때와 다른 값이 요청에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 와 함께 작동 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; 의&lt;/a&gt; 속성 또는으로 &lt;code&gt;credentials&lt;/code&gt; 에서 옵션을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 페치 API의 생성자를. 자격 증명이있는 CORS 요청의 경우, 브라우저가 서버 ( &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 헤더 사용)와 클라이언트 (XHR, Fetch, 또는 Ajax 요청)은 자격 증명 포함을 선택하고 있음을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 응답 헤더는 요청에 대한 응답이 페이지에 노출 될 수 있는지 여부를 나타냅니다. &lt;code&gt;true&lt;/code&gt; 값이 반환 될 때 노출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 응답 헤더는 요청의 인증 모드 (경우에 자바 스크립트 코드를 프론트 엔드에 대한 응답을 노출 여부를 브라우저에 알려줍니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; 가&lt;/a&gt; ) &quot;입니다 &lt;code&gt;include&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더는에 응답하여 서버에서 전송되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; ; CORS 요청에 어떤 &lt;a href=&quot;../../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 가 허용 되는지 클라이언트에 알려 줍니다. 클라이언트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 헤더에서 제공하지 않는 쉼표로 구분 된 값 중에서 헤더 이름으로 인식되지 않는 헤더 이름을 찾으면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">서버는 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더를 보내 클라이언트에게 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청을 지원하는 헤더를 알려줍니다 . &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 의 값은 &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; 과 같이 쉼표로 구분 된 헤더 이름 목록 이거나 표준이지만 기본이 아닌 헤더 이름 (항상 허용됨) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 응답 헤더는 응답에 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 포함 &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 실제 요청시 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">서버는 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 헤더를 보내 클라이언트가 CORS 요청에 대해 지원 하는 &lt;a href=&quot;../../methods&quot;&gt;HTTP 요청 방법&lt;/a&gt; 을 알려줍니다 . 헤더의 값은 &lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 같이 쉼표로 구분 된 HTTP 메소드 이름 문자열입니다 . 클라이언트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 지정된 값을 인식하지 못하면 이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; (A)에 응답하여, 상기 자원에 액세스 할 때의 방법 또는 방법들은 허용 응답 헤더 지정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;플라이트 요청&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 응답 헤더는 헤더 이름을 나열하여 응답의 한 부분으로 노출 될 수 있습니다 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 응답 헤더는 얼마나 오래 결과를 나타냅니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 합니다 (에 포함 된 정보입니다 &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 캐시 할 수있는 헤더).</target>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 발행 할 때 요청 헤더가 사용됩니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 서버 알려 &lt;a href=&quot;../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 실제 요청이있을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 발행 할 때 요청 헤더가 사용됩니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 서버 알려 &lt;a href=&quot;../methods&quot;&gt;HTTP 방법&lt;/a&gt; 실제 요청이있을 때 사용됩니다. 프리 플라이트 요청은 항상 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 이며 실제 요청과 동일한 방법을 사용하지 않으므로이 헤더가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">&lt;code&gt;Age&lt;/code&gt; 헤더는 일반적으로 가까운 제로입니다. 이 경우 &lt;code&gt;Age: 0&lt;/code&gt; , 그것은 아마 원본 서버에서 가져되었다; 그렇지 않으면 일반적으로 프록시의 현재 날짜와 HTTP 응답에 포함 된 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 일반 헤더 의 차이로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; 헤더는이 웹 사이트에 도달하기 위해 목록 다른 방법으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 의 방법은 타겟 자원에 의해 식별되는 서버에 터널을 설정한다.</target>
        </trans-unit>
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 의 방법은 요청 된 리소스와 양방향 통신을 시작합니다. 터널을 여는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 일반 헤더 필드는 요청과 응답 모두 메커니즘을 캐싱에 대한 지시자를 표시하는 데 사용한다. 캐싱 지시문은 단방향입니다. 즉, 요청의 지정된 지시문이 응답에 동일한 지시문이 제공되어야 함을 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-control&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더는 하나 개 이상의 지시를 받아들입니다. 모든 유형의 데이터를 지우면 와일드 카드 지시문 ( &lt;code&gt;&quot;*&quot;&lt;/code&gt; )을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더는 요청 웹 사이트와 관련된 데이터 (쿠키, 저장, 캐시)을 찾아 삭제합니다. 이를 통해 웹 개발자는 브라우저를 통해 로컬에 저장된 데이터를 더 많이 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; 일반 헤더 컨트롤이 있는지 여부를 네트워크 연결 숙박은 현재 트랜잭션이 완료된 후 엽니 다. 전송 된 값이 &lt;code&gt;keep-alive&lt;/code&gt; 인 경우 연결은 지속적이며 닫히지 않으므로 동일한 서버에 대한 후속 요청을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; 헤더로 설정 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 업그레이드가 요구되는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; 헤더는 전자 메일 MIME 메시지의 큰 맥락에서 정의되지만 가능한 매개 변수의 서브 세트 만 HTTP 양식 및 적용 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청. 선택적 지시문 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 뿐만 아니라 &lt;code&gt;form-data&lt;/code&gt; 값만 HTTP 컨텍스트에서 사용할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
