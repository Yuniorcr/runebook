<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; 엔티티 헤더는 미디어 유형을 압축하는 데 사용됩니다. 존재하는 경우 해당 값은 엔티티 본문에 적용된 인코딩을 나타냅니다. &lt;code&gt;Content-Type&lt;/code&gt; 헤더가 참조하는 미디어 유형을 얻기 위해 클라이언트에게 디코딩 방법을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; 헤더는 지정하는 데 사용되는 &lt;strong&gt;페이지의 대상 독자를&lt;/strong&gt; ,이 더 하나 개의 언어보다 것을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;엔티티 헤더&lt;/a&gt; 는 사용자가 사용자의 선호하는 언어에 따라 차별화 할 수 있습니다 그래서, 언어 (들)을 설명하는 사용자를 대상으로하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; 엔터티 헤더는 기업-body의 크기를 바이트 단위로 수신자에게 전송.</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; 헤더는 반환 된 데이터의 대체 위치를 나타냅니다. 주된 용도는 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 의 결과로 전송 된 자원의 URL을 나타내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; 전체 본문 메시지에 일부 메시지가 속한 곳 응답 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; 엔티티 헤더는 표시하는 데 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;미디어 유형&lt;/a&gt; 자원을.</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; HTTP 요청 헤더가 저장 포함 &lt;a href=&quot;../cookies&quot;&gt;HTTP 쿠키&lt;/a&gt; 이전에 서버가 보낸 &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; 헤더는 선택 사항이며, 예를 들어, 브라우저의 개인 정보 설정이 쿠키를 차단, 경우 생략 할 수있다.</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 방법은 지정된 자원을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; ( &lt;strong&gt;D&lt;/strong&gt; O &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt; 요청 헤더 랙) 사용자의 트래킹 순위를 나타낸다. 이를 통해 사용자는 개인화 된 컨텐츠보다는 프라이버시를 선호하는지 여부를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 일반 HTTP 헤더는 메시지가 유래 된 날짜와 시간이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; 과 &lt;code&gt;Path&lt;/code&gt; 지침은 정의 &lt;em&gt;범위&lt;/em&gt; 쿠키가로 전송해야하는지의 URL : 쿠키의를.</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; HTTP 응답의 헤더는 자원의 특정 버전에 대한 식별자이다. 컨텐츠가 변경되지 않은 경우 웹 서버가 전체 응답을 보낼 필요가 없으므로 캐시의 효율성이 향상되고 대역폭이 절약됩니다. 한편, 컨텐츠가 변경된 경우, etags는 자원의 동시 업데이트가 서로 겹쳐 쓰이지 않도록하는 데 유용합니다 ( &quot;공중 충돌&quot;).</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 헤더는 주목 갈에서 해당 사이트에 대한 misissued 인증서의 사용을 방지 인증서 투명성 요구 사항 및 / 또는 집행을보고하도록 선택에 사이트를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 헤더는 주목 갈에서 해당 사이트에 대한 misissued 인증서의 사용을 방지 인증서 투명성 요구 사항 및 / 또는 집행을보고하도록 선택에 사이트를 할 수 있습니다. 사이트에서 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더를 사용하도록 설정하면 브라우저는 해당 사이트에 대한 인증서가 공용 CT 로그에 나타나는지 브라우저가 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; HTTP 요청 헤더는 필요가 제대로 요청을 처리하기 위해 서버에 의해 성취 될 수 있다는 기대를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; 헤더는 프록시가 요청의 경로에 관여하는 경우 변경 또는 손실 프록시 서버의 클라이언트 측면에서 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 의 방법은 지정된 리소스의 표현을 요구한다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 은 지정된 자원의 표현을 요구한다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 방법은 그와 동일한 응답을 요청 &lt;code&gt;GET&lt;/code&gt; 을 요청하지만, 응답 본체없이.</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 는 지정된 리소스가 HTTP로 요청 될 경우 반환되는 헤더 요청 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 방법을. 예를 들어, 대역폭을 절약하기 위해 큰 리소스를 다운로드하기로 결정하기 전에 이러한 요청을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; 쿠키 속성은 자바 스크립트를 통해 쿠키 값에 대한 액세스를 방지하여 공격을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; HTTP 요청 헤더는 요청 조건을합니다. 들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 가 나열된 중 하나와 일치하는 경우에만 방법, 서버는 요청 된 리소스를 다시 보내드립니다 &lt;code&gt;ETags&lt;/code&gt; . 들어 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 및 기타 비 안전 방법, 그것은 단지이 경우 리소스를 업로드합니다.</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;If-Modified-Since&lt;/code&gt; 요청 HTTP 헤더 요구 조건을 만드는 : 서버가 함께 요청 된 리소스를 다시 보내드립니다 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 가 마지막으로 주어진 날짜 이후 수정 된 경우에만 상태입니다. 이후 요청이 수정되지 않은 경우 응답은 본문이없는 &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; 입니다&lt;/a&gt; . 이전 요청 의 &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 응답 헤더에는 마지막 수정 날짜가 포함됩니다. 달리 &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-Modified-Since&lt;/code&gt; 만 사용할 수 있습니다 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; HTTP 요청 헤더는 요청 조건을합니다. 들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 방법, 서버는 함께 요청 된 리소스를 다시 보내드립니다 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 그것이이없는 경우에만 상태 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 주어진 것과 일치합니다. 다른 방법의 경우 최종 기존 리소스의 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가 나열된 값과 일치하지 않는 경우에만 요청이 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; HTTP 요청 헤더는 다양한 요구 조건합니다 : 조건이 충족되는 경우, 범위 요청이 발행되고 서버가 다시 전송 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 해당하는 몸 대답을. 조건이 충족되지 않으면 전체 자원이 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 반송 됩니다.</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 요청 HTTP 헤더 조건부 요청한다 : 서버가 요청 된 리소스를 다시 보내거나 경우에 그것을 받아 들일 것 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 다른 비 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 이 마지막으로 주어진 이후에 수정되지 않은 경우에만, 방법을 데이트. 지정된 날짜 이후에 요청이 수정 된 경우 응답은 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 오류입니다.</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 요청 HTTP 헤더 조건부 요청한다 : 서버가 요청 된 리소스를 다시 보내거나 경우에 그것을 받아 들일 것 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 다른 비 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 이 마지막으로 주어진 이후에 수정되지 않은 경우에만, 방법을 데이트. 지정된 날짜 이후에 리소스가 수정 된 경우 응답은 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 을 잘못 사용하는 경우 헤더는 경고 또는 오류 메시지가 발생합니다. 당신은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;웹 콘솔&lt;/a&gt; 에서 그것들을 보게 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; 응답 HTTP 헤더가 원 서버가 자원이 마지막으로 변경되었다고 믿는 날짜와 시간이 포함되어 있습니다. 수신 또는 저장된 자원이 동일한 지 판별하기 위해 유효성 검증기로 사용됩니다. &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 헤더 보다 정확도가 떨어지면 대체 메커니즘입니다. &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 포함하는 조건부 요청 은이 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; 응답 헤더에 페이지를 리디렉션 할 URL을 나타냅니다. &lt;code&gt;3xx&lt;/code&gt; (리디렉션) 또는 &lt;code&gt;201&lt;/code&gt; (만든) 상태 응답 과 함께 제공 될 때만 의미를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 는 대상 자원의 통신 옵션을 설명하는 데 사용된다. 클라이언트는 OPTIONS 메소드의 URL 또는 별표 (*)를 지정하여 전체 서버를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 의 방법은 대상 리소스의 통신 옵션을 설명하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; A가에서 유래를 가져 오는 경우 요청 헤더를 나타냅니다. 경로 정보는 포함하지 않고 서버 이름 만 포함합니다. &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청 과 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청 과 함께 전송됩니다 . &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더 와 비슷 하지만이 헤더와 달리 전체 경로를 공개하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 방법은 리소스에 일부 변경을 적용하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 의 방법들은 서버 상태 또는 부작용의 변화를 일으키는 상기 특정 자원 엔티티를 제출하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 는 서버에 데이터를 전송합니다. 요청 본문의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 Content-Type 헤더로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 의 방법은 요청 페이로드 대상 자원의 현재 표현을 대체한다.</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; 헤더가 함께 전송됩니다 &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTP 요청 헤더는 서버가 반환해야하는 문서의 일부를 나타냅니다. 한 번에 하나의 &lt;code&gt;Range&lt;/code&gt; 헤더로 여러 부분을 요청할 수 있으며 서버는 이러한 범위를 여러 부분으로 된 문서로 다시 보낼 수 있습니다. 서버가 범위를 다시 보내면 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 를 사용하여 응답합니다. 범위가 유효하지 않으면 서버는 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; 오류를 리턴합니다 . 서버는 &lt;code&gt;Range&lt;/code&gt; 헤더를 무시하고 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 개의&lt;/a&gt; 상태 코드로 전체 문서를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP 헤더 다스리이되는 리퍼러에 전송되는 정보, &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더 된 요청에 포함되어야한다.</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; 응답 HTTP 헤더는 사용자 에이전트가 후속 요청을하기 전에 기다리는 시간을 나타냅니다. 이 헤더가 사용되는 세 가지 주요 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">&lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 헤더 지정하는 하나 이상의 웹 소켓 프로토콜은 우선 순위에 따라, 사용하고자하는 것이다. 서버에서 지원하는 첫 번째 서버가 응답에 포함 된 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 헤더 에서 서버에 의해 선택되어 반환됩니다 . 헤더에서도 이것을 두 번 이상 사용할 수 있습니다. 결과는 단일 헤더에 쉼표로 구분 된 서브 프로토콜 식별자 목록을 사용한 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 헤더는 주어진 요청 - 응답주기에 대해 하나 개 이상의 메트릭과 설명을 전달합니다. 사용자 브라우저 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt; 인터페이스 의 개발자 도구에 백엔드 서버 타이밍 메트릭 (예 : 데이터베이스 읽기 / 쓰기, CPU 시간, 파일 시스템 액세스 등)을 표시하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 헤더는 잠재적으로 민감한 애플리케이션 및 인프라 정보가 노출 될 수 있습니다. 서버 측에서 언제, 누구에게 어떤 메트릭이 리턴되는지 제어하십시오. 예를 들어 인증 된 사용자에게만 메트릭을 표시하고 일반 사용자에게는 아무 것도 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTP 응답 헤더는 사용자 에이전트 서버에서 쿠키를 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; 와 &lt;code&gt;Cookie&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">&lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; A와 코드를 생성 응답 헤더 링크 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;소스 맵&lt;/a&gt; 브라우저를 가능하게는, 원래의 소스를 재구성하고 디버거에서 복원 된 원본을 제시한다.</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; (종종 축약 응답 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS는&lt;/a&gt; ) 웹 사이트가 HTTPS를 사용하여, 대신에 HTTP를 사용하여 만 접근해야한다고 브라우저를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; 의 방법은 대상 자원의 경로를 따라 메시지 루프 - 백 테스트를 수행한다.</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; 는 유용한 디버그 메커니즘을 제공 대상 자원의 경로를 따라 메시지 루프 - 백 테스트를 수행한다.</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; 응답 헤더는 해당 요청에 적용되는 추적 상태를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; 헤더를 안전하게 전송하기 위해 사용되는 인코딩 형식 지정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;엔티티를&lt;/a&gt; 사용자에게있다.</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; 우선 순위에 따라 헤더를 지정하는 하나 이상의 쉼표로 구분 프로토콜 이름.</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">(가) &lt;code&gt;Vary&lt;/code&gt; HTTP를 응답 헤더는 캐시 된 응답이 원본 서버에서 새로운 하나를 요청하는 대신 사용할 수 있는지 여부를 결정하는 미래의 요청 헤더와 일치하는 방법을 결정합니다. &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 알고리즘 에서 자원의 표시를 선택할 때 사용한 헤더를 표시하기 위해 서버에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더가 설정되어야한다 &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 는 동등한에 설정했을 똑같이 응답 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 응답.</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더는 HTTP 버전 1.1에 추가 캐시가 적절하게 작동 할 수 있도록하기 위해 필요했다. 서버 구동 컨텐츠 협상을 수행하기 위해 캐시는 서버가 전송 된 컨텐츠를 선택하기 위해 사용한 기준을 알아야합니다. 이러한 방식으로 캐시는 알고리즘을 재생할 수 있으며 서버에 대한 추가 요청없이 수용 가능한 컨텐츠를 직접 제공 할 수 있습니다. 분명히, 와일드 카드 ' &lt;code&gt;*&lt;/code&gt; '는 캐시가 뒤에있는 요소를 알 수 없으므로 캐싱이 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 응답 헤더를</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 함께 전송된다 &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 응답.</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; 일반적인 HTTP 헤더는 메시지의 상태에 발생할 수있는 문제에 대한 정보가 포함되어 있습니다. 응답에 둘 이상의 &lt;code&gt;Warning&lt;/code&gt; 헤더가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; DNS는 프리 페치 HTTP 응답 헤더 컨트롤, 브라우저가 사전에 사용자가 따를뿐만 아니라 이미지, CSS를 포함하는 문서에 의해 참조 항목의 URL을 선택할 수 있다는 것을 모두 링크에 도메인 이름 확인을 수행하는 기능 , JavaScript 등.</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) 헤더는 HTTP 프록시 또는 부하 분산을 통해 웹 서버에 접속하는 고객의 발신 IP 주소를 식별하기위한 사실상의 표준 헤더이다. 클라이언트와 서버간에 트래픽이 차단되면 서버 액세스 로그에는 프록시 또는로드 밸런서의 IP 주소 만 포함됩니다. 클라이언트의 원래 IP 주소를 보려면 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 요청 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) 헤더는 클라이언트에 의해 요청 된 원래 호스트 식별하기위한 사실상의 표준 헤더 인 &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP 요청 헤더.</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) 헤더는 클라이언트가 프록시 또는 부하 분산 장치에 연결하는 데 사용하는 프로토콜 (HTTP 또는 HTTPS) 식별하기위한 사실상의 표준 헤더입니다. 서버 액세스 로그에는 서버와로드 밸런서 사이에 사용 된 프로토콜이 포함되어 있지만 클라이언트와로드 밸런서 사이에 사용 된 프로토콜은 포함되어 있지 않습니다. 클라이언트와로드 밸런서간에 사용되는 프로토콜을 결정하기 위해 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 요청 헤더를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; 응답 헤더는 브라우저가있는 페이지를 렌더링하도록 허용해야하는지 여부를 표시하는 데 사용할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . 사이트는이를 사용 하여 콘텐츠가 다른 사이트에 포함되지 않도록하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;클릭 재킹&lt;/a&gt; 공격 을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">&lt;code&gt;delta-seconds&lt;/code&gt; 매개 변수는 결과를 캐시 할 수있는 시간 (초)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; 지시어의 구문은 다른 지시자의 소스 목록 (예와 유사하다 &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 하지만, 허용하지 않는 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 예를. 그것은 또한 다시 떨어지지 않을 것이다 &lt;code&gt;default-src&lt;/code&gt; 설정 : 아래 나열된 소스 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 그것을 대소 문자를 구별하게하고, &lt;code&gt;mobi&lt;/code&gt; 모든 모바일 브라우저와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; 매개 변수는 base64로 형식으로 인코딩 될 파일의 이름이고, &lt;code&gt;remotename&lt;/code&gt; 실제로에 사용되지 않는 파일의 원격 이름입니다 &lt;code&gt;data&lt;/code&gt; 의 URL.</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; 같은 MIME 타입 캐릭터 인 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG 이미지 파일. 생략하면 기본값은 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; MIME 유형이 브라우저에 부분적인 응답을 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 완료된 값 전송시 타입이 사용될 수있다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 폼&lt;/a&gt; 서버 브라우저.</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 화이트리스트 또는 소스 표현식 은 무시됩니다. 예제는 &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 지시자는 이전에 평가 &lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt; 과이 설정되어있는 경우, 후자는 효과적으로 조작은 행해지 지 않습니다. HTTP로 경로 재 지정한 후 강제하지 않는 이전 브라우저에서 HTTPS를 강제 실행하지 않는 한 두 지시문 중 하나를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 지시어는 대체하지 않습니다 따라서 타사 사이트의 링크를 통해 사이트를 방문하는 사용자가 최상위 탐색을 위해 HTTPS로 업그레이드됩니다 보장하지 않습니다 &lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) 헤더, 어떤 사용자가 SSL 제거 공격을받지 않도록 적절한 &lt;code&gt;max-age&lt;/code&gt; 으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">&lt;em&gt;HTTP 버전&lt;/em&gt; 응답에 사용할 예정의 버전 표시 자 역할 나머지 메시지의 구조를 정의한다.</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">&lt;em&gt;별표 형태&lt;/em&gt; 간단한 별표 ( &lt;code&gt;'*'&lt;/code&gt; )와 함께 사용 &lt;code&gt;OPTIONS&lt;/code&gt; 서버 전체를 나타내는.</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;프로토콜 버전&lt;/em&gt; , 일반적으로 &lt;code&gt;HTTP/1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">&lt;em&gt;요청 대상&lt;/em&gt; , 통상 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt; 또는 프로토콜, 포트 및 도메인의 절대 경로는 일반적으로 요청 문맥 특징으로한다. 이 요청 대상의 형식은 HTTP 메소드마다 다릅니다. 그것은 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;사용자 에이전트는&lt;/em&gt; 사용자를 대신하여 역할을 어떤 도구입니다. 이 역할은 주로 웹 브라우저에서 수행됩니다. 엔지니어와 웹 개발자가 응용 프로그램을 디버깅하는 데 사용하는 프로그램은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Alt 키-SVC의&lt;/strong&gt; 헤더는이 웹 사이트에 도달하기 위해 목록 다른 방법으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">&lt;strong&gt;HTTP DELETE 요청 방법은&lt;/strong&gt; 지정된 자원을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;strong&gt;HTTP 패치 요청 방법은&lt;/strong&gt; 리소스에 일부 변경을 적용한다.</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;strong&gt;HTTP PUT 요청의 방법은&lt;/strong&gt; 새로운 자원을 생성 또는 요청 페이로드 대상 자원의 표시를 대체한다.</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;급 - 웹 소켓으로 수락&lt;/strong&gt; 헤더는 웹 소켓 개구 악수 사용된다. 응답 헤더에 나타납니다. 즉, 서버가 웹 소켓 연결을 시작하려고한다는 것을 알리기 위해 서버에서 클라이언트로 헤더가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;트레일러&lt;/strong&gt; 응답 헤더는 송신자가 메시지 본문이 그러한 메시지 무결성 검사, 디지털 서명, 또는 후 처리 상태와 같은 전송 동안 동적으로 생성 될 수 공급 메타하기 위해 청크 메시지의 끝에 추가 필드를 포함 할 수있다.</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;사용자 에이전트&lt;/strong&gt; 요청 헤더는 네트워크 프로토콜 피어 응용 프로그램 유형, 운영 체제, 소프트웨어 공급 업체 또는 요청 소프트웨어 사용자 에이전트의 소프트웨어 버전을 식별 할 수있는 특성 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">요청 헤더 승인 필드를 사용하여 응답에 적합한 특정 매체 유형을 지정할 수 있습니다. 수락 헤더는 인라인 이미지에 대한 요청의 경우와 같이 요청이 원하는 유형의 작은 세트로 특별히 제한됨을 나타내는 데 사용될 수 있습니다. Accept = &quot;Accept&quot; &quot;:&quot;# (media-range [accept-params]) media-range = ( &quot;* / *&quot;| ( &quot;/&quot; &quot;*&quot;) | ( &quot;/&quot;하위 유형)) * ( &quot;;&quot;parameter) accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue * (accept-extension) accept-extension = &quot;;&quot; token [ &quot;=&quot;(token | quoted-string)] 별표 &quot;*&quot;문자는 미디어 유형을 범위로 그룹화하는 데 사용되며 &quot;* / *&quot;는 모든 미디어 유형을 나타내고 &quot;type / *&quot;은 해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위는 해당 범위에 적용 할 수있는 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (미디어 범위는 해당 범위에 적용 가능한 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (미디어 범위는 해당 범위에 적용 할 수있는 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (&lt;a href=&quot;#section-3.9&quot;&gt;섹션 3.9&lt;/a&gt;). 기본값은 q = 1입니다. 참고 : &quot;q&quot;매개 변수 이름을 사용하여 미디어 유형 매개 변수를 확장 확장 매개 변수 허용과 분리하는 것은 이전의 관행 때문입니다. 이렇게하면 &quot;q&quot;라는 매체 유형 매개 변수가 매체 범위와 함께 사용되지 않지만, 이러한 이벤트는 IANA 매체 유형 레지스트리에 &quot;q&quot;매개 변수가없고 매체 유형이 거의 사용되지 않는 것으로 간주됩니다. 수락의 매개 변수. 향후 미디어 유형은 &quot;q&quot;라는 매개 변수를 등록하지 않는 것이 좋습니다. 수락 예 : audio / *; q = 0.2, 오디오 / 기본은 &quot;오디오 / 기본을 선호하지만 품질이 80 % 감소한 후에 가장 좋은 오디오 유형을 보내 주시기 바랍니다.&quot; 수락 헤더 필드가 없으면클라이언트는 모든 매체 유형을 승인한다고 가정합니다. 수락 헤더 필드가 있고 서버가 결합 된 수락 필드 값에 따라 허용되는 응답을 보낼 수없는 경우 서버는 406 (허용되지 않음) 응답을 보내야합니다. 보다 정교한 예는 Accept : text / plain; q = 0.5, 텍스트 / html, 텍스트 / x-dvi; q = 0.8, text / xc 구두로, 이것은 &quot;text / html 및 text / xc가 선호되는 미디어 유형으로 해석되지만 존재하지 않는 경우 text / x-dvi 엔티티를 보내십시오. 텍스트 / 일반 엔티티를 보냅니다. &quot; 보다 구체적인 용지 범위 또는 특정 용지 종류로 용지 범위를 재정의 할 수 있습니다. 특정 유형에 둘 이상의 매체 범위가 적용되는 경우 가장 구체적인 참조가 우선합니다. 예를 들어 수락 :text / *, text / html, text / html; level = 1, * / *의 우선 순위는 1) text / html; level = 1 2) text / html 3) text / * 4) * / * 미디어입니다. 주어진 유형과 관련된 유형 품질 계수는 해당 유형과 일치하는 우선 순위가 가장 높은 미디어 범위를 찾아서 결정됩니다. 예를 들어 수락 : text / *; q = 0.3, text / html; q = 0.7, text / html; level = 1, text / html; level = 2; q = 0.4, * / *; q = 0.5는 연관 될 다음 값 : text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7 참고 : 사용자 에이전트에 특정 미디어 범위에 대한 기본 품질 값 세트가 제공 될 수 있습니다.그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charset request-header 필드는 응답에 허용되는 문자 집합을 나타내는 데 사용할 수 있습니다. 이 필드를 사용하면보다 포괄적이거나 특수한 문자 세트를 이해할 수있는 클라이언트가 해당 문자 세트의 문서를 나타낼 수있는 서버에 해당 기능을 알릴 수 있습니다. Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;1 # ((charset | &quot;*&quot;) [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) 문자 세트 값은&lt;a href=&quot;#section-3.4&quot;&gt; 3.4 절에 있습니다.&lt;/a&gt;. 각 문자 세트에는 해당 문자 세트에 대한 사용자의 선호도를 나타내는 관련 품질 값이 주어질 수 있습니다. 기본값은 q = 1입니다. 예는 Accept-Charset입니다. iso-8859-5, unicode-1-1; q = 0.8 Accept-Charset 필드에있는 특수 값 &quot;*&quot;는 모든 문자 세트 (ISO-8859-1 포함)와 일치합니다. Accept-Charset 필드의 다른 곳에서는 언급되지 않았습니다. Accept-Charset 필드에 &quot;*&quot;가 없으면 명시 적으로 언급되지 않은 경우 품질 값이 1 인 ISO-8859-1을 제외하고 명시 적으로 언급되지 않은 모든 문자 세트의 품질 값은 0입니다. Accept-Charset 헤더가 없으면 기본적으로 모든 문자 집합이 허용됩니다. Accept-Charset 헤더가 있으면서버가 Accept-Charset 헤더에 따라 허용되는 응답을 보낼 수없는 경우 서버는 허용 할 수없는 응답 전송도 허용되지만 406 (허용되지 않음) 상태 코드로 오류 응답을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-Encoding request-header 필드는 Accept와 유사하지만 컨텐츠 코딩을 제한합니다 (&lt;a href=&quot;#section-3.5&quot;&gt; (3.5 절&lt;/a&gt;)가 응답에 허용됩니다. Accept-Encoding = &quot;Accept-Encoding&quot; &quot;:&quot;1 # (codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) codings = (content-coding | &quot;*&quot;) 사용 예는 다음과 같습니다. Accept-Encoding : 압축, gzip Accept-Encoding : Accept-Encoding : * Accept-Encoding : compress; q = 0.5, gzip; q = 1.0 Accept-Encoding : gzip; q = 1.0, ID; q = 0.5, *; q = 0 서버는 다음 규칙을 사용하여 Accept-Encoding 필드에 따라 컨텐츠 코딩이 허용되는지 여부를 테스트합니다. 1. 컨텐츠 코딩이 Accept에 나열된 컨텐츠 코딩 중 하나 인 경우 -인코딩 필드, q 값이 0이 아닌 경우 허용됩니다.&lt;a href=&quot;#section-3.9&quot;&gt; 섹션 3.9에&lt;/a&gt;qvalue 0은 &quot;허용되지 않음&quot;을 의미합니다. 2. Accept-Encoding 필드의 특수 &quot;*&quot;기호는 헤더 필드에 명시 적으로 나열되지 않은 사용 가능한 모든 컨텐츠 코딩과 일치합니다. 3. 다수의 컨텐츠 코딩이 허용 가능한 경우, 0이 아닌 q 값을 갖는 허용 가능한 컨텐츠 코딩이 선호됩니다. 4. Accept-Encoding 필드에 &quot;identity; q = 0&quot;이 포함되거나 필드에 &quot;*; q = 0&quot;이 포함되고 &quot;*; q = 0&quot;이 포함되어 있고 &quot;&quot;; 신원 &quot;콘텐츠 코딩. Accept-Encoding 필드 값이 비어 있으면 &quot;identity&quot;인코딩 만 허용됩니다.Accept-Encoding 필드가 요청에 있고 서버가 Accept-Encoding 헤더에 따라 허용되는 응답을 보낼 수없는 경우 서버는 406 (Not Acceptable) 상태 코드와 함께 오류 응답을 보내야합니다. 요청에 Accept-Encoding 필드가 없으면 서버는 클라이언트가 모든 컨텐츠 코딩을 수락한다고 가정 할 수 있습니다. 이 경우, &quot;identity&quot;가 이용 가능한 컨텐츠 코딩 중 하나라면, 다른 컨텐츠 코딩이 클라이언트에게 의미가 있다는 추가 정보가없는 한, 서버는 &quot;identity&quot;컨텐츠 코딩을 사용해야한다. 참고 : 요청에 Accept-Encoding 필드가 포함되어 있지 않고 &quot;identity&quot;컨텐츠 코딩을 사용할 수없는 경우 HTTP / 1.0 클라이언트에서 일반적으로 이해하는 컨텐츠 코딩 (예 :&quot;gzip&quot;및 &quot;compress&quot;)가 선호됩니다. 일부 오래된 클라이언트는 다른 컨텐츠 코딩으로 전송 된 메시지를 부적절하게 표시합니다. 서버는 특정 사용자 에이전트 또는 클라이언트에 대한 정보를 기반으로이 결정을 내릴 수도 있습니다. 참고 : 대부분의 HTTP / 1.0 응용 프로그램은 컨텐츠 코딩과 관련된 q 값을 인식하거나 따르지 않습니다. 이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-Language request-header 필드는 Accept와 비슷하지만 요청에 대한 응답으로 선호되는 자연어 세트를 제한합니다. 언어 태그는 &lt;a href=&quot;#section-3.10&quot;&gt;섹션 3.10에&lt;/a&gt; 정의되어 있습니다.. Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;1 # (language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) language-range = ((1 * 8ALPHA * ( &quot;-&quot;1 * 8ALPHA)) &quot;*&quot;) 각 언어 범위에는 해당 범위에 의해 지정된 언어에 대한 사용자의 선호도 추정치를 나타내는 관련 품질 값이 주어질 수 있습니다. 품질 값의 기본값은 &quot;q = 1&quot;입니다. 예를 들어 Accept-Language : da, en-gb; q = 0.8, en; q = 0.7은 &quot;나는 덴마크어를 선호하지만 영국 영어와 다른 유형의 영어는 허용합니다&quot;를 의미합니다. 언어 범위는 태그와 정확히 일치하거나 접두사 다음에 오는 첫 번째 태그 문자가 &quot;-&quot;가되도록 태그의 접두사와 정확히 일치하는 경우 언어 태그와 일치합니다.Accept-Language 필드에있는 경우 특수 범위 &quot;*&quot;는 Accept-Language 필드에있는 다른 범위와 일치하지 않는 모든 태그와 일치합니다. 참고 : 접두사 일치 규칙을 사용한다고해서 언어 태그가 언어에 할당되었다는 의미는 아닙니다. 사용자가 특정 태그가있는 언어를 이해하면이 사용자는 태그가있는 모든 언어도 이해할 수 있습니다 이 태그는 접두사입니다. 접두사 규칙을 사용하면 접두사 태그를 사용할 수 있습니다. Accept-Language 필드에 의해 언어 태그에 할당 된 언어 품질 요소는 언어 태그와 일치하는 필드에서 가장 긴 언어 범위의 품질 값입니다. 필드의 언어 범위가 태그와 일치하지 않으면 할당 된 언어 품질 계수는 0입니다.요청에 Accept-Language 헤더가 없으면 서버는 모든 언어가 똑같이 수용 가능한 것으로 가정해야합니다. Accept-Language 헤더가 있으면 0보다 큰 품질 계수가 지정된 모든 언어를 사용할 수 있습니다. 모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은 &lt;a href=&quot;#section-15.1.4&quot;&gt;섹션 15.1.4&lt;/a&gt;. 명료성은 개별 사용자에 따라 크게 달라 지므로 클라이언트 응용 프로그램에서 언어 선호도를 선택할 수 있도록하는 것이 좋습니다. 선택이 불가능한 경우 요청에 Accept-Language 헤더 필드를 지정해서는 안됩니다 (MUST NOT). 참고 : 언어 선호도 선택을 사용자에게 제공 할 때 사용자는 위에서 설명한대로 언어 일치에 대한 세부 사항에 익숙하지 않으며 적절한 지침을 제공해야한다는 사실을 구현 자에게 상기시킵니다. 예를 들어, 사용자는 &quot;en-gb&quot;를 선택할 때 영국 영어를 사용할 수없는 경우 모든 종류의 영어 문서가 제공된다고 가정 할 수 있습니다. 이 경우 사용자 에이전트는 &quot;en&quot;을 추가하여 가장 일치하는 동작을 얻을 것을 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Ranges response-header 필드는 서버가 자원에 대한 범위 요청의 수락을 표시 할 수있게합니다. &quot;none&quot;바이트 범위 요청을 수락하는 오리진 서버는 Accept-Ranges : bytes를 보낼 수 있지만 반드시 그럴 필요는 없습니다. 클라이언트는 관련된 리소스에 대해이 헤더를받지 않고도 바이트 범위 요청을 생성 할 수 있습니다. 범위 단위는 &lt;a href=&quot;#section-3.12&quot;&gt;섹션 3.12에&lt;/a&gt; 정의되어 있습니다 . 자원에 대해 어떤 종류의 범위 요청도 허용하지 않는 서버는 수락 범위를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Age 헤더 필드는 캐시에서 얻은 응답 메시지의 예상 수명을 전달하는 데 사용됩니다. Age 필드 값은 응답이 오리진 서버에 의해 생성되거나 유효성 검증 된 이후의 캐시 예상 시간 (초)입니다. 본질적으로 Age 값은 응답이 원래 서버의 경로를 따라 각 캐시에 상주 한 시간과 네트워크 경로를 따라 전송 된 시간의 합계입니다. 연령 계산에 다음 데이터가 사용됩니다. age_value &quot;age_value&quot;라는 용어는 연령 헤더 필드의 값을 나타냅니다 (&lt;a href=&quot;#section-5.1&quot;&gt; 섹션 5.1&lt;/a&gt;) 산술 연산에 적합한 형태 또는 사용할 수없는 경우 0입니다. date_value &quot;date_value&quot;라는 용어는 날짜 헤더 필드의 값을 산술 연산에 적합한 형식으로 나타냅니다. 날짜 헤더 필드의 정의 및 필드가없는 응답에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;은 [RFC7231]의 7.1.1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;단원을&lt;/a&gt; 참조하십시오 . &quot;지금&quot;이라는 용어는 &quot;계산을 수행하는 호스트에서의 클럭의 현재 값&quot;을 의미합니다. 호스트는 NTP를 사용해야합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt; RFC5905&lt;/a&gt;]) 또는 유사한 프로토콜을 사용하여 시계를 협정 세계시로 동기화합니다. request_time 저장된 응답을 생성 한 요청이있을 때 호스트에서 클록의 현재 값. response_time 응답을 받았을 때 호스트에서 클럭의 현재 값. 응답 시간은 완전히 독립적 인 두 가지 방법으로 계산할 수 있습니다. 1. 로컬 시계가 원래 서버의 시계와 합리적으로 동기화 된 경우 &quot;apparent_age&quot;: response_time에서 date_value를 뺀 값입니다. 결과가 음수이면 결과는 0으로 대체됩니다. 2. 응답 경로를 따라 모든 캐시가 HTTP / 1.1을 구현하는 경우 &quot;corrected_age_value&quot;.캐시는 응답이 수신 된 시간이 아니라 요청이 시작된 시간을 기준으로이 값을 해석해야합니다. obvious_age = max (0, response_time-날짜 _ 값); response_delay = 응답 시간-요청 시간; corrected_age_value = 연령 _ 값 + 응답 _ 지연; 이들은 corrected_initial_age = max (apparent_age, corrected_age_value); 캐시가 Age 헤더 필드의 값을 확신하지 않는 한 (예를 들어, Via 헤더 필드에 HTTP / 1.0 홉이 없기 때문에),이 경우 corrected_age_value가 corrected_initial_age로 사용될 수 있습니다. 저장된 응답의 origin_age는 저장된 응답이 원래 서버에 의해 마지막으로 유효성 검증 된 이후의 시간을 초 단위로 추가하여 계산할 수 있습니다 (초 단위).resident_time = 현재-response_time; current_age = corrected_initial_age + 상주 _ 시간;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Age response-header (연령 응답 헤더) 필드는 발신자 서버에서 응답 (또는 재확인)이 생성 된 이후 발신자의 예상 시간을 전달합니다. 캐시 된 응답의 수명이 신선도 수명을 초과하지 않으면 &quot;신선한&quot;상태입니다. 연령 값은 &lt;a href=&quot;#section-13.2.3&quot;&gt;섹션 13.2.3에&lt;/a&gt; 지정된대로 계산됩니다.. Age = &quot;Age&quot; &quot;:&quot;age-value age-value = delta-seconds Age 값은 음수가 아닌 10 진수 정수로 시간을 초 단위로 나타냅니다. 캐시가 나타낼 수있는 최대 양의 정수보다 큰 값을 받거나 에이지 계산 중 오버플로가 발생하면 값이 2147483648 (2 ^ 31) 인 Age 헤더를 전송해야합니다. 캐시를 포함하는 HTTP / 1.1 서버는 자체 캐시에서 생성 된 모든 응답에 Age 헤더 필드를 포함해야합니다. 캐시는 적어도 31 비트 범위의 산술 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">엔티티 헤더 허용 필드는 Request-URI에 의해 식별 된 자원에 의해 지원되는 메소드 세트를 나열합니다. 이 필드의 목적은 수신자에게 리소스와 관련된 유효한 방법을 알려주는 것입니다. 헤더 허용 필드는 반드시 405 (Method Not Allowed) 응답에 있어야합니다. Allow = &quot;Allow&quot; &quot;:&quot;#Method 사용 예 : Allow : GET, HEAD, PUT이 필드는 클라이언트가 다른 방법을 시도하지 못하게 할 수 없습니다. 그러나 Allow header (허용 헤더) 필드 값으로 표시되는 지시를 따라야합니다 (SHOULD). 허용되는 실제 메소드 세트는 각 요청시 오리진 서버에 의해 정의됩니다. 헤더 허용 필드에는 PUT 요청이 제공되어 새로운 또는 수정 된 자원이 지원할 방법을 권장 할 수 있습니다.서버는 이러한 방법을 지원할 필요가 없으며 실제 지원되는 방법을 제공하는 응답에 Allow 헤더를 포함해야합니다. 사용자 에이전트는 다른 방법으로 오리진 서버와 통신 할 수 있으므로 프록시는 지정된 모든 메소드를 이해하지 못하더라도 헤더 허용 필드를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atom 프로토콜은 서버 작업에 거의 제한이 없습니다. 여기에 제약 조건을 지정하지 않으면 서버는 특히 클라이언트가 보낸 Atom 항목 조작과 관련하여 동작이 달라질 수 있습니다. 예를 들어,이 스펙은 GET 및 POST와 관련하여 Collections의 예상되는 동작 만 정의하지만 PUT, DELETE, PROPPATCH 및 기타는 콜렉션 자원에서 금지됨을 의미하지는 않습니다.이 스펙은 서버의 내용을 정의하지 않습니다. 그 방법에 대한 답변이 될 것입니다. 마찬가지로 일부 HTTP 상태 코드가 명시 적으로 언급되어 있지만 클라이언트는 서버의 모든 상태 코드를 처리 할 수 ​​있도록 준비해야합니다. 서버는 수락, 거부, 지연, 보통, 검열, 재 포맷, 번역, 재배치,제출 된 컨텐츠를 다시 분류하십시오. 이러한 선택 중 일부만이 클라이언트 요청에 대한 응답으로 즉시 클라이언트에게 다시 중계됩니다. 다른 선택은 피드 또는 게시 된 항목에서 나중에 분명해질 수 있습니다. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [피드 또는 게시 된 항목에서. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [피드 또는 게시 된 항목에서. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;따라서 RFC2616 ]이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom 프로토콜은 HTTP를 사용하여 자원을 공개하고 편집하기위한 조작을 지정합니다. Atom 형식의 표현을 사용하여 해당 자원의 상태 및 메타 데이터를 설명합니다. 리소스 모음을 구성하는 방법을 정의하고 검색, 그룹화 및 분류를 지원하는 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atom 프로토콜은 HTTP에 정의 된 응답 상태 코드를 사용하여 작업의 성공 또는 실패를 나타냅니다. 각 상태 코드에 대한 자세한 정의 는 HTTP 사양 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]을 참조하십시오 . 구현자는 HTTP 사양에 따라 HTTP 4xx 및 5xx 응답 엔터티에는 사람이 읽을 수있는 오류에 대한 설명이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">원자 출판 프로토콜</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및 XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]을 사용하여 웹 자원을 공개하고 편집하기위한 애플리케이션 레벨 프로토콜입니다 . 이 프로토콜은 웹 리소스 생성을 지원하고 다음을위한 기능을 제공합니다. o 컬렉션 : 전체 또는 일부를 검색 할 수있는 리소스 집합. o 서비스 : 컬렉션 검색 및 설명. o 편집 : 리소스 생성, 편집 및 삭제. Atom Publishing Protocol은 서버가 클라이언트의 요청을 처리하는 데 광범위하게 제공된다는 점에서 많은 최신 프로토콜과 다릅니다. 자세한 내용 &lt;a href=&quot;#section-4.4&quot;&gt;은 4.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP를 기반으로하므로 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]의 섹션 15에&lt;/a&gt; 있는 보안 고려 사항이 적용됩니다 . 이 섹션에 나열된 위협은 HTTP에서 실행되는 많은 프로토콜에 적용됩니다. Atompub 실무 그룹은 TLS에서 인증 된 HTTP를 실행함으로써 ( &lt;a href=&quot;#section-14&quot;&gt;14 장에&lt;/a&gt; 설명 된 ) 보호가이 섹션에 나열된 공격으로 인한 많은 문제를 완화하기에 충분하다고 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom Publishing Protocol은 HTTP를 기반으로합니다. HTTP에 대한 인증 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;은 [RFC2616]의 섹션 11&lt;/a&gt; 에서 다룹니다 . 알 수 없거나 권한이없는 클라이언트의 POST 또는 편집을 방지하기 위해 인증 메커니즘을 사용하는 것이 권장되지만 필수는 아닙니다. 인증을 사용하지 않으면 클라이언트와 서버는 사소한 스푸핑, 서비스 거부 및 손상 공격에 취약합니다. 그러나 일부 상황에서는 이것이 허용 가능한 위험입니다. 배포 된 인증 유형은 서버 운영자가 내린 로컬 결정입니다. 클라이언트는 서버 배포마다 다른 인증 체계에 직면 할 수 있습니다. 최소한 클라이언트 및 서버 구현은 HTTP 기본 인증을 사용하도록 구성 할 수 있어야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt; RFC2617&lt;/a&gt;]를 TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ] 또는 TLS 의 후속 표준 트랙 버전 (예 : [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ])과 연결하여 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818에&lt;/a&gt; 설명 된 TLS를 통한 HTTP 사용 규칙을 지원함]. 인증 메커니즘을 선택하면 상호 운용성에 영향을줍니다. 위에서 언급 한 최소 보안 수준 (TLS를 사용한 기본 인증)은이 사양을 게시 할 때 인터넷 응용 프로그램에 대한 모범 사례로 간주되며 상호 운용성을위한 기준을 설정하기에 충분합니다. 구현 자들은 배치 시점에 동등하거나 양호하다고 간주되는 대체 메커니즘을 조사하고 사용하도록 권장됩니다. 새로운 인증 체계를 배포 할 수있는 방식으로 클라이언트를 구현하는 것이 좋습니다. 이 프로토콜은 요청 결과를보고하는 주요 수단으로 HTTP 응답 상태 코드를 사용하므로 서버는 적절한 4xx HTTP 응답 코드 (예 :401 &quot;무단&quot;또는 403 &quot;금지&quot;)에 따라 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP 메소드를 사용하여 다음과 같이 구성원 자원을 작성합니다. o GET은 알려진 자원의 표현을 검색하는 데 사용됩니다. o POST는 동적으로 명명 된 새로운 Resource를 작성하는 데 사용됩니다. 클라이언트가 작성을 위해 비 Atom-Entry 표현을 콜렉션에 제출하면 요청 된 자원에 대한 매체 항목과 콜렉션에 표시 될 자원에 대한 메타 데이터에 대한 매체 링크 항목이라는 두 가지 자원이 항상 작성됩니다. o PUT은 알려진 리소스를 편집하는 데 사용됩니다. 자원 작성에는 사용되지 않습니다. o DELETE는 알려진 자원을 제거하는 데 사용됩니다. Atom 프로토콜은 항목 및 미디어 리소스의 생성, 편집 및 삭제에만 적용됩니다. 컬렉션을 조작 한 결과 다른 리소스를 생성, 편집 및 삭제할 수 있습니다.그러나 이러한 리소스의 수, 미디어 유형 및 Atom 프로토콜 작업의 영향은이 사양의 범위를 벗어납니다. 클라이언트-서버 상호 작용의 모든 측면이 HTTP 측면에서 정의되므로 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;이 사양에서 다루지 않은 영역에 대해서는 RFC2616 ]을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]은 Atom Feed 및 Atom Entry Documents를 모두 식별하기 위해 &quot;application / atom + xml&quot;매체 유형을 정의합니다. 구현 경험에 따르면 Atom Feed 및 Entry 문서는 다른 처리 모델을 가질 수 있으며 차별화해야 할 상황이 있음을 보여주었습니다. 이 사양은 두 가지 유형의 Atom 문서를 구별하는 데 사용되는 &quot;type&quot;매개 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECT 메소드는 수신자가 요청 대상에 의해 식별 된 목적지 오리진 서버에 터널을 설정하도록 요청한 후, 성공하면 터널이 닫힐 때까지 양방향으로 패킷의 블라인드 전달으로 동작을 제한합니다. 터널은 일반적으로 하나 이상의 프록시를 통해 종단 간 가상 연결을 만드는 데 사용되며 TLS (Transport Layer Security, [ 사용하여 보호 할 수 있습니다&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt; RFC5246)를&lt;/a&gt;]). CONNECT는 프록시 요청에만 사용됩니다. 자체 CONNECT 요청을 수신 한 오리진 서버는 2xx (성공) 상태 코드로 응답하여 연결이 설정되었음을 표시 할 수 있습니다. 그러나 대부분의 오리진 서버는 CONNECT를 구현하지 않습니다. CONNECT 요청을 보내는 클라이언트는 반드시 요청 대상의 권한 양식을 보내야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 섹션 5.3&lt;/a&gt;); 즉, 요청 대상은 터널 대상의 호스트 이름과 포트 번호로 구성되며 콜론으로 구분됩니다. 예 : CONNECT server.example.com:80 HTTP / 1.1 호스트 : server.example.com:80 수신자 프록시는 요청 대상에 직접 연결하거나 다른 프록시를 사용하도록 구성된 경우 전달을 통해 터널을 설정할 수 있습니다. 다음 인바운드 프록시에 대한 CONNECT 요청 2xx (성공) 응답은 발신자 (및 모든 인바운드 프록시)가 빈 응답 행 바로 다음에 성공적인 응답 헤더 섹션을 마치는 즉시 터널 모드로 전환됨을 나타냅니다. 해당 빈 줄 이후에 수신 된 데이터는 요청 대상으로 식별 된 서버에서 온 것입니다.성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았으며 연결이 HTTP에 의해 관리됨을 나타냅니다. 터널 중개자가 어느 쪽의 연결이 끊 겼음을 감지하면 터널이 닫힙니다. 중개자는 반드시 닫힌 쪽에서 다른쪽으로 온 미해결 데이터를 전송하고 두 연결을 모두 닫은 다음 배달되지 않은 나머지 데이터는 모두 폐기해야합니다. 프록시 인증을 사용하여 터널을 만들 수있는 권한을 설정할 수 있습니다. 예를 들면 다음과 같습니다. CONNECT server.example.com:80 HTTP / 1.1 호스트 : server.example.com:80 프록시 인증 : basic aGVsbG86d29ybGQ = 임의의 서버로 터널을 설정하는 데 상당한 위험이 있습니다.특히 대상이 웹 트래픽 용이 아닌 잘 알려져 있거나 예약 된 TCP 포트 인 경우. 예를 들어 &quot;example.com:25&quot;의 요청 대상에 연결하려면 프록시가 SMTP 트래픽을 위해 예약 된 포트에 연결해야합니다. 허용되는 경우 프록시를 통해 스팸 전자 메일을 릴레이 할 수 있습니다. CONNECT를 지원하는 프록시는 제한된 알려진 포트 세트 또는 구성 가능한 안전 요청 대상 화이트리스트로 사용을 제한해야합니다. 서버는 2xx (성공) 응답으로 Transfer-Encoding 또는 Content-Length 헤더 필드를 CONNECT에 보내서는 안됩니다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신 된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야합니다. CONNECT 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다.CONNECT 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. CONNECT 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPY 메소드는 Destination 헤더의 URI로 식별 된 대상 자원에서 Request-URI로 식별 된 소스 자원의 복제본을 작성합니다. 대상 헤더가 있어야합니다. COPY 메소드의 정확한 동작은 소스 자원의 유형에 따라 다릅니다. 모든 WebDAV 호환 리소스는 반드시 COPY 방법을 지원해야합니다. 그러나 COPY 메소드를 지원한다고해서 자원을 복사하는 기능이 보장되지는 않습니다. 예를 들어 별도의 프로그램이 같은 서버의 리소스를 제어 할 수 있습니다. 결과적으로 동일한 서버에있는 위치로 리소스를 복사하지 못할 수 있습니다. 이 방법은 dem 등이지만 안전하지는 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]의 9.1 절&lt;/a&gt; 참조 ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">Depth 헤더가없는 컬렉션의 COPY 메소드는 &quot;infinity&quot;값을 가진 Depth 헤더가 포함 된 것처럼 작동해야합니다. 클라이언트는 값이 &quot;0&quot;또는 &quot;infinity&quot;인 컬렉션의 COPY에 Depth 헤더를 제출할 수 있습니다. 서버는 WebDAV 호환 리소스에서 &quot;0&quot;및 &quot;무한대&quot;깊이 헤더 동작을 지원해야합니다. 무한 깊이 COPY는 Request-URI로 식별 된 콜렉션 자원이 Destination 헤더의 URI로 식별 된 위치로 복사되고 모든 내부 구성원 자원이 재귀 적으로 상대 위치로 복사되도록 지시합니다. 컬렉션 계층의 모든 수준을 통해. / A /의 / A / B / 로의 무한 깊이 복사는 올바르게 처리되지 않으면 무한 재귀로 이어질 수 있습니다. &quot;깊이의 사본 :0 &quot;은 내부 구성원 URL로 식별 된 자원이 아닌 콜렉션 및 해당 특성을 복사하도록 지시합니다. COPY에 포함 된 헤더는 대상 헤더를 제외하고 복사 할 모든 자원을 처리하는 데 적용되어야합니다. Destination 헤더는 Request-URI의 대상 URI 만 지정하며, Request-URI로 식별 된 콜렉션의 멤버에 적용되면 계층 구조의 현재 위치를 반영하도록 Destination 값이 수정됩니다. -URI는 호스트 헤더 값이 http://example.com/ 인 / a /이고 대상은 http://example.com/b/이며, http://example.com/a/c/d가 처리 될 때 COPY 메소드 처리가 완료되면 http://example.com/b/c/d의 대상을 사용해야합니다.대상에서 일관된 URL 네임 스페이스를 작성해야합니다 (참조&lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;네임 스페이스 일관성의 정의를 위해). 그러나 내부 컬렉션을 복사하는 동안 오류가 발생하면 서버는이 컬렉션의 구성원이 식별 한 모든 리소스를 복사해서는 안됩니다 (즉, 서버는이 하위 트리를 건너 뛰어야합니다). 오류를 감지 한 후 COPY 작업은 가능한 한 많은 원본 복사 작업을 완료해야합니다 (즉, 서버는 오류를 일으키는 컬렉션의 하위 항목이 아닌 다른 하위 트리 및 해당 구성원을 계속 복사해야 함). 예를 들어, / a / b / 및 / a / c / 콜렉션을 포함하는 / a / 콜렉션에서 무한 깊이 복사 조작이 수행되고 / a / b /를 복사하는 중에 오류가 발생하면 시도는 계속되어야합니다. / a / c /를 복사하도록 만드십시오. 비슷하게,무한 깊이 복사의 일부로 비 수집 자원을 복사하는 중 오류가 발생하면 서버는 가능한 한 많은 원본 복사 작업을 완료해야합니다. COPY 메소드 실행 오류가 Request-URI에서 식별 된 자원 이외의 자원에서 발생하는 경우 응답은 반드시 207 (Multi-Status)이어야하며, 실패를 야기한 자원의 URL은 반드시 오류. 424 (실패 종속성) 상태 코드는 COPY 메소드의 207 (다중 상태) 응답으로 리턴되지 않아야합니다. 클라이언트는 부모에 대한 오류를 수신 할 때 자원의 자손을 복사 할 수 없다는 것을 클라이언트가 알기 때문에 이러한 응답을 안전하게 생략 할 수 있습니다. 또한201 (작성 됨) / 204 (콘텐츠 없음) 상태 코드는 COPY 메소드의 207 (다중 상태) 응답에서 값으로 반환되지 않아야합니다. 또한 기본 성공 코드이므로 안전하게 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS 메커니즘은 브라우저와 웹 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원합니다. 최신 브라우저는 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 와 같은 API 컨테이너에서 CORS를 사용 하여 원본 간 HTTP 요청의 위험을 완화합니다.</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORS 프로토콜은 원래 해당 동작이 필요했지만 &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;더 이상 필요하지 않도록 변경되었습니다&lt;/a&gt; . 그러나 모든 브라우저가 변경 사항을 구현하지는 않았으므로 원래 필요한 동작이 여전히 나타납니다.</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문은이 헤더와 함께 사용해야합니다. 그렇지 않으면이 헤더는 값 비싼 운영 체제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-header 필드는 요청 / 응답 체인을 따라 모든 캐싱 메커니즘에 따라야하는 지시문을 지정하는 데 사용됩니다. 지시문은 캐시가 요청 또는 응답을 방해하지 않도록하는 동작을 지정합니다. 이러한 지시문은 일반적으로 기본 캐싱 알고리즘보다 우선합니다. 캐시 지시문은 요청에 지시문이 있다는 것이 응답에 동일한 지시문이 제공되는 것을 의미하지 않는다는 점에서 단방향입니다. HTTP / 1.0 캐시는 Cache-Control을 구현하지 않을 수 있으며 Pragma : no-cache 만 구현할 수 있습니다.&lt;a href=&quot;#section-14.32&quot;&gt; 섹션 14.32&lt;/a&gt;). 지시문은 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 캐시 지시문은 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션에 의해 전달되어야합니다. 특정 캐시에 대해 캐시 지시문을 지정할 수 없습니다. Cache-Control = &quot;캐시-제어&quot; &quot;:&quot;1 # cache-directive 캐시-디렉티브 = 캐시-요청-디렉티브 | 캐시-응답-지시문 cache-request-directive = &quot;no-cache&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-store&quot;; &lt;a href=&quot;#section-14.9.2&quot;&gt;섹션 14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;델타-초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; , 14.9.4 | &quot;최대 이야기&quot;[ &quot;=&quot;델타 초]; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot;델타 초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;변형 없음&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;섹션 14.9.5&lt;/a&gt; | &quot;만 캐시 된 경우&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | 캐시 확장; &lt;a href=&quot;#section-14.9.6&quot;&gt;섹션 14.9.6&lt;/a&gt; 캐시-응답 지시문 = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;private&quot;[ &quot;=&quot;&amp;lt; &quot;&amp;gt; 1 # field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-cache&quot;[ &quot;=&quot;&amp;lt; &quot;&amp;gt; 1 # field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-store&quot;;&lt;a href=&quot;#section-14.9.2&quot;&gt;섹션 14.9.2&lt;/a&gt; | &quot;변형 없음&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;섹션 14.9.5&lt;/a&gt; | &quot;반드시 재확인&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | &quot;프록시 재확인&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;델타-초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot;델타 초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | 캐시 확장; &lt;a href=&quot;#section-14.9.6&quot;&gt;섹션 14.9.6&lt;/a&gt; cache-extension = token [ &quot;=&quot;(token | quoted-string)] 지시문이 1 # field-name 매개 변수없이 나타나면 지시문이 전체 요청 또는 응답에 적용됩니다. 이러한 지시문이 1 # field-name 매개 변수와 함께 나타나면 이름 지정된 필드에만 적용되고 나머지 요청이나 응답에는 적용되지 않습니다. 이 메커니즘은 확장 성을 지원합니다. 이후 버전의 HTTP 프로토콜 구현에서는 이러한 지시문을 HTTP / 1.1에 정의되지 않은 헤더 필드에 적용 할 수 있습니다. 캐시 제어 지시문은 다음과 같은 일반적인 범주로 나눌 수 있습니다.-캐시 가능한 대상에 대한 제한; 이것은 오리진 서버에 의해서만 부과 될 수 있습니다. -캐시에 의해 저장 될 수있는 것에 대한 제한; 이들은 오리진 서버 또는 사용자 에이전트에 의해 부과 될 수 있습니다.-기본 만기 메커니즘의 수정; 이들은 오리진 서버 또는 사용자 에이전트에 의해 부과 될 수 있습니다. -캐시 재확인 및 재로드를 제어합니다. 이들은 사용자 에이전트에 의해서만 부과 될 수 있습니다. -엔터티 변환 제어. -캐싱 시스템으로의 확장.</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control 헤더 필드는 각각 옵션으로 할당 된 값을 가진 하나 이상의 캐시 확장 토큰을 사용하여 확장 할 수 있습니다. 캐시 동작을 변경하지 않아도되는 정보 확장은 다른 지시문의 의미를 변경하지 않고 추가 될 수 있습니다. 동작 확장은 기존 캐시 지시문 기본에 대한 수정 자 역할을하여 작동하도록 설계되었습니다. 새 지시문과 표준 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본 지시문에 지정된 동작으로 기본 설정되고 새 지시문을 이해하는 응용 프로그램은 표준과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이런 식으로,캐시 제어 지시문의 확장은 기본 프로토콜을 변경하지 않고도 수행 할 수 있습니다. 이 확장 메커니즘은 기본 HTTP 버전에 대해 정의 된 모든 캐시 제어 지시문을 준수하고 특정 확장명을 준수하며 이해하지 못하는 모든 지시문을 무시하는 HTTP 캐시에 의존합니다. 예를 들어, private 지시문의 수정 자 역할을하는 커뮤니티라는 새로운 가상 지시문을 고려하십시오. 우리는이 새로운 지시문을 정의하여, 비공유 캐시 외에도 해당 값 내에 이름이 지정된 커뮤니티 구성원 만 공유하는 캐시가 응답을 캐시 할 수 있음을 의미합니다. UCI 커뮤니티가 공유 캐시에서 개인 응답을 사용하도록 허용하려는 원 서버는 Cache-Control : private,community = &quot;UCI&quot;이 헤더 필드를 보는 캐시는 캐시가 커뮤니티 캐시 확장을 이해하지 않더라도 개인 명령을보고 이해하므로 기본적으로 안전한 동작을 수행하기 때문에 올바르게 작동합니다. 인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control 헤더 필드는 각각 선택적 값을 가진 하나 이상의 캐시 확장 토큰을 사용하여 확장 할 수 있습니다. 캐시는 인식 할 수없는 캐시 지시문을 무시해야합니다. 다른 지시문의 의미를 변경하지 않고 정보 확장 (캐시 동작을 변경하지 않아도되는 확장)을 추가 할 수 있습니다. 동작 확장은 기존 캐시 지시문 기본에 대한 수정 자 역할을하여 작동하도록 설계되었습니다. 새 지시문과 이전 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본적으로 이전 지시문에 지정된 동작으로 기본 설정되며 새 지시문을 이해하는 응용 프로그램은 이전 지시문과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이런 식으로,배포 된 캐시를 손상시키지 않고 기존 캐시 제어 지시문에 대한 확장을 만들 수 있습니다. 예를 들어 개인 지시문에 대한 수정 자 역할을하는 &quot;커뮤니티&quot;라는 가상의 새로운 응답 지시문을 고려하십시오. 개인 캐시 외에, 이름 지정된 커뮤니티의 구성원 만 공유하는 캐시는 응답을 캐시 할 수 있습니다. UCI 커뮤니티가 공유 캐시에서 다른 개인 응답을 사용하도록 허용하려는 원 서버는 Cache-Control을 포함하여이를 수행 할 수 있습니다. private, community = &quot;UCI&quot;이러한 커뮤니티 캐시 확장을 인식하는 캐시는 확장 될 수 있습니다. 해당 확장에 따른 동작. 커뮤니티 캐시 확장을 인식하지 못하는 캐시는이를 무시하고 개인 지시문을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome (또는 Chromium / 블링크 기반 엔진) 사용자 에이전트 문자열은 Firefox 형식과 유사합니다. 호환성을 위해 &quot;Kecko와 같은 KHTML&quot;및 &quot;Safari&quot;와 같은 문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">연결 일반 헤더 필드를 사용하면 발신자가 특정 연결에 필요한 옵션을 지정할 수 있으며 추가 연결을 통해 프록시와 통신해서는 안됩니다. 연결 헤더에는 다음과 같은 문법이 있습니다. 연결 = &quot;연결&quot; &quot;:&quot;1 # (연결 토큰) 연결 토큰 = 토큰 HTTP / 1.1 프록시는 메시지가 전달되고 각 연결 토큰에 대해 연결 헤더 필드를 구문 분석해야합니다. 이 필드에서 연결 토큰과 동일한 이름을 가진 메시지에서 헤더 필드를 제거하십시오. 연결 옵션은 해당 추가 헤더 필드가 아닌 연결 헤더 필드에 연결 토큰이 있음을 나타냅니다.해당 연결 옵션과 연관된 매개 변수가 없으면 추가 헤더 필드가 전송되지 않을 수 있습니다. 연결 헤더에 나열된 메시지 헤더에는 Cache-Control과 같은 엔드 투 엔드 헤더가 포함되어서는 안됩니다. HTTP / 1.1은 발신자가 응답이 완료된 후 연결이 종료 될 것임을 알리는 &quot;닫기&quot;연결 옵션을 정의합니다. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (발신자가 응답 완료 후 연결이 끊 겼음을 알리는 연결 옵션. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (발신자가 응답 완료 후 연결이 끊 겼음을 알리는 연결 옵션. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (&lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; )은 현재 요청 / 응답이 완료된 후입니다. 지속적인 연결을 지원하지 않는 HTTP / 1.1 응용 프로그램은 모든 메시지에 &quot;close&quot;연결 옵션을 포함해야합니다. 이 필드의 각 연결 토큰에 대해 연결 헤더를 포함하는 HTTP / 1.0 (또는 하위 버전) 메시지를 수신하는 시스템은 연결과 동일한 이름을 가진 메시지에서 헤더 필드를 제거하고 무시합니다. 토큰. 이것은 HTTP / 1.1 이전 프록시에 의한 헤더 필드의 잘못된 전달을 방지합니다. &lt;a href=&quot;#section-19.6.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">연결 헤더 필드 (&lt;a href=&quot;#section-6.1&quot;&gt; 6.1 절&lt;/a&gt;)는 발신자가 현재 요청 / 응답 쌍 후에 연결을 닫으려고 할 때 보내야하는 &quot;닫기&quot;연결 옵션을 제공합니다. &quot;닫기&quot;연결 옵션을 보내는 클라이언트는 해당 연결에 대한 추가 요청을 보내지 말아야하며 ( &quot;닫기&quot;가 포함 된 후)이 요청에 해당하는 최종 응답 메시지를 읽은 후 연결을 닫아야합니다. &quot;닫기&quot;연결 옵션을 수신 한 서버는 &quot;닫기&quot;가 포함 된 요청에 최종 응답을 보낸 후 연결을 닫아야합니다 (아래 참조). 서버는 해당 연결에 대한 최종 응답으로 &quot;닫기&quot;연결 옵션을 보내야합니다 (SHOULD). 서버는 해당 연결에서 수신 된 추가 요청을 처리해서는 안됩니다 (MUST NOT). &quot;를 보내는 서버&quot;닫기&quot;연결 옵션은 &quot;닫기&quot;를 포함하는 응답을 보낸 후 연결을 닫아야합니다 (아래 참조). 서버는 해당 연결에서 수신 된 추가 요청을 처리해서는 안됩니다. &quot;닫기&quot;가 포함 된 응답 메시지를 읽은 후 해당 연결에서 요청을 보내고 연결을 닫습니다. 연결에서 추가 파이프 라인 요청이 전송 된 경우 클라이언트는 서버에서 요청을 처리한다고 가정해서는 안됩니다. TCP 연결을 즉시 닫으면 클라이언트가 마지막 HTTP 응답을 읽을 수 없게 될 위험이 있습니다 서버가 완전히 닫힌 연결에서 클라이언트로부터 추가 데이터를받는 경우,서버의 응답을 받기 전에 클라이언트가 보낸 다른 요청과 같이 서버의 TCP 스택은 클라이언트에 재설정 패킷을 보냅니다. 불행히도, 재설정 패킷은 클라이언트의 HTTP 파서가 읽고 해석하기 전에 클라이언트의 승인되지 않은 입력 버퍼를 지울 수 있습니다. TCP 재설정 문제를 방지하기 위해 서버는 일반적으로 단계적으로 연결을 닫습니다. 먼저, 서버는 읽기 / 쓰기 연결의 쓰기 쪽만 닫아 반-폐쇄를 수행합니다. 그런 다음 서버는 클라이언트가 해당 닫기를 수신 할 때까지 또는 자체 TCP 스택이 서버의 마지막 응답을 포함하는 패킷에 대한 클라이언트의 승인을 받았음을 합리적으로 확신 할 때까지 연결에서 계속 읽습니다. 드디어,서버가 연결을 완전히 닫습니다. 재설정 문제가 TCP 전용인지 또는 다른 전송 연결 프로토콜에서도 발견 될 수 있는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">사용자가 콘텐츠를 파일에 저장하도록 요청하는 경우 원본 서버가 기본 파일 이름을 제안하는 수단으로 콘텐츠 처리 응답 헤더 필드가 제안되었습니다. 이 사용법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ Content-Disposition]의 정의에서 파생됩니다.&lt;a href=&quot;#ref-35&quot;&gt; 35&lt;/a&gt;]. content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;처리 유형 * ( &quot;;&quot;disposition-parm) 처리 유형 = &quot;첨부 파일&quot;| disp- 확장 토큰 처리 -parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot;인용 문자열 disp-extension-token = 토큰 disp-extension-parm = token &quot;=&quot;(token | quoted-string) 예는 ​​Content-Disposition : attachment입니다. ; filename = &quot;fname.ext&quot;수신 사용자 에이전트는 filename-parm 매개 변수에 존재하는 디렉토리 경로 정보를 존중해서는 안됩니다. 이는 현재 HTTP 구현에 적용되는 것으로 생각되는 유일한 매개 변수입니다. 파일 이름은 터미널 구성 요소로만 취급해야합니다.이 헤더가 application / octet-stream content-type의 응답에 사용되는 경우 암시 된 제안은 사용자 에이전트가 응답을 표시하지 말고 '다른 이름으로 응답 저장 ...'대화 상자를 직접 입력해야한다는 것입니다. 보다&lt;a href=&quot;#section-15.5&quot;&gt;&lt;/a&gt;콘텐츠 처리 보안 문제에 대해서는 15.5 절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">콘텐츠 인코딩 엔터티 헤더 필드는 미디어 유형의 수정 자로 사용됩니다. 존재하는 경우, 그 값은 어떤 추가 컨텐츠 코딩이 엔티티 본문에 적용 되었는지를 나타내며, 따라서 Content-Type 헤더 필드에 의해 참조되는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘이 적용되어야 하는지를 나타낸다. 컨텐츠 인코딩은 주로 기본 미디어 유형의 ID를 잃지 않고 문서를 압축 할 수 있도록하는 데 사용됩니다. Content-Encoding = &quot;콘텐츠 인코딩&quot; &quot;:&quot;1 # content-coding 콘텐츠 코딩은 다음과 같이 정의됩니다.&lt;a href=&quot;#section-3.5&quot;&gt; 3.5 절&lt;/a&gt;. 사용 예는 Content-Encoding입니다. gzip content-coding은 Request-URI로 식별 된 엔티티의 특성입니다. 일반적으로 엔티티 본문은이 인코딩과 함께 저장되며 렌더링 또는 유사한 사용법 전에 만 디코딩됩니다. 그러나, &quot;비 변형&quot;캐시 제어 지시어가 메시지에 존재하지 않는 한, 비 투명 프록시는 새로운 코딩이 수신자에게 수용 가능한 것으로 알려진 경우 콘텐츠 코딩을 수정할 수있다 (MAY). 엔티티의 컨텐츠 코딩이 &quot;identity&quot;가 아닌 경우 응답에는 반드시 컨텐츠 인코딩 엔티티 헤더가 포함되어야합니다 ( &lt;a href=&quot;#section-14.11&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11).&lt;/a&gt;)는 사용 된 비 ID 콘텐츠 코딩을 나열합니다. 요청 메시지에있는 엔터티의 콘텐츠 코딩이 원본 서버에 적합하지 않은 경우 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답해야합니다. 엔터티에 여러 인코딩이 적용된 경우 콘텐츠 코딩은 적용된 순서대로 나열되어야합니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 엔터티 헤더 필드에서 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Language entity-header 필드는 동봉 된 엔터티에 대한 대상 독자의 자연어를 설명합니다. 이것은 엔터티 본문 내에서 사용되는 모든 언어와 같지 않을 수도 있습니다. Content-Language = &quot;Content-Language&quot; &quot;:&quot;1 # language-tag 언어 태그는&lt;a href=&quot;#section-3.10&quot;&gt; 섹션 3.10에 있습니다.&lt;/a&gt;. Content-Language의 주요 목적은 사용자가 선호하는 언어에 따라 엔티티를 식별하고 구별 할 수 있도록하는 것입니다. 따라서 본문 내용이 덴마크어를 사용하는 청중만을 대상으로하는 경우 해당 필드는 내용 언어입니다. da 내용 언어가 지정되지 않은 경우 기본적으로 해당 내용은 모든 언어 청중을 대상으로합니다. 이는 발신자가 자연 언어에 고유 한 것으로 간주하지 않거나 발신자가 어떤 언어를 사용하는지 알지 못했음을 의미 할 수 있습니다. 여러 사용자를 대상으로하는 콘텐츠에 대해 여러 언어가 나열 될 수 있습니다. 예를 들어, 원래 마오리어와 영어 버전에서 동시에 제시된 &quot;와이 탕이의 보물&quot;을 번역하려면 Content-Language : mi,jw.org ko 그러나 여러 언어가 하나의 엔티티 내에 존재한다고해서 여러 언어 사용자를 대상으로한다는 의미는 아닙니다. 예를 들어 &quot;Latin의 첫 수업&quot;과 같은 초보자의 언어 입문서를들 수 있습니다.이 언어는 영어를 사용하는 청중이 사용하기위한 것입니다. 이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Length entity-header (콘텐츠 길이 엔티티 헤더) 필드는 엔티티 본문의 크기를 10 진수 (OCTET 수)로 수신자에게 보내거나 HEAD 방법의 경우 전송 된 엔티티 본문의 크기를 나타냅니다. 요청은 GET이었습니다. Content-Length = &quot;Content-Length&quot; &quot;:&quot;1 * DIGIT 예는 Content-Length입니다. 3495 Applications &lt;a href=&quot;#section-4.4&quot;&gt;4.4 &lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;절의&lt;/a&gt; 규칙에 의해 금지되지 않는 한이 필드를 사용하여 메시지 본문의 전송 길이를 표시해야합니다. . 0보다 크거나 같은 Content-Length는 유효한 값입니다. &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt;Content-Length가 제공되지 않은 경우 메시지 본문의 길이를 결정하는 방법을 설명합니다. 이 필드의 의미는 &quot;메시지 / 외부 본문&quot;컨텐츠 유형에서 사용되는 선택적 필드 인 MIME의 해당 정의와 크게 다릅니다. HTTP &lt;a href=&quot;#section-4.4&quot;&gt;에서는 4.4 절의&lt;/a&gt; 규칙에 의해 금지되지 않는 한 전송 전에 메시지 길이를 결정할 수있을 때마다 전송되어야한다 .</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Content-Location entity-header 필드는 요청 된 리소스의 URI와 다른 위치에서 해당 엔터티에 액세스 할 수있을 때 메시지에 포함 된 엔터티의 리소스 위치를 제공하는 데 사용될 수 있습니다. 서버는 응답 엔터티에 해당하는 변형에 대한 콘텐츠 위치를 제공해야한다. 특히 자원에 연관된 엔티티가 여러 개 있고 해당 엔티티가 실제로 개별적으로 액세스 할 수있는 별도의 위치를 ​​가지고있는 경우, 서버는 리턴되는 특정 변형에 대한 컨텐츠 위치를 제공해야합니다 (SHOULD). Content-Location = &quot;Content-Location&quot; &quot;:&quot;(absoluteURI | relativeURI) Content-Location의 값은 또한 엔티티의 기본 URI를 정의합니다.Content-Location 값은 원래 요청 된 URI를 대체하지 않습니다. 요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔티티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.&lt;a href=&quot;#section-13.6&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; . Content-Location이 상대 URI 인 경우 상대 URI는 Request-URI를 기준으로 해석됩니다. PUT 또는 POST 요청에서 Content-Location 헤더의 의미는 정의되어 있지 않습니다. 이 경우 서버는이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]에 정의 된 Content-MD5 entity-header 필드 는 엔티티 본문의 엔드 투 엔드 메시지 무결성 검사 (MIC)를 제공 할 목적으로 엔티티 본문의 MD5 다이제스트입니다. (참고 : MIC는 전송중인 엔티티 본문의 우발적 인 수정을 감지하는 데 유용하지만 악의적 인 공격에 대한 증거는 아닙니다.) Content-MD5 = &quot;Content-MD5&quot; &quot;:&quot;md5-digest md5-digest = &amp;lt;base64 of &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864에&lt;/a&gt; 따른 128 비트 MD5 다이제스트&amp;gt; 오리진 서버 또는 클라이언트가 Content-MD5 헤더 필드를 생성하여 엔터티 본문의 무결성 검사 기능을 수행 할 수 있습니다. 오리진 서버 또는 클라이언트 만이 Content-MD5 헤더 필드를 생성 할 수있다; 프록시와 게이트웨이는 엔드 투 엔드 무결성 검사로서의 가치를 상실 할 수 있으므로이를 생성해서는 안됩니다. 게이트웨이와 프록시를 포함한 엔티티 본문의 수신자는이 헤더 필드의 다이제스트 값이 수신 된 엔티티 본문의 다이제스트 값과 일치하는지 확인할 수 있습니다. MD5 다이제스트는 적용된 모든 본문 인코딩을 포함하지만 메시지 본문에 적용된 전송 인코딩은 포함하지 않은 엔티티 본문의 내용을 기반으로 계산됩니다. 메시지가 전송 인코딩으로 수신되면 수신 된 엔터티에 대해 Content-MD5 값을 확인하기 전에 해당 인코딩을 제거해야합니다.이것은 다이제스트가 엔티티-바디의 옥텟에 대해 정확하게 계산되고 전송 인코딩이 적용되지 않은 경우에 전송되는 순서를 갖습니다. HTTP 확장&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;MIME 복합 미디어 유형 (예 : multipart / * 및 message / rfc822)에 대해 다이제스트를 계산할 수 있지만 이전 단락에 정의 된대로 다이제스트가 계산되는 방식은 변경되지 않습니다. 이것의 몇 가지 결과가 있습니다. 복합 유형의 엔티티 본문에는 각각 고유 한 MIME 및 HTTP 헤더 (Content-MD5, Content-Transfer-Encoding 및 Content-Encoding 헤더 포함)가있는 많은 본문 부분이 포함될 수 있습니다. 본문 부분에 Content-Transfer-Encoding 또는 Content-Encoding 헤더가있는 경우 본문 부분의 내용에 인코딩이 적용된 것으로 가정하고 본문 부분은 그대로 Content-MD5 다이제스트에 포함됩니다 -신청 후. 본문 부분에는 전송 인코딩 헤더 필드가 허용되지 않습니다.다이제스트를 계산하거나 확인하기 전에 모든 줄 바꿈을 CRLF로 변환해서는 안됩니다. 다이제스트를 계산할 때 실제로 전송되는 텍스트에 사용 된 줄 바꿈 규칙은 변경되지 않아야합니다. 참고 : Content-MD5의 정의는 HTTP의 경우와 동일하지만&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;MIME 엔터티 본문에 대한 RFC 1864 의 경우 Content-MD5에서 HTTP 엔터티 본문으로의 응용 프로그램이 해당 응용 프로그램에서 MIME 엔터티 본문으로 다른 방식에는 여러 가지가 있습니다. 하나는 HTTP가 MIME과 달리 Content-Transfer-Encoding을 사용하지 않고 Transfer-Encoding 및 Content-Encoding을 사용한다는 것입니다. 다른 하나는 HTTP가 MIME보다 이진 콘텐츠 형식을 더 자주 사용한다는 것이므로 이러한 경우 다이제스트를 계산하는 데 사용되는 바이트 순서는 형식에 대해 정의 된 전송 바이트 순서입니다. 마지막으로 HTTP는 CRLF를 사용하는 표준 형식뿐만 아니라 여러 줄 바꿈 규칙으로 텍스트 유형을 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Range 엔티티 헤더는 전체 엔티티 본문에서 부분 본문을 적용 할 위치를 지정하기 위해 부분 엔티티 본문과 함께 전송됩니다. 범위 단위는 &lt;a href=&quot;#section-3.12&quot;&gt;섹션 3.12에&lt;/a&gt; 정의되어 있습니다.. Content-Range = &quot;Content-Range&quot; &quot;:&quot;content-range-spec 컨텐츠-범위 -spec = 바이트-내용-범위-사양 byte-content-range-spec = 바이트-단위 SP 바이트-범위 -resp-spec &quot; / &quot;(instance-length |&quot;* &quot;) byte-range-resp-spec = (first-byte-pos&quot;- &quot;last-byte-pos) | &quot;*&quot;instance-length = 1 * DIGIT이 길이를 알 수 없거나 결정하기 어려운 경우가 아니라면 헤더는 전체 엔터티 본문의 전체 길이를 나타내야한다. 별표 &quot;*&quot;문자는 응답이 생성 될 때 인스턴스 길이를 알 수 없음을 의미합니다. 바이트 범위 지정자와 달리 ( &lt;a href=&quot;#section-14.35.1&quot;&gt;섹션 14.35.1&lt;/a&gt; 참조)), byte-range-resp-spec은 하나의 범위 만 지정해야하며 범위의 첫 번째 바이트와 마지막 바이트 모두에 대한 절대 바이트 위치를 포함해야합니다. last-byte-pos 값이 첫 번째 byte-pos 값보다 작거나 인스턴스 길이 값이 last-보다 작거나 같은 byte-range-resp-spec을 갖는 byte-content-range-spec 바이트 위치 값이 유효하지 않습니다. 유효하지 않은 byte-content-range-spec을받는 사람은이를 무시하고 그와 함께 전송 된 모든 내용을 무시해야합니다. 상태 코드 416 (요청한 범위는 만족할 수 없음) 인 응답을 전송하는 서버는 바이트-범위 -resp-spec이 &quot;*&quot;인 Content-Range 필드를 포함해야합니다. instance-length는 선택된 자원의 현재 길이를 지정합니다.상태 코드 206 (부분 컨텐츠)의 응답은 바이트 범위 범위 스펙이 &quot;*&quot;인 컨텐츠 범위 필드를 포함해서는 안됩니다 (MUST NOT). 엔터티에 총 1234 바이트가 포함되어 있다고 가정 한 바이트-콘텐츠-범위-사양 값의 예 :. 처음 500 바이트 : bytes 0-499 / 1234 두 번째 500 바이트 : bytes 500-999 / 1234 처음 500 바이트를 제외한 모두 : 바이트 500-1233 / 1234 마지막 500 바이트 : bytes 734-1233 / 1234 HTTP 메시지에 단일 범위의 컨텐츠가 포함 된 경우 (예 : 단일 범위에 대한 요청에 대한 응답 또는 구멍없이 겹치는 범위의 세트에 대한 요청) )에서이 콘텐츠는 Content-Range 헤더와 실제로 전송 된 바이트 수를 나타내는 Content-Length 헤더와 함께 전송됩니다. 예를 들어, HTTP / 1입니다.1206 부분 내용 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 내용 범위 : 바이트 21010-47021 / 47022 내용 길이 : 26012 내용 유형 : image / gif HTTP 메시지에 여러 범위의 내용 (예 : 겹치지 않는 여러 범위에 대한 요청에 대한 응답)이 포함되어 있으면 여러 부분 메시지로 전송됩니다. 이 목적으로 사용되는 멀티 파트 미디어 유형은 부록 19.2에 정의 된 &quot;멀티 파트 / 바이트 범위&quot;입니다. 호환성 문제에 대해서는 부록 19.6.3을 참조하십시오. 단일 범위에 대한 요청에 대한 응답은 multipart / byteranges 미디어 유형을 사용하여 전송해서는 안됩니다 (MUST NOT). 결과가 단일 범위 인 여러 범위에 대한 요청에 대한 응답은 한 부분으로 여러 부분 / 바이트 범위의 미디어 유형으로 전송 될 수 있습니다.멀티 파트 / 바이트 범위 메시지를 디코딩 할 수없는 클라이언트는 단일 요청에서 여러 바이트 범위를 요구해서는 안됩니다 (MUST NOT). 클라이언트가 한 요청에서 여러 바이트 범위를 요청하면 서버는 요청에 나타난 순서대로 반환해야합니다. 서버가 구문 적으로 유효하지 않기 때문에 바이트 범위 사양을 무시하면 서버는 유효하지 않은 Range 헤더 필드가 존재하지 않는 것처럼 요청을 처리해야합니다 (SHOULD). 일반적으로 이는 전체 엔터티를 포함하는 200 응답을 반환합니다. 서버가 만족할 수없는 범위 요청 헤더 필드 (즉, 모든 바이트 범위 스펙 값의 첫 번째 바이트 위치 값이 큰)와 함께 요청 (If-Range 요청 헤더 필드를 포함하는 것 이외)을 수신하는 경우 선택한 리소스의 현재 길이보다)416의 응답 코드를 반환해야합니다 (요청 범위가 만족스럽지 않습니다) (&lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt; ). 참고 : 모든 서버가이 요청 헤더를 구현하는 것은 아니기 때문에 클라이언트가 만족할 수없는 범위 요청 헤더에 대해 200 (OK) 응답 대신 416 (요청 범위가 만족스럽지 않음) 응답을 보내도록 서버에 의존 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Type entity-header 필드는 수신자에게 전송 된 엔티티 본문의 미디어 유형을 표시하거나 HEAD 메소드의 경우 요청이 GET 인 경우 전송 된 미디어 유형을 표시합니다. Content-Type = &quot;Content-Type&quot; &quot;:&quot;미디어 유형 미디어 유형은 &lt;a href=&quot;#section-3.7&quot;&gt;3.7 절&lt;/a&gt; 에서 정의됩니다 . 이 필드의 예는 Content-Type : text / html; charset = ISO-8859-4 엔티티의 미디어 타입을 식별하는 방법에 대한 추가 논의는 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1 장&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Cross-Origin Resource Sharing 표준은 서버가 웹 브라우저를 사용하여 해당 정보를 읽을 수있는 원본 세트를 설명 할 수있는 새로운 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; 를 추가하여 작동 합니다. 또한 서버 데이터에 부작용을 일으킬 수있는 HTTP 요청 방법 (특히 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 이외의 HTTP 방법 또는 특정 &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME 유형의 &lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 사용 )의 경우, 사양에서는 브라우저가 요청을 &quot;프리 플라이트&quot;하여 지원되는 방법을 요구합니다. HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 메소드를 사용하여 서버에서, 서버에서 &quot;승인&quot;하면 실제 HTTP 요청 메소드로 실제 요청을 보냅니다. 서버는 또한 &quot;신임 정보&quot;여부를 클라이언트에게 알릴 수 있습니다.( &lt;a href=&quot;cookies&quot;&gt;쿠키 포함)&lt;/a&gt;HTTP 인증 데이터)를 요청과 함께 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">컬렉션의 DELETE 메소드는 마치 &quot;Depth : infinity&quot;헤더가 사용 된 것처럼 작동해야합니다. 클라이언트는 무한대의 값을 가진 컬렉션에서 DELETE와 함께 깊이 헤더를 제출해서는 안됩니다. DELETE는 Request-URI에 지정된 콜렉션과 해당 내부 구성원 URL로 식별 된 모든 자원을 삭제하도록 지시합니다. 구성원 URL로 식별 된 자원을 삭제할 수없는 경우 URL 네임 스페이스 일관성을 유지하기 위해 모든 구성원의 조상을 삭제해서는 안됩니다. DELETE에 포함 된 모든 헤더는 삭제 될 모든 리소스를 처리하는 데 적용되어야합니다. DELETE 메소드가 처리를 완료하면 URL 네임 스페이스가 일관되어야합니다. 멤버 자원 (Request-URI에서 식별 된 자원 이외의 자원)을 삭제하는 중에 오류가 발생하면,응답은 207 (Multi-Status) 일 수 있습니다. 다중 상태는 여기에서 오류 코드를 포함하여 삭제할 수없는 내부 리소스를 나타 내기 위해 사용되며, 이로 인해 클라이언트가 어떤 리소스가 오류를 일으켰는지 이해할 수 있습니다. 예를 들어, 내부 자원이 잠겨 있으면 다중 상태 본문에 상태 423 (잠김)의 응답이 포함될 수 있습니다. 요청이 완전히 실패한 경우 서버는 207이 아닌 4xx 상태 응답을 반환 할 수 있습니다. 424 (실패 종속성) 상태 코드는 DELETE에 대한 207 (다중 상태) 응답에 있지 않아야합니다. 클라이언트가 조상의 자손에 대한 오류를 수신 할 때 리소스의 조상을 삭제할 수 없다는 것을 클라이언트가 알기 때문에 안전하게 제거 할 수 있습니다. 또한 207 (다중 상태)에서는 204 (콘텐츠 없음) 오류가 반환되지 않아야합니다.이 금지의 이유는 204 (No Content)가 기본 성공 코드이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETE 메소드는 오리진 서버가 Request-URI로 식별 된 자원을 삭제하도록 요청합니다. 이 방법은 오리진 서버에서 사람의 개입 (또는 다른 수단)에 의해 무시 될 수 있습니다. 오리진 서버에서 리턴 된 상태 코드가 조치가 성공적으로 완료되었음을 표시하더라도 클라이언트는 조작이 수행되었음을 보증 할 수 없습니다. 그러나 서버는 응답이 제공 될 때 리소스를 삭제하거나 액세스 할 수없는 위치로 이동시키지 않는 한 성공을 나타내서는 안됩니다. 응답에 상태를 설명하는 엔터티가 포함 된 경우 성공적인 응답은 200 (OK)이고, 조치가 아직 시행되지 않은 경우 202 (Accepted), 조치가 시행되었지만 응답이 포함되지 않은 경우 204 (No Content) 여야합니다. 실체.요청이 캐시를 통과하고 Request-URI가 현재 캐시 된 하나 이상의 엔티티를 식별하는 경우 해당 항목은 오래된 것으로 취급해야합니다. 이 방법에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETE 메소드는 오리진 서버가 대상 자원과 현재 기능 간의 연관을 제거하도록 요청합니다. 실제로이 방법은 UNIX의 rm 명령과 유사합니다. 이전에 연관된 정보가 삭제 될 것으로 예상하지 않고 원래 서버의 URI 맵핑에서 삭제 조작을 표시합니다. 대상 자원에 하나 이상의 현재 표시가있는 경우, 자원의 특성 및 원래 서버에 의한 구현에 따라 원래 서버에 의해 소멸되거나 소멸되지 않을 수 있으며 연관된 스토리지가 재생되거나 재생되지 않을 수 있습니다 ( 이 사양의 범위를 벗어납니다). 마찬가지로, DELETE의 결과로 리소스의 다른 구현 측면을 비활성화하거나 보관해야 할 수도 있습니다.데이터베이스 또는 게이트웨이 연결과 같은 일반적으로 오리진 서버는 삭제를 수행하기 위해 규정 된 메커니즘이있는 자원에 대해서만 DELETE를 허용한다고 가정합니다. DELETE 방법을 허용하는 리소스는 상대적으로 적습니다. 주된 용도는 원격 제작 환경에서 사용되며 사용자는 그 영향에 대한 방향이 있습니다. 예를 들어, PUT 요청을 사용하여 이전에 작성되었거나 POST 요청에 대한 201 (작성) 응답 후 위치 헤더 필드를 통해 식별 된 자원은 해당 DELETE 요청이 해당 조치를 실행 취소하도록 허용 할 수 있습니다. 마찬가지로, 원격 조작에 HTTP를 사용하는 개정 제어 클라이언트와 같은 작성 기능을 구현하는 사용자 정의 사용자 에이전트 구현에서는 서버의 가정에 따라 DELETE를 사용할 수 있습니다.URI 공간은 버전 저장소에 해당하도록 제작되었습니다. DELETE 방법이 성공적으로 적용되면, 원 서버는 조치가 성공할 수는 있지만 아직 제정되지 않은 경우 202 (수락 됨) 상태 코드를 전송하고, 조치가 제정되었고 더 이상 수행되지 않으면 204 (콘텐츠 없음) 상태 코드를 전송해야합니다. 정보가 제공되거나 조치가 제정되고 응답 메시지에 상태를 설명하는 표현이 포함 된 경우 200 (OK) 상태 코드가 제공됩니다. DELETE 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. DELETE 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. DELETE 메소드에 대한 응답은 캐시 할 수 없습니다. DELETE 요청이 유효 요청 URI에 대해 하나 이상의 저장된 응답이있는 캐시를 통과하면,저장된 응답은 무효화됩니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234] 4.4 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">날짜 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822의&lt;/a&gt; orig-date와 동일한 의미를 갖습니다 . 필드 값은 &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 에서 설명한 HTTP 날짜입니다 . 반드시 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 으로 보내야합니다. [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-날짜 형식. Date = &quot;Date&quot; &quot;:&quot;HTTP-date 예는 다음과 같습니다. Date : Tue, 1994 년 11 월 15 일 08:12:31 GMT 오리진 서버는 다음 경우를 제외하고 모든 응답에 Date 헤더 필드를 포함해야합니다. 1. 응답 상태 코드가 100 (계속) 또는 101 (전환 프로토콜)이면 응답에 서버 옵션에 날짜 헤더 필드가 포함될 수 있습니다. 2. 응답 상태 코드가 서버 오류 (예 : 500 (내부 서버 오류) 또는 503 (서비스를 사용할 수 없음))를 전달하는 경우 유효한 날짜를 생성하는 것이 불편하거나 불가능합니다. 3. 서버에 현재 시간의 합리적인 근사치를 제공 할 수있는 시계가없는 경우 응답에 날짜 헤더 필드를 포함해서는 안됩니다. 이 경우&lt;a href=&quot;#section-14.18.1&quot;&gt;섹션 14.18.1 의 규칙&lt;/a&gt;반드시 따라야합니다. 날짜 헤더 필드가없는 수신 된 메시지는 메시지가 해당 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이 인 경우 수신자가 하나씩 할당해야합니다. 시계가없는 HTTP 구현은 매번 사용할 때마다 응답을 다시 확인하지 않고 응답을 캐시해서는 안됩니다 (MUST NOT). HTTP 캐시, 특히 공유 캐시는 NTP와 같은 메커니즘을 사용해야합니다 [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], 시계를 안정적인 외부 표준과 동기화합니다. 클라이언트는 PUT 및 POST 요청의 경우와 같이 엔터티 본문을 포함하는 메시지로만 날짜 헤더 필드를 보내야하며, 선택 사항이기도합니다. 시계가없는 클라이언트는 요청에 날짜 헤더 필드를 보내서는 안됩니다 (MUST NOT). 날짜 헤더에 전송 된 HTTP 날짜는 메시지 생성 이후의 날짜와 시간을 나타내서는 안됩니다 (SHOULD NOT). 구현에 합리적으로 정확한 날짜와 시간을 생성 할 수단이없는 한, 메시지 생성 날짜와 시간의 가장 근접한 근사값을 나타내야한다. 이론적으로 날짜는 엔터티가 생성되기 직전의 순간을 나타냅니다. 실제로 날짜는 시맨틱 값에 영향을주지 않고 메시지를 생성하는 동안 언제든지 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">깊이 헤더는 LOCK 메소드와 함께 사용될 수 있습니다. 0 또는 무한대 이외의 값은 LOCK 메소드의 깊이 헤더와 함께 사용해서는 안됩니다 (MUST NOT). LOCK 메소드를 지원하는 모든 자원은 Depth 헤더를 지원해야합니다. 값이 0 인 깊이 헤더는 Request-URI에 의해 지정된 리소스를 잠그는 것을 의미합니다. Depth 헤더가 무한대로 설정되면 Request-URI에 지정된 모든 멤버와 함께 계층 구조에서 내려진 모든 리소스가 잠 깁니다. 성공적인 결과는 반드시 단일 잠금 토큰을 반환해야합니다. 마찬가지로이 토큰에서 UNLOCK이 성공적으로 실행되면 모든 관련 리소스가 잠금 해제됩니다. 따라서 부분 성공은 LOCK 또는 UNLOCK에 대한 옵션이 아닙니다. 전체 계층이 잠겨 있거나 리소스가 잠겨 있지 않습니다. 모든 자원에 잠금을 부여 할 수없는 경우서버는 해당 장애에 대한 적절한 상태 코드 (예 : 403 (Forbidden) 또는 423 (Locked))와 함께 잠금이 부여되지 않은 하나 이상의 리소스에 대해 'response'요소와 함께 Multi-Status 응답을 반환해야합니다. . 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.403 (금지) 또는 423 (잠금)). 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.403 (금지) 또는 423 (잠금)). 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">대상 요청 헤더는 두 개의 URI를 매개 변수로 사용하는 COPY 및 MOVE와 같은 메소드의 대상 자원을 식별하는 URI를 지정합니다. Destination = &quot;Destination&quot; &quot;:&quot;Simple-ref Destination 값이 절대 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]의 4.3 절&lt;/a&gt; ) 인 경우 다른 서버 (또는 다른 포트 또는 체계)의 이름을 지정할 수 있습니다. 소스 서버가 원격 서버로 복사를 시도 할 수 없으면 요청에 실패해야합니다. 자원을 원격 서버로 복사 및 이동하는 것은이 사양에서 완전히 정의되지 않았습니다 (예 : 특정 오류 조건). Destination 값이 너무 길거나 허용 할 수없는 경우 서버는 이상적으로 오류 본문에 유용한 정보와 함께 400 (잘못된 요청)을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETag 응답 헤더 필드는 요청 된 변형에 대한 엔티티 태그의 현재 값을 제공합니다. 엔티티 태그와 함께 사용되는 헤더는 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; 및 &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; 섹션에 설명되어 있습니다 . 엔티티 태그는 동일한 리소스의 다른 엔티티와 비교하는 데 사용될 수 있습니다 &lt;a href=&quot;#section-13.3.3&quot;&gt;(13.3.3 절&lt;/a&gt; 참조 ). ETag = &quot;ETag&quot; &quot;:&quot;엔티티 태그 예 : ETag : &quot;xyzzy&quot;ETag : W / &quot;xyzzy&quot;ETag : &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">엔티티 태그 인 ETag 응답 헤더 필드 값은 &quot;불투명 한&quot;캐시 유효성 검사기를 제공합니다. 이를 통해 수정 날짜를 저장하는 것이 불편한 상황, HTTP 날짜 값의 1 초 해상도가 충분하지 않은 경우 또는 오리진 서버가 수정 날짜 사용으로 인해 발생할 수있는 특정 역설을 피하려는 경우 더 안정적인 유효성 검증이 가능할 수 있습니다. . 엔터티 태그는 &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11에&lt;/a&gt; 설명되어 있습니다 . 엔티티 태그와 함께 사용되는 헤더는 섹션 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; , &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; 및 &lt;a href=&quot;#section-14.44&quot;&gt;14.44에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expect request-header 필드는 클라이언트에 특정 서버 비헤이비어가 필요함을 나타내는 데 사용됩니다. Expect = &quot;Expect&quot; &quot;:&quot;1 # expectation expectation = &quot;100-continue&quot;| expectation-extension expectation-extension = token [ &quot;=&quot;(token | quoted-string) * expect-params] expect-params = &quot;;&quot; token [ &quot;=&quot;(token | quoted-string)] 요청의 Expect 필드에있는 예상 값을 이해하지 못하거나 준수 할 수없는 서버는 적절한 오류 상태로 응답해야합니다. 서버는 기대치를 충족 할 수 없거나 요청에 다른 문제가있는 경우 다른 4xx 상태 인 경우 417 (예상 실패) 상태로 응답해야합니다.이 헤더 필드는 향후 확장을 위해 확장 가능한 구문으로 정의됩니다. 서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다보다보다보다보다보다보다서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다보다보다기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 받으면 417 (예상 실패) 상태를 반환해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 받으면 417 (예상 실패) 상태를 반환해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다&lt;a href=&quot;#section-8.2.3&quot;&gt;&lt;/a&gt;100 (계속) 상태 사용에 대한 섹션 8.2.3 .</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expires entity-header 필드는 응답이 오래된 것으로 간주 된 날짜 / 시간을 제공합니다. 오래된 캐시 항목은 원래 서버 (또는 엔티티의 새로운 사본이있는 중간 캐시)로 먼저 유효성 검증되지 않는 한 캐시 (프록시 캐시 또는 사용자 에이전트 캐시)에 의해 정상적으로 리턴되지 않을 수 있습니다. 만료 모델에 대한 자세한 내용은 &lt;a href=&quot;#section-13.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 를 참조하십시오 . 만료 필드가 있다고해서 원래 리소스가 해당 시간 전, 후 또는 후에 존재하거나 변경되지 않는다는 것을 의미하지는 않습니다. 형식은 &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 3.3.1&lt;/a&gt; 에서 HTTP-date로 정의 된 절대 날짜 및 시간입니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123에&lt;/a&gt; 있어야합니다.날짜 형식 : Expires = &quot;Expires&quot; &quot;:&quot;HTTP-date 사용 예는 Expires : Thu, 1994 년 12 월 01 일 16:00:00 GMT 참고 : 응답에 최대 지시문이있는 Cache-Control 필드가 포함 된 경우 ( &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 참조 ) 해당 지시문은 만료 필드를 재정의합니다. HTTP / 1.1 클라이언트 및 캐시는 과거와 같이 특히 &quot;0&quot;을 포함하여 다른 유효하지 않은 날짜 형식을 처리해야합니다 (예 : &quot;이미 만료 됨&quot;). 응답을 &quot;이미 만료 됨&quot;으로 표시하기 위해 오리진 서버는 만료 날짜를 Date 헤더 값과 동일하게 보냅니다. ( &lt;a href=&quot;#section-13.2.4&quot;&gt;섹션 13.2.4의&lt;/a&gt; 만료 계산 규칙을 ​​참조하십시오..) 응답이 &quot;만료되지 않음&quot;으로 표시하기 위해 오리진 서버는 응답이 전송 된 날로부터 약 1 년 후에 만료 날짜를 보냅니다. HTTP / 1.1 서버는 앞으로 1 년 이상 만료 날짜를 보내지 않아야합니다. 캐시 할 수없는 기본 응답에 대한 날짜 값이 미래의 시간 인 Expires 헤더 필드가 있으면 캐시 제어 헤더 필드 ( &lt;a href=&quot;#section-14.9&quot;&gt;14.9 절&lt;/a&gt; )에서 다르게 표시하지 않는 한 응답을 캐시 할 수 있음을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">기능 정책 HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">From request-header (요청한 요청 헤더) 필드에는 요청하는 사용자 에이전트를 제어하는 ​​사용자의 인터넷 전자 메일 주소가 포함되어야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ]에 의해 업데이트 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]의 &quot;사서함&quot;에 정의 된대로 주소는 기계적으로 사용 가능해야합니다.] : From = &quot;보낸 사람&quot; &quot;:&quot;우편함 예 : From : webmaster@w3.org이 헤더 필드는 로깅 목적 및 유효하지 않거나 원치 않는 요청의 출처를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호로 사용해서는 안됩니다. 이 필드의 해석은 요청 된 사람을 대신하여 요청이 수행되고 있으며, 수행 된 방법에 대한 책임을 수락하는 사람입니다. 특히 로봇 에이전트는이 헤더를 포함해야하므로 수신 측에서 문제가 발생할 경우 로봇 운영 담당자에게 연락 할 수 있습니다. 이 필드의 인터넷 이메일 주소는 요청을 발행 한 인터넷 호스트와 분리 될 수 있습니다. 예를 들어, 요청이 프록시를 통해 전달되면 원래 발급자의주소를 사용해야합니다. 클라이언트는 사용자의 개인 정보 보호 또는 사이트의 보안 정책과 충돌 할 수 있으므로 사용자의 승인없이 보낸 사람 헤더 필드를 보내지 않아야합니다. 사용자는 요청 전에 언제든지이 필드의 값을 비활성화, 활성화 및 수정할 수있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GET 메소드는 Request-URI에 의해 식별되는 모든 정보 (엔티티 형태)를 검색하는 것을 의미합니다. Request-URI가 데이터 생성 프로세스를 참조하는 경우, 해당 텍스트가 프로세스의 출력이 아닌 한, 프로세스의 소스 텍스트가 아닌 응답의 엔티티로 리턴되는 생성 된 데이터입니다. 요청 메시지에 If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match 또는 If-Range 헤더 필드가 포함 된 경우 GET 메소드의 의미는 &quot;조건부 GET&quot;으로 변경됩니다. 조건부 GET 메소드는 조건부 헤더 필드에 설명 된 상황에서만 엔티티를 전송하도록 요청합니다.조건부 GET 방법은 클라이언트가 이미 보유한 데이터를 여러 번 요청하거나 전송하지 않고도 캐시 된 엔터티를 새로 고치도록하여 불필요한 네트워크 사용을 줄 이도록 고안되었습니다. 요청 메시지에 Range 헤더 필드가 포함 된 경우 GET 메소드의 의미가 &quot;부분 GET&quot;으로 변경됩니다. 부분 GET은 다음에 설명 된대로 엔티티의 일부만 전송하도록 요청합니다.&lt;a href=&quot;#section-14.35&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; . 부분 GET 방법은 클라이언트가 이미 보유한 데이터를 전송하지 않고 부분 검색된 엔티티를 완료 할 수 있도록하여 불필요한 네트워크 사용을 줄 이도록 고안되었습니다. GET 요청에 대한 응답은 &lt;a href=&quot;#section-13&quot;&gt;13 섹션에&lt;/a&gt; 설명 된 HTTP 캐싱 요구 사항을 충족하는 경우에만 캐시 가능합니다 . 양식에 사용될 때 보안 고려 사항은 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GET 메소드는 대상 자원에 대해 현재 선택된 표현의 전송을 요청합니다. GET은 정보 검색의 주요 메커니즘이며 거의 모든 성능 최적화의 초점입니다. 따라서 사람들이 HTTP를 통해 식별 가능한 정보를 검색한다고 할 때 일반적으로 GET 요청을 말하는 것입니다. 리소스 식별자를 원격 파일 시스템 경로 이름으로, 표현을 그러한 파일의 내용의 복사본으로 생각하고 있습니다. 실제로, 그것은 구현 된 자원의 수입니다 ( &lt;a href=&quot;#section-9.1&quot;&gt;9.1 절&lt;/a&gt; 참조) 관련 보안 고려 사항). 그러나 실제로는 이러한 제한이 없습니다. 리소스에 대한 HTTP 인터페이스는 콘텐츠 개체 트리, 다양한 데이터베이스 레코드에 대한 프로그래밍 방식보기 또는 다른 정보 시스템으로의 게이트웨이로 구현 될 가능성이 높습니다. URI 맵핑 메커니즘이 파일 시스템에 연결되어 있더라도 오리진 서버는 요청을 입력으로 파일을 실행하고 파일을 직접 전송하지 않고 표현으로 출력을 보내도록 구성 될 수 있습니다. 어쨌든, 오리진 서버 만이 각 자원 식별자가 구현에 해당하는 방법과 각 구현이 GET에 대한 응답으로 대상 자원의 현재 표현을 선택하여 전송하는 방법을 알아야합니다. 클라이언트는 GET의 의미를 &quot;range request &quot;, 요청에 Range 헤더 필드를 전송하여 선택한 표현의 일부만 전송하도록 요청합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]). GET 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. GET 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. GET 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절)에&lt;/a&gt; 의해 달리 지시되지 않는 한, 후속 GET 및 HEAD 요청을 만족시키기 위해이를 사용할 수있다 .</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEAD 메소드는 서버가 응답으로 메시지 본문을 리턴해서는 안된다는 점을 제외하고는 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함 된 메타 정보는 GET 요청에 대한 응답으로 전송 된 정보와 동일해야합니다. 이 방법은 엔티티 본문 자체를 전송하지 않고 요청에 의해 암시 된 엔티티에 대한 메타 정보를 얻는 데 사용할 수 있습니다. 이 방법은 유효성, 접근성 및 최근 수정 사항에 대해 하이퍼 텍스트 링크를 테스트하는 데 자주 사용됩니다. HEAD 요청에 대한 응답은 응답에 포함 된 정보가 해당 리소스에서 이전에 캐시 된 엔티티를 업데이트하는 데 사용될 수 있다는 의미에서 캐시 가능할 수 있습니다.새로운 필드 값이 캐시 된 엔티티가 현재 엔티티와 다르다는 것을 표시하는 경우 (Content-Length, Content-MD5, ETag 또는 Last-Modified의 변경으로 표시됨) 캐시는 캐시 항목을 오래된 것으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEAD 메소드는 서버가 응답으로 메시지 본문을 보내서는 안된다는 점을 제외하고 GET과 동일합니다 (즉, 헤더 섹션의 끝에서 응답이 종료 됨). 서버는 페이로드 헤더 필드를 제외하고 요청이 GET이었을 때 보낸 것과 동일한 헤더 필드를 HEAD 요청에 대한 응답으로 보내야한다 ( &lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3).&lt;/a&gt;) 생략 될 수 있습니다. 이 방법은 표현 데이터를 전송하지 않고 선택된 표현에 대한 메타 데이터를 얻는 데 사용될 수 있으며, 유효성, 접근성 및 최근 수정을 위해 하이퍼 텍스트 링크를 테스트하는 데 종종 사용됩니다. HEAD 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. HEAD 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. HEAD 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절)에&lt;/a&gt; 의해 다르게 지시되지 않는 한 후속 HEAD 요청을 만족시키기 위해이를 사용할 수있다 . HEAD 응답은 GET에 대한 이전에 캐시 된 응답에도 영향을 줄 수 있습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]의 4.3.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; 의 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 지시문은 페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다. 제한되는 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 다른 CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;페치 지시문&lt;/a&gt; 의 폴백 역할을합니다 . 없는 다음 지시문 각각에 대해 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾아이 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; 지시문은 주어진 컨텍스트에서 양식 제출의 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 지시문은로드 할 수있는 자원 유형을 제한하여 문서에 포함 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">페이지로부터의 링크 에 대한 &lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더에 정보를 지정하는 데 사용되는 CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 지시문 ( 원래 스펙의 오타 인 단일 &lt;code&gt;r&lt;/code&gt; 과 함께 ) 이 API는 더 이상 사용되지 않으며 브라우저에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다. 팝업 방지, 플러그인 및 스크립트 실행 방지, 동일 출처 정책 시행 등 페이지 작업에 제한을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 지시문은 JavaScript의 유효한 소스를 지정합니다. 여기에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 직접로드 된 URL 뿐만 아니라 스크립트 실행을 트리거 할 수있는 인라인 스크립트 이벤트 핸들러 ( &lt;code&gt;onclick&lt;/code&gt; ) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT 스타일 시트&lt;/a&gt; 와 같은 것도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스타일 시트에 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트가 모든 사이트의 안전하지 않은 URL (HTTP를 통해 제공되는 URL)을 보안 URL (HTTPS를 통해 제공되는 URL)로 교체 한 것처럼 처리하도록 지시합니다. 이 지시문은 다시 작성해야하는 안전하지 않은 기존 URL이 많은 웹 사이트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문 은 리소스에 적용 할 수 있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;매니페스트를&lt;/a&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 이미지 및 즐겨 찾기 아이콘의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 지시문은 클라이언트가 페이지의 스크립트 또는 스타일에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 을 사용하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 지시문은 문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 . 이 값이 없으면 모든 URI가 허용됩니다. 이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;autoplay&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 요청 된 미디어를 자동 재생하도록 허용되는지 여부를 제어합니다 . 이 정책이 활성화되어 있고 사용자 제스처가 없으면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 으로 거부됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;autoplay&lt;/code&gt; 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;camera&lt;/code&gt; 지시문은 현재 문서에서 비디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">는 HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;document-domain&lt;/code&gt; 현재 문서가 세트로 허용되는지 여부를 지시 컨트롤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; 을&lt;/a&gt; . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; 설정 시도 가 실패하고 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;encrypted-media&lt;/code&gt; 지시문은 현재 문서가 EME ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API) 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;fullscreen&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;geolocation&lt;/code&gt; 지정 문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; 인터페이스 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 을 호출하면 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; 코드로 해당 함수의 콜백이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;microphone&lt;/code&gt; 지시문은 현재 문서에서 오디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;midi&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 으로 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;payment&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;지불 요청 API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; 생성자가 &lt;code&gt;SecurityError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;vr&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 지시문은 페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다. 제한되는 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 다른 CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;페치 지시문&lt;/a&gt; 의 폴백 역할을합니다 . 없는 다음 지시문 각각에 대해 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾아이 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; 지시문은 지정된 컨텍스트에서 양식 제출 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 지시문은로드 할 수있는 자원 유형을 제한하여 문서에 포함 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">페이지에서 떨어진 링크 에 대한 &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더에 정보를 지정하는 데 사용되는 CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 지시문 ( 원래 스펙의 오타 인 단일 &lt;code&gt;r&lt;/code&gt; 과 함께 ) 이 API는 더 이상 사용되지 않으며 브라우저에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다. 팝업 방지, 플러그인 및 스크립트 실행 방지, 동일 출처 정책 시행 등 페이지 작업에 제한을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 지시문은 JavaScript의 유효한 소스를 지정합니다. 여기에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 직접로드 된 URL 뿐만 아니라 스크립트 실행을 트리거 할 수있는 인라인 스크립트 이벤트 핸들러 ( &lt;code&gt;onclick&lt;/code&gt; ) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT 스타일 시트&lt;/a&gt; 와 같은 것들도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스타일 시트 소스의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트가 모든 사이트의 안전하지 않은 URL (HTTP를 통해 제공되는 URL)을 보안 URL (HTTPS를 통해 제공되는 URL)로 교체 한 것처럼 처리하도록 지시합니다. 이 지시문은 다시 작성해야하는 안전하지 않은 기존 URL이 많은 웹 사이트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문 은 리소스에 적용 할 수 있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;매니페스트를&lt;/a&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 이미지 및 즐겨 찾기 아이콘의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 지시문은 클라이언트가 페이지의 스크립트 또는 스타일에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 을 사용하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 지시문은 문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 . 이 값이 없으면 모든 URI가 허용됩니다. 이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;fullscreen&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;geolocation&lt;/code&gt; 지정 문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; 인터페이스 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 을 호출하면 해당 함수의 콜백이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; 코드 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;microphone&lt;/code&gt; 지시문은 현재 문서에서 오디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 메소드는 문서의 완전한 교체 만 허용합니다. &lt;code&gt;PUT&lt;/code&gt; 과 달리 , &lt;code&gt;PATCH&lt;/code&gt; 는 dem 등성이 아니며, 동일한 패치 요청 &lt;em&gt;이&lt;/em&gt; 연속하여 다른 영향을 미칠 &lt;em&gt;수&lt;/em&gt; 있음을 의미 합니다. 그러나 dem 등원 (Idempotent) 방식으로 &lt;code&gt;PATCH&lt;/code&gt; 요청 을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 정보 상태 응답 코드는 지금까지 모든 것이 정상이며 클라이언트가 요청을 계속하거나 이미 완료된 경우이를 무시해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했음을 나타냅니다. 기본적으로 200 응답은 캐시 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했으며 리소스가 생성되었음을 나타냅니다. 이 응답이 다시 전송되기 전에 새 자원이 효과적으로 작성되고 새 자원이 메시지 본문에 리턴되며, 해당 위치는 요청의 URL 또는 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더 의 컨텐츠입니다 .</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 응답 상태는 요청이 성공했지만 변환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시에&lt;/a&gt; 의해 동봉 된 페이로드가 원래 서버의 &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) 응답 의 페이로드에서 수정되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했지만 클라이언트가 현재 페이지에서 벗어날 필요가 없음을 나타냅니다. 204 응답은 기본적으로 캐시 가능합니다. 이러한 응답 에는 &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 응답 상태는 클라이언트에게 문서보기를 재설정하도록 지시합니다. 예를 들어 양식의 내용을 지우거나 캔버스 상태를 재설정하거나 UI를 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 성공 상태 응답 코드는 요청의 &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더에 설명 된대로 요청이 성공했으며 본문에 요청 된 데이터 범위가 포함되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client 오류 상태 응답 코드는 요청이 대상 자원에 대한 유효한 인증 신임 정보가 없기 때문에 적용되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error 상태 응답 코드는 서버가 요청을 이해했지만 권한 부여를 거부 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; 클라이언트 오류 상태 응답 코드는 요청 된 자원에 액세스 할 수있는 브라우저와 서버 사이 에있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;프록시 서버에&lt;/a&gt; 대한 유효한 인증 신임 정보가 없기 때문에 요청이 적용되지 않았 음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; 클라이언트 오류 응답 코드는 요청의 &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; 헤더에 제공된 기대치를 충족 할 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">&lt;code&gt;418 I'm a teapot&lt;/code&gt; 클라이언트 인 HTTP 418 오류 응답 코드는 서버가 주전자이므로 커피 추출을 거부 함을 나타냅니다. 이 오류는 1998 년 April Fools의 농담 인 Hyper Text Coffee Pot Control Protocol에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 응답 코드는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 요청 헤더를 포함하여 메시지를 보낸 클라이언트가 요청한대로 서버가 전환하는 프로토콜을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청에 둘 이상의 가능한 응답이 있음을 나타냅니다. 사용자 에이전트 또는 사용자는 그 중 하나를 선택해야합니다. 응답 중 하나를 선택하는 표준화 된 방법이 없으므로이 응답 코드는 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; 클라이언트 리디렉션 응답 코드는 요청 된 리소스를 다시 전송할 필요가 없음을 나타냅니다. 캐시 된 리소스에 대한 암시 적 리디렉션입니다. 이는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 과 같은 요청 메소드가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 하거나 요청이 조건부이고 &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 사용하는 경우에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 요청 된 자원을 찾을 수 없음을 나타냅니다. 404 페이지로 연결되는 링크는 종종 깨지거나 죽은 링크라고하며, 대상이 될 수 있습니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;죽은 링크&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 서버의 현재 상태와 충돌 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청 엔티티가 서버에서 정의한 한계보다 큼을 나타냅니다. 서버가 연결을 닫거나 &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; 헤더 필드를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 클라이언트가 요청한 URI가 서버가 해석하려는 것보다 길다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 페이로드 형식이 지원되지 않는 형식이므로 서버가 요청 승인을 거부 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드 한 후 기꺼이 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 요청을 &lt;a href=&quot;../conditional_requests&quot;&gt;조건부로&lt;/a&gt; 요구함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 사용자가 지정된 시간 내에 요청을 너무 많이 보냈 음을 나타냅니다 ( &quot;속도 제한&quot;).</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 헤더 필드가 너무 커서 서버가 요청을 처리하지 않을 것임을 나타냅니다. 요청 헤더 필드의 크기를 줄인 후 요청이 다시 제출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 클라이언트가 네트워크 액세스 권한을 얻기 위해 인증해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 피닝 위반 보고서를 헤더에 지정된 &lt;code&gt;report-uri&lt;/code&gt; 로 전송 하지만, &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 과 달리 고정을 위반하면 브라우저가 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 특정 암호화 공개 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;키&lt;/a&gt; 를 특정 웹 서버 와 연결하여 위조 된 인증서 로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; 공격 의 위험을 줄 입니다. 하나 이상의 키가 고정되어 있고 서버에서 사용하지 않는 키가 있으면 브라우저는 응답을 정당한 것으로 받아들이지 않고 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 요청 헤더에는 일반적으로 서버가 &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 상태 및 &lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더로 응답 한 후 서버로 사용자 에이전트를 인증하기위한 신임 정보가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">웹 개발자는 HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 응답 헤더를 사용하여 효과를 모니터링 (강제하지는 않음)하여 정책을 실험 할 수 있습니다. 이러한 위반 보고서 는 HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 통해 지정된 URI로 전송 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; 문서로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">웹 사이트 관리자는 HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 응답 헤더를 사용하여 사용자 에이전트가 특정 페이지에 대해로드 할 수있는 리소스를 제어 할 수 있습니다. 몇 가지 예외를 제외하고 정책에는 주로 서버 원본 및 스크립트 끝점 지정이 포함됩니다. 이를 통해 사이트 간 스크립팅 공격 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; )을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 헤더는 자체 프레임과 iframe에 포함 된 브라우저 기능의 사용을 허용 및 거부하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 응답 헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;프록시 서버&lt;/a&gt; 뒤의 리소스에 액세스하는 데 사용해야하는 인증 방법을 정의 합니다 . 요청을 프록시 서버로 인증하여 요청을 더 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; 요청 헤더에는 일반적으로 서버가 &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 상태 및 &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더로 응답 한 후 프록시 서버에 대한 사용자 에이전트를 인증하기위한 신임 정보가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 요청 헤더는 암호화되고 인증 된 응답에 대한 클라이언트의 기본 설정을 나타내는 신호를 서버에 전송하며 &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt; 지시문을 성공적으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 응답 헤더는 리소스에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 응답 헤더는 Internet Explorer, Chrome 및 Safari의 기능으로, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; (Cross-Site Scripting ) 공격이 감지 될 때 페이지로드를 중지합니다 . 사이트 가 인라인 JavaScript ( &lt;code&gt;'unsafe-inline'&lt;/code&gt; )를 사용하지 못하게 하는 강력한 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 을 구현할 때 최신 브라우저에서는 이러한 보호가 거의 필요 하지 않지만, 아직 그렇지 않은 이전 웹 브라우저의 사용자를 보호 할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP를&lt;/a&gt; 지원하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP Strict Transport Security 헤더는 브라우저에 HTTP를 사용하여 사이트를로드해서는 안된다고 알려주고 대신 HTTP를 사용하여 사이트에 액세스하려는 모든 시도를 HTTPS 요청으로 자동 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URL 네임 스페이스는 &quot;/&quot;문자로 계층이 구분되는 계층 적 네임 스페이스입니다. HTTP URL 네임 스페이스는 다음 조건을 충족하는 경우 일관된 것으로 간주됩니다. HTTP 계층의 모든 URL에 대해 해당 URL을 내부 구성원 URL로 포함하는 콜렉션이 있습니다. 고려중인 네임 스페이스의 루트 또는 최상위 수준 컬렉션은 이전 규칙에서 제외됩니다. 고려중인 네임 스페이스의 최상위 컬렉션은 반드시 절대 경로 '/'로 식별 된 컬렉션 일 필요는 없습니다. 하나 이상의 경로 세그먼트 (예 : / servlets / webdav / ...)로 식별 될 수 있습니다. HTTP / 1.1 또는 WebDAV에서는 전체 HTTP URL 네임 스페이스가 일관되어야합니다. WebDAV 호환 리소스에는 부모 컬렉션이 없을 수 있습니다. 하나,특정 WebDAV 메소드는 네임 스페이스 불일치를 유발하는 결과를 생성 할 수 없습니다. [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ], 콜렉션 자원을 포함한 모든 자원은 둘 이상의 URI로 식별 될 수 있습니다 (MAY). 예를 들어, 리소스는 여러 HTTP URL로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP 인증 프레임 워크는 자격 증명의 기밀성을 유지하기위한 단일 메커니즘을 정의하지 않습니다. 대신, 각 인증 체계는 전송 전에 자격 증명이 인코딩되는 방식을 정의합니다. 이는 향후 인증 체계의 개발에 유연성을 제공하지만 자체적으로 기밀성을 제공하지 않거나 재생 공격으로부터 충분히 보호하지 못하는 기존 체계를 보호하기에는 부적합합니다. 또한 서버가 각 개별 사용자에게 고유 한 자격 증명을 기대하면 자격 증명 내의 내용이 기밀로 유지되는 경우에도 해당 자격 증명을 교환하면 해당 사용자를 식별하는 효과가 있습니다.HTTP는 기본 전송 레벨 또는 세션 레벨 연결의 보안 특성에 따라 헤더 필드의 기밀 전송을 제공합니다. 즉, 서버가이 프레임 워크를 사용하여 인증 된 사용자에 대한 액세스를 제한하는 경우 서버는 사용 된 인증 체계의 특성에 따라 연결이 올바르게 보안되도록해야합니다. 예를 들어 개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;&lt;/a&gt;자격 증명을 교환하기 전에 RFC5246 ]).</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP 조건부 요청 헤더 필드 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]를 사용하면 클라이언트가 대상 자원의 상태에 사전 조건을 배치 할 수 있으므로 사전 조건이 false로 평가되는 경우 메소드 시맨틱에 해당하는 조치가 적용되지 않습니다. 이 규격에 의해 정의 된 각각의 전제 조건은 목표 자원의 사전 표현으로부터 획득 된 검증기 세트와 선택된 표현에 대한 검증기의 현재 상태 ( &lt;a href=&quot;#section-7.2&quot;&gt;섹션 7.2&lt;/a&gt; ) 사이의 비교로 구성된다 . 따라서 이러한 전제 조건은 클라이언트가 알려진 특정 상태 이후에 대상 자원의 상태가 변경되었는지 여부를 평가합니다. 이러한 평가의 효과는 방법론의 의미론과&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232] 섹션 5&lt;/a&gt; . + --------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + --------------------- + -------------------------- + | 일치하는 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232] 섹션 3.1&lt;/a&gt; | | 일치하지 않는 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232] 섹션 3.2&lt;/a&gt; | | 수정 된 이후 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232] 섹션 3.3&lt;/a&gt; | | 수정되지 않은 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232] 섹션 3.4&lt;/a&gt; | | 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233] 섹션 3.2&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청 에 사용되는 HTTP 메소드 는 응답의 &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 헤더에 지정된 메소드 목록에 포함되지 않습니다 . 이 헤더는 CORS를 사용하여 요청에 지정된 URL에 액세스 할 때 사용될 수있는 쉼표로 구분 된 HTTP 메소드 목록을 지정합니다. 요청이 다른 방법을 사용하는 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 프로토콜은 요청 / 응답 프로토콜입니다. 클라이언트는 요청 메소드, URI 및 프로토콜 버전의 형태로 서버에 요청을 보낸 다음 서버와의 연결을 통해 요청 수정 자, 클라이언트 정보 및 가능한 본문 내용을 포함하는 MIME와 유사한 메시지를 보냅니다. 서버는 메시지의 프로토콜 버전, 성공 또는 오류 코드를 포함한 상태 표시 줄과 서버 정보, 엔티티 메타 정보 및 가능한 엔티티 본문 컨텐츠를 포함하는 MIME와 유사한 메시지로 응답합니다. HTTP와 MIME의 관계는 부록 19.4에 설명되어 있습니다. 대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 오리진 서버의 자원에 적용되는 요청으로 구성됩니다. 가장 간단한 경우이것은 사용자 에이전트 (UA)와 오리진 서버 (O) 사이의 단일 연결 (v)을 통해 달성 될 수있다. 요청 체인 ------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;----------------------- 응답 체인보다 복잡한 상황은 하나 이상의 중개자가 요청 / 응답 체인에 존재합니다. 프록시, 게이트웨이 및 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 포워딩 에이전트로, 절대 형식으로 URI에 대한 요청을 수신하고, 메시지의 전부 또는 일부를 다시 쓰고, URI로 식별 된 서버로 재 포맷 된 요청을 전달합니다. 게이트웨이는 수신 에이전트로, 다른 서버보다 높은 계층으로 작동하며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다.터널은 메시지를 변경하지 않고 두 연결 사이의 중계 점 역할을합니다. 중개자가 메시지의 내용을 이해할 수없는 경우에도 통신이 방화벽과 같은 중개자를 통과해야하는 경우 터널이 사용됩니다. 요청 체인 --------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ---------------------------- 응답 체인 위의 그림은 사용자 에이전트와 오리진 사이의 세 가지 중개자 (A, B 및 C)를 보여줍니다. 섬기는 사람. 전체 체인을 이동하는 요청 또는 응답 메시지는 4 개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 비 터널 인접 장치와의 연결에만 적용 할 수 있기 때문에 이러한 구별이 중요합니다.체인의 끝점 또는 체인의 모든 연결부에만 연결하십시오. 다이어그램은 선형이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하고 /하거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다. 터널로 작동하지 않는 통신 당사자는 요청을 처리하기 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인을 따라 참가자 중 하나가 해당 요청에 적용 가능한 캐시 된 응답을 갖는 경우 요청 / 응답 체인이 단축되는 것입니다. 다음은 B에 UA 또는 A에 의해 캐시되지 않은 요청에 대해 (C를 통해) O로부터의 초기 응답의 캐시 된 사본이있는 경우 결과 체인을 보여줍니다.요청 체인 ----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;--------- 응답 체인 모든 응답을 캐시 할 수있는 것은 아니며 일부 요청에는 캐시 동작에 대한 특별한 요구 사항을 지정하는 수정자가 포함될 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구 사항은&lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;. 실제로, 월드 와이드 웹 (World Wide Web)에서 현재 실험되거나 배포되고있는 캐시 및 프록시의 다양한 아키텍처와 구성이 있습니다. 이러한 시스템에는 대서양 대역폭을 절약하기위한 전국 프록시 캐시 계층, 캐시 항목을 브로드 캐스트 또는 멀티 캐스트하는 시스템, CD-ROM을 통해 캐시 된 데이터의 서브 세트를 분배하는 조직 등이 포함됩니다. HTTP 시스템은 고 대역폭 링크를 통해 회사 인트라넷에서 사용되며 저전력 무선 링크 및 간헐적 인 연결을 통해 PDA를 통한 액세스에 사용됩니다. HTTP / 1.1의 목표는 이미 구축 된 다양한 구성을 지원하는 동시에 높은 안정성을 요구하는 웹 응용 프로그램을 작성하는 사람들의 요구를 충족시키는 프로토콜 구성을 도입하는 것입니다.HTTP 통신은 일반적으로 TCP / IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]이지만 다른 포트를 사용할 수 있습니다. 인터넷이나 다른 네트워크의 다른 프로토콜 위에 HTTP가 구현되는 것을 막을 수는 없습니다. HTTP는 안정적인 전송만을 가정합니다. 그러한 보증을 제공하는 모든 프로토콜을 사용할 수 있습니다. HTTP / 1.1 요청 및 응답 구조를 해당 프로토콜의 전송 데이터 단위로 매핑하는 것은이 사양의 범위를 벗어납니다. HTTP / 1.0에서 대부분의 구현은 각 요청 / 응답 교환에 대해 새로운 연결을 사용했습니다. HTTP / 1.1에서는 연결이 여러 가지 이유로 닫힐 수 있지만 하나 이상의 요청 / 응답 교환에 연결이 사용될 수 있습니다 ( &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTP 프로토콜은 &lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt; 라는 요청 메소드를 지정합니다 . 요청 된 리소스와 양방향 통신을 시작하고 터널을 여는 데 사용할 수 있습니다. HTTP 프록시 뒤의 클라이언트가 SSL (예 : HTTPS, 포트 443)을 사용하여 웹 사이트에 액세스 할 수있는 방법입니다. 그러나 모든 프록시 서버가 &lt;code&gt;CONNECT&lt;/code&gt; 메소드를 지원 하거나 포트 443으로 만 제한하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">초기 단계에서 사용 된 HTTP 프로토콜은 매우 단순했고 나중에 HTTP / 0.9라고 불 렸으며 때로는 한 줄 프로토콜로도 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP 응답 헤더</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">글로벌 오브젝트가 인스턴스화 된 자원의 HTTP 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">요청에 사용 된 HTTP 버전이 서버에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1 표준은 서버 중심 협상을 시작하는 표준 헤더 목록 ( &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; )을 정의합니다. 엄밀히 말하면 &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 는이 목록에 없지만 요청 된 리소스의 특정 표현을 보내는 데 사용되기도하지만 이는 좋은 방법으로 간주되지 않습니다. 서버는 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 &lt;a href=&quot;caching&quot;&gt;캐시&lt;/a&gt; 가 최적으로 작동 할 수 있도록 실제로 컨텐츠 협상에 사용 된 헤더 (또는보다 정확하게 연관된 응답 헤더)를 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP / 2 바이너리 프레이밍 메커니즘은 적용된 API 또는 구성 파일을 변경할 필요가 없도록 설계되었습니다. 사용자에게 광범위하게 투명합니다.</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP / 2 프로토콜은 HTTP / 1.1 버전과 몇 가지 주요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Host request-header (호스트 요청 헤더) 필드는 사용자 또는 참조 리소스가 제공 한 원래 URI (일반적으로 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2 절에&lt;/a&gt; 설명 된 HTTP URL)에서 얻은 요청중인 리소스의 인터넷 호스트 및 포트 번호를 지정합니다 . 호스트 필드 값은 원래 URL이 제공 한 오리진 서버 또는 게이트웨이의 이름 지정 권한을 나타내야합니다. 이를 통해 오리진 서버 또는 게이트웨이는 단일 IP 주소의 여러 호스트 이름에 대한 서버의 루트 &quot;/&quot;URL과 같이 내부적으로 모호한 URL을 구별 할 수 있습니다. Host = &quot;Host&quot; &quot;:&quot;host [ &quot;:&quot;port]; &lt;a href=&quot;#section-3.2.2&quot;&gt;섹션 3.2.2&lt;/a&gt; 후행 포트 정보가없는 &quot;호스트&quot;는 요청 된 서비스의 기본 포트를 의미합니다 (예 : HTTP URL의 경우 &quot;80&quot;). 예를 들어, 오리진 서버에서 &amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/에&lt;/a&gt; 대한 요청&amp;gt; GET / pub / WWW / HTTP / 1.1 호스트 : www.w3.org 클라이언트는 모든 HTTP / 1.1 요청 메시지에 호스트 헤더 필드를 포함해야합니다. 요청 된 URI에 요청중인 서비스의 인터넷 호스트 이름이 포함되어 있지 않으면 호스트 헤더 필드에 빈 값을 지정해야합니다. HTTP / 1.1 프록시는 전달하는 요청 메시지에 프록시가 요청하는 서비스를 식별하는 적절한 호스트 헤더 필드가 포함되어 있어야합니다. 모든 인터넷 기반 HTTP / 1.1 서버는 호스트 헤더 필드가없는 HTTP / 1.1 요청 메시지에 400 (잘못된 요청) 상태 코드로 응답해야합니다. 호스트와 관련된 다른 요구 사항은 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 및 &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; 단원을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">차 유출 장치 (HTCPCP-TEA)를위한 하이퍼 텍스트 커피 포트 제어 프로토콜</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 수신되었지만 아직 수행되지 않았 음을 나타냅니다. 커밋되지 않은 것은 HTTP가 나중에 요청 처리 결과를 나타내는 비동기 응답을 보낼 수있는 방법이 없음을 의미합니다. 다른 프로세스 나 서버가 요청을 처리하는 경우 또는 일괄 처리를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청 된 리소스가 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 확실히 이동했음을 나타냅니다 . 브라우저가이 페이지로 리디렉션되고 검색 엔진이 리소스에 대한 링크를 업데이트합니다 ( 'SEO-speak'에서 'link-juice'가 새 URL로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청 된 리소스가 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 일시적으로 이동했음을 나타냅니다 . 브라우저는이 페이지로 리디렉션되지만 검색 엔진은 리소스에 대한 링크를 업데이트하지 않습니다 ( 'SEO-speak'에서 'link-juice'는 새 URL로 전송되지 않는다고합니다).</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 리디렉션이 새로 업로드 된 리소스가 아니라 확인 페이지 또는 업로드 진행률 페이지와 같은 다른 페이지에 연결됨을 나타냅니다. 이 응답 코드는 일반적으로 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 의 결과로 다시 전송됩니다 . 이 리디렉션 된 페이지를 표시하는 데 사용되는 방법은 항상 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; 경로 재 지정 상태 응답 코드는 요청 된 자원이 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 확실히 이동되었음을 나타냅니다 . 브라우저가이 페이지로 리디렉션되고 검색 엔진이 리소스에 대한 링크를 업데이트합니다 ( 'SEO-speak'에서 'link-juice'가 새 URL로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 유효하지 않은 구문으로 인해 서버가 요청을 이해할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청 방법이 서버에 알려져 있지만 대상 자원에 의해 지원 &lt;strong&gt;되지 않음을&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 요청의 사전 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 헤더에 정의 된 허용 가능한 값 목록과 일치하는 응답을 생성 할 수없고 서버가 기본 표현을 제공하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가이 사용되지 않은 연결을 종료하려고 함을 의미합니다. &lt;em&gt;클라이언트의 이전 요청 없이도&lt;/em&gt; 일부 서버에서 유휴 연결로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 대상 자원에 대한 액세스를 더 이상 원래 서버에서 사용할 수 없으며이 조건이 영구적 일 가능성이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 정의 된 &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더 없이 요청 수락을 거부 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 대상 자원에 대한 액세스가 거부되었음을 나타냅니다. 이는 &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 헤더에 의해 정의 된 조건이 충족 되지 않은 경우 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 이외의 메소드에 대한 조건부 요청에서 발생합니다 . 이 경우 일반적으로 자원 업로드 또는 수정 요청을 수행 할 수 없으며이 오류 응답이 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; 오류 응답 코드는 서버가 요청 된 범위를 처리 할 수 ​​없음을 나타냅니다. 가장 가능성이 높은 이유는 문서에 이러한 범위가 포함되어 있지 않거나 구문으로 올바른 &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더 값이 의미가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 요청 엔티티의 컨텐츠 유형을 이해하고 요청 엔티티의 구문이 올바르지 만 포함 된 명령을 처리 할 수 ​​없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 재생할 수있는 요청을 처리 할 위험이 없음을 나타내므로 재생 공격의 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; HTTP (HyperText Transfer Protocol) &lt;strong&gt;451을 사용할 수 없음&lt;/strong&gt; 클라이언트 오류 응답 코드는 사용자가 합법적 인 조치가 발행 된 웹 페이지와 같이 합법적 인 이유로 인해 사용할 수없는 자원을 요청했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 요청을 수행하지 못하게하는 예기치 않은 조건이 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 요청 방법이 서버에서 지원되지 않아 처리 할 수 ​​없음을 나타냅니다. 서버가 지원해야하는 유일한 메소드 (따라서이 코드를 리턴하지 않아야 함)는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 게이트웨이 또는 프록시 역할을하는 동안 업스트림 서버로부터 유효하지 않은 응답을 수신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 요청을 처리 할 준비가되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 게이트웨이 또는 프록시로 작동하는 동안 시간 내에 응답을 얻을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청에 사용 된 HTTP 버전이 서버에서 &lt;strong&gt;지원되지 않음을&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)는 네트워크 기반 하이퍼 텍스트 정보 시스템과의 유연한 상호 작용을 위해 확장 가능한 의미 체계 및 자체 설명 메시지 페이로드를 사용하는 상태 비 저장 응용 프로그램 수준 요청 / 응답 프로토콜입니다. 이 문서는 HTTP / 1.1 사양을 종합적으로 구성하는 일련의 문서 중 첫 번째입니다. 1. &quot;메시지 구문 및 라우팅&quot;(이 문서) 2. &quot;시맨틱 및 컨텐츠&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3. &quot;조건부 요청&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4. &quot;범위 요청&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5. &quot;캐싱&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6. &quot;인증&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]이 HTTP / 1.1 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145를 폐기합니다&lt;/a&gt;(HTTP 버전 관리). 이 사양은 또한 이전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; 에 정의 된 터널을 설정하기 위해 CONNECT 사용을 업데이트하고 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818에&lt;/a&gt; 비공식적으로 설명 된 &quot;https&quot;URI 체계를 정의합니다.. HTTP는 정보 시스템을위한 일반적인 인터페이스 프로토콜입니다. 제공되는 리소스 유형에 관계없이 클라이언트에 균일 한 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었습니다. 마찬가지로 서버는 각 클라이언트의 목적을 인식 할 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트 또는 미리 결정된 일련의 응용 프로그램 단계와 관련되는 것이 아니라 격리 된 것으로 간주 될 수 있습니다. 그 결과 많은 다른 상황에서 효과적으로 사용될 수 있고 구현이 시간이 지남에 따라 독립적으로 발전 할 수있는 프로토콜이 만들어집니다. HTTP는 또한 비 HTTP 정보 시스템과의 통신을 변환하기위한 중개 프로토콜로 사용하도록 설계되었습니다.HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 HTTP 서비스와 동일한 방식으로 클라이언트가보고 조작 할 수있는 하이퍼 텍스트 형식으로 변환하여 대체 정보 서비스에 대한 액세스를 제공 할 수 있습니다. 이 유연성의 한 가지 결과는 프로토콜이 인터페이스 뒤에서 발생하는 측면에서 정의 될 수 없다는 것입니다. 대신, 우리는 의사 소통의 구문, 수신 된 의사의 의사의 의도, 수신자의 예상되는 행동을 정의하는 데 제한을받습니다. 통신이 격리 된 것으로 간주되면 서버에서 제공하는 관찰 가능한 인터페이스에 대한 해당 변경 사항에 성공적인 작업이 반영되어야합니다. 그러나 여러 클라이언트가 병렬로 작동하고 교차 목적으로 작동 할 수 있으므로단일 응답 범위를 넘어서 그러한 변경 사항을 관찰 할 것을 요구할 수는 없습니다. 이 문서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고 &quot;http&quot;및 &quot;https&quot;URI 체계를 정의하고 전반적인 네트워크 운영 및 연결 관리를 설명하며 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.전체 네트워크 운영 및 연결 관리에 대해 설명하고 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.전체 네트워크 운영 및 연결 관리에 대해 설명하고 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 미디어 정보 시스템을위한 응용 프로그램 수준 프로토콜입니다. HTTP는 1990 년 이래 World-Wide Web 글로벌 정보 이니셔티브에서 사용되고 있습니다. HTTP / 0.9라고하는 HTTP의 첫 번째 버전은 인터넷을 통한 원시 데이터 전송을위한 간단한 프로토콜이었습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945에&lt;/a&gt; 의해 정의 된 HTTP / 1.0 [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], 전송 된 데이터 및 요청 / 응답 시맨틱에 대한 수정 자에 대한 메타 정보를 포함하는 메시지가 MIME 유사 메시지 형식이되도록하여 프로토콜을 개선했습니다. 그러나 HTTP / 1.0은 계층 프록시, 캐싱, 영구 연결 필요성 또는 가상 호스트의 영향을 충분히 고려하지 않습니다. 또한 자체적으로 &quot;HTTP / 1.0&quot;이라고하는 불완전하게 구현 된 응용 프로그램의 확산으로 인해 두 개의 통신 응용 프로그램이 서로의 실제 기능을 판단 할 수 있도록 프로토콜 버전이 변경되었습니다. 이 사양에서는 &quot;HTTP / 1.1&quot;이라는 프로토콜을 정의합니다. 이 프로토콜에는 기능을 안정적으로 구현하기 위해 HTTP / 1.0보다 엄격한 요구 사항이 포함되어 있습니다.실용적인 정보 시스템은 검색, 프런트 엔드 업데이트 및 주석을 포함하여 간단한 검색보다 더 많은 기능이 필요합니다. HTTP는 요청의 목적을 나타내는 개방형 메소드 및 헤더 세트를 허용합니다.&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. 메소드가 적용될 자원을 표시하기 위해 URI (Uniform Resource Identifier) ​​[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]가 제공하는 참조 규율 ( 위치) (URL) [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] 또는 이름 (URN) [ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ]으로 작성됩니다. . 메시지는 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]에 정의 된대로 인터넷 메일 [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]에서 사용하는 것과 유사한 형식으로 전달됩니다 . HTTP는 또한 SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ], NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ], FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ], Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ] 및 WAIS [ 지원 ]를 포함하여 다른 인터넷 시스템에 대한 사용자 에이전트와 프록시 / 게이트웨이 간의 통신을위한 일반 프로토콜로도 사용됩니다.&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ] 프로토콜. 이러한 방식으로 HTTP를 통해 다양한 응용 프로그램에서 사용 가능한 리소스에 대한 기본 하이퍼 미디어 액세스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 상태 코드 308 (영구적 리디렉션)</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">If 헤더에는 다음과 같은 두 가지 목적이 있습니다. o 첫 번째 목적은 특정 자원에 토큰 및 ETag와 일치하는 조건이있는 일련의 상태 목록을 제공하여 요청을 조건부로 만드는 것입니다. 이 헤더가 평가되고 모든 상태 목록이 실패하면 요청은 412 (전제 조건 실패) 상태로 실패해야합니다. 반면에, 설명 된 상태 목록 중 하나가 성공한 경우에만 요청이 성공할 수 있습니다. 상태 목록 및 일치 기능의 성공 기준은 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 및 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 섹션에 정의되어 있습니다.. 또한 상태 토큰이 If 헤더에 표시된다는 사실은 요청과 함께 &quot;제출&quot;되었음을 의미합니다. 일반적으로 클라이언트가 해당 상태 토큰을 알고 있음을 나타내는 데 사용됩니다. 상태 토큰을 제출하기위한 시맨틱은 유형에 따라 다릅니다 (잠금 토큰의 경우 &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 참조 ). 이 두 가지 목적은 별개로 처리해야합니다. 상태 토큰은 서버가 실제로 표시되는 상태 목록을 평가했는지 여부와 표현 된 조건이 참인지 여부에 관계없이 제출 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">If 요청 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;[RFC2616] 14.24 절에&lt;/a&gt; 정의 된 If-Match 헤더와 유사한 기능을 갖도록 고안되었습니다 . 그러나 If 헤더는 ETag뿐만 아니라 모든 상태 토큰을 처리합니다. 상태 토큰의 일반적인 예는 잠금 토큰이며 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Match request-header 필드는 조건부로 만드는 방법과 함께 사용됩니다. 자원에서 이전에 얻은 하나 이상의 엔티티가있는 클라이언트는 If-Match 헤더 필드에 연관된 엔티티 태그 목록을 포함시켜 해당 엔티티 중 하나가 현재 상태인지 확인할 수 있습니다. 엔터티 태그는 &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11에&lt;/a&gt; 정의되어 있습니다.. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 또한 요청을 업데이트 할 때 잘못된 버전의 리소스가 실수로 수정되는 것을 방지하기 위해 사용됩니다. 특별한 경우, &quot;*&quot;값은 현재 자원의 모든 엔티티와 일치합니다. If-Match = &quot;If-Match&quot; &quot;:&quot;( &quot;*&quot;| 1 # entity-tag) 엔티티 태그 중 하나가 유사한 GET 요청에 대한 응답으로 리턴 된 엔티티의 엔티티 태그와 일치하는 경우 ( 해당 자원에 If-Match 헤더가없는 경우) 또는 &quot;*&quot;가 제공되고 해당 자원에 대한 현재 엔티티가 존재하는 경우, 서버는 If-Match 헤더 필드가 존재하지 않는 것처럼 요청 된 메소드를 수행 할 수 있습니다.서버는 강력한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3 참조)&lt;/a&gt;)를 사용하여 If-Match에서 엔티티 태그를 비교하십시오. 일치하는 엔티티 태그가 없거나 &quot;*&quot;가 제공되고 현재 엔티티가 존재하지 않으면 서버는 요청 된 메소드를 수행하지 않아야하며 412 (사전 조건 실패) 응답을 리턴해야합니다. 이 동작은 클라이언트가 PUT과 같은 업데이트 방법이 클라이언트가 마지막으로 검색 한 이후 변경된 리소스를 수정하지 못하게하려는 경우에 가장 유용합니다. 요청이 If-Match 헤더 필드없이 2xx 또는 412 이외의 상태가된다면 If-Match 헤더는 무시되어야합니다. &quot;If-Match : *&quot;의 의미는 오리진 서버 (또는 캐시, 아마도 Vary 메커니즘을 사용하여 캐시에 의해 선택된 표현은 &lt;a href=&quot;#section-14.44&quot;&gt;14.44 절&lt;/a&gt; 참조)가 수행되는 경우이 방법을 수행해야한다는 것입니다.)가 존재하며 표현이 존재하지 않으면 수행해서는 안됩니다. 자원 (예를 들어, PUT)을 업데이트하기위한 요청은 If-Match 값에 대응하는 엔티티 (단일 엔티티 태그)가 더 이상 존재하지 않는 경우 요청 방법이 적용되어서는 안된다는 신호를 보내기 위해 If-Match 헤더 필드를 포함 할 수있다. 그 자원의 표현 이를 통해 사용자는 자신의 지식없이 자원이 변경된 경우 요청이 성공하기를 원하지 않음을 표시 할 수 있습니다. 예 : If-Match : &quot;xyzzy&quot;If-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-Match : * If-Match 헤더 필드와 If-None-Match가 모두있는 요청의 결과 또는 If-Modified-Since 헤더 필드는이 사양에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Since 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 요청 된 변형이이 필드에 지정된 시간 이후 수정되지 않은 경우 서버에서 엔티티가 리턴되지 않습니다. 대신 메시지 본문없이 304 (수정되지 않음) 응답이 반환됩니다. If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot;HTTP-date 필드의 예는 다음과 같습니다. If-Modified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT If- Modified-Since 헤더 및 Range 헤더 없음은 식별 된 엔티티가 If-Modified-Since 헤더에 의해 제공된 날짜 이후에 수정 된 경우에만 전송되도록 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다.a) 요청이 정상적으로 200 (OK) 이외의 상태가되거나 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 정확히 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다또는 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다또는 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다&lt;a href=&quot;#section-14.35&quot;&gt;섹션 14.35&lt;/a&gt;자세한 내용은. 참고 : If-Modified-Since 시간은 서버에서 해석되며 시계는 클라이언트와 동기화되지 않을 수 있습니다. 참고 : If-Modified-Since 헤더 필드를 처리 할 때 일부 서버는 304 (수정되지 않음) 응답을 보낼지 여부를 결정하기 위해 기능보다 작지 않은 정확한 날짜 비교 기능을 사용합니다. 캐시 유효성 검사를 위해 If-Modified-Since 헤더 필드를 보낼 때 최상의 결과를 얻으려면 클라이언트는 가능할 때마다 이전 Last-modified 헤더 필드에서받은 정확한 날짜 문자열을 사용하는 것이 좋습니다. 참고 : 클라이언트가 동일한 요청에 대해 Last-Modified 헤더에서 가져온 날짜 대신 If-Modified-Since 헤더에서 임의의 날짜를 사용하는 경우,클라이언트는이 날짜가 서버의 시간 이해에서 해석된다는 사실을 알고 있어야합니다. 클라이언트는 클라이언트와 서버 간의 시간 인코딩이 다르기 때문에 동기화되지 않은 클럭과 반올림 문제를 고려해야합니다. 여기에는 문서가 처음 요청 된 시간과 후속 요청의 수정 후 날짜 사이에 변경된 경우 경쟁 조건의 가능성과 수정 후 날짜의 경우 시계 왜곡 관련 문제가 발생할 수 있습니다. 서버의 시계를 수정하지 않고 클라이언트의 시계에서 파생됩니다. 클라이언트와 서버 간의 다른 시간 기준에 대한 수정은 네트워크 대기 시간으로 인해 대략적으로 이루어집니다.If-Modified-Since 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두있는 요청의 결과는이 사양에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Match 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 자원에서 이전에 얻은 하나 이상의 엔티티가있는 클라이언트는 If-None-Match 헤더 필드에 연관된 엔티티 태그 목록을 포함하여 해당 엔티티가 현재 없음을 확인할 수 있습니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 또한 클라이언트가 리소스가 존재하지 않는다고 판단 할 때 메소드 (예 : PUT)가 기존 리소스를 실수로 수정하지 못하도록 방지하는 데 사용됩니다. 특별한 경우, &quot;*&quot;값은 현재 자원의 모든 엔티티와 일치합니다. If-None-Match = &quot;If-None-Match&quot; &quot;:&quot;( &quot;*&quot;| 1 # entity-tag) 엔티티 태그 중 하나가 해당 자원의 유사한 GET 요청 (If-None-Match 헤더없이)에 대한 응답으로 리턴 된 엔티티의 엔티티 태그와 일치하거나 &quot;* &quot;가 주어지고 해당 자원에 대한 현재 엔티티가 존재하는 경우, 자원의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 것과 일치하지 않으므로 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다보다보다보다보다자원의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 것과 일치하지 않기 때문에 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다리소스의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 날짜와 일치하지 않기 때문에 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다 (SHOULD). 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다 (SHOULD). 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;두 항목 태그가 일치하는지 확인하는 방법에 대한 규칙은 13.3.3 단원을 참조하십시오 . 약한 비교 기능은 GET 또는 HEAD 요청에만 사용할 수 있습니다. 일치하는 엔티티 태그가 없으면, 서버는 요청 된 메소드를 If-None-Match 헤더 필드가 존재하지 않는 것처럼 수행 할 수 있지만 요청의 If-Modified-Since 헤더 필드도 무시해야합니다. 즉, 엔티티 태그가 일치하지 않으면 서버는 304 (수정되지 않음) 응답을 반환해서는 안됩니다 (MUST NOT). 요청이 If-None-Match 헤더 필드없이 2xx 또는 304 이외의 상태가된다면 If-None-Match 헤더는 무시되어야합니다. ( &lt;a href=&quot;#section-13.3.4&quot;&gt;섹션 13.3.4&lt;/a&gt; 참조If-Modified-Since와 If-None-Match가 동일한 요청에 나타날 때 서버 비헤이비어에 대해 설명합니다.) &quot;If-None-Match : *&quot;의 의미는 표현이 선택된 경우이 방법을 수행하지 않아야한다는 것입니다. 오리진 서버 또는 캐시 (Vary 메커니즘을 사용하는 경우) &lt;a href=&quot;#section-14.44&quot;&gt;섹션 14.44&lt;/a&gt; 참조)가 존재하고 표현이 존재하지 않으면 수행되어야한다. 이 기능은 PUT 작업 간의 경쟁을 방지하는 데 유용합니다. 예 : If-None-Match : &quot;xyzzy&quot;If-None-Match : W / &quot;xyzzy&quot;If-None-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-None-Match : W / &quot;xyzzy&quot; , W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot;If-None-Match : * If-None-Match 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두있는 요청의 결과는 다음과 같습니다. 이 사양에서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Since 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 이 필드에 지정된 시간 이후 요청 된 리소스가 수정되지 않은 경우 서버는 If-Unmodified-Since 헤더가없는 것처럼 요청 된 작업을 수행해야합니다. 지정된 시간 이후에 요청 된 변형이 수정 된 경우 서버는 요청 된 작업을 수행해서는 안되며 412 (사전 조건 실패)를 반환해야합니다. If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot;HTTP-date 필드의 예는 다음과 같습니다. If-Unmodified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT 요청이 정상적으로 수행되는 경우 (예 : If-Unmodified-Since 헤더가 없으면 2xx 또는 412 이외의 상태가되므로 If-Unmodified-Since 헤더는 무시해야합니다.지정된 날짜가 유효하지 않으면 헤더가 무시됩니다. If-Unmodified-Since 헤더 필드와 If-None-Match 또는 If-Modified-Since 헤더 필드가 모두있는 요청의 결과는이 스펙에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">JavaScript 함수는 단일 문자열을 반환합니다</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScript 함수는 항상 파일 자체에 저장해야하며 HTML에 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">이 섹션에 포함 된 JavaScript 스 니펫 (및 이러한 교차 사이트 요청을 올바르게 처리하는 서버 코드 인스턴스 실행)은 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt; 에서 &quot;실제로&quot;찾을 수 있습니다. 크로스 사이트 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 지원하는 브라우저에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Keep-Alive 헤더 (실험 사양)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified entity-header (최종 수정 된 엔터티 헤더) 필드는 원본 서버에서 변형이 마지막으로 수정 된 날짜와 시간을 나타냅니다. Last-Modified = &quot;Last-Modified&quot; &quot;:&quot;HTTP-date 사용 예는 Last-Modified : Tue, 1994 년 11 월 15 일 12:45:26 GMT이 헤더 필드의 정확한 의미는 원본 구현에 따라 다릅니다. 서버 및 원래 자원의 특성. 파일의 경우 파일 시스템이 마지막으로 수정 된 시간 일 수 있습니다. 동적으로 포함 된 부품이있는 엔티티의 경우 구성 요소 부품에 대한 최신 수정 시간 집합 일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임 스탬프 일 수 있습니다. 가상 객체의 경우 내부 상태가 마지막으로 변경된 시간 일 수 있습니다.오리진 서버는 서버가 메시지를 보낸 시간보다 늦은 Last-Modified 날짜를 보내서는 안됩니다. 그러한 경우, 자원의 마지막 수정이 미래의 시간을 나타내는 경우, 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 Date 값을 생성하는 시간에 최대한 가깝게 엔티티의 Last-Modified 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.마지막 수정은 미래의 시간을 나타내며 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 날짜 값을 생성하는 시간에 최대한 가깝게 엔터티의 마지막 수정 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.마지막 수정은 미래의 시간을 나타내며 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 Date 값을 생성하는 시간에 최대한 가깝게 엔티티의 Last-Modified 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.s 수정 시간, 특히 응답이 생성되는 시간에 개체가 변경되는 경우. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.s 수정 시간, 특히 응답이 생성되는 시간에 개체가 변경되는 경우. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified entity-header 필드 값은 종종 캐시 유효성 검사기로 사용됩니다. 간단히 말해서, Last-Modified 값 이후 엔터티가 수정되지 않은 경우 캐시 항목이 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Location response-header (위치 응답 헤더) 필드는 요청 완료 또는 새 리소스 식별을 위해 수신자를 Request-URI 이외의 위치로 리디렉션하는 데 사용됩니다. 201 (작성 됨) 응답의 경우 위치는 요청에 의해 작성된 새 자원의 위치입니다. 3xx 응답의 경우, 위치는 자원으로의 자동 재 지정을 위해 서버가 선호하는 URI를 표시해야한다. 필드 값은 단일 절대 URI로 구성됩니다. Location = &quot;Location&quot; &quot;:&quot;absoluteURI 예는 다음과 같습니다. Location : &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt; 참고 : Content-Location 헤더 필드 ( &lt;a href=&quot;#section-14.14&quot;&gt;섹션 14.14&lt;/a&gt;)는 Content-Location이 요청에 포함 된 엔티티의 원래 위치를 식별한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 모두에 대한 헤더 필드가 포함될 수 있습니다. 또한 일부 메소드의 캐시 요구 사항에 대해서는 &lt;a href=&quot;#section-13.10&quot;&gt;13.10 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">시청각 파일의 MIME 유형은 대부분 컨테이너 형식을 나타냅니다. 웹에서 가장 일반적인 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">The MOVE operation on a non-collection resource is the logical equivalent of a copy (COPY), followed by consistency maintenance processing, followed by a delete of the source, where all three actions are performed in a single operation. The consistency maintenance step allows the server to perform updates caused by the move, such as updating all URLs, other than the Request-URI that identifies the source resource, to point to the new destination resource. The Destination header MUST be present on all MOVE methods and MUST follow all COPY requirements for the COPY part of the MOVE method. All WebDAV-compliant resources MUST support the MOVE method. Support for the MOVE method does not guarantee the ability to move a resource to a particular destination. For example, separate programs may actually control different sets of resources on the same server. Therefore, it may not be possible to move a resource within a namespace that appears to belong to the same server. If a resource exists at the destination, the destination resource will be deleted as a side-effect of the MOVE operation, subject to the restrictions of the Overwrite header. This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwards 요청 헤더 필드는 TRACE ( &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; ) 및 OPTIONS ( &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; )와 함께 메커니즘을 제공합니다.) 요청을 다음 인바운드 서버로 전달할 수있는 프록시 또는 게이트웨이 수를 제한하는 방법. 이는 클라이언트가 미드 체인에서 실패하거나 루핑 된 것으로 보이는 요청 체인을 추적하려고 할 때 유용 할 수 있습니다. Max-Forwards = &quot;Max-Forwards&quot; &quot;:&quot;1 * DIGIT Max-Forwards 값은이 요청 메시지가 전달 될 수있는 남은 횟수를 나타내는 십진 정수입니다. Max-Forwards 헤더 필드를 포함하는 TRACE 또는 OPTIONS 요청의 각 프록시 또는 게이트웨이 수신자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야합니다. 수신 된 값이 0이면, 수신자는 요청을 전달해서는 안된다. 대신 최종 수신자로 응답해야합니다. 수신 된 Max-Forwards 값이 0보다 큰 경우전달 된 메시지는 업데이트 된 Max-Forwards 필드를 1만큼 감소한 값으로 포함해야합니다. Max-Forwards 헤더 필드는이 표준에 의해 정의 된 다른 모든 메소드와 해당 메소드 정의의 일부로 명시 적으로 언급되지 않은 확장 메소드에 대해서는 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">멤버 URI를 통해 클라이언트는 HTTP의 GET, PUT 및 DELETE 메소드를 사용하여 멤버 자원을 검색, 편집 및 삭제할 수 있습니다. 응모 자료는 Atom Entry 문서로 표시됩니다. 멤버 URI는 두 곳에 나타납니다. 아래 &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2에&lt;/a&gt; 설명 된대로 POST를 사용하여 리소스를 성공적으로 생성 한 후 Location 헤더에 반환 됩니다. 또한 &quot;feed&quot;링크 관계를 가진 atom : link 요소로 Collection Feed의 항목에 나타날 수 있습니다. 멤버 엔트리는 멤버 관계를 나타내는 &quot;edit&quot;의 링크 관계를 갖는 그러한 atom : link 요소를 포함해야한다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">메소드 토큰은 Request-URI로 식별 된 자원에서 수행 할 메소드를 나타냅니다. 이 방법은 대소 문자를 구분합니다. 방법 = &quot;옵션&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; | &quot;가져 오기&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;섹션 9.3&lt;/a&gt; | &quot;헤드&quot;; &lt;a href=&quot;#section-9.4&quot;&gt;섹션 9.4&lt;/a&gt; | &quot;게시하다&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; | &quot;PUT&quot;; &lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; | &quot;삭제&quot;; &lt;a href=&quot;#section-9.7&quot;&gt;섹션 9.7&lt;/a&gt; | &quot;TRACE&quot;; &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; | &quot;잇다&quot;; &lt;a href=&quot;#section-9.9&quot;&gt;섹션 9.9&lt;/a&gt; | extension-method extension-method = token 리소스가 허용하는 메소드 목록은 헤더 허용 필드 ( &lt;a href=&quot;#section-14.7&quot;&gt;섹션 14.7)&lt;/a&gt; 에서 지정할 수 있습니다.). 허용 된 메소드 세트가 동적으로 변경 될 수 있으므로 응답의 리턴 코드는 항상 메소드가 현재 자원에서 허용되는지 여부를 클라이언트에 알립니다. 오리진 서버는 메소드가 오리진 서버에 의해 알려져 있지만 요청 된 자원에 대해 허용되지 않은 경우 상태 코드 405 (Method Not Allowed)를 리턴해야하며, 메소드가 인식되지 않거나 오리진 서버에 의해 구현되지 않은 경우 501 (Not Implemented)을 리턴해야합니다. GET 및 HEAD 방법은 모든 범용 서버에서 지원해야합니다. 다른 모든 방법은 선택 사항입니다. 그러나 위의 방법을 구현하는 경우 반드시 &lt;a href=&quot;#section-9&quot;&gt;섹션 9에&lt;/a&gt; 지정된 것과 동일한 의미로 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONS 메소드는 Request-URI로 식별 된 요청 / 응답 체인에서 사용 가능한 통신 옵션에 대한 정보 요청을 나타냅니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하거나 리소스 검색을 시작하지 않고도 리소스 또는 서버의 기능과 관련된 옵션 및 / 또는 요구 사항을 결정할 수 있습니다. 이 방법에 대한 응답은 캐시 할 수 없습니다. OPTIONS 요청에 엔티티 본문 (Content-Length 또는 Transfer-Encoding이 있음으로 표시됨)이 포함 된 경우 미디어 유형은 반드시 Content-Type 필드로 표시해야합니다. 이 스펙이 그러한 본문에 대한 사용을 정의하지는 않지만 향후 HTTP 확장은 OPTIONS 본문을 사용하여 서버에서 더 자세한 조회를 할 수 있습니다.이러한 확장을 지원하지 않는 서버는 요청 본문을 버릴 수 있습니다. Request-URI가 별표 ( &quot;*&quot;) 인 경우 OPTIONS 요청은 특정 자원이 아닌 서버에 일반적으로 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 다르므로 &quot;*&quot;요청은 &quot;ping&quot;또는 &quot;no-op&quot;유형의 방법으로 만 유용합니다. 클라이언트가 서버의 기능을 테스트 할 수 있도록하는 것 이상은 없습니다. 예를 들어, 이는 HTTP / 1.1 준수 (또는 부족)에 대한 프록시를 테스트하는 데 사용될 수 있습니다. Request-URI가 별표가 아닌 경우 OPTIONS 요청은 해당 자원과 통신 할 때 사용 가능한 옵션에만 적용됩니다.200 응답은 서버에 의해 구현되고 해당 규격에 정의되지 않은 확장을 포함하여 해당 자원에 적용 할 수있는 선택적 기능을 나타내는 헤더 필드를 포함해야한다 (SHOULD). 응답 본문에는 통신 옵션에 대한 정보도 포함되어야한다 (SHOULD). 이러한 본문의 형식은이 사양에 의해 정의되지 않지만 향후 HTTP 확장으로 정의 될 수 있습니다. 콘텐츠 협상을 사용하여 적절한 응답 형식을 선택할 수 있습니다. 응답 본문이 포함되어 있지 않으면 응답에 필드 값이 &quot;0&quot;인 Content-Length 필드가 포함되어야합니다. Max-Forwards 요청 헤더 필드는 요청 체인의 특정 프록시를 대상으로하는 데 사용될 수 있습니다.프록시가 요청 전달이 허용 된 absoluteURI에서 OPTIONS 요청을 수신하면 프록시는 Max-Forwards 필드를 확인해야합니다. Max-Forwards 필드 값이 0 ( &quot;0&quot;)이면 프록시는 메시지를 전달해서는 안됩니다. 대신 프록시는 자체 통신 옵션으로 응답해야합니다. Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에는 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에는 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONS 메소드는 원래 서버 또는 중간 매개체에서 대상 자원에 사용 가능한 통신 옵션에 대한 정보를 요청합니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하지 않고 리소스 또는 서버의 기능과 관련된 옵션 및 / 또는 요구 사항을 결정할 수 있습니다. 별표 ( &quot;*&quot;)를 요청 대상으로 사용하는 OPTIONS 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 섹션 5.3&lt;/a&gt;)는 특정 리소스가 아닌 일반적으로 서버에 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 다르므로 &quot;*&quot;요청은 &quot;ping&quot;또는 &quot;no-op&quot;유형의 방법으로 만 유용합니다. 클라이언트가 서버의 기능을 테스트 할 수 있도록하는 것 이상은 없습니다. 예를 들어, 이것은 HTTP / 1.1 적합성 (또는 그 부족)에 대한 프록시를 테스트하는 데 사용될 수 있습니다. 요청 대상이 별표가 아닌 경우 OPTIONS 요청은 대상 자원과 통신 할 때 사용 가능한 옵션에 적용됩니다. OPTIONS에 대한 성공적인 응답을 생성하는 서버는 서버가 구현하고 대상 자원에 적용 가능한 선택적 기능 (예 : 허용)을 나타내는 헤더 필드를 보내야합니다.이 사양에서 정의하지 않은 잠재적 인 확장을 포함합니다. 응답 페이로드 (있는 경우)는 기계 또는 사람이 읽을 수있는 표현의 통신 옵션을 설명 할 수도 있습니다. 이러한 표현에 대한 표준 형식은이 사양에 의해 정의되지 않지만 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조).그러나 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조).그러나 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조). &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; ). 요청을 Max-Forwards 필드와 함께 수신하지 않는 한 프록시는 요청을 전달하는 동안 Max-Forwards 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 페이로드 본문을 포함하는 OPTIONS 요청을 생성하는 클라이언트는 표현 미디어 유형을 설명하는 유효한 Content-Type 헤더 필드를 보내야합니다. 이 스펙은 그러한 페이로드에 대한 사용을 정의하지 않지만, 향후 HTTP 확장은 OPTIONS 본문을 사용하여 대상 자원에 대한 자세한 조회를 작성할 수 있습니다. OPTIONS 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Opera 브라우저는 또한 깜박임 엔진을 기반으로하므로 거의 동일하게 보이지만 &quot;OPR / &amp;lt;version&amp;gt;&quot;을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">운영 체제는 대부분의 User Agent 문자열로 제공되지만 (Firefox OS와 같은 웹 중심 플랫폼은 아니지만) 형식은 많이 다릅니다. 사용자 에이전트의 주석 부분에서 두 개의 세미콜론 사이에 고정 문자열입니다. 이 문자열은 각 브라우저마다 다릅니다. OS뿐만 아니라 의존 하드웨어 (32 또는 64 비트 또는 Mac 용 Intel / PPC)에 대한 버전 및 정보도 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC 파일 이름은 proxy.pac입니다.</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 섹션의 PHP 스 니펫 (및 서버에 대한 JavaScript 호출) &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;은 여기에 게시 된 작업 코드 샘플&lt;/a&gt; 에서 가져옵니다 . 이들은 크로스 사이트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 구현하는 브라우저에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POST 메소드는 오리진 서버가 요청에 포함 된 엔티티를 요청 라인의 Request-URI에 의해 식별 된 자원의 새로운 하위 항목으로 승인하도록 요청하는 데 사용됩니다. POST는 균일 한 방법으로 다음 기능을 처리 할 수 ​​있도록 설계되었습니다.-기존 자원의 주석; -게시판, 뉴스 그룹, 메일 링리스트 또는 유사한 기사 그룹에 메시지 게시; -양식 제출 결과와 같은 데이터 블록을 데이터 처리 프로세스에 제공 -추가 작업을 통해 데이터베이스를 확장합니다. POST 방법으로 수행되는 실제 기능은 서버에 의해 결정되며 일반적으로 Request-URI에 따라 다릅니다. 게시 된 엔티티는 파일이 포함 된 디렉토리에 종속 된 것과 동일한 방식으로 해당 URI에 종속됩니다.뉴스 기사는 게시 된 뉴스 그룹에 종속되거나 레코드는 데이터베이스에 종속됩니다. POST 메소드에 의해 수행 된 조치로 인해 URI로 식별 할 수있는 자원이 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 원 서버에서 자원이 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 자원과 위치 헤더를 참조하는 엔티티를 포함해야합니다 (참조).이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 오리진 서버에서 리소스가 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 리소스 및 위치 헤더를 나타내는 엔터티를 포함해야합니다 (참조).이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 오리진 서버에서 리소스가 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 리소스 및 위치 헤더를 나타내는 엔터티를 포함해야합니다 (참조).&lt;a href=&quot;#section-14.30&quot;&gt;섹션 14.30&lt;/a&gt; ). 응답에 적절한 Cache-Control 또는 Expires 헤더 필드가 포함되어 있지 않으면이 방법에 대한 응답을 캐시 할 수 없습니다. 그러나 303 (기타 참조) 응답을 사용하여 사용자 에이전트가 캐시 가능한 자원을 검색하도록 지시 할 수 있습니다. POST 요청은 &lt;a href=&quot;#section-8.2&quot;&gt;섹션 8.2에&lt;/a&gt; 설정된 메시지 전송 요구 사항을 준수해야합니다 . 보안 고려 사항에 대해서는 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">POST 메소드는 대상 자원이 자원 고유의 의미에 따라 요청에 포함 된 표현을 처리하도록 요청합니다. 예를 들어 POST는 다음과 같은 기능에 사용됩니다. o HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공합니다. o 게시판, 뉴스 그룹, 메일 목록, 블로그 또는 유사한 기사 그룹에 메시지 게시; o 오리진 서버에 의해 아직 식별되지 않은 새로운 자원 작성; o 자원의 기존 표현에 데이터 추가. 오리진 서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 의미론을 표시합니다.이 사양에서 정의한 거의 모든 상태 코드는 POST에 대한 응답으로 수신 될 수 있습니다 (예외는 206 (부분 내용), 304 (수정되지 않음) 및 416 (범위가 만족스럽지 않음)). POST 요청을 성공적으로 처리 한 결과로 오리진 서버에서 하나 이상의 리소스가 생성 된 경우 오리진 서버는 생성 된 기본 리소스에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야합니다.오리진 서버는 생성 된 1 차 자원에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야한다.오리진 서버는 생성 된 1 차 자원에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야한다.&lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; ) 및 새로운 자원을 참조하면서 요청의 상태를 설명하는 표현. POST 요청에 대한 응답은 명시 적 최신 정보가 포함 된 경우에만 캐시 할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]의 섹션 4.2.1&lt;/a&gt; 참조 ). 그러나 POST 캐싱은 널리 구현되지 않았습니다. 오리진 서버가 클라이언트가 나중에 GET에 의해 재사용 될 수있는 방식으로 POST 결과를 캐시 할 수 있기를 원하는 경우, 오리진 서버는 결과와 Content-Location을 포함하는 200 (OK) 응답을 보낼 수 있습니다. POST의 유효 요청 URI와 동일한 값을 가진 헤더 필드 ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;3.1.4.2 절)&lt;/a&gt;). POST 처리 결과가 기존 자원의 표현과 동일한 경우, 원 서버는 Location 필드에 기존 자원의 식별자와 함께 303 (기타 참조) 응답을 전송하여 사용자 에이전트를 해당 자원으로 리디렉션 할 수 있습니다. 이는 사용자 에이전트가 이미 캐시 된 표현을 가지고 있지 않은 경우 추가 요청 비용으로 사용자 에이전트에 자원 식별자를 제공하고 공유 캐싱에 더 적합한 방법을 통해 표시를 전송하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">PROPFIND 메소드는 자원에 내부 구성원이없는 경우 Request-URI로 식별 된 자원 또는 자원이있는 콜렉션 인 경우 Request-URI 및 잠재적으로 해당 구성원 자원으로 식별 된 자원에 정의 된 특성을 검색합니다. 내부 회원 URL. 모든 DAV 호환 리소스는 반드시 PROPFIND 메소드와 propfind XML 요소를 지원해야합니다 ( &lt;a href=&quot;#section-14.20&quot;&gt;14.20 절).&lt;/a&gt;) 및 해당 요소와 함께 사용하도록 정의 된 모든 XML 요소와 함께. 클라이언트는 PROPFIND 요청과 함께 &quot;0&quot;, &quot;1&quot;또는 &quot;infinity&quot;값을 가진 깊이 헤더를 제출해야합니다. 서버는 WebDAV 호환 리소스에서 &quot;0&quot;및 &quot;1&quot;깊이 요청을 지원해야하며 &quot;무한대&quot;요청을 지원해야합니다. 실제로이 동작과 관련된 성능 및 보안 문제로 인해 무한 깊이 요청에 대한 지원이 비활성화 될 수 있습니다. 서버는 &quot;Depth : infinity&quot;헤더가 포함 된 것처럼 Depth 헤더가없는 요청을 처리해야합니다. 클라이언트는 어떤 정보가 요청되고 있는지를 설명하는 요청 메소드 본문에 'propfind'XML 요소를 제출할 수 있습니다. o 특정 속성 값 요청,'prop'요소 내에서 원하는 속성의 이름을 지정함으로써 (여기에서 속성 순서는 서버에서 무시 될 수 있음) o '이 사양에 정의 된 속성에 대한 속성 값 (최소한)과' allprop '요소 ('include '요소는'allprop '와 함께 사용하여 서버에 달리 리턴되지 않은 추가 라이브 특성도 포함하도록 지시 할 수 있음) o 자원에 정의 된 모든 특성의 이름 목록을 요청합니다. 'propname'요소를 사용하여 고객은 요청 본문을 제출하지 않도록 선택할 수 있습니다. 빈 PROPFIND 요청 본문은 마치 'allprop'요청 인 것처럼 처리해야합니다. 'allprop'는 모든 라이브 속성에 대한 값을 반환하지는 않습니다.WebDAV 서버는 점점 비싸거나 계산되는 속성이 점점 증가합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) 이미 모든 속성을 반환하지는 않습니다. 대신 WebDAV 클라이언트는 propname 요청을 사용하여 어떤 라이브 특성이 있는지 발견하고 값을 검색 할 때 이름 지정된 특성을 요청할 수 있습니다. 다른 곳에 정의 된 라이브 속성의 경우 해당 정의는 해당 라이브 속성이 'allprop'요청으로 반환되는지 여부를 지정할 수 있습니다. 모든 서버는 다양한 속성을 검색하려는 시도의 결과를 설명하는 다중 상태 XML 요소가 포함 된 콘텐츠 유형 text / xml 또는 application / xml의 응답 반환을 지원해야합니다. 특성을 검색하는 중에 오류가 발생하면 응답에 올바른 오류 결과가 포함되어야합니다. 존재하지 않는 속성 값을 검색하라는 요청은 오류이며 '응답'과 함께 표시되어야합니다.404 (찾을 수 없음) 상태 값이 포함 된 XML 요소 결과적으로 컬렉션 리소스에 대한 'multistatus'XML 요소는 요청 된 깊이에 따라 컬렉션의 각 멤버 URL에 대한 'response'XML 요소를 포함해야합니다. WebDAV를 준수하지 않는 리소스에 대한 '응답'요소를 포함하지 않아야합니다. 각 'response'요소는 prop XML 요소의 특성이 정의 된 자원의 URL을 포함하는 'href'요소를 포함해야합니다. 콜렉션 자원의 PROPFIND에 대한 결과는 항목 순서가 중요하지 않은 단순 목록으로 리턴됩니다. 리소스는 주어진 이름의 속성에 대해 하나의 값만 가질 수 있으므로 속성은 PROPFIND 응답에 한 번만 표시 될 수 있습니다.속성에 따라 액세스 제어가 적용될 수 있습니다. 'allprop'및 'propname'요청의 경우, 주체가 특정 속성이 존재하는지 알 수있는 권한이 없으면 속성이 응답에서 자동으로 제외 될 수 있습니다. 대부분의 속성에 대해 캐시 유효성 검사 메커니즘이 없으므로 일부 PROPFIND 결과는주의해서 캐시 될 수 있습니다. 이 방법은 안전하고 dem 등입니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCH 메소드는 Request-URI로 식별 된 자원에 정의 된 특성을 설정 및 / 또는 제거하기 위해 요청 본문에 지정된 명령을 처리합니다. 모든 DAV 호환 리소스는 반드시 PROPPATCH 메서드를 지원해야하며 propertyupdate, set 및 remove XML 요소를 사용하여 지정된 명령어를 처리해야합니다. 물론이 방법에서 지시문의 실행은 액세스 제어 제약 조건의 적용을받습니다. DAV 호환 리소스는 임의의 데드 속성 설정을 지원해야합니다 (SHOULD). PROPPATCH 메소드의 요청 메시지 본문에는 propertyupdate XML 요소가 포함되어야합니다. 서버는 문서 순서대로 PROPPATCH 명령어를 처리해야합니다 (주문과 관련이없는 일반적인 규칙은 예외). 명령어는 모두 실행되거나 실행되지 않아야합니다. 그러므로,처리 중에 오류가 발생하면 실행 된 모든 명령을 실행 취소하고 적절한 오류 결과를 반환해야합니다. 명령어 처리 세부 사항은 섹션의 정의 및 제거 명령어 정의에서 찾을 수 있습니다.&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 및 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . 서버가 PROPPATCH 요청에서 속성을 변경하려고 시도하는 경우 (즉, 본문을 처리하기 전에 높은 수준의 오류에 대한 요청이 거부되지 않음) 응답은 &lt;a href=&quot;#section-9.2.1&quot;&gt;섹션 9.2.1에&lt;/a&gt; 설명 된 다중 상태 응답이어야합니다. . 이 방법은 dem 등이지만 안전하지는 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]의 9.1 절&lt;/a&gt; 참조 ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUT 메소드는 동봉 된 엔티티가 제공된 Request-URI 아래에 저장되도록 요청합니다. Request-URI가 이미 존재하는 자원을 참조하는 경우 동봉 된 엔티티는 원본 서버에있는 수정 된 버전으로 간주해야합니다. Request-URI가 기존 자원을 가리 키지 않고 요청 사용자 에이전트가 해당 URI를 새 자원으로 정의 할 수있는 경우, 오리진 서버는 해당 URI로 자원을 작성할 수 있습니다. 새로운 리소스가 생성되면 오리진 서버는 반드시 201 (Created) 응답을 통해 사용자 에이전트에게 알려야합니다. 기존 자원이 수정되면 요청 완료를 표시하기 위해 200 (OK) 또는 204 (No Content) 응답 코드를 보내야합니다. Request-URI로 자원을 작성하거나 수정할 수없는 경우,문제의 본질을 반영하는 적절한 오류 응답이 제공되어야한다. 엔터티의 수신자는 이해하지 않거나 구현하지 않은 Content-* (예 : Content-Range) 헤더를 무시해서는 안되며 그러한 경우 501 (구현되지 않음) 응답을 반환해야합니다. 요청이 캐시를 통과하고 Request-URI가 현재 캐시 된 하나 이상의 엔티티를 식별하는 경우 해당 항목은 오래된 것으로 취급해야합니다. 이 방법에 대한 응답은 캐시 할 수 없습니다. POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 동봉 된 엔터티를 처리 할 리소스를 식별합니다. 이 리소스는 데이터 수락 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 허용하는 별도의 엔티티 일 수 있습니다.반대로 PUT 요청의 URI는 요청으로 둘러싸인 엔티티를 식별합니다. 사용자 에이전트는 의도 된 URI를 알고 있으며 서버는 요청을 다른 자원에 적용해서는 안됩니다. 서버가 요청이 다른 URI에 적용되기를 원하면 301 (영구적으로 이동) 응답을 보내야합니다. 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부에 대한 자체 결정을 내릴 수 있습니다. 단일 리소스는 여러 가지 URI로 식별 될 수 있습니다. 예를 들어, 기사에는 &quot;현재 버전&quot;을 식별하기위한 URI가있을 수 있으며, 이는 각 특정 버전을 식별하는 URI와 별개입니다. 이 경우 일반 URI에 대한 PUT 요청으로 인해 여러 다른 URI가 오리진 서버에 의해 정의 될 수 있습니다. HTTP / 1.1은 PUT 방법이 원본 서버의 상태에 미치는 영향을 정의하지 않습니다. PUT 요청은 메시지 전송 요구 사항을 준수해야합니다.&lt;a href=&quot;#section-8.2&quot;&gt;섹션 8.2&lt;/a&gt; . 특정 엔터티 헤더에 다르게 지정되지 않는 한 PUT 요청의 엔터티 헤더는 PUT에 의해 생성되거나 수정 된 리소스에 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUT 메소드는 대상 자원의 상태를 작성하거나 요청 메시지 페이로드에 포함 된 표현으로 정의 된 상태로 바꾸도록 요청합니다. 주어진 표현의 성공적인 PUT은 동일한 목표 자원에 대한 후속 GET이 200 (OK) 응답으로 동등한 표현이 전송됨을 시사합니다. 그러나 후속 GET을 수신하기 전에 대상 자원이 다른 사용자 에이전트에 의해 병렬로 처리되거나 오리진 서버에 의해 동적 처리 될 수 있기 때문에 이러한 상태 변경을 관찰 할 수 있다는 보장은 없습니다. 성공적인 응답은 사용자 에이전트의 의도가 원래 서버에 의해 처리 될 때 달성되었음을 나타냅니다.대상 자원에 현재 표현이없고 PUT이 성공적으로 작성하면, 원 서버는 반드시 201 (작성) 응답을 보내 사용자 에이전트에게 알려야합니다. 대상 자원에 현재 표현이 있고 해당 표현이 동봉 된 표현의 상태에 따라 성공적으로 수정 된 경우, 오리진 서버는 성공적인 완료를 표시하기 위해 200 (OK) 또는 204 (No Content) 응답을 보내야합니다. 요청. 오리진 서버는 PUT 요청에서 수신 된 인식 할 수없는 헤더 필드를 무시해야합니다 (즉, 자원 상태의 일부로 저장하지 마십시오). 오리진 서버는 PUT 표현이 PUT에 의해 변경 될 수 있거나 변경되지 않을 대상 자원에 대한 서버의 제한 조건과 일치하는지 확인해야합니다.이는 오리진 서버가 GET 응답에서 표시 메타 데이터의 값을 설정하기 위해 URI와 관련된 내부 구성 정보를 사용할 때 특히 중요합니다. PUT 표현이 목표 자원과 일치하지 않는 경우, 원 서버는 표현을 변환하거나 자원 구성을 변경하여 일관성을 유지하거나 표현이 적합하지 않은 이유를 설명하기에 충분한 정보를 포함하는 적절한 오류 메시지로 응답해야한다. 409 (충돌) 또는 415 (지원되지 않는 매체 유형) 상태 코드가 제안되며 후자는 컨텐츠 유형 값의 제한 사항에 따라 다릅니다. 예를 들어 대상 자원이 항상 &quot;text / html&quot;의 Content-Type을 갖도록 구성된 경우PUT 인 표현은 &quot;image / jpeg&quot;의 Content-Type을 가지며, 오리진 서버는 다음 중 하나를 수행해야합니다. 새 매체 유형을 반영하도록 대상 자원을 재구성하십시오. 비. PUT 표현을 새로운 자원 상태로 저장하기 전에 자원의 형식과 일치하는 형식으로 변환합니다. 또는 c. 대상 리소스가 &quot;text / html&quot;로 제한됨을 나타내는 415 (지원되지 않는 미디어 유형) 응답으로 요청을 거부합니다. 새 표현에 적합한 다른 리소스에 대한 링크를 포함 할 수도 있습니다. HTTP는 PUT 메소드가 사용자 에이전트 요청의 의도와 오리진 서버 응답의 의미로 표현할 수있는 것 이상으로 오리진 서버의 상태에 미치는 영향을 정확하게 정의하지 않습니다.HTTP를 통해 제공되는 인터페이스를 넘어 어떤 의미에서든 리소스가 무엇인지 정의하지 않습니다. 자원 상태가 &quot;저장된&quot;방법이나 자원 상태 변경의 결과로 이러한 스토리지가 어떻게 변경 될 수 있는지 또는 원본 서버가 자원 상태를 표현으로 변환하는 방법을 정의하지 않습니다. 일반적으로, 자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (&lt;a href=&quot;#section-7.2&quot;&gt;&lt;/a&gt;ETag 또는 Last-Modified 필드와 같은 섹션 7.2 )는 요청의 표현 데이터가 본문에 적용되는 변환없이 저장되지 않은 경우 (즉, 자원의 새로운 표현 데이터가 수신 된 표현 데이터와 동일하지 않은 경우) PUT에 대한 성공적인 응답 PUT 요청) 및 유효성 검사기 필드 값은 새로운 표현을 반영합니다. 이 요구 사항을 통해 사용자 에이전트는 메모리에있는 표시 본문이 PUT의 결과로 최신 상태를 유지하는 시점을 알 수 있으므로 원본 서버에서 다시 검색 할 필요가없고 응답에서 새 유효성 검증기 (들)를 수신해야합니다. 우발적 인 덮어 쓰기를 방지하기 위해 향후 조건부 요청에 사용할 수 있습니다 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt;). POST와 PUT 방법의 근본적인 차이점은 동봉 된 표현에 대한 다른 의도로 강조됩니다. POST 요청의 대상 자원은 자원 자체의 의미에 따라 동봉 된 표현을 처리하기위한 반면 PUT 요청의 동봉 된 표현은 대상 자원의 상태를 대체하는 것으로 정의됩니다. 따라서 PUT의 의도는 server 등원이며 중개자에게만 표시됩니다. 비록 정확한 효과는 원래 서버에서만 알 수 있습니다. PUT 요청의 올바른 해석은 사용자 에이전트가 원하는 대상 자원을 알고 있다고 가정합니다. 상태 변경 요청을 수신 한 후 클라이언트 대신 적절한 URI를 선택하는 서비스는 PUT이 아닌 POST 메소드를 사용하여 구현해야합니다.원 서버가 요청 된 PUT 상태를 대상 자원으로 변경하지 않고 자원이 다른 URI로 이동 된 경우와 같이 다른 자원에 적용하려면 원 서버는 적절한 3xx를 보내야합니다. (리다이렉션) 응답; 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부에 대한 자체 결정을 내릴 수 있습니다. 대상 자원에 적용된 PUT 요청은 다른 자원에 부작용이있을 수 있습니다. 예를 들어, 기사에는 각 특정 버전을 식별하는 URI (한 시점에서 현재 버전 리소스와 동일한 상태를 공유하는 다른 리소스)와는 다른 &quot;현재 버전&quot;(리소스)을 식별하기위한 URI가있을 수 있습니다. &quot;현재 버전&quot;에 대한 성공적인 PUT 요청따라서 URI는 대상 자원의 상태를 변경하는 것 외에도 새 버전 자원을 작성하고 관련 자원 사이에 링크를 추가 할 수도 있습니다. 주어진 대상 리소스에서 PUT을 허용하는 오리진 서버는 반드시 Content-Range 헤더 필드를 포함하는 PUT 요청에 400 (잘못된 요청) 응답을 보내야합니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;&lt;/a&gt;페이로드는 전체 표현으로 실수로 PUT 된 부분 내용 일 가능성이 있기 때문에 [RFC7233] 섹션 4.2 . 부분 콘텐츠 업데이트는 더 큰 리소스의 일부와 겹치는 상태로 개별적으로 식별 된 리소스를 대상으로하거나 부분 업데이트에 대해 특별히 정의 된 다른 방법 (예 : [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]에 정의 된 PATCH 방법 )을 사용하여 가능합니다. PUT 메소드에 대한 응답은 캐시 할 수 없습니다. 성공적인 PUT 요청이 유효 요청 URI에 대해 하나 이상의 저장된 응답이있는 캐시를 통과하면 저장된 응답이 무효화됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234] 4.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma 일반 헤더 필드는 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수있는 구현 별 지시문을 포함하는 데 사용됩니다. 모든 pragma 지시문은 프로토콜 관점에서 선택적 동작을 지정합니다. 그러나 일부 시스템에서는 동작이 지시문과 일치해야 할 수도 있습니다. Pragma = &quot;Pragma&quot; &quot;:&quot;1 # pragma-directive pragma-directive = &quot;no-cache&quot;| extension-pragma extension-pragma = token [ &quot;=&quot;(token | quoted-string)] 요청 메시지에 no-cache 지시문이 있으면 응용 프로그램은 캐시 된 사본이 있어도 요청을 원본 서버로 전달해야합니다 요청되는 내용 이 pragma 지시문은 no-cache 캐시 지시문과 동일한 의미를 갖습니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9 참조).&lt;/a&gt;) 및 HTTP / 1.0과의 호환성을 위해 여기에 정의되어 있습니다. 캐시없는 요청이 HTTP / 1.1 호환이 아닌 서버로 전송 될 때 클라이언트는 두 헤더 필드를 모두 포함해야합니다 (SHOULD). 지시문은 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 Pragma 지시문은 해당 응용 프로그램에 대한 중요성에 관계없이 프록시 또는 게이트웨이 응용 프로그램을 통해 전달되어야합니다. 특정 수신자에 대한 pragma를 지정할 수 없습니다. 그러나 수신자와 관련이없는 pragma 지시문은 해당 수신자가 무시해야합니다. HTTP / 1.1 캐시는 클라이언트가 &quot;Cache-Control : no-cache&quot;를 보낸 것처럼 &quot;Pragma : no-cache&quot;를 처리해야합니다. 새로운 Pragma 지시문은 HTTP에 정의되지 않습니다. 참고 : &quot;Pragma :응답 헤더 필드 인 no-cache는 실제로 지정되지 않으며 응답에서 &quot;Cache-Control : no-cache&quot;를 안정적으로 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">프록시 인증 응답 헤더 필드는 반드시 407 (프록시 인증 필요) 응답의 일부로 포함되어야합니다. 필드 값은이 Request-URI의 프록시에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 인증 확인으로 구성됩니다. Proxy-Authenticate = &quot;프록시 인증&quot; &quot;:&quot;1 # challenge HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 현재 연결에만 적용되며 다운 스트림 클라이언트에 전달해서는 안됩니다. 그러나 중간 프록시는 다운 스트림 클라이언트에서 요청하여 자체 신임 정보를 가져와야 할 수도 있습니다. 이는 일부 상황에서 프록시가 프록시 인증 헤더 필드를 전달하는 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorization request-header 필드는 클라이언트가 인증이 필요한 프록시에 자신 (또는 사용자)을 식별 할 수 있도록합니다. 프록시 인증 필드 값은 프록시에 대한 사용자 에이전트의 인증 정보 및 / 또는 요청되는 리소스 영역을 포함하는 자격 증명으로 구성됩니다. Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;:&quot;자격 증명 HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. 권한 부여와 달리 프록시 인증 헤더 필드는 프록시 인증 필드를 사용하여 인증이 필요한 다음 아웃 바운드 프록시에만 적용됩니다. 체인에서 여러 프록시를 사용하는 경우 프록시 인증 헤더 필드는 자격 증명을받을 것으로 예상되는 첫 번째 아웃 바운드 프록시에서 사용됩니다. 프록시가 프록시가 주어진 요청을 협력 적으로 인증하는 메커니즘 인 경우 프록시는 클라이언트 요청에서 다음 프록시로 자격 증명을 릴레이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Referer [sic] request-header 필드는 클라이언트가 서버의 이익을 위해 Request-URI를 얻은 자원의 주소 (URI)를 지정하도록합니다 (헤더 필드의 철자가 틀리더라도 &quot;참조 자&quot;). Referer request-header는 서버가 관심, 로깅, 최적화 된 캐싱 등을 위해 자원에 대한 백 링크 목록을 생성 할 수있게합니다. 또한 유지 보수를 위해 사용되지 않거나 잘못 입력 된 링크를 추적 할 수 있습니다. 사용자 키보드의 입력과 같이 고유 URI가없는 소스에서 Request-URI를 얻은 경우 Referer 필드를 보내서는 안됩니다 (MUST NOT). Referer = &quot;Referer&quot; &quot;:&quot;(absoluteURI | relativeURI) 예 : &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;참조 자&lt;/a&gt; : http://www.w3.org/hypertext/DataSources/Overview.html 필드 값이 상대 URI 인 경우 Request-URI를 기준으로 해석해야합니다. URI는 프래그먼트를 포함해서는 안됩니다. 보안 고려 사항에 대해서는 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Request-Line은 메소드 토큰으로 시작하고 Request-URI 및 프로토콜 버전이 뒤 따르며 CRLF로 끝납니다. 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다. 요청 라인 = 메소드 SP 요청 URI SP HTTP 버전 CRLF</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI는 Uniform Resource Identifier입니다 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2)&lt;/a&gt;) 및 요청을 적용 할 리소스를 식별합니다. Request-URI = &quot;*&quot;| absoluteURI | abs_path | 권한 Request-URI의 네 가지 옵션은 요청의 특성에 따라 다릅니다. 별표 &quot;*&quot;는 요청이 특정 자원이 아니라 서버 자체에 적용되고 사용 된 방법이 자원에 반드시 적용되지 않는 경우에만 허용됨을 의미합니다. 한 가지 예는 OPTIONS * HTTP / 1.1입니다. 요청이 프록시에 작성 될 때 absoluteURI 양식이 필요합니다. 프록시는 유효한 캐시에서 요청 또는 서비스를 전달하고 응답을 반환하도록 요청됩니다. 프록시는 요청을 다른 프록시 또는 absoluteURI에 의해 지정된 서버로 직접 전달할 수 있습니다. 요청 루프를 피하기 위해프록시는 별칭, 로컬 변형 및 숫자 IP 주소를 포함한 모든 서버 이름을 인식 할 수 있어야합니다. 요청 라인의 예는 다음과 같습니다. GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1 향후 HTTP 버전의 모든 요청에서 absoluteURI로 전환 할 수 있도록하려면 모든 HTTP / 1.1 서버는 요청에서 절대 URI 양식을 수락해야합니다. HTTP / 1.1 클라이언트는 프록시 요청에서만 클라이언트를 생성합니다. 권한 형식은 CONNECT 메소드에서만 사용됩니다 ( &lt;a href=&quot;#section-9.9&quot;&gt;9.9 절&lt;/a&gt; ). Request-URI의 가장 일반적인 형태는 오리진 서버 또는 게이트웨이에서 자원을 식별하는 데 사용됩니다. 이 경우 URI의 절대 경로를 전송해야합니다 ( &lt;a href=&quot;#section-3.2.1&quot;&gt;섹션 3.2.1&lt;/a&gt; 참조)., abs_path)를 Request-URI로, URI (권한)의 네트워크 위치는 호스트 헤더 필드로 전송해야합니다. 예를 들어, 오리진 서버에서 직접 위의 자원을 검색하려는 클라이언트는 &quot;www.w3.org&quot;호스트의 포트 80에 대한 TCP 연결을 작성하고 다음 행을 보냅니다. GET /pub/WWW/TheProject.html HTTP / 1.1 호스트 : www.w3.org 다음에 나머지 요청. 절대 경로는 비워 둘 수 없습니다. 원래 URI에 존재하지 않는 경우 반드시 &quot;/&quot;(서버 루트)로 지정해야합니다. Request-URI는 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1 &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;절에&lt;/a&gt; 명시된 형식으로 전송된다 . Request-URI가 &quot;% HEX HEX&quot;인코딩을 사용하여 인코딩 된 경우 [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], 오리진 서버는 요청을 올바르게 해석하기 위해 Request-URI를 디코딩해야합니다. 서버는 적절한 상태 코드로 유효하지 않은 Request-URI에 응답해야합니다. 투명 프록시는 수신 된 Request-URI를 다음 인바운드 서버로 전달할 때 널 abs_path를 &quot;/&quot;로 바꾸는 것을 제외하고는 수신 된 Request-URI의 &quot;abs_path&quot;부분을 다시 쓰지 않아야합니다. 참고 : &quot;다시 쓰기 금지&quot;규칙은 오리진 서버가 예약되지 않은 URI 문자를 예약 된 목적으로 잘못 사용하는 경우 프록시가 요청의 의미를 변경하지 못하게합니다. 구현자는 일부 HTTP / 1.1 이전 프록시가 Request-URI를 다시 쓰는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After response-header 필드는 503 (Service Unavailable) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수없는 시간을 나타냅니다. 이 필드는 3xx (리디렉션) 응답과 함께 사용되어 리디렉트 된 요청을 발행하기 전에 사용자 에이전트에게 대기 시간을 요청하는 최소 시간을 나타냅니다. 이 필드의 값은 응답 시간 후 HTTP 날짜 또는 정수 초 (10 진수) 일 수 있습니다. Retry-After = &quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds) 사용의 두 가지 예는 Retry-After입니다. Fri, 31 Dec 1999 23:59:59 GMT Retry-After : 120 후자 예를 들어, 지연 시간은 2 분입니다.</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">서버 응답 헤더 필드에는 요청을 처리하기 위해 오리진 서버가 사용하는 소프트웨어에 대한 정보가 있습니다. 이 필드에는 여러 제품 토큰 ( &lt;a href=&quot;#section-3.8&quot;&gt;섹션 3.8&lt;/a&gt; )과 서버 및 중요한 하위 제품을 식별하는 주석 이 포함될 수 있습니다 . 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다. 서버 = &quot;서버&quot; &quot;:&quot;1 * (product | comment) 예 : 서버 : CERN / 3.0 libwww / 2.17 프록시를 통해 응답이 전달되는 경우 프록시 응용 프로그램은 서버 응답 헤더를 수정해서는 안됩니다. 대신, Via 필드를 포함해야합니다 ( &lt;a href=&quot;#section-14.45&quot;&gt;섹션 14.45에&lt;/a&gt; 설명되어 있음)). 참고 : 서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 서버 구현자는이 필드를 구성 가능한 옵션으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code 요소는 요청을 이해하고 만족시키기위한 3 자리 정수 결과 코드입니다. 이 코드는 &lt;a href=&quot;#section-10&quot;&gt;섹션 10에&lt;/a&gt; 완전히 정의되어 있습니다.. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기위한 것입니다. Status-Code는 오토마타에서 사용하기위한 것이며 Reason-Phrase는 사용자를위한 것입니다. 클라이언트는 이유 문구를 조사하거나 표시 할 필요가 없습니다. Status-Code의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다.-1xx : 정보-요청 수신, 프로세스 계속-2xx : 성공-조치가 성공적으로 수신, 이해 및 승인되었습니다.-3xx : 경로 재 지정-요청을 완료하려면 추가 조치를 수행해야합니다. -4xx : 클라이언트 오류-요청에 잘못된 구문이 포함되어 있거나 이행 할 수 없습니다-5xx :서버 오류-서버가 명백히 유효한 요청을 이행하지 못했습니다. HTTP / 1.1에 대해 정의 된 숫자 상태 코드의 개별 값 및 해당하는 이유 문구의 예가 아래에 나와 있습니다. 여기에 나열된 이유 문구는 권장 사항 일뿐입니다. 프로토콜에 영향을주지 않으면 서 해당하는 문구로 대체 할 수 있습니다. 상태 코드 = &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;섹션 10.1.1&lt;/a&gt; : 계속 | &quot;101&quot;; &lt;a href=&quot;#section-10.1.2&quot;&gt;섹션 10.1.2&lt;/a&gt; : 스위칭 프로토콜 | &quot;200&quot;; &lt;a href=&quot;#section-10.2.1&quot;&gt;섹션 10.2.1&lt;/a&gt; : 확인 | &quot;201&quot;; &lt;a href=&quot;#section-10.2.2&quot;&gt;섹션 10.2.2&lt;/a&gt; : 작성 | &quot;202&quot;; &lt;a href=&quot;#section-10.2.3&quot;&gt;섹션 10.2.3&lt;/a&gt; : 허용 | &quot;203&quot;; &lt;a href=&quot;#section-10.2.4&quot;&gt;섹션 10.2.4&lt;/a&gt; : 신뢰할 수없는 정보 | &quot;204&quot;; &lt;a href=&quot;#section-10.2.5&quot;&gt;섹션 10.2.5&lt;/a&gt; : 내용 없음 | &quot;205&quot;; &lt;a href=&quot;#section-10.2.6&quot;&gt;섹션 10.2.6&lt;/a&gt; : 내용 재설정 | &quot;206&quot;; &lt;a href=&quot;#section-10.2.7&quot;&gt;섹션 10.2.7&lt;/a&gt; : 부분 내용 | &quot;300&quot;; &lt;a href=&quot;#section-10.3.1&quot;&gt;섹션 10.3.1&lt;/a&gt; : 다중 선택 | &quot;301&quot;; &lt;a href=&quot;#section-10.3.2&quot;&gt;섹션 10.3.&lt;/a&gt;2 : 영구적으로 움직였다 | &quot;302&quot;;&lt;a href=&quot;#section-10.3.3&quot;&gt;섹션 10.3.3&lt;/a&gt; : 발견 | &quot;303&quot;; &lt;a href=&quot;#section-10.3.4&quot;&gt;섹션 10.3.4&lt;/a&gt; : 기타 | &quot;304&quot;; &lt;a href=&quot;#section-10.3.5&quot;&gt;섹션 10.3.5&lt;/a&gt; : 수정되지 않음 | &quot;305&quot;; &lt;a href=&quot;#section-10.3.6&quot;&gt;섹션 10.3.6&lt;/a&gt; : 프록시 사용 | &quot;307&quot;; &lt;a href=&quot;#section-10.3.8&quot;&gt;섹션 10.3.8&lt;/a&gt; : 임시 리디렉션 | &quot;400&quot;; &lt;a href=&quot;#section-10.4.1&quot;&gt;섹션 10.4.1&lt;/a&gt; : 잘못된 요청 | &quot;401&quot;; &lt;a href=&quot;#section-10.4.2&quot;&gt;섹션 10.4.2&lt;/a&gt; : 무단 | &quot;402&quot;; &lt;a href=&quot;#section-10.4.3&quot;&gt;섹션 10.4.3&lt;/a&gt; : 지불 필요 | &quot;403&quot;; &lt;a href=&quot;#section-10.4.4&quot;&gt;섹션 10.4.4&lt;/a&gt; : 금지 | &quot;404&quot;; &lt;a href=&quot;#section-10.4.5&quot;&gt;섹션 10.4.5&lt;/a&gt; : 찾을 수 없음 | &quot;405&quot;; &lt;a href=&quot;#section-10.4.6&quot;&gt;섹션 10.4.6&lt;/a&gt; :허용되지 않는 방법 | &quot;406&quot;; &lt;a href=&quot;#section-10.4.7&quot;&gt;섹션 10.4.7&lt;/a&gt;: 허용되지 않음 | &quot;407&quot;; &lt;a href=&quot;#section-10.4.8&quot;&gt;섹션 10.4.8&lt;/a&gt; : 프록시 인증 필요 | &quot;408&quot;; &lt;a href=&quot;#section-10.4.9&quot;&gt;섹션 10.4.9&lt;/a&gt; : 요청 시간 초과 | &quot;409&quot;; &lt;a href=&quot;#section-10.4.10&quot;&gt;섹션 10.4.10&lt;/a&gt; : 충돌 | &quot;410&quot;; &lt;a href=&quot;#section-10.4.11&quot;&gt;섹션 10.4.11&lt;/a&gt; : 사라짐 | &quot;411&quot;; &lt;a href=&quot;#section-10.4.12&quot;&gt;섹션 10.4.12&lt;/a&gt; : 필요한 길이 | &quot;412&quot;; &lt;a href=&quot;#section-10.4.13&quot;&gt;섹션 10.4.13&lt;/a&gt; : 전제 조건 실패 | &quot;413&quot;; &lt;a href=&quot;#section-10.4.14&quot;&gt;섹션 10.4.14&lt;/a&gt; : 요청 엔티티가 너무 큼 | &quot;414&quot;; &lt;a href=&quot;#section-10.4.15&quot;&gt;섹션 10.4.15&lt;/a&gt; : 요청 URI가 너무 큼 | &quot;415&quot;; &lt;a href=&quot;#section-10.4.16&quot;&gt;섹션 10.4.16&lt;/a&gt; : 지원되지 않는 미디어 유형 | &quot;416&quot;;&lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt;: 요청 된 범위를 충족시킬 수 없음 | &quot;417&quot;; &lt;a href=&quot;#section-10.4.18&quot;&gt;섹션 10.4.18&lt;/a&gt; : 예상 실패 | &quot;500&quot;; &lt;a href=&quot;#section-10.5.1&quot;&gt;섹션 10.5.1&lt;/a&gt; : 내부 서버 오류 | &quot;501&quot;; &lt;a href=&quot;#section-10.5.2&quot;&gt;섹션 10.5.2&lt;/a&gt; : 구현되지 않음 | &quot;502&quot;; &lt;a href=&quot;#section-10.5.3&quot;&gt;섹션 10.5.3&lt;/a&gt; : 잘못된 게이트웨이 | &quot;503&quot;; &lt;a href=&quot;#section-10.5.4&quot;&gt;섹션 10.5.4&lt;/a&gt; : 사용할 수없는 서비스 | &quot;504&quot;; &lt;a href=&quot;#section-10.5.5&quot;&gt;섹션 10.5.5&lt;/a&gt; : 게이트웨이 시간 초과 | &quot;505&quot;; &lt;a href=&quot;#section-10.5.6&quot;&gt;섹션 10.5.6&lt;/a&gt;: HTTP 버전이 지원되지 않습니다 | extension-code extension-code = 3DIGIT 이유-구문 = * &amp;lt;TEXT, CR, LF 제외&amp;gt; HTTP 상태 코드는 확장 가능합니다. HTTP 애플리케이션은 등록 된 모든 상태 코드의 의미를 이해할 필요는 없지만, 그러한 이해는 분명히 바람직합니다. 그러나 응용 프로그램은 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해해야하며 인식 할 수없는 응답을 캐시해서는 안된다는 점을 제외하고 인식 할 수없는 응답을 해당 클래스의 x00 상태 코드와 동등한 것으로 처리해야합니다. 예를 들어, 클라이언트가 인식 할 수없는 상태 코드 431을 수신하면 요청에 문제가 있다고 가정하고 응답을 400 상태 코드를 수신 한 것처럼 처리 할 수 ​​있습니다. 그런 경우는,사용자 에이전트는 사용자에게 응답과 함께 반환 된 개체를 사용자에게 제공해야합니다. 그 개체는 사람이 읽을 수있는 정보를 포함하여 비정상 상태를 설명 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP 핸드 셰이크 자체는 시간이 많이 걸리지 만 TCP 연결은로드에 적응하여보다 지속적이거나 따뜻한 연결로보다 효율적입니다. 수명이 짧은 연결은 TCP의 이러한 효율성 기능을 사용하지 않으며 새로운 콜드 연결을 통해 전송을 지속함으로써 성능이 최적에서 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE 요청 헤더 필드는 응답에서 수락 할 확장 전송 코딩 및 청크 전송 코딩에서 트레일러 필드를 허용 할 것인지 여부를 나타냅니다. 값은 &quot;트레일러&quot;키워드 및 / 또는 선택적 수락 매개 변수가있는 쉼표로 구분 된 확장 전송 코드화 이름 목록 &lt;a href=&quot;#section-3.6&quot;&gt;(3.6 절 참조&lt;/a&gt; )으로 구성 될 수 있습니다. TE = &quot;TE&quot; &quot;:&quot;# (t-codings) t-codings = &quot;트레일러&quot;| (transfer-extension [accept-params]) 키워드 &quot;트레일러&quot;가 있으면 &lt;a href=&quot;#section-3.6.1&quot;&gt;섹션 3.6.1에&lt;/a&gt; 정의 된대로 클라이언트가 청크 분할 전송 코딩에서 트레일러 필드를 허용 할 것임을 나타냅니다.. 이 키워드는 자체적으로 전송 코딩을 나타내지 않더라도 전송 코딩 값과 함께 사용하도록 예약되어 있습니다. TE : deflate TE : TE : 트레일러, deflate; q = 0.5 TE 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 키워드는 반드시 연결 헤더 필드 내에 제공해야합니다 ( &lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10).&lt;/a&gt;TE가 HTTP / 1.1 메시지에 존재할 때마다). 서버는 TE 필드에 따라 다음 규칙을 사용하여 전송 코딩이 허용되는지 테스트합니다. 1. &quot;청크 된&quot;전송 코딩이 항상 허용됩니다. &quot;트레일러&quot;라는 키워드가 나열되면 클라이언트는 자신과 다운 스트림 클라이언트를 대신하여 청크 응답에서 트레일러 필드를 수락 할 의사가 있음을 나타냅니다. 의미가 주어진 경우, 클라이언트는 모든 다운 스트림 클라이언트가 전달 된 응답에서 트레일러 필드를 기꺼이 수락하거나 다운 스트림 수신자를 대신하여 응답을 버퍼링하려고 시도한다는 의미입니다. 참고 : HTTP / 1.도 1은 클라이언트가 전체 응답을 버퍼링 할 수 있도록 청크 응답의 크기를 제한하는 수단을 정의하지 않는다. 2. 테스트중인 전송 코딩이 TE 필드에 나열된 전송 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&lt;a href=&quot;#section-3.9&quot;&gt;섹션 3.9&lt;/a&gt; 에서 q 값이 0이면 &quot;허용되지 않습니다&quot;를 의미합니다. 3. 다중 전송 코딩이 허용되는 경우 0이 아닌 q 값이 가장 높은 허용 전송 코딩이 선호됩니다. &quot;청크 된&quot;전송 코딩의 q 값은 항상 1입니다. TE 필드 값이 비어 있거나 TE 필드가없는 경우 유일한 전송 코딩은 &quot;청크&quot;됩니다. 전송 코딩이없는 메시지는 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACE 메소드는 요청 메시지의 원격 애플리케이션 계층 루프백을 호출하는 데 사용됩니다. 요청의 최종 수신자는 200 (OK) 응답의 엔티티 본문으로 클라이언트에 수신 된 메시지를 반영해야한다. 최종 수신자는 원래 서버이거나 요청에서 Max-Forwards 값을 0으로받는 첫 번째 프록시 또는 게이트웨이입니다 &lt;a href=&quot;#section-14.31&quot;&gt;(14.31 절&lt;/a&gt; 참조 ). TRACE 요청은 엔티티를 포함해서는 안됩니다. TRACE를 사용하면 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을보고 해당 데이터를 테스트 또는 진단 정보로 사용할 수 있습니다. Via 헤더 필드의 값 ( &lt;a href=&quot;#section-14.45&quot;&gt;섹션 14.45&lt;/a&gt;)는 요청 체인의 추적 역할을하기 때문에 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한 할 수 있습니다. 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다. 요청이 유효하다면, 응답은 &quot;message / http&quot;의 Content-Type과 함께 엔티티 본문에 전체 요청 메시지를 포함해야한다. 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACE 메소드는 요청 메시지의 원격 애플리케이션 레벨 루프백을 요청합니다. 메시지를 반영해야한다 요청의 최종 수신자는 일부 필드는 다시 &quot;메시지 / http&quot;의 Content-Type (와 응답 200 (OK)의 메시지 본문으로 클라이언트에, 아래에 설명 제외한받은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;제 8.3.1 [RFC7230]&lt;/a&gt; ). 최종 수신자는 원래 서버이거나 요청에서 Max-Forwards 값을 영 (0)으로받는 첫 번째 서버입니다 ( &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; ). 클라이언트는 응답에 의해 공개 될 수있는 민감한 데이터를 포함하는 TRACE 요청에서 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 예를 들어, 사용자 에이전트가 저장된 사용자 자격 증명 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] 또는 쿠키 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; 를 보내는 것은 어리석은 일입니다.]를 TRACE 요청에서 요청의 최종 수신자는 수신자가 응답 본문을 생성 할 때 민감한 데이터를 포함 할 가능성이있는 요청 헤더 필드를 제외해야합니다. TRACE를 사용하면 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을보고 해당 데이터를 테스트 또는 진단 정보로 사용할 수 있습니다. Via 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]의 섹션 5.7.1)의&lt;/a&gt; 값은 요청 체인의 추적으로 작동하므로 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한 할 수 있습니다. 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다. 클라이언트는 TRACE 요청으로 메시지 본문을 보내서는 안됩니다. TRACE 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">예고편 일반 필드 값은 주어진 헤더 필드 세트가 청크 전송 코드로 인코딩 된 메시지 예고편에 있음을 나타냅니다. Trailer = &quot;Trailer&quot; &quot;:&quot;1 # field-name HTTP / 1.1 메시지는 비어 있지 않은 트레일러와 함께 청크 분할 전송 코딩을 사용하는 메시지에 트레일러 헤더 필드를 포함해야합니다. 그렇게하면 수신자는 예고편에서 어떤 헤더 필드를 기대할 수 있는지 알 수 있습니다. 트레일러 헤더 필드가 없으면 트레일러는 헤더 필드를 포함하지 않아야합니다. &quot;청크 (chunked)&quot;전송 코딩에서 트레일러 필드 사용에 대한 제한 사항은 &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1 섹션을&lt;/a&gt; 참조하십시오 . 트레일러 헤더 필드에 나열된 메시지 헤더 필드에는 다음 헤더 필드가 포함되어서는 안됩니다. 전송 인코딩. 콘텐츠 길이.트레일러</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">전송 인코딩 일반 헤더 필드는 발신자와 수신자간에 안전하게 전송하기 위해 메시지 본문에 적용된 변환 유형 (있는 경우)을 나타냅니다. 이는 전송 코딩이 엔티티가 아닌 메시지의 속성이라는 점에서 컨텐츠 코딩과 다릅니다. 전송 인코딩 = &quot;전송 인코딩&quot; &quot;:&quot;1 # 전송 인코딩 전송 코딩은 &lt;a href=&quot;#section-3.6&quot;&gt;3.6 절&lt;/a&gt; 에서 정의됩니다.. 예를 들면 다음과 같습니다. Transfer-Encoding : chunked 엔터티에 여러 인코딩이 적용된 경우 전송 코딩은 적용된 순서대로 나열되어야합니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 엔터티 헤더 필드에서 제공 될 수 있습니다. 많은 이전 HTTP / 1.0 응용 프로그램은 Transfer-Encoding 헤더를 이해하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encoding 헤더 필드는 메시지 본문을 형성하기 위해 페이로드 본문에 적용되었거나 적용되는 전송 코딩 시퀀스에 해당하는 전송 코딩 이름을 나열합니다. 전송 코딩은 &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의되어 있습니다. Transfer-Encoding = 1 # transfer-coding Transfer-Encoding은 7 비트 전송 서비스를 통해 이진 데이터를 안전하게 전송하도록 설계된 MIME의 Content-Transfer-Encoding 필드와 유사합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], 섹션 6&lt;/a&gt;). 그러나 안전한 전송에는 8 비트 클린 전송 프로토콜에 대한 초점이 다릅니다. HTTP의 경우, Transfer-Encoding은 기본적으로 동적으로 생성 된 페이로드를 정확하게 구분하고 전송 효율성 또는 보안에만 적용되는 페이로드 인코딩을 선택된 리소스의 특성과 구별하기위한 것입니다. 수신자는 청크 전송 코드를 구문 분석 할 수 있어야합니다 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt;)는 페이로드 본문 크기를 미리 알 수 없을 때 메시지 프레이밍에 결정적인 역할을하기 때문입니다. 발신자는 메시지 본문에 두 번 이상 청크를 적용해서는 안됩니다 (즉, 이미 청크 된 메시지 청크는 허용되지 않음). 청크 이외의 전송 코딩이 요청 페이로드 본문에 적용되는 경우, 송신자는 메시지가 올바르게 프레임되도록하기 위해 최종 전송 코딩으로 청크를 적용해야합니다. 청크 이외의 전송 코딩이 응답 페이로드 본문에 적용되는 경우, 송신자는 최종 전송 코딩으로 청크를 적용하거나 연결을 닫아 메시지를 종료해야합니다. 예를 들어, Transfer-Encoding : gzip, chunked는 페이로드 본문이 gzip 코딩을 사용하여 압축 된 다음 메시지 본문을 형성하는 동안 청크 된 코딩을 사용하여 청크되었음을 나타냅니다.콘텐츠 인코딩과 달리&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]의 3.1.2.1 항에서&lt;/a&gt; , Transfer-Encoding은 표현이 아닌 메시지의 속성이며, 요청 / 응답 체인을 따르는 수신자는 수신 된 전송 코딩을 디코딩하거나 추가 전송 코딩을 적용 할 수 있습니다. )는 전송 인코딩 필드 값에 해당 변경이 있다고 가정하고 메시지 본문에 적용됩니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 헤더 필드에서 제공 할 수 있습니다. 전송 인코딩은 HEAD 요청에 대한 응답 또는 304 (수정되지 않음) 응답으로 전송 될 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]의 4.1 항&lt;/a&gt; ))는 요청이 무조건적인 GET 인 경우, 오리진 서버가 메시지 본문에 전송 코딩을 적용했음을 표시하기 위해 메시지 본문을 포함하지 않는 GET 요청에 대해. 그러나 응답 체인 (원본 서버 포함)의 모든 수신자가 필요하지 않은 전송 코딩을 제거 할 수 있으므로이 표시는 필요하지 않습니다. 서버는 상태 코드가 1xx (정보) 또는 204 (콘텐츠 없음) 인 응답으로 Transfer-Encoding 헤더 필드를 보내서는 안됩니다. 서버는 2xx (성공) 응답의 Transfer-Encoding 헤더 필드를 CONNECT 요청에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;보내서는 안됩니다 ([RFC7231]의 4.3.6 절).&lt;/a&gt;). 전송 인코딩이 HTTP / 1.1에 추가되었습니다. 일반적으로 HTTP / 1.0 지원 만 광고하는 구현은 전송 인코딩 된 페이로드를 처리하는 방법을 이해하지 못한다고 가정합니다. 클라이언트가 서버가 HTTP / 1.1 (이상) 요청을 처리 할 것이라는 것을 알지 않는 한, 클라이언트는 Transfer-Encoding을 포함하는 요청을 보내서는 안됩니다. 이러한 지식은 특정 사용자 구성의 형태이거나 이전에 수신 된 응답의 버전을 기억함으로써 이루어질 수 있습니다. 해당 요청이 HTTP / 1.1 이상을 나타내지 않는 한 서버는 Transfer-Encoding을 포함하는 응답을 보내서는 안됩니다. 전송 코딩으로 요청 메시지를 수신하는 서버는 501 (구현되지 않음)로 응답해야한다는 것을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">TLS (Transport Layer Security) 프로토콜 버전 1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">TLS (Transport Layer Security) 프로토콜 버전 1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Firefox 자체의 UA 문자열은 다음과 같은 네 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCK 메소드는 잠금 토큰 요청 헤더에서 잠금 토큰으로 식별 된 잠금을 제거합니다. Request-URI는 잠금 범위 내에서 리소스를 식별해야합니다. 잠금 토큰을 제공하기 위해 잠금 토큰 헤더를 사용하는 것은 잠금 상태가있는 If 헤더가 필요한 다른 상태 변경 방법과 일치하지 않습니다. 따라서 If 헤더는 잠금 토큰을 제공하는 데 필요하지 않습니다. 당연히 If 헤더가 있으면 조건부 헤더로서 정상적인 의미를 갖습니다. 이 방법에 성공적으로 응답하려면 서버는 반드시 잠금을 완전히 삭제해야합니다. 제출 된 잠금 토큰으로 잠긴 모든 자원을 잠금 해제 할 수 없으면 UNLOCK 요청이 실패해야합니다. UNLOCK 방법에 대한 응답이 리소스가 반드시 잠금 해제되어 있다는 것을 의미하지는 않습니다.지정된 토큰에 해당하는 특정 잠금이 더 이상 존재하지 않음을 의미합니다. LOCK 방법을 지원하는 DAV 호환 리소스는 반드시 UNLOCK 방법을 지원해야합니다. 이 방법은 dem 등이지만 안전하지는 않습니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">위반이 발생한 문서의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">콘텐츠 보안 정책에 의해로드가 차단 된 리소스의 URI입니다. 차단 된 URI가 document-uri와 다른 출처에서 온 경우 차단 된 URI는 체계, 호스트 및 포트만 포함하도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">클라이언트가 요청한 URI가 서버가 해석하려는 것보다 깁니다.</target>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;http://example.com/&lt;/code&gt; 은 &lt;code&gt;http://www.example.com/&lt;/code&gt; 으로 리디렉션 되며 그 아래 파일이나 디렉토리 ( &lt;code&gt;http://example.com/index.html&lt;/code&gt; ) 는 &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; 로 리디렉션됩니다 : //www.example.com/index.html )</target>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">액세스중인 URL입니다. &lt;code&gt;https://&lt;/code&gt; URL 의 경로 및 쿼리 구성 요소 가 제거되었습니다. Chrome에서는 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 이를 비활성화 할 수 있습니다 . Firefox에서는 환경 설정이 &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">업그레이드 일반 헤더를 사용하면 클라이언트가 지원하는 추가 통신 프로토콜을 지정하고 서버가 프로토콜 전환에 적합한 것으로 판단 할 경우 사용할 프로토콜을 지정할 수 있습니다. 서버는 101 (Switching Protocols) 응답 내에서 Upgrade header 필드를 사용하여 전환중인 프로토콜을 표시해야합니다. Upgrade = &quot;Upgrade&quot; &quot;:&quot;1 # product 예 : Upgrade : HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 Upgrade 헤더 필드는 HTTP / 1.1에서 일부로의 전환을위한 간단한 메커니즘을 제공하기위한 것입니다. 다른 호환되지 않는 프로토콜. 현재 요청이 HTTP / 1.1을 사용하여 이루어 졌더라도 클라이언트가 주 버전 번호가 더 높은 이후 버전의 HTTP와 같은 다른 프로토콜을 사용하려는 의사를 알릴 수 있습니다.이렇게하면 클라이언트가 더 일반적으로 지원되는 프로토콜로 요청을 시작하는 동시에 서버에 &quot;더 나은&quot;프로토콜을 사용하고 싶다는 표시를함으로써 (예 : &quot;더 나은&quot;서버에 의해 결정됨) 호환되지 않는 프로토콜 간 어려운 전환이 쉬워집니다. 요청 된 방법 및 / 또는 자원의 특성에 따라). 업그레이드 헤더 필드는 기존 전송 계층 연결시 응용 프로그램 계층 프로토콜 전환에만 적용됩니다. 프로토콜 변경을 주장하는 데 업그레이드를 사용할 수 없습니다. 서버에 의한 승인 및 사용은 선택 사항입니다. 프로토콜 변경 후 애플리케이션 계층 통신의 기능과 특성은 전적으로 선택한 새로운 프로토콜에 따라 달라집니다.프로토콜을 변경 한 후 첫 번째 조치는 반드시 업그레이드 헤더 필드를 포함하는 초기 HTTP 요청에 대한 응답이어야합니다. 업그레이드 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 업그레이드 키워드는 반드시 연결 헤더 필드 (&lt;a href=&quot;#section-14.10&quot;&gt;&lt;/a&gt;HTTP / 1.1 메시지에 업그레이드가있을 때마다 14.10 절 . 업그레이드 헤더 필드는 다른 연결에서 프로토콜로의 전환을 나타내는 데 사용할 수 없습니다. 이를 위해서는 301, 302, 303 또는 305 리디렉션 응답을 사용하는 것이 더 적합합니다. 이 사양은 &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; 의 HTTP 버전 규칙 과이 사양에 대한 향후 업데이트에 정의 된 하이퍼 텍스트 전송 프로토콜 제품군에서 사용할 프로토콜 이름 &quot;HTTP&quot;만 정의합니다 . 프로토콜 이름으로 모든 토큰을 사용할 수 있습니다. 그러나 클라이언트와 서버가 이름을 동일한 프로토콜과 연관시키는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">User-Agent ( &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; ), Via ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]의 섹션 5.7.1&lt;/a&gt; ) 및 Server ( &lt;a href=&quot;#section-7.4.2&quot;&gt;섹션 7.4.2&lt;/a&gt; ) 헤더 필드는 종종 각 발신자의 소프트웨어 시스템에 대한 정보를 표시합니다. 이론적으로 이것은 공격자가 알려진 보안 취약점을 쉽게 악용 할 수 있도록합니다. 실제로 공격자는 사용중인 명백한 소프트웨어 버전에 관계없이 모든 잠재적 인 허점을 시도하는 경향이 있습니다. 네트워크 방화벽을 통해 포털 역할을하는 프록시는 방화벽 뒤의 호스트를 식별 할 수있는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야합니다. Via 헤더 필드를 통해 중개자는 민감한 기계 이름을 가명으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">User-Agent request-header 필드는 요청을 시작한 사용자 에이전트에 대한 정보를 포함합니다. 이는 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하기 위해 통계 목적, 프로토콜 위반 추적 및 사용자 에이전트 자동 인식입니다. 사용자 에이전트는이 필드를 요청과 함께 포함해야합니다. 이 필드에는 여러 제품 토큰 ( &lt;a href=&quot;#section-3.8&quot;&gt;섹션 3.8&lt;/a&gt; )과 에이전트 및 사용자 에이전트의 중요한 부분을 구성하는 하위 제품을 식별하는 주석 이 포함될 수 있습니다 . 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다. User-Agent = &quot;User-Agent&quot; &quot;:&quot;1 * (product | comment) 예 : User-Agent : CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Vary 필드 값은 응답이 최신 인 동안 캐시가 응답을 사용하여 재확인없이 후속 요청에 응답 할 수 있는지 여부를 완전히 결정하는 요청 헤더 필드 세트를 나타냅니다. 캐시 할 수 없거나 부실한 응답의 경우 Vary 필드 값은 사용자 에이전트에게 표시를 선택하는 데 사용 된 기준을 알려줍니다. Vary 필드 값 &quot;*&quot;는 캐시가 후속 요청의 요청 헤더에서이 응답이 적절한 표현인지 확인할 수 없음을 의미합니다. &lt;a href=&quot;#section-13.6&quot;&gt;섹션 13.6&lt;/a&gt; 참조 Vary 헤더 필드를 캐시에 사용합니다. Vary = &quot;Vary&quot; &quot;:&quot;( &quot;*&quot;| 1 # field-name) HTTP / 1.1 서버는 서버 주도 협상의 대상이되는 캐시 가능한 응답을 갖는 Vary 헤더 필드를 포함해야합니다. 이렇게하면 캐시가 해당 리소스에 대한 향후 요청을 올바르게 해석하고 해당 리소스에 대한 협상이 있는지 사용자 에이전트에 알립니다. 서버는 서버 중심 협상의 대상이되는 캐시 불가능한 응답을 가진 Vary 헤더 필드를 포함 할 수 있습니다. 이는 응답시 응답이 변하는 차원에 대한 유용한 정보를 사용자 에이전트에 제공 할 수 있기 때문입니다.필드 이름 목록으로 구성된 Vary 필드 값은 응답에 대해 선택된 표현이 가장 적합한 표현을 선택할 때 나열된 요청 헤더 필드 값만 고려하는 선택 알고리즘을 기반으로한다는 신호를 보냅니다. 캐시는 응답이 새로운 시간 동안, 나열된 필드 이름에 대해 동일한 값을 갖는 미래 요청에 대해 동일한 선택이 이루어질 것이라고 가정 할 수있다. 제공된 필드 이름은이 사양에서 정의한 표준 요청 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. &quot;-&quot;신호의 가변 필드 값은 요청 헤더 (예를 들어, 클라이언트의 네트워크 주소)로 제한되지 않은 지정되지 않은 파라미터가 응답 표현의 선택에 역할을한다는 것을 나타낸다. &quot;* &quot;값은 프록시 서버에 의해 생성되어서는 안되며 오리진 서버에 의해서만 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">Via General-header 필드는 게이트웨이와 프록시가 요청에 따라 사용자 에이전트와 서버 사이, 그리고 응답시 오리진 서버와 클라이언트 사이에 중간 프로토콜과 수신자를 나타내야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; 의 &quot;Received&quot;필드와 유사합니다. [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 모든 발신자의 프로토콜 기능을 식별하는 데 사용됩니다. Via = &quot;Via&quot; &quot;:&quot;1 # (수신 프로토콜 [[]]에 의해 수신 됨] 수신 프로토콜 = [프로토콜 이름 &quot;/&quot;] 프로토콜 버전 protocol-name = 토큰 프로토콜 버전 = 토큰 수령자 = (호스트 [ &quot;:&quot;포트]) | pseudonym pseudonym = token 수신 프로토콜은 요청 / 응답 체인의 각 세그먼트를 따라 서버 또는 클라이언트가 수신 한 메시지의 프로토콜 버전을 나타냅니다.수신 된 프로토콜 버전은 메시지가 전달 될 때 Via 필드 값에 추가되어 업스트림 응용 프로그램의 프로토콜 기능에 대한 정보가 모든 수신자에게 계속 표시됩니다. protocol-name은 &quot;HTTP&quot;인 경우에만 선택적입니다. 수신인 필드는 일반적으로 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되면 가명으로 대체 될 수 있습니다. 포트가 제공되지 않으면, 수신 된 프로토콜의 기본 포트로 간주 될 수 있습니다. 다중 Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다.각 수령인은 전달 결과의 순서에 따라 최종 결과가 정렬되도록 정보를 추가해야합니다. Via 헤더 필드에서 주석을 사용하여 User-Agent 및 Server 헤더 필드와 유사한 수신자 프록시 또는 게이트웨이의 소프트웨어를 식별 할 수 있습니다. 그러나 Via 필드의 모든 주석은 선택 사항이며 메시지를 전달하기 전에 수신자가 제거 할 수 있습니다. 예를 들어, 요청 메시지는 HTTP / 1.0 사용자 에이전트에서 코드 이름이 &quot;fred&quot;인 내부 프록시로 전송 될 수 있습니다.이 프록시는 HTTP / 1.1을 사용하여 요청을 nowhere.com의 공용 프록시로 전달합니다. www.ics.uci.edu의 오리진 서버로 전달합니다. www.ics.uci.edu가 수신 한 요청은 다음 Via 헤더 필드를 갖게됩니다. Via : 1.0 fred, 1.1 nowhere.com (Apache / 1.1) 네트워크 방화벽을 통해 포털로 사용되는 프록시 및 게이트웨이는 기본적으로 방화벽 영역 내의 호스트 이름과 포트를 전달해서는 안됩니다. 이 정보는 명시 적으로 활성화 된 경우에만 전파해야합니다. 활성화되지 않은 경우 방화벽 뒤에있는 호스트의 수신 호스트는 해당 호스트에 대한 적절한 가명으로 교체해야합니다. 내부 구조를 숨기기 위해 강력한 개인 정보 보호 요구 사항이있는 조직의 경우 프록시는 Via 헤더 필드 항목의 순서가 지정된 하위 시퀀스를 동일한 수신 프로토콜 값과 단일 항목으로 결합 할 수 있습니다. 예를 들어, Via : 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy는 Via : 1.0 ricky, 1.1 mertz, 1로 축소 될 수 있습니다.0 lucy 응용 프로그램 여러 조직의 항목이 모두 동일한 조직 제어하에 있고 호스트가 이미 가명으로 바뀌지 않는 한 여러 항목을 결합해서는 안됩니다. 응용 프로그램은 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">WWW-Authenticate response-header 필드는 반드시 401 (Unauthorized) 응답 메시지에 포함되어야합니다. 필드 값은 Request-URI에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 하나 이상의 시도로 구성됩니다. WWW-Authenticate = &quot;WWW-Authenticate&quot; &quot;:&quot;1 # challenge HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 설명되어 있습니다. 사용자 에이전트는 WWW-Authenticate 필드 값을 두 개 이상의 챌린지가 포함되어있을 수 있으므로 구문 분석 할 때 특히주의해야합니다. 또는 둘 이상의 WWW-Authenticate 헤더 필드가 제공된 경우 챌린지 자체의 내용은 쉼표로 구분 될 수 있습니다 인증 매개 변수 목록</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">경고 일반 헤더 필드는 메시지에 반영되지 않을 수있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용됩니다. 이 정보는 일반적으로 메시지의 엔터티 본문에 적용된 캐싱 작업 또는 변환으로 인한 의미 투명성 부족에 대해 경고하는 데 사용됩니다. 경고 헤더는 다음을 사용하여 응답과 함께 전송됩니다. 경고 = &quot;경고&quot; &quot;:&quot;1 # 경고 값 경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트 [SP 경고 날짜] 경고 코드 = 3DIGIT 경고 에이전트 = (호스트 [ &quot;:&quot;포트]) | 가명; 추가하는 서버의 이름 또는 가명; 경고 헤더디버깅에 사용 warn-text = quoted-string warn-date = &amp;lt; &quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt; 응답에 둘 이상의 경고 헤더가있을 수 있습니다. 경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.기본 언어는 영어이고 기본 문자 집합은 ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.기본 언어는 영어이고 기본 문자 집합은 ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]. 경고 헤더는 일반적으로 모든 메시지에 적용 할 수 있지만 일부 특정 경고 코드는 캐시에만 적용되며 응답 메시지에만 적용 할 수 있습니다. 기존 경고 헤더 뒤에 새 경고 헤더를 추가해야합니다. 캐시는 메시지와 함께받은 경고 헤더를 삭제해서는 안됩니다 (MUST NOT). 그러나 캐시가 캐시 항목의 유효성을 성공적으로 확인하면 특정 경고 코드에 지정된 경우를 제외하고 해당 항목에 이전에 연결된 모든 경고 헤더를 제거해야합니다. 그런 다음 유효성 검사 응답에서 수신 된 모든 경고 헤더를 추가해야합니다. 다시 말해, 경고 헤더는 가장 최근의 관련 응답에 첨부되는 헤더입니다. 응답에 여러 개의 경고 헤더가 첨부되면 사용자 에이전트는 가능한 많은 헤더를 사용자에게 알려야합니다.응답에 나타나는 순서대로. 사용자에게 모든 경고를 알 수없는 경우, 사용자 에이전트는 다음 휴리스틱을 따라야합니다.-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은경고와 관련된 캐시 동작 요구 사항은경고와 관련된 캐시 동작 요구 사항은&lt;a href=&quot;#section-13.1.2&quot;&gt;섹션 13.1.2&lt;/a&gt;. 다음은 현재 정의 된 경고 코드 목록이며, 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 110 응답이 부실함 반환 된 응답이 부실 할 때마다 응답을 포함해야합니다. 111 서버에 도달 할 수 없기 때문에 응답 재확인 시도가 실패하여 캐시가 오래된 응답을 반환하는 경우 유효성 재확인에 실패해야합니다. 연결이 끊긴 작업 캐시가 일정 기간 동안 네트워크의 나머지 부분에서 의도적으로 연결이 끊어진 경우 포함해야합니다. 캐시가 24 시간보다 긴 신선도 수명을 발견 적으로 선택하고 응답 시간이 24 시간보다 큰 경우 휴리스틱 만료를 포함해야합니다.199 기타 경고 경고 텍스트는 사람에게 제시되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 사용자에게 경고를 표시하는 것 외에 자동 조치를 취해서는 안됩니다. 214 적용되는 변환은 응답의 내용 코딩 (Content-Encoding 헤더에 지정된대로) 또는 미디어 유형 (Content-Type 헤더에 지정된대로)을 변경하는 변환을 적용 할 경우 반드시 중간 캐시 또는 프록시에 의해 추가되어야한다. 이 경고 코드가 이미 응답에 나타나지 않는 한 응답의 엔터티 본문입니다. 299 기타 지속적 경고 경고 텍스트는 사람에게 제시되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 자동 조치를 취해서는 안됩니다.구현시 버전이 HTTP / 1.0 이하인 하나 이상의 경고 헤더가있는 메시지를 보내는 경우 발신인은 응답의 날짜와 일치하는 경고 날짜를 각 경고 값에 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.보낸 사람은 각 경고 값에 응답 날짜와 일치하는 경고 날짜를 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.보낸 사람은 각 경고 값에 응답 날짜와 일치하는 경고 날짜를 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.(이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.(이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">웹 API에는 base64로 인코딩 또는 디코딩하는 기본 메소드 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 인코딩 및 디코딩이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">웹 오리진 개념</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">Web Runtime은 데스크탑 Firefox와 동일한 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">예상치 못한 이유로 웹 페이지를 일시적으로 사용할 수 없습니다. 이렇게하면 검색 엔진이 링크를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">예상치 못한 이유로 웹 페이지를 일시적으로 사용할 수 없습니다. 이렇게하면 검색 엔진이 링크를 업데이트하지 않습니다. 사이트에서 비 GET 링크 / 작업을 사용할 수있는 경우 &lt;code&gt;302&lt;/code&gt; 보다 낫습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">웹 서버</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">WebSocket 프로토콜</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">클라이언트가 서버와 통신 할 때 사용하려는 WebSocket 프로토콜 버전. 이 번호는 &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket 버전 번호 레지스트리에&lt;/a&gt; 나열된 최신 버전이어야합니다 . WebSocket 프로토콜의 최신 버전은 버전 13입니다.</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">XML 네임 스페이스 확장 ([ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;])는 다른 XML 요소 이름과 충돌 할 염려없이 새로운 XML 요소를 추가 할 수 있도록이 사양에서 사용됩니다. WebDAV 요청 및 응답 본문은 메시지 수신자가 무시할 수있는 임의의 XML 요소로 확장 될 수 있지만 &quot;DAV :&quot;네임 스페이스의 XML 요소는 해당 XML 요소가 명시 적으로 정의되어 있지 않으면 요청 또는 응답 본문에서 사용해서는 안됩니다 (SHOULD). WebDAV 실무 그룹에 의해 검토 된 IETF RFC에서. WebDAV가 확장 가능하고 이전 버전과 호환 가능하도록하려면 클라이언트와 서버 모두 예기치 않은 또는 인식 할 수없는 명령 확장이 수신 될 때 동작하는 방법을 알아야합니다. XML 처리의 경우즉, 클라이언트와 서버는 예기치 않은 요소와 속성 (및 인식 할 수없는 요소의 모든 자식)이없는 것처럼 수신 된 XML 문서를 처리해야합니다. 예기치 않은 요소 또는 속성에는 다른 컨텍스트에서 사용될 수 있지만 여기에서는 예상되지 않는 요소 또는 속성이 포함됩니다. 처리 목적으로 이러한 항목을 무시하는 것은 물론 모든 정보를 기록하거나 디버깅을 위해 제시하는 것과 일치 할 수 있습니다. 이 제한은 속성 스키마가 달리 선언하지 않는 한 예기치 않은 XML 요소를 무시해야하는 클라이언트의 DAV 속성 값 처리에도 적용됩니다. 서버가 모든 XML 요소를 기록해야하는 서버에서 죽은 DAV 속성을 설정하는 경우에는이 제한이 적용되지 않습니다. 또한이 제한은 XML이 엔티티 본문의 컨텐츠 유형이되는 XML (예 : PUT의 본문으로 사용되는 경우)에는 적용되지 않습니다. 수신자는 XML로 처리 지침을 무시해야한다. 따라서 WebDAV를 확장하는 사양은 표준 동작을 정의하기 위해 처리 명령을 사용해서는 안됩니다. XML DTD 조각은이 사양에 정의 된 모든 XML 요소에 포함됩니다. 그러나 네임 스페이스 사용 및 확장 규칙으로 인해 DTD에 따라 올바른 XML이 유효하지 않습니다. o 요소 (이 사양의)는 &quot;DAV :&quot;네임 스페이스에 있습니다. o 달리 명시되지 않는 한 요소 순서는 관련이 없습니다. o 확장 속성이 추가 될 수 있습니다. o &quot;ANY&quot;의 요소 유형 정의의 경우,그 요소에 대한 규범 적 텍스트 정의는 그 안에있을 수있는 것과 그 의미를 정의합니다. o &quot;#PCDATA&quot;의 요소 유형 정의에는 확장 요소를 추가해서는 안됩니다. o &quot;EMPTY&quot;를 포함한 다른 요소 유형 정의의 경우 확장 요소가 추가 될 수 있습니다. 즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조).즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조).즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조). &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; ). XML 본문이있는 WebDAV 메시지를받는 사람은 하드 코딩되거나 동적으로 선언 된 DTD에 따라 XML 문서의 유효성을 검사해서는 안됩니다. 이 섹션에서는 이전 버전과 호환되는 확장 성 규칙에 대해 설명합니다. 예를 들어,이 문서에 정의 된 XML 요소를 재사용하는 확장을 정의하지만이 사양에서 DTD에 필요한 하위 요소 중 하나를 생략하는 등 확장이 하위 호환성을 갖도록 설계된 경우도있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">리소스를 잠그는 기능은 해당 리소스에 대한 액세스를 직렬화하는 메커니즘을 제공합니다. 잠금을 사용하여 작성 클라이언트는 다른 프린시 펄이 편집중인 자원을 수정하지 않을 것이라는 합리적인 보증을 제공 할 수 있습니다. 이러한 방식으로 클라이언트는 &quot;손실 된 업데이트&quot;문제를 방지 할 수 있습니다. 이 사양을 사용하면 잠금이 클라이언트가 지정한 두 가지 매개 변수, 포함 된 주체 수 (제외 대 공유) 및 부여 할 액세스 유형에 따라 달라질 수 있습니다. 이 문서는 하나의 액세스 유형에 대해서만 잠금을 정의합니다. 그러나 구문은 확장 가능하며 최종적으로 다른 액세스 유형에 대한 잠금 스펙을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">위의 콘텐츠 보안 정책은 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 허용 합니다</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">위의 콘텐츠 보안 정책은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 같은 인라인 스타일 및 모든 요소 의 &lt;code&gt;style&lt;/code&gt; 속성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">위의 내용 은 브라우저가 보낸 ($ _SERVER [ 'HTTP_ORIGIN']을 통해 얻은) &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더가 ' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; ' 과 일치하는지 확인 합니다. 그렇다면 &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; 반환합니다 . 이 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기서 실행되는&lt;/a&gt; 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">위의 예는 mozilla.org 도메인의 로컬 호스트를 제외한 모든 호스트에 프록시를 사용하지만, www.mozilla.org 및 merchant.mozilla.org 호스트는 프록시를 거치게됩니다.</target>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">위의 내용은 매번 DNS를 참조해야합니다. 다른 규칙으로 결과를 얻지 못하는 경우에만 DNS를 참조하도록 다른 규칙과 지능적으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">추가 된 보안은 문서에 액세스하는 사용자가 &lt;code&gt;X-Frame-Options&lt;/code&gt; 를 지원하는 브라우저를 사용하는 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">현재 요청 된 페이지로 연결되는 이전 웹 페이지의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">허용 목록은 다음 값 중 하나를 취하는 원점 목록입니다.</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">이 헤더의 대체 표준 표준 버전은 &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">app : categories 요소는 범주 목록이 고정 세트인지 또는 열린 세트인지를 나타내는 &quot;yes&quot;또는 &quot;no&quot;값을 갖는 &quot;fixed&quot;속성을 포함 할 수 있습니다. &quot;fixed&quot;속성이 없으면 &quot;no&quot;값을 가진 &quot;fixed&quot;속성이있는 것과 같습니다. 또는 app : categories 요소는 &quot;href&quot;속성을 포함 할 수 있으며, 그 값은 카테고리 문서를 식별하는 IRI 참조 여야합니다. &quot;href&quot;속성이 제공되는 경우 app : categories 요소는 비어 있어야하며 &quot;fixed&quot;또는 &quot;scheme&quot;속성이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">app : collection 요소는 Atom Feed Document에서 atom : feed 또는 atom : source 요소의 자식으로 나타날 수 있습니다. 컨텐츠는 새 항목을 추가하여 피드에 표시 할 수있는 콜렉션을 식별합니다. atom : feed 또는 atom : source 요소에 나타나는 경우 app : collection 요소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;섹션 &lt;/a&gt;6에 정의 된대로 외부 마크 업으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">app : collection 요소는 반드시 &quot;href&quot;속성을 포함해야하며, 그 값은 Collection의 IRI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">app : workspace 요소는 하나의 &quot;atom : title&quot;요소 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 정의 된대로)를 포함해야 하며, 작업 영역에 대한 사람이 읽을 수있는 제목을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">application / http 유형을 사용하여 하나 이상의 HTTP 요청 또는 응답 메시지 (혼합되지 않음)의 파이프 라인을 묶을 수 있습니다. 유형 이름 : application 하위 유형 이름 : http 필수 매개 변수 : 해당 사항 없음 선택적 매개 변수 : version, msgtype version : 동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;). 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 라인에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야합니다. 보안 고려 사항 :&lt;a href=&quot;#section-9&quot;&gt;섹션 9 참조&lt;/a&gt; 상호 운용성 고려 사항 : 해당 사항 없음 게시 된 사양 :이 사양 ( &lt;a href=&quot;#section-8.3.2&quot;&gt;섹션 8.3.2&lt;/a&gt; 참조 ). 이 미디어 유형을 사용하는 응용 프로그램 : 해당 사항 없음 조각 식별자 고려 사항 : 해당 사항 없음 추가 정보 :이 유형에 대해 더 이상 사용되지 않는 별칭 이름 : 해당 사항 없음 매직 번호 : 해당 사항 없음 파일 확장자 : 해당 없음 Macintosh 파일 유형 코드 : 해당 사항 없음 자세한 내용은 연락 할 사람과 이메일 주소 : 작성자 주소 섹션을 참조하십시오. 용도 : COMMON 사용 제한 : 해당 사항 없음 저자 : 저자 주소 섹션을 참조하십시오. 컨트롤러 변경 : IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">&lt;a href=&quot;cors&quot;&gt;클라이언트와 서버 모두에서 사용하는 HTTP 헤더를 다루는&lt;/a&gt; 기사 가 여기 있으며 전제 조건으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">별표는 모든 리소스를 나타내는 특수한 값입니다.</target>
        </trans-unit>
        <trans-unit id="74a66c2c405c525c313119a786fdc5a7536e3be4" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource. They are only useful when uploading a resource, usually with &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, to check if another resource with the identity has already been uploaded before.</source>
          <target state="translated">별표는 모든 리소스를 나타내는 특수한 값입니다. ID가있는 다른 리소스가 이미 업로드되었는지 확인하기 위해 일반적으로 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 과 함께 리소스를 업로드 할 때만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="dc0975dcc835c772deb36f7878cb50959eba5345" translate="yes" xml:space="preserve">
          <source>The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;Section&amp;nbsp;4.3.7 of [RFC7231]&lt;/a&gt;).

     asterisk-form  = &quot;*&quot;

   When a client wishes to request OPTIONS for the server as a whole, as
   opposed to a specific named resource of that server, the client MUST
   send only &quot;*&quot; (%x2A) as the request-target.  For example,

     OPTIONS * HTTP/1.1

   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query
   component, then the last proxy on the request chain MUST send a
   request-target of &quot;*&quot; when it forwards the request to the indicated
   origin server.

   For example, the request

     OPTIONS &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP/1.1

   would be forwarded by the final proxy as

     OPTIONS * HTTP/1.1
     Host: www.example.org:8001

   after connecting to port 8001 of host &quot;www.example.org&quot;.</source>
          <target state="translated">요청 대상의 별표 형식은 서버 전체의 OPTIONS 요청에만 사용됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.7&quot;&gt;[RFC7231] 4.3.7 절&lt;/a&gt; ). asterisk-form = &quot;*&quot;클라이언트가 해당 서버의 특정 명명 된 리소스와 달리 서버 전체에 대한 옵션을 요청하려는 경우 클라이언트는 &quot;*&quot;(% x2A) 만 요청 대상으로 보내야합니다. 예를 들어, OPTIONS * HTTP / 1.1 프록시가 URI에 빈 경로가 있고 쿼리 구성 요소가없는 절대 형식의 요청 대상으로 OPTIONS 요청을 수신하는 경우 요청 체인의 마지막 프록시는 요청을 보내야합니다. 지정된 오리진 서버에 요청을 전달할 때 &quot;*&quot;의 대상. 예를 들어, 요청 옵션 &lt;a href=&quot;http://www.example.org:8001&quot;&gt;http://www.example.org:8001&lt;/a&gt; HTTP / 1.1은 호스트 &quot;www.example.org&quot;의 포트 8001에 연결 한 후 OPTIONS * HTTP / 1.1 호스트 : www.example.org:8001로 최종 프록시에 의해 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7c769400bb18a5cd534dd7b8c9bf26657988f6ef" translate="yes" xml:space="preserve">
          <source>The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a &lt;code&gt;':'&lt;/code&gt;), is called the &lt;em&gt;authority form&lt;/em&gt;. It is only used with &lt;code&gt;CONNECT&lt;/code&gt; when setting up an HTTP tunnel.</source>
          <target state="translated">도메인 이름과 선택적으로 포트 ( &lt;code&gt;':'&lt;/code&gt; 접두사)로 구성된 URL의 권한 구성 요소를 &lt;em&gt;권한 양식&lt;/em&gt; 이라고합니다 . HTTP 터널을 설정할 때 &lt;code&gt;CONNECT&lt;/code&gt; 와 함께 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7687b27068a2ba93c3867498f2559aee586b78c2" translate="yes" xml:space="preserve">
          <source>The authority-form of request-target is only used for CONNECT
   requests (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of [RFC7231]&lt;/a&gt;).

     authority-form = authority

   When making a CONNECT request to establish a tunnel through one or
   more proxies, a client MUST send only the target URI's authority
   component (excluding any userinfo and its &quot;@&quot; delimiter) as the
   request-target.  For example,

     CONNECT www.example.com:80 HTTP/1.1</source>
          <target state="translated">request-target의 권한 형식은 CONNECT 요청에만 사용됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]의 4.3.6 절&lt;/a&gt; ). authority-form = authority 하나 이상의 프록시를 통해 터널을 설정하기 위해 CONNECT 요청을하는 경우, 클라이언트는 요청 URI로 대상 URI의 권한 구성 요소 (모든 사용자 정보 및 &quot;@&quot;분리 문자 제외) 만 보내야합니다. 예 : CONNECT www.example.com:80 HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="eb218e220bee49a462071f93357caea4eef78a66" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a .pac filename extension:</source>
          <target state="translated">자동 구성 파일은 파일 이름 확장자가 .pac 인 파일로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1a30935583f6c8ca798d1fb82e164294a1797dd" translate="yes" xml:space="preserve">
          <source>The auto-config file should be saved to a file with a &lt;code&gt;.pac&lt;/code&gt; filename extension:</source>
          <target state="translated">자동 구성 파일은 파일 이름 확장자 가 &lt;code&gt;.pac&lt;/code&gt; 인 파일로 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="885be6e78dcfaa04b9ed4e903a1be4fd5a6bb5be" translate="yes" xml:space="preserve">
          <source>The autoconfig file can be output by a CGI script. This is useful, for example, when making the autoconfig file act differently based on the client IP address (the REMOTE_ADDR environment variable in CGI).</source>
          <target state="translated">자동 구성 파일은 CGI 스크립트로 출력 할 수 있습니다. 예를 들어, 자동 구성 파일이 클라이언트 IP 주소 (CGI의 REMOTE_ADDR 환경 변수)에 따라 다르게 작동하도록 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="654dd208a7e3408c3ffc11bf5374d37d8901160c" translate="yes" xml:space="preserve">
          <source>The basic cache mechanisms in HTTP/1.1 (server-specified expiration
   times and validators) are implicit directives to caches. In some
   cases, a server or client might need to provide explicit directives
   to the HTTP caches. We use the Cache-Control header for this purpose.

   The Cache-Control header allows a client or server to transmit a
   variety of directives in either requests or responses. These
   directives typically override the default caching algorithms. As a
   general rule, if there is any apparent conflict between header
   values, the most restrictive interpretation is applied (that is, the
   one that is most likely to preserve semantic transparency). However, 

   in some cases, cache-control directives are explicitly specified as
   weakening the approximation of semantic transparency (for example,
   &quot;max-stale&quot; or &quot;public&quot;).

   The cache-control directives are described in detail in &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1의 기본 캐시 메커니즘 (서버 지정 만료 시간 및 유효성 검사기)은 캐시에 대한 암시 적 지시문입니다. 경우에 따라 서버 또는 클라이언트가 HTTP 캐시에 명시 적 지시문을 제공해야 할 수도 있습니다. 이를 위해 Cache-Control 헤더를 사용합니다. Cache-Control 헤더를 사용하면 클라이언트 또는 서버가 다양한 지시문을 요청 또는 응답으로 전송할 수 있습니다. 이러한 지시문은 일반적으로 기본 캐싱 알고리즘보다 우선합니다. 일반적으로 헤더 값간에 명백한 충돌이있는 경우 가장 제한적인 해석 (즉, 의미 투명도를 유지할 가능성이 가장 높은 해석)이 적용됩니다. 그러나 경우에 따라 캐시 제어 지시문이 의미 투명성 근사를 약화시키는 것으로 명시 적으로 지정됩니다 (예 : &quot;max-stale&quot;또는 &quot;공개&quot;). 캐시 제어 지시문은 다음에 자세히 설명되어 있습니다.&lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="205356eaedd8e0ecc02522f44b70d14ec801fc5f" translate="yes" xml:space="preserve">
          <source>The basic features of the client-server protocol: what it can do and its intended uses.</source>
          <target state="translated">클라이언트-서버 프로토콜의 기본 기능 : 수행 할 수있는 기능 및 용도.</target>
        </trans-unit>
        <trans-unit id="e7083aadda2c31d227df92dd2fa84ac3833dcfbc" translate="yes" xml:space="preserve">
          <source>The browser is &lt;strong&gt;always&lt;/strong&gt; the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages).</source>
          <target state="translated">브라우저는 &lt;strong&gt;항상&lt;/strong&gt; 요청을 시작하는 엔티티입니다. 서버가 아닙니다 (수년에 걸쳐 서버 시작 메시지를 시뮬레이션하기 위해 일부 메커니즘이 추가 되었음).</target>
        </trans-unit>
        <trans-unit id="2cbd8e5718ca567c96ddc915f16935aae94c67e0" translate="yes" xml:space="preserve">
          <source>The browser version is often, but not always, put in the value part of the &lt;em&gt;BrowserName/VersionNumber&lt;/em&gt; token in the User Agent String. This is of course not the case for Internet Explorer (which puts the version number right after the MSIE token), and for Opera after version 10, which has added a Version/&lt;em&gt;VersionNumber&lt;/em&gt; token.</source>
          <target state="translated">브라우저 버전은 종종 사용자 에이전트 문자열에서 &lt;em&gt;BrowserName / VersionNumber&lt;/em&gt; 토큰 의 값 부분에 배치되는 경우가 종종 있습니다. 물론 Internet Explorer (MSI 토큰 뒤에 바로 버전 번호를 표시 함) 및 Version / &lt;em&gt;VersionNumber&lt;/em&gt; 토큰을 추가 한 버전 10 이후 Opera에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bdbde6838426248696c94b45cfec9d0fc5ec1db" translate="yes" xml:space="preserve">
          <source>The browser will automatically retry a previously unresponsive proxy after 30 minutes. Additional attempts will continue beginning at one hour, always adding 30 minutes to the elapsed time between attempts.</source>
          <target state="translated">브라우저는 30 분 후에 이전에 응답하지 않는 프록시를 자동으로 다시 시도합니다. 추가 시도는 1 시간부터 계속되며 항상 시도 간격에 30 분이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="887b852d02845ba1a99a4a0744f4797dc2bf5823" translate="yes" xml:space="preserve">
          <source>The cache is disconnected from the rest of the network.</source>
          <target state="translated">캐시가 나머지 네트워크와 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="2f21d9d6b26c4e6bea5e52cb792172b8c9de3d95" translate="yes" xml:space="preserve">
          <source>The cache must verify the status of the stale resources before using it and expired ones should not be used.</source>
          <target state="translated">캐시는 부실 리소스를 사용하기 전에 상태를 확인해야하며 만료 된 리소스는 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="daeefaacace04c4b349d31a7092c605e7392d449" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response.</source>
          <target state="translated">캐시는 클라이언트 요청 또는 서버 응답에 대한 어떠한 것도 저장해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6c578830e2a2b4f9372dff694a83a347a725c406" translate="yes" xml:space="preserve">
          <source>The cache should not store anything about the client request or server response. A request is sent to the server and a full response is downloaded each and every time.</source>
          <target state="translated">캐시는 클라이언트 요청 또는 서버 응답에 대한 어떠한 것도 저장해서는 안됩니다. 요청이 서버로 전송되고 매번 전체 응답이 다운로드됩니다.</target>
        </trans-unit>
        <trans-unit id="0f42630e59bac670b1a39303ea428afbe6e77a0e" translate="yes" xml:space="preserve">
          <source>The character encoding standard.</source>
          <target state="translated">문자 인코딩 표준입니다.</target>
        </trans-unit>
        <trans-unit id="fd7f690c409848b22dbd45c29cbfb870b4b15ecf" translate="yes" xml:space="preserve">
          <source>The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited 

   to specialized HTTP services such as &quot;long polling&quot; (where client and
   server can have shared expectations regarding the use of chunk
   extensions) or for padding within an end-to-end secured connection.

   A recipient MUST ignore unrecognized chunk extensions.  A server
   ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the
   same way that it applies length limitations and timeouts for other
   parts of a message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.</source>
          <target state="translated">청크 단위 인코딩은 청크 당 메타 데이터 (서명 또는 해시와 같은), 메시지 중간 제어 정보 또는 메시지 본문의 무작위 화를 위해 청크 크기 바로 다음에 청크 확장을 0 ​​개 이상 포함 할 수 있습니다. 크기. chunk-ext = * ( &quot;;&quot;chunk-ext-name [ &quot;=&quot;chunk-ext-val]) chunk-ext-name = token chunk-ext-val = token / quoted-string 청크 인코딩은 각 항목에 따라 다릅니다. 상위 수준의 응용 프로그램에서 확장 프로그램을 검사하기 전에 각 수신자 (중개자 포함)가 연결을 제거하거나 다시 코딩 할 가능성이 있습니다. 따라서 청크 확장의 사용은 일반적으로 &quot;롱 폴링&quot;과 같은 특수한 HTTP 서비스로 제한됩니다.(클라이언트와 서버는 청크 확장 사용에 대한 기대치를 공유 할 수 있음) 또는 엔드 투 엔드 보안 연결 내 패딩에 사용됩니다. 수신자는 인식 할 수없는 청크 확장명을 무시해야합니다. 서버는 메시지의 다른 부분에 대한 길이 제한 및 시간 초과를 적용하고 적절한 4xx (클라이언트 오류)를 생성하는 것과 같은 방식으로 요청에서받은 청크 확장의 총 길이를 제공된 서비스에 적합한 양으로 제한해야합니다. ) 해당 금액을 초과하면 응답합니다.메시지의 다른 부분에 길이 제한 및 시간 초과를 적용하는 것과 같은 방식으로 해당 양을 초과하면 적절한 4xx (클라이언트 오류) 응답을 생성합니다.메시지의 다른 부분에 길이 제한 및 시간 초과를 적용하는 것과 같은 방식으로 해당 양을 초과하면 적절한 4xx (클라이언트 오류) 응답을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="48e4a91f8067d7ebfdee16e201dcdb0c016dab57" translate="yes" xml:space="preserve">
          <source>The chunked encoding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing entity-header fields. This
   allows dynamically produced content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.

       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF

       chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)

   The chunk-size field is a string of hex digits indicating the size of
   the chunk. The chunked encoding is ended by any chunk whose size is
   zero, followed by the trailer, which is terminated by an empty line.

   The trailer allows the sender to include additional HTTP header
   fields at the end of the message. The Trailer header field can be
   used to indicate which header fields are included in a trailer (see
   &lt;a href=&quot;#section-14.40&quot;&gt;section 14.40&lt;/a&gt;). 

   A server using chunked transfer-coding in a response MUST NOT use the
   trailer for any header fields unless at least one of the following is
   true:

   a)the request included a TE header field that indicates &quot;trailers&quot; is
     acceptable in the transfer-coding of the  response, as described in
     &lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;; or,

   b)the server is the origin server for the response, the trailer
     fields consist entirely of optional metadata, and the recipient
     could use the message (in a manner acceptable to the origin server)
     without receiving this metadata.  In other words, the origin server
     is willing to accept the possibility that the trailer fields might
     be silently discarded along the path to the client.

   This requirement prevents an interoperability failure when the
   message is being received by an HTTP/1.1 (or later) proxy and
   forwarded to an HTTP/1.0 recipient. It avoids a situation where
   compliance with the protocol would have necessitated a possibly
   infinite buffer on the proxy.

   An example process for decoding a Chunked-Body is presented in
   appendix 19.4.6.

   All HTTP/1.1 applications MUST be able to receive and decode the
   &quot;chunked&quot; transfer-coding, and MUST ignore chunk-extension extensions
   they do not understand.</source>
          <target state="translated">청크 인코딩은 메시지 본문을 수정하여 각각 자체 크기 표시기가있는 일련의 청크로 전송 한 다음 엔터티 헤더 필드를 포함하는 OPTIONAL 트레일러를 전송합니다. 이를 통해 수신자가 전체 메시지를 수신했는지 확인하는 데 필요한 정보와 함께 동적으로 생성 된 컨텐츠를 전송할 수 있습니다. 청크 바디 = * chunk last-chunk trailer CRLF 청크 = chunk-size [chunk-extension] CRLF chunk-data CRLF chunk-size = 1 * HEX last-chunk = 1 * ( &quot;0&quot;) [chunk-extension] CRLF chunk-extension = * ( &quot;;&quot;chunk-ext-name [ &quot;=&quot;chunk-ext-val]) chunk-ext-name = 토큰 chunk-ext-val = 토큰 | quoted-string chunk-data = chunk-size (OCTET) trailer = * (entity-header CRLF) 청크 크기 필드는 청크의 크기를 나타내는 16 진수 문자열입니다. 청크 인코딩은 크기가 0 인 청크와 트레일러 뒤에 빈 행으로 끝나는 청크로 끝납니다. 예고편을 사용하면 발신자가 메시지 끝에 추가 HTTP 헤더 필드를 포함 할 수 있습니다. 트레일러 헤더 필드는 트레일러에 포함 된 헤더 필드를 나타내는 데 사용할 수 있습니다 (참조청크 인코딩은 크기가 0 인 청크와 트레일러 다음에 빈 행으로 끝나는 청크로 끝납니다. 예고편을 사용하면 발신자가 메시지 끝에 추가 HTTP 헤더 필드를 포함 할 수 있습니다. 트레일러 헤더 필드는 트레일러에 포함 된 헤더 필드를 나타내는 데 사용할 수 있습니다 (참조청크 인코딩은 크기가 0 인 청크와 트레일러 다음에 빈 행으로 끝나는 청크로 끝납니다. 예고편을 사용하면 발신자가 메시지 끝에 추가 HTTP 헤더 필드를 포함 할 수 있습니다. 트레일러 헤더 필드는 트레일러에 포함 된 헤더 필드를 나타내는 데 사용할 수 있습니다 (참조 &lt;a href=&quot;#section-14.40&quot;&gt;섹션 14.40&lt;/a&gt; ). 응답에 청크 분할 전송 코딩을 사용하는 서버는 다음 중 하나 이상에 해당하지 않는 한 모든 헤더 필드에 트레일러를 사용해서는 안됩니다. &lt;a href=&quot;#section-14.39&quot;&gt;섹션 14.39에&lt;/a&gt; 설명 된대로 응답 ; 또는 b) 서버가 응답을위한 오리진 서버이고 트레일러 필드는 전적으로 선택적 메타 데이터로 구성되며 수신자는이 메타 데이터를받지 않고 메시지를 오리진 서버에 허용되는 방식으로 사용할 수 있습니다. 다시 말해, 오리진 서버는 트레일러 경로가 클라이언트 경로를 따라 자동으로 버려 질 가능성을 기꺼이 받아들입니다. 이 요구 사항은 메시지가 HTTP / 1.1 (이상) 프록시에 의해 수신되고 HTTP / 1.0 수신자에게 전달 될 때 상호 운용성 실패를 방지합니다. 프로토콜 준수가 프록시에서 무한 버퍼를 필요로하는 상황을 피합니다. Chunked-Body를 디코딩하는 프로세스의 예는 부록 19.4.6에 나와 있습니다. 모든 HTTP / 1.1 개의 응용 프로그램은 &quot;청크 된&quot;전송 코딩을 수신하고 디코딩 할 수 있어야하며 이해하지 못하는 청크 확장명을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7d9ecd82450ec8dc1ad7713aebafcc7e0d70fa4" translate="yes" xml:space="preserve">
          <source>The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.</source>
          <target state="translated">청크 분할 전송 코딩은 페이로드 본문을 랩핑하여 일련의 청크로 전송합니다 (각각 자체 크기 표시기가 있고 헤더 필드가 포함 된 선택 트레일러). 청크를 사용하면 알 수없는 크기의 콘텐츠 스트림을 길이로 구분 된 일련의 버퍼로 전송할 수 있으므로 보낸 사람이 연결 지속성을 유지하고받는 사람이 전체 메시지를 언제 받았는지 알 수 있습니다. 청크 본문 = * 청크 마지막 청크 트레일러 부품 CRLF 청크 = 청크 크기 [청크 확장] CRLF 청크 데이터 CRLF 청크 크기 = 1 * HEXDIG 마지막 청크 = 1 * ( &quot;0&quot;) [청크 확장 ] CRLF 청크 데이터 = 1 * OCTET;청크 크기 옥텟의 시퀀스 청크 크기 필드는 청크 데이터의 크기를 옥텟으로 나타내는 16 진수 문자열이다. 청크 전송 크기는 청크 크기가 0 인 청크가 수신되고 트레일러가 이어지고 빈 라인으로 종료되면 완료됩니다. 수신자는 청크 전송 코드를 구문 분석하고 디코딩 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="415a4bc5f36b8b74ac665b81439b0f17201eff1f" translate="yes" xml:space="preserve">
          <source>The client IP address</source>
          <target state="translated">클라이언트 IP 주소</target>
        </trans-unit>
        <trans-unit id="f4f8621b5597ea11953d56253188393201c5390d" translate="yes" xml:space="preserve">
          <source>The client SHOULD continue with its request. This interim response is
   used to inform the client that the initial part of the request has
   been received and has not yet been rejected by the server. The client
   SHOULD continue by sending the remainder of the request or, if the
   request has already been completed, ignore this response. The server
   MUST send a final response after the request has been completed. See
   &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for detailed discussion of the use and handling of this
   status code.</source>
          <target state="translated">클라이언트는 요청을 계속해야합니다. 이 임시 응답은 요청의 초기 부분이 서버에 의해 수신되었고 아직 거부되지 않았 음을 클라이언트에 알리는 데 사용됩니다. 클라이언트는 나머지 요청을 계속 보내거나 요청이 이미 완료된 경우이 응답을 무시해야합니다. 요청이 완료된 후 서버는 반드시 최종 응답을 보내야합니다. 이 상태 코드의 사용 및 처리에 대한 자세한 내용은 &lt;a href=&quot;#section-8.2.3&quot;&gt;섹션 8.2.3&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cdfa1347854a07ac313ca6b4125f4dd9a9af51d" translate="yes" xml:space="preserve">
          <source>The client did not produce a request within the time that the server
   was prepared to wait. The client MAY repeat the request without
   modifications at any later time.</source>
          <target state="translated">클라이언트는 서버가 대기 할 시간 내에 요청을 생성하지 않았습니다. 클라이언트는 나중에 수정없이 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7266b1abf9d7b15153ddaf61096e777051f04c74" translate="yes" xml:space="preserve">
          <source>The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.</source>
          <target state="translated">클라이언트는 컨텐츠에 대한 액세스 권한이 없습니다. 즉, 권한이 없으므로 서버가 적절한 응답을 거부합니다. 401과 달리 클라이언트의 ID는 서버에 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a06a1a055ac600eef86c86487e70e03abac976" translate="yes" xml:space="preserve">
          <source>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</source>
          <target state="translated">클라이언트는 TCP 연결 (또는 전송 계층이 TCP가 아닌 경우 적절한 연결)을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bc64fec6ee0e97b2601f305debb944c7297d99f9" translate="yes" xml:space="preserve">
          <source>The client has indicated preconditions in its headers which the server does not meet.</source>
          <target state="translated">클라이언트가 헤더에 서버가 충족하지 않는 전제 조건을 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="bfa31c734d07698a1162e761b391639dea1a2247" translate="yes" xml:space="preserve">
          <source>The client issues a request to the canonical domain: &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</source>
          <target state="translated">클라이언트는 표준 도메인에 요청을 발행합니다. &lt;code&gt;http://example.org/whatddup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="517d78c7c821635a0b4548cee1bab26d988c7745" translate="yes" xml:space="preserve">
          <source>The client sends its request, and waits for the answer.</source>
          <target state="translated">클라이언트는 요청을 보내고 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="ee32a252064fce95d78b27deb30677a6f5f9861f" translate="yes" xml:space="preserve">
          <source>The client should not repeat this request without modification.</source>
          <target state="translated">클라이언트는 수정없이이 요청을 반복해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6ecda58cff7b06f0ebd744bad8fc92cd64e7b568" translate="yes" xml:space="preserve">
          <source>The client that initiated the request and subsequent proxies in a chain of proxies.</source>
          <target state="translated">프록시 체인에서 요청 및 후속 프록시를 시작한 클라이언트</target>
        </trans-unit>
        <trans-unit id="72cded756bfa543235b2ef68f253845e7563a14d" translate="yes" xml:space="preserve">
          <source>The codings defined below can be used to compress the payload of a
   message.</source>
          <target state="translated">아래에 정의 된 코딩은 메시지의 페이로드를 압축하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9677ba4a41043c80dd7875428097d17f3b102726" translate="yes" xml:space="preserve">
          <source>The common use case is to return &lt;code&gt;204&lt;/code&gt; as a result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request, updating a resource, without changing the current content of the page displayed to the user. If the resource is created, &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; is returned instead. If the page should be changed to the newly updated page, the &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">일반적인 사용 사례는 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 요청 의 결과로 사용자에게 표시된 페이지의 현재 내용을 변경하지 않고 리소스를 업데이트하여 &lt;code&gt;204&lt;/code&gt; 를 반환 하는 것입니다 . 리소스가 생성되면 &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Created&lt;/code&gt; 가 대신 반환됩니다. 페이지를 새로 업데이트 된 페이지로 변경해야하는 경우 &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e652d732604ca7329e0833f245786713768ed8e7" translate="yes" xml:space="preserve">
          <source>The common use case of this status code is as the result of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request.</source>
          <target state="translated">이 상태 코드의 일반적인 사용 사례는 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="c04133abc831323a63813210792503c0061624d7" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;strong comparison algorithm&lt;/em&gt;, meaning two files are considered identical byte to byte only. This is weakened when the &lt;code&gt;W/&lt;/code&gt; prefix is used in front of the &lt;code&gt;ETag&lt;/code&gt;.</source>
          <target state="translated">저장된 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 와의 비교&lt;/em&gt; 에는 &lt;em&gt;강력한 비교 알고리즘이&lt;/em&gt; 사용 되므로 두 파일은 바이트 단위로 동일한 것으로 간주됩니다. &lt;code&gt;W/&lt;/code&gt; 접두사가 &lt;code&gt;ETag&lt;/code&gt; 앞에 사용될 때 약화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7a2fbb792f71c73497799f887f4d3819b0abaf6" translate="yes" xml:space="preserve">
          <source>The comparison with the stored &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; uses the &lt;em&gt;weak comparison algorithm&lt;/em&gt;, meaning two files are considered identical not only if they are identical byte to byte, but if the content is equivalent. For example, two pages that would differ only by the date of generation in the footer would be considered as identical.</source>
          <target state="translated">저장된 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 와의 비교&lt;/em&gt; 는 &lt;em&gt;약한 비교 알고리즘을&lt;/em&gt; 사용합니다 . 즉, 두 파일이 바이트 단위가 동일 할뿐만 아니라 내용이 동일한 경우 두 파일이 동일한 것으로 간주됩니다. 예를 들어 바닥 글에서 생성 날짜 만 다른 두 페이지는 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a0905c4e80c334babf93aeba4446459e7079b76c" translate="yes" xml:space="preserve">
          <source>The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; and send us a pull request.</source>
          <target state="translated">이 페이지의 호환성 표는 구조화 된 데이터에서 생성됩니다. 데이터에 기여하려면 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; 를 확인하고 풀 요청을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="a05c38dc87a4c3ad5288313d314048589646b4f9" translate="yes" xml:space="preserve">
          <source>The concrete steps necessary to deliver the HPKP header depend on the web server you use.</source>
          <target state="translated">HPKP 헤더를 제공하는 데 필요한 구체적인 단계는 사용하는 웹 서버에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f5aee79466e47707e7aaaf37d00efa279a7d1756" translate="yes" xml:space="preserve">
          <source>The content and concepts within are a product of the Atom community
   and the Atompub Working Group.</source>
          <target state="translated">내용과 개념은 Atom 커뮤니티와 Atompub 워킹 그룹의 제품입니다.</target>
        </trans-unit>
        <trans-unit id="5e832a9cde14ca1e931972542042bbb8f1f01671" translate="yes" xml:space="preserve">
          <source>The content of an &quot;app:accept&quot; element value is a media range as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The media range specifies a type of
   representation that can be POSTed to a Collection.

   The app:accept element is similar to the HTTP Accept request-header
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  Media type parameters are allowed within app:accept, but
   app:accept has no notion of preference -- &quot;accept-params&quot; or &quot;q&quot;
   arguments, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;Section&amp;nbsp;14.1 of [RFC2616]&lt;/a&gt; are not
   significant.

   White space (as defined in [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]) around the app:accept element's
   media range is insignificant and MUST be ignored.

   A value of &quot;application/atom+xml;type=entry&quot; MAY appear in any app:
   accept list of media ranges and indicates that Atom Entry Documents
   can be POSTed to the Collection.  If no app:accept element is
   present, clients SHOULD treat this as equivalent to an app:accept
   element with the content &quot;application/atom+xml;type=entry&quot;.

   If one app:accept element exists and is empty, clients SHOULD assume
   that the Collection does not support the creation of new Entries.

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }</source>
          <target state="translated">&quot;app : accept&quot;요소 값의 내용은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된 미디어 범위 입니다. 미디어 범위는 컬렉션에 POST 될 수있는 표현 유형을 지정합니다. app : accept 요소는 HTTP Accept 요청 헤더 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 와 유사합니다 . 미디어 유형 매개 변수는 app : accept 내에서 허용되지만 app : accept에는 기본 설정 개념 이 없습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.1&quot;&gt;[RFC2616]의 14.1 절에&lt;/a&gt; 지정된 &quot;accept-params&quot;또는 &quot;q&quot;인수 는 중요하지 않습니다. 공백 ([ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml에&lt;/a&gt; 정의 된대로)]) app : accept 요소의 미디어 범위 주변은 중요하지 않으므로 무시해야합니다. &quot;application / atom + xml; type = entry&quot;값은 모든 앱에 나타날 수 있습니다. 미디어 범위 목록을 수락하고 Atom Entry Documents를 Collection에 POST 할 수 있음을 나타냅니다. app : accept 요소가 없으면 클라이언트는 이것을 &quot;application / atom + xml; type = entry&quot;컨텐츠를 가진 app : accept 요소와 동일하게 취급해야합니다. 하나의 app : accept 요소가 존재하고 비어있는 경우, 클라이언트는 Collection이 새 항목 작성을 지원하지 않는다고 가정해야합니다. appAccept = 요소 app : accept {appCommonAttributes, (텍스트?)}</target>
        </trans-unit>
        <trans-unit id="539a35b3718ee8a5aee196d79e2ab252e1794cb2" translate="yes" xml:space="preserve">
          <source>The content security policy</source>
          <target state="translated">콘텐츠 보안 정책</target>
        </trans-unit>
        <trans-unit id="a99f7db56a8fc0d621fb9f438536232235171cde" translate="yes" xml:space="preserve">
          <source>The cookie created above is a &lt;em&gt;session cookie&lt;/em&gt;: it is deleted when the client shuts down, because it didn't specify an &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directive. However, web browsers may use &lt;strong&gt;session restoring&lt;/strong&gt;, which makes most session cookies permanent, as if the browser was never closed.</source>
          <target state="translated">위에서 생성 된 쿠키는 &lt;em&gt;세션 쿠키입니다&lt;/em&gt; . &lt;code&gt;Expires&lt;/code&gt; 또는 &lt;code&gt;Max-Age&lt;/code&gt; 지시어를 지정하지 않았기 때문에 클라이언트가 종료 될 때 삭제됩니다 . 그러나 웹 브라우저는 &lt;strong&gt;세션 복원을&lt;/strong&gt; 사용 하여 브라우저를 닫지 않은 것처럼 대부분의 세션 쿠키를 영구적으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ea80f5dbbb07b298e7e569c7ef43ac598c80e1" translate="yes" xml:space="preserve">
          <source>The creator of a lock has special privileges to use the lock to
   modify the resource.  When a locked resource is modified, a server
   MUST check that the authenticated principal matches the lock creator
   (in addition to checking for valid lock token submission).

   The server MAY allow privileged users other than the lock creator to
   destroy a lock (for example, the resource owner or an administrator).
   The 'unlock' privilege in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] was defined to provide that
   permission.

   There is no requirement for servers to accept LOCK requests from all
   users or from anonymous users.

   Note that having a lock does not confer full privilege to modify the
   locked resource.  Write access and other privileges MUST be enforced
   through normal privilege or authentication mechanisms, not based on
   the possible obscurity of lock token values.</source>
          <target state="translated">잠금 작성자에게는 잠금을 사용하여 자원을 수정할 수있는 특수 권한이 ​​있습니다. 잠긴 리소스가 수정되면 서버는 인증 된 보안 주체가 유효한 잠금 토큰 제출을 확인하는 것 외에 잠금 생성자와 일치하는지 확인해야합니다. 서버는 잠금 생성자 이외의 권한있는 사용자가 잠금 (예 : 자원 소유자 또는 관리자)을 파기하도록 허용 할 수 있습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt; 의 '잠금 해제'권한]은 해당 권한을 제공하기 위해 정의되었습니다. 서버가 모든 사용자 또는 익명 사용자의 LOCK 요청을 수락 할 필요는 없습니다. 잠금이 있다고해서 잠금 된 리소스를 수정하기위한 모든 권한이 부여되지는 않습니다. 쓰기 액세스 및 기타 권한은 잠금 토큰 값의 모호한 가능성을 기반으로하지 않고 일반 권한 또는 인증 메커니즘을 통해 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed6930808b04a49db2a6e882d398fb403c175d9d" translate="yes" xml:space="preserve">
          <source>The credentials are constructed like this:</source>
          <target state="translated">자격 증명은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b8947dfbd554435efd90ececbfae32fbeaafdf7" translate="yes" xml:space="preserve">
          <source>The current set of policy-controlled features fall into two broad categories:</source>
          <target state="translated">현재 정책 제어 기능 세트는 크게 두 가지 범주로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="a8e69d68f3b1fc3a7df5c137fb99fc1e2d0cfdfa" translate="yes" xml:space="preserve">
          <source>The data URL will use the encoded data after the initial header line.</source>
          <target state="translated">데이터 URL은 초기 헤더 행 다음에 인코딩 된 데이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="230d58d4d34777b830d4af9d56c4ae6916e8d111" translate="yes" xml:space="preserve">
          <source>The data portion of a data URL is opaque, so an attempt to use a query string (page-specific parameters, with the syntax &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt;) with a data URL will just include the query string in the data the URL represents.</source>
          <target state="translated">데이터 URL의 데이터 부분은 불투명하므로 데이터 URL과 함께 쿼리 문자열 (구문 &lt;code&gt;&amp;lt;url&amp;gt;?parameter-data&lt;/code&gt; 와 함께 페이지 특정 매개 변수 )을 사용하면 데이터에 쿼리 문자열이 포함됩니다. 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a838733e8354e6c49d346e5cb2fb10c66ede3853" translate="yes" xml:space="preserve">
          <source>The data to be sent is already compressed and a second compression won't lead to smaller data to be transmitted. This may be the case with some image formats;</source>
          <target state="translated">전송할 데이터는 이미 압축되어 있으며 두 번째 압축은 더 작은 데이터를 전송하지 않습니다. 일부 이미지 형식의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7f9129a63093295fb84eccd3b4f61f829c9ef91c" translate="yes" xml:space="preserve">
          <source>The date/time after which the response is considered stale.</source>
          <target state="translated">응답이 오래된 것으로 간주 된 날짜 / 시간입니다.</target>
        </trans-unit>
        <trans-unit id="cd1d97e38222ff903f1be33758664532039e0043" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;'self'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce8a92d4fc085eba2fc0033588db51c48988c071" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bebd0e8a85754c8108d63895e7f002620ba7cd6c" translate="yes" xml:space="preserve">
          <source>The definition of collection state has been fixed so it doesn't vary
   anymore depending on the Request-URI (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The DAV:source property introduced in &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;Section&amp;nbsp;4.6 of [RFC2518]&lt;/a&gt; was
   removed due to lack of implementation experience.

   The DAV header now allows non-IETF extensions through URIs in
   addition to compliance class tokens.  It also can now be used in
   requests, although this specification does not define any associated
   semantics for the compliance classes defined in here (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).

   In &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, the definition of the Depth header (&lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;)
   required that, by default, request headers would be applied to each
   resource in scope.  Based on implementation experience, the default
   has now been reversed (see &lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;).

   The definitions of HTTP status code 102 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], Section&amp;nbsp;10.1&lt;/a&gt;) and
   the Status-URI response header (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;) have been removed due to
   lack of implementation.

   The TimeType format used in the Timeout request header and the
   &quot;timeout&quot; XML element used to be extensible.  Now, only the two
   formats defined by this specification are allowed (see &lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;).

Author's Address

   Lisa Dusseault (editor)
   CommerceNet
   2064 Edgewood Dr.
   Palo Alto, CA  94303
   US

   EMail: ldusseault@commerce.net 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


Dusseault                   Standards Track                   [Page 127]</source>
          <target state="translated">수집 상태의 정의가 수정되어 Request-URI에 따라 더 이상 달라지지 않습니다 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; 참조 ). &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-4.6&quot;&gt;[RFC2518]의 섹션 4.6&lt;/a&gt; 에서 소개 된 DAV : source 속성 은 구현 경험이 부족하여 제거되었습니다. DAV 헤더는 이제 규정 준수 클래스 토큰 외에도 URI를 통해 비 IETF 확장을 허용합니다. 이 스펙은 여기에 정의 된 컴플라이언스 클래스에 대한 관련 시맨틱을 정의하지 않지만 요청에서도 사용할 수 있습니다 ( &lt;a href=&quot;#section-10.1&quot;&gt;10.1 절&lt;/a&gt; 참조 ). 에서 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; , 깊이 헤더의 정의 ( &lt;a href=&quot;#section-9.2&quot;&gt;9.2 절&lt;/a&gt;)는 기본적으로 요청 헤더가 범위 내 각 리소스에 적용되어야했습니다. 구현 경험을 바탕으로, 기본값이 바뀌 었습니다 ( &lt;a href=&quot;#section-10.2&quot;&gt;10.2 절&lt;/a&gt; 참조 ). HTTP 상태 코드 102 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;[RFC2518], 섹션 10.1&lt;/a&gt; ) 및 Status-URI 응답 헤더 ( &lt;a href=&quot;#section-9.7&quot;&gt;9.7 섹션&lt;/a&gt; )의 정의는 구현 부족으로 제거되었습니다. Timeout 요청 헤더에 사용 된 TimeType 형식과 &quot;timeout&quot;XML 요소는 확장 가능했습니다. 이제이 규격에서 정의한 두 가지 형식 만 허용됩니다 ( &lt;a href=&quot;#section-10.7&quot;&gt;섹션 10.7&lt;/a&gt; 참조).). 작성자 주소 Lisa Dusseault (편집자) CommerceNet 2064 Edgewood Dr. Palo Alto, CA 94303 미국 전자 우편 : ldusseault@commerce.net 전체 저작권 정보 저작권 (C) IETF 트러스트 (2007). 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78에&lt;/a&gt; 포함 된 권리, 라이센스 및 제한 사항의 적용을받습니다저자는 여기에 명시된 경우를 제외하고 모든 권리를 보유합니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며, 기부자, 그 / 그녀가 대표하거나 후원하는 단체, 인터넷 사회, IETF 신뢰 및 인터넷 엔지니어링 책임은 모두 부인됩니다. 여기에 포함 된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 어떠한 권리 나 묵시적 보증도 침해하지 않는다는 어떠한 보증도 포함하여 명시 적 또는 묵시적 보증.지적 재산권 IETF는이 문서에 기술 된 기술의 구현 또는 사용과 관련하여 주장 할 수있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스가 사용하지 못할 수 있습니다. 또한 그러한 권리를 식별하기 위해 독립적 인 노력을 기울인 것도 아닙니다. RFC 문서의 권리와 관련된 절차에 대한 정보는&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt; . IETF 사무국에 대한 IPR 공개 사본 및 사용 가능한 라이센스에 대한 보증 또는이 사양의 구현 자 또는 사용자가 해당 소유권을 사용하기위한 일반 라이센스 또는 허가를 획득하려는 시도의 결과를 얻을 수 있습니다. &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt; 의 IETF 온라인 IPR 저장소에서 . IETF는 모든 이해 당사자가이 표준을 구현하는 데 필요할 수있는 기술을 포괄 할 수있는 모든 저작권, 특허 또는 특허 출원 또는 기타 독점권에 관심을 갖도록 초대합니다. 정보는 IETF (ietf-ipr@ietf.org)로 문의하십시오. RFC 편집기 기능에 대한 승인 자금은 현재 인터넷 협회에서 제공합니다. Dusseault 표준 트랙 [페이지 127]</target>
        </trans-unit>
        <trans-unit id="846eb07b1348486cd629ae2d294bdd353ad9d018" translate="yes" xml:space="preserve">
          <source>The definition of validator weakness has been expanded and clarified.
   (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;)

   The precedence for evaluation of conditional requests has been
   defined.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)</source>
          <target state="translated">유효성 검사기 취약점의 정의가 확장되고 명확 해졌습니다. ( &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1&lt;/a&gt; ) 이제 범위 요청을 제외한 모든 요청에 ​​약한 엔티티 태그가 허용됩니다. (섹션 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 및 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; ) ETag 헤더 필드 ABNF가 인용 문자열을 사용하지 않도록 변경되었으므로 이스케이프 문제가 발생하지 않습니다. ( &lt;a href=&quot;#section-2.3&quot;&gt;2.3 절&lt;/a&gt; ) ETag는 선택된 표현에 대한 엔티티 태그를 제공하도록 정의되어 다양한 상황 (예 : PUT 응답)에 적용되는 내용을 명확하게합니다. ( &lt;a href=&quot;#section-2.3&quot;&gt;2.3 절&lt;/a&gt; ) 조건부 요청의 평가 우선 순위가 정의되었습니다. ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e5328b76256fad750a1749c068a42a24ebf54b5b" translate="yes" xml:space="preserve">
          <source>The delta-seconds rule specifies a non-negative integer, representing
   time in seconds.

     delta-seconds  = 1*DIGIT

   A recipient parsing a delta-seconds value and converting it to binary
   form ought to use an arithmetic type of at least 31 bits of
   non-negative integer range.  If a cache receives a delta-seconds
   value greater than the greatest integer it can represent, or if any
   of its subsequent calculations overflows, the cache MUST consider the
   value to be either 2147483648 (2^31) or the greatest positive integer
   it can conveniently represent.

      Note: The value 2147483648 is here for historical reasons,
      effectively represents infinity (over 68 years), and does not need
      to be stored in binary form; an implementation could produce it as
      a canned string if any overflow occurs, even if the calculations
      are performed with an arithmetic type incapable of directly
      representing that number.  What matters here is that an overflow
      be detected and not treated as a negative value in later
      calculations.</source>
          <target state="translated">델타-초 규칙은 시간을 초 단위로 나타내는 음이 아닌 정수를 지정합니다. delta-seconds = 1 * DIGIT delta-seconds 값을 구문 분석하고이를 2 진수 형식으로 변환하는 수신자는 31 비트 이상의 음이 아닌 정수 범위의 산술 유형을 사용해야합니다. 캐시가 나타낼 수있는 최대 정수보다 큰 델타 초 값을 수신하거나 후속 계산이 오버플로되면 캐시는 값을 2147483648 (2 ^ 31) 또는 가장 큰 양의 정수로 간주해야합니다. 말하다. 참고 : 값 2147483648은 역사적인 이유로 여기에 유효하며 무한대 (68 년 이상)를 나타내며 이진 형식으로 저장할 필요가 없습니다. 오버플로가 발생하면 구현에서이를 통조림 문자열로 생성 할 수 있습니다.계산이 해당 숫자를 직접 표현할 수없는 산술 유형으로 수행 되더라도. 여기서 중요한 것은 오버플로가 감지되고 이후 계산에서 음수 값으로 처리되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="462deec90237c01c88236d382d44851e9cb76a0d" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">더 이상 사용되지 않는 HTTP CSP ( &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트에게 콘텐츠 보안 정책 위반 시도를보고하도록 지시합니다. 이러한 위반 보고서는 HTTP POST 요청을 통해 지정된 URI로 전송 된 JSON 문서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fba7a8d872d32f2df3792a939bb1791a1db637" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">더 이상 사용되지 않는 HTTP CSP ( &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;child-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여로드 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 중첩 된 브라우징 컨텍스트에 유효한 소스를 정의합니다 . 작업자의 경우 비준수 요청은 사용자 에이전트에 의해 치명적인 네트워크 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e51c9503c283d705f7c21009451fd7fc25c1eae1" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive instructs the user agent to report attempts to violate the Content Security Policy. These violation reports consist of JSON documents sent via an HTTP POST request to the specified URI.</source>
          <target state="translated">더 이상 사용되지 않는 HTTP CSP ( &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트에게 콘텐츠 보안 정책 위반 시도를보고하도록 지시합니다. 이러한 위반 보고서는 HTTP POST 요청을 통해 지정된 URI로 전송 된 JSON 문서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fb07dc5196edc576bb2b0f9aa70d416b3225ffb6" translate="yes" xml:space="preserve">
          <source>The deprecated HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">더 이상 사용되지 않는 HTTP CSP ( &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;child-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여로드 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 중첩 된 브라우징 컨텍스트에 유효한 소스를 정의합니다 . 작업자의 경우 비준수 요청은 사용자 에이전트에 의해 치명적인 네트워크 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="546d3635c32a2c56e35d6d2aa60b3503528021d5" translate="yes" xml:space="preserve">
          <source>The determination of the best suited representation is made through one of two mechanisms:</source>
          <target state="translated">가장 적합한 표현의 결정은 다음 두 가지 메커니즘 중 하나를 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="1a6be54e0040e3b26e0677bc1c6c4c457e76e04c" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;PUT&lt;/code&gt; and &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;PUT&lt;/code&gt; is idempotent: calling it once or several times successively has the same effect (that is no &lt;em&gt;side&lt;/em&gt; effect), where successive identical &lt;code&gt;POST&lt;/code&gt; may have additional effects, like passing an order several times.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 과 &lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 의 차이점은 PUT 이 dem 등 적이 라는 점입니다. &lt;code&gt;PUT&lt;/code&gt; 을 한 번 또는 여러 번 연속 호출하면 동일한 효과가 있습니다 ( &lt;em&gt;부작용&lt;/em&gt; 이 아님 ). 동일한 동일한 &lt;code&gt;POST&lt;/code&gt; 가 주문을 여러 번 전달하는 것과 같은 추가 효과가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b97e83ad793fdb57539f72e47bc2da06f9dd1d1b" translate="yes" xml:space="preserve">
          <source>The different behaviors are defined by the method of the request used, and by the set of headers used for a precondition:</source>
          <target state="translated">다른 동작은 사용 된 요청 방법과 전제 조건에 사용 된 헤더 세트에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="80097a5c7491102e72da844144491c63c53e8bbd" translate="yes" xml:space="preserve">
          <source>The different operations that can be done with HTTP: &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, and also less common requests like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/trace&quot;&gt;&lt;code&gt;TRACE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP로 수행 할 수있는 다른 작업 : &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/trace&quot;&gt; &lt;code&gt;TRACE&lt;/code&gt; &lt;/a&gt; 와 같은 덜 일반적인 요청 .</target>
        </trans-unit>
        <trans-unit id="e04de4891d47a19965395d893dcab0798dc6bd5e" translate="yes" xml:space="preserve">
          <source>The directive has no effect in and of itself, but only gains meaning in combination with other directives.</source>
          <target state="translated">이 지침은 그 자체로는 영향을 미치지 않지만 다른 지침과 결합하여 의미를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ff5b92c5b8f032668f44bf6f84a3cf1d8c8d5495" translate="yes" xml:space="preserve">
          <source>The directive whose enforcement caused the violation.</source>
          <target state="translated">집행으로 인해 위반이 발생한 지시문.</target>
        </trans-unit>
        <trans-unit id="1e1a37c4f62f3222f090827450cdf97da20610e6" translate="yes" xml:space="preserve">
          <source>The directive whose inforcement caused the violation.</source>
          <target state="translated">강제로 위반을 일으킨 지시문.</target>
        </trans-unit>
        <trans-unit id="9d6fbbcf7c6fc507f3bb84ba69ad161ef0423583" translate="yes" xml:space="preserve">
          <source>The directives are case-insensitive and have an optional argument, that can use both token and quoted-string syntax. Multiple directives are comma-separated.</source>
          <target state="translated">지시문은 대소 문자를 구분하지 않으며 토큰과 따옴표로 묶은 문자열 구문을 모두 사용할 수있는 선택적 인수가 있습니다. 여러 지시문은 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="a323859b4a71cd1636fe58a5af5f7f00fc33a635" translate="yes" xml:space="preserve">
          <source>The directives of the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header can also be applied to &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 의 지시문은 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 에도 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95c774d8f9b5eed24a795ffcdff60addf8cc635d" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">문서 &lt;code&gt;https://example.com/page.html&lt;/code&gt; 는 레퍼러 보내드립니다 &lt;code&gt;https://example.com/&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1d8ec917bef56223b37a5c1500b0656c3dce3b2f" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation header&lt;/code&gt; has opened another window with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. This is for the same reason as above, namely that they can communicate and thus we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation header&lt;/code&gt; 가 있는 문서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 기능이 설정 되지 않은 다른 유사한 방법으로 다른 창을 열었습니다 . 이것은 위와 같은 이유로 통신 할 수 있으므로 프로세스 전환을 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a86ff11f18e76ef15af55380e0e783a222b5261" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in a window which was opened by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; or other similar methods without &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; or the &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; feature being set. These windows must remain in the same process as their opener, as they can communicate, meaning that we cannot allow them to switch processes.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 헤더가 있는 문서 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&amp;lt;a target=&quot;_blank&quot;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;rel=&quot;noopener&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;noopener&quot;&lt;/code&gt; 기능이 설정 되지 않은 다른 유사한 방법 으로 열린 창에로드되었습니다 . 이러한 창은 통신 할 수 있으므로 오프너와 동일한 프로세스를 유지해야합니다. 즉, 프로세스를 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="99747b44d362c4206f7c42047a6a2ac0e7e63002" translate="yes" xml:space="preserve">
          <source>The document with the &lt;code&gt;Large-Allocation&lt;/code&gt; header was loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. Firefox cannot move an iframe into a new process currently, so the document must load in the current process.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 헤더가 있는 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 에로드되었습니다 . Firefox는 현재 iframe을 새 프로세스로 이동할 수 없으므로 문서를 현재 프로세스에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6f2c4f6f26722715e92610972343c812a59e653" translate="yes" xml:space="preserve">
          <source>The domain name of the forwarded server.</source>
          <target state="translated">전달 된 서버의 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="063cfa7dcd340bc61f1b1e374717469ae3ca0edf" translate="yes" xml:space="preserve">
          <source>The domain name of the server (for virtual hosting) or the IP.</source>
          <target state="translated">서버 (가상 호스팅 용) 또는 IP의 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="29fdd0cbf82278b018fbbaf65a8801167da2e6c8" translate="yes" xml:space="preserve">
          <source>The effect of certain methods performed on a resource at the origin
   server might cause one or more existing cache entries to become non-
   transparently invalid. That is, although they might continue to be
   &quot;fresh,&quot; they do not accurately reflect what the origin server would
   return for a new request on that resource. 

   There is no way for the HTTP protocol to guarantee that all such
   cache entries are marked invalid. For example, the request that
   caused the change at the origin server might not have gone through
   the proxy where a cache entry is stored. However, several rules help
   reduce the likelihood of erroneous behavior.

   In this section, the phrase &quot;invalidate an entity&quot; means that the
   cache will either remove all instances of that entity from its
   storage, or will mark these as &quot;invalid&quot; and in need of a mandatory
   revalidation before they can be returned in response to a subsequent
   request.

   Some HTTP methods MUST cause a cache to invalidate an entity. This is
   either the entity referred to by the Request-URI, or by the Location
   or Content-Location headers (if present). These methods are:

      - PUT

      - DELETE

      - POST

   In order to prevent denial of service attacks, an invalidation based
   on the URI in a Location or Content-Location header MUST only be
   performed if the host part is the same as in the Request-URI.

   A cache that passes through requests for methods it does not
   understand SHOULD invalidate any entities referred to by the
   Request-URI.</source>
          <target state="translated">오리진 서버의 자원에서 수행 된 특정 방법의 영향으로 인해 하나 이상의 기존 캐시 항목이 투명하지 않게 될 수 있습니다. 즉, 계속 &quot;새로 고침&quot;상태 일 수 있지만 원본 서버가 해당 리소스에 대한 새 요청에 대해 반환 할 내용을 정확하게 반영하지 않습니다. HTTP 프로토콜이 그러한 모든 캐시 항목이 유효하지 않은 것으로 표시되도록 보장 할 방법은 없습니다. 예를 들어, 원래 서버에서 변경을 야기한 요청이 캐시 항목이 저장된 프록시를 통과하지 않았을 수 있습니다. 그러나 몇 가지 규칙은 잘못된 행동의 가능성을 줄이는 데 도움이됩니다. 이 섹션에서 &quot;엔터티 무효화&quot;라는 문구는 캐시가 해당 엔터티의 모든 인스턴스를 스토리지에서 제거하거나 &quot;invalid &quot;이고 후속 요청에 대한 응답으로 리턴되기 전에 필수 유효성 재확인이 필요합니다. 일부 HTTP 메소드는 캐시로 인해 엔티티를 무효화해야합니다. 이는 Request-URI 또는 ​​Location에서 참조하는 엔티티입니다. 또는 Content-Location 헤더 (있는 경우) 이러한 방법은 다음과 같습니다.-PUT-DELETE-POST 서비스 거부 공격을 방지하려면 Location 또는 Content-Location 헤더의 URI를 기반으로하는 무효화는 호스트 인 경우에만 수행해야합니다. 이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 엔티티를 무효화해야합니다.일부 HTTP 메소드는 캐시가 엔티티를 무효화하도록해야합니다. 이는 Request-URI 또는 ​​Location 또는 Content-Location 헤더 (있는 경우)에 의해 참조되는 엔티티입니다. 이러한 방법은 다음과 같습니다.-PUT-DELETE-POST 서비스 거부 공격을 방지하려면 Location 또는 Content-Location 헤더의 URI를 기반으로하는 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행해야합니다. . 이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 엔티티를 무효화해야합니다 (SHOULD).일부 HTTP 메소드는 캐시가 엔티티를 무효화하도록해야합니다. 이는 Request-URI 또는 ​​Location 또는 Content-Location 헤더 (있는 경우)에 의해 참조되는 엔티티입니다. 이러한 방법은 다음과 같습니다.-PUT-DELETE-POST 서비스 거부 공격을 방지하려면 Location 또는 Content-Location 헤더의 URI를 기반으로하는 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행해야합니다. . 이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 엔티티를 무효화해야합니다 (SHOULD).-PUT-DELETE-POST 서비스 거부 공격을 방지하기 위해 Location 또는 Content-Location 헤더의 URI를 기반으로하는 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행해야합니다. 이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 엔티티를 무효화해야합니다 (SHOULD).-PUT-DELETE-POST 서비스 거부 공격을 방지하기 위해 Location 또는 Content-Location 헤더의 URI를 기반으로하는 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행해야합니다. 이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 엔티티를 무효화해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="96733518a6ff2858b2648088ac99a8575b177584" translate="yes" xml:space="preserve">
          <source>The entity-body (if any) sent with an HTTP request or response is in
   a format and encoding defined by the entity-header fields.

       entity-body    = *OCTET

   An entity-body is only present in a message when a message-body is
   present, as described in &lt;a href=&quot;#section-4.3&quot;&gt;section 4.3&lt;/a&gt;. The entity-body is obtained
   from the message-body by decoding any Transfer-Encoding that might
   have been applied to ensure safe and proper transfer of the message.</source>
          <target state="translated">HTTP 요청 또는 응답과 함께 전송 된 엔티티 본문 (있는 경우)은 엔티티 헤더 필드에 의해 정의 된 형식 및 인코딩 형식입니다. entity-body = * OCTET 엔티티 본문은 &lt;a href=&quot;#section-4.3&quot;&gt;4.3 절에&lt;/a&gt; 설명 된 것처럼 메시지 본문이있을 때만 메시지에 존재 합니다. 엔티티 본문은 메시지의 안전하고 적절한 전송을 보장하기 위해 적용될 수있는 전송 인코딩을 디코딩하여 메시지 본문에서 얻습니다.</target>
        </trans-unit>
        <trans-unit id="446ffc851c64954297de6b7856c3aaf1d655d3fb" translate="yes" xml:space="preserve">
          <source>The entity-length of a message is the length of the message-body
   before any transfer-codings have been applied. &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; defines
   how the transfer-length of a message-body is determined.</source>
          <target state="translated">메시지의 엔티티 길이는 전송 코딩이 적용되기 전의 메시지 본문 길이입니다. &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; 은 메시지 본문의 전송 길이가 결정되는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="430808f49439af4bf0997780d867503fb8ae80aa" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response would have included the headers &lt;a href=&quot;../headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/content-location&quot;&gt;&lt;code&gt;Content-Location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동등한 &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 응답은 &lt;a href=&quot;../headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/content-location&quot;&gt; &lt;code&gt;Content-Location&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더를 포함했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bc6274c604e308e30d74c2f35a4f5fe3102aafe5" translate="yes" xml:space="preserve">
          <source>The exact resource identified by an Internet request is determined by
   examining both the Request-URI and the Host header field.

   An origin server that does not allow resources to differ by the
   requested host MAY ignore the Host header field value when
   determining the resource identified by an HTTP/1.1 request. (But see
   &lt;a href=&quot;#section-19.6.1.1&quot;&gt;section 19.6.1.1&lt;/a&gt; for other requirements on Host support in HTTP/1.1.)

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.</source>
          <target state="translated">인터넷 요청으로 식별되는 정확한 리소스는 Request-URI와 Host header 필드를 모두 검사하여 결정됩니다. 요청 된 호스트와 리소스가 다를 수없는 오리진 서버는 HTTP / 1.1 요청으로 식별 된 리소스를 결정할 때 호스트 헤더 필드 값을 무시할 수 있습니다. (단, &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1 항&lt;/a&gt; 참조 요청 된 호스트 (가상 호스트 또는 가상 호스트 이름이라고도 함)를 기반으로 리소스를 구별하는 오리진 서버는 HTTP /에서 요청 된 리소스를 결정하기 위해 다음 규칙을 사용해야합니다. 1.1 요청 : 1. Request-URI가 absoluteURI 인 경우 호스트는 Request-URI의 일부입니다. 요청의 호스트 헤더 필드 값은 무시해야합니다. 2. Request-URI가 absoluteURI가 아니고 요청에 Host 헤더 필드가 포함 된 경우 호스트는 Host 헤더 필드 값에 의해 결정됩니다. 3. 규칙 1 또는 2에 의해 결정된 호스트가 서버에서 유효한 호스트가 아닌 경우 응답은 400 (잘못된 요청) 오류 메시지 여야합니다. 호스트 헤더 필드가없는 HTTP / 1.0 요청의 수신자는 휴리스틱을 사용할 수 있습니다 (예 :요청되는 정확한 리소스를 확인하기 위해 특정 호스트에 고유 한 URI 경로 검사).</target>
        </trans-unit>
        <trans-unit id="9d41666eafa2d743345a256aece9bd1b22af0421" translate="yes" xml:space="preserve">
          <source>The examples at the end of this document are complete. There is no additional syntax needed to save it into a file and use it. (Of course, the JavaScripts must be edited to reflect your site's domain name and/or subnets.)</source>
          <target state="translated">이 문서의 끝에있는 예제가 완료되었습니다. 파일로 저장하고 사용하는 데 추가 구문이 필요하지 않습니다. 물론 사이트의 도메인 이름 및 / 또는 서브넷을 반영하도록 JavaScript를 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="4044137ba9e4a5b42152e40cc16d223426864ffc" translate="yes" xml:space="preserve">
          <source>The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the content security policy of the document or worker that created it.</source>
          <target state="translated">워커 스크립트의 출처가 전역 적으로 고유 한 식별자 인 경우 (예 : URL에 데이터 체계 또는 BLOB가있는 경우)는 예외입니다. 이 경우 작업자는 문서 또는 문서를 만든 작업자의 콘텐츠 보안 정책을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="25060abe4601e57cbdab7b0fcd2e4d780cee3888" translate="yes" xml:space="preserve">
          <source>The expectation given in an Expect request-header field (see &lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) could not be met by this server, or, if the server is a proxy,
   the server has unambiguous evidence that the request could not be met
   by the next-hop server.</source>
          <target state="translated">Expect 요청 헤더 필드 ( &lt;a href=&quot;#section-14.20&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; 참조 )에 제공된 예상 을이 서버에서 충족 할 수 없거나 서버가 프록시 인 경우 서버는 다음 홉 서버에서 요청을 충족 할 수 없다는 명확한 증거를 가지고 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e89474435ba5cceae8038928368d478ddd9d1651" translate="yes" xml:space="preserve">
          <source>The expected size of the allocation to be performed, in megabytes.</source>
          <target state="translated">수행 될 할당의 예상 크기 (MB).</target>
        </trans-unit>
        <trans-unit id="7187b470d2aaa46b6160031b6302821aeaad40ea" translate="yes" xml:space="preserve">
          <source>The experimental &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; lists configuration data that can be used by the server to select an appropriate response. Valid values are:</source>
          <target state="translated">실험적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt; 는 서버가 적절한 응답을 선택하는 데 사용할 수있는 구성 데이터를 나열합니다. 유효한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c1f313837ffc811f5a2970246c6c36e4cf61462" translate="yes" xml:space="preserve">
          <source>The expiration time is computed as follows:</source>
          <target state="translated">만료 시간은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="85e3770a3188fd2db74ea558b54fe9b64ff2f7c6" translate="yes" xml:space="preserve">
          <source>The expiration time of an entity MAY be specified by the origin
   server using the Expires header (see &lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;). Alternatively,
   it MAY be specified using the max-age directive in a response. When
   the max-age cache-control directive is present in a cached response,
   the response is stale if its current age is greater than the age
   value given (in seconds) at the time of a new request for that
   resource. The max-age directive on a response implies that the
   response is cacheable (i.e., &quot;public&quot;) unless some other, more
   restrictive cache directive is also present.

   If a response includes both an Expires header and a max-age
   directive, the max-age directive overrides the Expires header, even
   if the Expires header is more restrictive. This rule allows an origin
   server to provide, for a given response, a longer expiration time to
   an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
   useful if certain HTTP/1.0 caches improperly calculate ages or
   expiration times, perhaps due to desynchronized clocks.

   Many HTTP/1.0 cache implementations will treat an Expires value that
   is less than or equal to the response Date value as being equivalent
   to the Cache-Control response directive &quot;no-cache&quot;. If an HTTP/1.1
   cache receives such a response, and the response does not include a
   Cache-Control header field, it SHOULD consider the response to be
   non-cacheable in order to retain compatibility with HTTP/1.0 servers.

       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &quot;private&quot; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response. 

   s-maxage
       If a response includes an s-maxage directive, then for a shared
       cache (but not for a private cache), the maximum age specified by
       this directive overrides the maximum age specified by either the
       max-age directive or the Expires header. The s-maxage directive
       also implies the semantics of the proxy-revalidate directive (see
       &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt;), i.e., that the shared cache must not use the
       entry after it becomes stale to respond to a subsequent request
       without first revalidating it with the origin server. The s-
       maxage directive is always ignored by a private cache.

   Note that most older caches, not compliant with this specification,
   do not implement any cache-control directives. An origin server
   wishing to use a cache-control directive that restricts, but does not
   prevent, caching by an HTTP/1.1-compliant cache MAY exploit the
   requirement that the max-age directive overrides the Expires header,
   and the fact that pre-HTTP/1.1-compliant caches do not observe the
   max-age directive.

   Other directives allow a user agent to modify the basic expiration
   mechanism. These directives MAY be specified on a request:

   max-age
      Indicates that the client is willing to accept a response whose
      age is no greater than the specified time in seconds. Unless max-
      stale directive is also included, the client is not willing to
      accept a stale response.

   min-fresh
      Indicates that the client is willing to accept a response whose
      freshness lifetime is no less than its current age plus the
      specified time in seconds. That is, the client wants a response
      that will still be fresh for at least the specified number of
      seconds.

   max-stale
      Indicates that the client is willing to accept a response that has
      exceeded its expiration time. If max-stale is assigned a value,
      then the client is willing to accept a response that has exceeded
      its expiration time by no more than the specified number of
      seconds. If no value is assigned to max-stale, then the client is
      willing to accept a stale response of any age.

   If a cache returns a stale response, either because of a max-stale
   directive on a request, or because the cache is configured to
   override the expiration time of a response, the cache MUST attach a
   Warning header to the stale response, using Warning 110 (Response is
   stale). 

   A cache MAY be configured to return stale responses without
   validation, but only if this does not conflict with any &quot;MUST&quot;-level
   requirements concerning cache validation (e.g., a &quot;must-revalidate&quot;
   cache-control directive).

   If both the new request and the cached entry include &quot;max-age&quot;
   directives, then the lesser of the two values is used for determining
   the freshness of the cached entry for that request.</source>
          <target state="translated">엔터티의 유효 시간이 만료 헤더를 사용하여 원 서버에 의해 지정 될 수있다 (참조 : &lt;a href=&quot;#section-14.21&quot;&gt;14.21 절&lt;/a&gt;). 또는 응답에 max-age 지시문을 사용하여 지정할 수도 있습니다. max-age cache-control 지시문이 캐시 된 응답에있는 경우 현재 기간이 해당 자원에 대한 새 요청시 제공된 기간 값 (초)보다 큰 경우 응답이 오래됩니다. 응답에 대한 max-age 지시문은 더 제한적인 다른 캐시 지시문이없는 한 응답이 캐시 가능함 (즉, &quot;공개&quot;)을 의미합니다. 응답에 Expires 헤더와 max-age 지시문이 모두 포함 된 경우 Expires 헤더가 더 제한적인 경우에도 max-age 지시문이 Expires 헤더를 대체합니다. 이 규칙을 통해 오리진 서버는 지정된 응답에 대해 HTTP / 1.0 캐시보다 HTTP / 1.1 (또는 이후) 캐시에 더 긴 만료 시간을 제공 할 수 있습니다.이것은 특정 HTTP / 1.0 캐시가 아마도 동기화되지 않은 클럭으로 인해 유효 기간 또는 만료 시간을 잘못 계산하는 경우 유용 할 수 있습니다. 많은 HTTP / 1.0 캐시 구현은 응답 날짜 값보다 작거나 같은 Expires 값을 Cache-Control 응답 지시문 &quot;no-cache&quot;와 동등한 것으로 취급합니다. HTTP / 1.1 캐시가 이러한 응답을 수신하고 응답에 Cache-Control 헤더 필드가 포함되어 있지 않으면 HTTP / 1.0 서버와의 호환성을 유지하기 위해 응답을 캐시 할 수없는 것으로 간주해야합니다. 참고 : 오리진 서버는 해당 기능을 이해하지 못하는 이전 캐시를 포함하여 네트워크에서 &quot;private&quot;지시문과 같은 비교적 새로운 HTTP 캐시 제어 기능을 사용할 수 있습니다.오리진 서버는 새 기능을 값이 날짜 값보다 작거나 같은 만료 필드와 결합해야합니다. 이렇게하면 오래된 캐시가 응답을 부적절하게 캐싱하지 못하게됩니다. s-maxage 응답에 s-maxage 지시문이 포함 된 경우 공유 캐시 (개인 캐시는 아님)에 대해이 지시문에 의해 지정된 최대 보존 기간이 max-age 지시문 또는 Expires 헤더에 의해 지정된 최대 보존 기간보다 우선합니다. . s-maxage 지시문은 또한 proxy-revalidate 지시문의 의미를 내포합니다 (참조그런 다음 개인 캐시가 아닌 공유 캐시의 경우이 지정 문에 의해 지정된 최대 보존 기간이 max-age 지정 문 또는 Expires 헤더에 의해 지정된 최대 보존 기간보다 우선합니다. s-maxage 지시문은 또한 proxy-revalidate 지시문의 의미를 내포합니다 (참조그런 다음 개인 캐시가 아닌 공유 캐시의 경우이 지정 문에 의해 지정된 최대 보존 기간이 max-age 지정 문 또는 Expires 헤더에 의해 지정된 최대 보존 기간보다 우선합니다. s-maxage 지시문은 또한 proxy-revalidate 지시문의 의미를 내포합니다 (참조 &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt;), 즉 공유 캐시가 원래 서버로 먼저 유효성을 다시 확인하지 않고 후속 요청에 응답하기 위해 오래 된 후에는 항목을 사용해서는 안됩니다. s-maxage 지시문은 항상 개인 캐시에 의해 무시됩니다. 이 사양을 준수하지 않는 대부분의 이전 캐시는 캐시 제어 지시문을 구현하지 않습니다. HTTP / 1.1 호환 캐시에 의한 캐싱을 제한하지만 방지하지 않는 캐시 제어 지시문을 사용하려는 원 서버는 max-age 지시문이 Expires 헤더를 대체해야한다는 요구 사항과 HTTP 이전의 사실을 이용할 수 있습니다. /1.1 호환 캐시는 max-age 지시문을 준수하지 않습니다. 다른 지시문을 사용하면 사용자 에이전트가 기본 만기 메커니즘을 수정할 수 있습니다. 이러한 지시문은 요청에 따라 지정 될 수 있습니다.max-age 클라이언트가 지정된 시간 (초)을 초과하지 않는 응답을 기꺼이 수락 함을 나타냅니다. max-stale 지시문도 포함되어 있지 않으면 클라이언트는 부실 응답을 기꺼이 수락하지 않습니다. min-fresh 클라이언트가 최신 수명과 현재 시간에 지정된 시간 (초)을 더한 응답을 기꺼이 수락 함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간 (초) 동안 새로운 응답을 원합니다. max-stale 클라이언트가 만료 시간을 초과 한 응답을 기꺼이 수락 함을 나타냅니다. max-stale에 값이 할당되면그러면 클라이언트는 만료 시간을 지정된 초 수만큼 초과 한 응답을 기꺼이 수락합니다. max-stale에 값이 지정되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 수락합니다. 요청에 대한 max-stale 지시문으로 인해 또는 캐시가 응답 만료 시간을 무시하도록 캐시가 캐시에서 오래된 응답을 반환하는 경우 캐시는 경고 110을 사용하여 오래된 응답에 경고 헤더를 첨부해야합니다 (응답이 오래되었습니다). 캐시는 유효성 검사없이 오래된 응답을 반환하도록 구성 될 수 있지만 캐시 유효성 검사와 관련된 &quot;MUST&quot;수준 요구 사항 (예 : &quot;must-revalidate&quot;캐시 제어 지시문)과 충돌하지 않는 경우에만 구성 할 수 있습니다.새 요청과 캐시 된 항목 모두에 &quot;max-age&quot;지시문이 포함 된 경우 두 값 중 작은 값이 해당 요청에 대한 캐시 된 항목의 최신 성을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3993f15811c93a67d3ec5d0d92f253093020cabe" translate="yes" xml:space="preserve">
          <source>The features include:</source>
          <target state="translated">기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c73ddc20bc1d282151f4ec68084bc6164972b4dc" translate="yes" xml:space="preserve">
          <source>The file consists of a function called &lt;code&gt;FindProxyForURL&lt;/code&gt;. The example below will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">파일은 &lt;code&gt;FindProxyForURL&lt;/code&gt; 이라는 함수로 구성됩니다 . 아래 예제는 내부 DNS 서버가 설정되어 내부 호스트 이름 만 확인할 수있는 환경에서 작동하며, 확인할 수없는 호스트에 대해서만 프록시를 사용하는 것이 목표입니다.</target>
        </trans-unit>
        <trans-unit id="ce8df497bc37efd316beaa79c7a58e65942dbc0b" translate="yes" xml:space="preserve">
          <source>The file firefox.js passes preference names and values to the pref() function. For example:</source>
          <target state="translated">firefox.js 파일은 환경 설정 이름과 값을 pref () 함수에 전달합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b3cb207abfe237d7efa942f6a8fef274b6ca29a" translate="yes" xml:space="preserve">
          <source>The final block is a data block, which contains the optional data.</source>
          <target state="translated">마지막 블록은 선택적 데이터를 포함하는 데이터 블록입니다.</target>
        </trans-unit>
        <trans-unit id="82d496b5f7760cf0c1c546e8d1a28c4fc534cf8d" translate="yes" xml:space="preserve">
          <source>The final block is an optional data block, which may contain further data mainly used by the POST method.</source>
          <target state="translated">마지막 블록은 선택적 데이터 블록이며, 주로 POST 방법에서 사용하는 추가 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477b8ca70c884ab091243f614c5d70eeeab51fd8" translate="yes" xml:space="preserve">
          <source>The final part of the request is its body. Not all requests have one: requests fetching resources, like &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with &lt;code&gt;POST&lt;/code&gt; requests (containing HTML form data).</source>
          <target state="translated">요청의 마지막 부분은 본문입니다. 모든 요청에 ​​하나만있는 것은 아닙니다. &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; , DELETE 또는 OPTIONS 와 같은 리소스를 가져 오는 요청에는 일반적으로 필요하지 않습니다. 일부 요청은 &lt;code&gt;POST&lt;/code&gt; 요청 (HTML 양식 데이터 포함) 의 경우와 같이 업데이트하기 위해 서버로 데이터를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a7bd7db1836bd8959bc7e0d7e27321e685761ca2" translate="yes" xml:space="preserve">
          <source>The final recipient of the request should reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;message/http&lt;/code&gt;. The final recipient is either the origin server or the first server to receive a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt; value of 0 in the request.</source>
          <target state="translated">요청의 최종 수신자는 아래에 설명 된 일부 필드를 제외하고 수신 한 메시지를 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;message/http&lt;/code&gt; 인 200 (OK) 응답의 메시지 본문으로 클라이언트에 다시 반영해야합니다 . 최종 수신자는 원래 서버이거나 요청에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt; 값 0 을받는 첫 번째 서버 입니다.</target>
        </trans-unit>
        <trans-unit id="ec16b4ce596bd77bc971178dc4e6a8899896e2cb" translate="yes" xml:space="preserve">
          <source>The first 40 characters of the inline script, event handler, or style that caused the violation.</source>
          <target state="translated">위반을 일으킨 인라인 스크립트, 이벤트 핸들러 또는 스타일의 처음 40 자</target>
        </trans-unit>
        <trans-unit id="30b3cc93d61693c25216e29c69eecc3a87dde174" translate="yes" xml:space="preserve">
          <source>The first line contains a request method followed by its parameters:</source>
          <target state="translated">첫 번째 줄에는 요청 메소드와 그 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce913e069990d2088bde8127d92db28b9c6593c" translate="yes" xml:space="preserve">
          <source>The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code and its
   associated textual phrase, with each element separated by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</source>
          <target state="translated">응답 메시지의 첫 번째 줄은 상태 버전으로, 프로토콜 버전과 숫자 상태 코드 및 관련 텍스트 문구로 구성되며 각 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다. Status-Line = HTTP 버전 SP 상태 코드 SP 이유 문구 CRLF</target>
        </trans-unit>
        <trans-unit id="34ccf4b003a3910dffb0926766714dc4dd11b6eb" translate="yes" xml:space="preserve">
          <source>The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another
   space, a possibly empty textual phrase describing the status code,
   and ending with CRLF.

     status-line = HTTP-version SP status-code SP reason-phrase CRLF

   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request.  The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt; for information about the semantics of
   status codes, including the classes of status code (indicated by the
   first digit), the status codes defined by this specification,
   considerations for the definition of new status codes, and the IANA
   registry.

     status-code    = 3DIGIT

   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were
   more frequently used with interactive text clients.  A client SHOULD
   ignore the reason-phrase content.

     reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</source>
          <target state="translated">응답 메시지의 첫 번째 줄은 프로토콜 버전, 공백 (SP), 상태 코드, 다른 공간, 상태 코드를 설명하는 빈 텍스트 문구 및 CRLF로 끝나는 상태 줄입니다. status-line = HTTP 버전 SP 상태 코드 SP 이유 문구 CRLF status-code 요소는 서버가 클라이언트의 해당 요청을 이해하고 만족시키려는 시도의 결과를 설명하는 3 자리 정수 코드입니다. 나머지 응답 메시지는 해당 상태 코드에 대해 정의 된 의미론에 비추어 해석됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]의 섹션 6&lt;/a&gt; 참조상태 코드의 클래스 (첫 번째 숫자로 표시),이 사양으로 정의 된 상태 코드, 새 상태 코드의 정의에 대한 고려 사항 및 IANA 레지스트리를 포함하여 상태 코드의 의미에 대한 정보. status-code = 3DIGIT reason-phrase 요소는 주로 대화 형 텍스트 클라이언트에서 더 자주 사용되는 이전 인터넷 응용 프로그램 프로토콜에 의존하지 않고 숫자 상태 코드와 관련된 텍스트 설명을 제공하기위한 목적으로 만 존재합니다. 클라이언트는 이유 문구 내용을 무시해야합니다. 이유 문구 = * (HTAB / SP / VCHAR / obs-text)</target>
        </trans-unit>
        <trans-unit id="83e62459a880f4c5afe20430a0ef17081dbab746" translate="yes" xml:space="preserve">
          <source>The first line, the &lt;em&gt;status line&lt;/em&gt;, consists of an acknowledgment of the HTTP version used, followed by a status request (and its brief meaning in human-readable text).</source>
          <target state="translated">첫 번째 줄인 &lt;em&gt;status line&lt;/em&gt; 은 사용 된 HTTP 버전에 대한 승인과 상태 요청 (및 사람이 읽을 수있는 텍스트의 간략한 의미)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae099fefbfad76e3dc77d1838fdc9c03df6ff4f" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is always &lt;code&gt;form-data&lt;/code&gt;. Additional parameters are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">HTTP 컨텍스트의 첫 번째 매개 변수는 항상 &lt;code&gt;form-data&lt;/code&gt; 입니다. 추가 매개 변수는 대소 문자를 구분하지 않으며 &lt;code&gt;'='&lt;/code&gt; 기호 뒤에 인용 문자열 구문을 사용하는 인수를 갖습니다 . 여러 매개 변수는 세미콜론 ( &lt;code&gt;';'&lt;/code&gt; )으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe827f01fdf9c514ffb2a7b42770124ec3e2359" translate="yes" xml:space="preserve">
          <source>The first parameter in the HTTP context is either &lt;code&gt;inline&lt;/code&gt; (default value, indicating it can be displayed inside the Web page, or as the Web page) or &lt;code&gt;attachment&lt;/code&gt; (indicating it should be downloaded; most browsers presenting a 'Save as' dialog, prefilled with the value of the &lt;code&gt;filename&lt;/code&gt; parameters if present).</source>
          <target state="translated">HTTP 컨텍스트의 첫 번째 매개 변수는 &lt;code&gt;inline&lt;/code&gt; (기본값은 웹 페이지 내에 표시되거나 웹 페이지로 표시 될 수 있음을 나타냄) 또는 &lt;code&gt;attachment&lt;/code&gt; (다운로드해야 함을 나타냅니다. 대부분의 브라우저는 '다른 이름으로 저장'대화 상자가 사전 채워짐 &lt;code&gt;filename&lt;/code&gt; 매개 변수 값이있는 경우).</target>
        </trans-unit>
        <trans-unit id="ce28a16fac0b2bc02f8a3ca48fc7babba03c0403" translate="yes" xml:space="preserve">
          <source>The first time your site is accessed using HTTPS and it returns the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, the browser records this information, so that future attempts to load the site using HTTP will automatically use HTTPS instead.</source>
          <target state="translated">HTTPS를 사용하여 사이트에 처음 액세스하고 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 헤더를 반환하면 브라우저는이 정보를 기록하므로 나중에 HTTP를 사용하여 사이트를로드하려고하면 HTTPS가 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36a8e92e02612d193d4f4ea4835f02c068455028" translate="yes" xml:space="preserve">
          <source>The first upload of a resource is an edge case of the previous. Like any update of a resource, it is subject to a race condition if two clients try to perform at the similar times. To prevent this, conditional requests can be used: by adding &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; with the special value of &lt;code&gt;'*'&lt;/code&gt;, representing any etag. The request will succeed, only if the resource didn't exist before:</source>
          <target state="translated">리소스의 첫 번째 업로드는 이전의 가장 큰 경우입니다. 리소스 업데이트와 마찬가지로 두 클라이언트가 비슷한 시간에 수행하려고하면 경쟁 조건이 적용됩니다. 이를 방지하기 위해 조건부 요청을 사용할 수 있습니다 . etag를 나타내는 특수 값 &lt;code&gt;'*'&lt;/code&gt; 로&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 를 추가 하면 됩니다. 리소스가 이전에 존재하지 않은 경우에만 요청이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="e91a68110a72942d37f1a34f4d6ec060c7f1376a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 이 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485ecd6f231e048f16edaf6c17d5ccf5b1cb2429" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 이 차단되어로드되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="63f869c917c180bee24835b4bf30ef56f30bb133" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; is blocked and won't load:</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 가 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bd3ab38162171d160acbfdeffc4df3e7c14c331" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af33c524092efa46a9bc5e3da17591ca7a2dfed3" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are blocked and won't load:</source>
          <target state="translated">다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="613e74e65709c0a5a289fb76a70fe4d72cdf7122" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc90632d3761290b941626aad0314e6c02769a1e" translate="yes" xml:space="preserve">
          <source>The following Java code sets CORS response headers. Notice how the code sets the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value to the same value as the &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">다음 Java 코드는 CORS 응답 헤더를 설정합니다. 코드가 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 값을 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 요청 헤더 와 동일한 값으로 설정하는 방법에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="94255118119d25126914c95e1d87df4cff5fadb0" translate="yes" xml:space="preserve">
          <source>The following are all valid JavaScript MIME types according to the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME 스니핑 표준&lt;/a&gt; 에 따른 모든 유효한 JavaScript MIME 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="81369c9bb8b849666e492d12305470dc3ab76aac" translate="yes" xml:space="preserve">
          <source>The following command will extract the Base64 encoded information for a website.</source>
          <target state="translated">다음 명령은 웹 사이트에 대한 Base64 인코딩 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="386280384a9e1e846fc762abee1b45fa8528a42c" translate="yes" xml:space="preserve">
          <source>The following commands will help you extract the Base64 encoded information from a key file, a certificate signing request, or a certificate.</source>
          <target state="translated">다음 명령은 키 파일, 인증서 서명 요청 또는 인증서에서 Base64 인코딩 정보를 추출하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="509ad4a6b5b143b75559c314a8f0880abef072e8" translate="yes" xml:space="preserve">
          <source>The following connections are blocked and won't load:</source>
          <target state="translated">다음 연결이 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41623b548495875f7a172266a4ccbfc78a26525c" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     RWS           = &amp;lt;RWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     comment       = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;comment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     partial-URI   = &amp;lt;partial-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt; 

     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">다음 핵심 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234] 부록 B.1에&lt;/a&gt; 정의 된대로 참조로 포함됩니다 . ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어), DIGIT (10 진수 0-9) , DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), HTAB (가로 탭), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR ( 보이는 US-ASCII 문자). 아래 규칙은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의되어 있습니다 . BWS = &amp;lt;BWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 3.2.3 섹션&lt;/a&gt; &amp;gt; RWS = &amp;lt;RWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230]&lt;/a&gt; 참조 , 3.2.3 절 &amp;gt; URI 참조 = &amp;lt;URI 참조, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;2.7 절 [RFC7230]&lt;/a&gt; 참조&amp;gt; 절대 URI = &amp;lt;절대 URI, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;섹션 2.7 [RFC7230]&lt;/a&gt; 참조 &amp;gt; 주석 = &amp;lt;코멘트 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;, 섹션 3.2.6&lt;/a&gt; 참조 [RFC7230] 참조 &amp;gt; field-name = &amp;lt;comment &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;, 섹션 [RFC7230], 섹션 3.2 참조&lt;/a&gt; &amp;gt; URI = &amp;lt;partial-URI, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], 섹션 2.7 참조&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt; &amp;gt; token = &amp;lt;token, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c0942541cf8ef1d402170eff33c293ebc3cc0b4" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   Note that all rules derived from token are to be compared
   case-insensitively, like range-unit and acceptable-ranges.

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS        = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     token      = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date  = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;
     entity-tag = &amp;lt;entity-tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], Section&amp;nbsp;2.3&lt;/a&gt;&amp;gt;</source>
          <target state="translated">다음 핵심 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234] 부록 B.1에&lt;/a&gt; 정의 된대로 참조로 포함됩니다 . ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어), DIGIT (10 진수 0-9) , DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시적 인 US-ASCII 문자) ). 토큰에서 파생 된 모든 규칙은 범위 단위 및 허용 범위와 같이 대소 문자를 구분하지 않고 비교됩니다. 아래 규칙은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의되어 있습니다 . OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3&lt;/a&gt; &amp;gt; 토큰 = &amp;lt;토큰, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 3.2.6 단원 참조&lt;/a&gt; &amp;gt; 아래 규칙은 다른 부분에서 정의됩니다. HTTP -date = &amp;lt;HTTP-date, 참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], 섹션 7.1.1.1&lt;/a&gt; &amp;gt; entity-tag = &amp;lt;entity-tag, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232], 섹션 2.3&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb819c2dfc07123960d680297955265860aae754" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     BWS           = &amp;lt;BWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;</source>
          <target state="translated">다음 핵심 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234] 부록 B.1에&lt;/a&gt; 정의 된대로 참조로 포함됩니다 . ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어), DIGIT (10 진수 0-9) , DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시적 인 US-ASCII 문자) ). 아래 규칙은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의되어 있습니다 . BWS = &amp;lt;BWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3&lt;/a&gt; &amp;gt; OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3 참조&lt;/a&gt; &amp;gt; 인용 문자열 = &amp;lt;quoted-string, 참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6&lt;/a&gt; &amp;gt; 토큰 = &amp;lt;토큰, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6 참조&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="af8790fbb4ed65c1be1cf1a4b4f340c4491c4f9d" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     field-name    = &amp;lt;field-name, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     quoted-string = &amp;lt;quoted-string, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;
     token         = &amp;lt;token, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;
     pseudonym     = &amp;lt;pseudonym, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230], Section&amp;nbsp;5.7.1&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;uri-host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], Section&amp;nbsp;2.7&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">다음 핵심 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234] 부록 B.1에&lt;/a&gt; 정의 된대로 참조로 포함됩니다 . ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어), DIGIT (10 진수 0-9) , DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시적 인 US-ASCII 문자) ). 아래 규칙은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의되어 있습니다 . OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3 참조&lt;/a&gt; &amp;gt; field-name = &amp;lt;field-name &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;, 섹션 [RFC7230], 섹션 3.2 참조&lt;/a&gt; &amp;gt; quoted-string = &amp;lt;quoted-string 참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;섹션 3.2.6 [RFC7230]을&lt;/a&gt; &amp;gt; 토큰 = &amp;lt;토큰 참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6&lt;/a&gt; &amp;gt; 포트 = &amp;lt;포트,보다&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt; [RFC7230], 섹션 2.7&lt;/a&gt; &amp;gt; 가명 = &amp;lt;가명 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;, 섹션 5.7.1 참조&lt;/a&gt;&amp;gt; uri-host = &amp;lt;uri-host, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230], 섹션 2.7 참조&lt;/a&gt; &amp;gt; 아래 규칙은 다른 부분에 정의되어 있습니다. HTTP-date = &amp;lt;HTTP-date &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;, 섹션 7.1.1.1 참조&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="bde3f83ba4fdea6e1247cb746890cdb2c25a10cd" translate="yes" xml:space="preserve">
          <source>The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;Appendix&amp;nbsp;B.1 of [RFC5234]&lt;/a&gt;: ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any
   8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII
   character).

   The rules below are defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]:

     OWS           = &amp;lt;OWS, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     obs-text      = &amp;lt;obs-text, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.6&lt;/a&gt;&amp;gt;

   The rules below are defined in other parts:

     HTTP-date     = &amp;lt;HTTP-date, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231], Section&amp;nbsp;7.1.1.1&lt;/a&gt;&amp;gt;</source>
          <target state="translated">다음 핵심 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234] 부록 B.1에&lt;/a&gt; 정의 된대로 참조로 포함됩니다 . ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어), DIGIT (10 진수 0-9) , DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시적 인 US-ASCII 문자) ). 아래 규칙은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의되어 있습니다 . OWS = &amp;lt;OWS, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.3&quot;&gt;[RFC7230], 섹션 3.2.3 참조&lt;/a&gt; &amp;gt; obs-text = &amp;lt;obs-text, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230], 섹션 3.2.6&lt;/a&gt; &amp;gt; 아래 규칙은 다음에 정의되어 있습니다. 다른 부분 : HTTP-date = &amp;lt;HTTP-date &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;, 섹션 7.1.1.1&lt;/a&gt; 참조 [RFC7231] &amp;gt;</target>
        </trans-unit>
        <trans-unit id="8084bb34a7c23d1e9e812c435cfc66928e96c80b" translate="yes" xml:space="preserve">
          <source>The following example shows the same copy operation being performed,
   but with the Overwrite header set to &quot;F.&quot; A response of 412
   (Precondition Failed) is returned because the destination URL is
   already mapped to a resource.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html
     Overwrite: F 

   &amp;gt;&amp;gt;Response

     HTTP/1.1 412 Precondition Failed</source>
          <target state="translated">다음 예는 동일한 복사 작업이 수행되지만 덮어 쓰기 헤더가 &quot;F&quot;로 설정된 상태를 보여줍니다. 대상 URL이 이미 리소스에 매핑 되었기 때문에 412 (사전 조건 실패) 응답이 반환됩니다. &amp;gt;&amp;gt; 복사 요청 /~fielding/index.html HTTP / 1.1 호스트 : www.example.com 대상 : http://www.example.com/users/f/fielding/index.html 덮어 쓰기 : F &amp;gt;&amp;gt; 응답 HTTP / 1.1 412 전제 조건 실패</target>
        </trans-unit>
        <trans-unit id="7acf3453f8031411e0b71e19213cb90990e8cb3a" translate="yes" xml:space="preserve">
          <source>The following example specifies enforcement of Certificate Transparency for 24 hours and reports violations to foo.example.</source>
          <target state="translated">다음 예제는 24 시간 동안 인증서 투명성의 적용을 지정하고 위반을 foo.example에보고합니다.</target>
        </trans-unit>
        <trans-unit id="94b32d3de424f684aa74d5609ddab84fb75dd925" translate="yes" xml:space="preserve">
          <source>The following font resource loading is blocked and won't load:</source>
          <target state="translated">다음 글꼴 리소스로드가 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="354531c678665d3125c2ef3c1112692d5b4fe889" translate="yes" xml:space="preserve">
          <source>The following headers are involved in the WebSocket upgrade process. Other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, the rest are generally optional or handled for you by the browser and server when they're talking to each other.</source>
          <target state="translated">다음 헤더는 WebSocket 업그레이드 프로세스와 관련이 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 이외 헤더 나머지는 일반적으로 브라우저와 서버가 서로 대화 할 때 선택 사항이거나 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bb8db65f4711517dd753e17a8cd07fb37a9810cb" translate="yes" xml:space="preserve">
          <source>The following is an example of a request that will be preflighted.</source>
          <target state="translated">다음은 프리 플라이트 될 요청의 예입니다.</target>
        </trans-unit>
        <trans-unit id="6166015c4ad889984ba227b210f2740bda4740b4" translate="yes" xml:space="preserve">
          <source>The following line with your relevant key information (pin-sha256=&quot;...&quot; fields) will enable HPKP on lighttpd.</source>
          <target state="translated">관련 키 정보 (pin-sha256 = &quot;...&quot;필드)가있는 다음 줄은 lighttpd에서 HPKP를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2ae960e358cb5178ea4e99046d9b426fbe630cc9" translate="yes" xml:space="preserve">
          <source>The following list summarizes HTTP headers by their usage category. For an alphabetical list, see the navigation on the left side.</source>
          <target state="translated">다음 목록은 사용 카테고리별로 HTTP 헤더를 요약 한 것입니다. 알파벳순 목록은 왼쪽 탐색을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb997113b54cfb7ed6ae28493a5cfaf71d6f764b" translate="yes" xml:space="preserve">
          <source>The following request body for a PROPFIND method is illegal.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
       &amp;lt;D:propname/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The definition of the propfind element only allows for the allprop or
   the propname element, not both.  Thus, the above is an error and must
   be responded to with a 400 (Bad Request).

   Imagine, however, that a server wanted to be &quot;kind&quot; and decided to
   pick the allprop element as the true element and respond to it.  A
   client running over a bandwidth limited line who intended to execute
   a propname would be in for a big surprise if the server treated the
   command as an allprop.

   Additionally, if a server were lenient and decided to reply to this
   request, the results would vary randomly from server to server, with
   some servers executing the allprop directive, and others executing
   the propname directive.  This reduces interoperability rather than
   increasing it.</source>
          <target state="translated">PROPFIND 메소드에 대한 다음 요청 본문은 유효하지 않습니다. &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : allprop /&amp;gt; &amp;lt;D : propname /&amp;gt; &amp;lt;/ D : propfind&amp;gt; 정의 propfind 요소 중 하나만 allprop 또는 propname 요소 만 허용합니다. 따라서 위의 오류는 400이며 잘못된 요청 (400)으로 응답해야합니다. 그러나 서버가 &quot;종류&quot;가되기를 원했고 allprop 요소를 실제 요소로 선택하여 이에 응답하기로 결정했다고 상상해보십시오. propname을 실행하려는 대역폭 제한 라인을 통해 실행되는 클라이언트는 서버가 명령을 allprop로 취급하면 놀라 울 것입니다. 또한 서버가 관대하고이 요청에 응답하기로 결정한 경우,일부 서버는 allprop 지시문을 실행하고 다른 서버는 propname 지시문을 실행하는 결과는 서버마다 무작위로 달라집니다. 이렇게하면 상호 운용성이 향상되지 않고 감소합니다.</target>
        </trans-unit>
        <trans-unit id="afe5b5f9e1c6d81603d280407ff45a5bd4095d77" translate="yes" xml:space="preserve">
          <source>The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in &lt;a href=&quot;#section-3.4.1&quot;&gt;Section 3.4.1&lt;/a&gt;.  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt; |
   | Accept-Charset    | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt; |
   | Accept-Encoding   | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   | Accept-Language   | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">다음 요청 헤더 필드는 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1 절에&lt;/a&gt; 정의 된대로 응답 에이전트의 사전 협상에 참여하기 위해 사용자 에이전트에 의해 전송됩니다 . 이러한 필드에 전송 된 환경 설정은 대상 자원의 표현, 오류 또는 처리 상태의 표현, 프로토콜 내에 나타날 수있는 기타 텍스트 문자열을 포함하여 응답의 모든 컨텐츠에 적용됩니다. + ------------------- + --------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + --------------- + | 수락 | &lt;a href=&quot;#section-5.3.2&quot;&gt;섹션 5.3.2&lt;/a&gt; | | 수락 문자 | &lt;a href=&quot;#section-5.3.3&quot;&gt;섹션 5.3.3&lt;/a&gt; | | 수락 인코딩 | &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; | | 수락 언어 | &lt;a href=&quot;#section-5.3.5&quot;&gt;섹션 5.3.5&lt;/a&gt;| + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="b87d45a3e8d029bf68f7eb8d73ed362bd6af38eb" translate="yes" xml:space="preserve">
          <source>The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | Referer           | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | User-Agent        | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   +-------------------+---------------+</source>
          <target state="translated">다음 요청 헤더 필드는 사용자, 사용자 에이전트 및 요청 뒤에있는 자원에 대한 정보를 포함하여 요청 컨텍스트에 대한 추가 정보를 제공합니다. + ------------------- + --------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + --------------- + | 보낸 사람 | &lt;a href=&quot;#section-5.5.1&quot;&gt;섹션 5.5.1&lt;/a&gt; | | 리퍼러 | &lt;a href=&quot;#section-5.5.2&quot;&gt;섹션 5.5.2&lt;/a&gt; | | 사용자 에이전트 | &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; | + ------------------- + --------------- +</target>
        </trans-unit>
        <trans-unit id="0c838a2a126c25c04d28baea5afb318e21afbddd" translate="yes" xml:space="preserve">
          <source>The following rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
   is defined by ANSI X3.4-1986 [&lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. 

       OCTET          = &amp;lt;any 8-bit sequence of data&amp;gt;
       CHAR           = &amp;lt;any US-ASCII character (octets 0 - 127)&amp;gt;
       UPALPHA        = &amp;lt;any US-ASCII uppercase letter &quot;A&quot;..&quot;Z&quot;&amp;gt;
       LOALPHA        = &amp;lt;any US-ASCII lowercase letter &quot;a&quot;..&quot;z&quot;&amp;gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &amp;lt;any US-ASCII digit &quot;0&quot;..&quot;9&quot;&amp;gt;
       CTL            = &amp;lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&amp;gt;
       CR             = &amp;lt;US-ASCII CR, carriage return (13)&amp;gt;
       LF             = &amp;lt;US-ASCII LF, linefeed (10)&amp;gt;
       SP             = &amp;lt;US-ASCII SP, space (32)&amp;gt;
       HT             = &amp;lt;US-ASCII HT, horizontal-tab (9)&amp;gt;
       &amp;lt;&quot;&amp;gt;            = &amp;lt;US-ASCII double-quote mark (34)&amp;gt;

   HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
   protocol elements except the entity-body (see appendix 19.3 for
   tolerant applications). The end-of-line marker within an entity-body
   is defined by its associated media type, as described in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;.

       CRLF           = CR LF

   HTTP/1.1 header field values can be folded onto multiple lines if the
   continuation line begins with a space or horizontal tab. All linear
   white space, including folding, has the same semantics as SP. A
   recipient MAY replace any linear white space with a single SP before
   interpreting the field value or forwarding the message downstream.

       LWS            = [CRLF] 1*( SP | HT )

   The TEXT rule is only used for descriptive field contents and values
   that are not intended to be interpreted by the message parser. Words
   of *TEXT MAY contain characters from character sets other than ISO-
   8859-1 [&lt;a href=&quot;#ref-22&quot;&gt;22&lt;/a&gt;] only when encoded according to the rules of &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

       TEXT           = &amp;lt;any OCTET except CTLs,
                        but including LWS&amp;gt;

   A CRLF is allowed in the definition of TEXT only as part of a header
   field continuation. It is expected that the folding LWS will be
   replaced with a single SP before interpretation of the TEXT value.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
                      | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | DIGIT 

   Many HTTP/1.1 header field values consist of words separated by LWS
   or special characters. These special characters MUST be in a quoted
   string to be used within a parameter value (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;).

       token          = 1*&amp;lt;any CHAR except CTLs or separators&amp;gt;
       separators     = &quot;(&quot; | &quot;)&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;@&quot;
                      | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &amp;lt;&quot;&amp;gt;
                      | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                      | &quot;{&quot; | &quot;}&quot; | SP | HT

   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing &quot;comment&quot; as part of their field value definition.
   In all other fields, parentheses are considered part of the field
   value.

       comment        = &quot;(&quot; *( ctext | quoted-pair | comment ) &quot;)&quot;
       ctext          = &amp;lt;any TEXT excluding &quot;(&quot; and &quot;)&quot;&amp;gt;

   A string of text is parsed as a single word if it is quoted using
   double-quote marks.

       quoted-string  = ( &amp;lt;&quot;&amp;gt; *(qdtext | quoted-pair ) &amp;lt;&quot;&amp;gt; )
       qdtext         = &amp;lt;any TEXT except &amp;lt;&quot;&amp;gt;&amp;gt;

   The backslash character (&quot;\&quot;) MAY be used as a single-character
   quoting mechanism only within quoted-string and comment constructs.

       quoted-pair    = &quot;\&quot; CHAR</source>
          <target state="translated">기본 구문 분석 구문을 설명하기 위해이 표준에서 다음 규칙이 사용됩니다. US-ASCII 코딩 문자 세트는 ANSI X3.4-1986 [ &lt;a href=&quot;#ref-21&quot;&gt;21&lt;/a&gt;]. OCTET = &amp;lt;모든 8 비트 데이터 시퀀스&amp;gt; CHAR = &amp;lt;모든 US-ASCII 문자 (옥텟 0-127)&amp;gt; UPALPHA = &amp;lt;모든 US-ASCII 대문자 &quot;A&quot;... &quot;Z&quot;&amp;gt; LOALPHA = &amp;lt;모든 US- ASCII 소문자 &quot;a&quot;.. &quot;z&quot;&amp;gt; ALPHA = UPALPHA | LOALPHA DIGIT = &amp;lt;모든 US-ASCII 숫자 &quot;0&quot;.. &quot;9&quot;&amp;gt; CTL = &amp;lt;모든 US-ASCII 제어 문자 (옥텟 0-31) 및 DEL (127)&amp;gt; CR = &amp;lt;US-ASCII CR, 캐리지 리턴 ( 13)&amp;gt; LF = &amp;lt;US-ASCII LF, 줄 바꿈 (10)&amp;gt; SP = &amp;lt;US-ASCII SP, 공간 (32)&amp;gt; HT = &amp;lt;US-ASCII HT, 가로 탭 (9)&amp;gt; &amp;lt; &quot;&amp;gt; = &amp;lt;US-ASCII 큰 따옴표 (34)&amp;gt; HTTP / 1.1은 시퀀스 CR LF를 엔티티 본문을 제외한 모든 프로토콜 요소에 대한 라인 끝 마커로 정의합니다 (허용 응용 프로그램은 부록 19.3 참조). 엔터티 본문 내 줄 끝 마커는 관련 미디어 유형에 의해 정의됩니다.&lt;a href=&quot;#section-3.7&quot;&gt;섹션 3.7&lt;/a&gt; . CRLF = CR LF 연속 행이 공백 또는 가로 탭으로 시작하면 HTTP / 1.1 헤더 필드 값을 여러 행으로 접을 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다. 수신자는 필드 값을 해석하거나 메시지를 다운 스트림으로 전달하기 전에 선형 공백을 단일 SP로 대체 할 수 있습니다. LWS = [CRLF] 1 * (SP | HT) TEXT 규칙은 설명 필드 내용 및 메시지 파서가 해석하지 않는 값에만 사용됩니다. * TEXT의 단어는 ISO-8859 [이외의 문자 세트의 문자가 포함될 수있다 &lt;a href=&quot;#ref-22&quot;&gt;(22)&lt;/a&gt; ]의 규칙에 따라 인코딩 때만 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]. TEXT = &amp;lt;CTL을 제외하고 LWS를 포함하는 모든 OCTET&amp;gt; CRLF는 헤더 필드 연속의 일부로 만 TEXT 정의에 허용됩니다. TEXT 값을 해석하기 전에 폴딩 LWS가 단일 SP로 대체 될 것으로 예상됩니다. 16 진 숫자는 여러 프로토콜 요소에서 사용됩니다. HEX = &quot;A&quot;| &quot;B&quot;| &quot;C&quot;| &quot;D&quot;| &quot;E&quot;| &quot;F&quot;| &quot;a&quot;| &quot;b&quot;| &quot;c&quot;| &quot;d&quot;| &quot;e&quot;| &quot;f&quot;| DIGIT 많은 HTTP / 1.1 헤더 필드 값은 LWS 또는 특수 문자로 구분 된 단어로 구성됩니다.이러한 특수 문자는 매개 변수 값 ( &lt;a href=&quot;#section-3.6&quot;&gt;섹션에 정의 된대로) 내에서 사용하려면 따옴표로 묶은 문자열이어야 합니다.&lt;/a&gt;&lt;a href=&quot;#section-3.6&quot;&gt;이 특수 문자는 매개 변수 값 내에서 사용하기 위해 인용 된 문자열이어야합니다 ( 3.6&lt;/a&gt;). token = 1 * &amp;lt;CTL 또는 구분 기호를 제외한 모든 CHAR&amp;gt; 구분 기호 = &quot;(&quot;| &quot;)&quot;| &quot;&amp;lt;&quot;| &quot;&amp;gt;&quot;| &quot;@&quot;| &quot;,&quot;| &quot;;&quot; | &quot;:&quot;| &quot;\&quot;| &amp;lt; &quot;&amp;gt; |&quot;/ &quot;|&quot;[ &quot;|&quot;] &quot;|&quot;? &quot;|&quot;= &quot;|&quot;{ &quot;|&quot;} &quot;| SP | HT 주석 텍스트를 포함하여 일부 HTTP 헤더 필드에 주석을 포함 할 수 있습니다. 주석은 필드 값 정의의 일부로 &quot;comment&quot;를 포함하는 필드에서만 허용됩니다. 다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다. comment = &quot;(&quot;* (ctext | quoted-pair | comment) &quot; ) &quot;ctext = &amp;lt; &quot;(&quot;및 &quot;)&quot;&amp;gt;를 제외한 모든 텍스트 큰 따옴표로 묶은 텍스트 문자열은 작은 단어로 구문 분석됩니다. quoted-string = (&amp;lt; &quot;&amp;gt; * (qdtext | quoted-pair) &amp;lt;&quot;&amp;gt;) qdtext = &amp;lt;&amp;lt; &quot;을 제외한 모든 텍스트 백 슬래시 문자 (&quot;\ &quot;)는 단일 문자 인용 메커니즘으로 만 사용될 수 있습니다 (MAY). 인용 문자열 및 주석 구문 quoted-pair = &quot;\&quot;CHAR) 인용 문자열 및 주석 구조 내에서만 단일 문자 인용 메커니즘으로 사용될 수 있습니다. 인용 쌍 = &quot;\&quot;CHAR) 인용 문자열 및 주석 구조 내에서만 단일 문자 인용 메커니즘으로 사용될 수 있습니다. 인용 쌍 = &quot;\&quot;CHAR</target>
        </trans-unit>
        <trans-unit id="94fbcc64e65bdd0aa51395bd7a796209855490ba" translate="yes" xml:space="preserve">
          <source>The following sections describe the LOCK method, which is used to
   take out a lock of any access type and to refresh an existing lock.
   These sections on the LOCK method describe only those semantics that
   are specific to the LOCK method and are independent of the access
   type of the lock being requested.

   Any resource that supports the LOCK method MUST, at minimum, support
   the XML request and response formats defined herein.

   This method is neither idempotent nor safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">다음 섹션에서는 모든 액세스 유형의 잠금을 해제하고 기존 잠금을 ​​새로 고치는 데 사용되는 LOCK 방법에 대해 설명합니다. LOCK 메소드의이 섹션에서는 LOCK 메소드에 고유하고 요청 된 잠금의 액세스 유형과는 독립적 인 의미만을 설명합니다. LOCK 메소드를 지원하는 모든 자원은 최소한 여기에 정의 된 XML 요청 및 응답 형식을 지원해야합니다. 이 방법은 dem 등하거나 안전하지 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]의 9.1 절&lt;/a&gt; 참조 ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="abeecd90959a6815a68add2040eb84d9caaab598" translate="yes" xml:space="preserve">
          <source>The following status codes are added to those defined in HTTP/1.1
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].</source>
          <target state="translated">다음 상태 코드는 HTTP / 1.1 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된 상태 코드에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b6537480c704b017f88ab825b88e92592b9fb1e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the way major browser vendors indicate that their browsers are running on a mobile device:</source>
          <target state="translated">다음 표는 주요 브라우저 공급 업체가 브라우저가 모바일 장치에서 실행되고 있음을 나타내는 방법을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="84d447214f0a07951f17fa8b161dc87650490e95" translate="yes" xml:space="preserve">
          <source>The format for &lt;code&gt;data&lt;/code&gt; URLs is very simple, but it's easy to forget to put a comma before the &quot;data&quot; segment, or to incorrectly encode the data into base64 format.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL 의 형식 은 매우 간단하지만 &quot;데이터&quot;세그먼트 앞에 쉼표를 넣거나 데이터를 base64 형식으로 잘못 인코딩하는 것을 잊어 버리기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d7ba8c7d265a4018beb38838d1f5b22bd2735b93" translate="yes" xml:space="preserve">
          <source>The format problem might be due to the request's indicated &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, or as a result of inspecting the data directly.</source>
          <target state="translated">형식 문제는 요청에 표시된 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; 또는 데이터를 직접 검사 한 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd102c31666a18bf73247dbe968b9437a20ca82e" translate="yes" xml:space="preserve">
          <source>The forwarded protocol (http or https).</source>
          <target state="translated">전달 된 프로토콜 (http 또는 https).</target>
        </trans-unit>
        <trans-unit id="5ad0214c4fd4e5e15f5b8411cc3e3ac722291550" translate="yes" xml:space="preserve">
          <source>The framework for HTTP Authentication is now defined by this
   document, rather than &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.

   The &quot;realm&quot; parameter is no longer always required on challenges;
   consequently, the ABNF allows challenges without any auth parameters.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   The &quot;token68&quot; alternative to auth-param lists has been added for
   consistency with legacy authentication schemes such as &quot;Basic&quot;.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   This specification introduces the Authentication Scheme Registry,
   along with considerations for new authentication schemes.
   (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)</source>
          <target state="translated">HTTP 인증 프레임 워크는 이제 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617이 아니라이&lt;/a&gt; 문서에서 정의됩니다 . &quot;realm&quot;매개 변수는 더 이상 항상 도전에 필요하지 않습니다. 결과적으로 ABNF는 인증 매개 변수없이 문제를 허용합니다. ( &lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt; ) auth-param 목록에 대한 &quot;token68&quot;대안이 &quot;Basic&quot;과 같은 레거시 인증 체계와 일치하도록 추가되었습니다. ( &lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt; )이 사양에서는 새로운 인증 체계에 대한 고려와 함께 인증 체계 레지스트리를 소개합니다. ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e81a90a6f49982e97eba3c1cef4effa451cb6b9f" translate="yes" xml:space="preserve">
          <source>The freshness lifetime is calculated based on several headers. If a &quot;&lt;code&gt;Cache-control: max-age=N&lt;/code&gt;&quot; header is specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the case, it is checked if an &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header is present. If an &lt;code&gt;Expires&lt;/code&gt; header exists, then its value minus the value of the &lt;a href=&quot;headers/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header determines the freshness lifetime. Finally, if neither header is present, look for a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; header. If this header is present, then the cache's freshness lifetime is equal to the value of the &lt;code&gt;Date&lt;/code&gt; header minus the value of the &lt;code&gt;Last-modified&lt;/code&gt; header divided by 10.</source>
          <target state="translated">신선도 수명은 여러 헤더를 기반으로 계산됩니다. &quot; &lt;code&gt;Cache-control: max-age=N&lt;/code&gt; &quot;헤더가 지정된 경우, 신선도 수명은 N과 같습니다.이 헤더가 존재하지 않는 경우 (종종의 경우) &lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; 헤더가 있는지 확인합니다 . 이 경우 &lt;code&gt;Expires&lt;/code&gt; 헤더는 그 값을 뺀 값, 존재 &lt;a href=&quot;headers/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 헤더는 신선도 수명을 결정한다. 마지막으로, 헤더가 없으면 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 헤더를 찾으십시오 . 이 헤더가 있으면 캐시의 최신 상태 수명이 &lt;code&gt;Date&lt;/code&gt; 헤더 값에서 &lt;code&gt;Last-modified&lt;/code&gt; 헤더 값을 10으로 나눈 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="512b0319b59cba71ca1e2c65af451cb82702e739" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework</source>
          <target state="translated">일반적인 HTTP 인증 프레임 워크</target>
        </trans-unit>
        <trans-unit id="2a68383800c3c6e98cc63558c863f3f6c90c1d56" translate="yes" xml:space="preserve">
          <source>The general HTTP authentication framework is used by several authentication schemes. Schemes can differ in security strength and in their availability in client or server software.</source>
          <target state="translated">일반적인 HTTP 인증 프레임 워크는 여러 인증 체계에서 사용됩니다. 구성표는 보안 강도와 클라이언트 또는 서버 소프트웨어에서의 가용성이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047e5f84cba0657a76fe5fac248fc74bc7cb3a90" translate="yes" xml:space="preserve">
          <source>The general principle is that there should be an intuitive or non-breaking way for web developers to detect or handle the case when the feature is disabled. Newly introduced features may have an explicit API to signal the state. Existing features that later integrate with Feature Policy will typically use existing mechanisms. Some approaches include:</source>
          <target state="translated">일반적인 원칙은 웹 개발자가 기능이 비활성화 된 경우 사례를 감지하거나 처리 할 수있는 직관적이거나 중단되지 않는 방법이 있어야한다는 것입니다. 새로 도입 된 기능에는 상태를 알리는 명시 적 API가있을 수 있습니다. 나중에 기능 정책과 통합되는 기존 기능은 일반적으로 기존 메커니즘을 사용합니다. 일부 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4082c3c3add497840e14f2e91b541fe68c6e3568" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; attribute is used on HTML elements to indicate the language of an entire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; document or parts of it.</source>
          <target state="translated">전역 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;lang&lt;/a&gt;&lt;/code&gt; 속성은 HTML 요소에서 사용되어 전체 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; 문서 또는 그 일부의 언어를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="57f2be6c87684acab7e795f4366c55ff9f31e0e7" translate="yes" xml:space="preserve">
          <source>The hostname extracted from the URL. This is only for convenience; it is the same string as between :// and the first : or / after that. The port number is not included in this parameter. It can be extracted from the URL when necessary.</source>
          <target state="translated">URL에서 추출한 호스트 이름입니다. 이것은 단지 편의를위한 것입니다. : //와 첫 번째 : 또는 그 이후의 문자열과 같습니다. 포트 번호는이 매개 변수에 포함되지 않습니다. 필요한 경우 URL에서 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b2c30b24be1ada27dc38a1f58fce4304459396" translate="yes" xml:space="preserve">
          <source>The hostname from the URL (excluding port number).</source>
          <target state="translated">URL의 호스트 이름 (포트 번호 제외).</target>
        </trans-unit>
        <trans-unit id="e2ca20155497fac3b42eb54e6e58c4e5f8398358" translate="yes" xml:space="preserve">
          <source>The hostname from the URL.</source>
          <target state="translated">URL의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7bcc834a08945d7f53b90ecdf02df16cd4cbc61a" translate="yes" xml:space="preserve">
          <source>The identity and the location of resources on the Web are mostly given by a single URL (Uniform Resource Locator, a kind of URI). There are sometimes reasons identity and location are not given by the same URI: HTTP uses a specific HTTP header, &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; when the resource requested wants the client to access it at another location.</source>
          <target state="translated">웹상에서 리소스의 아이덴티티와 위치는 단일 URL (Uniform Resource Locator, 일종의 URI)에 의해 제공됩니다. 동일한 URI에 의해 ID와 위치가 제공되지 않는 이유 가 있습니다. 요청 된 리소스가 클라이언트가 다른 위치에서 클라이언트에 액세스하기를 원하는 경우 HTTP는 특정 HTTP 헤더 &lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c1e67e8b2786357d4a6663a2bc15f636eb756e8f" translate="yes" xml:space="preserve">
          <source>The iframe allow attribute</source>
          <target state="translated">iframe 허용 속성</target>
        </trans-unit>
        <trans-unit id="651815c795a02ba38593f0882335db6d832e2b91" translate="yes" xml:space="preserve">
          <source>The implementation of this prefetching in some browsers allows domain name resolution to occur in parallel with (instead of in serial with) the fetching of actual page content. By doing this, the high-latency domain name resolution process doesn't cause any delay while fetching content.</source>
          <target state="translated">일부 브라우저에서이 프리 페치를 구현하면 실제 페이지 컨텐츠 페치와 병렬로 (대신 직렬로가 아닌) 도메인 이름 확인이 발생할 수 있습니다. 이렇게하면 대기 시간이 긴 도메인 이름 확인 프로세스로 인해 콘텐츠를 가져 오는 동안 지연이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37f7cdd7fd1331a83928f974ca15680ae3b0af4f" translate="yes" xml:space="preserve">
          <source>The inclusion of the &quot;app:draft&quot; element represents a request by the
   client to control the visibility of a Member Resource.  The app:draft
   element MAY be ignored by the server.

   The number of app:draft elements in app:control MUST be zero or one.
   The content of an app:draft element MUST be one of &quot;yes&quot; or &quot;no&quot;.  If
   the element contains &quot;no&quot;, this indicates a client request that the
   Member Resource be made publicly visible.  If the app:draft element
   is not present, then servers that support the extension MUST behave
   as though an app:draft element containing &quot;no&quot; was sent.</source>
          <target state="translated">&quot;app : draft&quot;요소의 포함은 클라이언트가 멤버 자원의 가시성을 제어하도록 요청하는 것을 나타냅니다. app : draft 요소는 서버에서 무시 될 수 있습니다. app : control의 app : draft 요소 수는 0 또는 1이어야합니다. app : draft 요소의 내용은 &quot;yes&quot;또는 &quot;no&quot;중 하나 여야합니다. 요소에 &quot;no&quot;가 포함 된 경우 이는 구성원 자원이 공개되도록 클라이언트 요청을 나타냅니다. app : draft 요소가 없으면 확장을 지원하는 서버는 &quot;no&quot;를 포함하는 app : draft 요소가 전송 된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff9cab94e579758912dbc34c45bff0d14c466bcf" translate="yes" xml:space="preserve">
          <source>The information below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">아래 정보는 MDN의 GitHub ( &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; ) 에서 가져 왔습니다 .</target>
        </trans-unit>
        <trans-unit id="89f19b58853606bc26aa103de926f33f0228de47" translate="yes" xml:space="preserve">
          <source>The information by the client is quite verbose (HTTP/2 header compression mitigates this problem) and a privacy risk (HTTP fingerprinting)</source>
          <target state="translated">클라이언트의 정보는 매우 장황하며 (HTTP / 2 헤더 압축으로이 문제를 완화) 개인 정보 위험 (HTTP 지문)</target>
        </trans-unit>
        <trans-unit id="88371e0de52c1ea4ce93bd3a2050533f57795785" translate="yes" xml:space="preserve">
          <source>The information shown below has been pulled from MDN's GitHub (&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt;).</source>
          <target state="translated">아래 표시된 정보는 MDN의 GitHub ( &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;https://github.com/mdn/browser-compat-data&lt;/a&gt; ) 에서 가져 왔습니다 .</target>
        </trans-unit>
        <trans-unit id="3cf93a0d825024937b080186cbf88ae3afde9002" translate="yes" xml:space="preserve">
          <source>The initial range unit registry contains the registrations below:

   +-------------+---------------------------------------+-------------+
   | Range Unit  | Description                           | Reference   |
   | Name        |                                       |             |
   +-------------+---------------------------------------+-------------+
   | bytes       | a range of octets                     | &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt; |
   | none        | reserved as keyword, indicating no    | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   |             | ranges are supported                  |             |
   +-------------+---------------------------------------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">초기 범위 단위 레지스트리에는 다음과 같은 등록이 포함됩니다. + ------------- + ------------------------- -------------- + ------------- + | 레인지 유닛 | 설명 | 참조 | | 이름 | | | + ------------- + ----------------------------------- ---- + ------------- + | 바이트 | 옥텟의 범위 | &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1&lt;/a&gt; | | 없음 | 키워드로 예약되어 없음 | &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; | | | 범위가 지원됩니다 | | + ------------- + ----------------------------------- ---- + ------------- + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ebd17564840526ee148efdaf203fca839e5379a4" translate="yes" xml:space="preserve">
          <source>The initial version of HTTP had no version number; it has been later called 0.9 to differentiate it from the later versions. HTTP/0.9 is extremely simple: requests consist of a single line and start with the only possible method &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; followed by the path to the resource (not the URL as both the protocol, server, and port are unnecessary once connected to the server).</source>
          <target state="translated">HTTP의 초기 버전에는 버전 번호가 없었습니다. 이후 버전과 구별하기 위해 나중에 0.9로 불 렸습니다. HTTP / 0.9는 매우 간단합니다. 요청은 한 줄로 구성되며 가능한 유일한 방법 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 으로&lt;/a&gt; 시작하고 그 뒤에 리소스 경로가옵니다 (프로토콜, 서버 및 포트가 모두 서버에 연결되면 URL이 아님).</target>
        </trans-unit>
        <trans-unit id="aa546185419767d20a05e2cb4df36ea1b19d66d3" translate="yes" xml:space="preserve">
          <source>The interface where the request came in to the proxy server.</source>
          <target state="translated">요청이 프록시 서버에 들어온 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="7c3952a320aa0697f4c57ed16e077bfea2eed9ae" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt;&lt;code&gt;Client-Hints&lt;/code&gt;&lt;/a&gt; allows the browser, or client, to proactively communicate information about its requirements, or hardware constraints, to the server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Client-Hints&quot;&gt; &lt;code&gt;Client-Hints&lt;/code&gt; &lt;/a&gt; 의 도입으로 브라우저 또는 클라이언트는 요구 사항 또는 하드웨어 제한 사항에 대한 정보를 서버와 사전에 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b38d9075a389a16460fcd684d2635f8653d50eed" translate="yes" xml:space="preserve">
          <source>The introduction of security-related prefixes in the &lt;a href=&quot;../headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header, now helps guarantee a secure cookie has not been altered.</source>
          <target state="translated">&lt;a href=&quot;../headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 헤더 에 보안 관련 접두사가 도입되어 보안 쿠키가 변경되지 않았 음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="5e730b1eec3af5f9a050a8a9662df02e4c7599c2" translate="yes" xml:space="preserve">
          <source>The issued request looks like this:</source>
          <target state="translated">발행 된 요청은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c84804fc4afa331bf0f09b76ea2770dfd6b62155" translate="yes" xml:space="preserve">
          <source>The key for this request to upgrade. The client adds this if it wishes to do so, and the server will include in the response a key of its own, which the client will validate before delivering the upgrade response to you.</source>
          <target state="translated">업그레이드 요청에 대한 키입니다. 클라이언트는 원하는 경우이를 추가하고 서버는 응답에 자체 키를 포함하며 업그레이드 응답을 사용자에게 전달하기 전에 클라이언트가 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="9a15e6847a0ff9b62775caf043875cd4c43edfc3" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be &quot;unconditionally compliant&quot;; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be &quot;conditionally compliant.&quot;</source>
          <target state="translated">이 문서에서 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ]에 설명 된 대로 해석해야합니다 . 구현이 구현 한 프로토콜에 대한 하나 이상의 필수 또는 필수 레벨 요구 사항을 충족시키지 못하면 구현이 준수하지 않습니다. 프로토콜의 모든 필수 또는 필수 레벨과 모든 SHOULD 레벨 요구 사항을 충족하는 구현은 &quot;무조건 준수&quot;라고합니다. 모든 MUST 레벨 요구 사항을 만족하지만 그 프로토콜에 대한 SHOULD 레벨 요구 사항을 모두 만족하는 것은 &quot;조건부 준수&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="9a4a2293d2f84b8a5fd8f2e4def5c748288282ce" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].</source>
          <target state="translated">이 문서의 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119에&lt;/a&gt; 설명 된대로 해석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9eac2de940bf2c082a5aa542b14155a2665a0ba" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.</source>
          <target state="translated">이 문서의 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119에&lt;/a&gt; 설명 된대로 해석해야합니다 . 에러 처리에 관한 적합성 기준 및 고려 사항 &lt;a href=&quot;#section-2.5&quot;&gt;은 2.5 장에&lt;/a&gt; 정의되어있다 .</target>
        </trans-unit>
        <trans-unit id="6a63eeb5f4d9a57b187d7fb929309ed70bf0dbac" translate="yes" xml:space="preserve">
          <source>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Conformance criteria and considerations regarding error handling are
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;Section&amp;nbsp;2.5 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">이 문서의 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119에&lt;/a&gt; 설명 된대로 해석해야합니다 . 에러 처리에 관한 적합성 기준 및 고려 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.5&quot;&gt;은 [RFC7230]의 2.5 절에&lt;/a&gt; 정의되어 있다 .</target>
        </trans-unit>
        <trans-unit id="bb75c6ee1cca0ad36d986b0e355cb0e843e6e2f2" translate="yes" xml:space="preserve">
          <source>The kind of validation is independent of the validator used. Both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; allow both types of validation, though the complexity to implement it on the server side may vary. HTTP uses strong validation by default, and it specifies when weak validation can be used.</source>
          <target state="translated">유효성 검사의 종류는 사용 된 유효성 검사기와 독립적입니다. 둘 다 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 복잡성이 달라질 수 있습니다 서버 측에서 그것을 구현하지만, 검증의 두 가지 유형의 수 있습니다. HTTP는 기본적으로 강력한 유효성 검사를 사용하며 취약한 유효성 검사를 사용할 수있는시기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d08a92729e395511c2581a4dfc33791c98b63230" translate="yes" xml:space="preserve">
          <source>The largest change that happened to HTTP was done as early as end of 1994. Instead of sending HTTP over a basic TCP/IP stack, Netscape Communication created an additional encrypted transmission layer on top of it: SSL. SSL 1.0 was never released outside the companies, but SSL 2.0 and its successors SSL 3.0 and SSL 3.1 allowed for the creation of e-commerce Web sites by encrypting and guaranteeing the authenticity of the messages exchanged between the server and client. SSL was put on the standards track and eventually became TLS, with version 1.0, 1.1, and 1.2 appearing successfully to close vulnerabilities. TLS 1.3 is currently in the making.</source>
          <target state="translated">HTTP에 발생한 가장 큰 변경 사항은 1994 년 초에 이루어졌습니다. 기본 TCP / IP 스택을 통해 HTTP를 보내는 대신 Netscape Communication은 그 위에 추가 암호화 된 전송 계층 인 SSL을 만들었습니다. SSL 1.0은 회사 외부로 출시되지 않았지만 SSL 2.0 및 그 후속 버전 인 SSL 3.0 및 SSL 3.1은 서버와 클라이언트간에 교환되는 메시지의 신뢰성을 암호화하고 보장함으로써 전자 상거래 웹 사이트를 만들 수있었습니다. SSL은 표준 트랙에 올라 최종적으로 TLS가되었으며, 버전 1.0, 1.1 및 1.2는 취약점을 성공적으로 해결하는 것으로 나타났습니다. TLS 1.3이 현재 제작 중입니다.</target>
        </trans-unit>
        <trans-unit id="d01d212bb5fa98e344dced612706d97e4c48d614" translate="yes" xml:space="preserve">
          <source>The last part of a response is the body. Not all responses have one: responses with a status code, like &lt;a href=&quot;status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;, usually don't.</source>
          <target state="translated">응답의 마지막 부분은 본문입니다. 모든 응답에 하나가있는 것은 아닙니다. &lt;a href=&quot;status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; 과 같은 상태 코드가있는 응답 것은 아닙니다. 또는 &lt;a href=&quot;status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; 일반적으로 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13fd2da68ff6f625ec41f864542e44b06721f081" translate="yes" xml:space="preserve">
          <source>The length in decimal number of octets.</source>
          <target state="translated">10 진수의 10 진수로 표시 한 길이입니다.</target>
        </trans-unit>
        <trans-unit id="fc5fa9bc684bf265ecd239fcfb6b1be61af94a10" translate="yes" xml:space="preserve">
          <source>The length of a message body is determined by one of the following
   (in order of precedence):

   1.  Any response to a HEAD request and any response with a 1xx
       (Informational), 204 (No Content), or 304 (Not Modified) status
       code is always terminated by the first empty line after the
       header fields, regardless of the header fields present in the
       message, and thus cannot contain a message body.

   2.  Any 2xx (Successful) response to a CONNECT request implies that
       the connection will become a tunnel immediately after the empty
       line that concludes the header fields.  A client MUST ignore any
       Content-Length or Transfer-Encoding header fields received in
       such a message.

   3.  If a Transfer-Encoding header field is present and the chunked
       transfer coding (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) is the final encoding, the message
       body length is determined by reading and decoding the chunked
       data until the transfer coding indicates the data is complete.

       If a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection.

       If a message is received with both a Transfer-Encoding and a
       Content-Length header field, the Transfer-Encoding overrides the
       Content-Length.  Such a message might indicate an attempt to
       perform request smuggling (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;) or response splitting
       (&lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;) and ought to be handled as an error.  A sender MUST
       remove the received Content-Length field prior to forwarding such
       a message downstream.

   4.  If a message is received without Transfer-Encoding and with
       either multiple Content-Length header fields having differing
       field-values or a single Content-Length header field having an
       invalid value, then the message framing is invalid and the
       recipient MUST treat it as an unrecoverable error.  If this is a
       request message, the server MUST respond with a 400 (Bad Request)
       status code and then close the connection.  If this is a response
       message received by a proxy, the proxy MUST close the connection
       to the server, discard the received response, and send a 502 (Bad 

       Gateway) response to the client.  If this is a response message
       received by a user agent, the user agent MUST close the
       connection to the server and discard the received response.

   5.  If a valid Content-Length header field is present without
       Transfer-Encoding, its decimal value defines the expected message
       body length in octets.  If the sender closes the connection or
       the recipient times out before the indicated number of octets are
       received, the recipient MUST consider the message to be
       incomplete and close the connection.

   6.  If this is a request message and none of the above are true, then
       the message body length is zero (no message body is present).

   7.  Otherwise, this is a response message without a declared message
       body length, so the message body length is determined by the
       number of octets received prior to the server closing the
       connection.

   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.

   A server MAY reject a request that contains a message body but not a
   Content-Length by responding with 411 (Length Required).

   Unless a transfer coding other than chunked has been applied, a
   client that sends a request containing a message body SHOULD use a
   valid Content-Length header field if the message body length is known
   in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.
   This is typically because such services are implemented via a gateway
   that requires a content-length in advance of being called and the
   server is unable or unwilling to buffer the entire request before
   processing.

   A user agent that sends a request containing a message body MUST send
   a valid Content-Length header field if it does not know the server
   will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version
   of a prior received response.

   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user
   agent MAY discard the remaining data or attempt to determine if that 

   data belongs as part of the prior response body, which might be the
   case if the prior message's Content-Length value is incorrect.  A
   client MUST NOT process, cache, or forward such extra data as a
   separate response, since such behavior would be vulnerable to cache
   poisoning.</source>
          <target state="translated">메시지 본문의 길이는 다음 중 하나에 의해 결정됩니다 (우선 순위 순). 1. HEAD 요청에 대한 응답 및 1xx (정보), 204 (콘텐츠 없음) 또는 304 (수정되지 않음)의 응답 상태 코드는 메시지에있는 헤더 필드에 관계없이 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료되므로 메시지 본문을 포함 할 수 없습니다. 2. CONNECT 요청에 대한 2xx (성공) 응답은 헤더 필드를 마치는 빈 줄 바로 뒤에 연결이 터널이됨을 의미합니다. 클라이언트는 그러한 메시지로 수신 된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야합니다. 3. Transfer-Encoding 헤더 필드가 있고 청크 전송 코드 (&lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt;)는 최종 인코딩이고, 메시지 본문 길이는 전송 코딩이 데이터가 완료되었음을 나타낼 때까지 청크 된 데이터를 읽고 디코딩함으로써 결정된다. 응답에 Transfer-Encoding 헤더 필드가 있고 청크 된 전송 코딩이 최종 인코딩이 아닌 경우 서버에서 닫을 때까지 연결을 읽음으로써 메시지 본문 길이가 결정됩니다. 전송 인코딩 헤더 필드가 요청에 존재하고 청크 된 전송 코딩이 최종 인코딩이 아닌 경우, 메시지 본문 길이는 신뢰성있게 결정될 수 없으며; 서버는 반드시 400 (Bad Request) 상태 코드로 응답 한 다음 연결을 닫아야합니다. Transfer-Encoding과 Content-Length 헤더 필드가 모두있는 메시지가 수신되면전송 인코딩은 Content-Length보다 우선합니다. 이러한 메시지는 요청 밀수를 수행하려는 시도 (&lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; ) 또는 응답 분할 (&lt;a href=&quot;#section-9.4&quot;&gt; 섹션 9.4)&lt;/a&gt;) 오류로 처리해야합니다. 발신자는 그러한 메시지를 다운 스트림으로 전달하기 전에 수신 된 Content-Length 필드를 제거해야합니다. 4. Transfer-Encoding없이 필드 값이 다른 여러 Content-Length 헤더 필드 또는 유효하지 않은 값을 가진 단일 Content-Length 헤더 필드가있는 메시지가 수신되면 메시지 프레이밍이 유효하지 않으며 수신자가 처리해야합니다. 회복 불가능한 오류로. 이것이 요청 메시지 인 경우 서버는 반드시 400 (잘못된 요청) 상태 코드로 응답 한 다음 연결을 닫아야합니다. 이것이 프록시에 의해 수신 된 응답 메시지 인 경우, 프록시는 반드시 서버에 대한 연결을 닫고, 수신 된 응답을 폐기하고, 클라이언트에 502 (Bad Gateway) 응답을 보내야합니다.이것이 사용자 에이전트가 수신 한 응답 메시지 인 경우, 사용자 에이전트는 서버와의 연결을 닫아야하고 수신 된 응답을 폐기해야합니다. 5. Transfer-Encoding없이 유효한 Content-Length 헤더 필드가있는 경우 10 진수 값은 예상 메시지 본문 길이를 옥텟으로 정의합니다. 발신자가 연결을 닫거나 표시된 옥텟 수를 수신하기 전에 수신자가 시간 종료되면, 수신자는 메시지가 불완전한 것으로 간주하고 연결을 닫아야합니다. 6. 이것이 요청 메시지이고 위의 어느 것도 해당되지 않는 경우, 메시지 본문 길이는 0입니다 (메시지 본문이 없음). 7. 그렇지 않으면, 이것은 선언 된 메시지 본문 길이가없는 응답 메시지입니다.따라서 메시지 본문 길이는 서버가 연결을 닫기 전에 수신 한 옥텟 수에 의해 결정됩니다. 네트워크 장애로 중단 된 부분적으로 수신 된 메시지와 성공적으로 완료되고 종결 된 메시지를 구별 할 수있는 방법이 없기 때문에 서버는 가능할 때마다 인코딩 또는 길이로 구분 된 메시지를 생성해야합니다. 닫기 구분 기능은 주로 HTTP / 1.0과의 하위 호환성을 위해 존재합니다. 서버는 411 (Length Required)로 응답하여 메시지 본문은 포함하지만 Content-Length는 포함하지 않는 요청을 거부 할 수 있습니다. 청크 이외의 전송 코드가 적용되지 않은 경우, 메시지 본문을 포함하는 요청을 보내는 클라이언트는 메시지 본문 길이를 미리 알고 있으면 유효한 Content-Length 헤더 필드를 사용해야합니다.일부 기존 서비스는 청크 전송 코드를 이해하더라도 411 (길이 필요) 상태 코드로 청크에 응답하기 때문에 청크 전송 코드가 아니라 청크 전송 코드가 아닙니다. 이는 일반적으로 이러한 서비스가 호출되기 전에 컨텐츠 길이가 필요한 게이트웨이를 통해 구현되고 서버가 처리 전에 전체 요청을 버퍼링 할 수 없거나 원하지 않기 때문입니다. 메시지 본문이 포함 된 요청을 보내는 사용자 에이전트는 서버가 HTTP / 1.1 (또는 그 이후) 요청을 처리 할 줄 모른다면 유효한 Content-Length 헤더 필드를 보내야합니다. 이러한 지식은 특정 사용자 구성의 형태이거나 이전에 수신 된 응답의 버전을 기억함으로써 이루어질 수 있습니다.연결의 마지막 요청에 대한 최종 응답이 완전히 수신되고 읽을 추가 데이터가 남아있는 경우, 사용자 에이전트는 나머지 데이터를 삭제하거나 해당 데이터가 이전 응답 본문의 일부인지 여부를 판별하려고 시도 할 수 있습니다. 이전 메시지의 Content-Length 값이 올바르지 않은 경우 클라이언트는 이러한 추가 데이터를 별도의 응답으로 처리, 캐시 또는 전달해서는 안됩니다. 캐시 동작에 취약 할 수 있기 때문입니다.이러한 행동은 캐시 중독에 취약하기 때문입니다.이러한 행동은 캐시 중독에 취약하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="de35152ee3c77722bc9537cad929955d73dab593" translate="yes" xml:space="preserve">
          <source>The list of allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">허용 목록 &lt;a href=&quot;../methods&quot;&gt;HTTP 요청 방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15263fb5ed512784dbb85f5e27d3d988105feb1f" translate="yes" xml:space="preserve">
          <source>The maximum lifetime of the cookie as an HTTP-date timestamp. See &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; for the detailed format. If not specified, the cookie will have the lifetime of a &lt;strong&gt;session cookie. &lt;/strong&gt;A session is finished when the client is shut down meaning that session cookies will get removed at that point. However, many web browsers have a feature called session restore that will save all your tabs and have them come back next time you use the browser. Cookies will also be present and it's like you had never actually closed the browser.</source>
          <target state="translated">쿠키의 최대 수명은 HTTP- 날짜 타임 스탬프입니다. 자세한 형식 은 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 지정하지 않으면 쿠키의 &lt;strong&gt;세션 쿠키&lt;/strong&gt; 수명이 유지 &lt;strong&gt;됩니다. &lt;/strong&gt;클라이언트가 종료되면 세션이 종료되어 해당 시점에서 세션 쿠키가 제거됩니다. 그러나 많은 웹 브라우저에는 모든 탭을 저장하고 다음에 브라우저를 사용할 때 다시 표시하는 세션 복원 기능이 있습니다. 쿠키도 존재하며 실제로 브라우저를 닫지 않은 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e63c2c824f245057f299d57750e6b8789678a89a" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 32kB</source>
          <target state="translated">지원되는 최대 크기는 32kB입니다.</target>
        </trans-unit>
        <trans-unit id="c27432dd9f890b43b972ceef8be06ebeb078000d" translate="yes" xml:space="preserve">
          <source>The maximum size supported is 4GB</source>
          <target state="translated">지원되는 최대 크기는 4GB입니다.</target>
        </trans-unit>
        <trans-unit id="6711070acb52353698f99e67ae8f7a23d80cf676" translate="yes" xml:space="preserve">
          <source>The meaning of a success depends on the HTTP request method:</source>
          <target state="translated">성공의 의미는 HTTP 요청 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ed1aebd9e25e31bb79bed64a7c6d90aa83890cf3" translate="yes" xml:space="preserve">
          <source>The media format of the requested data is not supported by the server, so the server is rejecting the request.</source>
          <target state="translated">요청한 데이터의 미디어 형식이 서버에서 지원되지 않으므로 서버가 요청을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="6d8af46d85f95f2c6776a4511c1248db0db1fa9e" translate="yes" xml:space="preserve">
          <source>The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;.

     message-body = *OCTET

   The rules for when a message body is allowed in a message differ for
   requests and responses.

   The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.

   The presence of a message body in a response depends on both the
   request method to which it is responding and the response status code
   (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;).  Responses to the HEAD request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2
   of [RFC7231]&lt;/a&gt;) never include a message body because the associated
   response header fields (e.g., Transfer-Encoding, Content-Length,
   etc.), if present, indicate only what their values would have been if
   the request method had been GET (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;). 2xx
   (Successful) responses to a CONNECT request method (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
   responses do not include a message body.  All other responses do
   include a message body, although the body might be of zero length.</source>
          <target state="translated">HTTP 메시지의 메시지 본문 (있는 경우)은 해당 요청 또는 응답의 페이로드 본문을 전달하는 데 사용됩니다. &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; 에서 설명한 것처럼 전송 코딩이 적용되지 않은 경우 메시지 본문은 페이로드 본문과 동일합니다 . message-body = * OCTET 메시지에서 메시지 본문이 허용되는시기에 대한 규칙은 요청 및 응답마다 다릅니다. 요청에 메시지 본문이 있음은 Content-Length 또는 Transfer-Encoding 헤더 필드에 의해 알립니다. 요청 메시지 프레이밍은 메소드가 메시지 본문에 대한 사용을 정의하지 않더라도 메소드 시맨틱과 무관합니다. 응답에 메시지 본문이 있는지 여부는 응답하는 요청 방법과 응답 상태 코드 ( &lt;a href=&quot;#section-3.1.2&quot;&gt; 3.1.2 단원)에&lt;/a&gt;)에 따라 다릅니다 . HEAD 요청 방법에 대한 응답 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]의 섹션 4.3.2&lt;/a&gt; 에는 메시지 본문이 포함되어 있지 않습니다. 관련 응답 헤더 필드 (예 : Transfer-Encoding, Content-Length 등)가있는 경우 요청 방법 인 경우 해당 값이 무엇인지 표시하기 때문입니다. GET이었다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]의 4.3.1 절&lt;/a&gt; ). CONNECT 요청 메소드에 대한 2xx (성공) 응답 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]의 4.3.6 절&lt;/a&gt; )은 메시지 본문 대신 터널 모드로 전환합니다. 모든 1xx (정보), 204 (콘텐츠 없음) 및 304 (수정되지 않음) 응답에는 메시지 본문이 포함되지 않습니다. 본문의 길이는 0 일 수 있지만 다른 모든 응답에는 메시지 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4e8aaa241374a41dac239673c7a83e9b31912343" translate="yes" xml:space="preserve">
          <source>The message header fields below should be added to the permanent
   registry (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;]).</source>
          <target state="translated">아래의 메시지 헤더 필드는 영구 레지스트리에 추가해야합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; ] 참조 ).</target>
        </trans-unit>
        <trans-unit id="5e0a346350c18fe7ecba53dc40c76384937c220e" translate="yes" xml:space="preserve">
          <source>The message-body (if any) of an HTTP message is used to carry the
   entity-body associated with the request or response. The message-body
   differs from the entity-body only when a transfer-coding has been
   applied, as indicated by the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;).

       message-body = entity-body
                    | &amp;lt;entity-body encoded as per Transfer-Encoding&amp;gt;

   Transfer-Encoding MUST be used to indicate any transfer-codings
   applied by an application to ensure safe and proper transfer of the
   message. Transfer-Encoding is a property of the message, not of the 

   entity, and thus MAY be added or removed by any application along the
   request/response chain. (However, &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt; places restrictions on
   when certain transfer-codings may be used.)

   The rules for when a message-body is allowed in a message differ for
   requests and responses.

   The presence of a message-body in a request is signaled by the
   inclusion of a Content-Length or Transfer-Encoding header field in
   the request's message-headers. A message-body MUST NOT be included in
   a request if the specification of the request method (&lt;a href=&quot;#section-5.1.1&quot;&gt;section 5.1.1&lt;/a&gt;)
   does not allow sending an entity-body in requests. A server SHOULD
   read and forward a message-body on any request; if the request method
   does not include defined semantics for an entity-body, then the
   message-body SHOULD be ignored when handling the request.

   For response messages, whether or not a message-body is included with
   a message is dependent on both the request method and the response
   status code (&lt;a href=&quot;#section-6.1.1&quot;&gt;section 6.1.1&lt;/a&gt;). All responses to the HEAD request method
   MUST NOT include a message-body, even though the presence of entity-
   header fields might lead one to believe they do. All 1xx
   (informational), 204 (no content), and 304 (not modified) responses
   MUST NOT include a message-body. All other responses do include a
   message-body, although it MAY be of zero length.</source>
          <target state="translated">HTTP 메시지의 메시지 본문 (있는 경우)은 요청 또는 응답과 연관된 엔티티 본문을 전달하는 데 사용됩니다. 메시지 본문은 Transfer-Encoding 헤더 필드 ( &lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;절&lt;/a&gt; )에 표시된 것처럼 전송 코딩이 적용된 경우에만 엔티티 본문과 다릅니다 . 메시지 본문 = 엔티티 본문 | &amp;lt;전송 인코딩에 따라 인코딩 된 엔터티 본문&amp;gt; 전송 인코딩은 메시지가 안전하고 올바르게 전송되도록 응용 프로그램에서 적용한 전송 코딩을 나타내는 데 사용해야합니다. 전송 인코딩은 엔티티가 아닌 메시지의 속성이므로 요청 / 응답 체인을 따라 모든 응용 프로그램에서 추가하거나 제거 할 수 있습니다. (단, &lt;a href=&quot;#section-3.6&quot;&gt;3.6 항&lt;/a&gt;메시지에 메시지 본문이 허용되는시기에 대한 규칙은 요청 및 응답마다 다릅니다. 요청에 메시지 본문이 존재한다는 것은 요청의 메시지 헤더에 Content-Length 또는 Transfer-Encoding 헤더 필드를 포함시킴으로써 알 수 있습니다. 요청 방법의 명세 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1) 인&lt;/a&gt; 경우 메시지 본문은 요청에 포함되어서는 안된다 (MUST 5).)는 요청에서 엔티티 본문을 보내는 것을 허용하지 않습니다. 서버는 요청시 메시지 본문을 읽고 전달해야합니다. 요청 방법에 엔티티 본문에 대해 정의 된 의미가 포함되어 있지 않으면 요청을 처리 할 때 메시지 본문을 무시해야합니다. 응답 메시지의 경우 메시지 본문이 메시지에 포함되는지 여부는 요청 방법과 응답 상태 코드 ( &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1 섹션&lt;/a&gt; )에 따라 다릅니다 . HEAD 요청 방법에 대한 모든 응답에는 엔터티 헤더 필드가 존재한다고 믿어도 메시지 본문이 포함되어서는 안됩니다 (MUST NOT). 모든 1xx (정보), 204 (콘텐츠 없음) 및 304 (수정되지 않음) 응답에는 메시지 본문이 포함되어서는 안됩니다. 다른 모든 응답에는 길이가 0 일 수 있지만 메시지 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a40c2c2dfbf9c25f98c934df39c7f7ed182fe5cf" translate="yes" xml:space="preserve">
          <source>The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for
   all &quot;message&quot; types regarding line length and encodings.

   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed message (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body.

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted 

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.1&quot;&gt;Section 8.3.1&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Magic number(s):  N/A

      Deprecated alias names for this type:  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">메시지 / http 유형은 단일 HTTP 요청 또는 응답 메시지를 묶는 데 사용될 수 있습니다. 단, 라인 길이 및 인코딩과 관련된 모든 &quot;메시지&quot;유형에 대한 MIME 제한을 준수해야합니다. 유형 이름 : 메시지 하위 유형 이름 : http 필수 매개 변수 : 해당 사항 없음 선택적 매개 변수 : version, msgtype version : 동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;). 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 라인에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 : &quot;7bit&quot;, &quot;8bit&quot;또는 &quot;binary&quot;만 허용됩니다. 보안 고려 사항 :&lt;a href=&quot;#section-9&quot;&gt;섹션 9 참조&lt;/a&gt; 상호 운용성 고려 사항 : 해당 사항 없음 게시 된 사양 :이 사양 ( &lt;a href=&quot;#section-8.3.1&quot;&gt;섹션 8.3.1&lt;/a&gt; 참조 ). 이 미디어 유형을 사용하는 응용 프로그램 : 해당 사항 없음 조각 식별자 고려 사항 : 해당 사항 없음 추가 정보 : 매직 번호 : 해당 사항 없음이 유형의 더 이상 사용되지 않는 별칭 이름 : 해당 사항 없음 파일 확장자 : 해당 없음 Macintosh 파일 유형 코드 : 해당 사항 없음 자세한 내용은 연락 할 사람과 이메일 주소 : 작성자 주소 섹션을 참조하십시오. 용도 : COMMON 사용 제한 : 해당 사항 없음 저자 : 저자 주소 섹션을 참조하십시오. 컨트롤러 변경 : IESG</target>
        </trans-unit>
        <trans-unit id="0249133f37d2157bb5d5d75cceeb4bf6c3634006" translate="yes" xml:space="preserve">
          <source>The method and the body of the original request are reused to perform the redirected request. In the cases where you want the method used to be changed to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;303&quot;&gt;&lt;code&gt;303 See Other&lt;/code&gt;&lt;/a&gt; instead. This is useful when you want to give an answer to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method that is not the uploaded resources, but a confirmation message (like &quot;You successfully uploaded XYZ&quot;).</source>
          <target state="translated">원래 요청의 방법과 본문은 리디렉션 된 요청을 수행하기 위해 재사용됩니다. 메소드를 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경하려는 경우 대신 &lt;a href=&quot;303&quot;&gt; &lt;code&gt;303 See Other&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 이것은 업로드 된 리소스가 아니라 확인 메시지 (예 : &quot;XYZ를 성공적으로 업로드했습니다&quot;) 인 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 메소드에 대한 답변을 제공하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb5ff63a9c845a973320d106a4e7a8f6258bc0a" translate="yes" xml:space="preserve">
          <source>The method specified in the Request-Line is not allowed for the
   resource identified by the Request-URI. The response MUST include an
   Allow header containing a list of valid methods for the requested
   resource.</source>
          <target state="translated">Request-Line에 지정된 메소드는 Request-URI로 식별 된 자원에 허용되지 않습니다. 응답에는 요청 된 자원에 대한 유효한 메소드 목록이 포함 된 Allow 헤더가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c61cd0e1f1485b50b5d1e9ad93568afa1f7867e5" translate="yes" xml:space="preserve">
          <source>The misunderstood X-XSS-Protection &amp;ndash; blog.innerht.ml</source>
          <target state="translated">오해 X-XSS-Protection &amp;ndash; blog.innerht.ml</target>
        </trans-unit>
        <trans-unit id="6aa0132e5f88b4993af9157a3eacfea873d280a5" translate="yes" xml:space="preserve">
          <source>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To optimize this, good practices recommend to set expiration times as far in the future as possible. This is possible on resources that are regularly updated, or often, but is problematic for resources that are rarely and infrequently updated. They are the resources that would benefit the most from caching resources, yet this makes them very difficult to update. This is typical of the technical resources included and linked from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be updated quickly.</source>
          <target state="translated">캐시 된 리소스를 많이 사용할수록 웹 사이트의 응답 성과 성능이 향상됩니다. 이를 최적화하기 위해 모범 사례는 가능한 한 만료 시간을 설정하는 것이 좋습니다. 이는 정기적으로 업데이트되거나 자주 업데이트되는 리소스에서 가능하지만 거의 업데이트되지 않는 리소스에는 문제가 있습니다. 캐싱 리소스를 최대한 활용하는 리소스이지만 업데이트하기가 매우 어렵습니다. 이것은 각 웹 페이지에 포함되고 링크 된 기술 리소스의 전형적인 예입니다. JavaScript 및 CSS 파일은 자주 변경되지 않지만 변경 될 때 빠르게 업데이트되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="900a5182069f7643f5a96c3714605f7b28cd3d50" translate="yes" xml:space="preserve">
          <source>The most basic form of lock is an exclusive lock.  Exclusive locks
   avoid having to deal with content change conflicts, without requiring
   any coordination other than the methods described in this
   specification.

   However, there are times when the goal of a lock is not to exclude
   others from exercising an access right but rather to provide a
   mechanism for principals to indicate that they intend to exercise
   their access rights.  Shared locks are provided for this case.  A
   shared lock allows multiple principals to receive a lock.  Hence any
   principal that has both access privileges and a valid lock can use
   the locked resource.

   With shared locks, there are two trust sets that affect a resource.
   The first trust set is created by access permissions.  Principals who
   are trusted, for example, may have permission to write to the
   resource.  Among those who have access permission to write to the
   resource, the set of principals who have taken out a shared lock also
   must trust each other, creating a (typically) smaller trust set
   within the access permission write set.

   Starting with every possible principal on the Internet, in most
   situations the vast majority of these principals will not have write
   access to a given resource.  Of the small number who do have write
   access, some principals may decide to guarantee their edits are free
   from overwrite conflicts by using exclusive write locks.  Others may
   decide they trust their collaborators will not overwrite their work
   (the potential set of collaborators being the set of principals who
   have write permission) and use a shared lock, which informs their
   collaborators that a principal may be working on the resource.

   The WebDAV extensions to HTTP do not need to provide all of the
   communications paths necessary for principals to coordinate their
   activities.  When using shared locks, principals may use any out-of-
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen,
   telephone conversation, email, etc.)  The intent of a shared lock is
   to let collaborators know who else may be working on a resource.

   Shared locks are included because experience from Web-distributed
   authoring systems has indicated that exclusive locks are often too
   rigid.  An exclusive lock is used to enforce a particular editing
   process: take out an exclusive lock, read the resource, perform
   edits, write the resource, release the lock.  This editing process
   has the problem that locks are not always properly released, for
   example, when a program crashes or when a lock creator leaves without 

   unlocking a resource.  While both timeouts (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) and
   administrative action can be used to remove an offending lock,
   neither mechanism may be available when needed; the timeout may be
   long or the administrator may not be available.

   A successful request for a new shared lock MUST result in the
   generation of a unique lock associated with the requesting principal.
   Thus, if five principals have taken out shared write locks on the
   same resource, there will be five locks and five lock tokens, one for
   each principal.</source>
          <target state="translated">가장 기본적인 형태의 자물쇠는 독점적 인 자물쇠입니다. 배타적 잠금은이 사양에 설명 된 방법 이외의 다른 조정 없이도 콘텐츠 변경 충돌을 처리하지 않아도됩니다. 그러나 잠금의 목표가 다른 사람들이 접근 권한을 행사하는 것을 배제하는 것이 아니라 교장에게 그들이 접근 권한을 행사할 의사가 있음을 나타내는 메커니즘을 제공하는 것입니다. 이 경우 공유 잠금이 제공됩니다. 공유 잠금을 사용하면 여러 보안 주체가 잠금을받을 수 있습니다. 따라서 액세스 권한과 유효한 잠금이 모두있는 모든 주체는 잠긴 리소스를 사용할 수 있습니다. 공유 잠금에는 자원에 영향을주는 두 개의 신뢰 세트가 있습니다. 첫 번째 트러스트 세트는 액세스 권한으로 생성됩니다. 예를 들어, 신뢰할 수있는 교장리소스에 쓸 수있는 권한이있을 수 있습니다. 리소스에 대한 쓰기 권한이있는 사용자 중 공유 잠금을 해제 한 보안 주체 집합도 서로를 신뢰하여 액세스 권한 쓰기 세트 내에 (일반적으로) 더 작은 신뢰 세트를 만들어야합니다. 인터넷에서 가능한 모든 주체로 시작하여 대부분의 상황에서 이러한 주체의 대다수는 주어진 리소스에 대한 쓰기 액세스 권한을 갖지 않습니다. 쓰기 권한이있는 소수 중에서 일부 보안 주체는 독점 쓰기 잠금을 사용하여 편집 내용에 덮어 쓰기 충돌이 발생하지 않도록 할 수 있습니다. 다른 사람들은 공동 작업자가 자신의 작업을 덮어 쓰지 않을 것이라고 믿고 (잠재적 인 공동 작업자 그룹은 쓰기 권한을 가진 주체 집합 임) 공유 잠금을 사용합니다.공동 작업자에게 교장 선생님이 자원을 연구하고 있음을 알려줍니다. HTTP에 대한 WebDAV 확장은 프린시 펄이 활동을 조정하는 데 필요한 모든 통신 경로를 제공 할 필요는 없습니다. 공유 잠금을 사용할 때 교장은 대역 외 통신 채널을 사용하여 작업을 조정할 수 있습니다 (예 : 대면 상호 작용, 필기 메모, 화면의 포스트잇 메모, 전화 대화, 전자 메일 등). 공유 잠금의 목적은 공동 작업자에게 리소스에 대해 작업중인 다른 사람을 알리는 것입니다. 웹 분산 제작 시스템의 경험에 따르면 독점 잠금이 너무 엄격하다는 사실이 밝혀 졌기 때문에 공유 잠금이 포함됩니다. 단독 잠금은 특정 편집 프로세스를 시행하는 데 사용됩니다. 독점 잠금을 해제하고 리소스를 읽고 편집을 수행합니다.리소스를 작성하고 잠금을 해제하십시오. 이 편집 프로세스에는 프로그램이 충돌하거나 잠금 작성자가 자원을 잠금 해제하지 않고 떠날 때와 같이 잠금이 항상 올바르게 해제되지 않는 문제가 있습니다. 두 제한 시간 동안 (&lt;a href=&quot;#section-6.6&quot;&gt;섹션 6.6&lt;/a&gt; ) 및 관리 조치를 사용하여 문제가되는 잠금을 제거 할 수 있습니다. 필요한 경우 메커니즘을 사용할 수 없습니다. 시간 초과가 길거나 관리자를 사용할 수 없습니다. 새로운 공유 잠금에 대한 요청은 요청 주체와 관련된 고유 한 잠금을 생성해야합니다. 따라서 5 명의 보안 주체가 동일한 리소스에서 공유 쓰기 잠금을 해제 한 경우 각 보안 주체마다 하나씩 5 개의 잠금 및 5 개의 잠금 토큰이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a156ff3c58c5769ef6c6729d1da6678b0896af60" translate="yes" xml:space="preserve">
          <source>The most common authentication scheme is the &quot;Basic&quot; authentication scheme which is introduced in more details below. IANA maintains a &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;list of authentication schemes&lt;/a&gt;, but there are other schemes offered by host services, such as Amazon AWS. Common authentication schemes include:</source>
          <target state="translated">가장 일반적인 인증 체계는 &quot;기본&quot;인증 체계이며 아래에서 더 자세히 소개합니다. IANA &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml&quot;&gt;는 인증 체계 목록을&lt;/a&gt; 유지 하지만 Amazon AWS와 같은 호스트 서비스에서 제공하는 다른 체계가 있습니다. 일반적인 인증 체계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3c5a495d4e0bf178a13835396e7d4610c8dd302" translate="yes" xml:space="preserve">
          <source>The most common form of URI is the Uniform Resource Locator (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;), which is known as the &lt;em&gt;web address&lt;/em&gt;.</source>
          <target state="translated">URI의 가장 일반적인 형태는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt; (Uniform Resource Locator )이며 &lt;em&gt;웹 주소&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="441408fdebb55a519d6ec56cfba9f8cfcf41c9d1" translate="yes" xml:space="preserve">
          <source>The most common form of request-target is the origin-form.

     origin-form    = absolute-path [ &quot;?&quot; query ]

   When making a request directly to an origin server, other than a
   CONNECT or server-wide OPTIONS request (as detailed below), a client
   MUST send only the absolute path and query components of the target
   URI as the request-target.  If the target URI's path component is
   empty, the client MUST send &quot;/&quot; as the path within the origin-form of
   request-target.  A Host header field is also sent, as defined in
   &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;.

   For example, a client wishing to retrieve a representation of the
   resource identified as

     http://www.example.org/where?q=now

   directly from the origin server would open (or reuse) a TCP
   connection to port 80 of the host &quot;www.example.org&quot; and send the
   lines:

     GET /where?q=now HTTP/1.1
     Host: www.example.org

   followed by the remainder of the request message.</source>
          <target state="translated">request-target의 가장 일반적인 형식은 origin-form입니다. origin-form = 절대 경로 [ &quot;?&quot; query] CONNECT 또는 서버 차원의 OPTIONS 요청 이외의 오리진 서버에 직접 요청하는 경우 (아래 설명 참조) 클라이언트는 대상 URI의 절대 경로 및 쿼리 구성 요소 만 요청 대상으로 보내야합니다. 대상 URI의 경로 구성 요소가 비어있는 경우 클라이언트는 요청 대상의 원래 형식 내 경로로 &quot;/&quot;를 보내야합니다. &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4에&lt;/a&gt; 정의 된대로 호스트 헤더 필드도 전송됩니다. . 예를 들어, 원본 서버에서 직접 http://www.example.org/where?q=now로 식별 된 리소스의 표현을 검색하려는 클라이언트는 호스트의 포트 80에 대한 TCP 연결을 열거 나 재사용합니다. &quot;www.example.org&quot;를 입력하고 GET / where? q = now HTTP / 1.1 호스트 : www.example.org 다음에 나머지 요청 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46ee34a68e260d2ac9a208c1c10ecca4cdb7c99d" translate="yes" xml:space="preserve">
          <source>The most common reason to perform user agent sniffing is to determine which type of device the browser runs on. The goal is to serve different HTML to different device types.</source>
          <target state="translated">사용자 에이전트 스니핑을 수행하는 가장 일반적인 이유는 브라우저가 실행되는 장치 유형을 확인하기위한 것입니다. 목표는 장치 유형에 따라 다른 HTML을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61e4993d071956d95f174a16357fd080a1122e7b" translate="yes" xml:space="preserve">
          <source>The most common use case for conditional requests is updating a cache. With an empty cache, or without a cache, the requested resource is sent back with a status of &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">조건부 요청의 가장 일반적인 사용 사례는 캐시를 업데이트하는 것입니다. 캐시가 비어 있거나 캐시가없는 경우 요청 된 자원은 상태가 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 인 상태로 다시 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="63916efe76674061fe4628e66838f4f65d786f1d" translate="yes" xml:space="preserve">
          <source>The most common use case is to resume a download, to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">가장 일반적인 사용 사례는 다운로드를 다시 시작하여 마지막 조각이 수신 된 이후에 저장된 리소스가 수정되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9d5d6bfeb55ebb232d3c55e050956f34dcf4435" translate="yes" xml:space="preserve">
          <source>The most common use case is to update a cached entity that has no associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 사용 사례는 연결된 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가없는 캐시 된 엔터티를 업데이트하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="69e5095bac19f7e957fc81b9fc8a8c4dfee3e4ef" translate="yes" xml:space="preserve">
          <source>The most commonly used API based on top of HTTP is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, which can be used to exchange data between a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; and a server.</source>
          <target state="translated">HTTP를 기반으로 가장 일반적으로 사용되는 API는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API로, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 와 서버 간에 데이터를 교환하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e318c21bd25e3fadc6435097a45df0a0fc7f22d3" translate="yes" xml:space="preserve">
          <source>The most important directive here is &quot;&lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt;&quot; which is the maximum amount of time a resource will be considered fresh. Contrary to &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt;, this directive is relative to the time of the request. For the files in the application that will not change, you can usually add aggressive caching. This includes static files such as images, CSS files and JavaScript files, for example.</source>
          <target state="translated">여기서 가장 중요한 지시문은 &quot; &lt;code&gt;max-age=&amp;lt;seconds&amp;gt;&lt;/code&gt; &quot;이며 자원이 최신 상태 로 간주되는 최대 시간입니다. &lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; 와 달리이 지시문은 요청 시간과 관련이 있습니다. 변경되지 않는 응용 프로그램 파일의 경우 일반적으로 적극적인 캐싱을 추가 할 수 있습니다. 여기에는 이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2de54066611634f9bbfbe66c8f61f170f030f4d4" translate="yes" xml:space="preserve">
          <source>The most interesting capability exposed by both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; and CORS is the ability to make &quot;credentialed&quot; requests that are aware of &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt; and HTTP Authentication information. By default, in cross-site &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; invocations, browsers will &lt;strong&gt;not&lt;/strong&gt; send credentials. A specific flag has to be set on the &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; object or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor when it is invoked.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 및 CORS에서 노출되는 가장 흥미로운 기능 은 &lt;a href=&quot;cookies&quot;&gt;HTTP 쿠키&lt;/a&gt; 및 HTTP 인증 정보를 인식하는 &quot;인증 된&quot;요청을 작성하는 기능 입니다. 기본적으로 크로스 사이트 &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 호출에서 브라우저는 자격 증명을 보내지 &lt;strong&gt;않습니다&lt;/strong&gt; . &lt;code&gt;XMLHttpRequest&quot;&lt;/code&gt; 개체 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 생성자가 호출 될 때 특정 플래그를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3a1c1a63ba9f8dd30771846a530a5374e05d9e6e" translate="yes" xml:space="preserve">
          <source>The name of a supported request header. The header may list any number of headers, separated by commas.</source>
          <target state="translated">지원되는 요청 헤더의 이름입니다. 헤더는 쉼표로 구분하여 원하는 수의 헤더를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0efb14ebcb5f0fce2ff3b286a2ffd2165a867e1e" translate="yes" xml:space="preserve">
          <source>The name of the policy section that was violated.</source>
          <target state="translated">위반 한 정책 섹션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="844cb327de813003d80319f4e20e97ec08ef266e" translate="yes" xml:space="preserve">
          <source>The name of the software or (sub) product that handles the requests.</source>
          <target state="translated">요청을 처리하는 소프트웨어 또는 (하위) 제품의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cbecb7545401e92e7f01c19b30802601bc05d85b" translate="yes" xml:space="preserve">
          <source>The name or pseudonym of the server or software adding the &lt;code&gt;Warning&lt;/code&gt; header (might be &quot;-&quot; when the agent is unknown).</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; 헤더를 추가 한 서버 또는 소프트웨어의 이름 또는 가명 (에이전트를 알 수없는 경우 &quot;-&quot;일 수 있음).</target>
        </trans-unit>
        <trans-unit id="0040305cef3180d6d7255c0c077b8782a6cc726f" translate="yes" xml:space="preserve">
          <source>The next major version of HTTP, HTTP/3, will use QUIC instead TCP/TLS for the transport layer portion.</source>
          <target state="translated">HTTP의 다음 주요 버전 인 HTTP / 3는 전송 계층 부분에 TCP / TLS 대신 QUIC를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a49012952b5d13c3bc899a210b34a7392e5f266" translate="yes" xml:space="preserve">
          <source>The non-standard &lt;code&gt;Large-Allocation&lt;/code&gt; response header tells the browser that the page being loaded is going to want to perform a large allocation. It is currently only implemented in Firefox, but is harmless to send to every browser.</source>
          <target state="translated">비표준 &lt;code&gt;Large-Allocation&lt;/code&gt; 응답 헤더는로드중인 페이지가 큰 할당을 수행하려고 함을 브라우저에 알려줍니다. 현재 Firefox에서만 구현되지만 모든 브라우저로 전송하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="ba5026e86262d6245f07b3191a146bd8bb62bfc9" translate="yes" xml:space="preserve">
          <source>The notion of HTTP headers has been introduced, both for the requests and the responses, allowing metadata to be transmitted and making the protocol extremely flexible and extensible.</source>
          <target state="translated">요청과 응답 모두에 HTTP 헤더 개념이 도입되어 메타 데이터가 전송되고 프로토콜이 매우 유연하고 확장 가능해졌습니다.</target>
        </trans-unit>
        <trans-unit id="cebe7f3b1e1476fa1411cff9686fdc49ff3da815" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt;&lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;  directive.</source>
          <target state="translated">사용되지 않는 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;content-security-policy/referrer&quot;&gt; &lt;code&gt;referrer&lt;/code&gt; &lt;/a&gt; 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="8ee97cde545a5282f8eb8711464102b13b2f6dec" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Cookie2&lt;/code&gt; HTTP request header used to advise the server that the user agent understands &quot;new-style&quot; cookies, but nowadays user agents will use the &lt;a href=&quot;cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header instead, not this one.</source>
          <target state="translated">사용되지 않는 &lt;code&gt;Cookie2&lt;/code&gt; HTTP 요청 헤더는 사용자 에이전트가 &quot;새 스타일&quot;쿠키를 이해한다고 서버에 알리는 데 사용되지만 요즘 사용자 에이전트는 이 헤더가 아닌 &lt;a href=&quot;cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="33c769b0c666a82869a02203951c2b8b5edec421" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP response header used to send cookies from the server to the user agent, but has been deprecated by the specification. Use &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;Set-Cookie2&lt;/code&gt; HTTP 응답 헤더는 서버에서 사용자 에이전트로 쿠키를 보내는 데 사용되었지만 사양에서 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd9be51f044c110f50b29c3226b55ae882be5f1e" translate="yes" xml:space="preserve">
          <source>The only allowed methods are:</source>
          <target state="translated">허용되는 유일한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc061ae17eb93f938e35cb15516a270a95c70f3c" translate="yes" xml:space="preserve">
          <source>The only allowed values for the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header are:</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더에 허용되는 유일한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12f64d0b6bf68050154b5d92dd4e2be1345a3197" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;307&lt;/code&gt; and &lt;a href=&quot;302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;307&lt;/code&gt; guarantees that the method and the body will not be changed when the redirected request is made. With &lt;code&gt;302&lt;/code&gt;, some old clients were incorrectly changing the method to &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;: the behavior with non-&lt;code&gt;GET&lt;/code&gt; methods and &lt;code&gt;302&lt;/code&gt; is then unpredictable on the Web, whereas the behavior with &lt;code&gt;307&lt;/code&gt; is predictable. For &lt;code&gt;GET&lt;/code&gt; requests, their behavior is identical.</source>
          <target state="translated">유일한 차이점 &lt;code&gt;307&lt;/code&gt; 및 &lt;a href=&quot;302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; , 즉 &lt;code&gt;307&lt;/code&gt; 개 리디렉트 요청이있을시에있어서 상기 본체가 변경되지 않는다는 것을 보장한다. 로 &lt;code&gt;302&lt;/code&gt; , 오래된 고객이 잘못 할 수있는 방법을 변경 한 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 비와 동작 : &lt;code&gt;GET&lt;/code&gt; 의 방법과 &lt;code&gt;302&lt;/code&gt; 와 동작 반면, 웹에서 다음 예측할 수를 &lt;code&gt;307&lt;/code&gt; 예측이다. 들어 &lt;code&gt;GET&lt;/code&gt; 의 요청, 그들의 행동은 동일하다.</target>
        </trans-unit>
        <trans-unit id="d4019eec51fe05092ad2db95b5b089e76d4b1742" translate="yes" xml:space="preserve">
          <source>The only expectation defined in the specification is &lt;code&gt;Expect: 100-continue&lt;/code&gt;, to which the server shall respond with:</source>
          <target state="translated">사양에 정의 된 유일한 기대는 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 이며 서버는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="8582b84a04fd3c0703aeb779483786b9e1fec4ab" translate="yes" xml:space="preserve">
          <source>The only valid value for this header is &lt;code&gt;true&lt;/code&gt; (case-sensitive). If you don't need credentials, omit this header entirely (rather than setting its value to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">이 헤더의 유일한 유효한 값은 &lt;code&gt;true&lt;/code&gt; (대소 문자 구분)입니다. 신임 정보가 필요하지 않은 경우 값을 &lt;code&gt;false&lt;/code&gt; 로 설정하지 않고이 헤더를 완전히 생략하십시오 .</target>
        </trans-unit>
        <trans-unit id="57e0edd3cec8916417007e47f389d457d3b92156" translate="yes" xml:space="preserve">
          <source>The order in which header fields with differing field names are
   received is not significant.  However, it is good practice to send
   header fields that contain control data first, such as Host on
   requests and Date on responses, so that implementations can decide
   when not to handle a message as early as possible.  A server MUST NOT
   apply a request to the target resource until the entire request 

   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.

   A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).

   A recipient MAY combine multiple header fields with the same field
   name into one &quot;field-name: field-value&quot; pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

      Note: In practice, the &quot;Set-Cookie&quot; header field ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]) often
      appears multiple times in a response message and does not use the
      list syntax, violating the above requirements on multiple header
      fields with the same name.  Since it cannot be combined into a
      single field-value, recipients ought to handle &quot;Set-Cookie&quot; as a
      special case while processing header fields.  (See &lt;a href=&quot;#appendix-A.2.3&quot;&gt;Appendix A.2.3&lt;/a&gt;
      of [&lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;] for details.)</source>
          <target state="translated">필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 구현시 가능한 한 빨리 메시지를 처리하지 않을지 결정할 수 있도록 요청시 호스트 및 응답 날짜와 같은 제어 데이터가 포함 된 헤더 필드를 보내는 것이 좋습니다. 서버는 전체 요청 헤더 섹션이 수신 될 때까지 대상 리소스에 요청을 적용해서는 안됩니다. 이후 헤더 필드에는 조건부, 인증 자격 증명 또는 요청 처리에 영향을 줄 의도적으로 잘못된 헤더 필드가 포함될 수 있기 때문입니다. 발신자는 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록으로 정의되지 않는 한 메시지에서 동일한 필드 이름을 가진 여러 헤더 필드를 생성해서는 안됩니다 (예 :# (값)] 또는 헤더 필드는 잘 알려진 예외입니다 (아래에 언급 된 바와 같이). 수신자는 메시지의 의미를 변경하지 않고 동일한 필드 이름을 가진 여러 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있습니다. 각 후속 필드 값을 순서대로 결합 된 필드 값에 반점. 따라서 동일한 필드 이름을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT). 참고 : 실제로 &quot;Set-Cookie&quot;헤더 필드 ([메시지의 의미를 변경하지 않고 각 후속 필드 값을 결합 된 필드 값에 쉼표로 구분하여 순서대로 추가합니다. 따라서 동일한 필드 이름을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT). 참고 : 실제로 &quot;Set-Cookie&quot;헤더 필드 ([메시지의 의미를 변경하지 않고 각 후속 필드 값을 결합 된 필드 값에 쉼표로 구분하여 순서대로 추가합니다. 따라서 동일한 필드 이름을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT). 참고 : 실제로 &quot;Set-Cookie&quot;헤더 필드 ([실제로 &quot;Set-Cookie&quot;헤더 필드 ([실제로 &quot;Set-Cookie&quot;헤더 필드 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ])는 종종 응답 메시지에 여러 번 나타나며 동일한 이름을 가진 여러 헤더 필드에서 위 요구 사항을 위반하여 목록 구문을 사용하지 않습니다. 단일 필드 값으로 결합 될 수 없으므로 수신자는 헤더 필드를 처리하는 동안 &quot;Set-Cookie&quot;를 특수한 경우로 처리해야합니다. (자세한 내용 은 [ &lt;a href=&quot;#ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ] 의 &lt;a href=&quot;#appendix-A.2.3&quot;&gt;부록 A.2.3&lt;/a&gt; 을 참조 하십시오.)</target>
        </trans-unit>
        <trans-unit id="18149c10ff86aae91ec06cd0aef8f5de4440363f" translate="yes" xml:space="preserve">
          <source>The origin is a URI indicating the server from which the request initiated. It does not include any path information, but only the server name.</source>
          <target state="translated">오리진은 요청이 시작된 서버를 나타내는 URI입니다. 경로 정보는 포함하지 않고 서버 이름 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="26e7668fe582d80ecc70504dac9a50d81f54d606" translate="yes" xml:space="preserve">
          <source>The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.</source>
          <target state="translated">오리진 서버는 요청이 조건부이어야합니다. 클라이언트가 자원 상태를 가져 와서 수정 한 후 서버에 다시 PUT하는 '손실 된 업데이트'문제를 방지하기 위해 제 3자가 서버의 상태를 수정하여 충돌을 일으키는 경우.</target>
        </trans-unit>
        <trans-unit id="c28b7e0ef7daf83cb81a618727021028721dfa63" translate="yes" xml:space="preserve">
          <source>The original WebDAV model for locking unmapped URLs created &quot;lock-
   null resources&quot;.  This model was over-complicated and some
   interoperability and implementation problems were discovered.  The
   new WebDAV model for locking unmapped URLs (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;) creates
   &quot;locked empty resources&quot;.  Lock-null resources are deprecated.  This
   section discusses the original model briefly because clients MUST be
   able to handle either model.

   In the original &quot;lock-null resource&quot; model, which is no longer
   recommended for implementation:

   o  A lock-null resource sometimes appeared as &quot;Not Found&quot;.  The
      server responds with a 404 or 405 to any method except for PUT,
      MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK.

   o  A lock-null resource does however show up as a member of its
      parent collection.

   o  The server removes the lock-null resource entirely (its URI
      becomes unmapped) if its lock goes away before it is converted to
      a regular resource.  Recall that locks go away not only when they
      expire or are unlocked, but are also removed if a resource is
      renamed or moved, or if any parent collection is renamed or moved. 

   o  The server converts the lock-null resource into a regular resource
      if a PUT request to the URL is successful.

   o  The server converts the lock-null resource into a collection if a
      MKCOL request to the URL is successful (though interoperability
      experience showed that not all servers followed this requirement).

   o  Property values were defined for DAV:lockdiscovery and DAV:
      supportedlock properties but not necessarily for other properties
      like DAV:getcontenttype.

   Clients can easily interoperate both with servers that support the
   old model &quot;lock-null resources&quot; and the recommended model of &quot;locked
   empty resources&quot; by only attempting PUT after a LOCK to an unmapped
   URL, not MKCOL or GET.</source>
          <target state="translated">매핑되지 않은 URL을 잠그기위한 원래 WebDAV 모델은 &quot;lock-null resources&quot;를 만들었습니다. 이 모델은 지나치게 복잡해졌으며 일부 상호 운용성 및 구현 문제가 발견되었습니다. 매핑되지 않은 URL을 잠그기위한 새로운 WebDAV 모델 ( &lt;a href=&quot;#section-7.3&quot;&gt;7.3 절&lt;/a&gt; 참조))는 &quot;잠긴 빈 자원&quot;을 작성합니다. 잠금 널 자원은 더 이상 사용되지 않습니다. 이 섹션에서는 클라이언트가 두 모델을 모두 처리 할 수 ​​있어야하므로 원래 모델에 대해 간략하게 설명합니다. 더 이상 구현에 권장되지 않는 원래 &quot;lock-null resource&quot;모델에서는 다음과 같습니다. o lock-null 리소스는 때때로 &quot;Not Found&quot;로 나타납니다. 서버는 PUT, MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK을 제외한 모든 방법에 대해 404 또는 405로 응답합니다. o 잠금 null 리소스는 그러나 부모 컬렉션의 멤버로 표시됩니다. o 잠금 자원이 일반 자원으로 변환되기 전에 잠금이 사라지면 서버는 잠금 널 자원을 완전히 제거합니다 (URI가 맵핑되지 않음). 잠금은 만료되거나 잠금 해제 될 때뿐만 아니라자원의 이름이 바뀌거나 이동되거나 상위 컬렉션의 이름이 바뀌거나 이동되는 경우에도 제거됩니다. o URL에 대한 PUT 요청이 성공하면 서버는 잠금 널 자원을 일반 자원으로 변환합니다. o URL에 대한 MKCOL 요청이 성공하면 서버는 잠금 널 자원을 콜렉션으로 변환합니다 (상호 운용성 경험에 따르면 모든 서버가이 요구 사항을 준수하지는 않음). o 속성 값은 DAV : lockdiscovery 및 DAV : supportedlock 속성에 대해 정의되었지만 반드시 DAV : getcontenttype과 같은 다른 속성에 대해서는 정의되지 않았습니다. 클라이언트는 이전 모델 &quot;lock-null resources&quot;를 지원하는 서버와 &quot;locked empty resources&quot;권장 모델을 쉽게 상호 운용 할 수 있습니다.MKCOL 또는 GET이 아닌 매핑되지 않은 URL에 대한 잠금 후 PUT 만 시도합니다.</target>
        </trans-unit>
        <trans-unit id="351291dcc2c8f40b6fda3d0b9fb11a63f52c019f" translate="yes" xml:space="preserve">
          <source>The original model of HTTP, and the default one in HTTP/1.0, is &lt;em&gt;short-lived connections&lt;/em&gt;. Each HTTP request is completed on its own connection; this means a TCP handshake happens before each HTTP request, and these are serialized.</source>
          <target state="translated">HTTP의 원래 모델과 HTTP / 1.0의 기본 모델은 &lt;em&gt;수명&lt;/em&gt; 이 &lt;em&gt;짧은 연결&lt;/em&gt; 입니다. 각 HTTP 요청은 자체 연결로 완료됩니다. 즉, 각 HTTP 요청 전에 TCP 핸드 셰이크가 발생하고 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="79e460eb743f85621e4024af0b7bff004e6c3d39" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; HTTP 헤더에 의해 지정된 원래 정책 .</target>
        </trans-unit>
        <trans-unit id="4893fed57017b899f622f28734ae6d2fe80b3b77" translate="yes" xml:space="preserve">
          <source>The original policy as specified by the &lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP header.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; HTTP 헤더에 의해 지정된 원래 정책 .</target>
        </trans-unit>
        <trans-unit id="65440960b2a3f39f3e1fd7555605568089a8d96a" translate="yes" xml:space="preserve">
          <source>The original vision of Tim Berners-Lee for the Web wasn't a read-only medium. He envisioned a Web where people can add and move documents remotely, a kind of distributed file system. Around 1996, HTTP has been extended to allow authoring, and a standard called WebDAV was created. It has been further extended for specific applications like CardDAV to handle address book entries and CalDAV to deal with calendars. But all these *DAV extensions had a flaw: they had to be implemented by the servers to be used, which was quite complex. Their use on Web realms stayed confidential.</source>
          <target state="translated">웹에 대한 Tim Berners-Lee의 원래 비전은 읽기 전용 매체가 아닙니다. 그는 사람들이 문서를 원격으로 추가하고 이동할 수있는 일종의 분산 파일 시스템 인 웹을 구상했습니다. 1996 년 경, HTTP는 저작을 허용하도록 확장되었으며 WebDAV라는 표준이 만들어졌습니다. CardDAV와 같은 특정 응용 프로그램에서 주소록 항목을 처리하고 CalDAV를 사용하여 달력을 처리하도록 확장되었습니다. 그러나 이러한 모든 * DAV 확장에는 결함이있었습니다. 사용할 서버에서 구현해야했기 때문에 상당히 복잡했습니다. 웹 영역에서의 사용은 기밀로 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec62cbdca93d2ad4ec39377f99d81883dfe1d146" translate="yes" xml:space="preserve">
          <source>The output will look something like this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa47362e2b58ce7c1d4859c59d1d577c32eab05a" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the same origin as the page itself. The spec leaves it up to browser vendors to decide whether this option applies to the top level, the parent, or the whole chain, although it is argued that the option is not very useful unless all ancestors are also in the same origin (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;bug 725490&lt;/a&gt;). Also see &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for support details.</source>
          <target state="translated">페이지는 페이지 자체와 동일한 원점의 프레임에만 표시 될 수 있습니다. 스펙은이 옵션이 최상위 레벨, 상위 또는 전체 체인에 적용되는지 여부를 브라우저 공급 업체에 맡겨 둡니다. 그러나 모든 조상이 동일한 출처에 있지 않으면 옵션이 그다지 유용하지 않다고 주장합니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=725490&quot;&gt;버그&lt;/a&gt; 참조) 725490 ). 지원 세부 사항 은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="87ed0031ffdd1f701402da552456ef09ffc21cb3" translate="yes" xml:space="preserve">
          <source>The page can only be displayed in a frame on the specified origin. Note that in Firefox this still suffers from the same problem as &lt;code&gt;sameorigin&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin.</source>
          <target state="translated">페이지는 지정된 원점의 프레임에만 표시 될 수 있습니다. Firefox에서 이것은 &lt;code&gt;sameorigin&lt;/code&gt; 과 동일한 문제를 여전히 겪 습니다. 프레임 조상이 동일한 원점인지 확인하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fd708bba3250a928bde72e278816558269ceee3" translate="yes" xml:space="preserve">
          <source>The page cannot be displayed in a frame, regardless of the site attempting to do so.</source>
          <target state="translated">사이트는 시도하려는 사이트에 관계없이 프레임에 페이지를 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e65beef9355c724f3b8565f6ab1fad05b9ee018" translate="yes" xml:space="preserve">
          <source>The parameters &quot;filename&quot; and &quot;filename*&quot; differ only in that &quot;filename*&quot; uses the encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;. When both &quot;filename&quot; and &quot;filename*&quot; are present in a single header field value, &quot;filename*&quot; is preferred over &quot;filename&quot; when both are understood.</source>
          <target state="translated">&quot;filename&quot;및 &quot;filename *&quot;매개 변수는 &quot;filename *&quot;이 &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987에&lt;/a&gt; 정의 된 인코딩을 사용한다는 점에서만 다릅니다 . 단일 헤더 필드 값에 &quot;filename&quot;과 &quot;filename *&quot;이 모두 있으면 &quot;filename *&quot;이 둘 다 이해 될 때 &quot;filename&quot;보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="f73b0f673ad4f6ff6cd78d437d63486d3077a18d" translate="yes" xml:space="preserve">
          <source>The path of the resource to fetch; the URL of the resource stripped from elements that are obvious from the context, for example without the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;protocol&lt;/a&gt; (&lt;code&gt;http://&lt;/code&gt;), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;domain&lt;/a&gt; (here &lt;code&gt;developer.mozilla.org&lt;/code&gt;), or the TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;port&lt;/a&gt; (here &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">가져올 리소스의 경로입니다. 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/protocol&quot;&gt;프로토콜&lt;/a&gt; ( &lt;code&gt;http://&lt;/code&gt; ), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/domain&quot;&gt;도메인&lt;/a&gt; (여기서는 &lt;code&gt;developer.mozilla.org&lt;/code&gt; ) 또는 TCP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/port&quot;&gt;포트&lt;/a&gt; (여기서는 &lt;code&gt;80&lt;/code&gt; )가 없는 컨텍스트에서 명백한 요소에서 제거 된 자원의 URL</target>
        </trans-unit>
        <trans-unit id="21d24dd0cdd0a56d270ae234ba2ae51b6e5cb97c" translate="yes" xml:space="preserve">
          <source>The performance of web sites and applications can be significantly improved by reusing previously fetched resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a representation of a resource. By making use of HTTP caching, Web sites become more responsive.</source>
          <target state="translated">이전에 가져온 리소스를 재사용하여 웹 사이트 및 응용 프로그램의 성능을 크게 향상시킬 수 있습니다. 웹 캐시는 대기 시간과 네트워크 트래픽을 줄이고 리소스 표현을 표시하는 데 필요한 시간을 줄입니다. HTTP 캐싱을 사용하면 웹 사이트의 응답 성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef7dc4ef4177a90ccc5fba5f3743824b87bfd8e" translate="yes" xml:space="preserve">
          <source>The policy is a string containing the policy directives describing your Content Security Policy.</source>
          <target state="translated">정책은 콘텐츠 보안 정책을 설명하는 정책 지시문이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1cde3605fdc2afc6de4d0a52e9aa9896f47fafaf" translate="yes" xml:space="preserve">
          <source>The policy:</source>
          <target state="translated">정책 :</target>
        </trans-unit>
        <trans-unit id="776afe838427d09cf840d7fc30aa63d4eaa2c3d9" translate="yes" xml:space="preserve">
          <source>The precondition given in one or more of the request-header fields
   evaluated to false when it was tested on the server. This response
   code allows the client to place preconditions on the current resource
   metainformation (header field data) and thus prevent the requested
   method from being applied to a resource other than the one intended.</source>
          <target state="translated">하나 이상의 요청 헤더 필드에 지정된 전제 조건이 서버에서 테스트 될 때 false로 평가되었습니다. 이 응답 코드를 통해 클라이언트는 현재 자원 메타 정보 (헤더 필드 데이터)에 사전 조건을 설정하여 요청 된 메소드가 의도 한 것과 다른 자원에 적용되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82d265543b246e66360f0830a564b27c84119c7f" translate="yes" xml:space="preserve">
          <source>The preferred way to target content to a device form factor is to use CSS Media Queries. However, if you use UA sniffing to target content to a device form factor, please look for &lt;strong&gt;Mobi&lt;/strong&gt; (to include Opera Mobile, which uses &quot;Mobi&quot;) for the phone form factor and do &lt;strong&gt;not&lt;/strong&gt; assume any correlation between &quot;Android&quot; and the device form factor. This way, your code will work if/when Firefox ships on other phone/tablet operating systems or Android is used for laptops. Also, please use touch detection to find touch devices rather than looking for &quot;Mobi&quot; or &quot;Tablet&quot;, since there may be touch devices which are not tablets.</source>
          <target state="translated">컨텐트를 장치 폼 팩터에 대상으로 지정하는 가장 좋은 방법은 CSS 미디어 쿼리를 사용하는 것입니다. 그러나 UA 스니핑을 사용하여 콘텐츠를 장치 폼 팩터에 대상으로 지정하는 경우 전화 폼 팩터에 대해 &lt;strong&gt;Mobi&lt;/strong&gt; ( &quot;Mobi&quot;를 사용하는 Opera Mobile 포함)를 찾아 &quot;Android&quot;와 장치 사이의 상관 관계를 가정 하지 &lt;strong&gt;마십시오&lt;/strong&gt; 폼 팩터. 이런 식으로 Firefox가 다른 휴대 전화 / 태블릿 운영 체제 또는 Android에 제공되는 경우 랩톱에 코드가 작동하는 경우 코드가 작동합니다. 또한 태블릿이 아닌 터치 장치가있을 수 있으므로 &quot;Mobi&quot;또는 &quot;태블릿&quot;을 찾는 대신 터치 감지를 사용하여 터치 장치를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="336e39ad55330caf3f7eb800fefcd2e0dc7dd455" translate="yes" xml:space="preserve">
          <source>The preflight request simply suffered any kind of networking error that might ordinarily occur.</source>
          <target state="translated">프리 플라이트 요청에는 일반적으로 발생할 수있는 모든 종류의 네트워킹 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="debdc150f8d10727246ce79b174d0a3a9962d2c4" translate="yes" xml:space="preserve">
          <source>The previous example was illegal because it contained two elements
   that were explicitly banned from appearing together in the propfind
   element.  However, XML is an extensible language, so one can imagine
   new elements being defined for use with propfind.  Below is the
   request body of a PROPFIND and, like the previous example, must be
   rejected with a 400 (Bad Request) by a server that does not
   understand the expired-props element.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
      xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;E:expired-props/&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   To understand why a 400 (Bad Request) is returned, let us look at the
   request body as the server unfamiliar with expired-props sees it.

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   As the server does not understand the 'expired-props' element,
   according to the WebDAV-specific XML processing rules specified in
   &lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;, it must process the request as if the element were not
   there.  Thus, the server sees an empty propfind, which by the
   definition of the propfind element is illegal.

   Please note that had the extension been additive, it would not
   necessarily have resulted in a 400 (Bad Request).  For example,
   imagine the following request body for a PROPFIND:


      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;
                  xmlns:E=&quot;http://www.example.com/standards/props/&quot;&amp;gt;
       &amp;lt;D:propname/&amp;gt;
       &amp;lt;E:leave-out&amp;gt;*boss*&amp;lt;/E:leave-out&amp;gt;
      &amp;lt;/D:propfind&amp;gt;

   The previous example contains the fictitious element leave-out.  Its
   purpose is to prevent the return of any property whose name matches
   the submitted pattern.  If the previous example were submitted to a
   server unfamiliar with 'leave-out', the only result would be that the
   'leave-out' element would be ignored and a propname would be
   executed.</source>
          <target state="translated">앞의 예제에는 propfind 요소에 함께 나타나지 않는 두 개의 요소가 포함되어있어 불법입니다. 그러나 XML은 확장 가능한 언어이므로 propfind와 함께 사용하기 위해 정의 된 새로운 요소를 상상할 수 있습니다. 아래는 PROPFIND의 요청 본문이며 이전 예제와 같이 expired-props 요소를 이해하지 못하는 서버에서 400 (잘못된 요청)으로 거부해야합니다. &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;xmlns : E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt;E : expired-props /&amp;gt; &amp;lt;/ D : propfind&amp;gt; 400 (잘못된 요청)이 반환되는 이유를 이해하기 위해 만료 된 props에 익숙하지 않은 서버에서이를 본 요청 본문을 살펴 보겠습니다. &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;xmlns : E = &quot;http://www.example.com/standards/props/&quot;&amp;gt; &amp;lt; / D : propfind&amp;gt; 서버가 'expired-props'요소를 이해하지 못하므로 WebDAV 관련 XML 처리 규칙에 따라 &lt;a href=&quot;#section-17&quot;&gt;섹션 17&lt;/a&gt;요소가없는 것처럼 요청을 처리해야합니다. 따라서 서버는 빈 propfind를보고 propfind 요소의 정의에 의해 불법입니다. 확장이 부가 적 이었음에 따라 반드시 400 (잘못된 요청)이되지는 않았을 것입니다. 예를 들어 PROPFIND에 대한 다음 요청 본문을 상상해보십시오. &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;xmlns : E = &quot;http : // www.example.com/standards/props / &quot;&amp;gt; &amp;lt;D : propname /&amp;gt; &amp;lt;E : leave-out&amp;gt; * boss * &amp;lt;/ E : leave-out&amp;gt; &amp;lt;/ D : propfind&amp;gt; 위의 예에는 가상의 요소가 있습니다. -밖. 그 목적은 제출 된 패턴과 이름이 일치하는 속성이 반환되지 않도록하는 것입니다.이전 예가 'leave-out'에 익숙하지 않은 서버에 제출 된 경우 유일한 결과는 'leave-out'요소가 무시되고 propname이 실행되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ae30a0f00a7837d72ecd861dd4a6d9fd65f4447" translate="yes" xml:space="preserve">
          <source>The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (&lt;a href=&quot;#section-3.1.1.3&quot;&gt;Section 3.1.1.3&lt;/a&gt; and &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;)

   To be consistent with the method-neutral parsing algorithm of
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;)

   Definition of the CONNECT method has been moved from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;] to
   this specification.  (&lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt;)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; and &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) 

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;)

   The &quot;about:blank&quot; URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (&lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (&lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (&lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; and &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (&lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (&lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (&lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;)

   The 426 (Upgrade Required) status code has been incorporated from
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;].  (&lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;) 

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (&lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;)

   A Method Registry has been defined.  (&lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.
   (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;)

   Registration of content codings has been changed to require IETF
   Review.  (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;)

   The Content-Disposition header field has been removed since it is now
   defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt;].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.</source>
          <target state="translated">이 개정판의 주요 변경 사항은 본질적으로 편집 기능입니다. 메시징 구문 추출 및 HTTP 시맨틱을 핵심 기능, 조건부 요청, 부분 요청, 캐싱 및 인증에 대한 별도의 문서로 분할합니다. 적합성 언어는 요구 사항을 명확하게 목표로 수정되었으며 페이로드와 표현 및 자원을 구별하기 위해 용어가 개선되었습니다. 상호 운용성 오류의 일반적인 원인이기 때문에 이러한 의미 체계가 요청 방법과 일치하지 않으면 URI에 포함 된 의미 체계를 비활성화해야한다는 새로운 요구 사항이 추가되었습니다. ( &lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt; ) 페이로드가 특정 식별자와 연관되어 있는지 판별하기위한 알고리즘이 추가되었습니다. ( &lt;a href=&quot;#section-3.1.4.1&quot;&gt;3.1.4.1 항&lt;/a&gt;) 텍스트 미디어 유형에 대한 기본 문자셋 ISO-8859-1이 제거되었습니다. 미디어 유형 정의에 따라 기본값이 설정됩니다. 마찬가지로 ISO-8859-1의 특수 처리가 Accept-Charset 헤더 필드에서 제거되었습니다. ( &lt;a href=&quot;#section-3.1.1.3&quot;&gt;3.1.1.3&lt;/a&gt; 및 &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3 섹션&lt;/a&gt; ) Content-Location의 정의는 구현 지원이 불량하고 컨텐츠에서 상대 링크를 잠재적으로 중단시키는 바람직하지 않은 효과로 인해 상대 URI 참조를 해결하기위한 기본 URI에 더 이상 영향을 미치지 않도록 변경되었습니다. 협상 된 자원. ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; ) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; 의 메소드 중립적 파싱 알고리즘과 일치], 본문은 GET에 의미가 없지만 요청이 본문을 가질 수 있도록 GET의 정의가 완화되었습니다. ( &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; ) 서버는 더 이상 모든 Content- * 헤더 필드를 처리 할 필요가 없으며 PUT 요청에서 Content-Range 사용이 명시 적으로 금지되었습니다. ( &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4 항&lt;/a&gt; ) CONNECT 방법의 정의가 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ]에서이 사양 으로 이동되었습니다 . ( &lt;a href=&quot;#section-4.3.6&quot;&gt;4.3.6 절&lt;/a&gt; ) OPTIONS 및 TRACE 요청 방법은 안전하다고 정의되었습니다. ( &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7&lt;/a&gt; 및 &lt;a href=&quot;#section-4.3.8&quot;&gt;4.3.8 단원&lt;/a&gt; ) Expect 헤더 필드의 확장 메커니즘은 광범위하게 배포 된 깨진 구현으로 인해 제거되었습니다. ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt;) Max-Forwards 헤더 필드가 OPTIONS 및 TRACE 메소드로 제한되었습니다. 이전에는 확장 방법으로도 사용할 수있었습니다. ( &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; ) 참조 URI가 적용되지 않는 경우 &quot;about : blank&quot;URI가 Referer 헤더 필드의 값으로 제안되었으며,이 경우 Referer 필드가 전송되지 않거나 제거 된 다른 경우와 구별됩니다. ( &lt;a href=&quot;#section-5.5.2&quot;&gt;섹션 5.5.2&lt;/a&gt; ) 이제 다음 상태 코드를 캐시 할 수 있습니다 (즉, 명시 적 최신 정보가없는 캐시에서 저장 및 재사용 할 수 있음) : 204, 404, 405, 414, 501. ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 201 ( 작성 됨) 상태 설명이 둘 이상의 자원이 작성 될 수 있도록 변경되었습니다. (&lt;a href=&quot;#section-6.3.2&quot;&gt;섹션 6.3.2&lt;/a&gt; ) 페이로드 변환 사례도 포함하도록 203 (비 정식 정보 )의 정의가 확대되었습니다. ( &lt;a href=&quot;#section-6.3.4&quot;&gt;섹션 6.3.4&lt;/a&gt; ) 자동 리디렉션이 안전한 요청 메소드 세트가 더 이상 닫히지 않습니다. 사용자 에이전트는 요청 방법 시맨틱에 기초하여 결정을 내릴 수 있습니다. 리디렉션 상태 코드 301, 302 및 307에는 더 이상 응답 페이로드 및 사용자 상호 작용에 대한 규범적인 요구 사항이 없습니다. ( &lt;a href=&quot;#section-6.4&quot;&gt;6.4 절&lt;/a&gt; ) 상태 코드 301 및 302는 사용자 에이전트가 POST에서 GET으로 메소드를 다시 작성할 수 있도록 변경되었습니다. (섹션 &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; 및 &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;) 명시 적 최신 정보가 제공 될 경우 캐시 될 수 있도록 303 (기타 참조) 상태 코드에 대한 설명이 변경되었으며 GET에 대한 303 응답에 대한 특정 정의가 추가되었습니다. ( &lt;a href=&quot;#section-6.4.4&quot;&gt;섹션 6.4.4&lt;/a&gt; ) 프록시의 대역 내 구성과 관련된 보안 문제로 인해 305 (프록시 사용) 상태 코드가 사용되지 않습니다. ( &lt;a href=&quot;#section-6.4.5&quot;&gt;섹션 6.4.5&lt;/a&gt; ) 400 (잘못된 요청) 상태 코드는 구문 오류로 제한되지 않도록 완화되었습니다. ( &lt;a href=&quot;#section-6.5.1&quot;&gt;섹션 6.5.1&lt;/a&gt; ) 426 (업그레이드 필요) 상태 코드는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] 에서 통합되었습니다 . ( &lt;a href=&quot;#section-6.5.15&quot;&gt;섹션 6.5.15&lt;/a&gt;) HTTP-date 및 Date 헤더 필드의 요구 사항 대상은 날짜를 보내는 모든 시스템이 아니라 날짜를 생성하는 시스템으로 축소되었습니다. ( &lt;a href=&quot;#section-7.1.1&quot;&gt;7.1.1 절&lt;/a&gt; ) Location 헤더 필드의 구문은 프래그먼트 사용이 적절하지 않은 경우에 대한 설명과 함께 상대 참조 및 프래그먼트를 포함한 모든 URI 참조를 허용하도록 변경되었습니다. ( &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2 절&lt;/a&gt; ) 허용은 PUT 요청에 지정할 수있는 옵션을 제거하여 응답 헤더 필드로 다시 분류되었습니다. Allow의 내용과 관련된 요구 사항이 완화되었습니다. 따라서 고객은 항상 그 가치를 신뢰할 필요는 없습니다. ( &lt;a href=&quot;#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt; ) 메소드 레지스트리가 정의되었습니다. (&lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; ) 상태 코드 레지스트리는이 사양에 의해 재정의되었습니다. 이전 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;에는 [RFC2817] 7.1 절&lt;/a&gt; 에서 정의되었다 . ( &lt;a href=&quot;#section-8.2&quot;&gt;섹션 8.2&lt;/a&gt; ) 컨텐츠 코딩 등록이 IETF 검토를 요구하도록 변경되었습니다. ( &lt;a href=&quot;#section-8.4&quot;&gt;섹션 8.4&lt;/a&gt; ) Content-Disposition 헤더 필드는 이제 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC6266&lt;/a&gt; ]에 의해 정의되었으므로 제거되었습니다 . Content-MD5 헤더 필드는 부분 응답과 관련하여 일관성이 없어서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="e12309a2843027455af9add0576f0892e2a69fde" translate="yes" xml:space="preserve">
          <source>The primary difference between the HTTP header and the &lt;code&gt;allow&lt;/code&gt; attribute is that the allow attribute only controls features within an iframe. The header controls features in the response and any embedded content within the page.</source>
          <target state="translated">HTTP 헤더와 &lt;code&gt;allow&lt;/code&gt; 속성 의 주요 차이점은 allow 속성은 iframe 내의 기능 만 제어한다는 것입니다. 헤더는 응답의 기능 및 페이지 내의 임베드 된 컨텐츠를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b50ebcbe3e89d6447760b75f1e616af6abba5bb8" translate="yes" xml:space="preserve">
          <source>The principle behind entity tags is that only the service author
   knows the semantics of a resource well enough to select an
   appropriate cache validation mechanism, and the specification of any
   validator comparison function more complex than byte-equality would
   open up a can of worms. Thus, comparisons of any other headers
   (except Last-Modified, for compatibility with HTTP/1.0) are never
   used for purposes of validating a cache entry.</source>
          <target state="translated">엔티티 태그의 기본 원리는 서비스 작성자 만이 적절한 캐시 유효성 검사 메커니즘을 선택할 수있을만큼 리소스의 의미를 잘 알고 있으며 바이트 평형보다 복잡한 모든 유효성 검사기 비교 기능을 지정하면 웜이 발생할 수 있다는 것입니다. 따라서 다른 헤더의 비교 (HTTP / 1.0과의 호환성을 위해 Last-Modified 제외)는 캐시 항목의 유효성 검증을 위해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e894f8457ed794b88882865f6c9931e22354537d" translate="yes" xml:space="preserve">
          <source>The principle behind entity-tags is that only the service author
   knows the implementation of a resource well enough to select the most
   accurate and efficient validation mechanism for that resource, and
   that any such mechanism can be mapped to a simple sequence of octets
   for easy comparison.  Since the value is opaque, there is no need for
   the client to be aware of how each entity-tag is constructed.

   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.  Other
   implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.

   An origin server SHOULD send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity-tag's use in conditional requests and
   evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) can result in a substantial
   reduction of HTTP network traffic and can be a significant factor in
   improving service scalability and reliability.</source>
          <target state="translated">엔티티 태그의 기본 원리는 서비스 작성자 만이 해당 리소스에 대해 가장 정확하고 효율적인 유효성 검사 메커니즘을 선택할 수있을만큼 리소스의 구현을 잘 알고 있으며 이러한 메커니즘은 간단한 비교를 위해 간단한 일련의 8 진수로 매핑 될 수 있다는 것입니다. . 값이 불투명하기 때문에 클라이언트가 각 엔티티 태그가 구성되는 방식을 알 필요가 없습니다. 예를 들어, 모든 변경 사항에 구현 별 버전 관리가 적용된 리소스는 내용을 협상하기 위해 분산 식별자와 결합 된 내부 수정 번호를 사용하여 표현을 정확하게 구분할 수 있습니다. 다른 구현에서는 다양한 파일 속성의 조합으로 표현 내용의 충돌 방지 해시를 사용할 수 있습니다.또는 초 미만의 해상도를 갖는 수정 타임 스탬프. 오리진 서버는 엔터티 태그가 조건부 요청에 사용되고 캐시 신선도를 평가하기 때문에 변경 감지가 합리적이고 일관되게 결정될 수있는 선택된 표현에 대해 ETag를 보내야한다.&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ])는 HTTP 네트워크 트래픽을 상당히 감소시킬 수 있으며 서비스 확장 성과 안정성을 향상시키는 데 중요한 요소가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1875060cbf6a72a618b42c5d094d85aee6d41e8" translate="yes" xml:space="preserve">
          <source>The principle is simple, but there is one potential problem: if the downloaded resource has been modified between both downloads, the obtained ranges will correspond to two different versions of the resource, and the final document will be corrupted.</source>
          <target state="translated">원칙은 간단하지만 한 가지 잠재적 인 문제가 있습니다. 두 다운로드간에 다운로드 된 리소스가 수정 된 경우 획득 한 범위는 서로 다른 두 버전의 리소스에 해당하며 최종 문서가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="2f036bd357e0e56c778c2d79ff8ac18d032812cb" translate="yes" xml:space="preserve">
          <source>The protocol that is used. Usually it is the HTTP protocol or its secured version, HTTPS.</source>
          <target state="translated">사용되는 프로토콜. 일반적으로 HTTP 프로토콜 또는 보안 버전 인 HTTPS입니다.</target>
        </trans-unit>
        <trans-unit id="2ec525dcadd68d3467f5291ea2396006096b487a" translate="yes" xml:space="preserve">
          <source>The purpose of an HTTP cache is to store information received in
   response to requests for use in responding to future requests. In
   many cases, a cache simply returns the appropriate parts of a
   response to the requester. However, if the cache holds a cache entry
   based on a previous response, it might have to combine parts of a new
   response with what is held in the cache entry.</source>
          <target state="translated">HTTP 캐시의 목적은 향후 요청에 응답하는 데 사용하기위한 요청에 대한 응답으로 수신 된 정보를 저장하는 것입니다. 대부분의 경우 캐시는 단순히 요청의 적절한 부분을 요청자에게 반환합니다. 그러나 캐시가 이전 응답을 기반으로 캐시 항목을 보유하는 경우 새 응답의 일부를 캐시 항목에 보유 된 내용과 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="6728c1b09c31f5d826dfb315c8231a9800e8a7de" translate="yes" xml:space="preserve">
          <source>The purpose of the 100 (Continue) status (see &lt;a href=&quot;#section-10.1.1&quot;&gt;section 10.1.1&lt;/a&gt;) is to
   allow a client that is sending a request message with a request body
   to determine if the origin server is willing to accept the request
   (based on the request headers) before the client sends the request
   body. In some cases, it might either be inappropriate or highly
   inefficient for the client to send the body if the server will reject
   the message without looking at the body.

   Requirements for HTTP/1.1 clients:

      - If a client will wait for a 100 (Continue) response before
        sending the request body, it MUST send an Expect request-header
        field (&lt;a href=&quot;#section-14.20&quot;&gt;section 14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation.

      - A client MUST NOT send an Expect request-header field (&lt;a href=&quot;#section-14.20&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) with the &quot;100-continue&quot; expectation if it does not intend
        to send a request body.

   Because of the presence of older implementations, the protocol allows
   ambiguous situations in which a client may send &quot;Expect: 100-
   continue&quot; without receiving either a 417 (Expectation Failed) status
   or a 100 (Continue) status. Therefore, when a client sends this
   header field to an origin server (possibly via a proxy) from which it
   has never seen a 100 (Continue) status, the client SHOULD NOT wait
   for an indefinite period before sending the request body.

   Requirements for HTTP/1.1 origin servers:

      - Upon receiving a request which includes an Expect request-header
        field with the &quot;100-continue&quot; expectation, an origin server MUST
        either respond with 100 (Continue) status and continue to read
        from the input stream, or respond with a final status code. The
        origin server MUST NOT wait for the request body before sending
        the 100 (Continue) response. If it responds with a final status
        code, it MAY close the transport connection or it MAY continue 

        to read and discard the rest of the request.  It MUST NOT
        perform the requested method if it returns a final status code.

      - An origin server SHOULD NOT send a 100 (Continue) response if
        the request message does not include an Expect request-header
        field with the &quot;100-continue&quot; expectation, and MUST NOT send a
        100 (Continue) response if such a request comes from an HTTP/1.0
        (or earlier) client. There is an exception to this rule: for
        compatibility with &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, a server MAY send a 100 (Continue)
        status in response to an HTTP/1.1 PUT or POST request that does
        not include an Expect request-header field with the &quot;100-
        continue&quot; expectation. This exception, the purpose of which is
        to minimize any client processing delays associated with an
        undeclared wait for 100 (Continue) status, applies only to
        HTTP/1.1 requests, and not to requests with any other HTTP-
        version value.

      - An origin server MAY omit a 100 (Continue) response if it has
        already received some or all of the request body for the
        corresponding request.

      - An origin server that sends a 100 (Continue) response MUST
        ultimately send a final status code, once the request body is
        received and processed, unless it terminates the transport
        connection prematurely.

      - If an origin server receives a request that does not include an
        Expect request-header field with the &quot;100-continue&quot; expectation,
        the request includes a request body, and the server responds
        with a final status code before reading the entire request body
        from the transport connection, then the server SHOULD NOT close
        the transport connection until it has read the entire request,
        or until the client closes the connection. Otherwise, the client
        might not reliably receive the response message. However, this
        requirement is not be construed as preventing a server from
        defending itself against denial-of-service attacks, or from
        badly broken client implementations.

   Requirements for HTTP/1.1 proxies:

      - If a proxy receives a request that includes an Expect request-
        header field with the &quot;100-continue&quot; expectation, and the proxy
        either knows that the next-hop server complies with HTTP/1.1 or
        higher, or does not know the HTTP version of the next-hop
        server, it MUST forward the request, including the Expect header
        field. 

      - If the proxy knows that the version of the next-hop server is
        HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST
        respond with a 417 (Expectation Failed) status.

      - Proxies SHOULD maintain a cache recording the HTTP version
        numbers received from recently-referenced next-hop servers.

      - A proxy MUST NOT forward a 100 (Continue) response if the
        request message was received from an HTTP/1.0 (or earlier)
        client and did not include an Expect request-header field with
        the &quot;100-continue&quot; expectation. This requirement overrides the
        general rule for forwarding of 1xx responses (see &lt;a href=&quot;#section-10.1&quot;&gt;section 10.1&lt;/a&gt;).</source>
          <target state="translated">100 (계속) 상태의 목적 ( &lt;a href=&quot;#section-10.1.1&quot;&gt;섹션 10.1.1&lt;/a&gt; 참조 )은 요청 본문과 함께 요청 메시지를 보내는 클라이언트가 오리진 서버가 요청을 수락 할 의사가 있는지 (요청 헤더를 기반으로) 결정할 수 있도록하는 것입니다. 클라이언트가 요청 본문을 보내기 전에 경우에 따라 서버가 본문을 보지 않고 메시지를 거부하면 클라이언트가 본문을 보내는 것이 부적절하거나 비효율적 일 수 있습니다. HTTP / 1.1 클라이언트에 대한 요구 사항 :-요청 본문을 보내기 전에 클라이언트가 100 (계속) 응답을 기다리는 경우 &quot;100-continue&quot;예상과 함께 Expect 요청 헤더 필드 ( &lt;a href=&quot;#section-14.20&quot;&gt;14.20 절&lt;/a&gt; )를 보내야합니다 . -고객은 Expect 요청 헤더 필드를 보내면 안됩니다 ( &lt;a href=&quot;#section-14.20&quot;&gt;섹션)&lt;/a&gt;&lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;) 요청 본문을 보내지 않으려는 경우 &quot;100-continue&quot;예상과 함께 이전 구현이 존재하기 때문에이 프로토콜은 클라이언트가 417 (예상 실패) 상태 또는 100 (계속) 상태를 수신하지 않고 &quot;예상 : 100- 계속&quot;을 보낼 수있는 모호한 상황을 허용합니다. 따라서 클라이언트가이 헤더 필드를 100 (계속) 상태를 보지 못한 원래 서버 (프록시를 통해)로 보낼 때 클라이언트는 요청 본문을 보내기 전에 무기한 대기하지 않아야합니다. HTTP / 1.1 오리진 서버 요구 사항 :- &quot;100-continue&quot;예상과 함께 Expect request-header 필드가 포함 된 요청을 수신하면,오리진 서버는 100 (Continue) 상태로 응답하고 입력 스트림에서 계속 읽거나 최종 상태 코드로 응답해야합니다. 오리진 서버는 100 (Continue) 응답을 보내기 전에 요청 본문을 기다리지 않아야합니다. 최종 상태 코드로 응답하면 전송 연결을 닫거나 나머지 요청을 계속 읽고 버릴 수 있습니다. 최종 상태 코드를 반환하면 요청 된 메소드를 수행해서는 안됩니다. -요청 메시지에 &quot;100-continue&quot;예상과 함께 Expect 요청 헤더 필드가 포함되어 있지 않으면 오리진 서버는 100 (계속) 응답을 보내지 말아야하며, 요청이 오면 100 (계속) 응답을 보내지 않아야합니다. HTTP / 1.0 (또는 이전) 클라이언트에서.이 규칙에는 예외가 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;서버는 HTTP / 1.1 PUT 또는 POST 요청에 대한 응답으로 &quot;계속&quot;이라는 예상 요청 헤더 필드를 포함하지 않는 100 (계속) 상태를 보낼 수 있습니다. 이 예외의 목적은 선언되지 않은 대기 100 (계속) 상태와 관련된 클라이언트 처리 지연을 최소화하기위한 것이며 다른 HTTP 버전 값이있는 요청에는 적용되지 않고 HTTP / 1.1 요청에만 적용됩니다. -오리진 서버는 해당 요청에 대한 요청 본문의 일부 또는 전부를 이미 수신 한 경우 100 (계속) 응답을 생략 할 수 있습니다. -100 (Continue) 응답을 보내는 오리진 서버는 요청 본문을 받고 처리 한 후에 최종 상태 코드를 보내야합니다.전송 연결을 조기에 종료하지 않는 한 -오리진 서버가 &quot;100-continue&quot;예상을 갖는 Expect request-header 필드를 포함하지 않는 요청을 수신하면 요청에 요청 본문이 포함되고 서버는 전체 요청 본문을 읽기 전에 최종 상태 코드로 응답합니다. 전송 연결의 경우 서버는 전체 요청을 읽거나 클라이언트가 연결을 닫을 때까지 전송 연결을 닫지 말아야합니다. 그렇지 않으면 클라이언트가 응답 메시지를 안정적으로받지 못할 수 있습니다. 그러나이 요구 사항은 서버가 서비스 거부 공격이나 잘못 구현 된 클라이언트 구현으로부터 자신을 방어하지 못하도록 해석되지는 않습니다.HTTP / 1.1 프록시 요구 사항 :-프록시가 &quot;100-continue&quot;예상과 함께 Expect request-header 필드를 포함하는 요청을 수신하고 프록시가 다음 홉 서버가 HTTP / 1.1 이상을 준수한다는 것을 알고있는 경우, 다음 홉 서버의 HTTP 버전을 모르는 경우 Expect 헤더 필드를 포함하여 요청을 전달해야합니다. -프록시가 다음 홉 서버의 버전이 HTTP / 1.0 이하임을 알고 있으면 요청을 전달해서는 안되며 417 (예상 실패) 상태로 응답해야합니다. -프록시는 최근에 참조 된 다음 홉 서버로부터 수신 한 HTTP 버전 번호를 기록하는 캐시를 유지해야합니다.-요청 메시지가 HTTP / 1.0 (또는 그 이전) 클라이언트로부터 수신되었고 &quot;100-continue&quot;예상과 함께 Expect 요청 헤더 필드를 포함하지 않은 경우 프록시는 100 (계속) 응답을 전달해서는 안됩니다. 이 요구 사항은 1xx 응답 전달에 대한 일반 규칙을 대체합니다 (참조&lt;a href=&quot;#section-10.1&quot;&gt;섹션 10.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b61f958141b9100243d1bc18970ced7c1dcafec" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded &lt;em&gt;Subject Public Key Information&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future. See below on how to extract this information out of a certificate or key file.</source>
          <target state="translated">인용 된 문자열은 Base64로 인코딩 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt; ( &lt;em&gt;Subject Public Key Information&lt;/em&gt; ) 지문입니다. 다른 공개 키에 대해 여러 개의 핀을 지정할 수 있습니다. 일부 브라우저는 나중에 SHA-256 이외의 다른 해싱 알고리즘을 허용 할 수 있습니다. 인증서 또는 키 파일에서이 정보를 추출하는 방법에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="caac15f88bc560faaa8d23301f149cd934db87b9" translate="yes" xml:space="preserve">
          <source>The quoted string is the Base64 encoded Subject Public Key Information (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt;) fingerprint. It is possible to specify multiple pins for different public keys. Some browsers might allow other hashing algorithms than SHA-256 in the future.</source>
          <target state="translated">인용 된 문자열은 Base64로 인코딩 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SPKI&quot;&gt;SPKI&lt;/a&gt; (Subject Public Key Information ) 지문입니다. 다른 공개 키에 대해 여러 개의 핀을 지정할 수 있습니다. 일부 브라우저는 나중에 SHA-256 이외의 다른 해싱 알고리즘을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="048868ca8bba5de4473c03e4f113e14a03b3840f" translate="yes" xml:space="preserve">
          <source>The range specified by the &lt;code&gt;Range&lt;/code&gt; header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.</source>
          <target state="translated">요청 의 &lt;code&gt;Range&lt;/code&gt; 헤더 필드에 지정된 범위를 이행 할 수 없습니다. 범위가 대상 URI 데이터의 크기를 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2b5330a14328ad92bbc96c72d50b3c95138424" translate="yes" xml:space="preserve">
          <source>The recommendation is to compress data as much as possible and therefore to use this field, but some types of resources, such as jpeg images, are already compressed. Sometimes, using additional compression doesn't reduce payload size and can even make the payload longer.</source>
          <target state="translated">권장 사항은 가능한 한 많이 데이터를 압축하여이 필드를 사용하는 것이지만 jpeg 이미지와 같은 일부 유형의 리소스는 이미 압축되어 있습니다. 때로는 추가 압축을 사용하더라도 페이로드 크기가 줄어들지 않고 페이로드가 더 길어질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4310de37bf5d5b890a2b93359f92ce5fd4a2747" translate="yes" xml:space="preserve">
          <source>The recommended way of sniffing for Gecko-based browsers (if you &lt;em&gt;have to&lt;/em&gt; sniff for the browser engine instead of using feature detection) is by the presence of the &quot;&lt;code&gt;Gecko&lt;/code&gt;&quot; and &quot;&lt;code&gt;rv:&lt;/code&gt;&quot; strings, since some other browsers include a &quot;&lt;code&gt;like Gecko&lt;/code&gt;&quot; token.</source>
          <target state="translated">(당신이 경우 Gecko 기반 브라우저 스니핑의 권장되는 방법 &lt;em&gt;으로이&lt;/em&gt; 대신 기능 탐지를 사용하는 브라우저 엔진 냄새)는 &quot;의 존재입니다 &lt;code&gt;Gecko&lt;/code&gt; &quot;와 &quot; &lt;code&gt;rv:&lt;/code&gt; 다른 브라우저가&quot;를 포함하기 때문에, 문자열 &quot; &lt;code&gt;like Gecko&lt;/code&gt; &quot;토큰.</target>
        </trans-unit>
        <trans-unit id="835a33da74dbfed0d3a5afc284d8d5f7eeac4750" translate="yes" xml:space="preserve">
          <source>The referrer of the document in which the violation occurred.</source>
          <target state="translated">위반이 발생한 문서의 리퍼러</target>
        </trans-unit>
        <trans-unit id="457d2e04c3cca60af5bcc1e43cb940e66612e208" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +-----------+----------------------------------+---------------+
   | Warn Code | Short Description                | Reference     |
   +-----------+----------------------------------+---------------+
   | 110       | Response is Stale                | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt; |
   | 111       | Revalidation Failed              | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; |
   | 112       | Disconnected Operation           | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt; |
   | 113       | Heuristic Expiration             | &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt; |
   | 199       | Miscellaneous Warning            | &lt;a href=&quot;#section-5.5.5&quot;&gt;Section 5.5.5&lt;/a&gt; |
   | 214       | Transformation Applied           | &lt;a href=&quot;#section-5.5.6&quot;&gt;Section 5.5.6&lt;/a&gt; |
   | 299       | Miscellaneous Persistent Warning | &lt;a href=&quot;#section-5.5.7&quot;&gt;Section 5.5.7&lt;/a&gt; |
   +-----------+----------------------------------+---------------+</source>
          <target state="translated">레지스트리는 아래 등록으로 채워져 있습니다. + ----------- + ----------------------------- ------- + --------------- + | 경고 코드 | 간단한 설명 | 참조 | + ----------- + ---------------------------------- +- ------------- + | 110 | 응답이 오래되었습니다 | &lt;a href=&quot;#section-5.5.1&quot;&gt;섹션 5.5.1&lt;/a&gt; | | 111 | 재확인 실패 | &lt;a href=&quot;#section-5.5.2&quot;&gt;섹션 5.5.2&lt;/a&gt; | | 112 | 연결이 끊긴 작업 | &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; | | 113 | 휴리스틱 만료 | &lt;a href=&quot;#section-5.5.4&quot;&gt;섹션 5.5.4&lt;/a&gt; | | 199 | 기타 경고 | &lt;a href=&quot;#section-5.5.5&quot;&gt;섹션 5.5.5&lt;/a&gt; | | 214 | 변환 적용 | &lt;a href=&quot;#section-5.5.6&quot;&gt;섹션 5.5.6&lt;/a&gt;| | 299 | 기타 지속적 경고 | &lt;a href=&quot;#section-5.5.7&quot;&gt;섹션 5.5.7&lt;/a&gt; | + ----------- + ---------------------------------- +- ------------- +</target>
        </trans-unit>
        <trans-unit id="6bfb04acf1092d994bf84da7df6bb36e8f3a785e" translate="yes" xml:space="preserve">
          <source>The registry has been populated with the registrations below:

   +------------------------+----------------------------------+
   | Cache Directive        | Reference                        |
   +------------------------+----------------------------------+
   | max-age                | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;Section 5.2.1.1&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt; |
   | max-stale              | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;Section 5.2.1.2&lt;/a&gt;                  |
   | min-fresh              | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;Section 5.2.1.3&lt;/a&gt;                  |
   | must-revalidate        | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;Section 5.2.2.1&lt;/a&gt;                  |
   | no-cache               | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;Section 5.2.1.4&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt; |
   | no-store               | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.3&quot;&gt;Section 5.2.2.3&lt;/a&gt; |
   | no-transform           | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;Section 5.2.1.6&lt;/a&gt;, &lt;a href=&quot;#section-5.2.2.4&quot;&gt;Section 5.2.2.4&lt;/a&gt; |
   | only-if-cached         | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;Section 5.2.1.7&lt;/a&gt;                  |
   | private                | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;                  |
   | proxy-revalidate       | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;Section 5.2.2.7&lt;/a&gt;                  |
   | public                 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;                  |
   | s-maxage               | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;                  |
   | stale-if-error         | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], Section&amp;nbsp;4&lt;/a&gt;             |
   | stale-while-revalidate | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], Section&amp;nbsp;3&lt;/a&gt;             |
   +------------------------+----------------------------------+</source>
          <target state="translated">레지스트리는 아래 등록으로 채워져 있습니다. + ------------------------ + -------------- -------------------- + | 캐시 지시문 | 참조 | + ------------------------ + ------------------------ ---------- + | 최대 연령 | &lt;a href=&quot;#section-5.2.1.1&quot;&gt;5.2.1.1 절&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.8&quot;&gt;5.2.2.8 절&lt;/a&gt; | | 최대 이야기 | &lt;a href=&quot;#section-5.2.1.2&quot;&gt;섹션 5.2.1.2&lt;/a&gt; | | 분 신선한 | &lt;a href=&quot;#section-5.2.1.3&quot;&gt;섹션 5.2.1.3&lt;/a&gt; | | 필수 재확인 | &lt;a href=&quot;#section-5.2.2.1&quot;&gt;5.2.2.1 절&lt;/a&gt; | | 캐시 없음 | &lt;a href=&quot;#section-5.2.1.4&quot;&gt;5.2.1.4 절&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.2&quot;&gt;5.2.2.2 절&lt;/a&gt; | | 가게 없음 | &lt;a href=&quot;#section-5.2.1.5&quot;&gt;섹션 5.2.1.5&lt;/a&gt; ,&lt;a href=&quot;#section-5.2.2.3&quot;&gt;섹션 5.2.2.3&lt;/a&gt; | | 변형 금지 | &lt;a href=&quot;#section-5.2.1.6&quot;&gt;섹션 5.2.1.6&lt;/a&gt; , &lt;a href=&quot;#section-5.2.2.4&quot;&gt;섹션 5.2.2.4&lt;/a&gt; | | 캐시 된 경우에만 | &lt;a href=&quot;#section-5.2.1.7&quot;&gt;섹션 5.2.1.7&lt;/a&gt; | | 개인 | &lt;a href=&quot;#section-5.2.2.6&quot;&gt;섹션 5.2.2.6&lt;/a&gt; | | 프록시 재확인 | &lt;a href=&quot;#section-5.2.2.7&quot;&gt;섹션 5.2.2.7&lt;/a&gt; | | 공개 | &lt;a href=&quot;#section-5.2.2.5&quot;&gt;섹션 5.2.2.5&lt;/a&gt; | | s-maxage | &lt;a href=&quot;#section-5.2.2.9&quot;&gt;섹션 5.2.2.9&lt;/a&gt; | | 오래된 오류 | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-4&quot;&gt;[RFC5861], 섹션 4&lt;/a&gt; | | 오래된 재검토 | &lt;a href=&quot;https://tools.ietf.org/html/rfc5861#section-3&quot;&gt;[RFC5861], 섹션 3&lt;/a&gt; | + ------------------------ + ------------------------ ---------- +</target>
        </trans-unit>
        <trans-unit id="6c3e9e6ad9f0e3368fa4d44e9aa2e2c33c90d7a5" translate="yes" xml:space="preserve">
          <source>The relevant RFC document for the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Upgrade header field is RFC 7230, section 6.7&lt;/a&gt;. The standard establishes rules for upgrading or changing to a different protocol on the current client, server, transport protocol connection. For example, this header standard allows a client to change from HTTP 1.1 to HTTP 2.0, assuming the server decides to acknowledge and implement the Upgrade header field. Neither party is required to accept the terms specified in the Upgrade header field. It can be used in both client and server headers. If the Upgrade header field is specified, then the sender MUST also send the Connection header field with the upgrade option specified. For details on the Connection header field &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;please see section 6.1 of the aforementioned RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;업그레이드 헤더 필드에&lt;/a&gt; 대한 관련 RFC 문서 는 RFC 7230, 섹션 6.7 입니다. 표준은 현재 클라이언트, 서버, 전송 프로토콜 연결에서 다른 프로토콜로 업그레이드하거나 변경하기위한 규칙을 설정합니다. 예를 들어, 서버가 업그레이드 헤더 필드를 확인하고 구현하기로 결정한 경우이 헤더 표준을 사용하면 클라이언트가 HTTP 1.1에서 HTTP 2.0으로 변경할 수 있습니다. 어느 쪽도 업그레이드 헤더 필드에 지정된 조건에 동의하지 않아도됩니다. 클라이언트 및 서버 헤더 모두에서 사용할 수 있습니다. 업그레이드 헤더 필드가 지정되면 발신자는 업그레이드 옵션이 지정된 연결 헤더 필드도 보내야합니다. 연결 헤더 필드에 대한 자세한 내용 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;은 앞에서 언급 한 RFC의 섹션 6.1을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9681bfccce6746b808712df87789877aff1a0a08" translate="yes" xml:space="preserve">
          <source>The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7233]&lt;/a&gt; |
   | Allow             | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;            |
   | Server            | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;            |
   +-------------------+--------------------------+</source>
          <target state="translated">나머지 응답 헤더 필드는 이후 요청에서 잠재적으로 사용할 수 있도록 대상 자원에 대한 자세한 정보를 제공합니다. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | 수락 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-2.3&quot;&gt;[RFC7233] 2.3 절&lt;/a&gt; | | 허용 | &lt;a href=&quot;#section-7.4.1&quot;&gt;섹션 7.4.1&lt;/a&gt; | | 서버 | &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2 절&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="4af6457a5675ed1ed5b26a3a3626f6948e42d207" translate="yes" xml:space="preserve">
          <source>The report JSON object contains the following data:</source>
          <target state="translated">보고서 JSON 개체에는 다음 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5baf54425251a0af52438742ec528ea5d7cad288" translate="yes" xml:space="preserve">
          <source>The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )</source>
          <target state="translated">HTTP 메시지와 연관된 표현 데이터는 메시지의 페이로드 본문으로 제공되거나 메시지 시맨틱 및 유효 요청 URI에 의해 참조됩니다. 표현 데이터는 표현 메타 데이터 헤더 필드에 의해 정의 된 포맷 및 인코딩이다. 표현 데이터의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이들은 2 계층 순서의 인코딩 모델을 정의합니다 : representation-data : = Content-Encoding (Content-Type (bits))</target>
        </trans-unit>
        <trans-unit id="57fb990a7173c920416af3c97b46113340011437" translate="yes" xml:space="preserve">
          <source>The request could not be completed due to a conflict with the current
   state of the resource. This code is only allowed in situations where
   it is expected that the user might be able to resolve the conflict
   and resubmit the request. The response body SHOULD include enough 

   information for the user to recognize the source of the conflict.
   Ideally, the response entity would include enough information for the
   user or user agent to fix the problem; however, that might not be
   possible and is not required.

   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the entity being PUT
   included changes to a resource which conflict with those made by an
   earlier (third-party) request, the server might use the 409 response
   to indicate that it can't complete the request. In this case, the
   response entity would likely contain a list of the differences
   between the two versions in a format defined by the response
   Content-Type.</source>
          <target state="translated">자원의 현재 상태와 충돌하여 요청을 완료 할 수 없습니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수있는 상황에서만 허용됩니다. 응답 본문에는 사용자가 충돌의 원인을 인식 할 수있는 충분한 정보가 포함되어야합니다. 이상적으로, 응답 엔티티는 사용자 또는 사용자 에이전트가 문제를 해결하기에 충분한 정보를 포함 할 것이다. 그러나 불가능할 수도 있고 필요하지 않을 수도 있습니다. PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 높습니다. 예를 들어, 버전 관리를 사용 중이고 PUT중인 엔티티에 이전 (타사) 요청으로 작성된 자원과 충돌하는 자원에 대한 변경 사항이 포함 된 경우 서버는 409 응답을 사용하여요청을 완료하지 마십시오. 이 경우 응답 엔티티는 응답 Content-Type에 의해 정의 된 형식으로 두 버전 간의 차이점 목록을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62943efc1c331624006dfa87f2880914c04923b3" translate="yes" xml:space="preserve">
          <source>The request could not be understood by the server due to malformed
   syntax. The client SHOULD NOT repeat the request without
   modifications.</source>
          <target state="translated">잘못된 구문으로 인해 서버에서 요청을 이해할 수 없습니다. 클라이언트는 수정없이 요청을 반복해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f388607fcf883d14ee29792afda2dc8c83b32d" translate="yes" xml:space="preserve">
          <source>The request failed due to failure of a previous request.</source>
          <target state="translated">이전 요청이 실패하여 요청이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="80b2b18dab161f54208331e259eefdc84181c453" translate="yes" xml:space="preserve">
          <source>The request has been accepted for processing, but the processing has
   not been completed.  The request might or might not eventually be
   acted upon, as it might be disallowed when processing actually takes
   place. There is no facility for re-sending a status code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The entity returned with this
   response SHOULD include an indication of the request's current status
   and either a pointer to a status monitor or some estimate of when the
   user can expect the request to be fulfilled.</source>
          <target state="translated">처리 요청이 승인되었지만 처리가 완료되지 않았습니다. 처리가 실제로 수행 될 때 허용되지 않을 수 있기 때문에 요청이 결국 수행 될 수도 있고 수행되지 않을 수도 있습니다. 이와 같은 비동기 작업에서 상태 코드를 다시 보내는 기능은 없습니다. 202 응답은 의도적으로 비 커밋입니다. 이 프로세스의 목적은 프로세스가 완료 될 때까지 서버에 대한 사용자 에이전트 연결이 유지되도록 요구하지 않고 서버가 다른 프로세스 (아마도 하루에 한 번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락하도록하는 것입니다. 이 응답과 함께 반환 된 엔터티에는 요청의 현재 상태 표시와 상태 모니터에 대한 포인터 또는 사용자가 요청이 이행 될 것으로 예상 할 수있는시기에 대한 추정값이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3496a6a34429a71d096b5d661e42c1a9bb755e60" translate="yes" xml:space="preserve">
          <source>The request has been fulfilled and resulted in a new resource being
   created. The newly created resource can be referenced by the URI(s)
   returned in the entity of the response, with the most specific URI
   for the resource given by a Location header field. The response
   SHOULD include an entity containing a list of resource
   characteristics and location(s) from which the user or user agent can
   choose the one most appropriate. The entity format is specified by
   the media type given in the Content-Type header field. The origin
   server MUST create the resource before returning the 201 status code.
   If the action cannot be carried out immediately, the server SHOULD
   respond with 202 (Accepted) response instead.

   A 201 response MAY contain an ETag response header field indicating
   the current value of the entity tag for the requested variant just
   created, see &lt;a href=&quot;#section-14.19&quot;&gt;section 14.19&lt;/a&gt;.</source>
          <target state="translated">요청이 이행되어 새 자원이 작성되었습니다. 새로 작성된 자원은 응답의 엔티티에 리턴 된 URI에 의해 참조 될 수 있으며 Location 헤더 필드에 의해 제공된 자원에 대한 가장 구체적인 URI가 있습니다. 응답은 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수있는 자원 특성 및 위치 목록을 포함하는 개체를 포함해야한다 (SHOULD). 엔티티 형식은 컨텐츠 유형 헤더 필드에 제공된 매체 유형으로 지정됩니다. 오리진 서버는 201 상태 코드를 반환하기 전에 반드시 리소스를 생성해야합니다. 조치를 즉시 수행 할 수없는 경우 서버는 대신 202 (Accepted) 응답으로 응답해야합니다.201 응답은 방금 생성 된 요청 된 변형에 대한 엔티티 태그의 현재 값을 나타내는 ETag 응답 헤더 필드를 포함 할 수 있습니다.&lt;a href=&quot;#section-14.19&quot;&gt;섹션 14.19&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d84e18807de0c6356f2f62e25c75fb03b74e11" translate="yes" xml:space="preserve">
          <source>The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">요청이 접수되었지만 아직 처리되지 않았습니다. 커밋되지 않은 것은 HTTP에서 나중에 요청 처리 결과를 나타내는 비동기 응답을 보낼 수있는 방법이 없음을 의미합니다. 다른 프로세스 나 서버가 요청을 처리하는 경우 또는 일괄 처리를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="563c97ec35447bf615f29b9828050c09a712103e" translate="yes" xml:space="preserve">
          <source>The request has more than one possible response. The user-agent or user should choose one of them. There is no standardized way of choosing one of the responses.</source>
          <target state="translated">요청에 둘 이상의 가능한 응답이 있습니다. 사용자 에이전트 또는 사용자 중 하나를 선택해야합니다. 응답 중 하나를 선택하는 표준화 된 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5487d137616e521aa017175b35b13aa2e3f74d3d" translate="yes" xml:space="preserve">
          <source>The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a POST request, or after some PUT requests.</source>
          <target state="translated">요청이 성공했으며 그 결과 새로운 자원이 작성되었습니다. 이것은 일반적으로 POST 요청 후 또는 일부 PUT 요청 후 전송되는 응답입니다.</target>
        </trans-unit>
        <trans-unit id="d8ecc9cc6596038de67ec68a577d983da6a673ef" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The information returned with the response
   is dependent on the method used in the request, for example:

   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action; 

   TRACE  an entity containing the request message as received by the
          end server.</source>
          <target state="translated">요청이 성공했습니다. 응답과 함께 리턴 된 정보는 요청에 사용 된 방법에 따라 다릅니다. 예를 들면 다음과 같습니다. 요청 된 자원에 해당하는 엔티티가 응답으로 전송됩니다. HEAD 요청 된 자원에 해당하는 엔티티 헤더 필드는 메시지 본문없이 응답으로 전송됩니다. 조치 결과를 설명하거나 포함하는 엔티티를 POST합니다. 최종 서버가 수신 한 요청 메시지를 포함하는 엔티티를 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="f565b6003126123248442292df2bf9baaa5e391b" translate="yes" xml:space="preserve">
          <source>The request has succeeded. The meaning of a success varies depending on the HTTP method:</source>
          <target state="translated">요청이 성공했습니다. 성공의 의미는 HTTP 메소드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d11383f57aada516934509a2d3957090ac4763bc" translate="yes" xml:space="preserve">
          <source>The request looks something like this (less interesting headers are omitted here):</source>
          <target state="translated">요청은 다음과 같습니다 (여기서 흥미로운 헤더는 생략되지 않음).</target>
        </trans-unit>
        <trans-unit id="0c671ed51daf22d159e04d7c4fd432023c8f3806" translate="yes" xml:space="preserve">
          <source>The request method and the body will not be altered, whereas &lt;a href=&quot;301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; may incorrectly sometimes be changed to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">요청 방법과 본문은 변경되지 않지만 &lt;a href=&quot;301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; 은 때때로 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 방법으로 잘못 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e391f1f093da1eaf3c8079eb9f1cb969d2137823" translate="yes" xml:space="preserve">
          <source>The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, must never be disabled and should not return this error code.</source>
          <target state="translated">요청 방법이 서버에 알려져 있지만 비활성화되어 사용할 수 없습니다. 예를 들어, API는 리소스 삭제를 금지 할 수 있습니다. 두 가지 필수 메소드 인 &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;HEAD&lt;/code&gt; 는 사용하지 않아야하며이 오류 코드를 리턴하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3868804eb59e6799895608f9d8fc1f4241a46d74" translate="yes" xml:space="preserve">
          <source>The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">서버에서 요청 방법을 지원하지 않으므로 처리 할 수 ​​없습니다. 서버가 지원해야하는 유일한 메소드 (따라서이 코드를 리턴하지 않아야 함)는 &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cacbb0963918be12f6522f203c0731acc095523b" translate="yes" xml:space="preserve">
          <source>The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;)
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) to make the requested action conditional on the current
   state of the target resource ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [&lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters. 

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the &quot;Hypertext Transfer Protocol (HTTP) Method
   Registry&quot; maintained by IANA, as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   The set of methods allowed by a target resource can be listed in an
   Allow header field (&lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.</source>
          <target state="translated">요청 메소드 토큰은 요청 시맨틱의 주요 소스입니다. 클라이언트가이 요청을 한 목적과 클라이언트가 성공적인 결과로 기대하는 것을 나타냅니다. 추가 시맨틱이 메소드와 충돌하지 않는 경우 요청에 존재하는 경우 ( &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; ) 헤더 필드의 시맨틱에 의해 요청 메소드 시맨틱이 더욱 전문화 될 수 있습니다 . 예를 들어, 클라이언트는 요청 된 조치를 대상 자원의 현재 상태에 대해 조건부로 만들기 위해 조건부 요청 헤더 필드 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; )를 보낼 수 있습니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]). method = token HTTP는 원래 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계되었습니다. 요청 메소드는 식별 된 오브젝트에서 정의 된 메소드를 호출하는 것이 시맨틱을 적용하는 것과 거의 같은 방식으로 대상 자원에 시맨틱을 적용하는 것으로 구상되었습니다. 메소드 토큰은 대소 문자를 구분하는 메소드 이름을 가진 오브젝트 기반 시스템의 게이트웨이로 사용될 수 있으므로 대소 문자를 구분합니다. 분산 된 객체와 달리 HTTP의 표준화 된 요청 방법은 리소스별로 다릅니다. 균일 한 인터페이스는 네트워크 기반 시스템에서 더 나은 가시성과 재사용을 제공하기 때문에 [ &lt;a href=&quot;#ref-REST&quot;&gt;REST&lt;/a&gt;]. 일단 정의되면, 표준화 된 방법은 모든 자원에 적용될 때 동일한 의미론을 가져야하지만, 각각의 자원은 그 의미론의 구현 또는 허용 여부를 스스로 결정합니다. 이 사양은 다음 표에 요약 된 것처럼 HTTP에서 일반적으로 사용되는 여러 가지 표준화 된 방법을 정의합니다. 관례에 따라 표준화 된 방법은 모두 대문자 US-ASCII 문자로 정의됩니다. + --------- + --------------------------------------- ---------- + ------- + | 방법 | 설명 | 비서. | + --------- + --------------------------------------- ---------- + ------- + | GET | 대상의 현재 표현을 전송 | 4.3.1 | | | 자원. | | | 헤드 | GET과 동일상태 표시 줄 만 전송 | 4.3.2 | | | 헤더 섹션. | | | POST | 자원 별 처리를 | 4.3.3 | | | 페이로드를 요청하십시오. | | | 퍼팅 | 현재의 모든 표현을 바꾸십시오 | 4.3.4 | | | 요청 페이로드가있는 대상 자원. | | | 삭제 | 현재의 모든 표현을 제거하십시오 | 4.3.5 | | | 대상 자원. | | | 연결 | 서버로 터널을 설정하십시오. | 4.3.6 | | | 대상 자원 | | | 옵션 | 통신 옵션 설명 | 4.3.7 | | | 대상 자원.| | | 트랙 | 경로를 따라 메시지 루프백 테스트 수행 | 4.3.8 | | | 대상 리소스에. | | + --------- + --------------------------------------- ---------- + ------- + 모든 범용 서버는 GET 및 HEAD 방법을 지원해야합니다. 다른 모든 방법은 선택 사항입니다. 이 사양의 범위를 벗어난 추가 방법은 HTTP에서 사용하도록 표준화되었습니다. 이러한 모든 방법은 IANA가 관리하는 &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot;에 등록해야합니다.| | + --------- + --------------------------------------- ---------- + ------- + 모든 범용 서버는 GET 및 HEAD 방법을 지원해야합니다. 다른 모든 방법은 선택 사항입니다. 이 사양의 범위를 벗어난 추가 방법은 HTTP에서 사용하도록 표준화되었습니다. 이러한 모든 방법은 IANA가 관리하는 &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot;에 등록되어 있어야합니다.| | + --------- + --------------------------------------- ---------- + ------- + 모든 범용 서버는 GET 및 HEAD 방법을 지원해야합니다. 다른 모든 방법은 선택 사항입니다. 이 사양의 범위를 벗어난 추가 방법은 HTTP에서 사용하도록 표준화되었습니다. 이러한 모든 방법은 IANA가 관리하는 &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot;에 등록되어 있어야합니다.&lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; . 대상 자원이 허용하는 메소드 세트는 허용 헤더 필드에 나열 될 수 있습니다 ( &lt;a href=&quot;#section-7.4.1&quot;&gt;섹션 7.4.1&lt;/a&gt; ). 그러나 허용되는 메소드 세트는 동적으로 변경 될 수 있습니다. 오리진 서버에 의해 인식되지 않거나 구현되지 않은 요청 방법이 수신되면, 오리진 서버는 501 (구현되지 않음) 상태 코드로 응답해야한다. 오리진 서버에 의해 알려져 있지만 목표 자원에 대해 허용되지 않은 요청 방법이 수신되면, 오리진 서버는 405 (Method Not Allowed) 상태 코드로 응답해야한다.</target>
        </trans-unit>
        <trans-unit id="ea4723439e12f3374a0c44c124fcfaaf67f0d247" translate="yes" xml:space="preserve">
          <source>The request requires user authentication. The response MUST include a
   WWW-Authenticate header field (&lt;a href=&quot;#section-14.47&quot;&gt;section 14.47&lt;/a&gt;) containing a challenge
   applicable to the requested resource. The client MAY repeat the
   request with a suitable Authorization header field (&lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;). If
   the request already included Authorization credentials, then the 401
   response indicates that authorization has been refused for those
   credentials. If the 401 response contains the same challenge as the
   prior response, and the user agent has already attempted
   authentication at least once, then the user SHOULD be presented the
   entity that was given in the response, since that entity might
   include relevant diagnostic information. HTTP access authentication
   is explained in &quot;HTTP Authentication: Basic and Digest Access
   Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">요청에는 사용자 인증이 필요합니다. 응답에는 요청 된 자원에 해당하는 챌린지를 포함하는 WWW-Authenticate 헤더 필드 ( &lt;a href=&quot;#section-14.47&quot;&gt;14.47 절&lt;/a&gt; )가 포함되어야합니다. 클라이언트는 적절한 Authorization 헤더 필드 ( &lt;a href=&quot;#section-14.8&quot;&gt;14.8 절)로&lt;/a&gt; 요청을 반복 할 수있다). 요청에 이미 인증 자격 증명이 포함 된 경우 401 응답은 해당 자격 증명에 대한 인증이 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 시도가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 응답에 제공된 엔티티가 사용자에게 표시되어야합니다. 해당 엔티티는 관련 진단 정보를 포함 할 수 있기 때문입니다. HTTP 액세스 인증은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="536c30469835dbdbadd49c3051aea9ea66357e5b" translate="yes" xml:space="preserve">
          <source>The request to TLS can be made either optionally or mandatorily.</source>
          <target state="translated">TLS에 대한 요청은 선택적으로 또는 필수적으로 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab19f93fa18ca65854665f21139e776133cce6e1" translate="yes" xml:space="preserve">
          <source>The request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.</source>
          <target state="translated">요청이 응답을 생성 할 수없는 서버로 보내졌습니다. 요청 URI에 포함 된 체계 및 권한 조합에 대한 응답을 생성하도록 구성되지 않은 서버에서이를 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e88680dcf3022af1b9dae0ac257cac1136f1dced" translate="yes" xml:space="preserve">
          <source>The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight</source>
          <target state="translated">요청이 'https://example.com/foo'로 리디렉션되었으며 프리 플라이트가 필요한 교차 출처 요청은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7233ccb2f021155bf357e2393734dc2cb1fd475" translate="yes" xml:space="preserve">
          <source>The request was well-formed but was unable to be followed due to semantic errors.</source>
          <target state="translated">요청이 제대로 구성되었지만 의미 오류로 인해 추적 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c92c57474b6ca0ed55b1d1a0fed53a9265911a89" translate="yes" xml:space="preserve">
          <source>The request-header fields allow the client to pass additional
   information about the request, and about the client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parameters on a programming language method
   invocation.

       request-header = Accept                   ; &lt;a href=&quot;#section-14.1&quot;&gt;Section 14.1&lt;/a&gt;
                      | Accept-Charset           ; &lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;
                      | Accept-Encoding          ; &lt;a href=&quot;#section-14.3&quot;&gt;Section 14.3&lt;/a&gt;
                      | Accept-Language          ; &lt;a href=&quot;#section-14.4&quot;&gt;Section 14.4&lt;/a&gt;
                      | Authorization            ; &lt;a href=&quot;#section-14.8&quot;&gt;Section 14.8&lt;/a&gt;
                      | Expect                   ; &lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;
                      | From                     ; &lt;a href=&quot;#section-14.22&quot;&gt;Section 14.22&lt;/a&gt;
                      | Host                     ; &lt;a href=&quot;#section-14.23&quot;&gt;Section 14.23&lt;/a&gt;
                      | If-Match                 ; &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt; 

                      | If-Modified-Since        ; &lt;a href=&quot;#section-14.25&quot;&gt;Section 14.25&lt;/a&gt;
                      | If-None-Match            ; &lt;a href=&quot;#section-14.26&quot;&gt;Section 14.26&lt;/a&gt;
                      | If-Range                 ; &lt;a href=&quot;#section-14.27&quot;&gt;Section 14.27&lt;/a&gt;
                      | If-Unmodified-Since      ; &lt;a href=&quot;#section-14.28&quot;&gt;Section 14.28&lt;/a&gt;
                      | Max-Forwards             ; &lt;a href=&quot;#section-14.31&quot;&gt;Section 14.31&lt;/a&gt;
                      | Proxy-Authorization      ; &lt;a href=&quot;#section-14.34&quot;&gt;Section 14.34&lt;/a&gt;
                      | Range                    ; &lt;a href=&quot;#section-14.35&quot;&gt;Section 14.35&lt;/a&gt;
                      | Referer                  ; &lt;a href=&quot;#section-14.36&quot;&gt;Section 14.36&lt;/a&gt;
                      | TE                       ; &lt;a href=&quot;#section-14.39&quot;&gt;Section 14.39&lt;/a&gt;
                      | User-Agent               ; &lt;a href=&quot;#section-14.43&quot;&gt;Section 14.43&lt;/a&gt;

   Request-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of request-
   header fields if all parties in the communication recognize them to
   be request-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">요청 헤더 필드를 사용하면 클라이언트는 요청 및 클라이언트 자체에 대한 추가 정보를 서버에 전달할 수 있습니다. 이 필드는 프로그래밍 언어 메소드 호출의 매개 변수와 동일한 의미로 요청 수정 자 역할을합니다. 요청 헤더 = 수락; &lt;a href=&quot;#section-14.1&quot;&gt;섹션 14.1&lt;/a&gt; | 수락 문자; &lt;a href=&quot;#section-14.2&quot;&gt;섹션 14.2&lt;/a&gt; | 수락 인코딩; &lt;a href=&quot;#section-14.3&quot;&gt;섹션 14.3&lt;/a&gt; | 수락 언어; &lt;a href=&quot;#section-14.4&quot;&gt;섹션 14.4&lt;/a&gt; | 승인; &lt;a href=&quot;#section-14.8&quot;&gt;섹션 14.8&lt;/a&gt; | 기대; &lt;a href=&quot;#section-14.20&quot;&gt;섹션 14.20&lt;/a&gt; | 부터; &lt;a href=&quot;#section-14.22&quot;&gt;섹션 14.22&lt;/a&gt; | 주최자 ; &lt;a href=&quot;#section-14.23&quot;&gt;섹션 14.23&lt;/a&gt; | 일치하는 경우; &lt;a href=&quot;#section-14.24&quot;&gt;섹션 14.24&lt;/a&gt; | If-Modified-Since; &lt;a href=&quot;#section-14.25&quot;&gt;섹션 14.25&lt;/a&gt; | 일치하지 않는 경우; &lt;a href=&quot;#section-14.26&quot;&gt;섹션 14.26&lt;/a&gt; | If-Range; &lt;a href=&quot;#section-14.27&quot;&gt;섹션 14.27&lt;/a&gt; | 수정되지 않은 경우; &lt;a href=&quot;#section-14.28&quot;&gt;섹션 14.28&lt;/a&gt; | 최대 앞으로; &lt;a href=&quot;#section-14.31&quot;&gt;섹션 14.31&lt;/a&gt; | 프록시 인증; &lt;a href=&quot;#section-14.34&quot;&gt;섹션 14.34&lt;/a&gt; | 범위; &lt;a href=&quot;#section-14.35&quot;&gt;섹션 14.35&lt;/a&gt; | 레퍼러; &lt;a href=&quot;#section-14.36&quot;&gt;섹션 14.36&lt;/a&gt; | TE; &lt;a href=&quot;#section-14.39&quot;&gt;섹션 14.39&lt;/a&gt; | 사용자 에이전트 ; &lt;a href=&quot;#section-14.43&quot;&gt;섹션 14.43&lt;/a&gt; 요청 헤더 필드 이름은 프로토콜 버전의 변경과 결합해서 만 확실하게 확장 될 수 있습니다. 그러나, 통신의 모든 당사자가 요청 헤더 필드 인 것으로 인식하는 경우, 새로운 또는 실험 헤더 필드에 요청 헤더 필드의 의미가 부여 될 수있다 (MAY). 인식 할 수없는 헤더 필드는 엔티티 헤더 필드로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="00ee3240d5b62db652acaaec1c517dfc4187762e" translate="yes" xml:space="preserve">
          <source>The requested resource MUST be accessed through the proxy given by
   the Location field. The Location field gives the URI of the proxy.
   The recipient is expected to repeat this single request via the
   proxy. 305 responses MUST only be generated by origin servers.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; was not clear that 305 was intended to redirect a
      single request, and to be generated by origin servers only.  Not
      observing these limitations has significant security consequences.</source>
          <target state="translated">요청 된 리소스는 Location 필드에서 제공 한 프록시를 통해 액세스해야합니다. 위치 필드는 프록시의 URI를 제공합니다. 수신자는 프록시를 통해이 단일 요청을 반복해야합니다. 305 응답은 오리진 서버에서만 생성해야합니다. 참고 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 은 305가 단일 요청을 리디렉션하고 오리진 서버에서만 생성되도록 의도 된 것은 아닙니다. 이러한 제한 사항을 준수하지 않으면 보안에 심각한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="d984d2d7ff09514806eb927c4043ee9bc91f6a1d" translate="yes" xml:space="preserve">
          <source>The requested resource corresponds to any one of a set of
   representations, each with its own specific location, and agent-
   driven negotiation information (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) is being provided so that
   the user (or user agent) can select a preferred representation and
   redirect its request to that location.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of resource characteristics and location(s) from
   which the user or user agent can choose the one most appropriate. The
   entity format is specified by the media type given in the Content-
   Type header field. Depending upon the format and the capabilities of 

   the user agent, selection of the most appropriate choice MAY be
   performed automatically. However, this specification does not define
   any standard for such automatic selection.

   If the server has a preferred choice of representation, it SHOULD
   include the specific URI for that representation in the Location
   field; user agents MAY use the Location field value for automatic
   redirection. This response is cacheable unless indicated otherwise.</source>
          <target state="translated">요청 된 자원은 각각 고유 한 위치 및 상담원 주도 협상 정보를 가진 일련의 표현 중 하나에 해당합니다 ( &lt;a href=&quot;#section-12&quot;&gt;섹션 12).&lt;/a&gt;)이 제공되어 사용자 (또는 사용자 에이전트)가 선호하는 표현을 선택하고 해당 요청을 해당 위치로 리디렉션 할 수 있습니다. HEAD 요청이 아닌 한, 응답은 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수있는 자원 특성 및 위치 목록을 포함하는 엔티티를 포함해야한다. 엔터티 형식은 내용 형식 헤더 필드에 지정된 미디어 유형으로 지정됩니다. 사용자 에이전트의 형식 및 기능에 따라 가장 적합한 선택이 자동으로 수행 될 수 있습니다. 그러나이 사양에서는 이러한 자동 선택에 대한 표준을 정의하지 않습니다. 서버가 선호하는 표현 방식을 선택한다면, 해당 표현에 대한 특정 URI를 Location 필드에 포함시켜야합니다.사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 달리 명시하지 않는 한이 응답은 캐시 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e7c77b9895c801f0e66c9d13d10555d8495d972e" translate="yes" xml:space="preserve">
          <source>The requested resource has been assigned a new permanent URI and any
   future references to this resource SHOULD use one of the returned
   URIs.  Clients with link editing capabilities ought to automatically
   re-link references to the Request-URI to one or more of the new
   references returned by the server, where possible. This response is
   cacheable unless indicated otherwise.

   The new permanent URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

   If the 301 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: When automatically redirecting a POST request after
      receiving a 301 status code, some existing HTTP/1.0 user agents
      will erroneously change it into a GET request.</source>
          <target state="translated">요청 된 리소스에 새로운 영구 URI가 할당되었으며이 리소스에 대한 이후의 참조는 반환 된 URI 중 하나를 사용해야합니다. 링크 편집 기능이있는 클라이언트는 가능하면 요청 URI에 대한 참조를 서버가 리턴 한 하나 이상의 새 참조에 자동으로 다시 링크해야합니다. 달리 명시하지 않는 한이 응답은 캐시 가능합니다. 새로운 영구 URI는 응답의 Location 필드에서 제공해야합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔티티는 새로운 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야한다. GET 또는 HEAD 이외의 요청에 대한 응답으로 301 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수없는 경우가 아니라면 자동으로 요청을 리디렉션해서는 안됩니다.요청이 발행 된 조건이 변경 될 수 있기 때문입니다. 참고 : 301 상태 코드를 수신 한 후 POST 요청을 자동으로 리디렉션하면 일부 기존 HTTP / 1.0 사용자 에이전트가 해당 요청을 GET 요청으로 잘못 변경합니다.</target>
        </trans-unit>
        <trans-unit id="84c9980aa16b04f88efc81ddd498027c5e617c08" translate="yes" xml:space="preserve">
          <source>The requested resource is no longer available at the server and no
   forwarding address is known. This condition is expected to be
   considered permanent. Clients with link editing capabilities SHOULD
   delete references to the Request-URI after user approval. If the
   server does not know, or has no facility to determine, whether or not
   the condition is permanent, the status code 404 (Not Found) SHOULD be
   used instead. This response is cacheable unless indicated otherwise.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer working at the server's site. It is not
   necessary to mark all permanently unavailable resources as &quot;gone&quot; or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.</source>
          <target state="translated">요청한 리소스를 더 이상 서버에서 사용할 수 없으며 전달 주소를 알 수 없습니다. 이 상태는 영구적 인 것으로 간주됩니다. 링크 편집 기능이있는 클라이언트는 사용자 승인 후 Request-URI에 대한 참조를 삭제해야합니다. 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 기능이없는 경우 상태 코드 404 (찾을 수 없음)를 대신 사용해야합니다. 달리 명시하지 않는 한이 응답은 캐시 가능합니다. 410 응답은 기본적으로 수신자에게 자원을 의도적으로 사용할 수 없으며 서버 소유자가 해당 자원에 대한 원격 링크를 제거하기를 원한다는 것을 통지하여 웹 유지 보수 작업을 지원하기위한 것입니다. 이러한 이벤트는 제한된 시간 동안 일반적입니다.판촉 서비스 및 더 이상 서버 사이트에서 일하지 않는 개인 소유의 리소스 영구적으로 사용할 수없는 모든 리소스를 &quot;사라진&quot;것으로 표시하거나 서버 소유자의 재량에 따라 오랫동안 마크를 유지할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a016e600e3bce12c26484b50fa5be354243d903" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection MAY be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s) , since many pre-HTTP/1.1 user agents do not
   understand the 307 status. Therefore, the note SHOULD contain the
   information necessary for a user to repeat the original request on
   the new URI.

   If the 307 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.</source>
          <target state="translated">요청 된 리소스가 일시적으로 다른 URI에 있습니다. 경우에 따라 리디렉션이 변경 될 수 있으므로 클라이언트는 향후 요청에 계속 Request-URI를 사용해야합니다. 이 응답은 Cache-Control 또는 Expires 헤더 필드로 표시된 경우에만 캐시 가능합니다. 임시 URI는 응답의 Location 필드에서 제공해야합니다. 요청 방법이 HEAD가 아닌 한, 응답의 엔티티는 많은 HTTP / 1.1 사용자 에이전트가 307 상태를 이해하지 못하기 때문에 새로운 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야한다 (SHOULD). 그러므로, 노트는 사용자가 새로운 URI에 대한 원래 요청을 반복하는데 필요한 정보를 포함해야한다. GET 또는 HEAD 이외의 요청에 대한 응답으로 307 상태 코드가 수신되면,사용자 에이전트는 사용자가 요청을 확인할 수없는 한 요청을 자동으로 리디렉션해서는 안됩니다. 요청이 발행 된 조건이 변경 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a9d909310ffffdfd39320376da2640abfbc56135" translate="yes" xml:space="preserve">
          <source>The requested resource resides temporarily under a different URI.
   Since the redirection might be altered on occasion, the client SHOULD
   continue to use the Request-URI for future requests.  This response
   is only cacheable if indicated by a Cache-Control or Expires header
   field.

   The temporary URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s). 

   If the 302 status code is received in response to a request other
   than GET or HEAD, the user agent MUST NOT automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions under which the request was issued.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; specify that the client is not allowed
      to change the method on the redirected request.  However, most
      existing user agent implementations treat 302 as if it were a 303
      response, performing a GET on the Location field-value regardless
      of the original request method. The status codes 303 and 307 have
      been added for servers that wish to make unambiguously clear which
      kind of reaction is expected of the client.</source>
          <target state="translated">요청 된 리소스가 일시적으로 다른 URI에 있습니다. 경우에 따라 리디렉션이 변경 될 수 있으므로 클라이언트는 향후 요청에 계속 Request-URI를 사용해야합니다. 이 응답은 Cache-Control 또는 Expires 헤더 필드로 표시된 경우에만 캐시 가능합니다. 임시 URI는 응답의 Location 필드에서 제공해야합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔티티는 새로운 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야한다. GET 또는 HEAD 이외의 요청에 대한 응답으로 302 상태 코드가 수신되면, 사용자 에이전트는 요청이 발행 된 조건을 변경할 수 있으므로 사용자가 확인할 수없는 경우 요청을 자동으로 리디렉션해서는 안됩니다. 참고 : &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; 및&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 은 클라이언트가 경로 재 지정된 요청에 대한 메소드를 변경할 수 없도록 지정합니다. 그러나 대부분의 기존 사용자 에이전트 구현은 원래 요청 방법에 관계없이 Location 필드 값에 대해 GET을 수행하여 302를 303 응답 인 것처럼 처리합니다. 클라이언트에 어떤 종류의 반응이 예상되는지 명확하게 나타내려는 서버에 대해 상태 코드 303 및 307이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="24d06f0884418e17262e5806d51e7313670997da" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host header
   field (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), report an error if it is missing from an
   HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) are among
   the most important changes defined by HTTP/1.1. 

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed.  The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional
   requirements were placed on all HTTP/1.1 requests in order to ensure
   complete adoption.  At the time of this writing, most HTTP-based
   services are dependent upon the Host header field for targeting
   requests.</source>
          <target state="translated">클라이언트와 서버가 호스트 헤더 필드 ( &lt;a href=&quot;#section-5.4&quot;&gt;5.4 절&lt;/a&gt; )를 지원하고 HTTP / 1.1 요청에서 누락 된 경우 오류를보고하며 절대 URI를 수락해야하는 요구 사항 ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3 절)&lt;/a&gt;)는 HTTP / 1.1에서 정의 된 가장 중요한 변경 중 하나입니다. 이전 HTTP / 1.0 클라이언트는 IP 주소와 서버의 일대일 관계를 가정했습니다. 요청의 의도 된 서버를 해당 요청이 지시 된 IP 주소보다 구별하기위한 다른 확립 된 메커니즘은 없었습니다. 호스트 헤더 필드는 HTTP / 1.1 개발 중에 도입되었으며 대부분의 HTTP / 1.0 브라우저에서 빠르게 구현되었지만 모든 채택을 보장하기 위해 모든 HTTP / 1.1 요청에 추가 요구 사항이 적용되었습니다. 이 문서를 작성할 당시 대부분의 HTTP 기반 서비스는 요청을 대상으로하는 호스트 헤더 필드에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="554d1e6bd5194783475ebafadd7bbf4b3ceb10ad" translate="yes" xml:space="preserve">
          <source>The requirements that clients and servers support the Host request-
   header, report an error if the Host request-header (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) is
   missing from an HTTP/1.1 request, and accept absolute URIs (&lt;a href=&quot;#section-5.1.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;) are among the most important changes defined by this
   specification.

   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The changes outlined above will
   allow the Internet, once older HTTP clients are no longer common, to
   support multiple Web sites from a single IP address, greatly
   simplifying large operational Web servers, where allocation of many
   IP addresses to a single host has created serious problems. The
   Internet will also be able to recover the IP addresses that have been
   allocated for the sole purpose of allowing special-purpose domain
   names to be used in root-level HTTP URLs. Given the rate of growth of
   the Web, and the number of servers already deployed, it is extremely 

   important that all implementations of HTTP (including updates to
   existing HTTP/1.0 applications) correctly implement these
   requirements:

      - Both clients and servers MUST support the Host request-header.

      - A client that sends an HTTP/1.1 request MUST send a Host header.

      - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1
        request does not include a Host request-header.

      - Servers MUST accept absolute URIs.</source>
          <target state="translated">클라이언트와 서버가 Host request-header 를 지원하고 HTTP / 1.1 요청에서 Host request-header ( &lt;a href=&quot;#section-14.23&quot;&gt;14.23 절&lt;/a&gt; )가 누락 된 경우 오류를보고하고 절대 URI를 수락해야하는 요구 사항 &lt;a href=&quot;#section-5.1.2&quot;&gt;( &lt;/a&gt;&lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2 &lt;/a&gt;절))는이 사양에서 정의 된 가장 중요한 변경 중 하나입니다. 이전 HTTP / 1.0 클라이언트는 IP 주소와 서버의 일대일 관계를 가정했습니다. 요청의 의도 된 서버를 해당 요청이 지시 된 IP 주소보다 구별하기위한 다른 확립 된 메커니즘은 없었습니다. 위에서 설명한 변경 사항으로 인해 이전 HTTP 클라이언트가 더 이상 일반적이지 않은 인터넷은 단일 IP 주소에서 여러 웹 사이트를 지원할 수 있으므로 단일 호스트에 많은 IP 주소를 할당하면 심각한 문제가 발생하는 대규모 운영 웹 서버가 크게 단순화됩니다. . 인터넷은 루트 도메인 HTTP URL에서 특수 목적 도메인 이름을 사용할 수 있도록 목적으로 만 할당 된 IP 주소를 복구 할 수도 있습니다. 웹의 성장 속도를 고려할 때이미 배포 된 서버 수에 따라 모든 HTTP 구현 (기존 HTTP / 1.0 응용 프로그램에 대한 업데이트 포함)이 다음 요구 사항을 올바르게 구현하는 것이 매우 중요합니다.-클라이언트와 서버 모두 호스트 요청 헤더를 지원해야합니다. -HTTP / 1.1 요청을 보내는 클라이언트는 반드시 호스트 헤더를 보내야합니다. -HTTP / 1.1 요청에 호스트 요청 헤더가 포함되지 않은 경우 서버는 반드시 400 (잘못된 요청) 오류를보고해야합니다. -서버는 절대 URI를 허용해야합니다.1 요청은 반드시 호스트 헤더를 보내야합니다. -HTTP / 1.1 요청에 호스트 요청 헤더가 포함되지 않은 경우 서버는 반드시 400 (잘못된 요청) 오류를보고해야합니다. -서버는 절대 URI를 허용해야합니다.1 요청은 반드시 호스트 헤더를 보내야합니다. -HTTP / 1.1 요청에 호스트 요청 헤더가 포함되지 않은 경우 서버는 반드시 400 (잘못된 요청) 오류를보고해야합니다. -서버는 절대 URI를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b85098c9f819adbf87cde9578f01517d8065c6c2" translate="yes" xml:space="preserve">
          <source>The resource identified by the request is only capable of generating
   response entities which have content characteristics not acceptable
   according to the accept headers sent in the request.

   Unless it was a HEAD request, the response SHOULD include an entity
   containing a list of available entity characteristics and location(s)
   from which the user or user agent can choose the one most
   appropriate. The entity format is specified by the media type given
   in the Content-Type header field. Depending upon the format and the
   capabilities of the user agent, selection of the most appropriate
   choice MAY be performed automatically. However, this specification
   does not define any standard for such automatic selection.

      Note: HTTP/1.1 servers are allowed to return responses which are
      not acceptable according to the accept headers sent in the
      request. In some cases, this may even be preferable to sending a
      406 response. User agents are encouraged to inspect the headers of
      an incoming response to determine if it is acceptable.

   If the response could be unacceptable, a user agent SHOULD
   temporarily stop receipt of more data and query the user for a
   decision on further actions.</source>
          <target state="translated">요청에 의해 식별 된 리소스는 요청에서 전송 된 수락 헤더에 따라 허용되지 않는 컨텐츠 특성을 갖는 응답 엔티티 만 생성 할 수 있습니다. HEAD 요청이 아닌 한, 응답에는 사용 가능한 엔티티 특성 및 위치 목록이 포함 된 엔티티가 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수 있어야합니다. 엔티티 형식은 컨텐츠 유형 헤더 필드에 제공된 매체 유형으로 지정됩니다. 사용자 에이전트의 형식 및 기능에 따라 가장 적합한 선택이 자동으로 수행 될 수 있습니다. 그러나이 사양에서는 이러한 자동 선택에 대한 표준을 정의하지 않습니다. 참고 : HTTP / 1.1 개의 서버는 요청에서 전송 된 승인 헤더에 따라 허용되지 않는 응답을 리턴 할 수 있습니다. 경우에 따라 406 응답을 보내는 것보다이 방법이 더 좋습니다. 사용자 에이전트는 들어오는 응답의 헤더를 검사하여 허용되는지 확인하는 것이 좋습니다. 응답을 받아 들일 수없는 경우, 사용자 에이전트는 일시적으로 더 많은 데이터의 수신을 중지하고 추가 조치에 대한 결정을 사용자에게 조회해야합니다.사용자 에이전트는 더 많은 데이터의 수신을 일시적으로 중지하고 추가 조치에 대한 결정을 사용자에게 조회해야합니다.사용자 에이전트는 더 많은 데이터의 수신을 일시적으로 중지하고 추가 조치에 대한 결정을 사용자에게 조회해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d38c9e9eed37f8ebb054ffe20689cb741c8e1bf" translate="yes" xml:space="preserve">
          <source>The resource that is being accessed is locked.</source>
          <target state="translated">액세스중인 리소스가 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e6d65ce6753d6adca24d41c2f2aab6cad178c87" translate="yes" xml:space="preserve">
          <source>The response from the server may include these.</source>
          <target state="translated">서버의 응답에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0596f7bd46252bc01ceca1b37ff3abcdb40b4bc7" translate="yes" xml:space="preserve">
          <source>The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.</source>
          <target state="translated">응답 헤더 필드를 통해 서버는 상태 표시 줄에 배치 된 것 이상의 응답에 대한 추가 정보를 전달할 수 있습니다. 이 헤더 필드는 서버, 대상 자원에 대한 추가 액세스 또는 관련 자원에 대한 정보를 제공합니다. 각각의 응답 헤더 필드가 정의 된 의미를 갖지만, 일반적으로, 정확한 의미론은 요청 방법 및 / 또는 응답 상태 코드의 의미론에 의해 더 세분화 될 수있다.</target>
        </trans-unit>
        <trans-unit id="ff7a362ee27a0f1762005f0ec6ebc5bb964259ee" translate="yes" xml:space="preserve">
          <source>The response is extremely simple too: it only consisted of the file itself.</source>
          <target state="translated">응답도 매우 간단합니다. 파일 자체로만 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="513c2898705ac68cc3e3ee06f80d9c90116f1922" translate="yes" xml:space="preserve">
          <source>The response then contains an &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; header with the allowed methods:</source>
          <target state="translated">응답에는 허용 된 메소드 가 포함 된 &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; 헤더가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="18088efa80d68a5ff78b12db71323e5708eee380" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is missing the required &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, which is used to determine whether or not the resource can be accessed by content operating within the current origin.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청에 대한 응답에 필요한 &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더 가 없습니다.이 헤더는 현재 오리진 내에서 작동하는 컨텐츠가 자원에 액세스 할 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bacd2f05b83c3c39f0e7214a569bb88e96978d01" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid header name.</source>
          <target state="translated">서버가 보낸 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청에 대한 응답 에는 하나 이상의 유효하지 않은 헤더 이름이 포함 된 &lt;a href=&quot;../../headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 헤더가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a529998feb2d569f6cffb35b10491d075a60be" translate="yes" xml:space="preserve">
          <source>The response to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request that was sent by the server includes an &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header which includes at least one invalid method name.</source>
          <target state="translated">서버가 보낸 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청에 대한 응답 에는 하나 이상의 유효하지 않은 메소드 이름을 포함하는 &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae0be16c13fe096b642ef89520ae9e65e43a5c6" translate="yes" xml:space="preserve">
          <source>The response to the request can be found under a different URI and
   SHOULD be retrieved using a GET method on that resource. This method
   exists primarily to allow the output of a POST-activated script to
   redirect the user agent to a selected resource. The new URI is not a
   substitute reference for the originally requested resource. The 303
   response MUST NOT be cached, but the response to the second
   (redirected) request might be cacheable.

   The different URI SHOULD be given by the Location field in the
   response. Unless the request method was HEAD, the entity of the
   response SHOULD contain a short hypertext note with a hyperlink to
   the new URI(s).

      Note: Many pre-HTTP/1.1 user agents do not understand the 303
      status. When interoperability with such clients is a concern, the
      302 status code may be used instead, since most user agents react
      to a 302 response as described here for 303.</source>
          <target state="translated">요청에 대한 응답은 다른 URI에서 찾을 수 있으며 해당 리소스의 GET 메소드를 사용하여 검색해야합니다. 이 방법은 주로 POST 활성화 스크립트의 출력이 사용자 에이전트를 선택된 리소스로 리디렉션하도록 허용합니다. 새로운 URI는 원래 요청 된 자원의 대체 참조가 아닙니다. 303 응답은 캐시해서는 안되지만 두 번째 (리디렉션 된) 요청에 대한 응답은 캐시 할 수 있습니다. 응답의 위치 필드에서 다른 URI를 제공해야합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔티티는 새로운 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야한다. 참고 : 많은 HTTP / 1.1 이전 사용자 에이전트는 303 상태를 이해하지 못합니다. 그러한 고객과의 상호 운용성이 문제가 될 때302 상태 코드가 대신 사용될 수 있는데, 대부분의 사용자 에이전트는 여기에 설명 된 바와 같이 303에 대한 302 응답에 반응하기 때문이다.</target>
        </trans-unit>
        <trans-unit id="12506b704a003858abdf13381ee9b21f91a7f1af" translate="yes" xml:space="preserve">
          <source>The response-header fields allow the server to pass additional
   information about the response which cannot be placed in the Status-
   Line. These header fields give information about the server and about
   further access to the resource identified by the Request-URI.

       response-header = Accept-Ranges           ; &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;
                       | Age                     ; &lt;a href=&quot;#section-14.6&quot;&gt;Section 14.6&lt;/a&gt;
                       | ETag                    ; &lt;a href=&quot;#section-14.19&quot;&gt;Section 14.19&lt;/a&gt;
                       | Location                ; &lt;a href=&quot;#section-14.30&quot;&gt;Section 14.30&lt;/a&gt;
                       | Proxy-Authenticate      ; &lt;a href=&quot;#section-14.33&quot;&gt;Section 14.33&lt;/a&gt; 

                       | Retry-After             ; &lt;a href=&quot;#section-14.37&quot;&gt;Section 14.37&lt;/a&gt;
                       | Server                  ; &lt;a href=&quot;#section-14.38&quot;&gt;Section 14.38&lt;/a&gt;
                       | Vary                    ; &lt;a href=&quot;#section-14.44&quot;&gt;Section 14.44&lt;/a&gt;
                       | WWW-Authenticate        ; &lt;a href=&quot;#section-14.47&quot;&gt;Section 14.47&lt;/a&gt;

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">응답 헤더 필드를 통해 서버는 상태 행에 배치 할 수없는 응답에 대한 추가 정보를 서버가 전달할 수 있습니다. 이 헤더 필드는 서버 및 Request-URI로 식별 된 자원에 대한 추가 액세스에 대한 정보를 제공합니다. response-header = 수락 범위; &lt;a href=&quot;#section-14.5&quot;&gt;섹션 14.5&lt;/a&gt; | 나이; &lt;a href=&quot;#section-14.6&quot;&gt;섹션 14.6&lt;/a&gt; | ETag; &lt;a href=&quot;#section-14.19&quot;&gt;섹션 14.19&lt;/a&gt; | 위치; &lt;a href=&quot;#section-14.30&quot;&gt;섹션 14.30&lt;/a&gt; | 프록시 인증; &lt;a href=&quot;#section-14.33&quot;&gt;섹션 14.33&lt;/a&gt; | 재시도 후; &lt;a href=&quot;#section-14.37&quot;&gt;섹션 14.37&lt;/a&gt; | 서버; &lt;a href=&quot;#section-14.38&quot;&gt;섹션 14.38&lt;/a&gt; | 다름; &lt;a href=&quot;#section-14.44&quot;&gt;섹션 14.44&lt;/a&gt; | WWW 인증; &lt;a href=&quot;#section-14.47&quot;&gt;섹션 14.47&lt;/a&gt; 응답 헤더 필드 이름은 프로토콜 버전의 변경과 결합해서 만 확실하게 확장 될 수 있습니다. 그러나 통신의 모든 당사자가 응답 헤더 필드로 인식하는 경우 새로운 헤더 필드 또는 실험 헤더 필드에 응답 헤더 필드의 의미가 부여 될 수 있습니다 (MAY). 인식 할 수없는 헤더 필드는 엔티티 헤더 필드로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="e9dacdcee08be9c8b87ede18aa52688f460db02e" translate="yes" xml:space="preserve">
          <source>The resulting string is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded (&lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt;).</source>
          <target state="translated">결과 문자열은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64로&lt;/a&gt; 인코딩됩니다 ( &lt;code&gt;YWxhZGRpbjpvcGVuc2VzYW1l&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe3f7b6dc9ffc173061b38ba8ad0c8201cfdcbaa" translate="yes" xml:space="preserve">
          <source>The returned metainformation in the entity-header is not the
   definitive set as available from the origin server, but is gathered
   from a local or a third-party copy. The set presented MAY be a subset
   or superset of the original version. For example, including local
   annotation information about the resource might result in a superset
   of the metainformation known by the origin server. Use of this
   response code is not required and is only appropriate when the
   response would otherwise be 200 (OK).</source>
          <target state="translated">entity-header에서 리턴 된 메타 정보는 오리진 서버에서 사용 가능한 확정 세트가 아니지만 로컬 또는 써드 파티 사본에서 수집됩니다. 제시된 세트는 원래 버전의 서브 세트 또는 수퍼 세트 일 수있다. 예를 들어, 리소스에 대한 로컬 주석 정보를 포함하면 원본 서버가 알고있는 메타 정보의 상위 집합이 될 수 있습니다. 이 응답 코드를 사용할 필요는 없으며 응답이 200 (OK) 인 경우에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="18a95000f2ca8553876b3106954ec5daa00d8eec" translate="yes" xml:space="preserve">
          <source>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a date.</source>
          <target state="translated">개정 된 자원에 추가 된 개정판 버전은 1.1.3과 같은 고전적인 개정 문자열이거나 단조롭게 증가하는 일련의 숫자 일 필요는 없습니다. 해시 또는 날짜와 같이 충돌을 방지하는 모든 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b125ccbfa7a0e3bda312abb6c814a3f729297ece" translate="yes" xml:space="preserve">
          <source>The root of a Category Document is the &quot;app:categories&quot; element.  An
   app:categories element can contain zero or more atom:category
   elements from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] namespace
   (&quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;).

   An atom:category child element that has no &quot;scheme&quot; attribute
   inherits the attribute from its app:categories parent.  An atom:
   category child element with an existing &quot;scheme&quot; attribute does not
   inherit the &quot;scheme&quot; value of its app:categories parent element. 

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       }

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories</source>
          <target state="translated">카테고리 문서의 루트는 &quot;app : categories&quot;요소입니다. app : categories 요소는 Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 네임 스페이스 ( &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom)의&lt;/a&gt; 0 개 이상의 atom : category 요소를 포함 할 수 있습니다 .&quot;scheme&quot;속성이없는 atom : category 하위 요소는 app : categories 상위에서 속성을 상속합니다 atom : 기존 &quot;scheme&quot;속성이있는 atom : category 하위 요소는 해당 앱의 &quot;scheme&quot;값을 상속하지 않습니다 : 범주 상위 요소 atomCategory = 요소 atom : category {atomCommonAttributes, 속성 용어 {text}, 속성 체계 {atomURI} ?, 속성 레이블 {text} ?, undefinedContent} appInlineCategories = element app : categories {속성 고정 { &quot;yes&quot;| &quot;no&quot;} ?, 특성 체계 {atomURI} ?, (atomCategory *, undefinedContent)} appOutOfLineCategories = 요소 앱 :카테고리 {속성 href {atomURI}, undefinedContent} appCategories = appInline 카테고리 | appOutOfLine 카테고리</target>
        </trans-unit>
        <trans-unit id="dac1669f4b5c683593043fc93e45f9e39b9b3183" translate="yes" xml:space="preserve">
          <source>The root of a Service Document is the &quot;app:service&quot; element.

   The app:service element is the container for service information
   associated with one or more Workspaces.  An app:service element MUST
   contain one or more app:workspace elements.

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   start = appService

   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }</source>
          <target state="translated">서비스 문서의 루트는 &quot;app : service&quot;요소입니다. app : service 요소는 하나 이상의 작업 공간과 연관된 서비스 정보의 컨테이너입니다. app : service 요소는 하나 이상의 app : workspace 요소를 포함해야합니다. 네임 스페이스 앱 = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;시작 = appService appService = 요소 app : service {appCommonAttributes, (appWorkspace + &amp;amp; extensionElement *)}</target>
        </trans-unit>
        <trans-unit id="32ded409a46c9e2ba7534a99504667ab5ee8ab0f" translate="yes" xml:space="preserve">
          <source>The same challenge and response mechanism can be used for &lt;em&gt;proxy authentication&lt;/em&gt;. In this case, it is an intermediate proxy that requires authentication. As both resource authentication and proxy authentication can coexist, a different set of headers and status codes is needed. In the case of proxies, the challenging status code is &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt; (Proxy Authentication Required), the &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response header contains at least one challenge applicable to the proxy, and the &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request header is used for providing the credentials to the proxy server.</source>
          <target state="translated">&lt;em&gt;프록시 인증에&lt;/em&gt; 동일한 챌린지 및 응답 메커니즘을 사용할 수 있습니다 . 이 경우 인증이 필요한 중간 프록시입니다. 리소스 인증과 프록시 인증이 공존 할 수 있으므로 다른 헤더 및 상태 코드 세트가 필요합니다. 프록시의 경우 인증 상태 코드는 &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; (프록시 인증 필요)이고 &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 응답 헤더에는 프록시에 적용 할 수있는 인증 정보가 하나 이상 포함되어 있으며 &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 요청 헤더는 프록시에 자격 증명을 제공하는 데 사용됩니다. 섬기는 사람.</target>
        </trans-unit>
        <trans-unit id="0fb319a198a96a066c14d3602f889f224011cec2" translate="yes" xml:space="preserve">
          <source>The same-site attribute can have one of two values:</source>
          <target state="translated">동일한 사이트 속성은 다음 두 값 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b6e8afc97244358680d329fe8d9b651eecefb1" translate="yes" xml:space="preserve">
          <source>The second way to use Feature Policy is for controlling content within an iframe. Use the &lt;code&gt;allow&lt;/code&gt; attribute to specify a policy list for embedded content.</source>
          <target state="translated">기능 정책을 사용하는 두 번째 방법은 iframe 내에서 콘텐츠를 제어하는 ​​것입니다. (가) 사용 &lt;code&gt;allow&lt;/code&gt; 속성이 포함 된 콘텐츠에 대한 정책 목록을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3498e5bef07e6ed03f63dc1e56c45eca481341" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;Preflighted Access Control Requests&lt;/a&gt; shows a header exchange between client and server. A server resource responding to a preflight requests needs to be able to make the following determinations:</source>
          <target state="translated">&lt;a href=&quot;cors#Preflighted_requests&quot;&gt;프리 플라이트 액세스 제어 요청&lt;/a&gt; 섹션 에는 클라이언트와 서버 간의 헤더 교환이 표시됩니다. 프리 플라이트 요청에 응답하는 서버 리소스는 다음을 결정할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="90f4ec1e7f4c071f00d99bb58a633629eba8d99f" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;cors#Simple_requests&quot;&gt;Simple Access Control Requests&lt;/a&gt; shows you the header exchanges between client and server. Here is a PHP code segment that handles a Simple Request:</source>
          <target state="translated">&lt;a href=&quot;cors#Simple_requests&quot;&gt;단순 액세스 제어 요청&lt;/a&gt; 섹션 에는 클라이언트와 서버 간의 헤더 교환이 표시됩니다. 간단한 요청을 처리하는 PHP 코드 세그먼트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa4d350781530c820391fd6c19e201ae2a7686b3" translate="yes" xml:space="preserve">
          <source>The semantics of GET are unchanged when applied to a collection,
   since GET is defined as, &quot;retrieve whatever information (in the form
   of an entity) is identified by the Request-URI&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  GET, when
   applied to a collection, may return the contents of an &quot;index.html&quot;
   resource, a human-readable view of the contents of the collection, or
   something else altogether.  Hence, it is possible that the result of
   a GET on a collection will bear no correlation to the membership of
   the collection.

   Similarly, since the definition of HEAD is a GET without a response
   message body, the semantics of HEAD are unmodified when applied to
   collection resources.</source>
          <target state="translated">GET의 의미는 컬렉션에 적용될 때 변경되지 않습니다. GET은 &quot;엔터티 형태의 정보가 Request-URI로 식별되는 모든 정보 검색&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]으로 정의되기 때문 입니다. GET은 컬렉션에 적용될 때 &quot;index.html&quot;리소스의 내용, 컬렉션의 내용에 대한 사람이 읽을 수있는보기 등을 반환 할 수 있습니다. 따라서 컬렉션에 대한 GET 결과는 컬렉션의 멤버 자격과 상관 관계가 없을 수 있습니다. 마찬가지로 HEAD의 정의는 응답 메시지 본문이없는 GET이므로 HEAD의 의미는 콜렉션 자원에 적용될 때 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00fa260f74b6e3042ef94427143bf9ccc1a0c47d" translate="yes" xml:space="preserve">
          <source>The server MUST generate an &lt;code&gt;Allow&lt;/code&gt; header field in a 405 response containing a list of the target resource's currently supported methods.</source>
          <target state="translated">서버 는 대상 리소스의 현재 지원되는 메소드 목록을 포함하는 405 응답에 &lt;code&gt;Allow&lt;/code&gt; 헤더 필드를 생성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0562c768d353635c49184c6fe08601647efdac48" translate="yes" xml:space="preserve">
          <source>The server also sends &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; with a value of &quot;&lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt;&quot;, confirming that these are permitted headers to be used with the actual request. Like &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;, &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; is a comma separated list of acceptable headers.</source>
          <target state="translated">또한 서버는 값이 &quot; &lt;code&gt;X-PINGOTHER, Content-Type&lt;/code&gt; &quot;인 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 를 전송 하여 실제 요청에 헤더를 사용할 수 있음을 확인합니다. 마찬가지로 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; , &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 콤마 허용 헤더의 목록을 분리한다.</target>
        </trans-unit>
        <trans-unit id="583376e0dba516f5c2825a92214abd5ad5c19f01" translate="yes" xml:space="preserve">
          <source>The server answers with a code &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; with the header &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt;.</source>
          <target state="translated">서버 는 &lt;code&gt;&lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;: http://example.org/whaddup&lt;/code&gt; : http://example.org/whaddup 헤더와 함께 코드 &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; 로 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="51013a828db296ccfd288d288af04cf909401777" translate="yes" xml:space="preserve">
          <source>The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.</source>
          <target state="translated">서버가 요청 된 리소스를 찾을 수 없습니다. 브라우저에서 이는 URL이 인식되지 않음을 의미합니다. API에서 이는 엔드 포인트가 유효하지만 자원 자체는 존재하지 않음을 의미 할 수도 있습니다. 서버는 403 대신이 응답을 전송하여 권한없는 클라이언트로부터 자원의 존재를 숨길 수 있습니다. 이 응답 코드는 웹에서 자주 발생하기 때문에 가장 유명한 코드 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="79671e2c7c02bbc1b0253a58c7f5460d4f719ccf" translate="yes" xml:space="preserve">
          <source>The server can now redirect to a secure version of the site. A &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header can be used so that the site isn't served by caches to clients that don&amp;rsquo;t support the upgrade mechanism.</source>
          <target state="translated">서버는 이제 안전한 버전의 사이트로 리디렉션 할 수 있습니다. A는 &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더 사이트가 업그레이드 메커니즘을 지원하지 않는 클라이언트에 캐시에 의해 제공되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5445db0622182456257f92e9ecf6bebf5eeb4a0" translate="yes" xml:space="preserve">
          <source>The server compares the client's &lt;code&gt;ETag&lt;/code&gt; (sent with &lt;code&gt;If-None-Match&lt;/code&gt;) with the &lt;code&gt;ETag&lt;/code&gt; for its current version of the resource and if both values match (that is, the resource has not changed), the server send back a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Not Modified&lt;/code&gt; status, without any body, which tells the client that the cached version of the response is still good to use (&lt;em&gt;fresh&lt;/em&gt;).</source>
          <target state="translated">서버는 클라이언트의 &lt;code&gt;ETag&lt;/code&gt; ( &lt;code&gt;If-None-Match&lt;/code&gt; 와 함께 전송 )를 현재 버전의 자원에 대한 &lt;code&gt;ETag&lt;/code&gt; 와 비교하고 두 값이 일치하는 경우 (즉, 자원이 변경되지 않은 경우) 서버는 &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Not Modified&lt;/code&gt; 상태를 다시 보냅니다. , 본문이 없으면 클라이언트에게 캐시 된 버전의 응답이 여전히 사용하기에 좋습니다 ( &lt;em&gt;fresh&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="61c7564335ef677861a44bea5af3ab893bbca1c3" translate="yes" xml:space="preserve">
          <source>The server could also consider other &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, such as &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버는 &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; 와 같은 다른 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 헤더 도 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96160ecd7ee13608af383e3bb73b0b35b5d6fb42" translate="yes" xml:space="preserve">
          <source>The server detected an infinite loop while processing the request.</source>
          <target state="translated">서버가 요청을 처리하는 동안 무한 루프를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="fedec016c5b57cc11eff3c532c6a93596d64f0f6" translate="yes" xml:space="preserve">
          <source>The server does not support the functionality required to fulfill the
   request. This is the appropriate response when the server does not
   recognize the request method and is not capable of supporting it for
   any resource.</source>
          <target state="translated">서버는 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 서버가 요청 방법을 인식하지 못하고 자원을 지원할 수없는 경우 적절한 응답입니다.</target>
        </trans-unit>
        <trans-unit id="b05cf7bf3fff0832cc499297170da1dced108414" translate="yes" xml:space="preserve">
          <source>The server does not support, or refuses to support, the HTTP protocol
   version that was used in the request message. The server is
   indicating that it is unable or unwilling to complete the request
   using the same major version as the client, as described in &lt;a href=&quot;#section-3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;, other than with this error message. The response SHOULD contain
   an entity describing why that version is not supported and what other
   protocols are supported by that server.</source>
          <target state="translated">서버가 요청 메시지에 사용 된 HTTP 프로토콜 버전을 지원하지 않거나 지원하지 않습니다. 서버는 이 오류 메시지를 제외하고 &lt;a href=&quot;#section-3.1&quot;&gt;3.1 &lt;/a&gt;&lt;a href=&quot;#section-3.1&quot;&gt;절에&lt;/a&gt; 설명 된대로 클라이언트와 동일한 주 버전을 사용하여 요청을 완료 할 수 없거나 완료하지 않음을 나타냅니다 . 응답에는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 엔터티가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c06e31cc29dd99d9a9450fd0a50b146873ff8448" translate="yes" xml:space="preserve">
          <source>The server doesn't have total knowledge of the browser. Even with the Client Hints extension, it has not a complete knowledge of the capabilities of the browser. Unlike reactive content negotiation where the client makes the choice, the server choice is always somewhat arbitrary.</source>
          <target state="translated">서버에 브라우저에 대한 완전한 지식이 없습니다. 클라이언트 힌트 확장을 사용하더라도 브라우저 기능에 대한 완전한 지식이 없습니다. 클라이언트가 선택하는 반응 형 컨텐츠 협상과 달리 서버 선택은 항상 다소 임의적입니다.</target>
        </trans-unit>
        <trans-unit id="59d4cf28c9831ade812e9ba3919040baedea9266" translate="yes" xml:space="preserve">
          <source>The server encountered an unexpected condition which prevented it
   from fulfilling the request.</source>
          <target state="translated">서버에 예기치 않은 조건이 발생하여 요청을 이행하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="10710baff0a022ad3a742df8fef3c65957eb66a8" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.</source>
          <target state="translated">서버에 내부 구성 오류가 있습니다. 선택한 변형 리소스가 투명한 콘텐츠 협상 자체에 관여하도록 구성되어 있으므로 협상 프로세스의 적절한 끝 점이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="706ed34301bbcc058a72a5142e2a23a25bb1303a" translate="yes" xml:space="preserve">
          <source>The server has an internal configuration error: transparent content negotiation for the request results in a circular reference.</source>
          <target state="translated">서버에 내부 구성 오류가 있습니다. 요청에 대한 투명한 컨텐츠 협상으로 인해 순환 참조가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d758b127d939bbbe9c83eda748c2d96b939c4dc5" translate="yes" xml:space="preserve">
          <source>The server has encountered a situation it doesn't know how to handle.</source>
          <target state="translated">서버에서 처리 방법을 모르는 상황이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b30dd73b04a13c811e1dbf9b2319193169edb03c" translate="yes" xml:space="preserve">
          <source>The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.</source>
          <target state="translated">서버가 자원에 대한 GET 요청을 이행했으며 응답은 현재 인스턴스에 적용된 하나 이상의 인스턴스 조작 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e118a9d32f4f8ee5d1a291b20a7b4b379a234f47" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the partial GET request for the resource.
   The request MUST have included a Range header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;)
   indicating the desired range, and MAY have included an If-Range
   header field (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) to make the request conditional.

   The response MUST include the following header fields:

      - Either a Content-Range header field (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;) indicating
        the range included with this response, or a multipart/byteranges
        Content-Type including Content-Range fields for each part. If a
        Content-Length header field is present in the response, its
        value MUST match the actual number of OCTETs transmitted in the
        message-body.

      - Date

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request 

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the 206 response is the result of an If-Range request that used a
   strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), the response SHOULD NOT
   include other entity-headers. If the response is the result of an
   If-Range request that used a weak validator, the response MUST NOT
   include other entity-headers; this prevents inconsistencies between
   cached entity-bodies and updated headers. Otherwise, the response
   MUST include all of the entity-headers that would have been returned
   with a 200 (OK) response to the same request.

   A cache MUST NOT combine a 206 response with other previously cached
   content if the ETag or Last-Modified headers do not match exactly,
   see 13.5.4.

   A cache that does not support the Range and Content-Range headers
   MUST NOT cache 206 (Partial) responses.</source>
          <target state="translated">서버가 자원에 대한 부분 GET 요청을 이행했습니다. 요청 에는 원하는 범위를 나타내는 Range 헤더 필드 ( &lt;a href=&quot;#section-14.35&quot;&gt;14.35 섹션&lt;/a&gt; )가 포함되어 있어야하고, 요청을 조건부로 만들기 위해 If-Range 헤더 필드 ( &lt;a href=&quot;#section-14.27&quot;&gt;14.27 섹션&lt;/a&gt; ) 가 포함되어있을 수 있습니다. 응답에는 다음 헤더 필드가 포함되어야합니다.-Content-Range 헤더 필드 ( &lt;a href=&quot;#section-14.16&quot;&gt;섹션 14.16)&lt;/a&gt;)는이 응답에 포함 된 범위 또는 각 파트의 컨텐츠 범위 필드를 포함하는 멀티 파트 / 바이트 범위 컨텐츠 유형을 나타냅니다. Content-Length 헤더 필드가 응답에 존재하면 해당 값은 메시지 본문에서 전송 된 실제 OCTET 수와 일치해야합니다. -날짜-ETag 및 / 또는 Content-Location (헤더가 동일한 요청에 200 응답으로 전송 된 경우)-필드 값이 전송 된 필드 값과 다를 수있는 경우 만료, 캐시 제어 및 / 또는 가변 동일한 변형에 대한 이전 응답 206 응답이 강력한 캐시 검사기를 사용한 If-Range 요청의 결과 인 경우 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3&lt;/a&gt; 참조))에 응답에는 다른 엔터티 헤더가 포함되어서는 안됩니다. 응답이 취약한 유효성 검사기를 사용한 If-Range 요청의 결과 인 경우 다른 엔티티 헤더를 포함해서는 안됩니다. 이렇게하면 캐시 된 엔터티 본문과 업데이트 된 헤더 간의 불일치가 방지됩니다. 그렇지 않으면 응답에는 동일한 요청에 대해 200 (OK) 응답으로 반환 된 모든 엔터티 헤더가 포함되어야합니다. ETag 또는 Last-Modified 헤더가 정확히 일치하지 않으면 캐시는 206 응답을 이전에 캐시 된 다른 컨텐츠와 결합해서는 안됩니다 (13.5.4 참조). Range 및 Content-Range 헤더를 지원하지 않는 캐시는 206 (부분) 응답을 캐시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9154c7f74bf47c2abcfe8e8637f31d473b4ccf8a" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request and the user agent SHOULD reset
   the document view which caused the request to be sent. This response
   is primarily intended to allow input for actions to take place via
   user input, followed by a clearing of the form in which the input is
   given so that the user can easily initiate another input action. The
   response MUST NOT include an entity.</source>
          <target state="translated">서버가 요청을 이행했으며 사용자 에이전트는 요청을 보낸 문서보기를 재설정해야합니다. 이 응답은 주로 사용자 입력을 통해 작업에 대한 입력을 수행 한 다음 사용자가 다른 입력 작업을 쉽게 시작할 수 있도록 입력이 제공되는 형식을 지 웁니다. 응답은 엔티티를 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee5c3ee094642bb5d46e9cb3d051a90abd31149" translate="yes" xml:space="preserve">
          <source>The server has fulfilled the request but does not need to return an
   entity-body, and might want to return updated metainformation. The
   response MAY include new or updated metainformation in the form of
   entity-headers, which if present SHOULD be associated with the
   requested variant.

   If the client is a user agent, it SHOULD NOT change its document view
   from that which caused the request to be sent. This response is
   primarily intended to allow input for actions to take place without
   causing a change to the user agent's active document view, although
   any new or updated metainformation SHOULD be applied to the document
   currently in the user agent's active view.

   The 204 response MUST NOT include a message-body, and thus is always
   terminated by the first empty line after the header fields.</source>
          <target state="translated">서버가 요청을 이행했지만 엔티티 본문을 리턴 할 필요가 없으며 업데이트 된 메타 정보를 리턴 할 수 있습니다. 응답에는 엔티티 헤더의 형태로 새로운 메타 정보 또는 업데이트 된 메타 정보가 포함될 수 있으며, 존재하는 경우 요청 된 변형과 관련되어야합니다. 클라이언트가 사용자 에이전트 인 경우 요청을 보낸 원인에서 문서보기를 변경해서는 안됩니다. 이 응답은 주로 사용자 에이전트의 활성보기에있는 문서에 새로운 또는 업데이트 된 메타 정보를 적용해야하지만, 사용자 에이전트의 활성 문서보기를 변경하지 않고 작업에 대한 입력을 허용하기위한 것입니다. 204 응답은 메시지 본문을 포함해서는 안되므로 항상 헤더 필드 다음의 첫 번째 빈 줄로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2ef715f1697c767e016f66e48a9c5ad3088fc4" translate="yes" xml:space="preserve">
          <source>The server has not found anything matching the Request-URI. No
   indication is given of whether the condition is temporary or
   permanent. The 410 (Gone) status code SHOULD be used if the server
   knows, through some internally configurable mechanism, that an old
   resource is permanently unavailable and has no forwarding address.
   This status code is commonly used when the server does not wish to
   reveal exactly why the request has been refused, or when no other
   response is applicable.</source>
          <target state="translated">서버가 Request-URI와 일치하는 것을 찾지 못했습니다. 조건이 일시적인지 영구적인지에 대한 표시는 없습니다. 410 (Gone) 상태 코드는 서버가 내부적으로 구성 가능한 메커니즘을 통해 오래된 리소스를 영구적으로 사용할 수없고 전달 주소가 없음을 알고있는 경우 사용해야합니다. 이 상태 코드는 일반적으로 서버가 요청이 거부 된 이유를 정확히 밝히지 않거나 다른 응답이없는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76d2c9e44a151f75cad87b75d25351ab5902d469" translate="yes" xml:space="preserve">
          <source>The server includes in this response an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; response header to indicate the protocol it switched to. The process is described in detail in the article &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;Protocol upgrade mechanism&lt;/a&gt;.</source>
          <target state="translated">서버는이 응답에 스위치가 전환 된 프로토콜을 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 응답 헤더를 포함합니다. 이 프로세스는 &lt;a href=&quot;../protocol_upgrade_mechanism&quot;&gt;프로토콜 업그레이드 메커니즘&lt;/a&gt; 기사에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be80728dab68882cff956fbc4def7165d17d07e6" translate="yes" xml:space="preserve">
          <source>The server is currently unable to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is a temporary condition which will be alleviated after
   some delay. If known, the length of the delay MAY be indicated in a
   Retry-After header. If no Retry-After is given, the client SHOULD
   handle the response as it would for a 500 response.

      Note: The existence of the 503 status code does not imply that a
      server must use it when becoming overloaded. Some servers may wish
      to simply refuse the connection.</source>
          <target state="translated">서버의 일시적인 과부하 또는 유지 관리로 인해 서버가 현재 요청을 처리 할 수 ​​없습니다. 이는 약간의 지연 후에 완화 될 일시적인 상태라는 의미입니다. 알려진 경우 지연 길이는 Retry-After 헤더에 표시 될 수 있습니다. Retry-After가 제공되지 않으면 클라이언트는 500 응답과 마찬가지로 응답을 처리해야합니다. 참고 : 503 상태 코드가 존재한다고해서 서버가 오버로드 될 때이를 사용해야한다는 것을 의미하지는 않습니다. 일부 서버는 단순히 연결을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf2d9062e2499753136835fe0c821934d565f38" translate="yes" xml:space="preserve">
          <source>The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the &lt;code&gt;Retry-After:&lt;/code&gt; HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.</source>
          <target state="translated">서버가 요청을 처리 할 준비가되지 않았습니다. 일반적인 원인은 유지 관리를 위해 다운되었거나 과부하 된 서버입니다. 이 응답과 함께 문제를 설명하는 사용자 친화적 인 페이지를 보내야합니다. 이 응답은 임시 조건에 사용해야하며 가능하면 &lt;code&gt;Retry-After:&lt;/code&gt; HTTP 헤더는 가능한 경우 서비스 복구 전 예상 시간을 포함해야합니다. 웹 마스터는 이러한 임시 조건 응답은 일반적으로 캐시되지 않으므로이 응답과 함께 전송되는 캐싱 관련 헤더를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="30401629d5451d683706de07ce99fc1a19648e2c" translate="yes" xml:space="preserve">
          <source>The server is overloaded and cannot afford the computational overhead induced by the compression requirement. Typically, Microsoft recommends not to compress if a server uses more than 80% of its computational power.</source>
          <target state="translated">서버에 과부하가 발생하여 압축 요구 사항으로 인한 계산 오버 헤드를 감당할 수 없습니다. 일반적으로 서버가 계산 능력의 80 % 이상을 사용하는 경우 압축하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="91058d54183ce48b758a3923ca1dd0add318d618" translate="yes" xml:space="preserve">
          <source>The server is refusing to process a request because the request
   entity is larger than the server is willing or able to process. The
   server MAY close the connection to prevent the client from continuing
   the request.

   If the condition is temporary, the server SHOULD include a Retry-
   After header field to indicate that it is temporary and after what
   time the client MAY try again.</source>
          <target state="translated">요청 엔티티가 서버가 처리 할 수 ​​있거나 처리 할 수있는 것보다 크기 때문에 서버가 요청 처리를 거부합니다. 서버는 클라이언트가 요청을 계속하지 못하도록 연결을 닫을 수 있습니다. 조건이 일시적인 경우 서버는 재시도 후 헤더 필드를 포함하여 일시적이고 클라이언트가 다시 시도 할 수있는 시간을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="555c0a61bfb0c95cce342015880bc471fe52028d" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the Request-URI
   is longer than the server is willing to interpret. This rare
   condition is only likely to occur when a client has improperly
   converted a POST request to a GET request with long query
   information, when the client has descended into a URI &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself), or when the server is under attack by a client attempting to
   exploit security holes present in some servers using fixed-length
   buffers for reading or manipulating the Request-URI.</source>
          <target state="translated">Request-URI가 서버가 해석하고자하는 것보다 길기 때문에 서버가 요청 서비스를 거부합니다. 클라이언트가 리디렉션의 URI &quot;블랙홀&quot;(예 : 리디렉션 된 URI 접두사)로 내림차순으로 클라이언트가 긴 쿼리 정보를 사용하여 POST 요청을 GET 요청으로 잘못 변환 한 경우에만이 드문 조건이 발생합니다 접미사 자체) 또는 Request-URI를 읽거나 조작하기 위해 고정 길이 버퍼를 사용하여 일부 서버에 존재하는 보안 허점을 악용하려는 클라이언트가 서버를 공격하는 경우.</target>
        </trans-unit>
        <trans-unit id="b7583fbc3987a772449c07846db7b69d3aab25c3" translate="yes" xml:space="preserve">
          <source>The server is refusing to service the request because the entity of
   the request is in a format not supported by the requested resource
   for the requested method.</source>
          <target state="translated">요청의 엔티티가 요청 된 메소드에 대해 요청 된 자원이 지원하지 않는 형식이므로 서버가 요청 서비스를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="9e40f61b278945136b6bf8c69ccb6441c6101dc0" translate="yes" xml:space="preserve">
          <source>The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">헤더 필드가 너무 커서 서버가 요청을 처리하지 않습니다. 요청 헤더 필드의 크기를 줄인 후 요청을 다시 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b402009d984cfa7b4aa7445fadf6432930d62bf" translate="yes" xml:space="preserve">
          <source>The server may either refuse the upgrade &amp;mdash; in this case it merely ignores the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header and sends back a regular response (&lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; if it can serve the requested resource, a &lt;code&gt;30x&lt;/code&gt; status code if it wants to perform a redirect, a &lt;code&gt;40x&lt;/code&gt; or &lt;code&gt;50x&lt;/code&gt; one if it can't serve the requested resource) &amp;mdash; or accept the upgrade. In this case, it sends back a &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; with an Upgrade header that specifies the protocol chosen.</source>
          <target state="translated">서버는 업그레이드를 거부 할 수 있습니다.이 경우에는 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 헤더를 무시하고 정기적 인 응답 ( 요청 된 자원을 제공 할 수있는 경우 &lt;code&gt;&quot;200 OK&quot;&lt;/code&gt; , 리디렉션을 수행하려는 경우 &lt;code&gt;30x&lt;/code&gt; 상태 코드, &lt;code&gt;40x&lt;/code&gt; 또는 &lt;code&gt;50x&lt;/code&gt; 하나가) 요청 된 리소스를 제공 할 수없는 경우 - 또는 업그레이드에 동의합니다. 이 경우 선택한 프로토콜을 지정하는 업그레이드 헤더와 함께 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 을 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="2eb9ea8eac80a46172e3c3d063d37cbb8a09735e" translate="yes" xml:space="preserve">
          <source>The server may specify &quot;*&quot; as a wildcard, thereby allowing any origin to see timing resources.</source>
          <target state="translated">서버는 &quot;*&quot;를 와일드 카드로 지정하여 모든 오리진이 타이밍 자원을 볼 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="0103c094e5add7857b8d5242900bc764e81c4d56" translate="yes" xml:space="preserve">
          <source>The server now checks the request headers and may respond with a &lt;a href=&quot;../status/100&quot;&gt;&lt;code&gt;100&lt;/code&gt;&lt;/a&gt; (Continue) response to instruct the client to go ahead and send the message body, or it will send a &lt;a href=&quot;../status/417&quot;&gt;&lt;code&gt;417&lt;/code&gt;&lt;/a&gt; (Expectation Failed) status if any of the expectations cannot be met.</source>
          <target state="translated">서버는 이제 요청 헤더를 확인하고 &lt;a href=&quot;../status/100&quot;&gt; &lt;code&gt;100&lt;/code&gt; &lt;/a&gt; (Continue) 응답으로 응답하여 클라이언트에게 메시지 본문을 보내도록 지시하거나 기대치를 충족 할 수없는 경우 &lt;a href=&quot;../status/417&quot;&gt; &lt;code&gt;417&lt;/code&gt; &lt;/a&gt; (예상 실패) 상태를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e1283857d0934fd62a1b18ee296b4ffd28fea393" translate="yes" xml:space="preserve">
          <source>The server only permits access to documents being loaded specifically over HTTPS through the single origin onlinebanking.jumbobank.com.</source>
          <target state="translated">서버는 단일 출처 onlinebanking.jumbobank.com을 통해 HTTPS를 통해 특별히로드되는 문서에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c7fec239224320ece1ddcef09fb8d8afe6a922" translate="yes" xml:space="preserve">
          <source>The server processes the request, sending back its answer, providing a status code and appropriate data.</source>
          <target state="translated">서버는 요청을 처리하고 응답을 다시 보내 상태 코드와 적절한 데이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a76d046fb30a4094df60f730aa186a8214f36f9" translate="yes" xml:space="preserve">
          <source>The server refuses the attempt to brew coffee with a teapot.</source>
          <target state="translated">서버는 주전자로 커피를 추출하려는 시도를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="0521746f768ead6cf341a3de72d80f86946a50aa" translate="yes" xml:space="preserve">
          <source>The server refuses to accept the request without a defined Content-
   Length. The client MAY repeat the request if it adds a valid
   Content-Length header field containing the length of the message-body
   in the request message.</source>
          <target state="translated">서버는 정의 된 Content- Length없이 요청 수락을 거부합니다. 클라이언트는 요청 메시지에 메시지 본문의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하면 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098d1595780b213e964cc55bccf5bbf26c81cacc" translate="yes" xml:space="preserve">
          <source>The server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header in a 426 response to indicate the required protocol(s).</source>
          <target state="translated">서버는 현재 프로토콜을 사용하여 요청을 수행하지 않지만 클라이언트가 다른 프로토콜로 업그레이드 한 후 기꺼이 할 수 있습니다. 서버는 필요한 프로토콜을 나타 내기 위해 426 응답으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d96c620c10c72c2facba569247c0abd76880b504" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and says that &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; are viable methods to query the resource in question. This header is similar to the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of CORS.</source>
          <target state="translated">서버는 &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 로&lt;/a&gt; 응답 하고 &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;OPTIONS&lt;/code&gt; 가 문제의 리소스를 쿼리하는 데 유용한 방법 이라고 말합니다 . 이 헤더는 &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; 응답 헤더 와 유사 하지만 CORS 컨텍스트 내에서 엄격하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0adba182e0838c8ba807f3caebecfe1ff5519a80" translate="yes" xml:space="preserve">
          <source>The server responds with &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; and says that &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; are viable methods to query the resource in question. Note that this header is similar to the &lt;a href=&quot;headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; response header, but used strictly within the context of access control.</source>
          <target state="translated">서버는 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 로 응답 하고 &lt;code&gt;POST&lt;/code&gt; 및 &lt;code&gt;GET&lt;/code&gt; 이 문제의 리소스를 쿼리하는 데 유용한 방법 이라고 말합니다 . 이 헤더는 &lt;a href=&quot;headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; 응답 헤더 와 유사 하지만 액세스 제어 컨텍스트 내에서 엄격하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d7efc45419f666af1044e66769f805e285297d7" translate="yes" xml:space="preserve">
          <source>The server responds with the scheme used, indicated by the &lt;code&gt;Content-Encoding&lt;/code&gt; response header.</source>
          <target state="translated">서버는 &lt;code&gt;Content-Encoding&lt;/code&gt; 응답 헤더로 표시되는 사용 된 체계로 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="adb6ebfb2d7ba636e549327e9964bd8e4a9aa87e" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status and a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; header, indicating that a multipart byterange follows. Each part contains its own &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-Range&lt;/code&gt; fields and the required boundary parameter specifies the boundary string used to separate each body-part.</source>
          <target state="translated">서버는 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 상태 및 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: multipart/byteranges; boundary=3d6b6a416f9b5&lt;/code&gt; 헤더는 멀티 파트 바이트 범위가 뒤따른 다는 것을 나타냅니다. 각 파트에는 고유 한 &lt;code&gt;Content-Type&lt;/code&gt; 및 &lt;code&gt;Content-Range&lt;/code&gt; 필드가 있으며 필수 경계 매개 변수는 각 본문 부분을 구분하는 데 사용되는 경계 문자열을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d9701baf78124c3a98a96cf4e906d3722ade4288" translate="yes" xml:space="preserve">
          <source>The server responses with the &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; status:</source>
          <target state="translated">서버는 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 상태로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="60a245e6b24fad30a550d86662bff1af7454a2ee" translate="yes" xml:space="preserve">
          <source>The server sends an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with this response to indicate the required protocol(s).</source>
          <target state="translated">서버는 이 응답과 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더를 보내 필요한 프로토콜을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9542fcfca4223129b519747385fa48be52ecf048" translate="yes" xml:space="preserve">
          <source>The server sends this response to direct the client to get the requested resource at another URI with same method that was used in the prior request. This has the same semantics as the &lt;code&gt;302 Found&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">서버는이 요청을 전송하여 클라이언트가 이전 요청에서 사용한 것과 동일한 방법으로 다른 URI에서 요청 된 자원을 가져 오도록 지시합니다. 이것은 같은 의미를 갖는다 &lt;code&gt;302 Found&lt;/code&gt; 사용자 에이전트는 것을 제외하고는, HTTP 응답 코드를 &lt;em&gt;안&lt;/em&gt; 경우 사용되는 HTTP 방법을 변경 &lt;code&gt;POST&lt;/code&gt; 가 첫 번째 요청에 사용 하였다하는 &lt;code&gt;POST&lt;/code&gt; 는 두 번째 요청에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="5c7306d33878ab5bc99fecabc06252df15d1029f" translate="yes" xml:space="preserve">
          <source>The server sent this response to direct the client to get the requested resource at another URI with a GET request.</source>
          <target state="translated">서버는이 응답을 전송하여 클라이언트가 GET 요청과 함께 다른 URI에서 요청 된 자원을 가져 오도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="8cf25e98d428f5cff29ccef9eba702a25e100fa8" translate="yes" xml:space="preserve">
          <source>The server understands and is willing to comply with the client's
   request, via the Upgrade message header field (&lt;a href=&quot;#section-14.42&quot;&gt;section 14.42&lt;/a&gt;), for a
   change in the application protocol being used on this connection. The
   server will switch protocols to those defined by the response's
   Upgrade header field immediately after the empty line which
   terminates the 101 response.

   The protocol SHOULD be switched only when it is advantageous to do
   so. For example, switching to a newer version of HTTP is advantageous
   over older versions, and switching to a real-time, synchronous
   protocol might be advantageous when delivering resources that use
   such features.</source>
          <target state="translated">서버는 이 연결에서 사용되는 애플리케이션 프로토콜의 변경에 대한 업그레이드 메시지 헤더 필드 ( &lt;a href=&quot;#section-14.42&quot;&gt;섹션 14.42&lt;/a&gt; ) 를 통해 클라이언트의 요청을 이해하고 기꺼이 준수 합니다. 서버는 빈 줄 바로 다음에 응답의 업그레이드 헤더 필드에 의해 정의 된 프로토콜로 프로토콜을 전환하여 101 응답을 종료합니다. 프로토콜은 유리한 경우에만 전환해야한다. 예를 들어, 최신 버전의 HTTP로 전환하는 것이 이전 버전보다 유리하며 실시간 동기 프로토콜로 전환하면 이러한 기능을 사용하는 리소스를 제공 할 때 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1ec0c651dbab18735a86dfc8ae8c14372b5e8a" translate="yes" xml:space="preserve">
          <source>The server understood the request, but is refusing to fulfill it.
   Authorization will not help and the request SHOULD NOT be repeated.
   If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it SHOULD describe the
   reason for the refusal in the entity.  If the server does not wish to
   make this information available to the client, the status code 404
   (Not Found) can be used instead.</source>
          <target state="translated">서버가 요청을 이해했지만 요청 이행을 거부하고 있습니다. 승인은 도움이되지 않으며 요청을 반복해서는 안됩니다. 요청 방법이 HEAD가 아니고 서버가 요청이 이행되지 않은 이유를 공개하기를 원한다면, 엔티티에서 거부 이유를 설명해야한다. 서버가이 정보를 클라이언트가 사용할 수 없게하려면 상태 코드 404 (찾을 수 없음)를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94809fc6f53d174f5374acd4dfb1f7acb678c149" translate="yes" xml:space="preserve">
          <source>The server's response's &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header will have a value computed based upon the specified &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">서버의 응답 &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; 헤더는 지정된 &lt;code&gt;key&lt;/code&gt; 기반으로 계산 된 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ef1a39a25ddc08d8e0d5a5bb5464d92b09bc2a" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, did not receive a
   timely response from the upstream server specified by the URI (e.g.
   HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed
   to access in attempting to complete the request.

      Note: Note to implementors: some deployed proxies are known to
      return 400 or 500 when DNS lookups time out.</source>
          <target state="translated">게이트웨이 또는 프록시 역할을하는 서버는 URI (예 : HTTP, FTP, LDAP) 또는 완료를 시도하는 데 액세스해야하는 다른 보조 서버 (예 : DNS)로 지정된 업스트림 서버로부터시기 적절한 응답을받지 못했습니다. 요청. 참고 : 구현 자 참고 사항 : 배포 된 일부 프록시는 DNS 조회 시간이 초과 될 때 400 또는 500을 반환하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e47cc0b16529d905f0b1b3af210872557d572b" translate="yes" xml:space="preserve">
          <source>The server, while acting as a gateway or proxy, received an invalid
   response from the upstream server it accessed in attempting to
   fulfill the request.</source>
          <target state="translated">게이트웨이 또는 프록시 역할을하는 서버가 요청을 수행하기 위해 액세스 한 업스트림 서버로부터 잘못된 응답을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="cad9f838a72a1881211f8a63fadbd9aa2da06441" translate="yes" xml:space="preserve">
          <source>The set of common methods for HTTP/1.1 is defined below. Although
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extended clients and servers.

   The Host request-header field (&lt;a href=&quot;#section-14.23&quot;&gt;section 14.23&lt;/a&gt;) MUST accompany all
   HTTP/1.1 requests.</source>
          <target state="translated">HTTP / 1.1에 대한 일반적인 방법 세트는 아래에 정의되어 있습니다. 이 세트를 확장 할 수는 있지만 별도로 확장 된 클라이언트 및 서버에 대해 동일한 의미를 공유하는 추가 방법을 가정 할 수 없습니다. 호스트 요청 헤더 필드 ( &lt;a href=&quot;#section-14.23&quot;&gt;14.23 절&lt;/a&gt; )는 모든 HTTP / 1.1 요청과 함께 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="57fc403f1552de7486f1009e75d3e485460c6c32" translate="yes" xml:space="preserve">
          <source>The site returns a generic success message confirming the post was published. The server specifies &lt;em&gt;where&lt;/em&gt; the new post is with &lt;code&gt;Content-Location&lt;/code&gt;:</source>
          <target state="translated">사이트는 게시물이 게시되었음을 확인하는 일반적인 성공 메시지를 반환합니다. 서버 지정 새로운 포스트가 함께 &lt;code&gt;Content-Location&lt;/code&gt; :&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40812bee8a9705438af783eaa9ebe956256664d2" translate="yes" xml:space="preserve">
          <source>The special value of '&lt;code&gt;*&lt;/code&gt;' means that the server-driven content negotiation also uses information not conveyed in a header to choose the appropriate content.</source>
          <target state="translated">' &lt;code&gt;*&lt;/code&gt; ' 의 특수 값은 서버 기반 컨텐츠 협상에서 헤더로 전달되지 않은 정보를 사용하여 적절한 컨텐츠를 선택 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8f79a17c3099080cc2dd18760e1e6dd5db53ca77" translate="yes" xml:space="preserve">
          <source>The specification advices that names and descriptions should be kept as short as possible (use abbreviations and omit optional values where possible) to minimize the HTTP overhead.</source>
          <target state="translated">사양에서는 HTTP 오버 헤드를 최소화하기 위해 이름과 설명을 가능한 짧게 유지해야합니다 (약어를 사용하고 가능한 경우 선택적 값을 생략 함).</target>
        </trans-unit>
        <trans-unit id="6830140aefcebc442d186cdf8f55cdcc404c9a85" translate="yes" xml:space="preserve">
          <source>The specification has been substantially rewritten for clarity.

   The conditions under which an authenticated response can be cached
   have been clarified.  (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   New status codes can now define that caches are allowed to use
   heuristic freshness with them.  Caches are now allowed to calculate
   heuristic freshness for URIs with query components.  (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The algorithm for calculating age is now less conservative.  Caches
   are now required to handle dates with time zones as if they're
   invalid, because it's not possible to accurately guess.
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;)

   The Content-Location response header field is no longer used to
   determine the appropriate response to use when validating.
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)

   The algorithm for selecting a cached negotiated response to use has
   been clarified in several ways.  In particular, it now explicitly
   allows header-specific canonicalization when processing selecting
   header fields.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   Requirements regarding denial-of-service attack avoidance when
   performing invalidation have been clarified.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache invalidation only occurs when a successful response is
   received.  (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;)

   Cache directives are explicitly defined to be case-insensitive.
   Handling of multiple instances of cache directives when only one is
   expected is now defined.  (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;)

   The &quot;no-store&quot; request directive doesn't apply to responses; i.e., a
   cache can satisfy a request with no-store on it and does not
   invalidate it.  (&lt;a href=&quot;#section-5.2.1.5&quot;&gt;Section 5.2.1.5&lt;/a&gt;)

   The qualified forms of the private and no-cache cache directives are
   noted to not be widely implemented; for example, &quot;private=foo&quot; is
   interpreted by many caches as simply &quot;private&quot;.  Additionally, the
   meaning of the qualified form of no-cache has been clarified.
   (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;)

   The &quot;no-cache&quot; response directive's meaning has been clarified.
   (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;) 

   The one-year limit on Expires header field values has been removed;
   instead, the reasoning for using a sensible value is given.
   (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The Pragma header field is now only defined for backwards
   compatibility; future pragmas are deprecated.  (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;)

   Some requirements regarding production and processing of the Warning
   header fields have been relaxed, as it is not widely implemented.
   Furthermore, the Warning header field no longer uses &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;
   encoding, nor does it allow multiple languages, as these aspects were
   not implemented.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   This specification introduces the Cache Directive and Warn Code
   Registries, and defines considerations for new cache directives.
   (&lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt; and &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;)</source>
          <target state="translated">사양은 명확성을 위해 재 작성되었습니다. 인증 된 응답을 캐시 할 수있는 조건이 명확 해졌습니다. ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; ) 새로운 상태 코드는 이제 캐시가 추론 적 신선도를 사용할 수 있도록 정의 할 수 있습니다. 캐시는 이제 쿼리 구성 요소가있는 URI의 휴리스틱 신선도를 계산할 수 있습니다. ( &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ) 이제 연령 계산 알고리즘이 덜 보수적입니다. 캐시는 이제 정확하게 추측 할 수 없기 때문에 표준 시간대가 유효하지 않은 것처럼 날짜를 처리해야합니다. ( &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; ) 컨텐츠 위치 응답 헤더 필드는 더 이상 유효성을 검사 할 때 사용할 적절한 응답을 결정하는 데 사용되지 않습니다. ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 항&lt;/a&gt;) 캐시 된 협상 응답을 선택하기위한 알고리즘이 여러 가지 방법으로 명확 해졌습니다. 특히, 이제 헤더 필드 선택을 처리 할 때 헤더 별 정규화를 명시 적으로 허용합니다. ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; ) 무효화를 수행 할 때 서비스 거부 공격 방지와 관련된 요구 사항이 명확 해졌습니다. ( &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; ) 캐시 무효화는 성공적인 응답이 수신 된 경우에만 발생합니다. ( &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; ) 캐시 지시문은 대소 문자를 구분하지 않도록 명시 적으로 정의됩니다. 하나만 예상 될 때 캐시 지시문의 여러 인스턴스 처리가 정의되었습니다. ( &lt;a href=&quot;#section-5.2&quot;&gt;5.2 절&lt;/a&gt;) &quot;비 점포&quot;요청 지시문은 응답에 적용되지 않습니다. 즉, 캐시는 저장소가없는 요청을 만족시킬 수 있으며 무효화하지 않습니다. ( &lt;a href=&quot;#section-5.2.1.5&quot;&gt;5.2.1.5 절&lt;/a&gt; ) 개인 및 캐시없는 캐시 지시문의 규정 된 형식은 널리 구현되지 않은 것으로 나타납니다. 예를 들어, &quot;private = foo&quot;는 많은 캐시에서 단순히 &quot;private&quot;으로 해석됩니다. 또한 규정 된 비 캐시 양식의 의미가 명확 해졌습니다. ( &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2 절&lt;/a&gt; ) &quot;캐시 없음&quot;응답 지시문의 의미가 명확 해졌습니다. ( &lt;a href=&quot;#section-5.2.2.2&quot;&gt;5.2.2.2 절&lt;/a&gt; ) 만료 헤더 필드 값에 대한 1 년 제한이 제거되었습니다. 대신 합리적인 가치를 사용하는 이유가 제시됩니다. ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;) Pragma 헤더 필드는 이제 이전 버전과의 호환성을 위해서만 정의되었습니다. 미래의 pragma는 더 이상 사용되지 않습니다. ( &lt;a href=&quot;#section-5.4&quot;&gt;5.4 절&lt;/a&gt; ) 경고 헤더 필드의 생성 및 처리와 관련된 일부 요구 사항은 널리 구현되지 않았으므로 완화되었습니다. 또한 경고 헤더 필드는 더 이상 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; 인코딩을 사용 하지 않으며 이러한 측면이 구현되지 않았으므로 여러 언어를 허용하지 않습니다. ( &lt;a href=&quot;#section-5.5&quot;&gt;5.5 절&lt;/a&gt; )이 사양은 캐시 지시문 및 경고 코드 레지스트리를 소개하고 새로운 캐시 지시문에 대한 고려 사항을 정의합니다. ( &lt;a href=&quot;#section-7.1&quot;&gt;7.1 항&lt;/a&gt; 및 &lt;a href=&quot;#section-7.2&quot;&gt;7.2 항&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="69f7236ac3c099aef6887071703596241bc5ffd5" translate="yes" xml:space="preserve">
          <source>The specified HTTPS proxy should be used</source>
          <target state="translated">지정된 HTTPS 프록시를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="53a5be96dd5bb71c6d16a8d35e8c39cbe4374a0d" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server (with the specified SOCK version) should be used</source>
          <target state="translated">지정된 SOCKS 서버 (지정된 SOCK 버전)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="303a58e78e8f8eb268fe6f62c8b7f193b6bc1142" translate="yes" xml:space="preserve">
          <source>The specified SOCKS server should be used</source>
          <target state="translated">지정된 SOCKS 서버를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="68cc27ab7cd860287da7fdc9be46fedaaa277c72" translate="yes" xml:space="preserve">
          <source>The specified proxy should be used</source>
          <target state="translated">지정된 프록시를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="6b8ade5bf013491609fa2a91c4e3f35610d584fc" translate="yes" xml:space="preserve">
          <source>The standardized header:</source>
          <target state="translated">표준화 된 헤더 :</target>
        </trans-unit>
        <trans-unit id="f7bf0204749a2c35928a6f9840f70eb32df13567" translate="yes" xml:space="preserve">
          <source>The start line of an HTTP response, called the &lt;em&gt;status line&lt;/em&gt;, contains the following information:</source>
          <target state="translated">&lt;em&gt;status line&lt;/em&gt; 이라는 HTTP 응답의 시작 줄 에는 다음 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f31c6de41f53a39d348494f7a67a1dcc8252643d" translate="yes" xml:space="preserve">
          <source>The start-line and HTTP headers of the HTTP message are collectively known as the &lt;em&gt;head&lt;/em&gt; of the requests, whereas its payload is known as the &lt;em&gt;body&lt;/em&gt;.</source>
          <target state="translated">HTTP 메시지의 시작 라인 및 HTTP 헤더는 통칭 하여 요청 의 &lt;em&gt;헤드&lt;/em&gt; 라고하며 페이로드는 &lt;em&gt;body&lt;/em&gt; 로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f72d9e6a8a95e3d9c5ddb845c0490a8f4e705e6" translate="yes" xml:space="preserve">
          <source>The status code registry has been updated with the registrations
   below: 

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;  |
   | 101   | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;  |
   | 200   | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;  |
   | 201   | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;  |
   | 202   | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;  |
   | 203   | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;  |
   | 204   | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;  |
   | 205   | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;  |
   | 300   | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;  |
   | 301   | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;  |
   | 302   | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;  |
   | 303   | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;  |
   | 305   | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;  |
   | 306   | (Unused)                      | &lt;a href=&quot;#section-6.4.6&quot;&gt;Section 6.4.6&lt;/a&gt;  |
   | 307   | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;  |
   | 400   | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;  |
   | 402   | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;  |
   | 403   | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;  |
   | 404   | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;  |
   | 405   | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;  |
   | 406   | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;  |
   | 408   | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;  |
   | 409   | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;  |
   | 410   | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;  |
   | 411   | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt; |
   | 413   | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt; |
   | 414   | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt; |
   | 415   | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt; |
   | 417   | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt; |
   | 426   | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt; |
   | 500   | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;  |
   | 501   | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;  |
   | 502   | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;  |
   | 503   | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;  |
   | 504   | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;  |
   | 505   | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;  |
   +-------+-------------------------------+----------------+</source>
          <target state="translated">상태 코드 레지스트리가 아래 등록으로 업데이트되었습니다 : + ------- + ------------------------------- -+ ---------------- + | 가치 | 설명 | 참조 | + ------- + ------------------------------- + --------- ------- + | 100 | 계속 | &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1 절&lt;/a&gt; | | 101 | 스위칭 프로토콜 | &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2 절&lt;/a&gt; | | 200 | 확인 | &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1 절&lt;/a&gt; | | 201 | 작성 | &lt;a href=&quot;#section-6.3.2&quot;&gt;섹션 6.3.2&lt;/a&gt; | | 202 | 허용됨 | &lt;a href=&quot;#section-6.3.3&quot;&gt;섹션 6.3.3&lt;/a&gt; | | 203 | 신뢰할 수없는 정보 | &lt;a href=&quot;#section-6.3.4&quot;&gt;섹션 6.3.4&lt;/a&gt; | | 204 | 내용 없음 |&lt;a href=&quot;#section-6.3.5&quot;&gt;섹션 6.3.5&lt;/a&gt; | | 205 | 내용 재설정 | &lt;a href=&quot;#section-6.3.6&quot;&gt;섹션 6.3.6&lt;/a&gt; | | 300 | 여러 선택 | &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1 절&lt;/a&gt; | | 301 | 영구적으로 움직였다 | &lt;a href=&quot;#section-6.4.2&quot;&gt;섹션 6.4.2&lt;/a&gt; | | 302 | 발견 | &lt;a href=&quot;#section-6.4.3&quot;&gt;섹션 6.4.3&lt;/a&gt; | | 303 | 기타 | &lt;a href=&quot;#section-6.4.4&quot;&gt;섹션 6.4.4&lt;/a&gt; | | 305 | 프록시 사용 | &lt;a href=&quot;#section-6.4.5&quot;&gt;섹션 6.4.5&lt;/a&gt; | | 306 | (미사용) | &lt;a href=&quot;#section-6.4.6&quot;&gt;섹션 6.4.6&lt;/a&gt; | | 307 | 임시 리디렉션 | &lt;a href=&quot;#section-6.4.7&quot;&gt;섹션 6.4.7&lt;/a&gt; | | 400 | 나쁜 요청 | &lt;a href=&quot;#section-6.5.1&quot;&gt;섹션 6.5.1&lt;/a&gt; | | 402 | 지불 필요 | &lt;a href=&quot;#section-6.5.2&quot;&gt;섹션 6.5.2&lt;/a&gt; | | 403 | 금지 | &lt;a href=&quot;#section-6.5.3&quot;&gt;섹션 6.5.3&lt;/a&gt; | | 404 | 찾을 수 없음 | &lt;a href=&quot;#section-6.5.4&quot;&gt;섹션 6.5.4&lt;/a&gt; | | 405 | 허용되지 않는 방법 | &lt;a href=&quot;#section-6.5.5&quot;&gt;섹션 6.5.5&lt;/a&gt; | | 406 | 허용되지 않음 | &lt;a href=&quot;#section-6.5.6&quot;&gt;섹션 6.5.6&lt;/a&gt; | | 408 | 요청 시간 초과 | &lt;a href=&quot;#section-6.5.7&quot;&gt;섹션 6.5.7&lt;/a&gt; | | 409 | 갈등 | &lt;a href=&quot;#section-6.5.8&quot;&gt;섹션 6.5.8&lt;/a&gt; | | 410 | 사라지다 | &lt;a href=&quot;#section-6.5.9&quot;&gt;섹션 6.5.9&lt;/a&gt; | | 411 | 필요한 길이 | &lt;a href=&quot;#section-6.5.10&quot;&gt;섹션 6.5.10&lt;/a&gt; | | 413 | 페이로드가 너무 큼 |&lt;a href=&quot;#section-6.5.11&quot;&gt;섹션 6.5.11&lt;/a&gt; | | 414 | URI가 너무 깁니다 | &lt;a href=&quot;#section-6.5.12&quot;&gt;섹션 6.5.12&lt;/a&gt; | | 415 | 지원되지 않는 미디어 유형 | &lt;a href=&quot;#section-6.5.13&quot;&gt;섹션 6.5.13&lt;/a&gt; | | 417 | 기대 실패 | &lt;a href=&quot;#section-6.5.14&quot;&gt;섹션 6.5.14&lt;/a&gt; | | 426 | 업그레이드 필요 | &lt;a href=&quot;#section-6.5.15&quot;&gt;섹션 6.5.15&lt;/a&gt; | | 500 | 내부 서버 오류 | &lt;a href=&quot;#section-6.6.1&quot;&gt;섹션 6.6.1&lt;/a&gt; | | 501 | 구현되지 않음 | &lt;a href=&quot;#section-6.6.2&quot;&gt;섹션 6.6.2&lt;/a&gt; | | 502 | 나쁜 게이트웨이 | &lt;a href=&quot;#section-6.6.3&quot;&gt;섹션 6.6.3&lt;/a&gt; | | 503 | 사용할 수없는 서비스 | &lt;a href=&quot;#section-6.6.4&quot;&gt;섹션 6.6.4&lt;/a&gt; | | 504 | 게이트웨이 시간 초과 | &lt;a href=&quot;#section-6.6.5&quot;&gt;섹션 6.6.5&lt;/a&gt; | | 505 | 지원되지 않는 HTTP 버전 | &lt;a href=&quot;#section-6.6.6&quot;&gt;섹션 6.6.6&lt;/a&gt; | + ------- + ------------------------------- + --------- ------- +</target>
        </trans-unit>
        <trans-unit id="ed1c1d835f4a51029a15ccecbb039e7a11e9bd7a" translate="yes" xml:space="preserve">
          <source>The status codes listed below are defined in this specification,
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7232]&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7233]&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;Section&amp;nbsp;3 of
   [RFC7235]&lt;/a&gt;.  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]; all other status codes are not
   cacheable by default. 

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | &lt;a href=&quot;#section-6.2.1&quot;&gt;Section 6.2.1&lt;/a&gt;            |
   | 101  | Switching Protocols           | &lt;a href=&quot;#section-6.2.2&quot;&gt;Section 6.2.2&lt;/a&gt;            |
   | 200  | OK                            | &lt;a href=&quot;#section-6.3.1&quot;&gt;Section 6.3.1&lt;/a&gt;            |
   | 201  | Created                       | &lt;a href=&quot;#section-6.3.2&quot;&gt;Section 6.3.2&lt;/a&gt;            |
   | 202  | Accepted                      | &lt;a href=&quot;#section-6.3.3&quot;&gt;Section 6.3.3&lt;/a&gt;            |
   | 203  | Non-Authoritative Information | &lt;a href=&quot;#section-6.3.4&quot;&gt;Section 6.3.4&lt;/a&gt;            |
   | 204  | No Content                    | &lt;a href=&quot;#section-6.3.5&quot;&gt;Section 6.3.5&lt;/a&gt;            |
   | 205  | Reset Content                 | &lt;a href=&quot;#section-6.3.6&quot;&gt;Section 6.3.6&lt;/a&gt;            |
   | 206  | Partial Content               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7233]&lt;/a&gt; |
   | 300  | Multiple Choices              | &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;            |
   | 301  | Moved Permanently             | &lt;a href=&quot;#section-6.4.2&quot;&gt;Section 6.4.2&lt;/a&gt;            |
   | 302  | Found                         | &lt;a href=&quot;#section-6.4.3&quot;&gt;Section 6.4.3&lt;/a&gt;            |
   | 303  | See Other                     | &lt;a href=&quot;#section-6.4.4&quot;&gt;Section 6.4.4&lt;/a&gt;            |
   | 304  | Not Modified                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt; |
   | 305  | Use Proxy                     | &lt;a href=&quot;#section-6.4.5&quot;&gt;Section 6.4.5&lt;/a&gt;            |
   | 307  | Temporary Redirect            | &lt;a href=&quot;#section-6.4.7&quot;&gt;Section 6.4.7&lt;/a&gt;            |
   | 400  | Bad Request                   | &lt;a href=&quot;#section-6.5.1&quot;&gt;Section 6.5.1&lt;/a&gt;            |
   | 401  | Unauthorized                  | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7235]&lt;/a&gt; |
   | 402  | Payment Required              | &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;            |
   | 403  | Forbidden                     | &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;            |
   | 404  | Not Found                     | &lt;a href=&quot;#section-6.5.4&quot;&gt;Section 6.5.4&lt;/a&gt;            |
   | 405  | Method Not Allowed            | &lt;a href=&quot;#section-6.5.5&quot;&gt;Section 6.5.5&lt;/a&gt;            |
   | 406  | Not Acceptable                | &lt;a href=&quot;#section-6.5.6&quot;&gt;Section 6.5.6&lt;/a&gt;            |
   | 407  | Proxy Authentication Required | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7235]&lt;/a&gt; |
   | 408  | Request Timeout               | &lt;a href=&quot;#section-6.5.7&quot;&gt;Section 6.5.7&lt;/a&gt;            |
   | 409  | Conflict                      | &lt;a href=&quot;#section-6.5.8&quot;&gt;Section 6.5.8&lt;/a&gt;            |
   | 410  | Gone                          | &lt;a href=&quot;#section-6.5.9&quot;&gt;Section 6.5.9&lt;/a&gt;            |
   | 411  | Length Required               | &lt;a href=&quot;#section-6.5.10&quot;&gt;Section 6.5.10&lt;/a&gt;           |
   | 412  | Precondition Failed           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7232]&lt;/a&gt; |
   | 413  | Payload Too Large             | &lt;a href=&quot;#section-6.5.11&quot;&gt;Section 6.5.11&lt;/a&gt;           |
   | 414  | URI Too Long                  | &lt;a href=&quot;#section-6.5.12&quot;&gt;Section 6.5.12&lt;/a&gt;           |
   | 415  | Unsupported Media Type        | &lt;a href=&quot;#section-6.5.13&quot;&gt;Section 6.5.13&lt;/a&gt;           |
   | 416  | Range Not Satisfiable         | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7233]&lt;/a&gt; |
   | 417  | Expectation Failed            | &lt;a href=&quot;#section-6.5.14&quot;&gt;Section 6.5.14&lt;/a&gt;           |
   | 426  | Upgrade Required              | &lt;a href=&quot;#section-6.5.15&quot;&gt;Section 6.5.15&lt;/a&gt;           |
   | 500  | Internal Server Error         | &lt;a href=&quot;#section-6.6.1&quot;&gt;Section 6.6.1&lt;/a&gt;            |
   | 501  | Not Implemented               | &lt;a href=&quot;#section-6.6.2&quot;&gt;Section 6.6.2&lt;/a&gt;            |
   | 502  | Bad Gateway                   | &lt;a href=&quot;#section-6.6.3&quot;&gt;Section 6.6.3&lt;/a&gt;            |
   | 503  | Service Unavailable           | &lt;a href=&quot;#section-6.6.4&quot;&gt;Section 6.6.4&lt;/a&gt;            |
   | 504  | Gateway Timeout               | &lt;a href=&quot;#section-6.6.5&quot;&gt;Section 6.6.5&lt;/a&gt;            |
   | 505  | HTTP Version Not Supported    | &lt;a href=&quot;#section-6.6.6&quot;&gt;Section 6.6.6&lt;/a&gt;            |
   +------+-------------------------------+--------------------------+ 

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; for
   details.</source>
          <target state="translated">아래 나열된 상태 코드는 본 명세서에 정의되어있다 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4&quot;&gt;[RFC7232] 제 4&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4&quot;&gt;[RFC7233] 제 4&lt;/a&gt; , 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3&quot;&gt;[RFC7235] 제 3&lt;/a&gt; . 여기에 나열된 이유 문구는 권장 사항 일뿐입니다. 프로토콜에 영향을주지 않으면 서 해당하는 문구로 대체 할 수 있습니다. 기본적으로 캐시 가능한 것으로 정의 된 상태 코드가있는 응답 (예 :이 사양에서 200, 203, 204, 206, 300, 301, 404, 405, 410, 414 및 501)은 휴리스틱 만료가있는 캐시에서 재사용 할 수 있습니다. 그렇지 않으면 메소드 정의 또는 명시 적 캐시 제어에 의해 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;표시됨&lt;/a&gt; [ RFC7234]; 다른 모든 상태 코드는 기본적으로 캐시 할 수 없습니다. + ------ + ------------------------------- + ---------- ---------------- + | 코드 | 이유 문구 | 정의 ... | + ------ + ------------------------------- + ---------- ---------------- + | 100 | 계속 | &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1 절&lt;/a&gt; | | 101 | 스위칭 프로토콜 | &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2 절&lt;/a&gt; | | 200 | 확인 | &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1 절&lt;/a&gt; | | 201 | 작성 | &lt;a href=&quot;#section-6.3.2&quot;&gt;섹션 6.3.2&lt;/a&gt; | | 202 | 허용됨 | &lt;a href=&quot;#section-6.3.3&quot;&gt;섹션 6.3.3&lt;/a&gt; | | 203 | 신뢰할 수없는 정보 | &lt;a href=&quot;#section-6.3.4&quot;&gt;섹션 6.3.4&lt;/a&gt; | | 204 | 내용 없음 | &lt;a href=&quot;#section-6.3.5&quot;&gt;섹션 6.3.5&lt;/a&gt; | | 205 | 내용 재설정 | &lt;a href=&quot;#section-6.3.6&quot;&gt;섹션 6.3.6&lt;/a&gt; | | 206 | 부분 내용 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;[RFC7233] 섹션 4.1&lt;/a&gt; | | 300 | 여러 선택 | &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1 절&lt;/a&gt; | | 301 | 영구적으로 움직였다 | &lt;a href=&quot;#section-6.4.2&quot;&gt;섹션 6.4.2&lt;/a&gt; | | 302 | 발견 | &lt;a href=&quot;#section-6.4.3&quot;&gt;섹션 6.4.3&lt;/a&gt; | | 303 | 기타 | &lt;a href=&quot;#section-6.4.4&quot;&gt;섹션 6.4.4&lt;/a&gt; | | 304 | 수정되지 않음 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232] 섹션 4.1&lt;/a&gt; | | 305 | 프록시 사용 |&lt;a href=&quot;#section-6.4.5&quot;&gt;섹션 6.4.5&lt;/a&gt; | | 307 | 임시 리디렉션 | &lt;a href=&quot;#section-6.4.7&quot;&gt;섹션 6.4.7&lt;/a&gt; | | 400 | 나쁜 요청 | &lt;a href=&quot;#section-6.5.1&quot;&gt;섹션 6.5.1&lt;/a&gt; | | 401 | 무단 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;[RFC7235] 섹션 3.1&lt;/a&gt; | | 402 | 지불 필요 | &lt;a href=&quot;#section-6.5.2&quot;&gt;섹션 6.5.2&lt;/a&gt; | | 403 | 금지 | &lt;a href=&quot;#section-6.5.3&quot;&gt;섹션 6.5.3&lt;/a&gt; | | 404 | 찾을 수 없음 | &lt;a href=&quot;#section-6.5.4&quot;&gt;섹션 6.5.4&lt;/a&gt; | | 405 | 허용되지 않는 방법 | &lt;a href=&quot;#section-6.5.5&quot;&gt;섹션 6.5.5&lt;/a&gt; | | 406 | 허용되지 않음 | &lt;a href=&quot;#section-6.5.6&quot;&gt;섹션 6.5.6&lt;/a&gt; | | 407 | 프록시 인증 필요 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;[RFC7235] 섹션 3.2&lt;/a&gt; | | 408 | 요청 시간 초과 | &lt;a href=&quot;#section-6.5.7&quot;&gt;섹션 6.5.7&lt;/a&gt; | | 409 | 갈등 | &lt;a href=&quot;#section-6.5.8&quot;&gt;섹션 6.5.8&lt;/a&gt; | | 410 | 사라지다 | &lt;a href=&quot;#section-6.5.9&quot;&gt;섹션 6.5.9&lt;/a&gt; | | 411 | 필요한 길이 | &lt;a href=&quot;#section-6.5.10&quot;&gt;섹션 6.5.10&lt;/a&gt; | | 412 | 전제 조건 실패 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;[RFC7232] 4.2 절&lt;/a&gt; | | 413 | 페이로드가 너무 큼 | &lt;a href=&quot;#section-6.5.11&quot;&gt;섹션 6.5.11&lt;/a&gt; | | 414 | URI가 너무 깁니다 | &lt;a href=&quot;#section-6.5.12&quot;&gt;섹션 6.5.12&lt;/a&gt; | | 415 | 지원되지 않는 미디어 유형 |&lt;a href=&quot;#section-6.5.13&quot;&gt;섹션 6.5.13&lt;/a&gt; | | 416 | 범위가 만족스럽지 않음 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;[RFC7233] 4.4 절&lt;/a&gt; | | 417 | 기대 실패 | &lt;a href=&quot;#section-6.5.14&quot;&gt;섹션 6.5.14&lt;/a&gt; | | 426 | 업그레이드 필요 | &lt;a href=&quot;#section-6.5.15&quot;&gt;섹션 6.5.15&lt;/a&gt; | | 500 | 내부 서버 오류 | &lt;a href=&quot;#section-6.6.1&quot;&gt;섹션 6.6.1&lt;/a&gt; | | 501 | 구현되지 않음 | &lt;a href=&quot;#section-6.6.2&quot;&gt;섹션 6.6.2&lt;/a&gt; | | 502 | 나쁜 게이트웨이 | &lt;a href=&quot;#section-6.6.3&quot;&gt;섹션 6.6.3&lt;/a&gt; | | 503 | 사용할 수없는 서비스 | &lt;a href=&quot;#section-6.6.4&quot;&gt;섹션 6.6.4&lt;/a&gt; | | 504 | 게이트웨이 시간 초과 | &lt;a href=&quot;#section-6.6.5&quot;&gt;섹션 6.6.5&lt;/a&gt; | | 505 | 지원되지 않는 HTTP 버전 | &lt;a href=&quot;#section-6.6.6&quot;&gt;섹션 6.6.6&lt;/a&gt; | + ------ + ------------------------------- + ---------- ---------------- +이 목록은 전체 목록이 아니며 다른 사양에 정의 된 확장 상태 코드는 포함되지 않습니다. 상태 코드의 전체 목록은 IANA에서 관리합니다. 자세한 내용 &lt;a href=&quot;#section-8.2&quot;&gt;은 8.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abe4655086702c287f500adc1ea133906ee1151a" translate="yes" xml:space="preserve">
          <source>The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled 

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request</source>
          <target state="translated">status-code 요소는 요청을 이해하고 만족시키려는 시도의 결과를 제공하는 3 자리 정수 코드입니다. HTTP 상태 코드는 확장 가능합니다. HTTP 클라이언트는 등록 된 모든 상태 코드의 의미를 이해할 필요는 없지만 그러한 이해는 분명히 바람직합니다. 그러나 클라이언트는 첫 번째 숫자로 표시되는 모든 상태 코드의 클래스를 이해하고 인식 할 수없는 상태 코드를 해당 클래스의 x00 상태 코드와 동등한 것으로 취급해야합니다. 단, 수신자는 응답을 캐시하지 않아야합니다. 인식 할 수없는 상태 코드 예를 들어, 클라이언트가 인식 할 수없는 상태 코드 471을 수신하면 클라이언트는 요청에 문제가 있다고 가정하고 응답을 400 (잘못된 요청) 상태 코드를 수신 한 것처럼 처리 할 수 ​​있습니다.응답 메시지에는 일반적으로 상태를 설명하는 표현이 포함됩니다. 상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다. o 1xx (정보) : 요청을 수신하고 프로세스를 계속합니다. o 2xx (성공) : 요청을 성공적으로 수신, 이해 및 수락했습니다. o 3xx (리디렉션) : 추가 조치를 취해야합니다. 요청을 완료하려면 4xx (클라이언트 오류) : 요청에 잘못된 구문이 포함되어 있거나 이행 할 수 없습니다. 5xx (서버 오류) : 서버가 명백히 유효한 요청을 수행하지 못했습니다.마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다. o 1xx (정보) : 요청을 수신하여 프로세스를 계속합니다. o 2xx (성공) : 요청을 성공적으로 수신, 이해 및 수락했습니다. o 3xx (리디렉션) : 추가 조치를 취해야합니다. 요청을 완료하려면 4xx (클라이언트 오류) : 요청에 잘못된 구문이 포함되어 있거나 이행 할 수 없습니다. 5xx (서버 오류) : 서버가 명백히 유효한 요청을 수행하지 못했습니다.마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다. o 1xx (정보) : 요청을 수신하고 프로세스를 계속합니다. o 2xx (성공) : 요청을 성공적으로 수신, 이해 및 수락했습니다. o 3xx (리디렉션) : 추가 조치를 취해야합니다. 요청을 완료하려면 4xx (클라이언트 오류) : 요청에 잘못된 구문이 포함되어 있거나 이행 할 수 없습니다. 5xx (서버 오류) : 서버가 명백히 유효한 요청을 수행하지 못했습니다.요청을 완료하려면 추가 조치를 취해야합니다. 4xx (클라이언트 오류) : 요청에 구문이 잘못되었거나 이행 할 수 없습니다. 5xx (서버 오류) : 서버가 명백히 유효한 요청을 이행하지 못했습니다.요청을 완료하려면 추가 조치를 취해야합니다. 4xx (클라이언트 오류) : 요청에 구문이 잘못되었거나 이행 할 수 없습니다. 5xx (서버 오류) : 서버가 명백히 유효한 요청을 이행하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="ea09a27e31ad55afff5e7a2614ea2f6ce9a594b2" translate="yes" xml:space="preserve">
          <source>The string can contain any number of the following building blocks, separated by a semicolon:</source>
          <target state="translated">문자열은 세미콜론으로 구분 된 다음과 같은 구성 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad6aeb189468d6962df260c9530bf2336ac50aef" translate="yes" xml:space="preserve">
          <source>The successful result of a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; is often not a &lt;code&gt;200&lt;/code&gt;&lt;code&gt;OK&lt;/code&gt; but a &lt;a href=&quot;204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;&lt;code&gt;No Content&lt;/code&gt; (or a &lt;a href=&quot;201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Created&lt;/code&gt; when the resource is uploaded for the first time).</source>
          <target state="translated">&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 의 성공적인 결과 는 종종 &lt;code&gt;200&lt;/code&gt; &lt;code&gt;OK&lt;/code&gt; 가 아니라 &lt;a href=&quot;204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; &lt;code&gt;No Content&lt;/code&gt; (또는 &lt;a href=&quot;201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; 은 리소스를 처음 업로드 할 때 &lt;code&gt;Created&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="b7a73c4b6342735091b4f2e7334e43ba0cdd039a" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;Server-Timing&lt;/code&gt; header allows you to communicate metrics in different ways: server metric name only, metric with value, metric with value and description, and metric with description.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 헤더 의 구문을 사용하면 서버 메트릭 이름 만, 값 메트릭, 값 및 설명 메트릭, 설명 메트릭과 같은 다양한 방법으로 메트릭을 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d244dc96c1e69e051bc4e338a9553169a494af1" translate="yes" xml:space="preserve">
          <source>The syntax of the Slug header is defined using the augmented BNF
   syntax defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;:

       LWS      = &amp;lt;defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC2616]&lt;/a&gt;&amp;gt;
       slugtext = %x20-7E | LWS
       Slug     = &quot;Slug&quot; &quot;:&quot; *slugtext

   The field value is the percent-encoded value of the UTF-8 encoding of
   the character sequence to be included (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC3986]&lt;/a&gt;
   for the definition of percent encoding, and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;] for the
   definition of the UTF-8 encoding).

   Implementation note: to produce the field value from a character
   sequence, first encode it using the UTF-8 encoding, then encode all
   octets outside the ranges %20-24 and %26-7E using percent encoding
   (%25 is the ASCII encoding of &quot;%&quot;, thus it needs to be escaped).  To
   consume the field value, first reverse the percent encoding, then run
   the resulting octet sequence through a UTF-8 decoding process.</source>
          <target state="translated">슬러그 헤더의 구문은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]의 섹션 2.1에&lt;/a&gt; 정의 된 증강 BNF 구문을 사용하여 정의됩니다 . LWS = &amp;lt; &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]의 섹션 2.2에&lt;/a&gt; 정의 됨 &amp;gt; slugtext = % x20-7E | LWS Slug = &quot;Slug&quot; &quot;:&quot;* slugtext 필드 값은 포함 할 문자 시퀀스의 UTF-8 인코딩 백분율로 인코딩 된 값입니다 ( % 인코딩의 정의에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.1&quot;&gt;[RFC3986]의 2.1 절&lt;/a&gt; 참조 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC3629&lt;/a&gt;UTF-8 인코딩의 정의에 대해서는]를 참조하십시오. 구현 참고 사항 : 문자 시퀀스에서 필드 값을 생성하려면 먼저 UTF-8 인코딩을 사용하여 필드 값을 인코딩 한 다음 백분율 인코딩을 사용하여 % 20-24 및 % 26-7E 범위 밖의 모든 옥텟을 인코딩하십시오 (% 25는 &quot;%&quot;이므로 이스케이프해야합니다. 필드 값을 사용하려면 먼저 퍼센트 인코딩을 뒤집은 다음 UTF-8 디코딩 프로세스를 통해 결과 옥텟 시퀀스를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ea12de6efa63fc587d1f14a9b9c6eb9b2ffc6913" translate="yes" xml:space="preserve">
          <source>The table below describes the behavior that occurs when a lock
   request is made on a resource.

     +--------------------------+----------------+-------------------+
     | Current State            | Shared Lock OK | Exclusive Lock OK |
     +--------------------------+----------------+-------------------+
     | None                     | True           | True              |
     | Shared Lock              | True           | False             |
     | Exclusive Lock           | False          | False*            |
     +--------------------------+----------------+-------------------+

   Legend: True = lock may be granted.  False = lock MUST NOT be
   granted. *=It is illegal for a principal to request the same lock
   twice.

   The current lock state of a resource is given in the leftmost column,
   and lock requests are listed in the first row.  The intersection of a
   row and column gives the result of a lock request.  For example, if a
   shared lock is held on a resource, and an exclusive lock is
   requested, the table entry is &quot;false&quot;, indicating that the lock must
   not be granted.</source>
          <target state="translated">아래 표는 리소스에 대한 잠금 요청이있을 때 발생하는 동작을 설명합니다. + -------------------------- + ---------------- + ----- -------------- + | 현재 상태 | 공유 잠금 OK | 독점 잠금 OK | + -------------------------- + ---------------- + ----- -------------- + | 없음 | 참 | 참 | | 공유 잠금 | 참 | 거짓 | | 독점 잠금 | 거짓 | 거짓 * | + -------------------------- + ---------------- + ----- -------------- + 범례 : True = 잠금이 부여 될 수 있습니다. False = 잠금을 부여해서는 안됩니다. * = 주체가 동일한 잠금을 두 번 요청하는 것은 불법입니다. 리소스의 현재 잠금 상태는 가장 왼쪽 열에 있습니다.잠금 요청은 첫 번째 행에 나열됩니다. 행과 열의 교차는 잠금 요청의 결과를 제공합니다. 예를 들어, 공유 잠금이 자원에 보유되고 독점 잠금이 요청 된 경우 테이블 항목은 &quot;false&quot;이며 잠금을 부여해서는 안됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b94957031bbb851c3915a1e070dc41a5bc6b1c5f" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;, which nature isn't defined further; it can be a document, a photo, or anything else. Each resource is identified by a Uniform Resource Identifier (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;) used throughout HTTP for identifying resources.</source>
          <target state="translated">HTTP 요청의 대상을 &quot;리소스&quot;라고하며이 특성은 더 이상 정의되지 않습니다. 문서, 사진 또는 다른 것이 될 수 있습니다. 각 자원은 자원 식별 을 위해 HTTP 전체에서 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt; (Uniform Resource Identifier )로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="0027de0398e06b3c16ab5881af95789a5ccae8db" translate="yes" xml:space="preserve">
          <source>The target of an HTTP request is called a &quot;resource&quot;.  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;Section&amp;nbsp;2.7 of [RFC7230]&lt;/a&gt;.

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of
   [RFC7230]&lt;/a&gt;).  When a request is received, the server reconstructs an
   effective request URI for the target resource (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and a few
   request-modifying header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;, the method semantics take
   precedence.</source>
          <target state="translated">HTTP 요청의 대상을 &quot;리소스&quot;라고합니다. HTTP는 리소스의 특성을 제한하지 않습니다. 리소스와 상호 작용하는 데 사용될 수있는 인터페이스 만 정의합니다. 각 자원은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.7&quot;&gt;[RFC7230]의 2.7 절에&lt;/a&gt; 설명 된 바와 같이 URI (Uniform Resource Identifier)로 식별된다 . 클라이언트가 HTTP / 1.1 요청 메시지를 구성 할 때 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 5.3 절)에&lt;/a&gt; 정의 된대로 다양한 형식 중 하나로 대상 URI를 보냅니다 . 요청이 수신되면 서버는 대상 자원에 대한 유효 요청 URI를 재구성합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; ). HTTP의 한 가지 디자인 목표는 요청 시맨틱과 자원 식별을 분리하는 것입니다. 이는 요청 시맨틱을 요청 메소드에 적용하여 가능합니다 (&lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ) 및 몇 가지 요청 수정 헤더 필드 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ). &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1 절&lt;/a&gt; 에서 설명한 것처럼, 메소드 시맨틱과 URI 자체에 의해 내포 된 시맨틱 사이에 충돌이있는 경우 , 메소드 시맨틱이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9418d48752326ff0dff5f0989dac32b59078dac8" translate="yes" xml:space="preserve">
          <source>The text of the error message will be something similar to the following:</source>
          <target state="translated">오류 메시지의 텍스트는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="19c4cdcadd110283f71f254a20c3b6bdf9d892cf" translate="yes" xml:space="preserve">
          <source>The time in seconds the object has been in a proxy cache.</source>
          <target state="translated">오브젝트가 프록시 캐시에있는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="b56b41274f5f4a39f688c4966d1da21de98a88bd" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that a site is only to be accessed using HTTPS.</source>
          <target state="translated">브라우저가 사이트를 HTTPS를 통해서만 액세스해야한다는 것을 기억해야하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="1ab5a5f12646b8f33cf1a6e834273c9a7926c03d" translate="yes" xml:space="preserve">
          <source>The time, in seconds, that the browser should remember that this site is only to be accessed using one of the defined keys.</source>
          <target state="translated">브라우저가이 사이트에 정의 된 키 중 하나만 사용하여 액세스한다는 것을 기억해야하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="42e4cd11bd5edf3670dcbf4e3f786a4428a217a9" translate="yes" xml:space="preserve">
          <source>The total size of the document (or &lt;code&gt;'*'&lt;/code&gt; if unknown).</source>
          <target state="translated">문서의 전체 크기 (또는 알 수없는 경우 &lt;code&gt;'*'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f6969607248ffc4491cc44dae24cf7138a7b4be2" translate="yes" xml:space="preserve">
          <source>The transfer-length of a message is the length of the message-body as
   it appears in the message; that is, after any transfer-codings have
   been applied. When a message-body is included with a message, the
   transfer-length of that body is determined by one of the following
   (in order of precedence):

   1.Any response message which &quot;MUST NOT&quot; include a message-body (such
     as the 1xx, 204, and 304 responses and any response to a HEAD
     request) is always terminated by the first empty line after the
     header fields, regardless of the entity-header fields present in
     the message.

   2.If a Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;) is present and
     has any value other than &quot;identity&quot;, then the transfer-length is
     defined by use of the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;),
     unless the message is terminated by closing the connection.

   3.If a Content-Length header field (&lt;a href=&quot;#section-14.13&quot;&gt;section 14.13&lt;/a&gt;) is present, its
     decimal value in OCTETs represents both the entity-length and the
     transfer-length. The Content-Length header field MUST NOT be sent
     if these two lengths are different (i.e., if a Transfer-Encoding 

     header field is present). If a message is received with both a
     Transfer-Encoding header field and a Content-Length header field,
     the latter MUST be ignored.

   4.If the message uses the media type &quot;multipart/byteranges&quot;, and the
     ransfer-length is not otherwise specified, then this self-
     elimiting media type defines the transfer-length. This media type
     UST NOT be used unless the sender knows that the recipient can arse
     it; the presence in a request of a Range header with ultiple byte-
     range specifiers from a 1.1 client implies that the lient can parse
     multipart/byteranges responses.

       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.

   5.By the server closing the connection. (Closing the connection
     cannot be used to indicate the end of a request body, since that
     would leave no possibility for the server to send back a response.)

   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
   containing a message-body MUST include a valid Content-Length header
   field unless the server is known to be HTTP/1.1 compliant. If a
   request contains a message-body and a Content-Length is not given,
   the server SHOULD respond with 400 (bad request) if it cannot
   determine the length of the message, or with 411 (length required) if
   it wishes to insist on receiving a valid Content-Length.

   All HTTP/1.1 applications that receive entities MUST accept the
   &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), thus allowing this mechanism
   to be used for messages when the message length cannot be determined
   in advance.

   Messages MUST NOT include both a Content-Length header field and a
   non-identity transfer-coding. If the message does include a non-
   identity transfer-coding, the Content-Length MUST be ignored.

   When a Content-Length is given in a message where a message-body is
   allowed, its field value MUST exactly match the number of OCTETs in
   the message-body. HTTP/1.1 user agents MUST notify the user when an
   invalid length is received and detected.</source>
          <target state="translated">메시지의 전송 길이는 메시지에 나타나는 메시지 본문의 길이입니다. 즉, 전송 코딩이 적용된 후입니다. 메시지 본문이 메시지에 포함 된 경우 해당 본문의 전송 길이는 다음 중 하나에 의해 결정됩니다 (우선 순위 순). 1. &quot;MUST NOT&quot;이 메시지 본문을 포함하는 응답 메시지 (예 : 1xx, 204 및 304 응답 및 HEAD 요청에 대한 응답)은 메시지에 존재하는 엔티티 헤더 필드에 관계없이 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료됩니다. 2. Transfer-Encoding 헤더 필드 ( &lt;a href=&quot;#section-14.41&quot;&gt;14.41 절&lt;/a&gt; )가 존재하고 &quot;identity&quot;이외의 다른 값을 갖는 경우 &quot;chunked&quot;를 사용하여 전송 길이가 정의됩니다.전송 코딩 (&lt;a href=&quot;#section-3.6&quot;&gt;&lt;/a&gt;연결을 닫아서 메시지가 종료되지 않는 한, 3.6 절 ). 3. Content-Length 헤더 필드 ( &lt;a href=&quot;#section-14.13&quot;&gt;섹션 14.13)&lt;/a&gt;)이 있으면 OCTET의 10 진수 값은 엔티티 길이와 전송 길이를 모두 나타냅니다. 이 두 길이가 다른 경우 (즉, Transfer-Encoding 헤더 필드가있는 경우) Content-Length 헤더 필드를 보내면 안됩니다. Transfer-Encoding 헤더 필드와 Content-Length 헤더 필드가 모두있는 메시지가 수신되면 후자는 무시해야합니다. 메시지가 매체 유형 &quot;multipart / byteranges&quot;를 사용하고 ransfer-length가 달리 지정되지 않은 경우이 자체 분리 매체 유형은 전송 길이를 정의합니다. 발신자가 수신자가이를 알 수 있다는 사실을 모르면이 매체 유형 UST는 사용되지 않습니다. 1에서 ultiple byte-range 지정자를 가진 Range 헤더 요청의 존재.1 클라이언트는 lient가 multipart / byteranges 응답을 구문 분석 할 수 있음을 나타냅니다. 범위 헤더는 멀티 파트 / 바이트 범위를 이해하지 못하는 1.0 프록시에 의해 전달 될 수 있습니다. 이 경우 서버는이 섹션의 1, 3 또는 5 항목에 정의 된 방법을 사용하여 메시지를 구분해야합니다. 5. 서버가 연결을 닫습니다. (연결을 닫으면 요청 본문의 끝을 나타 내기 위해 서버를 사용할 수 없기 때문에 연결을 닫을 수 없습니다.) HTTP / 1.0 응용 프로그램과의 호환성을 위해 메시지 본문을 포함하는 HTTP / 1.1 요청은 반드시 있어야합니다. 서버가 HTTP / 1.1을 준수하는 것으로 알려진 경우가 아니면 유효한 Content-Length 헤더 필드를 포함하십시오. 요청에 메시지 본문이 포함되어 있고 Content-Length가 제공되지 않은 경우,서버는 메시지 길이를 결정할 수없는 경우 400 (잘못된 요청)으로 응답하거나 유효한 Content-Length 수신을 요구하려면 411 (길이가 필요한)으로 응답해야합니다. 엔터티를받는 모든 HTTP / 1.1 응용 프로그램은 &quot;청크 된&quot;전송 코딩 (&lt;a href=&quot;#section-3.6&quot;&gt;섹션 3.6&lt;/a&gt; ), 따라서 메시지의 길이를 미리 결정할 수 없을 때이 메커니즘이 사용될 수 있도록. 메시지는 Content-Length 헤더 필드와 비 ID 전송 코드를 모두 포함해서는 안됩니다 (MUST NOT). 메시지에 비 아이덴티티 전송 코딩이 포함 된 경우 Content-Length를 무시해야합니다. 메시지 본문이 허용되는 메시지에 Content-Length가 주어지면 필드 값은 메시지 본문의 OCTET 수와 정확히 일치해야합니다. HTTP / 1.1 사용자 에이전트는 유효하지 않은 길이가 수신되어 감지되면 사용자에게 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="38523484ffd68ebb6eb7a5214e3ed27961920f11" translate="yes" xml:space="preserve">
          <source>The two URNs correspond to</source>
          <target state="translated">두 URN은</target>
        </trans-unit>
        <trans-unit id="ff2f97e2406493e9f79fccc71e1be4f7abf32463" translate="yes" xml:space="preserve">
          <source>The unit for ranges are bytes.</source>
          <target state="translated">범위의 단위는 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="b6b0d4dfd9983f94ad3e71c861ccec5e604be4be" translate="yes" xml:space="preserve">
          <source>The unit in which ranges are specified. This is usually &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">범위가 지정된 단위입니다. 일반적으로 &lt;code&gt;bytes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="924b5ee64285daafc6521cbe0d29ade1c8958494" translate="yes" xml:space="preserve">
          <source>The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">사용자가 지정된 시간 내에 너무 많은 요청을 보냈습니다 ( &quot;속도 제한&quot;).</target>
        </trans-unit>
        <trans-unit id="9ffdd05f199fbe940ba584fa8cdea1148a035d9b" translate="yes" xml:space="preserve">
          <source>The user prefers not to be tracked on the target site.</source>
          <target state="translated">사용자는 대상 사이트에서 추적하지 않는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="d71574f65fb3da08e3baf6b4a99a03c89f5a3b91" translate="yes" xml:space="preserve">
          <source>The user prefers to allow tracking on the target site.</source>
          <target state="translated">사용자는 대상 사이트에서 추적을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="91276b37149e1af5a39e9acf956fda9d8e55baac" translate="yes" xml:space="preserve">
          <source>The user requests an illegal resource, such as a web page censored by a government.</source>
          <target state="translated">사용자가 정부가 검열 한 웹 페이지와 같은 불법 자원을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="9b9325341a547bb5d13f713ae99d4c608b9f2504" translate="yes" xml:space="preserve">
          <source>The user's DNT preference can also be read from JavaScript using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt;&lt;code&gt;Navigator.doNotTrack&lt;/code&gt;&lt;/a&gt; property:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/doNotTrack&quot;&gt; &lt;code&gt;Navigator.doNotTrack&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 JavaScript에서 사용자의 DNT 환경 설정을 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e6eca9e7b97463080612be2b9d7493bcb1e1c94" translate="yes" xml:space="preserve">
          <source>The username and the password are combined with a colon (&lt;code&gt;aladdin:opensesame&lt;/code&gt;).</source>
          <target state="translated">사용자 이름과 비밀번호는 콜론 ( &lt;code&gt;aladdin:opensesame&lt;/code&gt; ) 과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7e7dde22649be5d5f9982b5b058ad7e12b419de" translate="yes" xml:space="preserve">
          <source>The value of a property is always a (well-formed) XML fragment.

   XML has been chosen because it is a flexible, self-describing,
   structured data format that supports rich schema definitions, and
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by
   adding elements.  Clients will not break when they encounter
   extensions because they will still have the data specified in the
   original schema and MUST ignore elements they do not understand. 

   XML's support for multiple character sets allows any human-readable
   property to be encoded and read in a character set familiar to the
   user.  XML's support for multiple human languages, using the &quot;xml:
   lang&quot; attribute, handles cases where the same character set is
   employed by multiple human languages.  Note that xml:lang scope is
   recursive, so an xml:lang attribute on any element containing a
   property name element applies to the property value unless it has
   been overridden by a more locally scoped attribute.  Note that a
   property only has one value, in one language (or language MAY be left
   undefined); a property does not have multiple values in different
   languages or a single value in multiple languages.

   A property is always represented with an XML element consisting of
   the property name, called the &quot;property name element&quot;.  The simplest
   example is an empty property, which is different from a property that
   does not exist:

      &amp;lt;R:title xmlns:R=&quot;http://www.example.com/ns/&quot;&amp;gt;&amp;lt;/R:title&amp;gt;

   The value of the property appears inside the property name element.
   The value may be any kind of well-formed XML content, including both
   text-only and mixed content.  Servers MUST preserve the following XML
   Information Items (using the terminology from [&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]) in
   storage and transmission of dead properties:

   For the property name Element Information Item itself:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;] named &quot;xml:lang&quot; or any such attribute in scope

      [&lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt;] of type element or character

   On all Element Information Items in the property value:

      [namespace name]

      [local name]

      [&lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt;]

      [&lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;] of type element or character 

   On Attribute Information Items in the property value:

      [namespace name]

      [local name]

      [normalized value]

   On Character Information Items in the property value:

      [character code]

   Since prefixes are used in some XML vocabularies (XPath and XML
   Schema, for example), servers SHOULD preserve, for any Information
   Item in the value:

      [&lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt;]

   XML Infoset attributes not listed above MAY be preserved by the
   server, but clients MUST NOT rely on them being preserved.  The above
   rules would also apply by default to live properties, unless defined
   otherwise.

   Servers MUST ignore the XML attribute xml:space if present and never
   use it to change whitespace handling.  Whitespace in property values
   is significant.</source>
          <target state="translated">속성 값은 항상 (잘 구성된) XML 조각입니다. XML은 다양한 스키마 정의를 지원하는 유연한 자체 설명 구조화 된 데이터 형식이며 여러 문자 집합을 지원하기 때문에 선택되었습니다. XML의 자체 설명 특성을 통해 요소를 추가하여 모든 속성 값을 확장 할 수 있습니다. 클라이언트는 원래 스키마에 데이터가 지정되어 있고 이해하지 못하는 요소를 무시해야하기 때문에 확장이 발생하더라도 중단되지 않습니다. 다중 문자 집합에 대한 XML의 지원을 통해 사람이 읽을 수있는 속성을 사용자에게 익숙한 문자 집합으로 인코딩하고 읽을 수 있습니다. &quot;xml : lang&quot;속성을 사용하여 여러 사람 언어에 대한 XML 지원여러 사람의 언어로 동일한 문자 집합을 사용하는 경우를 처리합니다. xml : lang 범위는 재귀 적이므로 속성 이름 요소를 포함하는 모든 요소의 xml : lang 속성은 로컬 범위가 더 지정된 속성으로 재정의되지 않는 한 속성 값에 적용됩니다. 속성은 하나의 언어에서 하나의 값만 갖습니다 (또는 언어는 정의되지 않은 채로있을 수 있음). 속성에 다른 언어의 여러 값이 없거나 여러 언어의 단일 값이 없습니다. 속성은 항상 &quot;속성 이름 요소&quot;라는 속성 이름으로 구성된 XML 요소로 표현됩니다. 가장 간단한 예는 존재하지 않는 속성과 다른 빈 속성입니다. &amp;lt;R : title xmlns : R = &quot;http://www.example.com/ns/&quot;&amp;gt; &amp;lt;/ R : title&amp;gt;속성 값은 속성 이름 요소 안에 나타납니다. 이 값은 텍스트 전용 컨텐츠와 혼합 컨텐츠를 포함하여 모든 유형의 올바른 XML 컨텐츠 일 수 있습니다. 서버는 다음 XML 정보 항목을 보존해야합니다 ([&lt;a href=&quot;#ref-REC-XML-INFOSET&quot;&gt;사용하지 않는&lt;/a&gt; 속성의 저장 및 전송에서 REC-XML-INFOSET ]) : 속성 이름 요소 정보 항목 자체 : [namespace name] [local name] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt; ] &quot;xml : lang&quot;또는 [ &lt;a id=&quot;ref-children&quot; name=&quot;ref-children&quot;&gt;children&lt;/a&gt; ] 범위의 해당 속성 element 또는 character 유형의 모든 요소 정보 속성 값의 항목 : [namespace name] [local name] [ &lt;a id=&quot;ref-attributes&quot; name=&quot;ref-attributes&quot;&gt;attributes&lt;/a&gt; ] [ &lt;a href=&quot;#ref-children&quot;&gt;children&lt;/a&gt;요소 또는 문자 유형] 속성 값의 속성 정보 항목 속성 값 : [namespace name] [local name] [정규화 된 값] 속성 값의 속성 정보 항목 : [character code] 일부 XML 어휘에서 접두어가 사용되므로 (XPath 예를 들어 XML 스키마는 서버가 값의 모든 정보 항목에 대해 보존해야합니다. [ &lt;a id=&quot;ref-prefix&quot; name=&quot;ref-prefix&quot;&gt;prefix&lt;/a&gt; ] 위에 나열되지 않은 XML Infoset 속성은 서버에 의해 보존 될 수 있지만 클라이언트는 보존되는 것에 의존해서는 안됩니다. 달리 정의되지 않는 한 위의 규칙은 기본적으로 라이브 속성에도 적용됩니다. 서버는 반드시 XML 속성 xml : space를 무시하고 공백 처리를 변경하는 데 절대 사용하지 않아야합니다. 속성 값의 공백이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="fb3e4816a344b23838df3c23c4b5bab0b9342359" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; and &lt;code&gt;'src'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">값은 &lt;code&gt;*&lt;/code&gt; (모든 기원에 대해 사용 가능) 또는 &lt;code&gt;'none'&lt;/code&gt; 동안 (모든 기원에 대한 비활성화) 만 단독으로 사용 할 수 없습니다 &lt;code&gt;'self'&lt;/code&gt; 와 &lt;code&gt;'src'&lt;/code&gt; 하나 또는 그 이상의 기원과 함께 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="f91edc1b64b95c9c888baf6cb011efedf5d401fa" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;*&lt;/code&gt; (enable for all origins) or &lt;code&gt;'none'&lt;/code&gt; (disable for all origins) may only be used alone, while &lt;code&gt;'self'&lt;/code&gt; may be used with one or more origins.</source>
          <target state="translated">값은 &lt;code&gt;*&lt;/code&gt; (모든 기원에 대해 사용 가능) 또는 &lt;code&gt;'none'&lt;/code&gt; 동안 (모든 기원에 대한 비활성화) 만 단독으로 사용 할 수 없습니다 &lt;code&gt;'self'&lt;/code&gt; 하나 이상의 기원과 함께 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="dcb79e8e805e8e88b9627449d36415ee11787dcd" translate="yes" xml:space="preserve">
          <source>The version numbers are not relevant. Avoid inferring materials based on these.</source>
          <target state="translated">버전 번호는 관련이 없습니다. 이를 바탕으로 자료를 유추하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c896f8683d1b38332492f9add5b7e8036c2af733" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol they follow.</source>
          <target state="translated">그들이 따르는 HTTP 프로토콜의 버전.</target>
        </trans-unit>
        <trans-unit id="af0975667c912879263ed1a3127961e483e13536" translate="yes" xml:space="preserve">
          <source>The version of the HTTP protocol.</source>
          <target state="translated">HTTP 프로토콜의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="18e8cb1bbc1cc055f8280b649b640d1c2817543a" translate="yes" xml:space="preserve">
          <source>The version of the protocol used, such as &quot;1.1&quot;.</source>
          <target state="translated">사용 된 프로토콜 버전 (예 : &quot;1.1&quot;)</target>
        </trans-unit>
        <trans-unit id="8a2eeda1fd5d692f44f72233f1d8f895ceec9038" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action, besides presenting the warning to the
   user.</source>
          <target state="translated">경고 텍스트는 사람에게 제공되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 사용자에게 경고를 표시하는 것 외에 자동 조치를 취해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="15cc2f59f7cbc4d7458f6cc67c3db06644c699c3" translate="yes" xml:space="preserve">
          <source>The warning text can include arbitrary information to be presented to
   a human user or logged.  A system receiving this warning MUST NOT
   take any automated action.</source>
          <target state="translated">경고 텍스트는 사람에게 제공되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 자동 조치를 취해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5141799507b06d7b06feb80a1395a0473365c760" translate="yes" xml:space="preserve">
          <source>The web provides functionality and APIs that may have privacy or security risks if abused. In some cases, you may wish to strictly limit how such functionality is used on a website. There are policy-controlled features to allow functionality to be enabled/disabled for specific origins or frames within a website. Where available, the feature integrates with the Permissions API, or feature-specific mechanisms to check if the feature is available.</source>
          <target state="translated">웹은 악용 될 경우 개인 정보 보호 또는 보안 위험이있을 수있는 기능 및 API를 제공합니다. 경우에 따라 웹 사이트에서 이러한 기능이 사용되는 방식을 엄격하게 제한 할 수 있습니다. 웹 사이트 내 특정 출처 또는 프레임에 대해 기능을 활성화 / 비활성화 할 수있는 정책 제어 기능이 있습니다. 사용 가능한 경우이 기능은 권한 API 또는 기능별 메커니즘과 통합되어 기능이 사용 가능한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7dfe76bf0e6f8f40957fd161579016ac421163fe" translate="yes" xml:space="preserve">
          <source>The wildcard value (*) that is mentioned in the latest specification, is not yet implemented in browsers:</source>
          <target state="translated">최신 사양에서 언급 된 와일드 카드 값 (*)은 아직 브라우저에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1efbe0911ef1776423c120227469a104642f0bff" translate="yes" xml:space="preserve">
          <source>The&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt; HTML5 boilerplate project&lt;/a&gt; has an example on &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;how to configure an Apache server to redirect one domain to the other&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;HTML5의 상용구 프로젝트&lt;/a&gt; 에 대한 예제가 &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258&quot;&gt;다른 하나 개의 도메인을 리디렉션 아파치 서버를 구성하는 방법을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8f25ce63c5964fb8abf78f765646524df92d04" translate="yes" xml:space="preserve">
          <source>Then include an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">그런 다음 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 요소 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; 속성을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a105d13d54e1c2eb5dcd554ae6b632346f6c862" translate="yes" xml:space="preserve">
          <source>Then the client could remember that the JSON version is available at that particular URL, skipping content negotation the next time it requests that document.</source>
          <target state="translated">그런 다음 클라이언트는 특정 URL에서 JSON 버전을 사용할 수 있음을 기억하여 다음 번에 해당 문서를 요청할 때 컨텐츠 협상을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="c166069763014ce7a3cf04a150e6d98bc4aa9d06" translate="yes" xml:space="preserve">
          <source>Then you need to set up your server to receive the reports; it can store or process them in whatever manner you feel is appropriate.</source>
          <target state="translated">그런 다음 보고서를 받도록 서버를 설정해야합니다. 적절하다고 생각하는 방식으로 저장하거나 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="19356494f1c284767cfe46395570ff7af7ec9025" translate="yes" xml:space="preserve">
          <source>There are a few header fields which have general applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. These header fields apply only to the 

   message being transmitted.

       general-header = Cache-Control            ; &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;
                      | Connection               ; &lt;a href=&quot;#section-14.10&quot;&gt;Section 14.10&lt;/a&gt;
                      | Date                     ; &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;
                      | Pragma                   ; &lt;a href=&quot;#section-14.32&quot;&gt;Section 14.32&lt;/a&gt;
                      | Trailer                  ; &lt;a href=&quot;#section-14.40&quot;&gt;Section 14.40&lt;/a&gt;
                      | Transfer-Encoding        ; &lt;a href=&quot;#section-14.41&quot;&gt;Section 14.41&lt;/a&gt;
                      | Upgrade                  ; &lt;a href=&quot;#section-14.42&quot;&gt;Section 14.42&lt;/a&gt;
                      | Via                      ; &lt;a href=&quot;#section-14.45&quot;&gt;Section 14.45&lt;/a&gt;
                      | Warning                  ; &lt;a href=&quot;#section-14.46&quot;&gt;Section 14.46&lt;/a&gt;

   General-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given the semantics of general
   header fields if all parties in the communication recognize them to
   be general-header fields. Unrecognized header fields are treated as
   entity-header fields.</source>
          <target state="translated">요청 및 응답 메시지 모두에 적용 할 수 있지만 전송되는 엔티티에는 적용되지 않는 몇 가지 헤더 필드가 있습니다. 이 헤더 필드는 전송중인 메시지에만 적용됩니다. 일반 헤더 = 캐시 제어; &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; | 연결; &lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10&lt;/a&gt; | 데이트 ; &lt;a href=&quot;#section-14.18&quot;&gt;섹션 14.18&lt;/a&gt; | 프라 그마; &lt;a href=&quot;#section-14.32&quot;&gt;섹션 14.32&lt;/a&gt; | 트레일러; &lt;a href=&quot;#section-14.40&quot;&gt;섹션 14.40&lt;/a&gt; | 전송 인코딩; &lt;a href=&quot;#section-14.41&quot;&gt;섹션 14.41&lt;/a&gt; | 업그레이드 ;&lt;a href=&quot;#section-14.42&quot;&gt;섹션 14.42&lt;/a&gt; | 경유; &lt;a href=&quot;#section-14.45&quot;&gt;섹션 14.45&lt;/a&gt; | 경고; &lt;a href=&quot;#section-14.46&quot;&gt;섹션 14.46&lt;/a&gt; 일반 헤더 필드 이름은 프로토콜 버전의 변경과 결합해서 만 확실하게 확장 될 수 있습니다. 그러나 통신의 모든 당사자가 일반 헤더 필드로 인식하는 경우 새 헤더 필드 또는 실험 헤더 필드에 일반 헤더 필드의 의미가 부여 될 수 있습니다. 인식 할 수없는 헤더 필드는 엔티티 헤더 필드로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd54b5762f67dada954e548e046b34d36650e6c" translate="yes" xml:space="preserve">
          <source>There are a few rare conditions when this might occur:</source>
          <target state="translated">이러한 상황이 발생할 수있는 몇 가지 드문 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d68958166491fcc8ea9c6532f3f7c7286929a632" translate="yes" xml:space="preserve">
          <source>There are certain aspects of the HTTP Authentication Framework that
   put constraints on how new authentication schemes can work:

   o  HTTP authentication is presumed to be stateless: all of the
      information necessary to authenticate a request MUST be provided
      in the request, rather than be dependent on the server remembering
      prior requests.  Authentication based on, or bound to, the
      underlying connection is outside the scope of this specification
      and inherently flawed unless steps are taken to ensure that the
      connection cannot be used by any party other than the
      authenticated user (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7230]&lt;/a&gt;).

   o  The authentication parameter &quot;realm&quot; is reserved for defining
      protection spaces as described in &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;.  New schemes MUST
      NOT use it in a way incompatible with that definition.

   o  The &quot;token68&quot; notation was introduced for compatibility with
      existing authentication schemes and can only be used once per
      challenge or credential.  Thus, new schemes ought to use the
      auth-param syntax instead, because otherwise future extensions
      will be impossible.

   o  The parsing of challenges and credentials is defined by this
      specification and cannot be modified by new authentication
      schemes.  When the auth-param syntax is used, all parameters ought
      to support both token and quoted-string syntax, and syntactical
      constraints ought to be defined on the field value after parsing
      (i.e., quoted-string processing).  This is necessary so that
      recipients can use a generic parser that applies to all
      authentication schemes.

      Note: The fact that the value syntax for the &quot;realm&quot; parameter is
      restricted to quoted-string was a bad design choice not to be
      repeated for new parameters.

   o  Definitions of new schemes ought to define the treatment of
      unknown extension parameters.  In general, a &quot;must-ignore&quot; rule is
      preferable to a &quot;must-understand&quot; rule, because otherwise it will
      be hard to introduce new parameters in the presence of legacy
      recipients.  Furthermore, it's good to describe the policy for
      defining new parameters (such as &quot;update the specification&quot; or
      &quot;use this registry&quot;).

   o  Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using WWW-Authenticate),
      and/or proxy authentication (i.e., using Proxy-Authenticate). 

   o  The credentials carried in an Authorization header field are
      specific to the user agent and, therefore, have the same effect on
      HTTP caches as the &quot;private&quot; Cache-Control response directive
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;Section&amp;nbsp;5.2.2.6 of [RFC7234]&lt;/a&gt;), within the scope of the request in
      which they appear.

      Therefore, new authentication schemes that choose not to carry
      credentials in the Authorization header field (e.g., using a newly
      defined header field) will need to explicitly disallow caching, by
      mandating the use of either Cache-Control request directives
      (e.g., &quot;no-store&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;Section&amp;nbsp;5.2.1.5 of [RFC7234]&lt;/a&gt;) or response
      directives (e.g., &quot;private&quot;).</source>
          <target state="translated">새로운 인증 체계가 작동하는 방식에 제약을 두는 HTTP 인증 프레임 워크의 특정 측면이 있습니다. o HTTP 인증은 상태가없는 것으로 가정합니다. 요청을 인증하는 데 필요한 모든 정보는 요청에 의존하지 않고 요청에 제공되어야합니다. 이전 요청을 기억하는 서버. 인증 된 사용자 이외의 다른 사람이 연결을 사용할 수 없도록하기위한 단계를 수행하지 않으면 기본 연결에 기반한 인증 또는 기본 연결이 본 사양의 범위를 벗어나며 본질적으로 결함이 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.3&quot;&gt;[RFC7230]의 2.3 절&lt;/a&gt; 참조 ) . o 인증 매개 변수 &quot;realm&quot;은 &lt;a href=&quot;#section-2.2&quot;&gt;섹션 2.2에&lt;/a&gt; 설명 된대로 보호 공간을 정의하기 위해 예약되어 있습니다. 새로운 계획은 해당 정의와 호환되지 않는 방식으로 사용해서는 안됩니다. o &quot;token68&quot;표기법은 기존 인증 체계와의 호환성을 위해 도입되었으며 챌린지 또는 자격 증명 당 한 번만 사용할 수 있습니다. 따라서 새로운 스키마는 auth-param 구문을 대신 사용해야합니다. 그렇지 않으면 향후 확장이 불가능할 것입니다. o 과제 및 자격 증명의 구문 분석은이 사양에 의해 정의되며 새로운 인증 체계로 수정할 수 없습니다. auth-param 구문을 사용하는 경우 모든 매개 변수는 토큰 및 인용 문자열 구문을 모두 지원해야하며 구문 분석 후 구문 값을 필드 값에 정의해야합니다 (즉, 인용 문자열 처리).받는 사람이 모든 인증 체계에 적용되는 일반 파서를 사용할 수 있도록하기 위해 필요합니다. 참고 : &quot;realm&quot;매개 변수의 값 구문이 인용 문자열로 제한된다는 사실은 새로운 매개 변수에 대해 반복하지 않는 나쁜 설계 선택이었습니다. o 새로운 체계의 정의는 알려지지 않은 확장 매개 변수의 처리를 정의해야한다. 일반적으로 &quot;무시해야하는&quot;규칙은 &quot;이해해야합니다&quot;규칙보다 선호됩니다. 그렇지 않으면 레거시받는 사람이있을 경우 새 매개 변수를 도입하기가 어렵습니다. 또한 새 매개 변수 정의 정책 (예 : &quot;사양 업데이트&quot;또는 &quot;이 레지스트리 사용&quot;)을 설명하는 것이 좋습니다.o 인증 체계는 오리진 서버 인증 (WWW 인증 사용) 및 / 또는 프록시 인증 (프록시 인증 사용)에 사용 가능한지 여부를 문서화해야합니다. o Authorization 헤더 필드에 제공된 신임 정보는 사용자 에이전트에 따라 다르므로 &quot;private&quot;Cache-Control 응답 지시문과 동일한 HTTP 캐시에 영향을줍니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.2.6&quot;&gt;&lt;/a&gt;요청 범위 내에서 [RFC7234] 5.2.2.6 절 . 따라서 Authorization 헤더 필드에 자격 증명을 전달하지 않기로 선택한 새로운 인증 체계 (예 : 새로 정의 된 헤더 필드 사용)는 Cache-Control 요청 지시문 (예 : &quot;no- 매장 ', &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2.1.5&quot;&gt;[RFC7234] 섹션 5.2.1.5&lt;/a&gt; ) 또는 응답 지침 (예 : &quot;비공개&quot;).</target>
        </trans-unit>
        <trans-unit id="47def022b2952624e6b7c50d68fc89498c6bcbc8" translate="yes" xml:space="preserve">
          <source>There are different ways to choose which website is &lt;em&gt;canonical&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;표준&lt;/em&gt; 웹 사이트를 선택하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb9fab7f67432c45ef3a01bc4e6955ba9af7ef46" translate="yes" xml:space="preserve">
          <source>There are five major rendering engines: Trident, Gecko, Presto, Blink, and WebKit. As sniffing the rendering engines names is common, a lot of user agents added other rendering names to trigger detection. It is therefore important to pay attention not to trigger false-positives when detecting the rendering engine.</source>
          <target state="translated">Trident, Gecko, Presto, Blink 및 WebKit의 5 가지 주요 렌더링 엔진이 있습니다. 렌더링 엔진 이름을 스니핑하는 것이 일반적이므로 많은 사용자 에이전트가 감지를 트리거하기 위해 다른 렌더링 이름을 추가했습니다. 따라서 렌더링 엔진을 탐지 할 때 오 탐지를 유발하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec7265e037a89a08f26052ad3aa1abd61eeef50e" translate="yes" xml:space="preserve">
          <source>There are no legal or technological requirements for its use, but the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header can be used to signal that a web application should disable either its tracking or cross-site user tracking of an individual user. See the &lt;a href=&quot;headers/dnt&quot;&gt;&lt;code&gt;DNT&lt;/code&gt;&lt;/a&gt; header for more information.</source>
          <target state="translated">사용에 대한 법적 또는 기술적 요구 사항은 없지만 &lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 웹 응용 프로그램이 개별 사용자의 추적 또는 사이트 간 사용자 추적을 비활성화해야 함을 알릴 수 있습니다. 자세한 내용은 &lt;a href=&quot;headers/dnt&quot;&gt; &lt;code&gt;DNT&lt;/code&gt; &lt;/a&gt; 헤더를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8341be3003600a3499c2c6008b5ac1ba78954829" translate="yes" xml:space="preserve">
          <source>There are numerous request headers available. They can be divided in several groups:</source>
          <target state="translated">사용 가능한 수많은 요청 헤더가 있습니다. 여러 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e686045e6ac4c90ab4cd236500952ba40ae62b2" translate="yes" xml:space="preserve">
          <source>There are numerous response headers available. These can be divided into several groups:</source>
          <target state="translated">사용 가능한 수많은 응답 헤더가 있습니다. 이들은 여러 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9222fd28dc57a16808d7c19d6bf6f9df7c972ab4" translate="yes" xml:space="preserve">
          <source>There are numerous use cases for redirects, but as performance is impacted with every redirect, their use should be kept to a minimum.</source>
          <target state="translated">리디렉션에 대한 많은 사용 사례가 있지만 모든 리디렉션에서 성능에 영향을 미치므로 사용을 최소화해야합니다.</target>
        </trans-unit>
        <trans-unit id="13f9ecbdd18ed16f602f0ce2e3e411623b20ecea" translate="yes" xml:space="preserve">
          <source>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A &lt;em&gt;shared cache&lt;/em&gt; is a cache that stores responses for reuse by more than one user. A &lt;em&gt;private cache&lt;/em&gt; is dedicated to a single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN, reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and scaling of web sites and web applications.</source>
          <target state="translated">여러 종류의 캐시가 있습니다. 이들은 개인 또는 공유 캐시의 두 가지 주요 범주로 그룹화 할 수 있습니다. &lt;em&gt;공유 캐시는&lt;/em&gt; 캐시 인 하나 이상의 사용자에 의한 재사용을 위해 저장하는 반응. &lt;em&gt;개인 캐시는&lt;/em&gt; 단일 사용자에 전념하고 있습니다. 이 페이지는 주로 브라우저 및 프록시 캐시에 대해 설명하지만 웹 사이트 및 웹 응용 프로그램의 안정성, 성능 및 확장 성을 높이기 위해 웹 서버에 배포되는 게이트웨이 캐시, CDN, 리버스 프록시 캐시 및로드 밸런서도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb582dbfa4a7b1600d7a27acf7bcaf2e2220c793" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features designed to represent functionality that can negatively impact the user experience. These features include:</source>
          <target state="translated">사용자 경험에 부정적인 영향을 줄 수있는 기능을 나타내도록 설계된 여러 정책 제어 기능이 있습니다. 이러한 기능에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5b36e7ddb912239041ca7ab0dc533b4f7149cde8" translate="yes" xml:space="preserve">
          <source>There are several policy-controlled features to help enforce best practices for providing good performance and user experiences.</source>
          <target state="translated">우수한 성능과 사용자 경험을 제공하기위한 모범 사례를 시행하는 데 도움이되는 몇 가지 정책 제어 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3b7153e2634e73590a4cce2b8c456ab59f6363" translate="yes" xml:space="preserve">
          <source>There are several types of redirects and they fall into three categories: permanent, temporary and special redirections.</source>
          <target state="translated">리디렉션에는 여러 유형이 있으며 영구, 임시 및 특수 리디렉션의 세 가지 범주로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f58fdbcbba9bec3b86fd66d8bc7fa26b8fe6f5" translate="yes" xml:space="preserve">
          <source>There are three possible directives for &lt;code&gt;X-Frame-Options&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 에는 세 가지 가능한 지시문이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="617a6e0c426a32391566dd90c1be40e2204860a0" translate="yes" xml:space="preserve">
          <source>There are three relevant statuses, when working with range requests:</source>
          <target state="translated">범위 요청으로 작업 할 때 세 가지 관련 상태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae719b0ddb46afe501f7c4d04161647540a420e" translate="yes" xml:space="preserve">
          <source>There are two common use cases:</source>
          <target state="translated">두 가지 일반적인 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8949bb550cb1be029d6340065449416ee39fb0" translate="yes" xml:space="preserve">
          <source>There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as &quot;weak&quot;. 

   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/&quot;1&quot;  | W/&quot;1&quot;  | no match          | match           |
   | W/&quot;1&quot;  | W/&quot;2&quot;  | no match          | no match        |
   | W/&quot;1&quot;  | &quot;1&quot;    | no match          | match           |
   | &quot;1&quot;    | &quot;1&quot;    | match             | match           |
   +--------+--------+-------------------+-----------------+</source>
          <target state="translated">비교 컨텍스트가 약한 유효성 검증기의 사용을 허용하는지 여부에 따라 두 개의 엔티티 태그 비교 함수가 있습니다. o 강력한 비교 : 두 엔티티 태그가 둘 다 약하지 않고 불투명 태그가 문자별로 일치하면 두 엔티티 태그가 동일합니다. . o 약한 비교 : 두 개의 엔티티 태그는 불투명 태그가 &quot;약한&quot;태그로 지정 되든 상관없이 불투명 태그가 문자별로 일치하는 경우 동일합니다. 아래 예는 엔티티 태그 쌍 세트와 약한 및 강한 비교 함수 결과에 대한 결과를 보여줍니다. + -------- + -------- + --------- ------------ + ----------------- + | ETag 1 | ETag 2 | 강력한 비교 | 약한 비교 | + -------- + -------- + ------------------- + ----------- ------ + | W / &quot;1&quot;| W / &quot;1&quot;| 일치하지 않습니다 | 경기 | | W / &quot;1&quot;| W / &quot;2&quot;| 일치하지 않습니다 | 일치하지 않습니다 | | W / &quot;1&quot;| &quot;1&quot;| 일치하지 않습니다 | 경기 | | &quot;1&quot;| &quot;1&quot;| 경기 | 경기 | + -------- + -------- + ------------------- + ----------- ------ +</target>
        </trans-unit>
        <trans-unit id="db65cf9eb555812887e466f13f1dfba01665198b" translate="yes" xml:space="preserve">
          <source>There are two kinds of collection write locks.  A depth-0 write lock
   on a collection protects the collection properties plus the internal
   member URLs of that one collection, while not protecting the content
   or properties of member resources (if the collection itself has any
   entity bodies, those are also protected).  A depth-infinity write
   lock on a collection provides the same protection on that collection
   and also provides write lock protection on every member resource.

   Expressed otherwise, a write lock of either kind protects any request
   that would create a new resource in a write locked collection, any
   request that would remove an internal member URL of a write locked
   collection, and any request that would change the segment name of any
   internal member.

   Thus, a collection write lock protects all the following actions:

   o  DELETE a collection's direct internal member, 

   o  MOVE an internal member out of the collection,

   o  MOVE an internal member into the collection,

   o  MOVE to rename an internal member within a collection,

   o  COPY an internal member into a collection, and

   o  PUT or MKCOL request that would create a new internal member.

   The collection's lock token is required in addition to the lock token
   on the internal member itself, if it is locked separately.

   In addition, a depth-infinity lock affects all write operations to
   all members of the locked collection.  With a depth-infinity lock,
   the resource identified by the root of the lock is directly locked,
   and all its members are indirectly locked.

   o  Any new resource added as a descendant of a depth-infinity locked
      collection becomes indirectly locked.

   o  Any indirectly locked resource moved out of the locked collection
      into an unlocked collection is thereafter unlocked.

   o  Any indirectly locked resource moved out of a locked source
      collection into a depth-infinity locked target collection remains
      indirectly locked but is now protected by the lock on the target
      collection (the target collection's lock token will thereafter be
      required to make further changes).

   If a depth-infinity write LOCK request is issued to a collection
   containing member URLs identifying resources that are currently
   locked in a manner that conflicts with the new lock (see &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;,
   point 3), the request MUST fail with a 423 (Locked) status code, and
   the response SHOULD contain the 'no-conflicting-lock' precondition.

   If a lock request causes the URL of a resource to be added as an
   internal member URL of a depth-infinity locked collection, then the
   new resource MUST be automatically protected by the lock.  For
   example, if the collection /a/b/ is write locked and the resource /c
   is moved to /a/b/c, then resource /a/b/c will be added to the write
   lock.</source>
          <target state="translated">컬렉션 쓰기 잠금에는 두 가지 종류가 있습니다. 컬렉션의 depth-0 쓰기 잠금은 컬렉션 속성과 해당 컬렉션의 내부 멤버 URL을 보호하는 동시에 컬렉션 리소스의 내용이나 속성은 보호하지 않습니다 (컬렉션 자체에 엔터티 본문이있는 경우에도 보호됨). 컬렉션의 깊이 무한 쓰기 잠금은 해당 컬렉션에 대해 동일한 보호 기능을 제공하며 모든 구성원 리소스에 대한 쓰기 잠금 보호 기능도 제공합니다. 달리 표현하면, 두 종류의 쓰기 잠금은 쓰기 잠금 컬렉션에서 새 리소스를 생성하는 모든 요청, 쓰기 잠금 컬렉션의 내부 멤버 URL을 제거하는 모든 요청 및 세그먼트 이름을 변경하는 모든 요청을 보호합니다. 내부 회원. 그러므로,컬렉션 쓰기 잠금은 다음 작업을 모두 보호합니다. o 컬렉션의 직접 내부 멤버 삭제, o 컬렉션에서 내부 멤버 이동, o 내부 멤버를 컬렉션으로 이동, o 컬렉션 내에서 내부 멤버 이름 바꾸기를위한 이동, o 복사 컬렉션에 대한 내부 멤버 및 o 새 내부 멤버를 작성하는 PUT 또는 MKCOL 요청. 컬렉션의 잠금 토큰은 별도로 잠긴 경우 내부 멤버 자체의 잠금 토큰과 함께 필요합니다. 또한 깊이 무한대 잠금은 잠긴 컬렉션의 모든 멤버에 대한 모든 쓰기 작업에 영향을줍니다. 깊이 무한대 잠금을 사용하면 잠금의 루트로 식별 된 자원이 직접 잠기고 모든 구성원이 간접적으로 잠 깁니다.o 깊이 무한대 잠금 컬렉션의 자손으로 추가 된 모든 새로운 리소스는 간접적으로 잠 깁니다. o 잠긴 컬렉션에서 잠금 해제 된 컬렉션으로 이동 된 간접적으로 잠긴 리소스는 잠금 해제됩니다. o 잠긴 소스 콜렉션에서 깊이 무한대 잠금 대상 콜렉션으로 이동 된 간접적으로 잠긴 자원은 간접적으로 잠긴 상태로 유지되지만 이제 대상 콜렉션의 잠금으로 보호됩니다 (그 후에 대상 콜렉션의 잠금 토큰이 추가 변경을 수행해야 함). 새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조o 잠긴 컬렉션에서 잠금 해제 된 컬렉션으로 이동 된 간접적으로 잠긴 리소스는 잠금 해제됩니다. o 잠긴 소스 콜렉션에서 깊이 무한대 잠금 대상 콜렉션으로 이동 된 간접적으로 잠긴 자원은 간접적으로 잠긴 상태로 유지되지만 이제 대상 콜렉션의 잠금으로 보호됩니다 (그 후에 대상 콜렉션의 잠금 토큰이 추가 변경을 수행해야 함). 새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조o 잠긴 컬렉션에서 잠금 해제 된 컬렉션으로 이동 된 간접적으로 잠긴 리소스는 잠금 해제됩니다. o 잠긴 소스 콜렉션에서 깊이 무한대 잠금 대상 콜렉션으로 이동 된 간접적으로 잠긴 자원은 간접적으로 잠긴 상태로 유지되지만 이제 대상 콜렉션의 잠금으로 보호됩니다 (그 후에 대상 콜렉션의 잠금 토큰이 추가 변경을 수행해야 함). 새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조o 잠긴 소스 콜렉션에서 깊이 무한대 잠금 대상 콜렉션으로 이동 된 간접적으로 잠긴 자원은 간접적으로 잠긴 상태로 유지되지만 이제 대상 콜렉션의 잠금으로 보호됩니다 (그 후에 대상 콜렉션의 잠금 토큰이 추가 변경을 수행해야 함). 새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조o 잠긴 소스 콜렉션에서 깊이 무한대 잠금 대상 콜렉션으로 이동 된 간접적으로 잠긴 자원은 간접적으로 잠긴 상태로 유지되지만 이제 대상 콜렉션의 잠금으로 보호됩니다 (그 후에 대상 콜렉션의 잠금 토큰이 추가 변경을 수행해야 함). 새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조새 잠금과 충돌하는 방식으로 현재 잠겨있는 자원을 식별하는 구성원 URL을 포함하는 콜렉션에 깊이 무한 쓰기 쓰기 잠금 요청이 발행 된 경우 (참조&lt;a href=&quot;#section-6.1&quot;&gt;6.1 절&lt;/a&gt; , 3 절 ), 요청은 반드시 423 (잠금) 상태 코드로 실패해야하며 응답에는 '충돌 방지'전제 조건이 포함되어야한다. 잠금 요청으로 인해 자원의 URL이 깊이 무한 잠금 모음의 내부 구성원 URL로 추가되는 경우 새 자원은 잠금에 의해 자동으로 보호되어야합니다. 예를 들어, / a / b / 콜렉션이 쓰기 잠금 상태이고 / c 자원이 / a / b / c로 이동되면 / ​​a / b / c 자원이 쓰기 잠금에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea804f8e0e63528d1dd87bc0e827f009664d28b8" translate="yes" xml:space="preserve">
          <source>There are two types of HTTP messages, requests and responses, each with its own format.</source>
          <target state="translated">HTTP 메시지에는 요청과 응답의 두 가지 유형이 있으며 각각 고유 한 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fe2bb96492312ef6374bb657cdd41b390e796741" translate="yes" xml:space="preserve">
          <source>There are two types of proxies: &lt;strong&gt;forward proxies&lt;/strong&gt; (or tunnel, or gateway) and&lt;strong&gt; reverse proxies&lt;/strong&gt; (used to control and protect access to a server for load-balancing, authentication, decryption or caching).</source>
          <target state="translated">프록시에는 &lt;strong&gt;순방향 프록시&lt;/strong&gt; (또는 터널 또는 게이트웨이)와 &lt;strong&gt;역방향 프록시&lt;/strong&gt; (로드 균형 조정, 인증, 암호 해독 또는 캐싱을 위해 서버에 대한 액세스를 제어하고 보호하는 데 사용 ) 의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d24023e8db6a2be9a6f15c3bd48794df9fdd2114" translate="yes" xml:space="preserve">
          <source>There is a discussion to add WebP (&lt;code&gt;image/webp&lt;/code&gt;) to this list, but browser vendors are cautious in accepting it.</source>
          <target state="translated">WebP ( &lt;code&gt;image/webp&lt;/code&gt; )를이 목록 에 추가하는 것에 대한 토론 이 있지만 브라우저 공급 업체는이를 신중하게 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">이 요청에 보낼 내용이 없지만 헤더가 유용 할 수 있습니다. 사용자 에이전트는이 자원에 대한 캐시 된 헤더를 새로운 것으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">두 클라이언트 중 하나를 성가 시게하지 않고이 문제를 처리 할 방법이 없습니다. 그러나 손실 된 업데이트 및 경쟁 조건은 피해야합니다. 우리는 예측 가능한 결과를 원하며, 변경 사항이 거부되면 고객에게 알림을받을 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">JavaScript가 현재 자체적으로 정의 할 수 없기 때문에 이미 정의 된 연관 배열이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">클라이언트가 상태 토큰을 제출하려고하지만 상태 토큰이 더 이상 최신 상태가 아니기 때문에 요청이 실패하는 것을 원하지 않는 경우가 있습니다. 이를 수행하는 한 가지 간단한 방법은 다음과 같이 항상 true로 평가되는 것으로 알려진 조건을 포함하는 것입니다. If : (&amp;lt;urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;) lock&amp;gt;) &quot;DAV : no-lock&quot;은 현재 잠금 토큰을 나타내지 않는 것으로 알려져 있습니다. &lt;a href=&quot;#section-6.5&quot;&gt;6.5에&lt;/a&gt; 설명 된 고유성 요구 사항에 따라 서버에서 잠금 토큰을 할당합니다.따라서 &quot;DAV :&quot;체계를 사용할 수 없습니다. 따라서 현재 상태가 아닌 것으로 알려진 상태 토큰에 &quot;Not&quot;을 적용하면 Condition이 항상 true로 평가됩니다. 따라서 전체 If 헤더는 항상 true로 평가되며 잠금 토큰 urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2는 어떤 경우에도 제출됩니다.</target>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">민감한 조치에는 항상 확인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">이러한 HTTP 코드는 재정의되지 않지만 WebDAV 메소드 및 요구 사항에 의해 사용이 다소 확장됩니다. 일반적으로이 문서에 설명 된 경우뿐만 아니라 모든 HTTP 상태 코드를 모든 요청에 ​​응답하여 사용할 수 있습니다. 또한 WebDAV 서버는 300 수준의 리디렉션 응답을 사용하는 것으로 알려져 있으며 초기 상호 운용성 테스트에서 클라이언트가 해당 응답을 볼 수없는 것으로 나타났습니다. 서버가 요청에 대한 응답으로 새 리소스를 생성 한 경우 300 수준 응답을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">이러한 URL은 예입니다 - 사이트가 같은 같은이 원하는 모든 URL 패턴과 다른 파일 형식 봉사 할 수 있었다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;쿼리 문자열 매개 변수를&lt;/a&gt; : &lt;code&gt;/documents/foo?format=json&lt;/code&gt; , &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; , 등등.</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">이러한 URL은 요청이 이루어지기 전에 다시 작성되므로 안전하지 않은 요청이 네트워크에 도달하지 않습니다. 요청 된 리소스를 실제로 HTTPS를 통해 사용할 수없는 경우 HTTP로 폴백하지 않고 요청이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">다음은 다양한 플랫폼에서 다른 Gecko 기반 브라우저의 샘플 UA 문자열입니다. 이 중 다수는 아직 Gecko 2.0에서 출시되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">컨텍스트가 더 나은 정보를 제공하지 않을 때 전송되는 값입니다. 모든 브라우저는 모든 경우를 다루기 위해 &lt;code&gt;*/*&lt;/code&gt; MIME 유형을 추가합니다 . 이는 일반적으로 브라우저의 주소 표시 줄 또는 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 통해 시작된 요청에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">이 네 개의 빌딩 블록은 1990 년 말까지 완료하고, 첫 번째 서버는 이미 8 월 6 일 이른 1991 년으로 CERN의 외부에서 실행 된 &lt;sup&gt;일&lt;/sup&gt; , 팀 버너스 - 리 1991 년 &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;이후&lt;/a&gt; 대중에 &lt;em&gt;alt.hypertext의&lt;/em&gt; 뉴스 그룹은 이제 공식으로 간주됩니다 공개 프로젝트로 월드 와이드 웹의 시작.</target>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">이 기능들은 PAC 파일을 만드는 데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">이 헤더는 단일 전송 레벨 연결에만 의미가 있으며 프록시에 의해 재전송되거나 캐시되지 않아야합니다. 이러한 헤더는 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 일반 헤더를 사용하여 홉별 헤더 만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">이 헤더는 메시지의 최종 수신자에게 전송되어야합니다. 즉, 요청을위한 서버 또는 응답을위한 클라이언트입니다. 중간 프록시는 수정되지 않은 엔드 투 엔드 헤더를 재전송해야하며 캐시는이를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">이러한 참신함은 공동 노력으로 소개 된 것이 아니라 1991-1995 년에 걸친 시도와 접근 방식으로 소개되었습니다 : 서버와 브라우저는 하나의 기능을 추가하여 견인력을 얻었는지 확인했습니다. 많은 상호 운용성 문제가 일반적이었습니다. 1996 년 11 월, 이러한 성가심을 해결하기 위해 일반적인 관행을 설명하는 정보 문서 인 &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; 가 발표되었습니다 . 이것은 HTTP / 1.0의 정의이며, 좁은 의미에서 공식 표준이 아니라는 점이 주목할 만하다.</target>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">이러한 방향 전환은 영원히 지속됩니다. 그들은 원래 URL을 더 이상 사용해서는 안되며 새로운 URL을 선호한다는 것을 의미합니다. 검색 엔진 로봇은 색인에서 리소스에 대한 관련 URL 업데이트를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; CSP 지시문을 통해 Javascript를 허용하지 않으면 이러한 유형의 조작을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">존재합니다. 그들은 방어하기 어렵다. 연구는 계속됩니다. 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">예를 들어 사이트에서 언어 메뉴를 제공하여 서버가 선택한 언어를 극복 할 수있는 방법을 항상 제공해야합니다. 대부분의 사용자 에이전트는 &lt;code&gt;Accept-Language&lt;/code&gt; 헤더에 기본값을 제공하며 사용자 인터페이스 언어에 적합하며 최종 사용자는 인터넷 카페에서와 같이 방법을 모르거나 수행 할 수 없어서 수정하지 않는 경우가 많습니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">타사 쿠키</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 작업자는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">이 &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;교차 출처 공유 표준&lt;/a&gt; 은 다음에 대한 사이트 간 HTTP 요청을 활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">이 경고 코드가 응답에이 경고 코드가 이미 표시되어 있지 않은 경우 내용 코딩, 미디어 유형 변경 또는 표현 데이터 수정과 같은 표현에 변환을 적용하는 경우 반드시이 경고 코드를 프록시에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">이를 통해 &lt;code&gt;X-My-Custom-Header&lt;/code&gt; 및 &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; 헤더가 브라우저에 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">이 부록은 유익한 정보입니다. Relax NG 스키마는이 사양 개정에 정의되지 않은 Atom 프로토콜 네임 스페이스의 요소를 명시 적으로 제외합니다. 이러한 마크 업이 발생하는 Atom 프로토콜 프로세서에 대한 요구 사항 은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 섹션 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 및 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; 에 나와 있습니다. 서비스 문서의 스키마 : #-*-rnc-*-# Atom 프로토콜 네임 스페이스 앱의 RELAX NG 압축 구문 문법 = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 atom = &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http : // www.w3.org/2005/Atom&lt;/a&gt; &quot;네임 스페이스 xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &quot;네임 스페이스 xhtml =&quot; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appService # common : attrs atomURI = text appCommonAttributes = attribute xml : base {atomURI} ?, attribute xml : lang {atomLanguageTag} ?, attribute xml : space {&quot;default &quot;|&quot;preserved &quot;}? , undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute = attribute *-(xml : base | xml : space | xml : lang | local : *) {text} atomLanguageTag = xsd : string {패턴 = &quot;([A-Za-z] {1 , 8} (-[A-Za-z0-9] {1,8}) *)? &quot;} atomDateConstruct = appCommonAttributes, xsd : dateTime # app : service appService = element app : service {appCommonAttributes, (appWorkspace + &amp;amp; extensionElement * )} # app : workspace appWorkspace = 요소 앱 :작업 공간 {appCommonAttributes, (atomTitle &amp;amp; appCollection * &amp;amp; extensionSansTitleElement *)} atomTitle = 요소 atom : title {atomTextConstruct} # app : collection appCollection = 요소 app : collection {appCommonAttributes, 특성 href {atomURI}, (atomTitle &amp;amp; appAccept * &amp;amp; app 카테고리 * &amp;amp; extensionSansTitleElement *)} # app : 카테고리 atomCategory = 요소 atom : category {atomCommonAttributes, 속성 용어 {text}, 속성 체계 {atomURI} ?, 속성 레이블 {text} ?, undefinedContent} appInlineCategories = 요소 app : categories {속성 고정 { &quot;예&quot;| &quot;아니&quot; }?,속성 체계 {atomURI} ?, (atomCategory *, undefinedContent)} appOutOfLineCategories = element app : categories {속성 href {atomURI}, undefinedContent} appCategories = appInline 카테고리 | appOutOfLine 카테고리 # app : accept appAccept = element app : accept {appCommonAttributes, (text?)} # Simple Extension simpleSansTitleExtensionElement = element *-(app : * | atom : title) {text} simpleExtensionElement = 요소 *-(app : *) { text} # 구조적 확장 structuredSansTitleExtensionElement = element *-(app : * | atom : title) {(속성 * {text} +, (text | anyElement) *) | (속성 * {text} *, (text ?,anyElement +, (text | anyElement) *))} structuredExtensionElement = 요소 *-(app : *) {(속성 * {text} +, (text | anyElement) *) | (속성 * {text} *, (text ?, anyElement +, (text | anyElement) *))} # 기타 확장 성 extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | structuredExtensionElement undefinedContent = (text | anyForeignElement) * # 확장명 anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-app : * {(속성 * {text} | text | anyElement) * } atomPlainTextConstruct = atomCommonAttributes,속성 유형 { &quot;text&quot;| &quot;html&quot;} ?, 텍스트 atomXHTMLTextConstruct = atomCommonAttributes, 속성 유형 { &quot;xhtml&quot;}, xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 atom =&quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;네임 스페이스 xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;namespace local =&quot; &quot;start = app 카테고리 atomCommonAttributes = 속성 xml : base {atomURI} ?, 속성 xml : lang {atomLanguageTag} ?, undefinedAttribute * undefinedAttribute = 속성 *-(xml : base | xml : lang | local : *) { text} atomURI = 텍스트 atomLanguageTag = xsd : string {pattern = &quot;([A-Za-z] {1,8} (-[A-Za-z0-9] {1,8}) *)?&quot;} atomCategory = 요소 atom : category {atomCommonAttributes, 속성 용어 {text}, 속성 체계 {atomURI} ?, 속성 레이블 {text} ?, undefinedContent} appInlineCategories = element app : categories {속성 고정 { &quot;yes&quot;| &quot;no&quot;} ?, 속성 체계 {atomURI} ?, (atomCategory *,undefinedContent)} appOutOfLineCategories = 요소 app : categories {attribute href {atomURI}, (비어 있음)} appCategories = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :(비어 있음)} app 카테고리 = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :(비어 있음)} app 카테고리 = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :* {(속성 * {text} | text | anyElement) *} # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :* {(속성 * {text} | text | anyElement) *} # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI : &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Bill de hOra (편집자) NewBay Software 이메일 : bill@dehora.net URI : &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 전체 저작권 정보 Copyright (C) IETF Trust (2007). 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78에&lt;/a&gt; 포함 된 권리, 라이센스 및 제한 사항의 적용을받습니다저자는 여기에 명시된 경우를 제외하고 모든 권리를 보유합니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며, 기부자, 그 / 그녀가 대표하거나 후원하는 단체, 인터넷 사회, IETF 신뢰 및 인터넷 엔지니어링 책임은 모두 부인됩니다. 여기에 포함 된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 어떠한 권리 나 묵시적 보증도 침해하지 않는다는 어떠한 보증도 포함하여 명시 적 또는 묵시적 보증.지적 재산권 IETF는이 문서에 기술 된 기술의 구현 또는 사용과 관련하여 주장 할 수있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스가 사용하지 못할 수 있습니다. 또한 그러한 권리를 식별하기 위해 독립적 인 노력을 기울인 것도 아닙니다. RFC 문서의 권리와 관련된 절차에 대한 정보는&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt; . IETF 사무국에 대한 IPR 공개 사본 및 사용 가능한 라이센스에 대한 보증, 또는이 사양의 구현 자 또는 사용자가 해당 소유권을 사용하기위한 일반 라이센스 또는 허가를 획득하려는 시도의 결과를 얻을 수 있습니다. 에서 IETF 온라인 IPR 저장소에서 &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt; . IETF는 모든 이해 당사자가이 표준을 구현하는 데 필요할 수있는 기술을 포괄 할 수있는 모든 저작권, 특허 또는 특허 응용 프로그램 또는 기타 소유권을 관심을 갖도록 초대합니다. 정보는 IETF (ietf-ipr@ietf.org)로 문의하십시오. Gregorio &amp;amp; de hOra 표준 트랙 [페이지 53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">이 기사에서는 특정 입력 및 브라우저 버전에 대한 HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; 헤더 의 기본값을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">이 기사는 Cross-Origin Resource Sharing에 대한 일반적인 토론이며 필요한 HTTP 헤더에 대한 토론을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">이것은 Linux 및 Mac OS X 시스템 에서 명령 행 &lt;code&gt;uuencode&lt;/code&gt; 유틸리티를 사용하여 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">예를 들어 콘텐츠를 동적으로 제공하는 데 유용 할 수 있습니다. 사용하는 경우는 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 캐시에서 페이지를 제공할지 여부를 결정할 때 헤더, 캐싱 서버가 사용자 에이전트를 고려해야합니다. 모바일 사용자에게 다른 컨텐츠를 제공하는 경우 캐시가 실수로 데스크탑 버전의 사이트를 모바일 사용자에게 제공하는 것을 피할 수 있습니다. 또한 Google 및 기타 검색 엔진이 모바일 버전의 페이지를 발견하는 데 도움을 줄 수 있으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;클로킹&lt;/a&gt; 이 의도 되지 않았다고 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">예를 들어, JavaScript 코드가 여러 도메인의 콘텐츠에 액세스 할 수있는 향상된 권한으로 실행되는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">이 상태 코드 클래스는 상태 라인 및 선택적 헤더로만 구성된 임시 응답을 나타내며 빈 라인으로 종료됩니다. 이 클래스의 상태 코드에 필요한 헤더가 없습니다. HTTP / 1.0은 1xx 상태 코드를 정의하지 않았기 때문에 서버는 실험 조건을 제외하고 1xx 응답을 HTTP / 1.0 클라이언트에 보내서는 안됩니다. 클라이언트가 100 (계속) 상태 메시지를 기대하지 않더라도 클라이언트는 정기 응답 전에 하나 이상의 1xx 상태 응답을 승인 할 수 있어야합니다. 예상치 못한 1xx 상태 응답은 사용자 에이전트에 의해 무시 될 수 있습니다. 프록시와 클라이언트 간의 연결이 닫히지 않았거나 프록시 자체가 1xx 응답의 생성을 요청하지 않는 한 프록시는 반드시 1xx 응답을 전달해야합니다. (예 : 프록시가 '예상 : 100-continue &quot;필드는 요청을 전달할 때 해당 100 (계속) 응답을 전달할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 조치는 두 번째 요청에 사용 된 방법이 GET 또는 HEAD 인 경우에만 사용자와의 상호 작용없이 사용자 에이전트에 의해 수행 될 수 있습니다. 클라이언트는 무한 리디렉션 루프를 감지해야합니다. 이러한 루프는 각 리디렉션에 대해 네트워크 트래픽을 생성하기 때문입니다. 참고 :이 사양의 이전 버전에서는 최대 5 개의 리디렉션이 권장되었습니다. 컨텐츠 개발자는 이러한 고정 된 제한을 구현하는 클라이언트가있을 수 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">이 상태 코드 클래스는 클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">이 코드는 서버가 요청을 수신하여 처리 중이지만 아직 응답을 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">이 코드는 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">이 코드는 클라이언트 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 요청 헤더 에 응답하여 전송 하며 서버가 전환하는 프로토콜을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">이 코드는 401 (권한 없음)과 유사하지만 클라이언트가 먼저 프록시를 사용하여 인증해야 함을 나타냅니다. 프록시 는 요청 된 자원에 대한 프록시에 적용 가능한 챌린지를 포함 하는 프록시 인증 헤더 필드 ( &lt;a href=&quot;#section-14.33&quot;&gt;섹션 14.33&lt;/a&gt; )를 반환해야 합니다. 클라이언트는 적절한 Proxy-Authorization 헤더 필드 ( &lt;a href=&quot;#section-14.34&quot;&gt;14.34 절&lt;/a&gt; )로 요청을 반복 할 수있다 . HTTP 액세스 인증은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">이 디자인 기법에는 상향식 접근 방식을 사용하여 웹 사이트를 '계층'으로 개발하고 간단한 계층부터 시작하여 연속 된 계층에서 사이트 기능을 향상시키는 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">이 지시문은 Public-Key-Pins-Report-Only 헤더에는 의미가 없으며, 사용자 에이전트에 의해 무시되며 헤더는 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 또는 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 필드 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">이 문서는 클라이언트가 원격 웹 컨텐츠 저작 작업을 수행 할 수 있도록하는 HTTP / 1.1 프로토콜의 확장에 대해 설명합니다. 이 확장은 다음과 같은 작업을 제공하는 일관된 메소드, 헤더, 요청 엔터티 본문 형식 및 응답 엔터티 본문 형식을 제공합니다. 속성 : 웹 페이지에 대한 정보 (예 : 작성자, 작성 날짜, 콜렉션 : 문서 세트를 작성하고 계층 적 멤버쉽 리스팅 (파일 시스템의 디렉토리 리스팅과 같은)을 검색하는 기능. 잠금 : 여러 사람이 동시에 한 문서에서 작업하지 못하게하는 기능. 이렇게하면 &quot;잃어버린 업데이트 문제&quot;를 방지 할 수 있습니다.이 업데이트에서 수정자는 먼저 한 사람 씩, 다른 사람은다른 작성자의 변경 사항을 병합하지 않고 변경 사항을 작성합니다. 네임 스페이스 작업 : URL에서 리소스로 매핑을 변경하는 작업 인 서버에 웹 리소스를 복사하고 이동하도록 지시하는 기능. 이러한 작업에 대한 요구 사항 및 이론적 근거는 &quot;WWW (World Wide Web)에 대한 분산 작성 및 버전 관리 프로토콜에 대한 요구 사항&quot;문서에 설명되어 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]. 이 문서는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]에서 제안한 버전 관리 작업을 지정하지 않습니다 . 이 작업은 별도의 문서 &quot;WebDAV에 대한 버전 확장&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]에서 수행되었습니다. 아래 섹션에서는 다양한 WebDAV 추상화에 대한 자세한 소개를 제공합니다. 리소스 속성 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ), 리소스 모음 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ), 잠금 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 및 쓰기 잠금 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ). 이러한 추상화는 WebDAV 고유의 HTTP 메소드 ( &lt;a href=&quot;#section-9&quot;&gt;섹션 9&lt;/a&gt; ) 및 추가 HTTP 헤더 ( &lt;a href=&quot;#section-10&quot;&gt;섹션 10)로 조작됩니다.&lt;/a&gt;)는 WebDAV 메소드와 함께 사용됩니다. WebDAV에서 HTTP 요청 및 응답을 처리하기위한 일반적인 고려 사항은 &lt;a href=&quot;#section-8&quot;&gt;섹션 8에&lt;/a&gt; 있습니다. HTTP / 1.1에서 제공하는 상태 코드는 WebDAV 메소드에서 발생하는 대부분의 오류 조건을 설명하기에 충분하지만 기존 범주에 속하지 않는 일부 오류가 있습니다. 이 사양은 WebDAV 메소드 용으로 개발 된 추가 상태 코드 ( &lt;a href=&quot;#section-11&quot;&gt;11 &lt;/a&gt;&lt;a href=&quot;#section-12&quot;&gt;장&lt;/a&gt; )를 정의하고 WebDAV에서 사용되는 기존 HTTP 상태 코드 ( 12 장 )를 설명 합니다. 일부 WebDAV 방법은 많은 리소스를 통해 작동 할 수 있으므로 다중 상태 응답 ( &lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;)가 여러 리소스에 대한 상태 정보를 반환하기 위해 도입되었습니다. 마지막으로,이 버전의 WebDAV 는 오류 응답 본문에 사전 조건 및 사후 조건 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; ) XML 요소를 도입 합니다. WebDAV는 속성 이름 및 일부 값에 XML ([ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ])을 사용하고 복잡한 요청 및 응답을 마샬링하기 위해 XML을 사용합니다. 이 사양에는 마샬링에 사용되는 모든 속성 ( &lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt; ) 및 기타 모든 XML 요소 ( &lt;a href=&quot;#section-14&quot;&gt;섹션 14&lt;/a&gt; )의 DTD 및 텍스트 정의가 포함 됩니다. WebDAV에는 이전 버전과 호환되는 방식으로 WebDAV XML 마샬링을 확장하는 몇 가지 특수 규칙이 포함되어 있습니다 ( &lt;a href=&quot;#section-17&quot;&gt;섹션 17).&lt;/a&gt;). 사양의 마무리는 자원이이 사양을 준수한다는 의미 ( &lt;a href=&quot;#section-18&quot;&gt;섹션 18&lt;/a&gt; ), 국제화 지원 ( &lt;a href=&quot;#section-19&quot;&gt;섹션 19&lt;/a&gt; ) 및 보안 ( &lt;a href=&quot;#section-20&quot;&gt;섹션 20&lt;/a&gt; ) 에 대한 섹션 입니다.</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Firefox 4 이상에서 사용되는 사용자 에이전트 문자열과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 이상 기반 응용 프로그램에 대해 설명합니다 . Gecko 2.0의 문자열 변경 내용 &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;은 Firefox 4 용 최종 사용자 에이전트 문자열&lt;/a&gt; (블로그 게시물)을 참조하십시오. &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트 스니핑&lt;/a&gt; 에 대한이 문서 와이 &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks 블로그 게시물을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Firefox 4 이상에서 사용되는 사용자 에이전트 문자열과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 이상 기반 응용 프로그램에 대해 설명합니다 . Gecko 2.0의 문자열 변경 내용 &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;은 Firefox 4 용 최종 사용자 에이전트 문자열&lt;/a&gt; (블로그 게시물)을 참조하십시오. &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트 스니핑&lt;/a&gt; 에 대한이 문서 와이 &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks 블로그 게시물을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">이 HTTP / 1.1 버전은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616에&lt;/a&gt; 많은 기여를했습니다.팀 버너스-리, 아리 루 오토 넨, 로이 T. 필딩, 헨리크 프라이스 티크 닐슨, 짐 게티, 제프리시 모굴, 래리 마스터, 폴 제이 리치 . Mark Nottingham은 이러한 노력을 실무 그룹 의장으로 감독했습니다. 1999 년부터 다음 기고자들은 버그를보고하고, 현명한 질문을하고, 텍스트를 작성하거나 검토하고, 공개 된 문제를 평가하여 HTTP 사양을 개선하는 데 도움을주었습니다. Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole, Adrien W. de Croy , Alan Ford, Alan Ruttenberg, Albert Lunde, Alek Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier, Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, 브라이언 켈, Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens, Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann, Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus Daboo, Dale Robert Anderson, Dan Wing , Dan Winship, Daniel Stenberg, Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty, Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan Adler Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D. Williams, Eric J. Bowman,Eric Lawrence, Eric Rescorla, Erik Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser, Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham, Gili Tzabari, 그레이엄 그리브 , Greg Slepak, Greg Wilkins, Grzegorz Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel, Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson , Ido Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll, James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges '유효한 요청 URI'라는 용어), Jeff Pinner, Jeff Walden, Jim Luther, Jitu Padhye, Joe D. Williams,Joe Gregorio, Joe Orton, Joel Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp, John Panzer, John Schneider, John Stracke, John Sullivan, Jonas Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore , Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault, Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler, Martin J. Duerst, Martin Musatov, Martin 닐슨, 마틴 톰슨, 맷 린치, 매튜 콕스, 매튜 커윈, 맥스 클락, 메나 켐 닷지,Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen, Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin, Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, 니콜라스 샹크스, 니코 윌리엄스, 니콜라스 알바레즈, 니콜라스 Mailhot, 노아 슬레이터, 오사마 마 자히르, 파블로 카스트로, 팻 헤이스, 패트릭 R. 맥 마누스, 폴 E. 존스, 폴 호프만, 폴 마르케스, 피트 레닉, 피터 레 페스 카, 피터 오실, 피터 세인트 안드레, 피터 왓킨스, 필 궁수, 필 헌트, 필립 무 gin, 필립 할람 베이커, 피오트르 도브로 고스트, 폴 헤닝 캄프, 프레 티 나타 라얀, 라 예프 벡터, 레이 포크, 레토 바흐 만-구 에르, 리차드 반스, 리차드 시가 닉 트레이스, 로비 심슨, Robert Brewer, Robert Collins, Robert Mattson, Robert O'Callahan,Robert Olofsson, Robert Sayre, Robert Siemer, Robert de Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence (원본 문제 목록을 유지 한 사람), Sean B. Palmer, Sean Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin 스튜어트 윌리엄스, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares, Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim 브레이, 팀 모건, 팀 올슨, 톰 주, 트래비스 스 누지,Tyler Close, Vincent Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang, Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang, Yuchung Cheng , Yutaka Oiwa, Yves Lafon (오래 편집자 멤버), Zed A. Shaw 및 Zhong Yu. 보다&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;&lt;/a&gt;이전 개정의 추가 승인에 대해서는 [RFC2616]의 16 항 .</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">응답에 둘 이상의 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더가 포함 된 경우에도이 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">이 오류는 문서가 사용자가 열거 나 열지 않은 탭 또는 창의 최상위 레벨에로드되지 않았 음을 의미합니다. 다음과 같은 상황에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">이 오류 응답은 일반적인 &quot;catch-all&quot;응답입니다. 때때로 서버 관리자는 나중에 오류가 다시 발생하지 않도록 요청에 대한 자세한 정보와 함께 500 상태 코드와 같은 오류 응답을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">이 오류 응답은 서버가 게이트웨이로 작동하고 시간 내에 응답을 얻을 수 없을 때 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">이 오류 응답은 서버가 요청을 처리하는 데 필요한 응답을 얻기 위해 게이트웨이로 작업하는 동안 유효하지 않은 응답을 받았음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">이 오류는 테스트를 거친 프로덕션 시스템에서는 발생하지 않지만 새 시스템을 테스트하는 동안 더 자주 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">이러한 HTTP의 진화는 확장 성과 단순성을 입증하여 많은 응용 프로그램을 생성하고 프로토콜 채택을 강요합니다. 오늘날 HTTP가 사용되는 환경은 1990 년대 초와는 상당히 다릅니다. HTTP의 독창적 인 디자인은 걸작 인 것으로 판명되었으므로 웹은 반란없이 4 세기 동안 진화 할 수있었습니다. 결함을 치유하면서도 HTTP를 성공으로 이끈 유연성과 확장 성을 유지함으로써 프로토콜의 미래에 HTTP / 2 힌트를 채택 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">이 예에서는 특정 출발지의 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 콘텐츠가 사용자의 위치에 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">이 예제는 www.example.com 서버에서 / webdisc / xfiles /라는 컬렉션을 만듭니다. &amp;gt;&amp;gt; MKCOL 요청 / webdisc / xfiles / HTTP / 1.1 호스트 : www.example.com &amp;gt;&amp;gt; 응답 HTTP / 1.1 201 생성</target>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">이 예는 더 정교합니다. 4 개의 프록시 서버가 있습니다. 그들 중 하나는 다른 모든 것의 핫 스탠바이이므로 나머지 세 개 중 하나라도 쓰러지면 네 번째 것이 인계됩니다. 또한 나머지 3 개의 프록시 서버는 URL 패턴을 기반으로로드를 공유하므로보다 효과적으로 캐싱 할 수 있습니다 (3 개의 서버에는 하나의 사본이 아니라 각 서버에 하나의 문서 사본 만 있음). 하중은 다음과 같이 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">이 예제 응답은 IETF RFC (아래 참조)에서 가져 왔으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python의 Life of Brian에&lt;/a&gt; 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">이 예는 여러 헤더에 대한 지원을 지정할 때 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">이 예는 http://www.example.com/~fielding/index.html 리소스가 http://www.example.com/users/f/fielding/index.html 위치로 복사되는 것을 보여줍니다. 204 (No Content) 상태 코드는 대상의 기존 리소스를 덮어 쓴 것을 나타냅니다. &amp;gt;&amp;gt; 요청 복사 /~fielding/index.html HTTP / 1.1 호스트 : www.example.com 대상 : http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt; 응답 HTTP / 1.1 204 아니요 함유량</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">이 예는 http://www.example.com/~fielding/index.html 자원이 http://www.example.com/users/f/fielding/index.html 위치로 이동되는 것을 보여줍니다. 대상 URL이 이미 리소스에 매핑 된 경우 대상 리소스의 내용을 덮어 씁니다. 이 경우 대상 자원에 아무것도 없으므로 응답 코드는 201 (작성 됨)입니다. &amp;gt;&amp;gt; 요청 MOVE /~fielding/index.html HTTP / 1.1 호스트 : www.example.com 대상 : http : //www.example/users/f/fielding/index.html &amp;gt;&amp;gt; 응답 HTTP / 1.1 201 생성 된 위치 : http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">이 예제는 내부 DNS 서버가 설정되어 내부 호스트 이름 만 확인할 수있는 환경에서 작동하며 목표는 분석 할 수없는 호스트에 대해서만 프록시를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">이러한 확장 가능한 HTTP 특성으로 인해 시간이 지남에 따라 웹의 제어 및 기능이 향상되었습니다. 캐시 또는 인증 방법은 HTTP 기록 초기에 처리 된 기능이었습니다. 반대로, &lt;em&gt;원점 제약&lt;/em&gt; 을 완화하는 기능 은 2010 년대에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">이 기능은 웹 표준에서 제거되었습니다. 일부 브라우저는 여전히이를 지원할 수 있지만 삭제되는 중입니다. 사용하지 말고 가능한 경우 기존 코드를 업데이트하십시오. 결정을 안내하려면이 페이지 하단의 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 참조하십시오 . 이 기능은 언제든지 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">이 기능은 비표준이며 표준 트랙이 아닙니다. 웹이있는 프로덕션 사이트에서는 사용하지 마십시오. 모든 사용자에게 적용되는 것은 아닙니다. 구현 간에는 큰 비 호환성이있을 수 있으며 향후 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 일부 브라우저에서는 여전히 작동하지만 언제든지 제거 할 수 있으므로 사용하지 않는 것이 좋습니다. 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">이 기본 기사에서는 일반적인 HTTP 세션에 대해 설명합니다. 브라우저에서 링크를 클릭 할 때 발생하는 상황&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 유효성 검사기 또는 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있지만 둘 다와 함께 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">서버의이 헤더는 클라이언트에게 쿠키를 저장하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">이 헤더는 서버가 명시적인 사용자 결정에 의해 제어되는 특정 URL과 같은 다른 방법을 통해 언어를 결정할 방법이 없을 때 사용되는 힌트입니다. 서버가 명시 적 결정을 무시하지 않는 것이 좋습니다. &lt;code&gt;Accept-Language&lt;/code&gt; 의 내용은 사용자가 통제 할 수없는 경우가 많습니다 (예 : 다른 국가의 인터넷 카페를 여행하거나 이용할 때). 사용자는 자신의 사용자 인터페이스 로캘이 아닌 다른 언어로 페이지를 방문 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 헤더는 사용하기로 선택한 클라이언트에 의해 자동으로 추가됩니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 추가 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 내에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">요청에 &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더 가있는 경우이 헤더가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">이 헤더는 디버깅, 통계 및 위치 종속 컨텐츠 생성에 사용되며 설계 상 클라이언트의 IP 주소와 같은 개인 정보에 민감한 정보를 노출합니다. 따라서이 헤더를 배포 할 때 사용자의 개인 정보를 염두에 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">서버가 &lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; 상태 코드로 응답하여 사용할 수있는 요청 방법을 나타내는 경우이 헤더를 보내야합니다 . 빈 &lt;code&gt;Allow&lt;/code&gt; 헤더는 리소스가 요청 리소스를 허용하지 않음을 나타냅니다. 예를 들어 지정된 리소스에 대해 일시적으로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이 헤더는 발생한 위반을보고합니다. 이를 사용하여 컨텐츠 보안 정책을 반복적으로 작업 할 수 있습니다. 사이트의 작동 방식을 관찰하고 위반 보고서를 관찰 한 후 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더로 시행 할 원하는 정책을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">이 헤더는 웹 마스터가 발생하는 콘텐츠 스니핑을 차단하고 실행 불가능한 MIME 유형을 실행 가능한 MIME 유형으로 변환 할 수있는 방법으로 IE 8에서 Microsoft에 의해 도입되었습니다. 그 이후로 MIME 스니핑 알고리즘이 덜 공격적인 경우에도 다른 브라우저에서이를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">이 임시 응답은 지금까지 모든 것이 정상이며 클라이언트가 요청을 계속하거나 요청이 이미 완료된 경우이를 무시해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더 와 함께 유효하지 않거나 알 수없는 헤더 이름을 더 이상 보내지 않도록 서버 구성을 수정하면 서버 측에서만 해결할 수있는 문제입니다 . 클라이언트에서 사용중인 사용자 에이전트 또는 HTTP 라이브러리가 최신인지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 헤더 로 더 이상 유효하지 않거나 알려지지 않은 메소드 이름을 보내지 않도록 서버의 구성을 수정하여 서버 측에서만 해결할 수있는 문제점입니다 . 클라이언트에서 사용중인 사용자 에이전트 또는 HTTP 라이브러리가 최신인지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">이것은 원하는 모든 기능을 사용하여 최상의 사이트를 구축 한 다음 이전 브라우저에서 작동하도록 조정합니다. 점진적 향상보다 수행하기가 어렵고 효과가 떨어질 수 있지만 경우에 따라 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://bikeshed.com/&quot;&gt;자전거 흘림&lt;/a&gt; 문제 로 간주 될 수있는 매우 주관적인 주제 입니다. 더 자세히 읽으 려면 주제에 대한 &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;많은 &lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;기사&lt;/a&gt; 중 일부를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">더 이상 &lt;code&gt;text/html&lt;/code&gt; 보다 &lt;code&gt;image/png&lt;/code&gt; 순위를 가지지 않기 때문에 이전 &lt;code&gt;Accept&lt;/code&gt; 헤더 보다 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">이것은 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 구현됩니다 . etag가 원본 파일과 일치하지 않거나 파일을 얻은 후 수정 된 경우에는 &lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 오류 와 함께 변경이 거부됩니다 . 오류를 처리하는 것은 클라이언트에게 달려 있습니다. 사용자에게 다시 시작하도록 알리거나 (이번에는 최신 버전에서) 사용자에게 두 버전 의 &lt;em&gt;차이점&lt;/em&gt; 을 보여 주어 유지하려는 변경 사항을 결정할 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">이는 &lt;em&gt;클라이언트 힌트&lt;/em&gt; 라는 &lt;strong&gt;실험&lt;/strong&gt; 기술의 일부이며 Chrome 61 이상에서만 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">이것은 &lt;em&gt;클라이언트 힌트&lt;/em&gt; 라는 &lt;strong&gt;실험&lt;/strong&gt; 기술의 일부입니다 . 초기 지원은 Chrome 46 이상입니다. 기기 메모리 값은 Chrome 61 이상입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">이것은 401과 비슷하지만 프록시로 인증을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">이진 파일의 기본값입니다. &lt;em&gt;알 수없는 이진&lt;/em&gt; 파일을 의미하므로 브라우저는 일반적으로 파일을 실행하지 않거나 실행해야하는지 묻습니다. 그들은 &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; 헤더가 &lt;code&gt;attachment&lt;/code&gt; 로 설정된 것처럼 취급 하고 &quot;다른 이름으로 저장&quot;대화 상자를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">텍스트 파일의 기본값입니다. &lt;em&gt;알 수없는 텍스트&lt;/em&gt; 파일을 의미하더라도 브라우저는 파일을 표시 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">정책이 지정되지 않은 경우 이는 사용자 에이전트의 기본 동작입니다. 프로토콜 보안 수준이 동일하게 유지 될 때 (HTTP &amp;rarr; HTTP, HTTPS &amp;rarr; HTTPS) URL은 참조 자로 전송되지만 보안 수준이 낮은 대상 (HTTPS &amp;rarr; HTTP)으로 전송되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">정책이 지정되지 않은 경우 이는 사용자 에이전트의 기본 동작입니다. 오리진은 보안 상 가장 안전한 대상 (HTTPS-&amp;gt; HTTPS)에 대한 참조 자로 전송되지만 덜 안전한 대상 (HTTPS-&amp;gt; HTTP)으로 전송되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">캐싱 목적으로 사용됩니다. 클라이언트에게 응답이 수정되지 않았 음을 알리므로 클라이언트는 동일한 캐시 버전의 응답을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">이것은 일반적으로 나쁜 습관이지만 이것이 필요한 경우가 있습니다. 이러한 경우에는 상황을 먼저 분석하여 실제로 필요한지 확인해야합니다. 의미없는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 추가하여이를 방지 할 수 있습니까 ? 사용자 에이전트 감지를 성공적으로 사용하는 데 어려움이 있다면 HTML 순도를 약간 떨어 뜨릴 가치가 있습니다. 또한 디자인을 다시 생각하십시오. 점진적 향상 또는 유동적 인 레이아웃을 사용하여이를 수행 할 필요가 없습니까?</target>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">이는 이제 자원이 &lt;code&gt;Location:&lt;/code&gt; HTTP Response 헤더에 의해 지정된 다른 URI에 영구적으로 위치 함을 의미합니다 . 것과 동일한 의미를 갖는다 &lt;code&gt;301 Moved Permanently&lt;/code&gt; 사용자 에이전트는 것을 제외하고는, HTTP 응답 코드 &lt;em&gt;안&lt;/em&gt; 경우 사용되는 HTTP 방법을 변경 &lt;code&gt;POST&lt;/code&gt; 가 첫 번째 요청에 사용 하였다하는 &lt;code&gt;POST&lt;/code&gt; 는 두 번째 요청에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">이 메커니즘은 항상 클라이언트에서 시작되며 (단 한 가지 예외 : 서버 &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;에서 TLS로 업그레이드해야&lt;/a&gt; 할 수 있음) 서버는 새 프로토콜로의 전환을 수락하거나 거부 할 수 있습니다. 이를 통해 HTTP / 1.1과 같이 일반적으로 사용되는 프로토콜을 사용하여 연결을 시작한 다음 연결이 HTTP / 2 또는 WebSocket으로 전환되도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">이 메시지는 브라우저가 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더를 보고 더 많은 사용 가능한 연속 메모리를 가져야하는 새 프로세스로 페이지를 다시로드 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">이 모델은 HTTP / 1.0에서 사용되는 기본 모델입니다 ( &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더가 없거나 값이 &lt;code&gt;close&lt;/code&gt; 로 설정된 경우 ). HTTP / 1.1에서이 모델은 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더가 &lt;code&gt;close&lt;/code&gt; 값으로 전송 될 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">이 페이지는 완성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">이 페이지는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 로 인해 새 프로세스에로드되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">이 페이지는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 로 인해 새 프로세스에로드 되지만 Win32 이외의 플랫폼 에서는 &lt;code&gt;Large-Allocation&lt;/code&gt; 프로세스 생성이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">이 정책은 TLS로 보호되는 리소스에서 안전하지 않은 오리진으로 오리진 및 경로를 유출합니다. 이 설정의 영향을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">이 프리 페치는 백그라운드에서 수행되므로 참조 항목이 필요할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; 가 해결되었을 가능성이 있습니다. 사용자가 링크를 클릭 할 때 대기 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">HTTP / 2는 웹 사이트 및 응용 프로그램을 조정할 필요가 없기 때문에 빠른 채택률이 높았습니다. HTTP / 1.1 또는 HTTP / 2를 사용하는 것은 투명합니다. 최신 서버와 최신 서버와 통신하는 것만으로도 충분히 사용할 수 있습니다. 제한된 그룹 집합 만 채택하면 트리거가 가능하고 레거시 브라우저 및 서버 버전이 갱신됨에 따라 웹을 추가하지 않고도 사용량이 자연스럽게 증가했습니다. 개발자 노력.</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">내용이 다음과 같은 HTML 리소스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">이 응답 코드는 더 이상 사용되지 않으며 현재 예약되어 있습니다. HTTP 1.1 스펙의 이전 버전에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">이 응답 코드는 나중에 사용하기 위해 예약되어 있습니다. 이 코드를 작성하기위한 초기 목표는 디지털 지불 시스템에 사용되었지만 현재는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">이 응답 코드는 요청을 완료 한 후 전송되어 사용자 에이전트에게이 요청을 보낸 문서보기를 재설정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">이 응답 코드는 다운로드를 여러 스트림으로 분리하기 위해 클라이언트가 전송 한 범위 헤더 때문에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">이 응답 코드는 리턴 된 메타 정보 세트가 원래 서버에서 사용 가능한 정확한 세트가 아니라 로컬 또는 써드 파티 사본에서 수집됨을 의미합니다. 이 조건을 제외하고이 응답 대신 200 OK 응답이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">이 응답 코드는 요청 된 자원의 URI가 &lt;em&gt;일시적&lt;/em&gt; 으로 변경되었음을 의미합니다 . 향후 URI에서 새로운 변경이 이루어질 수 있습니다. 따라서 향후 요청에서 클라이언트가 동일한 URI를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">이 응답 코드는 요청 된 자원의 URI가 변경되었음을 의미합니다. 아마도 새로운 URI가 응답에 주어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">이 응답 코드 는 서버 가 &lt;code&gt;Expect&lt;/code&gt; 요청 헤더 필드로 표시된 예상을 충족 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">이 응답은 클라이언트의 이전 요청 없이도 일부 서버에서 유휴 연결로 전송됩니다. 서버가이 사용되지 않는 연결을 종료하려고 함을 의미합니다. 이 응답은 Chrome, Firefox 27 이상 또는 IE9와 같은 일부 브라우저가 HTTP 사전 연결 메커니즘을 사용하여 서핑 속도를 높이기 때문에 훨씬 더 많이 사용됩니다. 또한 일부 서버는이 메시지를 보내지 않고 연결을 종료하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">요청이 서버의 현재 상태와 충돌 할 때이 응답이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">이 응답은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;서버 구동 컨텐츠 협상&lt;/a&gt; 을 수행 한 후 웹 서버 가 사용자 에이전트가 제공 한 기준을 따르는 컨텐츠를 찾지 못할 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">이 응답은 Chrome, Firefox 27 이상 및 IE9와 같은 일부 브라우저가 HTTP 사전 연결 메커니즘을 사용하여 서핑 속도를 높이기 때문에 훨씬 더 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">이 응답은 유효하지 않은 구문으로 인해 서버가 요청을 이해할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">요청 된 콘텐츠가 전달 주소없이 서버에서 영구적으로 삭제되면이 응답이 전송됩니다. 클라이언트는 캐시와 자원에 대한 링크를 제거해야합니다. HTTP 사양에서는이 상태 코드를 &quot;제한된 프로모션 서비스&quot;에 사용하려고합니다. API는이 상태 코드로 삭제 된 리소스를 나타내도록 강요해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">이 섹션은 요청에 전제 조건을 적용하기위한 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다. &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; 는 전제 조건이 적용되는시기를 정의합니다. &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 은 둘 이상의 전제 조건이 존재할 때 평가 순서를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">이 섹션은 캐싱과 관련된 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">이 섹션은 모든 표준 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다. 엔터티 헤더 필드의 경우 보낸 사람과받는 사람 모두 엔터티를 보내고받는 사람에 따라 클라이언트 또는 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">이 섹션은 HTTP 인증 프레임 워크와 관련된 헤더 필드의 구문과 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;data&lt;/code&gt; URL을 만들고 사용할 때 일반적으로 발생하는 문제에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">이 섹션에서는 쓰기 잠금 유형과 관련된 의미를 설명합니다. 쓰기 잠금은 잠금 유형의 특정 인스턴스이며이 사양에 설명 된 유일한 잠금 유형입니다. 단독 쓰기 잠금은 리소스를 보호합니다. 잠금 생성자 이외의 다른 주체와 잠금 토큰이 제출되지 않은 경우 (예 : 잠금을 보유한 클라이언트 프로세스 이외의 클라이언트 프로세스)에 의한 변경을 방지합니다. 클라이언트는 쓰기 잠금 리소스를 수정하는 모든 요청에 ​​사용할 권한이있는 잠금 토큰을 제출해야합니다. 쓰기 잠금이 적용되는 수정 목록에는 다음이 포함됩니다. 1. 쓰기 잠금 리소스의 다음 측면에 대한 변경 사항 : * 변형, * 사용 불능 속성,* 잠글 수있는 라이브 속성 (달리 정의되지 않는 한 라이브 속성은 잠글 수 있음) 2. 컬렉션의 경우 내부 멤버 URI의 수정. 컬렉션의 내부 멤버 URI는 다른 리소스를 추가, 제거 또는 식별하는 경우 수정 된 것으로 간주됩니다. 쓰기 잠금 및 컬렉션에 대한 자세한 내용은 &lt;a href=&quot;#section-7.4&quot;&gt;섹션 7.4&lt;/a&gt; . 3. 쓰기 잠금의 루트를 다른 리소스로 또는 리소스가없는 것으로 (예 : DELETE) 매핑 수정. HTTP 및 WebDAV에 정의 된 메소드 중에서 PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, COPY (대상 자원의 경우), DELETE 및 MKCOL은 쓰기 잠금의 영향을받습니다. 지금까지 정의 된 다른 모든 HTTP / WebDAV 메소드 (특히 GET)는 쓰기 잠금과 독립적으로 작동합니다. 다음 몇 섹션에서는 쓰기 잠금이 다양한 작업과 상호 작용하는 방식을보다 구체적인 용어로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1 as described by this document. The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks.</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 의미와 관련된 알려진 보안 문제 및 인터넷을 통한 정보 전송에 대한 사용에 대해 설명합니다. 메시지 구문, 구문 분석 및 라우팅과 관련된 고려 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;은 [RFC7230]의 섹션 9&lt;/a&gt; 에서 설명 합니다. 아래 고려 사항 목록은 완전한 것이 아닙니다. HTTP 시맨틱과 관련된 대부분의 보안 문제는 서버 측 애플리케이션 (HTTP 인터페이스 뒤의 코드) 보안, HTTP를 통해 수신 된 페이로드의 사용자 에이전트 처리 보안 또는 일반적으로 프로토콜의 보안보다는 인터넷의 안전한 사용에 관한 것입니다. 다양한 조직이 주제 정보를 유지하고 웹 응용 프로그램 보안에 대한 최신 연구 링크 (예 : [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ])를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 인증과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 시맨틱 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 해결됩니다.&lt;/a&gt;]. HTTP 인증 주제에 대한 모든 것은 보안 고려 사항이므로 아래 고려 사항 목록이 완전한 것은 아닙니다. 또한 특정 인증 체계 (해당 체계를 정의하는 사양에 문서화되어야 함)에 대한 모든 잠재적 고려 사항을 논의하기보다는 일반적으로 인증 프레임 워크와 관련된 보안 고려 사항으로 제한됩니다. 다양한 조직 에서 실제로 발견 된 인증 체계를 구현하고 사용하기위한 일반적인 함정을 포함하여 웹 응용 프로그램 보안 (예 : [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]) 에 대한 최신 연구에 대한 주제 정보와 링크를 유지 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 캐싱과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 시맨틱 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 해결됩니다.&lt;/a&gt;]. 캐시의 내용은 악의적 인 악용의 대상이되기 때문에 캐시는 잠재적 인 취약점을 추가로 노출시킵니다. HTTP 요청이 완료된 후에도 캐시 내용이 유지되므로 사용자가 네트워크에서 정보가 제거되었다고 생각한 후에 캐시를 공격하면 정보가 노출 될 수 있습니다. 따라서 캐시 내용을 중요한 정보로 보호해야합니다. 특히, 공유 캐시에 저장함으로써 다양한 공격이 증폭 될 수 있습니다. 이러한 &quot;캐시 포이즌&quot;공격은 캐시를 사용하여 악의적 인 페이로드를 많은 클라이언트에 배포하며, 특히 공격자가 구현 결함, 높은 권한 또는 기타 기술을 사용하여 이러한 응답을 캐시에 삽입 할 수있을 때 효과적입니다.캐시 포이즈 닝에 대한 하나의 일반적인 공격 벡터는 프록시와 사용자 에이전트의 메시지 구문 분석의 차이점을 이용하는 것입니다. 보다 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;&lt;/a&gt;관련 요구 사항에 대해서는 [RFC7230]의 3.3.3 절 . 마찬가지로, 구현 결함 (캐시 조작에 대한 오해)은 개인 정보로 간주되는 민감한 정보 (예 : 인증 신임 정보)를 캐싱하여 권한없는 당사자에게 노출시킬 수 있습니다. 또한 캐시를 많이 사용하면 개인 정보 보호 문제가 발생할 수 있습니다. 예를 들어 두 명의 사용자가 캐시를 공유하고 첫 번째 사용자가 사이트를 탐색하는 경우 두 번째 사용자는 캐시 덕분에 다른 사용자가 해당 사이트를 방문했음을 감지 할 수 있습니다. Set-Cookie 응답 헤더 필드 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]는 캐싱을 금지하지 않습니다. Set-Cookie 헤더 필드를 가진 캐시 가능한 응답은 캐시에 대한 후속 요청을 충족시키는 데 사용될 수 있습니다. 이러한 응답의 캐싱을 제어하려는 서버는 적절한 캐시 제어 응답 헤더 필드를 생성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 조건부 요청 메커니즘과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP &quot;Message Syntax and Routing&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 &quot;Semantics and Content&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 다룹니다.&lt;/a&gt;]. 이 사양으로 정의 된 유효성 검사기는 표현의 유효성을 보장하거나 악의적 인 변경을 방지하거나 중간자 공격을 탐지하기위한 것이 아닙니다. 기껏해야 모든 참가자가 잘 동작 할 때보다 효율적인 캐시 업데이트와 낙관적 인 동시 쓰기가 가능합니다. 최악의 경우 조건이 실패하고 클라이언트는 조건부 요청없이 HTTP 교환보다 더 해로운 응답을받습니다. 개인 정보 위험을 유발하는 방식으로 엔티티 태그를 남용 할 수 있습니다. 예를 들어, 사이트는 사용자 또는 사용자 에이전트에 고유 한 의미 적으로 유효하지 않은 엔티티 태그를 의도적으로 구성하고, 신선도 시간이 긴 캐시 가능한 응답으로 전송합니다.그런 다음 해당 사용자 또는 사용자 에이전트를 다시 식별하는 수단으로 나중에 조건부 요청에서 해당 엔티티 태그를 읽습니다. 이러한 식별 태그는 사용자 에이전트가 원래 캐시 항목을 유지하는 한 지속적 식별자가됩니다. 표현을 캐시하는 사용자 에이전트는 사용자가 저장된 쿠키를 지우거나 개인 브라우징 모드로 변경하는 등 개인 정보 유지 관리 작업을 수행 할 때마다 캐시를 ​​지우거나 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 범위 요청 메커니즘과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 의미론 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에서 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 메시지 구문, 구문 분석 및 라우팅과 관련된 알려진 보안 고려 사항을 알려줍니다. HTTP 시맨틱 및 페이로드에 대한 보안 고려 사항은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">이 섹션은 WebDAV 응용 프로그램이 인식해야하는 보안 관련 문제에 대해 자세히 설명합니다. HTTP / 1.1 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 설명) 및 XML ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]에 설명)의 모든 보안 고려 사항 도 WebDAV에 적용됩니다. 또한 원격 작성에 내재 된 보안 위험에는보다 강력한 인증 기술이 필요하며 몇 가지 새로운 개인 정보 보호 문제가 발생하며 서버 디자인이 좋지 않아 위험이 증가 할 수 있습니다. 이러한 문제는 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">이 섹션에는 클라이언트 간 공유 기능을 사용하기 위해 클라이언트가 HTTP 요청을 발행 할 때 사용할 수있는 헤더가 나열되어 있습니다. 이 헤더는 서버를 호출 할 때 설정됩니다. 교차 사이트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 기능을 사용하는 개발자 는 프로그래밍 방식으로 교차 출처 공유 요청 헤더를 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">이 섹션에는 구현 변경을 초래할 수있는 변경 사항부터 시작 하여이 문서와 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 간의 주요 변경 사항이 나와 있습니다. 서버는 DAV 응답 헤더에 준수 클래스 &quot;3&quot;을 반환하여이 사양의 모든 변경 사항에 대한 지원을 알립니다 (섹션 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 및 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">이 섹션에는 서버 간 자원 공유 사양에 정의 된대로 서버가 액세스 제어 요청을 위해 보내는 HTTP 응답 헤더가 나열되어 있습니다. 이전 섹션에서는 이러한 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">이 섹션에서는 잠금 작동 방식에 대한 간결한 모델을 제공합니다. 이후 섹션에서는 일부 개념에 대해 자세히 설명하고 이러한 모델 설명을 다시 참조합니다. LOCK 및 UNLOCK 메소드 처리와 관련된 규범 문은 해당 메소드의 섹션에서 찾을 수 있지만 모든 메소드를 다루는 규범 문은 여기에 수집됩니다. 1. 잠금은 리소스를 직접 또는 간접적으로 잠급니다. 2. 해당 리소스의 URL에 대한 잠금 요청이 새 잠금을 만들면 리소스가 직접 잠 깁니다. 새 잠금의 &quot;루트 루트&quot;는 해당 URL입니다. 요청시 URL이 자원에 맵핑되지 않으면 비어있는 새 자원이 작성되고 직접 잠 깁니다. 3. 독점 잠금 장치 ( &lt;a href=&quot;#section-6.2&quot;&gt;섹션 6.2&lt;/a&gt;) 잠금이 직접적이든 간접적이든 동일한 리소스에 대한 다른 종류의 잠금과 충돌합니다. 서버는 리소스에 대해 충돌하는 잠금을 생성해서는 안됩니다 (MUST NOT). 4. 깊이 무한대 잠금 L로 잠긴 컬렉션의 경우 모든 멤버 리소스가 간접적으로 잠 깁니다. 이러한 콜렉션의 멤버쉽 변경은 간접적으로 잠긴 자원 세트에 영향을줍니다. * 멤버 자원이 콜렉션에 추가되는 경우 새 자원이 L에 의해 간접적으로 잠금 상태가되어야하므로 새 멤버 자원은 충돌하는 잠금이 없어야합니다. * 멤버 자원이 콜렉션의 멤버 인 것을 중지하면 L로 자원을 더 이상 간접적으로 잠그지 않아야합니다. 5. 각 잠금은 단일 한 글로벌 고유 잠금 토큰 (&lt;a href=&quot;#section-6.5&quot;&gt;섹션 6.5&lt;/a&gt; ). 6. UNLOCK 요청은 지정된 잠금 토큰을 가진 잠금을 삭제합니다. 잠금이 삭제 된 후에는 해당 잠금에 의해 리소스가 잠기지 않습니다. 7. &quot;If&quot;헤더에 나타날 때 요청에 잠금 토큰이 &quot;제출&quot;됩니다 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; , &quot;쓰기 잠금&quot;, 쓰기 잠금에 토큰 제출이 필요한시기에 대해 설명). 8. 요청으로 인해 잠금의 잠금 루트가 매핑되지 않은 URL이되면 해당 요청에 의해 잠금도 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">이 섹션에서는 웹 리소스 유형, 컬렉션에 대한 설명과 HTTP URL 네임 스페이스 및 HTTP 메서드와의 상호 작용에 대해 설명합니다. 콜렉션 자원의 목적은 서버의 네임 스페이스 내에서 콜렉션과 유사한 오브젝트 (예 : 파일 시스템 디렉토리)를 모델링하는 것입니다. 모든 DAV 호환 리소스는 여기에 지정된 HTTP URL 네임 스페이스 모델을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">이 섹션에서는 몇 가지 일반적인 보안 정책 시나리오의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">이 섹션에서는 버전 HTTP / 1.0과 HTTP / 1.1의 주요 차이점을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">이 섹션은 다른 방법에 대한 유사한 섹션과 마찬가지로 PROPFIND에 특히 유용 할 수있는 오류 코드 및 사전 조건 또는 사후 조건 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16에&lt;/a&gt; 정의 됨)에 대한 지침을 제공 합니다. 403 금지-서버는 깊이 헤더가 &quot;Infinity&quot;인 컬렉션에 대한 PROPFIND 요청을 거부 할 수 있습니다.이 경우 오류 본문 내에서 사전 조건 코드 'propfind-finite-depth'와 함께이 오류를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">이 간단한 HTML 파일은 브라우저에 표시되지 않고 일반 다운로드로 저장됩니다. 대부분의 브라우저는 기본적으로 &lt;code&gt;cool.html&lt;/code&gt; 파일 이름으로 파일 을 저장하도록 제안합니다 .</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">이 간단한 모델은 성능면에서 본질적인 한계를 가지고있었습니다. 각 TCP 연결을 여는 것은 리소스를 소비하는 작업입니다. 클라이언트와 서버간에 여러 메시지를 교환해야합니다. 네트워크 대기 시간 및 대역폭은 요청을 보내야 할 때 성능에 영향을줍니다. 최신 웹 페이지에는 필요한 양의 정보를 제공하기 위해 많은 요청 (12 개 이상)이 필요하므로이 초기 모델은 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">이 솔루션은 하나의 etag 만 조건에서 사용될 수 있으므로보다 효율적이지만 약간 덜 유연합니다. 그러한 추가적인 유연성이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">이 사양은 &quot;edit&quot;값을 링크 관계의 Atom 레지스트리에 추가합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]의 7.1 절&lt;/a&gt; 참조 ). &quot;edit&quot;값은 href 속성 값이 편집 가능한 멤버 항목의 IRI임을 지정합니다. atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목이 나타내는 자원을 검색, 업데이트 및 삭제할 수 있습니다. atom : entry는 하나 이상의 &quot;편집&quot;링크 관계를 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">이 사양은 &quot;edit-media&quot;값을 링크 관계의 Atom 레지스트리에 추가합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287] 섹션 7.1&lt;/a&gt; 참조 )). atom : entry 내에 나타날 때 href 속성의 값은 해당 항목과 연관된 매체 자원을 수정하는 데 사용할 수있는 IRI입니다. atom : entry 요소는 0 개 이상의 &quot;미디어 편집&quot;링크 관계를 포함 할 수 있습니다. atom : entry는 &quot;rel&quot;속성 값이 &quot;edit-media&quot;인 &quot;type&quot;및 &quot;hreflang&quot;속성 값이 같은 atom : link 요소를 두 개 이상 포함해서는 안됩니다. 동일한 항목의 모든 &quot;편집 매체&quot;링크 관계는 동일한 자원을 참조합니다. 클라이언트가 엔트리에서 여러 개의 &quot;미디어 편집&quot;링크 관계를 발견하면 &quot;type&quot;및 &quot;hreflang&quot;에 대한 클라이언트 기본 설정을 기반으로 링크를 선택해야합니다. 클라이언트가 여러 &quot;편집 미디어&quot;를 발견 한 경우항목의 링크 관계와 &quot;type&quot;및 &quot;hreflang&quot;속성을 기반으로하는 기본 설정이없는 경우 클라이언트는 문서 순서에서 첫 번째 &quot;미디어 편집&quot;링크 관계를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">이 사양은 &quot;application / atom + xml&quot;미디어 유형과 함께 사용할 새로운 &quot;type&quot;매개 변수를 정의합니다. &quot;type&quot;매개 변수의 값은 &quot;entry&quot;또는 &quot;feed&quot;입니다. 매개 변수 이름과 값은 대소 문자를 구분하지 않습니다. &quot;entry&quot;값은 매체 유형이 원자 항목 문서를 식별 함을 나타냅니다. 문서의 루트 요소는 atom : entry 여야합니다. &quot;feed&quot;값은 미디어 유형이 Atom Feed Document를 식별 함을 나타냅니다. 문서의 루트 요소는 atom : feed 여야합니다. 지정되지 않은 경우 유형이 지정되지 않은 것으로 간주되므로 Atom 프로세서는 Atom 문서의 유형을 판별하기 위해 루트 요소를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">이 사양은 &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 내에서 제어를 공개하기 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 Atom 형식 구조 확장을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">이 사양은 HTTP 상태 코드를 정의합니다 .o 207 다중 상태 ( &lt;a href=&quot;#section-11.1&quot;&gt;섹션 11.1&lt;/a&gt; ) o 422 처리 할 수없는 엔티티 ( &lt;a href=&quot;#section-11.2&quot;&gt;섹션 11.2&lt;/a&gt; ), o 423 잠금 ( &lt;a href=&quot;#section-11.3&quot;&gt;섹션 11.3&lt;/a&gt; ), o 424 실패 종속성 ( &lt;a href=&quot;#section-11.4&quot;&gt;섹션 11.4&lt;/a&gt; ) 및 o 507 스토리지 부족 ( &lt;a href=&quot;#section-11.5&quot;&gt;섹션 11.5&lt;/a&gt; ) &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 의 레지스트리에서 업데이트됩니다 . 참고 :이 사양에서는 HTTP 상태 코드 102 (처리 중)가 제거되었습니다. IANA 등록은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518을&lt;/a&gt; 계속 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">이 규격은 두 가지 URI 체계를 정의한다 : 1. &lt;a href=&quot;#appendix-C&quot;&gt;부록 C에&lt;/a&gt; 정의 된 &quot;opaquelocktoken&quot;체계 , 2. 역사적으로 WebDAV 속성과 XML 요소 이름을 명확하게하기 위해 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 에서 사용 된 &quot;DAV&quot;URI 체계 이 사양 및 WebDAV를 확장하는 기타 목적에서 사용됩니다. &quot;DAV :&quot;네임 스페이스에서 식별자 생성은 IETF에 의해 제어됩니다. XML 네임 스페이스에 대한 새 URI 체계를 정의하는 것은 권장되지 않습니다. &quot;DAV :&quot;는 표준 모범 사례가 나타나기 전에 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">이 사양은 자원 상태를 관찰하고 전제 조건을 테스트하는 데 일반적으로 사용되는 두 가지 형식의 메타 데이터 인 수정 날짜 ( &lt;a href=&quot;#section-2.2&quot;&gt;섹션 2.2&lt;/a&gt; )와 불투명 엔티티 태그 ( &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; )를 정의합니다. 리소스 상태를 반영하는 추가 메타 데이터 는이 사양의 범위를 벗어난 WebDAV, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ] 와 같은 HTTP의 다양한 확장에 의해 정의되었습니다 . 리소스 메타 데이터 값은 사전 조건 내에서 사용될 때 &quot;유효성 검사기&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">이 사양은 범주 문서와 서비스 문서의 두 종류의 문서를 정의합니다. 카테고리 문서 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; )에는 Atom Syndication Format의 &quot;atom : category&quot;요소를 사용하여 지정된 카테고리 목록이 포함되어 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;[RFC4287]의 섹션 4.2.2&lt;/a&gt; 참조 ). 서비스 문서 ( &lt;a href=&quot;#section-8&quot;&gt;섹션 8&lt;/a&gt; )는 사용 가능한 콜렉션을 작업 공간으로 그룹화합니다. 네임 스페이스의 이름은 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-XML-이름은&lt;/a&gt; 문서의 두 종류이기] : &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; 아톰 출판 프로토콜 XML 문서가 있어야한다 &quot;네임 스페이스-잘 형성&quot;의 7 절에 규정 된 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml- 이름&lt;/a&gt;]. 이 사양에서는 네임 스페이스 이름으로 접두사 &quot;app :&quot;를 사용합니다. 접두사 &quot;atom :&quot;은 &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;에 사용 되며 Atom 신디케이션 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 네임 스페이스 이름입니다 . 이러한 네임 스페이스 접두사는 의미 상 중요하지 않습니다. 이 사양에서는 Atom 프로토콜 형식에 대한 DTD를 정의하지 않으므로 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]에서 사용하는 의미에서 &quot;유효한&quot;형식 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">이 사양에서는 기존 컬렉션에 대한 PUT 메서드의 동작을 정의하지 않습니다. 기존 컬렉션에 대한 PUT 요청은 오류로 처리 될 수 있습니다 (405 Method Not Allowed). MKCOL 메소드는 콜렉션을 작성하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">이 사양에서는 공간과 시간에 걸쳐 고유성을 보장하기 위해 잠금 토큰 ( &lt;a href=&quot;#section-6.5&quot;&gt;6.5 절&lt;/a&gt; )에 &quot;UUID (Universally Unique Identifier) ​​URN 네임 스페이스&quot;([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ])를 사용하도록 권장합니다 . 버전 1 UUID ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의 됨)) &quot;노드&quot;필드를 포함 할 수 있습니다. &quot;일반적으로 호스트 주소 인 IEEE 802 MAC 주소로 구성됩니다. IEEE 주소가 여러 개인 시스템의 경우 사용 가능한 주소를 사용할 수 있습니다&quot;. WebDAV 서버는 수명 기간 동안 많은 잠금을 발행하므로 IEEE 802 주소를 공개적으로 노출 할 수도 있습니다. IEEE 802 주소 노출과 관련된 몇 가지 위험이 있습니다. IEEE 802 주소 사용 : o 서브넷에서 서브넷으로의 하드웨어 이동을 추적 할 수 있습니다. o WebDAV 서버를 실행하는 하드웨어 제조업체를 식별 할 수 있습니다. o WebDAV를 실행하는 각 컴퓨터 유형의 수를 결정할 수 있습니다. 이 위험은 호스트 주소 기반 UUID 버전에만 적용됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;[RFC4122]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;섹션 &lt;/a&gt;4호스트 주소를 포함하지 않으므로 UUID를 생성하기위한 몇 가지 다른 메커니즘을 설명하므로 이러한 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">이 사양은 키워드 사용을 수정하고 명확하게하기 위해 신중하게 감사되었습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ] 에 제시된 규칙과 관련하여 많은 문제가있었습니다 . 인바운드 서버 오류 (예 : DNS 오류)에 사용해야하는 오류 코드가 명확 해졌습니다. ( &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5 항&lt;/a&gt; ). CREATE에는 리소스를 처음 만들 때 Etag를 보내야하는 경쟁이있었습니다. ( &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2 항&lt;/a&gt; ). Content-Base가 사양에서 삭제되었습니다. 광범위하게 구현되지 않았으며 강력한 확장 메커니즘없이 간단하고 안전하게 도입 할 수있는 방법이 없습니다. 또한 MHTML에서 유사하지만 동일하지 않은 방식으로 사용됩니다. [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]. 전송 코딩 및 메시지 길이는 모두 청크 분할 인코딩을 사용할 때 (자체 구분이 아닌 전송 인코딩을 허용하기 위해) 정확하게 수정해야하는 방식으로 상호 작용합니다. 메시지 길이 계산 방법을 정확하게 정리하는 것이 중요했습니다. (섹션 3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16) 캐싱에서 발견 된 문제를 해결하기 위해 &quot;identity&quot;의 컨텐츠 코딩이 도입되었습니다. ( &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt; ) 품질 값이 0 인 경우 고객이 표현을 거부 할 수 있도록 &quot;나는 원하지 않습니다&quot;가 표시되어야합니다. ( &lt;a href=&quot;#section-3.9&quot;&gt;3.9 절&lt;/a&gt; ) &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145에&lt;/a&gt; 의해 HTTP 버전 번호의 사용 및 해석이 명확 해졌습니다.. 프록시가 HTTP / 1.0 구현에서 발견 된 문제점을 처리하기 위해 지원하는 최고 프로토콜 버전으로 요청을 업그레이드해야합니다 ( &lt;a href=&quot;#section-3.1&quot;&gt;3.1 절&lt;/a&gt; ). ( &lt;a href=&quot;#section-14.2&quot;&gt;14.2 절&lt;/a&gt; ) HTTP / 1.1의 캐시 제어 모델에서 사례가 누락되었습니다. 이 누락 사례를 추가하기 위해 s-maxage가 도입되었습니다. (섹션 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; , &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; , &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; , 14.9.3) Cache-Control : max-age 지시문이 응답에 대해 올바르게 정의되지 않았습니다. ( &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3 항&lt;/a&gt;) 서버 (특히 프록시)가 응답의 전체 길이를 모르지만 바이트 범위 요청을 처리 할 수있는 상황이 있습니다. 따라서 메시지의 전체 길이를 나타내지 않는 내용 범위의 바이트 범위를 허용하는 메커니즘이 필요합니다. ( &lt;a href=&quot;#section-14.16&quot;&gt;14.14 절&lt;/a&gt; ) 모든 메타 데이터가 항상 반환되면 범위 요청 응답은 매우 장황해진다. 서버가 206 응답으로 필요한 헤더 만 보내도록 허용함으로써이 문제를 피할 수 있습니다. ( &lt;a href=&quot;#section-10.2.7&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3 및 14.27) 만족할 수없는 범위 요청 문제를 해결합니다. 구문상의 문제와 문서에 범위가 존재하지 않는 두 가지 경우가 있습니다. 416 상태 코드는 문서의 실제 내용을 벗어나는 바이트 범위 요청에 대한 오류를 나타내는 데 필요한이 모호성을 해결하는 데 필요했습니다. ( &lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt;, 14.16) 오류로 인한 결과가 인터넷에 중대한 영향을 미치고 다음과 같은 문제를 처리 할 수 ​​있기 때문에 구현자가 실수를 저지르기가 더 어려워 지도록 메시지 전송 요구 사항을 다시 작성하십시오. 1. &quot;HTTP / 1.1 또는 나중에 HTTP / 1.x 2의 구현 동작에 대한 요구 사항을 잘못 요구하는 상황에서 나중에 &quot;HTTP / 1.1&quot;으로 변경하십시오. 사용자 에이전트가 &quot;클라이언트가 아닌 요청을 다시 시도해야 함을 분명히했습니다.&quot; &quot;일반적으로 3. 클라이언트가 예기치 않은 100 (계속) 응답을 무시하고 프록시가 100 응답을 전달하도록 요구 사항을 1xx 응답의 일반 요구 사항으로 변환했습니다. 4. 일부 TCP 관련 언어를 수정했습니다.비 TCP 전송이 HTTP에 가능하다는 것을보다 명확하게하기 위해. 5. 오리진 서버가 요구 된 100 (계속) 응답을 보내기 전에 요청 본문을 기다리지 않아야합니다. 6. 서버가 요청 본문 중 일부를 이미 본 경우 서버가 필요하지 않고 100 (계속)을 생략하도록 허용하십시오. 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.요청 본문 중 일부를 이미 본 경우 100 (계속)을 생략하는 서버 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.요청 본문 중 일부를 이미 본 경우 100 (계속)을 생략하는 서버 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; , &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; , 8.1.2.2, 13.11 및 14.20. 프록시는 적절한 경우 Content-Length를 추가 할 수 있어야합니다. ( &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2 절&lt;/a&gt; ) 403과 404 응답 사이의 혼란을 정리하십시오. ( &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; , 10.4.5 및 10.4.11 섹션 ) 경고가 잘못 캐시되거나 적절하게 업데이트되지 않을 수 있습니다. ( &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2 항&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3 및 14.46) 경고는 PUT 또는 기타 방법이 요청에 필요할 수 있으므로 일반 헤더 여야합니다. 전송 코딩은 특히 청크 인코딩과의 상호 작용에 중대한 문제가있었습니다. 해결책은 전송 코딩이 콘텐츠 코딩만큼 본격화되는 것입니다. 전송 코딩 (컨텐츠 코딩과는 별도)을위한 IANA 레지스트리 추가, 새로운 헤더 필드 (TE) 및 향후 트레일러 헤더 활성화가 포함됩니다. 전송 인코딩은 성능상의 주요 이점이므로 수정할 가치가 있습니다 [ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]. TE는 또한 인증 트레일러, 청크 인코딩 및 HTTP / 1.0 클라이언트 간의 상호 작용으로 인해 발생할 수있는 모호하지 않은 하향 상호 운용성 문제를 해결합니다 ( &lt;a href=&quot;#section-3.6&quot;&gt;3.6 절)&lt;/a&gt; ., 3.6.1 및 14.39) PATCH, LINK, UNLINK 방법이 정의되었지만이 사양의 이전 버전에서는 일반적으로 구현되지 않았습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]를 참조하십시오 . Alternates, Content-Version, Derived-From, Link, URI, Public 및 Content-Base 헤더 필드는이 사양의 이전 버전에서 정의되었지만 일반적으로 구현되지 않았습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 에 David H. Crocker에 의해 정의 된 증강 BNF 및 일반 구성을 많이 사용합니다 . 마찬가지로, Nathaniel Borenstein과 Ned Freed가 제공 한 많은 정의를 MIME에 재사용합니다. [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. 이 사양에 포함 시키면 HTTP와 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄일 수 있기를 바랍니다. HTTP 프로토콜은 수년에 걸쳐 상당히 발전했습니다. 이 사이트는 www-talk 메일 링리스트에 참여한 많은 사람들이 참여하는 대규모의 활발한 개발자 커뮤니티의 혜택을 받았으며 HTTP 및 World-Wide Web의 성공에 가장 큰 책임을지는 커뮤니티입니다. 일반. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders 및 Marc VanHeyningen은 프로토콜의 초기 측면을 정의하려는 노력에 대해 특별한 인정을받을 자격이 있습니다.이 문서는 HTTP-WG에 참여하는 모든 사람들의 의견에서 큰 도움이되었습니다. 이미 언급 한 것 외에도 다음과 같은 개인이이 사양에 기여했습니다. Gary Adams Ross Patterson Harald Tveit Alvestrand Albert Lunde Keith Ball John C. Mallery Brian Behlendorf Jean-Plipin Martin-Flatin Paul Burchard Mitra Maurizio Codogno David Morris Mike Cowlishaw Gavin Nicol Roman Czyborra 빌 페리 Michael A. Dolan Jeffrey Perry David J.Fiander Scott Powers Alan Freier Owen Rees Marc Hedlund Luigi Rizzo Greg Herlihy David Robinson Koen Holtman Marc Salomon Alex Hopmann Rich Salz Bob Jernigan Allan M. Schiffman Shel Kaphan Jim Seidman Rohit Khare Chuck Shotton John Klensin Eric W. Sink Martijn Koster Simon E. Spero Alexei Kosut Richard N. Taylor David M. Kristol Robert S. Thau Daniel LaLiberte Bill (베어 하트) Weinman Ben Laurie Francois Yergeau Paul J.Leach Mary Ellen Zurko Daniel DuBois Josh Cohen 캐싱 디자인의 내용과 프레젠테이션은 Shel Kaphan, Paul Leach, Koen Holtman, David Morris 및 Larry Masinter를 포함한 개인의 제안과 의견에 의한 것입니다. 범위 사양의 대부분은 Ari Luotonen과 John Franks가 원래 수행 한 작업을 기반으로하며 Steve Zilles의 추가 정보를 제공합니다. 팔로 알토의 &quot;동굴 남자&quot;에게 감사합니다. 넌 네가 누구인지 안다. Jim Gettys (현재이 문서의 편집자)는 John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann,이 문서의 이전 편집자 인 Roy Fielding에게 감사의 말씀을 전합니다. Scott Lawrence와 Larry Masinter의 도움을 받았습니다.&quot;MUST / MAY / SHOULD&quot;감사를 수행해 주신 Jeff Mogul과 Scott Lawrence에게 감사드립니다. Apache Group, Anselm Baird-Smith, Jigsaw의 저자 및 Henrik Frystyk가 구현했습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 초기에이 문서에서 해결하려는 많은 문제를 발견해 주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">이 스펙은 터널로 동적 전환 할 수있는 프록시와 함께 사용하기 위해 메소드 이름 CONNECT를 예약합니다 (예 : SSL 터널링 [ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">이 사양은 이전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; 에 정의 된 HTTP 인증 프레임 워크의 정의를 대체 합니다. John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen 및 Lawrence C. Stewart가이 사양에 대한 작업을 해주셔서 감사합니다. 추가 승인에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;[RFC2617]의 섹션 6을&lt;/a&gt; 참조하십시오 . 이 문서 개정과 관련된 승인에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]의 섹션 10을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">이 사양은 HTTP 통신에서 참가자의 역할에 따른 적합성 기준을 대상으로합니다. 따라서 HTTP 요구 사항은 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 오리진 서버, 프록시, 게이트웨이 또는 캐시에 적용됩니다. 구현, 리소스 소유자 및 프로토콜 요소 등록이 단일 통신 범위를 넘어 적용되는 경우 추가 (사회적) 요구 사항이 적용됩니다. 요구 사항이 프로토콜 요소를 작성하는 것과 수신 된 요소를 다운 스트림으로 전달하는 것만 구별하는 &quot;보내기&quot;대신 &quot;생성&quot;동사가 사용됩니다.구현이 HTTP에서 수행하는 역할과 관련된 모든 요구 사항을 준수하는 경우 적합한 것으로 간주됩니다. 적합성에는 프로토콜 요소의 구문과 의미가 모두 포함됩니다. 발신자는 발신자가 알고있는 의미를 거짓으로 나타내는 프로토콜 요소를 생성해서는 안됩니다. 발신자는 해당 ABNF 규칙에 의해 정의 된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안된다 (MUST NOT). 주어진 메시지 내에서, 발신자는 다른 역할 (즉, 발신자가 그 메시지에 대해 가지고 있지 않은 역할)의 참가자 만이 생성 할 수있는 프로토콜 요소 나 구문 대안을 생성해서는 안된다 (MUST NOT). 수신 된 프로토콜 요소가 구문 분석 될 때 수신자는 수신자에게 적용 가능한 합리적인 길이의 값을 구문 분석 할 수 있어야합니다.역할과 해당 ABNF 규칙에 의해 정의 된 문법과 일치합니다. 그러나 일부 수신 된 프로토콜 요소는 구문 분석되지 않을 수 있습니다. 예를 들어, 메시지를 전달하는 중개자는 헤더 필드를 일반 필드 이름 및 필드 값 컴포넌트로 구문 분석 할 수 있지만 필드 값 내부에서 추가 구문 분석을하지 않고 헤더 필드를 전달할 수 있습니다. HTTP는 많은 프로토콜 요소에 대한 특정 길이 제한이 없습니다. 배포 길이와 구현 목적에 따라 적절한 길이가 크게 달라질 수 있기 때문입니다. 따라서, 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소의 합리적인 길이에 대한 공유 된 기대에 달려 있습니다. 더욱이,일부 프로토콜 요소에 대해 합리적인 길이로 일반적으로 이해되는 것은 지난 20 년간의 HTTP 사용 과정에서 변경되었으며 앞으로도 계속 변경 될 것으로 예상됩니다. 최소한 수신자는 다른 메시지에서 동일한 프로토콜 요소에 대해 생성 한 값만큼 최소한 프로토콜 요소 길이를 구문 분석하고 처리 할 수 ​​있어야합니다. 예를 들어, 매우 긴 URI 참조를 자체 자원에 공개하는 오리진 서버는 요청 대상으로 수신 될 때 동일한 참조를 구문 분석하고 처리 할 수 ​​있어야합니다. 수신자는 반드시이 규격에 대한 확장을 포함하여 본 규격에 의해 정의 된 의미론에 따라 수신 된 프로토콜 요소를 해석해야한다.수신자가 (경험이나 구성을 통해) 발신자가 해당 의미에 의해 암시 된 것을 잘못 구현 한 것으로 판단하지 않는 한. 예를 들어, User-Agent 헤더 필드의 검사가 특정 컨텐츠 코딩의 수신에 실패한 것으로 알려진 특정 구현 버전을 나타내는 경우, 오리진 서버는 수신 된 Accept-Encoding 헤더 필드의 컨텐츠를 무시할 수 있습니다. 달리 언급되지 않는 한, 수신자는 유효하지 않은 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도 할 수있다. 프로토콜의 응용 프로그램마다 다른 오류 처리 전략이 필요하기 때문에 HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않습니다. 예를 들어웹 브라우저는 ABNF에 따라 Location 헤더 필드가 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하지만 시스템 제어 클라이언트는 모든 형태의 오류 복구를 위험한 것으로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">이 표준은 여러 용어를 사용하여 HTTP 통신의 참여자 및 대상이 수행하는 역할을 나타냅니다. 연결 통신 목적으로 두 프로그램간에 설정된 전송 계층 가상 회로. 메시지 HTTP 통신의 기본 단위로, &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의되어 있고 연결을 통해 전송 된 구문과 일치하는 구조화 된 옥텟 시퀀스로 구성됩니다 . request &lt;a href=&quot;#section-5&quot;&gt;섹션 5에&lt;/a&gt; 정의 된 HTTP 요청 메시지 . response &lt;a href=&quot;#section-6&quot;&gt;6 절에&lt;/a&gt; 정의 된 HTTP 응답 메시지 . resource &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절에&lt;/a&gt; 정의 된 URI로 식별 할 수있는 네트워크 데이터 객체 또는 서비스. 리소스는 여러 가지 표현 (예 : 여러 언어, 데이터 형식, 크기 및 해상도)으로 제공되거나 다른 방식으로 달라질 수 있습니다. 엔티티 요청 또는 응답의 페이로드로 전송 된 정보입니다. 엔터티는 &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; 에서 설명한 것처럼 엔터티 헤더 필드 형식의 메타 정보와 엔터티 본문 형식의 콘텐츠로 구성됩니다 . 표현 &lt;a href=&quot;#section-12&quot;&gt;12 절에&lt;/a&gt; 기술 된 바와 같이, 내용 협상을받는 응답에 포함 된 실체 . 특정 응답 상태와 관련된 여러 표현이있을 수 있습니다. 내용 협상 &lt;a href=&quot;#section-12&quot;&gt;섹션 12에&lt;/a&gt; 설명 된대로 요청을 처리 할 때 적절한 표현을 선택하는 메커니즘. 응답에서 엔터티 표현을 협상 할 수 있습니다 (오류 응답 포함). 변형 자원은 임의의 주어진 순간에 그와 관련된 하나 이상의 표현 (들)을 가질 수있다. 이 표현들은 각각 '변종'이라고합니다. '변형 (variant)'이라는 용어를 사용한다고해서 반드시 자원이 내용 협상을 받아야한다는 것을 의미하지는 않습니다. 클라이언트 요청을 보내기 위해 연결을 설정하는 프로그램입니다. 사용자 에이전트 요청을 시작하는 클라이언트입니다. 이들은 종종 브라우저, 편집자, 스파이더 (웹 탐색 로봇) 또는 기타 최종 사용자 도구입니다. 서버 응답을 다시 보내 요청을 처리하기 위해 연결을 수락하는 응용 프로그램.임의의 주어진 프로그램은 클라이언트 및 서버 둘 다일 수있다; 이러한 용어의 사용은 일반적으로 프로그램의 기능이 아니라 특정 연결에 대해 프로그램이 수행하는 역할만을 나타냅니다. 마찬가지로 모든 서버는 원본 서버, 프록시, 게이트웨이 또는 터널로 작동하여 각 요청의 특성에 따라 동작을 전환 할 수 있습니다. 오리진 서버 지정된 자원이 상주하거나 작성 될 서버. 프록시 다른 클라이언트를 대신하여 요청을하기 위해 서버와 클라이언트의 역할을하는 중개 프로그램입니다. 요청은 내부적으로 또는 가능한 번역을 통해 다른 서버로 전달하여 서비스됩니다. 프록시는 반드시이 사양의 클라이언트 및 서버 요구 사항을 모두 구현해야합니다.&quot;투명 프록시&quot;는 프록시 인증 및 식별에 필요한 것 이상으로 요청 또는 응답을 수정하지 않는 프록시입니다. &quot;투명한 프록시&quot;는 그룹 주석 서비스, 미디어 유형 변환, 프로토콜 축소 또는 익명 필터링과 같은 추가 에이전트 서비스를 사용자 에이전트에 제공하기 위해 요청 또는 응답을 수정하는 프록시입니다. 투명하거나 투명하지 않은 동작이 명시 적으로 언급 된 경우를 제외하고 HTTP 프록시 요구 사항은 두 가지 유형의 프록시 모두에 적용됩니다. 게이트웨이 다른 서버의 중개자 역할을하는 서버. 프록시와 달리 게이트웨이는 요청 된 자원의 원래 서버 인 것처럼 요청을 수신합니다.요청 클라이언트는 게이트웨이와 통신하고 있음을 인식하지 못할 수 있습니다. 터널 두 연결 사이의 블라인드 릴레이 역할을하는 중개 프로그램. 터널이 HTTP 요청에 의해 시작되었을 수 있지만 터널이 활성화되면 HTTP 통신의 당사자로 간주되지 않습니다. 중계 된 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. 캐시 응답 메시지의 프로그램 로컬 저장소 및 해당 메시지 저장소, 검색 및 삭제를 제어하는 ​​하위 시스템. 캐시는 캐시 가능한 응답을 저장하여 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트 나 서버에는 캐시가 포함될 수 있지만 터널로 작동하는 서버는 캐시를 사용할 수 없습니다.캐시 가능 캐시가 후속 요청에 응답하기 위해 응답 메시지의 사본을 캐시에 저장하도록 허용 된 경우 응답을 캐시 할 수 있습니다. HTTP 응답의 캐시 가능성을 결정하기위한 규칙은&lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;. 리소스가 캐시 가능한 경우에도 캐시가 특정 요청에 대해 캐시 된 복사본을 사용할 수 있는지 여부에 대한 추가 제약이있을 수 있습니다. 직접 응답 하나 이상의 프록시를 통해 오리진 서버에서 불필요한 지연없이 직접 발생하는 경우 직접 응답합니다. 응답이 원래 서버에서 직접 확인 된 경우에도 직접 응답합니다. 명시 적 만기 시간 원래 서버가 더 이상 유효성 검증없이 캐시가 엔티티를 더 이상 리턴하지 않도록 의도 한 시간입니다. 휴리스틱 만료 시간 명시적인 만료 시간이 없을 때 캐시에 의해 할당 된 만료 시간입니다. age 응답의 나이는 오리진 서버에 의해 전송되거나 검증 된 이후의 시간입니다.신선도 수명 응답 생성과 만료 시간 사이의 시간입니다. 신선도 나이가 신선도 수명을 아직 초과하지 않은 경우 반응이 신선합니다. 부실 나이가 신선도 수명을 지났 으면 응답이 부실합니다. 의미 적으로 투명성 캐시는 성능 향상을 제외하고는 사용이 요청 클라이언트 나 오리진 서버에 영향을 미치지 않을 때 특정 응답과 관련하여 &quot;의도적으로 투명하게&quot;동작합니다. 캐시가 의미 적으로 투명한 경우 클라이언트는 요청이 오리진 서버에 의해 직접 처리 된 경우 수신 한 것과 동일한 응답 (홉별 헤더 제외)을 수신합니다. 유효성 검사기 프로토콜 요소 (예 :캐시 항목이 엔티티의 동등한 사본인지 여부를 확인하는 데 사용되는 엔티티 태그 또는 Last-Modified 시간). 업스트림 / 다운 스트림 업스트림 및 다운 스트림은 메시지 흐름을 설명합니다. 모든 메시지는 업스트림에서 다운 스트림으로 흐릅니다. 인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;#section-7&quot;&gt;섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*' '연산자는 반복을 나타냅니다). &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;부록 B.1 [RFC5234]에&lt;/a&gt; 정의 된대로 다음 핵심 규칙이 참조로 포함됩니다. : ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (컨트롤), DIGIT (10 진수 0-9), DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), HTAB (수평 탭), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시 [ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ] 문자). 관례 적으로, &quot;obs-&quot;접두사가 붙은 ABNF 규칙 이름은 역사적 이유로 나타나는 &quot;사용되지 않는&quot;문법 규칙을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; 에서는 다른 문서에서 가져온 규칙에 대해 설명합니다. &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 다른 문서에서 가져온 규칙을 설명합니다. &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 다른 문서에서 가져온 규칙을 설명합니다. &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다. 본 명세서는 용어 &quot;문자&quot;, &quot;문자 인코딩 체계&quot;, &quot;문자 세트&quot;및 &quot;프로토콜 요소&quot;를 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]에 정의 된 바와 같이 사용 한다.</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">이 사양에서는 선형 공백 사용을 나타내는 세 가지 규칙 인 OWS (선택적 공백), RWS (필수 공백) 및 BWS ( &quot;나쁜&quot;공백)를 사용합니다. OWS 규칙은 0 개 이상의 선형 공백 옥텟이 나타날 수있는 곳에 사용됩니다. 가독성을 개선하기 위해 선택적 공백이 선호되는 프로토콜 요소의 경우, 발신자는 선택적 SP를 단일 SP로 생성해야합니다. 그렇지 않으면 발신자는 전체 메시지 필터링 중에 유효하지 않거나 원치 않는 프로토콜 요소를 제거하는 데 필요한 경우를 제외하고 선택적 공백을 생성하지 않아야합니다. RWS 규칙은 필드 토큰을 분리하기 위해 하나 이상의 선형 공백 옥텟이 필요한 경우에 사용됩니다. 발신자는 RWS를 단일 SP로 생성해야합니다. BWS 규칙은 문법이 역사적 이유로 만 선택적 공백을 허용하는 경우에 사용됩니다.발신자는 메시지에서 BWS를 생성해서는 안됩니다. 수신자는 이러한 잘못된 공백을 구문 분석하고 프로토콜 요소를 해석하기 전에 제거해야합니다. OWS = * (SP / HTAB); 선택적 공백 RWS = 1 * (SP / HTAB); 필요한 공백 BWS = OWS; &quot;나쁜&quot;공백</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">이 명세서 [에서 설명한 등록 메커니즘에 부합 개의 새로운 미디어 타입 사용 &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ] 레지스트리 메커니즘에 부합는 [에서 설명한 새로운 메시지 헤더 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; [에서 설명한 등록 메커니즘에 부합], 2 개 개의 새로운 링크 관계 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287을&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">이 상태 코드는 HTTP 1.1에서 다른 위치의 URI가 아닌 Request-URI에 대해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">이 상태는 오리진 서버가 아니라 네트워크 액세스를 제어하는 ​​프록시를 가로 채서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">이 상태는 올바르게 인증하는 방법에 대한 정보가 포함 된 &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">이 상태는 올바르게 권한 부여하는 방법에 대한 정보가 포함 된 &lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">이 상태는 &lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만이 경우 다시 인증해도 아무런 차이가 없습니다. 액세스 권한이 영구적으로 금지되며 리소스에 대한 권한이 충분하지 않은 등의 응용 프로그램 논리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">이 상태는 &lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; 과 유사 하지만이 경우 인증이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">이 기술에는 추가 이점이 있습니다. 두 개의 캐시 된 리소스를 동시에 업데이트해도 한 리소스의 오래된 버전이 다른 리소스의 새 버전과 함께 사용되는 상황이 발생하지 않습니다. 이는 웹 사이트에 상호 의존성을 갖는 CSS 스타일 시트 또는 JS 스크립트가있는 경우 매우 중요합니다. 즉, 동일한 HTML 요소를 참조하기 때문에 서로 의존합니다.</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">이 값은 &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt; 매개 변수를 사용하여 수정할 수 있습니다 . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">이 값은 &lt;code&gt;image.http.accept&lt;/code&gt; 매개 변수를 사용하여 수정할 수 있습니다 . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">이는 CORS 헤더를 사용하여 권한을 처리하여 클라이언트와 서버 사이를 간단하게 교환합니다.</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">이것은 클라이언트가 시작한 업그레이드와 거의 같은 방식으로 작동합니다. 메시지에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더를 추가하여 선택적 업그레이드를 요청 합니다. 그러나 필수 업그레이드는 다음과 같이 &lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt; 상태 코드로 수신되는 메시지에 응답하여 업그레이드를 요청한다는 점에서 약간 다르게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">이를 통해 Mozilla, Google, Microsoft 및 Apple 도메인의 CORS 요청이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">기능 정책은 일관된 구문을 사용하여 여러 기능을 제어 할 수 있지만 정책 제어 기능의 동작은 다양하며 여러 요인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2는 성능을 향상시키기 위해 프레임에 HTTP 메시지를 임베드하여 약간의 복잡성을 추가하지만 메시지의 기본 구조는 HTTP / 1.0 이후로 동일하게 유지되었습니다. 세션 흐름은 단순하게 유지되므로 간단한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP 메시지 모니터&lt;/a&gt; 로이를 조사하고 디버깅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하지만 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지침이되지 않는 대체하기위한 것입니다 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지침을 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 아직 대부분의 브라우저에서 지원되지 않습니다. 따라서 브라우저가 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지원할 때 호환성을 추가하면서 현재 브라우저와의 호환성 을 위해 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 와 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 를&lt;/a&gt; 모두 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하지만 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지침이되지 않는 대체하기위한 것입니다 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지침을 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 아직 대부분의 브라우저에서 지원되지 않습니다. 따라서 브라우저가 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지원할 때 호환성을 추가하면서 현재 브라우저와의 호환성 을 위해 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 와 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 를&lt;/a&gt; 모두 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">컨텐츠를 선택하기 위해이 헤더를 합법적으로 사용하지만 사용자 에이전트가 지원하는 기능을 정의하기 위해이 헤더에 의존하는 것은 &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;나쁜 습관&lt;/a&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">리퍼러에 대한 엄격한 제어 &amp;ndash; Mozilla 보안 블로그</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">시간 기반 조건</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut = &quot;Timeout&quot; &quot;:&quot;1 # TimeType TimeType = ( &quot;Second-&quot;DAVTimeOutVal | &quot;무한&quot;); TimeType 내에 허용 된 LWS가 없습니다. DAVTimeOutVal = 1 * DIGIT 클라이언트는 LOCK 요청에 타임 아웃 요청 헤더를 포함 할 수 있습니다. 그러나 서버는 이러한 요청을 존중하거나 고려할 필요가 없습니다. 클라이언트는 LOCK 메서드 이외의 다른 방법으로 타임 아웃 요청 헤더를 제출해서는 안됩니다. &quot;두 번째&quot;TimeType은 서버에서 잠금 부여와 잠금 자동 제거 사이의 경과 시간 (초)을 지정합니다. TimeType &quot;Second&quot;의 시간 초과 값은 2 ^ 32-1보다 크지 않아야합니다. 잠금 시간 종료 동작에 대한 설명은 &lt;a href=&quot;#section-6.6&quot;&gt;6.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">컬렉션에 멤버를 추가하기 위해 클라이언트는 POST 요청을 컬렉션의 URI로 보냅니다. 성공적인 멤버 작성은 201 ( &quot;Created&quot;) 응답 코드로 표시됩니다. 컬렉션이 상태 코드 201로 응답하면 응답 본문을 반환해야합니다. 응답 본문은 반드시 새로 생성 된 리소스를 나타내는 Atom 항목 문서 여야합니다. 서버는 예를 들어 atom : id 요소의 내용을 변경하여 POST 된 항목을 자유롭게 변경할 수 있으므로 항목을 반환하면 클라이언트에 유용 할 수 있으므로 새 항목의 클라이언트와 서버보기를 상관시킬 수 있습니다. 멤버 리소스가 생성되면 멤버 엔트리 URI는 컬렉션 응답의 Location 헤더에 반환되어야합니다. 작성 요청에 Atom Entry Document가 포함 된 경우서버로부터의 후속 응답은 문자마다 문자의 위치 헤더와 일치하는 Content-Location 헤더를 포함하고, 클라이언트는 응답 엔티티를 새로 생성 된 엔트리의 완전한 표현으로 해석 할 수있다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은보다보다그러면 클라이언트는 응답 엔터티를 새로 생성 된 항목의 완전한 표현으로 해석 할 수 있습니다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.그러면 클라이언트는 응답 엔터티를 새로 생성 된 항목의 완전한 표현으로 해석 할 수 있습니다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.클라이언트는 리턴 된 엔티티가 작성된 자원의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.클라이언트는 리턴 된 엔티티가 작성된 자원의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은)은 POSTed 엔티티의 미디어 유형이 콜렉션에서 허용되거나 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은)은 POSTed 엔티티의 미디어 유형이 콜렉션에서 허용되거나 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은&lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">&lt;code&gt;X-Kuma-Revision&lt;/code&gt; 과 같은 사용자 정의 헤더를 추가로 노출하려면 쉼표로 구분하여 여러 헤더를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">&lt;code&gt;https://developer.mozilla.org&lt;/code&gt; 에서 타이밍 리소스를 볼 수 있도록 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">리소스가 타이밍 리소스를 볼 수있게하려면 :</target>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">인라인 스크립트 및 인라인 이벤트 핸들러를 허용하기 위해 &lt;code&gt;'unsafe-inline'&lt;/code&gt; , nonce-source 또는 인라인 블록과 일치하는 해시 소스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">인라인 스타일을 허용하기 위해 &lt;code&gt;'unsafe-inline'&lt;/code&gt; , 인라인 블록과 일치하는 nonce-source 또는 hash-source를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">폴더 또는 페이지의 하위 집합에만 리디렉션을 적용하려면 &lt;code&gt;rewrite&lt;/code&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">기존 웹 컨텐츠가 손상되는 것을 방지하기 위해 이러한 정책 제어 기능의 기본값은 모든 출처에서 기능을 사용할 수 있도록하는 것입니다. 즉, 기본 허용 목록은 각 기능에 대해 &lt;code&gt;'*'&lt;/code&gt; 입니다. 차선의 기능 사용을 방지하려면 기능을 사용하지 않도록 설정하는 정책을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">모든 페이지에 대해 &lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 Apache를 구성하려면 다음을 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; deny 를 설정하도록 Apache를 구성하려면 이를 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 를 특정 호스트 &lt;code&gt;allow-from&lt;/code&gt; 하도록 Apache를 구성하려면 이를 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 HAProxy를 구성하려면 이를 프론트 엔드, 청취 또는 백엔드 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 IIS를 구성하려면 이를 사이트의 &lt;code&gt;Web.config&lt;/code&gt; 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">Xgin &lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 nginx를 구성하려면 http, 서버 또는 위치 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">클라이언트 측에서이 문제점을 정정하려면 CORS 요청을 발행 할 때 신임 정보 플래그의 값이 &lt;code&gt;false&lt;/code&gt; 인지 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">구성원 자원을 삭제하기 위해 클라이언트는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 지정된대로 구성원 URI에 DELETE 요청을 보냅니다 . 미디어 링크 항목을 삭제하면 해당 미디어 리소스가 삭제되어야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">모든 플러그인을 허용하지 않으려면 &lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt; 지시문을 &lt;code&gt;'none'&lt;/code&gt; 으로 설정해야 플러그인을 허용하지 않습니다. &lt;code&gt;plugin-types&lt;/code&gt; 당신이 플러그인을 허용하는 경우 지시어에만 사용됩니다 &lt;code&gt;object-src&lt;/code&gt; 전혀합니다.</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">보다 세분화 된 수준에서 http 자산을 허용하지 않으려면 개별 지시문을 &quot;https :&quot;로 설정할 수도 있습니다. 예를 들어 안전하지 않은 http 이미지를 허용하지 않으려면 :</target>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이를 위해 HTTP는 엔드-투-엔드 압축을위한 컨텐츠 협상과 유사한 메커니즘을 사용합니다. 요청을 전송하는 노드는 &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; 헤더 를 사용하여 자신의 의지를 알리고 다른 노드는 적절한 방법을 선택하고 적용하며 &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">배포를 쉽게하기 위해 CSP를 보고서 전용 모드로 배포 할 수 있습니다. 정책은 시행되지 않지만 위반 사항은 제공된 URI에보고됩니다. 또한 보고서 전용 헤더를 사용하여 실제로 배포하지 않고 향후 정책 개정을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">멤버 자원을 편집하기 위해 클라이언트는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 지정된대로 PUT 요청을 멤버 URI에 보냅니다 . 멤버 항목 또는 미디어 링크 항목을 편집 할 때 의도하지 않은 데이터 손실을 방지하기 위해 Atom 프로토콜 클라이언트는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 알 수없는 외부 마크 업을 포함하여 의도적으로 수정되지 않은 모든 메타 데이터를 보존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">서버 구성을 변경하여이 오류를 제거하려면 서버 구성을 조정하여 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 헤더 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">CSP를 사용하려면 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더 를 반환하도록 웹 서버를 구성해야합니다 (때로는 &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; 헤더에 대한 언급이 있지만 이전 버전 일 필요는 없음). 더 이상 지정하십시오).</target>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">사이트에서이 기능을 사용하려면 HTTPS를 통해 사이트에 액세스 할 때 &lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; HTTP 헤더 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; 세션 에서 사용되는 서버의 공개 키의 신뢰성을 보장하기 위해이 공개 키는 일반적으로 인증 기관 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt; )에 의해 서명 된 X.509 인증서로 래핑됩니다 . 브라우저와 같은 웹 클라이언트는 이러한 많은 CA를 신뢰하므로 임의의 도메인 이름에 대한 인증서를 만들 수 있습니다. 공격자가 단일 CA를 손상시킬 수 있으면 다양한 TLS 연결에서 MITM 공격을 수행 할 수 있습니다. HPKP는 클라이언트에게 특정 웹 서버에 속하는 공개 키를 알려줌으로써 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; 프로토콜에 대한 이러한 위협을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">단순하지 않은 응답 헤더를 표시하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">서버가 &lt;code&gt;PATCH&lt;/code&gt; 를 지원하는지 여부를 확인하기 위해 서버는 서버를 &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; (CORS) 응답 헤더 의 목록에 추가하여 지원 을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">서버가 지원하는 요청 방법을 찾으려면 curl을 사용하여 OPTIONS 요청을 발행 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
