<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="342c659777997bec12f413246e5e24d6a8317e2a" translate="yes" xml:space="preserve">
          <source>Usage Example</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="31fdeb34a4f4bc8a7b882018ab434e09d2defd44" translate="yes" xml:space="preserve">
          <source>Usage Examples</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="4df13ec4234f96a6f1f82fccdde77669b4c4b95c" translate="yes" xml:space="preserve">
          <source>Usage Notes</source>
          <target state="translated">사용법 메모</target>
        </trans-unit>
        <trans-unit id="3439e83eddd9b986dc9a370152a22cf7dcf9b189" translate="yes" xml:space="preserve">
          <source>Usage example</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="92d99b032888bf69448943e3813f272f0f43c556" translate="yes" xml:space="preserve">
          <source>Usage notes</source>
          <target state="translated">사용법 메모</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3ca40217dc0e70d2dc410e2c690446266314d73f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;component-interaction#countdown-tests&quot;&gt;the same countdown timer tests&lt;/a&gt; as before.</source>
          <target state="translated">이전 &lt;a href=&quot;component-interaction#countdown-tests&quot;&gt;과 동일한 카운트 다운 타이머 테스트&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbdce1a9856fbb51307f203e0fd8807247521091" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/writing-declaration-files.html&quot;&gt;TypeScript type definition files&lt;/a&gt;&amp;mdash;&lt;code&gt;d.ts files&lt;/code&gt;&amp;mdash;to tell the compiler about the libraries you load.</source>
          <target state="translated">사용 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/writing-declaration-files.html&quot;&gt;타이프 라이터 유형 정의 파일&lt;/a&gt; - &lt;code&gt;d.ts files&lt;/code&gt; 은로드 라이브러리에 대한 컴파일러에게 -to.</target>
        </trans-unit>
        <trans-unit id="c534d42b01e57fa797f2c9dd829715b3aaef6e23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ngzone#run&quot;&gt;run&lt;/a&gt; to reenter the Angular zone and do work that updates the application model.</source>
          <target state="translated">&lt;a href=&quot;ngzone#run&quot;&gt;run&lt;/a&gt; 을 사용 하여 각도 영역을 다시 입력하고 응용 프로그램 모델을 업데이트하는 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="11460a33232086c248106ff99715d4babce3c64e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;router#route-parameters&quot;&gt;&lt;em&gt;route parameters&lt;/em&gt;&lt;/a&gt; to specify a &lt;em&gt;required&lt;/em&gt; parameter value &lt;em&gt;within&lt;/em&gt; the route URL as you do when navigating to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; in order to view the hero with &lt;em&gt;id&lt;/em&gt; 15:</source>
          <target state="translated">&lt;em&gt;ID가&lt;/em&gt; 15 인 영웅을 보려면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 탐색 할 때와 같이 &lt;a href=&quot;router#route-parameters&quot;&gt;&lt;em&gt;경로 매개 변수&lt;/em&gt;&lt;/a&gt; 를 사용 하여 경로 URL &lt;em&gt;내에 &lt;/em&gt;&lt;em&gt;필수&lt;/em&gt; 매개 변수 값 을 지정 하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a19d669d6ab0a452aeaf8626b2d9150aebbdc3cf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;/deep/&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;::ng-deep&lt;/code&gt; only with &lt;em&gt;emulated&lt;/em&gt; view encapsulation. Emulated is the default and most commonly used view encapsulation. For more information, see the &lt;a href=&quot;component-styles#view-encapsulation&quot;&gt;Controlling view encapsulation&lt;/a&gt; section.</source>
          <target state="translated">&lt;em&gt;에뮬레이트 된&lt;/em&gt; 뷰 캡슐화 에만 &lt;code&gt;/deep/&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;::ng-deep&lt;/code&gt; 을 사용하십시오 . 에뮬레이트는 가장 일반적으로 사용되는 기본보기 캡슐화입니다. 자세한 내용은 &lt;a href=&quot;component-styles#view-encapsulation&quot;&gt;뷰 캡슐화 제어&lt;/a&gt; 섹션을 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fbc5373a6098820428d8f87b4ebef3596f21ac25" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:increment&lt;/code&gt; and &lt;code&gt;:decrement&lt;/code&gt; to initiate transitions:</source>
          <target state="translated">&lt;code&gt;:increment&lt;/code&gt; 및 &lt;code&gt;:decrement&lt;/code&gt; 를 사용 하여 전환을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="37da0447d1fa140f28f8fb6b08272482bf10d2b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; to apply styling data over a given time interval.</source>
          <target state="translated">주어진 시간 간격 동안 스타일 데이터를 적용 하려면 &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8117b02663c31ca30a3505b5dea37c42a73d66f9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; to look for an element entering the page that meets certain criteria.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 를 사용 하여 특정 기준에 맞는 페이지를 입력하는 요소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c340b82cff5a85036fa97538fb63c0522defe830" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/animations/stagger&quot;&gt;stagger&lt;/a&gt;()&lt;/code&gt; to delay each animation by 30 milliseconds.</source>
          <target state="translated">스 &lt;code&gt;&lt;a href=&quot;../api/animations/stagger&quot;&gt;stagger&lt;/a&gt;()&lt;/code&gt; 를 사용 하여 각 애니메이션을 30 밀리 초 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="744032ff1407c7169be00664314296b80fa6d2ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; to apply the provided styling data immediately.</source>
          <target state="translated">제공된 스타일 데이터를 즉시 적용 하려면 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c164f914355419d833cd09abe62d44f39e5d7fa3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; to define intermediate styles, which create the illusion of motion during the animation.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 애니메이션 동안 모션의 환상을 만드는 중간 스타일을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84330455001cba6cc5fc4fcfcc5e6a9131fbbea2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; to set many inline styles simultaneously and dynamically, based on the state of the component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; 을 사용 하여 구성 요소의 상태에 따라 많은 인라인 스타일을 동시에 동적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5245359421c59b09a4a49d6a64056af5518fc2a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; to define styles that are applied at the end of each transition, they persist after the animation has completed.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 애니메이션이 완료된 후에 각각의 전이의 끝에서 적용되는 스타일 정의들은 지속.</target>
        </trans-unit>
        <trans-unit id="23e2c4fd66aaf035f564822cce538de6531f6bbc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; to create two-way data bindings for reading and writing input-control values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용 하여 입력 제어 값을 읽고 쓰는 양방향 데이터 바인딩을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3fd82b61ae0dda767fc8f3a6beca402be658ba83" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; to separate providers from a module so you can import that module into the root module with &lt;code&gt;providers&lt;/code&gt; and child modules without &lt;code&gt;providers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 와 모듈없이 &lt;code&gt;providers&lt;/code&gt; 를 분리 하려면 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 공급자 없이 공급자 와 자식 모듈 을 사용하여 해당 모듈을 루트 모듈로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4659a85a02ce72bfcc286731ea25c8f664cf6829" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;upgrade/upgradeadapter&quot;&gt;UpgradeAdapter&lt;/a&gt;&lt;/code&gt; to allow AngularJS and Angular to coexist in a single application.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;upgrade/upgradeadapter&quot;&gt;UpgradeAdapter&lt;/a&gt;&lt;/code&gt; 는 AngularJS와와 각도가 하나의 응용 프로그램에서 공존 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5dac23ff3bdee9064747ccf719f0ed4727aad84f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;upgrade/upgradeadapterref&quot;&gt;UpgradeAdapterRef&lt;/a&gt;&lt;/code&gt; to control a hybrid AngularJS / Angular application.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;upgrade/upgradeadapterref&quot;&gt;UpgradeAdapterRef&lt;/a&gt;&lt;/code&gt; 를 사용 하여 하이브리드 AngularJS / Angular 애플리케이션을 제어 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02f4fc0380dc5751bed787fa57f8c1da57539efe" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;upgradeadapter&quot;&gt;UpgradeAdapter&lt;/a&gt;&lt;/code&gt; to allow AngularJS and Angular to coexist in a single application.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;upgradeadapter&quot;&gt;UpgradeAdapter&lt;/a&gt;&lt;/code&gt; 는 AngularJS와와 각도가 하나의 응용 프로그램에서 공존 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ca40e78c4209c9b5e5203ae6d1381b2251b2aed8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;upgradeadapterref&quot;&gt;UpgradeAdapterRef&lt;/a&gt;&lt;/code&gt; to control a hybrid AngularJS / Angular application.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;upgradeadapterref&quot;&gt;UpgradeAdapterRef&lt;/a&gt;&lt;/code&gt; 를 사용 하여 하이브리드 AngularJS / Angular 애플리케이션을 제어 하십시오 .</target>
        </trans-unit>
        <trans-unit id="af06267d70ed596a77b6002d1c976ef8cf195c8c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; to inject the instance.</source>
          <target state="translated">사용 &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; 인스턴스를 주입합니다.</target>
        </trans-unit>
        <trans-unit id="8871425e87aae0b3cd3521f2757473e950108c92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; so that Angular will only look at the &lt;code&gt;ElementInjector&lt;/code&gt; for the current component or directive.</source>
          <target state="translated">Angular가 현재 구성 요소 또는 지시문에 대해서만 &lt;code&gt;ElementInjector&lt;/code&gt; 를 보도록 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c336104380f0d2867d853d0a9497070d9a8d351" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; with &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; to prevent an error if the value is &lt;code&gt;null&lt;/code&gt;. In the following example, the &lt;code&gt;Person&lt;/code&gt; service is injected in the constructor. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; tells Angular to skip the current injector and &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; will prevent an error should the &lt;code&gt;Person&lt;/code&gt; service be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 값이 경우에 방지하기 위해 오류가 &lt;code&gt;null&lt;/code&gt; . 다음 예제에서는 &lt;code&gt;Person&lt;/code&gt; 서비스가 생성자에 삽입됩니다. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 는 Angular에게 현재 인젝터를 건너 뛰도록 지시하고 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 은 &lt;code&gt;Person&lt;/code&gt; 서비스가 &lt;code&gt;null&lt;/code&gt; 인 경우 오류를 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="0c3acfd0b42193c69c97319b8d40897bd917fd56" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;currency&lt;/code&gt; to format a number as currency.</source>
          <target state="translated">&lt;code&gt;currency&lt;/code&gt; 를 사용하여 숫자를 통화 형식으로 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f1bdfdd07f0e51b3ed046c10f3d302723845732" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;downgradeNg2Component&lt;/code&gt; to create an AngularJS Directive Definition Factory from Angular Component. The adapter will bootstrap Angular component from within the AngularJS template.</source>
          <target state="translated">&lt;code&gt;downgradeNg2Component&lt;/code&gt; 를 사용하여 Angular Component에서 AngularJS Directive Definition Factory를 작성 하십시오 . 어댑터는 AngularJS 템플릿 내에서 Angular 구성 요소를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="a89fbfa3b7a5cad46931da1a2b1acafab5e39b74" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fromString&lt;/code&gt; to create HttpParams</source>
          <target state="translated">사용 &lt;code&gt;fromString&lt;/code&gt; HttpParams를 만들</target>
        </trans-unit>
        <trans-unit id="9016f8a4d5f440de4485c2ed9ab0fb4c65014418" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;markForCheck()&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;changedetectorref&quot;&gt;CheckOnce&lt;/a&gt;&lt;/code&gt; strategy</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;changedetectorref&quot;&gt;CheckOnce&lt;/a&gt;&lt;/code&gt; 전략 과 함께 &lt;code&gt;markForCheck()&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="57ed9bd08229eab245c48c01dd77e6ea3a5924a2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt; &amp;lt;lib_name&amp;gt;&lt;/code&gt; to update individual library versions. The Angular CLI checks the latest published release of the library, and if the latest version is newer than your installed version, downloads it and updates your &lt;code&gt;package.json&lt;/code&gt; to match the latest version.</source>
          <target state="translated">사용 &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt; &amp;lt;lib_name&amp;gt;&lt;/code&gt; 개별 라이브러리 버전을 업데이트합니다. Angular CLI는 라이브러리의 최신 공개 릴리스를 확인하고 최신 버전이 설치된 버전보다 최신 인 경우 다운로드 하여 최신 버전과 일치하도록 &lt;code&gt;package.json&lt;/code&gt; 을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="86ee33b42fd33fef24e535d80cee1f4a2d9b6d98" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ngOnInit()&lt;/code&gt; for two main reasons:</source>
          <target state="translated">다음 두 가지 이유로 &lt;code&gt;ngOnInit()&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0101700ae7ee3247de5052bf7ea3d11a837378c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;setTimeout()&lt;/code&gt; to wait one tick and then revise the &lt;code&gt;seconds()&lt;/code&gt; method so that it takes future values from the timer component.</source>
          <target state="translated">&lt;code&gt;setTimeout()&lt;/code&gt; 을 사용 하여 한 번의 틱을 기다린 다음 타이머 구성 요소에서 향후 값을 가져 오도록 &lt;code&gt;seconds()&lt;/code&gt; 메서드 를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb1322724221816f73d5c0329a7eb5dcab8960c7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;upgradeNg1Component&lt;/code&gt; to create an Angular component from AngularJS Component directive. The adapter will bootstrap AngularJS component from within the Angular template.</source>
          <target state="translated">&lt;code&gt;upgradeNg1Component&lt;/code&gt; 를 사용하여 AngularJS Component 지시문에서 Angular 구성 요소를 작성 하십시오 . 어댑터는 Angular 템플릿 내에서 AngularJS 구성 요소를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="50956624e8944e35a6d37b0adb8e3d1bd4c37693" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;root URLs&lt;/em&gt; for all web resources: CSS, images, scripts, and template HTML files.</source>
          <target state="translated">CSS, 이미지, 스크립트 및 템플릿 HTML 파일과 같은 모든 웹 리소스에 &lt;em&gt;루트 URL&lt;/em&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a03f29e1bd5ed1ad5fcb9c4057f36f7e599cdd5" translate="yes" xml:space="preserve">
          <source>Use Angular's &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; function to define different states to call at the end of each transition. This function takes two arguments: a unique name like &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;closed&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 각 전환이 끝날 때 호출 할 다른 상태를 정의하십시오. 이 함수는 &lt;code&gt;open&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 와 같은 고유 이름과 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 함수 라는 두 가지 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="87f7bdc684fc8838c17afd26ef0911196a4cc431" translate="yes" xml:space="preserve">
          <source>Use HTML tables to present tabular data.</source>
          <target state="translated">HTML 테이블을 사용하여 테이블 형식 데이터를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d52844f8f4d368ecefe3c48b7579af4485aa36ae" translate="yes" xml:space="preserve">
          <source>Use Lifecycle hooks to tap into important events exposed by Angular.</source>
          <target state="translated">수명주기 후크를 사용하여 Angular에 의해 노출되는 중요한 이벤트를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9658986afcec6ffd4c7f6a0574e23679c2ba6611" translate="yes" xml:space="preserve">
          <source>Use Shadow DOM to encapsulate styles.</source>
          <target state="translated">Shadow DOM을 사용하여 스타일을 캡슐화하십시오.</target>
        </trans-unit>
        <trans-unit id="f08d443a95d8465aefd51bbcd60a391957292522" translate="yes" xml:space="preserve">
          <source>Use TypeScript path mapping for peer dependencies</source>
          <target state="translated">피어 종속성에 TypeScript 경로 매핑 사용</target>
        </trans-unit>
        <trans-unit id="9cc4b5a0a1615c582c8ca48d1ec27455af6a185b" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;button&lt;/code&gt; element to add a button to the bottom of the form to trigger the form submission.</source>
          <target state="translated">&lt;code&gt;button&lt;/code&gt; 요소를 사용하여 단추 를 양식 맨 아래에 추가하여 양식 제출을 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="5b5ea0356b91d0915d4b8c036e052844c79a4502" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;formGroup&lt;/code&gt; property binding to bind the &lt;code&gt;checkoutForm&lt;/code&gt; to the &lt;code&gt;form&lt;/code&gt; tag in the template. Also include a &quot;Purchase&quot; button to submit the form.</source>
          <target state="translated">&lt;code&gt;formGroup&lt;/code&gt; 속성 바인딩을 사용 하여 &lt;code&gt;checkoutForm&lt;/code&gt; 을 템플리트 의 &lt;code&gt;form&lt;/code&gt; 태그에 바인딩하십시오 . 양식을 제출하려면 &quot;구매&quot;버튼도 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="fdac760c5116185edbb31c4a9ad9c814fe4129bb" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;page&lt;/code&gt; object</source>
          <target state="translated">용도 &lt;code&gt;page&lt;/code&gt; 객체를</target>
        </trans-unit>
        <trans-unit id="d47d2a657fa1d3c60905a8a9ccd668a501f568ba" translate="yes" xml:space="preserve">
          <source>Use a JavaScript function, &lt;code&gt;customElements.define()&lt;/code&gt;, to register the configured constructor and its associated custom-element tag with the browser's &lt;code&gt;CustomElementRegistry&lt;/code&gt;. When the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.</source>
          <target state="translated">JavaScript &lt;code&gt;customElements.define()&lt;/code&gt; 을 사용하여 구성된 생성자와 연관된 사용자 정의 요소 태그를 브라우저의 &lt;code&gt;CustomElementRegistry&lt;/code&gt; 에 등록하십시오 . 브라우저가 등록 된 요소의 태그를 발견하면 생성자를 사용하여 사용자 정의 요소 인스턴스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="72a2b18f27d211118108e49c2dd0efc7f61f3f3d" translate="yes" xml:space="preserve">
          <source>Use a custom id with a description</source>
          <target state="translated">설명이 포함 된 맞춤 ID 사용</target>
        </trans-unit>
        <trans-unit id="ca0772b11fa11c22b7bfb2cc9e1ebd036d26eb58" translate="yes" xml:space="preserve">
          <source>Use a custom renderer to bypass Angular's templating and make custom UI changes that can't be expressed declaratively. For example if you need to set a property or an attribute whose name is not statically known, use the &lt;code&gt;setProperty()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;renderer2&quot;&gt;setAttribute()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 렌더러를 사용하여 Angular의 템플릿을 무시하고 선언적으로 표현할 수없는 사용자 정의 UI를 변경하십시오. 예를 들어 이름을 정적으로 알 수없는 속성 또는 속성을 설정해야하는 경우 &lt;code&gt;setProperty()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;renderer2&quot;&gt;setAttribute()&lt;/a&gt;&lt;/code&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2defd1faf147625042e6e427843821178b67bd1b" translate="yes" xml:space="preserve">
          <source>Use a double arrow syntax to specify state-to-state transitions in both directions.</source>
          <target state="translated">양방향 화살표 구문을 사용하여 양방향 상태 전환을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8f86fd2cb52558a5f799a9078de5c642cbd17287" translate="yes" xml:space="preserve">
          <source>Use a separate bundle containing code used across multiple bundles.</source>
          <target state="translated">여러 번들에서 사용되는 코드가 포함 된 별도의 번들을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4de7347c4ae42c0338292a697420d7631cff3899" translate="yes" xml:space="preserve">
          <source>Use a separate bundle containing only vendor libraries.</source>
          <target state="translated">공급 업체 라이브러리 만 포함 된 별도의 번들을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d1d96dbe4bfa2f8afd5e063fb099246e2f933e9" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; whenever the type you are injecting is not reified (does not have a runtime representation) such as when injecting an interface, callable type, array or parameterized type.</source>
          <target state="translated">인터페이스, 호출 가능 유형, 배열 또는 매개 변수화 된 유형을 주입 할 때와 같이 주입중인 유형이 구체화되지 않은 경우 (런타임 표현이없는 경우) &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b24b7564615489f70464a0b684de4d00e3cad09" translate="yes" xml:space="preserve">
          <source>Use an input property setter to intercept and act upon a value from the parent.</source>
          <target state="translated">입력 특성 설정기를 사용하여 상위의 값을 가로 채서 조치하십시오.</target>
        </trans-unit>
        <trans-unit id="aa89ae11b8e5412bd5017dd7f915184a5121c58a" translate="yes" xml:space="preserve">
          <source>Use both techniques together</source>
          <target state="translated">두 기술을 함께 사용</target>
        </trans-unit>
        <trans-unit id="58c616bd0cf85cc12a155f6a80ac80d1c6ac921b" translate="yes" xml:space="preserve">
          <source>Use built-in Angular directives to show and hide elements and display lists of hero data.</source>
          <target state="translated">내장 Angular 지시문을 사용하여 요소를 표시하거나 숨기고 영웅 데이터 목록을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ba903051e852b2dc8a92992587da4085b281db62" translate="yes" xml:space="preserve">
          <source>Use directives to enhance an element</source>
          <target state="translated">지시문을 사용하여 요소 향상</target>
        </trans-unit>
        <trans-unit id="12ab61a4fd4336f2c2953a0f712c04fb91949dba" translate="yes" xml:space="preserve">
          <source>Use file name for lazy loaded chunks.</source>
          <target state="translated">지연로드 된 청크에 파일 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f8f0525e366cb8c77a4916b799b14b984e598076" translate="yes" xml:space="preserve">
          <source>Use in components with the &lt;code&gt;@&lt;a href=&quot;core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; directive to emit custom events synchronously or asynchronously, and register handlers for those events by subscribing to an instance.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 지시문 과 함께 구성 요소에서 사용하여 사용자 정의 이벤트를 동기식 또는 비동기식으로 생성하고 인스턴스를 구독하여 해당 이벤트에 대한 핸들러를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="6610f463a7407078fa7bae85f8fc8f843b6debb4" translate="yes" xml:space="preserve">
          <source>Use in components with the &lt;code&gt;@&lt;a href=&quot;output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; directive to emit custom events synchronously or asynchronously, and register handlers for those events by subscribing to an instance.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 지시문 과 함께 구성 요소에서 사용하여 사용자 정의 이벤트를 동기식 또는 비동기식으로 생성하고 인스턴스를 구독하여 해당 이벤트에 대한 핸들러를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="9848cb209b02d0955db09afd48d35722b7baf9e6" translate="yes" xml:space="preserve">
          <source>Use in development mode to verify that running change detection doesn't introduce other changes.</source>
          <target state="translated">개발 모드에서 사용하여 변경 감지 실행시 다른 변경이 발생하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="562fbe07806719e4eb320decc50510c6f8fcbd9d" translate="yes" xml:space="preserve">
          <source>Use integration testing for your builder, so that you can use the Architect scheduler to create a context, as in this &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo&quot;&gt;예제&lt;/a&gt; 와 같이 Architect 스케줄러를 사용하여 컨텍스트를 작성할 수 있도록 빌더에 통합 테스트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="922b5062ec0572aa1adccb4f5632805f5154deab" translate="yes" xml:space="preserve">
          <source>Use kebab-case for downgraded component attributes</source>
          <target state="translated">다운 그레이드 된 구성 요소 속성에 케밥 케이스 사용</target>
        </trans-unit>
        <trans-unit id="44f566857d643f1d49f711c0b30d0dc6a3ffce4b" translate="yes" xml:space="preserve">
          <source>Use keyframes to create a pulse effect in your animations by defining styles at specific offset throughout the animation.</source>
          <target state="translated">애니메이션 전체에서 특정 오프셋에 스타일을 정의하여 키 프레임을 사용하여 애니메이션에 펄스 효과를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f78e562ea1e7f343fb60afc2c7e41be5afad1302" translate="yes" xml:space="preserve">
          <source>Use nested form groups to validate a sub-group of a form separately from the rest or to group the values of certain controls into their own nested object.</source>
          <target state="translated">중첩 양식 그룹을 사용하여 나머지 양식과 별도로 양식의 하위 그룹을 검증하거나 특정 컨트롤의 값을 자체 중첩 객체로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0b7c6086be4df2a4b72a414920640b2b9519a5" translate="yes" xml:space="preserve">
          <source>Use of *ngIf and *ngFor with :enter and :leave</source>
          <target state="translated">: enter 및 : leave와 함께 * ngIf 및 * ngFor 사용</target>
        </trans-unit>
        <trans-unit id="825f8becf5e248543919edc40655a1407e732140" translate="yes" xml:space="preserve">
          <source>Use one-way data binding for read-only data.</source>
          <target state="translated">읽기 전용 데이터에는 단방향 데이터 바인딩을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33c9c9b12a49197173a1f9a9e99b1ab027db7481" translate="yes" xml:space="preserve">
          <source>Use property binding to &lt;em&gt;set&lt;/em&gt; properties of target elements or directive &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorators. For an example demonstrating all of the points in this section, see the &lt;span name=&quot;property-binding&quot;&gt;property binding example&lt;/span&gt;.</source>
          <target state="translated">속성 바인딩을 사용 하여 대상 요소 또는 지시문 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 데코레이터의 속성 을 &lt;em&gt;설정&lt;/em&gt; 하십시오 . 이 섹션의 모든 포인트를 보여주는 예제는 &lt;span name=&quot;property-binding&quot;&gt;속성 바인딩 예제를&lt;/span&gt; 참조하십시오 .&lt;span name=&quot;property-binding&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0e687455aeeac52967421ad9e0ea548379e0207c" translate="yes" xml:space="preserve">
          <source>Use route parameters</source>
          <target state="translated">경로 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="83397ceeb8cb2ee18c72cf2e39d941138c6e3d3b" translate="yes" xml:space="preserve">
          <source>Use routing to navigate among different views and their components.</source>
          <target state="translated">라우팅을 사용하여 다른보기와 해당 구성 요소를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="0bfd4f1040c27256f1f7a7669dce5333fc8f6d46" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; to automatically set up your project with the correct polyfill: &lt;code&gt;ng add @angular/elements --name=*your_project_name*&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; 를 사용하여 올바른 폴리 필로 프로젝트를 자동으로 설정하십시오 : &lt;code&gt;ng add @angular/elements --name=*your_project_name*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0967d7ae25fbeb074644d90cbc2a0b6e09376c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;cli/run&quot;&gt;CLI command &lt;code&gt;ng run&lt;/code&gt;&lt;/a&gt; to invoke a builder by specifying a &lt;a href=&quot;glossary#target&quot;&gt;target configuration&lt;/a&gt; associated with that builder. Integrators can add builders to enable tools and workflows to run through the Angular CLI. For example, a custom builder can replace the third-party tools used by the built-in implementations for CLI commands such as &lt;code&gt;ng build&lt;/code&gt; or &lt;code&gt;ng test&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli/run&quot;&gt;CLI 명령 &lt;code&gt;ng run&lt;/code&gt; &lt;/a&gt; 을 사용하여 해당 빌더와 연관된 &lt;a href=&quot;glossary#target&quot;&gt;대상 구성&lt;/a&gt; 을 지정하여 빌더를 호출하십시오 . 통합자는 빌더를 추가하여 도구 및 워크 플로우가 Angular CLI를 통해 실행될 수 있도록합니다. 예를 들어, 사용자 정의 빌더는 내장 &lt;code&gt;ng build&lt;/code&gt; 에서 ng build 또는 &lt;code&gt;ng test&lt;/code&gt; 와 같은 CLI 명령에 사용되는 써드 파티 도구를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f443ef713021a89a07c940630b1de13045528f0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;singleton-services#providedIn&quot;&gt;&lt;code&gt;providedIn&lt;/code&gt; syntax&lt;/a&gt; instead of registering the service in the module.</source>
          <target state="translated">모듈에 서비스를 등록하는 대신 &lt;a href=&quot;singleton-services#providedIn&quot;&gt; &lt;code&gt;providedIn&lt;/code&gt; 구문을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="802892225bada3f629d8e440f05c2e60e8ea54c8" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;template-syntax#non-null-assertion-operator&quot;&gt;non-null type assertion operator&lt;/a&gt; to suppress the &lt;code&gt;Object is possibly 'undefined'&lt;/code&gt; error when it is inconvenient to use &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.</source>
          <target state="translated">&lt;a href=&quot;template-syntax#non-null-assertion-operator&quot;&gt;Null&lt;/a&gt; 이 아닌 어설 션 연산자 를 사용하여 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt; 를 사용하는 것이 불편 하거나 구성 요소의 일부 제약 조건으로 인해 바인딩식이 보간 될 때식이 항상 null이 아닌 것을 보장하는 경우 &lt;code&gt;Object is possibly 'undefined'&lt;/code&gt; 오류를 표시하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="5a253ee9798a26a31ec1940c9c82d1392f5a3876" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; pseudo-class selector to target styles in the element that &lt;em&gt;hosts&lt;/em&gt; the component (as opposed to targeting elements &lt;em&gt;inside&lt;/em&gt; the component's template).</source>
          <target state="translated">사용 &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; 하는 요소에 목표 스타일에 의사 클래스 선택기를 &lt;em&gt;호스트&lt;/em&gt; 구성 요소 (같은 요소 대상에 반대하는 &lt;em&gt;내부&lt;/em&gt; 구성 요소의 템플릿을).</target>
        </trans-unit>
        <trans-unit id="3d5018825bf0a7d2fd0cd9ddf6fdbc3f0fd42061" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:host-context()&lt;/code&gt; pseudo-class selector, which works just like the function form of &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;()&lt;/code&gt;. The &lt;code&gt;:host-context()&lt;/code&gt; selector looks for a CSS class in any ancestor of the component host element, up to the document root. The &lt;code&gt;:host-context()&lt;/code&gt; selector is useful when combined with another selector.</source>
          <target state="translated">사용 &lt;code&gt;:host-context()&lt;/code&gt; 단지의 기능 양식처럼 작동 의사 클래스 선택기 &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;()&lt;/code&gt; . &lt;code&gt;:host-context()&lt;/code&gt; 문서 루트 구성 요소 호스트 요소의 조상, 최대의 CSS 클래스 선택 보인다. &lt;code&gt;:host-context()&lt;/code&gt; 다른 선택과 결합 선택기 유용하다.</target>
        </trans-unit>
        <trans-unit id="c620015e08354210a92a8e92a39367a30c7b96b6" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function to define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place. You can also use the &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function to define the &lt;code&gt;&lt;a href=&quot;../api/animations/keyframes&quot;&gt;keyframes&lt;/a&gt;()&lt;/code&gt; function for multi-step animations. These definitions are placed in the second argument of the &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 길이, 지연을 정의하는 기능을하고, 변화의 완화 및 전환이 일어나고있는 동안 스타일을 정의하는 스타일 기능을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 함수를 사용하여 다단계 애니메이션 의 &lt;code&gt;&lt;a href=&quot;../api/animations/keyframes&quot;&gt;keyframes&lt;/a&gt;()&lt;/code&gt; 함수 를 정의 할 수도 있습니다 . 이러한 정의는 &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 함수 의 두 번째 인수에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="f32ed10372c1cab9fb95fe4e02cc957f60ec0b21" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/animations/group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; method to create the &lt;code&gt;profileForm&lt;/code&gt; controls.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/animations/group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 작성하는 방법을 &lt;code&gt;profileForm&lt;/code&gt; 의 컨트롤을.</target>
        </trans-unit>
        <trans-unit id="8bdd7bc62b27869a9b7bb04eb7df3c59285d92cc" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; method to find and animate elements within the current host component. The &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;(&quot;:enter&quot;)&lt;/code&gt; statement returns the view that is being inserted, and &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;(&quot;:leave&quot;)&lt;/code&gt; returns the view that is being removed.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 찾아 현재 호스트 구성 요소 내에서 애니메이션 요소하는 방법. &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;(&quot;:enter&quot;)&lt;/code&gt; 문이 삽입되고보기 및 반환 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;(&quot;:leave&quot;)&lt;/code&gt; 삭제되는 뷰를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="ebd22958c7847fa77a78ef8e03b47db2e683c9d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; function to define a set of styles to associate with a given state name. Note that the style attributes must be in &lt;a href=&quot;glossary#case-conventions&quot;&gt;&lt;em&gt;camelCase&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 주어진 상태 이름과 연결 스타일 세트를 정의하는 기능. 스타일 속성은 &lt;a href=&quot;glossary#case-conventions&quot;&gt;&lt;em&gt;camelCase에&lt;/em&gt;&lt;/a&gt; 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="91acc14e39e5119c18415965f1423d1c1e94ab00" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; method to simulate the passage of time within the &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; task.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; () 작업 내에서 시간 경과를 시뮬레이션 하려면 &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e11e33b2cc2033eeec839ccb2bf4ff8db1df75b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array as another way to provide services in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator. Using &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; makes services visibile in the &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 에서 서비스를 제공하는 또 다른 방법으로 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 데코레이터. &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 를 사용 하면 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 서비스가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9da9c13c3494d39f9b8123dc99a605e807be36b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; hook to detect and act upon changes that Angular doesn't catch on its own.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; 후크를 사용하여 Angular가 자체적으로 포착하지 않는 변경 사항을 감지하고 조치하십시오.</target>
        </trans-unit>
        <trans-unit id="b14dbf457ff7a844ac29eacc3c02344a0ca4f6f9" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/elements/createcustomelement&quot;&gt;createCustomElement&lt;/a&gt;()&lt;/code&gt; function to convert a component into a class that can be registered with the browser as a custom element. After you register your configured class with the browser's custom-element registry, you can use the new element just like a built-in HTML element in content that you add directly into the DOM:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/elements/createcustomelement&quot;&gt;createCustomElement&lt;/a&gt;()&lt;/code&gt; 함수를 사용하여 컴포넌트를 브라우저에 사용자 정의 요소로 등록 할 수있는 클래스로 변환하십시오. 구성된 클래스를 브라우저의 사용자 정의 요소 레지스트리에 등록한 후 DOM에 직접 추가하는 컨텐츠의 내장 HTML 요소와 같이 새 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24aafb47c577f92905ee4910fc51532818acf73" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#array&quot;&gt;FormBuilder.array()&lt;/a&gt;&lt;/code&gt; method to define the array, and the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#control&quot;&gt;FormBuilder.control()&lt;/a&gt;&lt;/code&gt; method to populate the array with an initial control.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#array&quot;&gt;FormBuilder.array()&lt;/a&gt;&lt;/code&gt; 배열을 정의하는 방법 및 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#control&quot;&gt;FormBuilder.control()&lt;/a&gt;&lt;/code&gt; 메소드는 초기 제어 배열을 채우는.</target>
        </trans-unit>
        <trans-unit id="ee7d38fbbd61f8f37159836272223af030e2357d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;animationbuilder&quot;&gt;build()&lt;/a&gt;&lt;/code&gt; method to create a programmatic animation using the &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function. The method returns an &lt;code&gt;&lt;a href=&quot;animationfactory&quot;&gt;AnimationFactory&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;animationbuilder&quot;&gt;build()&lt;/a&gt;&lt;/code&gt; 사용하여 프로그래밍 애니메이션 만드는 방법을 &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 함수를. 이 메소드는 &lt;code&gt;&lt;a href=&quot;animationfactory&quot;&gt;AnimationFactory&lt;/a&gt;&lt;/code&gt; 인스턴스를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3765ca5842a3e715a91529c10554d2f2c436e303" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckOnce&lt;/a&gt;&lt;/code&gt; strategy, meaning that automatic change detection is deactivated until reactivated by setting the strategy to &lt;code&gt;Default&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckAlways&lt;/a&gt;&lt;/code&gt;). Change detection can still be explicitly invoked. This strategy applies to all child directives and cannot be overridden.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckOnce&lt;/a&gt;&lt;/code&gt; 전략을 사용하십시오. 이는 전략을 &lt;code&gt;Default&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckAlways&lt;/a&gt;&lt;/code&gt; ) 으로 설정하여 다시 활성화 할 때까지 자동 변경 감지가 비활성화됨을 의미합니다 . 변경 감지는 여전히 명시 적으로 호출 할 수 있습니다. 이 전략은 모든 하위 지시문에 적용되며 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2cf0a1cf425beff3e317842f9cdbcec4e95baf3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; function to register states to an animation trigger. Use the &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; function to animate between states. When a state is active within a component, its associated styles persist on the element, even when the animation ends.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; 함수를 사용하여 애니메이션 트리거에 상태를 등록하십시오. 상태 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 위해 전환 () 함수를 사용하십시오 . 구성 요소 내에서 상태가 활성화되면 애니메이션이 종료 되더라도 관련 스타일이 요소에서 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b3851f1b2f6c392b87e343e5e9be15390610617a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator in a child component or directive to let Angular know that a property in that component can receive its value from its parent component. It helps to remember that the data flow is from the perspective of the child component. So an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; allows data to be input &lt;em&gt;into&lt;/em&gt; the child component from the parent component.</source>
          <target state="translated">자식 구성 요소 또는 지시문에서 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 데코레이터를 사용하여 Angular에 해당 구성 요소의 속성이 부모 구성 요소에서 값을받을 수 있음을 알립니다. 데이터 흐름은 하위 구성 요소의 관점에서 온 것임을 기억하는 데 도움이됩니다. 따라서 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 사용 하면 부모 구성 요소에서 자식 구성 요소 &lt;em&gt;로&lt;/em&gt; 데이터를 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef440cee0d4b619baf1dc108b572b145ffe599c6" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; decorator in the child component or directive to allow data to flow from the child &lt;em&gt;out&lt;/em&gt; to the parent.</source>
          <target state="translated">사용 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 데이터가 자녀로부터의 정보 흐름을 허용하는 하위 구성 요소 또는 지시에 장식을 &lt;em&gt;밖으로&lt;/em&gt; 부모.</target>
        </trans-unit>
        <trans-unit id="cb9e4c97b8a1368fcaea25ed71eeaf564330d68c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Observable&lt;/code&gt; constructor to create an observable stream of any type. The constructor takes as its argument the subscriber function to run when the observable&amp;rsquo;s &lt;code&gt;subscribe()&lt;/code&gt; method executes. A subscriber function receives an &lt;code&gt;Observer&lt;/code&gt; object, and can publish values to the observer's &lt;code&gt;next()&lt;/code&gt; method.</source>
          <target state="translated">사용 &lt;code&gt;Observable&lt;/code&gt; 모든 종류의 관찰 스트림을 생성하는 생성자를. 생성자는 옵저버 블의 &lt;code&gt;subscribe()&lt;/code&gt; 메서드 가 실행될 때 구독자 함수를 인수로 사용합니다 . 구독자 함수는 &lt;code&gt;Observer&lt;/code&gt; 객체를 받고 관찰자의 &lt;code&gt;next()&lt;/code&gt; 메서드에 값을 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1173fd6da6508928f593314bd49b24f1cee5a901" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;RouterModule.forRoot&lt;/code&gt; method to define a set of routes. Also, import this &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;imports&lt;/code&gt; array of the main module, &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RouterModule.forRoot&lt;/code&gt; 메소드를 사용하여 라우트 세트를 정의하십시오. 또한이 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 기본 모듈 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;imports&lt;/code&gt; 배열로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="236f90d8a2b43b2b908f826c2dd47da6ccc4d554" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;declarations&lt;/code&gt; array for directives. To use a directive, component, or pipe in a module, you must do a few things:</source>
          <target state="translated">지시문에 &lt;code&gt;declarations&lt;/code&gt; 배열을 사용하십시오 . 모듈에서 지시문, 구성 요소 또는 파이프를 사용하려면 몇 가지 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c3fa69688b331df5c2d1c642a70ae5ecd3bdf4b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;favoriteColorControl&lt;/code&gt;, a &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance, to set the new value.</source>
          <target state="translated">사용 &lt;code&gt;favoriteColorControl&lt;/code&gt; 하는 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 의 새 값을 설정하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="16cf1db0421f9d869402c30f489d6a26b1ef363c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;patchValue()&lt;/code&gt; method to replace any properties defined in the object that have changed in the form model.</source>
          <target state="translated">&lt;code&gt;patchValue()&lt;/code&gt; 메소드를 사용하여 양식 모델에서 변경된 오브젝트에 정의 된 특성을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="663da71b4933858141a19f1c639501cb180552d7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;retry&lt;/code&gt; operator before the &lt;code&gt;catchError&lt;/code&gt; operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.</source>
          <target state="translated">&lt;code&gt;catchError&lt;/code&gt; 연산자 전에 &lt;code&gt;retry&lt;/code&gt; 연산자를 사용하십시오 . 관찰 가능한 원래 소스에 다시 가입 한 다음 오류가 발생한 전체 동작 시퀀스를 다시 실행할 수 있습니다. HTTP 요청이 포함 된 경우 해당 HTTP 요청을 재 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3c670bb360c8cc1af3a13abb754e25fbb2f42f5b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;schematics&lt;/code&gt; command to run a named schematic. Provide the path to the project folder, the schematic name, and any mandatory options, in the following format.</source>
          <target state="translated">&lt;code&gt;schematics&lt;/code&gt; 명령을 사용하여 명명 된 회로도를 실행하십시오. 프로젝트 폴더의 경로, 회로도 이름 및 모든 필수 옵션을 다음 형식으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d6dfca72b156d70b98370724a6bf1ea5950071f5" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;set()&lt;/code&gt; method instead, to return a clone of the current instance with the new changes applied.</source>
          <target state="translated">사용 &lt;code&gt;set()&lt;/code&gt; 적용되는 새로운 변화와 현재의 인스턴스의 복제를 반환하는 대신 방법을.</target>
        </trans-unit>
        <trans-unit id="52f536a15c49df755922f56c142d44e19a8db2b4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;setValue()&lt;/code&gt; method to set a new value for an individual control. The &lt;code&gt;setValue()&lt;/code&gt; method strictly adheres to the structure of the form group and replaces the entire value for the control.</source>
          <target state="translated">&lt;code&gt;setValue()&lt;/code&gt; 메소드를 사용하여 개별 제어에 대한 새 값을 설정하십시오. &lt;code&gt;setValue()&lt;/code&gt; 메소드는 엄격 형태 기의 구조에 부착 및 제어 전체 값을 대체한다.</target>
        </trans-unit>
        <trans-unit id="608e3ecc67d63ebd131072715526770717d76070" translate="yes" xml:space="preserve">
          <source>Use the &lt;em&gt;function form&lt;/em&gt; to apply host styles conditionally by including another selector inside parentheses after &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;em&gt;기능 양식을&lt;/em&gt; 후 괄호 안에 다른 선택 포함하여 조건부 호스트 스타일을 적용 &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0228ac89e07be504f25494e9676937a8b7718d7a" translate="yes" xml:space="preserve">
          <source>Use the @Injectable() class decorator</source>
          <target state="translated">@Injectable () 클래스 데코레이터 사용</target>
        </trans-unit>
        <trans-unit id="d3a17a236cfd17da399af8b8cc707e6575ce9b8c" translate="yes" xml:space="preserve">
          <source>Use the Angular CLI and the npm package manager to build and publish your library as an npm package. Libraries are built in &lt;a href=&quot;aot-compiler&quot;&gt;AoT mode&lt;/a&gt; by default, so you do not need to specify the &lt;code&gt;-prod&lt;/code&gt; flag when building for publication.</source>
          <target state="translated">Angular CLI 및 npm 패키지 관리자를 사용하여 라이브러리를 npm 패키지로 빌드하고 게시하십시오. 라이브러리는 기본적으로 &lt;a href=&quot;aot-compiler&quot;&gt;AoT 모드&lt;/a&gt; 로 빌드 되므로 게시를 위해 빌드 할 때 &lt;code&gt;-prod&lt;/code&gt; 플래그 를 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4633a55586a6fa2e22e42b322b523d199217f07e" translate="yes" xml:space="preserve">
          <source>Use the Angular CLI to generate a new component named &lt;code&gt;hero-detail&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 &lt;code&gt;hero-detail&lt;/code&gt; 이라는 새 구성 요소를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d57c142dc3dc54d8d21e3c079a0a3926683c980" translate="yes" xml:space="preserve">
          <source>Use the Angular CLI to generate a new library skeleton with the following command:</source>
          <target state="translated">Angular CLI를 사용하여 다음 명령으로 새 라이브러리 스켈레톤을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="359dd0a4bcbf30fc27fe4c0e62d05c483ce99a29" translate="yes" xml:space="preserve">
          <source>Use the CLI command &lt;a href=&quot;cli/new&quot;&gt;&lt;code&gt;ng new displaying-data&lt;/code&gt;&lt;/a&gt; to create a workspace and app named &lt;code&gt;displaying-data&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli/new&quot;&gt; &lt;code&gt;ng new displaying-data&lt;/code&gt; &lt;/a&gt; CLI 명령 ng 를 사용하여 이름이 &lt;code&gt;displaying-data&lt;/code&gt; 작업 공간 및 앱을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="38c9f16db58637bd61abdf74662688ec8ee2214e" translate="yes" xml:space="preserve">
          <source>Use the CLI to automatically create the app shell.</source>
          <target state="translated">CLI를 사용하여 앱 셸을 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9ece05677ae45d1939690d567a9eb86967b7bbf8" translate="yes" xml:space="preserve">
          <source>Use the CLI to build the &lt;code&gt;app-shell&lt;/code&gt; target.</source>
          <target state="translated">CLI를 사용하여 &lt;code&gt;app-shell&lt;/code&gt; 대상 을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5cf2ec90353ca6935df3915b02b577d867b4e88" translate="yes" xml:space="preserve">
          <source>Use the CLI to create the &lt;code&gt;MessageService&lt;/code&gt; in &lt;code&gt;src/app&lt;/code&gt;.</source>
          <target state="translated">CLI를 사용하여 &lt;code&gt;src/app&lt;/code&gt; 에서 &lt;code&gt;MessageService&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="308d836de00681b82b1a6ac4629d26037ebc7917" translate="yes" xml:space="preserve">
          <source>Use the CLI to create the &lt;code&gt;MessagesComponent&lt;/code&gt;.</source>
          <target state="translated">CLI를 사용하여 &lt;code&gt;MessagesComponent&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf59379107eb2f1e9f7b6aeeaba809aa6857254" translate="yes" xml:space="preserve">
          <source>Use the CLI to generate it.</source>
          <target state="translated">CLI를 사용하여 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9784a04039a561954033d9fe973f0a4c5920fe5c" translate="yes" xml:space="preserve">
          <source>Use the HTML</source>
          <target state="translated">HTML 사용</target>
        </trans-unit>
        <trans-unit id="5bbf6b5276a555599737d1dbfa3accbd3fb1e8c7" translate="yes" xml:space="preserve">
          <source>Use the ID in this previous-state object to differentiate between a newly created state and one returned to by a &lt;code&gt;popstate&lt;/code&gt; event, so that you can restore some remembered state, such as scroll position.</source>
          <target state="translated">이 이전 상태 객체의 ID를 사용하여 새로 만든 상태와 &lt;code&gt;popstate&lt;/code&gt; 이벤트에서 반환 된 상태를 구별 하여 스크롤 위치와 같은 일부 기억 된 상태를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9afc5479b408292ddfb0e17196fc61151a2e25" translate="yes" xml:space="preserve">
          <source>Use the cart service</source>
          <target state="translated">카트 서비스 사용</target>
        </trans-unit>
        <trans-unit id="eecd35206481b79b7c4507d8f30817c32cca25ef" translate="yes" xml:space="preserve">
          <source>Use the component instance to set the value of the &lt;code&gt;favoriteColor&lt;/code&gt; property.</source>
          <target state="translated">구성 요소 인스턴스를 사용하여 &lt;code&gt;favoriteColor&lt;/code&gt; 속성 값을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d9ebb52ab384cbcfd61b51ce977015d8e0b30b7" translate="yes" xml:space="preserve">
          <source>Use the constructor of &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; to set its initial value, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 의 생성자를 사용하여 초기 값을 설정 하십시오 ( 이 경우 빈 문자열). 컴포넌트 클래스에서 이러한 제어를 작성하면 양식 입력의 상태를 청취, 업데이트 및 유효성 검증 할 수있는 즉시 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7587cbf004aad2b4e56b322cfef850309d1e76b" translate="yes" xml:space="preserve">
          <source>Use the default &lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckAlways&lt;/a&gt;&lt;/code&gt; strategy, in which change detection is automatic until explicitly deactivated.</source>
          <target state="translated">명시 적으로 비활성화 할 때까지 변경 감지가 자동으로 수행되는 기본 &lt;code&gt;&lt;a href=&quot;changedetectionstrategy&quot;&gt;CheckAlways&lt;/a&gt;&lt;/code&gt; 전략을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d11f8688c1e1b1658b40526cee3f9f4dfd5fa0" translate="yes" xml:space="preserve">
          <source>Use the factory object to create an &lt;code&gt;&lt;a href=&quot;animationplayer&quot;&gt;AnimationPlayer&lt;/a&gt;&lt;/code&gt; and attach it to a DOM element.</source>
          <target state="translated">팩토리 객체를 사용하여 &lt;code&gt;&lt;a href=&quot;animationplayer&quot;&gt;AnimationPlayer&lt;/a&gt;&lt;/code&gt; 를 만들고 DOM 요소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="09aee07ff0cbe6302c8871e0400bf8743cc280bd" translate="yes" xml:space="preserve">
          <source>Use the following content in the JavaScript configuration file.</source>
          <target state="translated">JavaScript 구성 파일에서 다음 내용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e1c4b14a5abd7301b86d2981a9d5c9c7b2e3b27" translate="yes" xml:space="preserve">
          <source>Use the getter syntax to create an &lt;code&gt;aliases&lt;/code&gt; class property to retrieve the alias's form array control from the parent form group.</source>
          <target state="translated">getter 구문을 사용하여 &lt;code&gt;aliases&lt;/code&gt; 클래스 특성을 작성하여 상위 양식 그룹에서 별명의 양식 배열 제어를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="2b9f9c8bf8a06791c1b3d0e9f88f619639572ebe" translate="yes" xml:space="preserve">
          <source>Use the hash symbol (#) to declare a reference variable. The following reference variable, &lt;code&gt;#phone&lt;/code&gt;, declares a &lt;code&gt;phone&lt;/code&gt; variable on an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">해시 기호 (#)를 사용하여 참조 변수를 선언하십시오. 다음 참조 변수 &lt;code&gt;#phone&lt;/code&gt; 은 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;phone&lt;/code&gt; 변수를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="bc2bab9bb36109c9261e4e21e1209550f2534701" translate="yes" xml:space="preserve">
          <source>Use the largest version, including beta and RCs.</source>
          <target state="translated">베타 및 RC를 포함하여 가장 큰 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a68d4930594481bd496a5d3065ddf5ac88c6c31d" translate="yes" xml:space="preserve">
          <source>Use the native encapsulation mechanism of the renderer. See &lt;a href=&quot;https://github.com/angular/angular/blob/3e992e18ebf51d6036818f26c3d77b52d3ec48eb/packages/core/src/metadata/view.ts#L32&quot;&gt;view.ts&lt;/a&gt;.</source>
          <target state="translated">렌더러의 기본 캡슐화 메커니즘을 사용하십시오. &lt;a href=&quot;https://github.com/angular/angular/blob/3e992e18ebf51d6036818f26c3d77b52d3ec48eb/packages/core/src/metadata/view.ts#L32&quot;&gt;view.ts를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84bc78fa2e78ed5dfdea31357fb98bf3bc73c6e3" translate="yes" xml:space="preserve">
          <source>Use the offline template compiler</source>
          <target state="translated">오프라인 템플릿 컴파일러 사용</target>
        </trans-unit>
        <trans-unit id="4e5c044a102c6e5b28de2adf47e3ca6799e2b720" translate="yes" xml:space="preserve">
          <source>Use the player object to control the animation programmatically.</source>
          <target state="translated">플레이어 객체를 사용하여 프로그래밍 방식으로 애니메이션을 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="33b6e8a56b6a428c4c11a0f9864e1086bde51fbc" translate="yes" xml:space="preserve">
          <source>Use the returned AngularJS module in a call to &lt;a href=&quot;https://docs.angularjs.org/api/ngMock/function/angular.mock.module&quot;&gt;&lt;code&gt;angular.mocks.module&lt;/code&gt;&lt;/a&gt; to include this module in the unit test injector.</source>
          <target state="translated">반환 된 AngularJS 모듈을 &lt;a href=&quot;https://docs.angularjs.org/api/ngMock/function/angular.mock.module&quot;&gt; &lt;code&gt;angular.mocks.module&lt;/code&gt; &lt;/a&gt; 에 호출 하여 단위 테스트 인젝터에이 모듈을 포함 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="5077e6c1fae00cd3872afeb69763760817a2633f" translate="yes" xml:space="preserve">
          <source>Use the returned class as an &quot;import&quot; when configuring the &lt;code&gt;&lt;a href=&quot;../../../core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../../core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 구성 할 때 반환 된 클래스를 &quot;가져 오기&quot;로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da723cd932f5f79f6b8665dde136ba0626c258d9" translate="yes" xml:space="preserve">
          <source>Use the same command to create a second lazy-loaded feature module with routing, along with its stub component.</source>
          <target state="translated">동일한 명령을 사용하여 스텁 구성 요소와 함께 라우팅이있는 두 번째 지연로드 기능 모듈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e7ea2de74a92043d55f851bb691e02d30a346279" translate="yes" xml:space="preserve">
          <source>Use the wildcard &lt;code&gt;*&lt;/code&gt; with a style to tell the animation to use whatever the current style value is, and animate with that. Wildcard is a fallback value that's used if the state being animated isn't declared within the trigger.</source>
          <target state="translated">스타일에 와일드 카드 &lt;code&gt;*&lt;/code&gt; 를 사용하여 애니메이션에 현재 스타일 값이 무엇이든 사용하도록 지시하고 애니메이션을 적용하십시오. 와일드 카드는 애니메이션중인 상태가 트리거 내에서 선언되지 않은 경우 사용되는 대체 값입니다.</target>
        </trans-unit>
        <trans-unit id="e31d6952c1ff1fd94a0e173b45067b6c83f34690" translate="yes" xml:space="preserve">
          <source>Use this API as the last resort when direct access to DOM is needed. Use templating and data-binding provided by Angular instead. Alternatively you can take a look at &lt;a href=&quot;renderer2&quot;&gt;&lt;code&gt;Renderer2&lt;/code&gt;&lt;/a&gt; which provides API that can safely be used even when direct access to native elements is not supported.</source>
          <target state="translated">DOM에 직접 액세스해야하는 경우이 API를 최후의 수단으로 사용하십시오. 대신 Angular에서 제공하는 템플릿 및 데이터 바인딩을 사용하십시오. 또는 기본 요소에 대한 직접 액세스가 지원되지 않는 경우에도 안전하게 사용할 수있는 API를 제공하는 &lt;a href=&quot;renderer2&quot;&gt; &lt;code&gt;Renderer2&lt;/code&gt; &lt;/a&gt; 를 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66dc17561e140a926f2fa11ae753d9ec492fade0" translate="yes" xml:space="preserve">
          <source>Use this API to define how an HTML element can move, change color, grow or shrink, fade, or slide off the page. These changes can occur simultaneously or sequentially. You can control the timing of each of these transformations. The function calls generate the data structures and metadata that enable Angular to integrate animations into templates and run them based on application states.</source>
          <target state="translated">이 API를 사용하여 HTML 요소가 페이지를 이동, 색상 변경, 확장 또는 축소, 페이드 또는 슬라이드 아웃하는 방법을 정의하십시오. 이러한 변경은 동시에 또는 순차적으로 발생할 수 있습니다. 이러한 각 변환의 타이밍을 제어 할 수 있습니다. 함수 호출은 Angular가 애니메이션을 템플릿에 통합하고 응용 프로그램 상태에 따라 애니메이션을 실행할 수 있도록하는 데이터 구조 및 메타 데이터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="239c77567c5a5ce0197bcc941ceca052e2b45d4e" translate="yes" xml:space="preserve">
          <source>Use this API to register directives, build form and data models, and provide validation to your forms. Validators can be synchronous or asynchronous depending on your use case. You can also extend the built-in functionality provided by forms in Angular by using the interfaces and tokens to create custom validators and input elements.</source>
          <target state="translated">지시문을 등록하고 양식 및 데이터 모델을 작성하며 양식에 대한 유효성 검증을 제공하려면이 API를 사용하십시오. 유효성 검사기는 사용 사례에 따라 동기식 또는 비동기식 일 수 있습니다. 인터페이스와 토큰을 사용하여 사용자 지정 유효성 검사기 및 입력 요소를 만들어 Angular 양식에서 제공하는 기본 제공 기능을 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98648d6e7331cfddebf675e6e48d5ecfd58e4545" translate="yes" xml:space="preserve">
          <source>Use this directive to validate a sub-group of your form separately from the rest of your form, or if some values in your domain model make more sense to consume together in a nested object.</source>
          <target state="translated">이 지정 문을 사용하여 양식의 하위 그룹을 나머지 양식과 별도로 또는 도메인 모델의 일부 값이 중첩 된 오브젝트에서 함께 소비하는 것이 더 적합한 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c2f2d6d2eb1b9fd68f5d4923160640fa9a45cb27" translate="yes" xml:space="preserve">
          <source>Use this enum at bootstrap as an option of &lt;code&gt;bootstrapModule&lt;/code&gt; to define the strategy that the compiler should use in case of missing translations:</source>
          <target state="translated">의 옵션으로 부트 스트랩에서이 열거를 사용 &lt;code&gt;bootstrapModule&lt;/code&gt; 컴파일러 누락 된 번역의 경우에 사용해야하는 전략을 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="f91861f9b1b35370d057dd7a059c665663e94008" translate="yes" xml:space="preserve">
          <source>Use this method to detect a change that Angular overlooked.</source>
          <target state="translated">이 방법을 사용하면 Angular가 간과 한 변경 사항을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a000c17e1eb4958b9423311364219b7482d859" translate="yes" xml:space="preserve">
          <source>Use this service to bypass Angular's templating and make custom UI changes that can't be expressed declaratively. For example if you need to set a property or an attribute whose name is not statically known, use &lt;a href=&quot;renderer#setElementProperty&quot;&gt;setElementProperty&lt;/a&gt; or &lt;a href=&quot;renderer#setElementAttribute&quot;&gt;setElementAttribute&lt;/a&gt; respectively.</source>
          <target state="translated">이 서비스를 사용하여 Angular의 템플릿을 무시하고 선언적으로 표현할 수없는 사용자 정의 UI를 변경하십시오. 예를 들어 이름을 정적으로 알 수없는 속성 또는 속성을 설정해야하는 경우 각각 &lt;a href=&quot;renderer#setElementProperty&quot;&gt;setElementProperty&lt;/a&gt; 또는 &lt;a href=&quot;renderer#setElementAttribute&quot;&gt;setElementAttribute를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51dda038803b68b227c51a7dd1d4b365f5cd7449" translate="yes" xml:space="preserve">
          <source>Use this technique to create a dependency object with a factory function whose inputs are a combination of &lt;em&gt;injected services&lt;/em&gt; and &lt;em&gt;local state&lt;/em&gt;.</source>
          <target state="translated">이 기술을 사용하여 입력이 &lt;em&gt;주입 된 서비스&lt;/em&gt; 와 &lt;em&gt;로컬 상태&lt;/em&gt; 의 조합 인 팩토리 함수로 종속성 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f43a26151d902b04c11d0c3a3e3e04a2047274" translate="yes" xml:space="preserve">
          <source>Use this token at bootstrap to provide the content of your translation file (&lt;code&gt;xtb&lt;/code&gt;, &lt;code&gt;xlf&lt;/code&gt; or &lt;code&gt;xlf2&lt;/code&gt;) when you want to translate your application in another language.</source>
          <target state="translated">부트 스트랩에서이 토큰을 사용 하여 응용 프로그램을 다른 언어로 번역하려는 경우 번역 파일의 내용 ( &lt;code&gt;xtb&lt;/code&gt; , &lt;code&gt;xlf&lt;/code&gt; 또는 &lt;code&gt;xlf2&lt;/code&gt; )을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="094736eaeca16e2bc6a94afbc3cacd046430016c" translate="yes" xml:space="preserve">
          <source>Use to find one or more inner HTML elements within the current element.</source>
          <target state="translated">현재 요소에서 하나 이상의 내부 HTML 요소를 찾는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ceb45b9a9a131e5ceaa63ef67912c840118032d7" translate="yes" xml:space="preserve">
          <source>Use to get the &lt;code&gt;&lt;a href=&quot;querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt; of elements or directives from the content DOM. Any time a child element is added, removed, or moved, the query list will be updated, and the changes observable of the query list will emit a new value.</source>
          <target state="translated">컨텐츠 DOM에서 요소 또는 지시문 의 &lt;code&gt;&lt;a href=&quot;querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt; 를 가져 오는 데 사용합니다 . 자식 요소가 추가, 제거 또는 이동할 때마다 쿼리 목록이 업데이트되고 쿼리 목록에서 관찰 가능한 변경 사항이 새로운 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="aaf7d01d8950aef25f0bf03d88c14b898cbfd099" translate="yes" xml:space="preserve">
          <source>Use to get the &lt;code&gt;&lt;a href=&quot;querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt; of elements or directives from the view DOM. Any time a child element is added, removed, or moved, the query list will be updated, and the changes observable of the query list will emit a new value.</source>
          <target state="translated">뷰 DOM에서 요소 또는 지시문 의 &lt;code&gt;&lt;a href=&quot;querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt; 를 가져 오는 데 사용합니다 . 자식 요소가 추가, 제거 또는 이동할 때마다 쿼리 목록이 업데이트되고 쿼리 목록에서 관찰 가능한 변경 사항이 새로운 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51523185d9e70bc9258966c8eac5f9f38fa211f8" translate="yes" xml:space="preserve">
          <source>Use to get the first element or the directive matching the selector from the content DOM. If the content DOM changes, and a new child matches the selector, the property will be updated.</source>
          <target state="translated">컨텐츠 DOM에서 선택기와 일치하는 첫 번째 요소 또는 지시문을 가져 오는 데 사용하십시오. 컨텐츠 DOM이 변경되고 새 자식이 선택자와 일치하면 속성이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a87e5cd79cc9d650614c0174e0c297ada3478f25" translate="yes" xml:space="preserve">
          <source>Use to store arbitrary developer-defined data on a renderer instance, as an object containing key-value pairs. This is useful for renderers that delegate to other renderers.</source>
          <target state="translated">키-값 쌍을 포함하는 객체로 렌더러 인스턴스에 임의의 개발자 정의 데이터를 저장하는 데 사용합니다. 다른 렌더러에게 위임하는 렌더러에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e25c946e66827dc805dd24ff51d8ae7f98f6815b" translate="yes" xml:space="preserve">
          <source>Use with animations test-only mode. Notifies the test when rendering has completed.</source>
          <target state="translated">애니메이션 테스트 전용 모드와 함께 사용하십시오. 렌더링이 완료되면 테스트에 알립니다.</target>
        </trans-unit>
        <trans-unit id="eca7e21232f973eab61af44da3d689a26c0f17dc" translate="yes" xml:space="preserve">
          <source>Use with caution</source>
          <target state="translated">주의해서 사용하십시오</target>
        </trans-unit>
        <trans-unit id="ef1c61aa074b0daa2467d00ee7659dad5f0b62ee" translate="yes" xml:space="preserve">
          <source>Use with ngModel</source>
          <target state="translated">ngModel과 함께 사용</target>
        </trans-unit>
        <trans-unit id="bddb8fbb30136aa27bb73ecdceb87cca98f6bcc9" translate="yes" xml:space="preserve">
          <source>Use with the &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; call. Instead of applying animations from the current state to the destination state, keyframes describe how each style entry is applied and at what point within the animation arc. Compare &lt;a href=&quot;https://www.w3schools.com/css/css3_animations.asp&quot;&gt;CSS Keyframe Animations&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 호출 과 함께 사용하십시오 . 키 프레임은 현재 상태에서 대상 상태로 애니메이션을 적용하는 대신 각 스타일 항목이 적용되는 방법과 애니메이션 원호의 어느 지점에 설명합니다. &lt;a href=&quot;https://www.w3schools.com/css/css3_animations.asp&quot;&gt;CSS 키 프레임 애니메이션을&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d45dfd3ff2a81b444a5dc591b91dc8c66653e7e" translate="yes" xml:space="preserve">
          <source>Use within an animation &lt;code&gt;&lt;a href=&quot;animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; call to issue a timing gap after each queried item is animated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 된 각 항목이 애니메이션 된 후 애니메이션 쿼리 () 호출 내에서 사용 하여 타이밍 간격을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="652f99cdce6039c1c4c392a599facc0ac9d2adbf" translate="yes" xml:space="preserve">
          <source>Use within an animation &lt;code&gt;&lt;a href=&quot;query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; call to issue a timing gap after each queried item is animated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 된 각 항목이 애니메이션 된 후 애니메이션 쿼리 () 호출 내에서 사용 하여 타이밍 간격을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="b8859d06d9af44888d766f829a446792669e41bf" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;core/rendererfactory2&quot;&gt;RendererFactory2&lt;/a&gt;&lt;/code&gt; to associate custom rendering data and styles with a rendering implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;core/rendererfactory2&quot;&gt;RendererFactory2&lt;/a&gt;&lt;/code&gt; 에서 사용자 정의 렌더링 데이터 및 스타일을 렌더링 구현과 연관시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="94c0582398c2c0bb749ac544039ffb4bb01b9afa" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt; 에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="60c65c08999202c9b804c2bf81c87ddaf0860f85" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;rendererfactory2&quot;&gt;RendererFactory2&lt;/a&gt;&lt;/code&gt; to associate custom rendering data and styles with a rendering implementation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rendererfactory2&quot;&gt;RendererFactory2&lt;/a&gt;&lt;/code&gt; 에서 사용자 정의 렌더링 데이터 및 스타일을 렌더링 구현과 연관시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f7d0b82c6afb0f2e3b4d749e7cc7ac4a4f630d9" translate="yes" xml:space="preserve">
          <source>Used only in debug mode to serialize property changes to dom nodes as attributes.</source>
          <target state="translated">속성 변경 사항을 속성으로 dom 노드에 직렬화하기 위해 디버그 모드에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7005a105d0d69ea62d874ba99e5723ee092e0f01" translate="yes" xml:space="preserve">
          <source>Used only in generated code. No source code should depend on this API.</source>
          <target state="translated">생성 된 코드에서만 사용됩니다. 소스 코드는이 API에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="14a1cad3d2bd65cf489b11e28cb9d774f23a3e7d" translate="yes" xml:space="preserve">
          <source>Used to load ng module factories.</source>
          <target state="translated">모듈 팩토리를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e8b3ef8c7b0f5735596a0cecd6a98afb2da940" translate="yes" xml:space="preserve">
          <source>Used to mark Async start. Async are similar to scope but they don't have to be strictly nested. The return value is used in the call to [endAsync]. Async ranges only work if WTF has been enabled.</source>
          <target state="translated">비동기 시작을 표시하는 데 사용됩니다. 비동기는 범위와 비슷하지만 엄격하게 중첩 될 필요는 없습니다. 반환 값은 [endAsync] 호출에 사용됩니다. 비동기 범위는 WTF가 활성화 된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="599d8de2a24b2f250ae7926588cacd259bc9a982" translate="yes" xml:space="preserve">
          <source>Used to mark end of Scope.</source>
          <target state="translated">범위 끝을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c9ab424d315bb61a8d13d1e6541ce25bacbe35" translate="yes" xml:space="preserve">
          <source>Used to mark scope entry. The return value is used to leave the scope.</source>
          <target state="translated">범위 항목을 표시하는 데 사용됩니다. 반환 값은 범위를 벗어나는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3503a2162dbb4997a5439b46fb2c2bf5478d21a" translate="yes" xml:space="preserve">
          <source>Used to provide a &lt;code&gt;&lt;a href=&quot;controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; for form controls.</source>
          <target state="translated">양식 컨트롤에 &lt;code&gt;&lt;a href=&quot;controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e34138b486124e172c27967e95851b105c53c11" translate="yes" xml:space="preserve">
          <source>Used to provide a &lt;code&gt;&lt;a href=&quot;forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; for form controls.</source>
          <target state="translated">양식 컨트롤에 &lt;code&gt;&lt;a href=&quot;forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c9a0ff249b4ff0367c0e831859d912df5989e4a" translate="yes" xml:space="preserve">
          <source>Used when AngularJS is loaded lazily, and not available on &lt;code&gt;window&lt;/code&gt;.</source>
          <target state="translated">AngularJS가 느리게로드되고 &lt;code&gt;window&lt;/code&gt; 에서 사용할 수 없을 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8fcc9eb0d01cd2af8a401bb5fbad0ceddd4ebbd6" translate="yes" xml:space="preserve">
          <source>Useful tools and tips for Angular.</source>
          <target state="translated">Angular에 유용한 도구 및 팁.</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">사용자 입력</target>
        </trans-unit>
        <trans-unit id="602a8dcdba61fe963a2ee0eabfa7c6c12caef58a" translate="yes" xml:space="preserve">
          <source>User actions such as clicking a link, pushing a button, and entering text raise DOM events. This page explains how to bind those events to component event handlers using the Angular event binding syntax.</source>
          <target state="translated">링크 클릭, 버튼 누르기 및 텍스트 입력과 같은 사용자 작업은 DOM 이벤트를 발생시킵니다. 이 페이지에서는 Angular 이벤트 바인딩 구문을 사용하여 해당 이벤트를 컴포넌트 이벤트 핸들러에 바인딩하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="058b267dc9414eb566cadb188507382a9127c368" translate="yes" xml:space="preserve">
          <source>User events other than &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; clicks aren't supported. You must wait for the full client app to bootstrap and run, or buffer the events using libraries like &lt;a href=&quot;https://github.com/angular/preboot&quot;&gt;preboot&lt;/a&gt;, which allow you to replay these events once the client-side scripts load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 클릭 이외의 사용자 이벤트 는 지원되지 않습니다. 클라이언트 측 스크립트가로드되면 이러한 이벤트를 재생할 수있는 &lt;a href=&quot;https://github.com/angular/preboot&quot;&gt;preboot&lt;/a&gt; 와 같은 라이브러리를 사용하여 전체 클라이언트 앱이 부트 스트랩 및 실행을 기다리거나 이벤트를 버퍼링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5141e17357a02f63be66086ece12a9f2d302df1e" translate="yes" xml:space="preserve">
          <source>Users can add, edit, and delete heroes and save these changes over HTTP.</source>
          <target state="translated">사용자는 영웅을 추가, 편집 및 삭제하고 HTTP를 통해 이러한 변경 사항을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb71aafecac3c94302931b31f63e1168c9b1166" translate="yes" xml:space="preserve">
          <source>Users can click on a product name from the list to see details in a new view, with a distinct URL (route)</source>
          <target state="translated">사용자는 목록에서 제품 이름을 클릭하여 고유 한 URL (경로)을 사용하여 새보기에서 세부 사항을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6701a88f4173410a6b0358f016f5ca47cd5c83bc" translate="yes" xml:space="preserve">
          <source>Users can opt in to share their Angular CLI usage data with &lt;a href=&quot;https://support.google.com/analytics/answer/1008015?hl=en&quot;&gt;Google Analytics&lt;/a&gt;, using the &lt;a href=&quot;https://angular.io/cli/analytics&quot;&gt;&lt;code&gt;ng analytics&lt;/code&gt; CLI command&lt;/a&gt;. The data is also shared with the Angular team, and used to improve the CLI.</source>
          <target state="translated">사용자는 &lt;a href=&quot;https://angular.io/cli/analytics&quot;&gt; &lt;code&gt;ng analytics&lt;/code&gt; &lt;/a&gt; CLI 명령을 사용하여 Angular CLI 사용 데이터를 &lt;a href=&quot;https://support.google.com/analytics/answer/1008015?hl=en&quot;&gt;Google Analytics&lt;/a&gt; 와 공유하도록 선택할 수 있습니다 . 데이터는 Angular 팀과 공유되며 CLI를 개선하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f300cd0d7b9a4b1286d7eb15eb10210c5e6bec6" translate="yes" xml:space="preserve">
          <source>Users can search for heroes by name.</source>
          <target state="translated">사용자는 이름으로 영웅을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75567a342e40c9e2e644d8dc12675b4ec829db5" translate="yes" xml:space="preserve">
          <source>Users should be able to edit the hero name in an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; textbox.</source>
          <target state="translated">사용자는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 텍스트 상자 에서 영웅 이름을 편집 할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="7b3840d786e1f73b113066b49ab864de5ce34535" translate="yes" xml:space="preserve">
          <source>Users that visit your URL will see a development server start up, and then your application will load.</source>
          <target state="translated">URL을 방문하는 사용자에게는 개발 서버가 시작된 다음 응용 프로그램이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="39302b04bcbaac9bc8c1d2667096f87cf5896e04" translate="yes" xml:space="preserve">
          <source>Users update crisis information in the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;. Unlike the &lt;code&gt;HeroDetailComponent&lt;/code&gt;, the user changes do not update the crisis entity immediately. Instead, the app updates the entity when the user presses the &lt;em&gt;Save&lt;/em&gt; button and discards the changes when the user presses the &lt;em&gt;Cancel&lt;/em&gt; button.</source>
          <target state="translated">사용자는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 에서 위기 정보를 업데이트합니다 . &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 달리 사용자 변경 사항은 위기 엔티티를 즉시 업데이트하지 않습니다. 대신 사용자가 &lt;em&gt;저장&lt;/em&gt; 버튼을 누르면 앱이 엔티티를 업데이트 하고 사용자가 &lt;em&gt;취소&lt;/em&gt; 버튼을 누르면 변경 사항을 버립니다 .</target>
        </trans-unit>
        <trans-unit id="7e5352cba15d17c20f0a63d91386ede57619fc48" translate="yes" xml:space="preserve">
          <source>Users want to see the heroes in alphabetical order. Rather than modify the original component, sub-class it and create a &lt;code&gt;SortedHeroesComponent&lt;/code&gt; that sorts the heroes before presenting them. The &lt;code&gt;SortedHeroesComponent&lt;/code&gt; lets the base class fetch the heroes.</source>
          <target state="translated">사용자는 영웅을 알파벳 순서로보고 싶어합니다. 원래 구성 요소를 수정하는 대신 하위 클래스로 분류하고 영웅을 제시하기 전에 정렬 하는 &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 를 만듭니다 . &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 는 기본 클래스는 영웅을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f8c815cbd3d0f6b995bdfc4167eccf93e89835" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; to determine which child view is entering and which is leaving the host view.</source>
          <target state="translated">용도는 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 아이 뷰가 입력되고 호스트 뷰를 떠나하는 결정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31aea878b7cc6457d61c00c1a42726ffdd26bdea" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; function to make the inner animations run in parallel.</source>
          <target state="translated">용도 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 내 애니메이션을 병렬로 실행할 수 있도록 기능한다.</target>
        </trans-unit>
        <trans-unit id="eb3f711d4d463174e45d6d4d25298cf04c07c73e" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;XMLHttpRequest&lt;/code&gt; to send requests to a backend server.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용 하여 백엔드 서버로 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fb544a35f46de4fa74e1a77fac25ace9926dc2ca" translate="yes" xml:space="preserve">
          <source>Uses the cart service's &lt;code&gt;#addToCart()&lt;/code&gt; method to add the product to the cart</source>
          <target state="translated">장바구니 서비스의 &lt;code&gt;#addToCart()&lt;/code&gt; 메소드를 사용하여 장바구니 에 제품을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="26498e934159fe90edddba43e16fe5686239bbb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt;&lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt;&lt;/a&gt; to group elements when there is no suitable host element for the directive.</source>
          <target state="translated">지시문에 적합한 호스트 요소가없는 경우 &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt; &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하여 요소를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="dafc513bc116615d9bcd01ae37d00fbc6d71e7be" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; allows the TypeScript compiler to infer that the &lt;code&gt;person&lt;/code&gt; used in the binding expression will never be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 것을 추론에 타이프 스크립트 컴파일러 수 있습니다 &lt;code&gt;person&lt;/code&gt; 바인딩 식 사용은 않을 것입니다 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2079239a97ead0b33bc251fc5c650a30d5b63e76" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="009d6972085fee6a31f1c55238d2601d61726d62" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; in a form gives you more than just two-way data binding. It also tells you if the user touched the control, if the value changed, or if the value became invalid.</source>
          <target state="translated">양식에서 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용하면 양방향 데이터 바인딩 이상의 기능이 제공됩니다. 또한 사용자가 컨트롤을 터치했는지, 값이 변경되었는지 또는 값이 유효하지 않은지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ecb3202cb740968562d3700dc9265b6286e554ac" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b80bc244560b6471b5ebc73479dd0654103c5a79" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; is a good option for hybrid apps when you want to keep the AngularJS and Angular parts less coupled. You can still mix and match components and services from both frameworks, but you might need to manually propagate change detection. In return, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; offers more control and better performance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용 하는 것은 AngularJS와 Angular 부품의 결합을 덜 유지하려는 경우 하이브리드 앱에 적합한 옵션입니다. 두 프레임 워크에서 구성 요소와 서비스를 혼합하여 사용할 수 있지만 변경 감지를 수동으로 전파해야 할 수도 있습니다. 그에 따라 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 더 많은 제어와 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74169e90061ae53df7dfd46eec63ac28d5d94ef4" translate="yes" xml:space="preserve">
          <source>Using Ahead-of-time compilation with hybrid apps</source>
          <target state="translated">하이브리드 앱에서 Ahead-of-time 컴파일 사용</target>
        </trans-unit>
        <trans-unit id="0f882c8db368aa93dcfdc9565b2fe479a0f65394" translate="yes" xml:space="preserve">
          <source>Using Angular Components from AngularJS Code</source>
          <target state="translated">AngularJS 코드에서 각도 구성 요소 사용</target>
        </trans-unit>
        <trans-unit id="23d76136981acebe9548a54e9f89615171752fe2" translate="yes" xml:space="preserve">
          <source>Using Angular with Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015에서 Angular 사용</target>
        </trans-unit>
        <trans-unit id="17c25861439c77e4c24ac7b18b709a16ebcd8414" translate="yes" xml:space="preserve">
          <source>Using AngularJS Component Directives from Angular Code</source>
          <target state="translated">각도 코드에서 AngularJS 구성 요소 지시문 사용</target>
        </trans-unit>
        <trans-unit id="6eedc5b4078ec5038cac8e2b9d65aa8e2af22115" translate="yes" xml:space="preserve">
          <source>Using Bazel with the Angular CLI</source>
          <target state="translated">Angular CLI와 함께 Bazel 사용</target>
        </trans-unit>
        <trans-unit id="c8043476b24c21372dff83314cac228b720e7e28" translate="yes" xml:space="preserve">
          <source>Using Component Directives</source>
          <target state="translated">구성 요소 지시문 사용</target>
        </trans-unit>
        <trans-unit id="5a929294f1668f68b734694e2f6b28e39e561245" translate="yes" xml:space="preserve">
          <source>Using Components and Injectables</source>
          <target state="translated">성분 및 주사제 사용</target>
        </trans-unit>
        <trans-unit id="8560edfb2496478ddf9a15a34d1f1a4eea8ae268" translate="yes" xml:space="preserve">
          <source>Using Ivy in a new project</source>
          <target state="translated">새 프로젝트에서 아이비 사용</target>
        </trans-unit>
        <trans-unit id="cf8265992d20fc1bd54761a66691a09bc3fa959c" translate="yes" xml:space="preserve">
          <source>Using Ivy in an existing project</source>
          <target state="translated">기존 프로젝트에서 아이비 사용</target>
        </trans-unit>
        <trans-unit id="bd58271391a20dd5989d94d3502323887e683ca7" translate="yes" xml:space="preserve">
          <source>Using Published Libraries</source>
          <target state="translated">게시 된 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="85890bb2deccf4180db150068e3ca159756d5544" translate="yes" xml:space="preserve">
          <source>Using UpgradeModule with Angular &lt;code&gt;NgModules&lt;/code&gt;</source>
          <target state="translated">Angular &lt;code&gt;NgModules&lt;/code&gt; 와 함께 UpgradeModule 사용</target>
        </trans-unit>
        <trans-unit id="26f2d58b409e22020a26e1496a62efdcfdf36b19" translate="yes" xml:space="preserve">
          <source>Using Web Workers with Angular CLI</source>
          <target state="translated">Angular CLI와 함께 웹 워커 사용</target>
        </trans-unit>
        <trans-unit id="25a7a129fc73369732e5d055709e4cf9d964e38c" translate="yes" xml:space="preserve">
          <source>Using a Module Loader</source>
          <target state="translated">모듈 로더 사용</target>
        </trans-unit>
        <trans-unit id="1bb470f1f27338d27d105cf1de41569b72b27987" translate="yes" xml:space="preserve">
          <source>Using a checkbox with a reactive form.</source>
          <target state="translated">반응 형과 함께 확인란 사용</target>
        </trans-unit>
        <trans-unit id="31590c1417cdeb82cd1f78154e9df03671bd0ac5" translate="yes" xml:space="preserve">
          <source>Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have &lt;em&gt;no implementation&lt;/em&gt;. The &lt;code&gt;MinimalLogger&lt;/code&gt; transpiles to this unoptimized, pre-minified JavaScript for a constructor function.</source>
          <target state="translated">클래스를 인터페이스로 사용하면 실제 JavaScript 객체의 인터페이스 특성이 제공됩니다. 그러나 메모리 비용을 최소화하려면 클래스에 &lt;em&gt;구현&lt;/em&gt; 이 &lt;em&gt;없어야합니다&lt;/em&gt; . &lt;code&gt;MinimalLogger&lt;/code&gt; 는 생성자 함수에 대한이 최적화되지 않은, 사전 축소 된 자바 스크립트에 transpiles.</target>
        </trans-unit>
        <trans-unit id="4d9d664f928769890dab78d8b2d3d0c3e2b54a9f" translate="yes" xml:space="preserve">
          <source>Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; to provide the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;localStorage&lt;/a&gt; browser API as a dependency in the &lt;code&gt;BrowserStorageService&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 공급자를 사용하면 기본 제공 브라우저 API와 같은 암시 적 종속성에 대한 구체적인 구현을 제공 할 수 있습니다. 다음 예제는 &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;localStorage&lt;/a&gt; 브라우저 API를 &lt;code&gt;BrowserStorageService&lt;/code&gt; 의 종속성으로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="02aeb5cb190c15997bab2a850739e9d394f7fa3c" translate="yes" xml:space="preserve">
          <source>Using a module loader such as &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, &lt;a href=&quot;http://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; allows us to use the built-in module systems of TypeScript or ES2015. You can use the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; features that explicitly specify what code can and will be shared between different parts of the application. For ES5 applications you can use CommonJS style &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; features. In both cases, the module loader will then take care of loading all the code the application needs in the correct order.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; , &lt;a href=&quot;http://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; 또는 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 모듈 로더 를 사용하면 TypeScript 또는 ES2015의 내장 모듈 시스템을 사용할 수 있습니다. 응용 프로그램의 다른 부분간에 공유 할 수있는 코드를 명시 적으로 지정 하는 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 기능을 사용할 수 있습니다 . ES5 애플리케이션의 경우 CommonJS 스타일 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;module.exports&lt;/code&gt; 기능을 사용할 수 있습니다 . 두 경우 모두 모듈 로더는 응용 프로그램에 필요한 모든 코드를 올바른 순서로로드합니다.</target>
        </trans-unit>
        <trans-unit id="f25102a62964a05eaec1c93977c505a046e3af36" translate="yes" xml:space="preserve">
          <source>Using a multi-select control</source>
          <target state="translated">다중 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="f0463c4ad562556ca75b5685c437f035005a3898" translate="yes" xml:space="preserve">
          <source>Using a number input with a reactive form.</source>
          <target state="translated">반응 형으로 숫자 입력 사용.</target>
        </trans-unit>
        <trans-unit id="43277715c244dfa655936028d9803ebc04d819da" translate="yes" xml:space="preserve">
          <source>Using a range input with a reactive form</source>
          <target state="translated">반응 형과 함께 범위 입력 사용</target>
        </trans-unit>
        <trans-unit id="0bc00d2438413210675960c941e89d3aaad3f65b" translate="yes" xml:space="preserve">
          <source>Using a standalone ngModel within a group</source>
          <target state="translated">그룹 내에서 독립형 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="2339a60fcda21d90b519800c5c237255868c84d4" translate="yes" xml:space="preserve">
          <source>Using absolute URLs for server requests</source>
          <target state="translated">서버 요청에 절대 URL 사용</target>
        </trans-unit>
        <trans-unit id="838f5332e38c0970cd6624c40ba4f576025a9c67" translate="yes" xml:space="preserve">
          <source>Using ahead-of-time compilation with hybrid apps</source>
          <target state="translated">하이브리드 앱으로 사전 컴파일 사용</target>
        </trans-unit>
        <trans-unit id="3fb461289e6b21adcc3eeca9c5745cff8590fa02" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; requires less boilerplate and is a good default option as it supports AOT out-of-the-box. Using a custom function requires slightly more code, but gives you greater flexibility.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; 를 사용하면 상용구 가 적고 AOT가 기본적으로 지원되므로 기본 옵션으로 사용하는 것이 좋습니다. 사용자 정의 기능을 사용하려면 약간 더 많은 코드가 필요하지만 더 큰 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="225b30fb1178e65060dad8d2124424365a8f210e" translate="yes" xml:space="preserve">
          <source>Using an Angular custom element makes the process much simpler and more transparent, by providing all of the infrastructure and framework automatically&amp;mdash;all you have to do is define the kind of event handling you want. (You do still have to exclude the component from compilation, if you are not going to use it in your app.)</source>
          <target state="translated">Angular 사용자 정의 요소를 사용하면 모든 인프라와 프레임 워크를 자동으로 제공하여 프로세스를 훨씬 간단하고 투명하게 만들 수 있습니다. 원하는 이벤트 처리 유형을 정의하기 만하면됩니다. 앱에서 구성 요소를 사용하지 않으려는 경우 구성 요소를 컴파일에서 제외해야합니다.</target>
        </trans-unit>
        <trans-unit id="b770296ed0960ba4e0adf200d5857757fb6ba30c" translate="yes" xml:space="preserve">
          <source>Using an external &lt;code&gt;then&lt;/code&gt; template</source>
          <target state="translated">외부 사용하여 &lt;code&gt;then&lt;/code&gt; 템플릿을</target>
        </trans-unit>
        <trans-unit id="6551ed39890875715b3cd0878168d51e0620c7b7" translate="yes" xml:space="preserve">
          <source>Using an inline function</source>
          <target state="translated">인라인 함수 사용</target>
        </trans-unit>
        <trans-unit id="1f00ba280ffbec54abe918ad286a8c43241f37e6" translate="yes" xml:space="preserve">
          <source>Using component styles</source>
          <target state="translated">컴포넌트 스타일 사용</target>
        </trans-unit>
        <trans-unit id="326e590dcb9985b96603eaad2f203133d3ba3bbb" translate="yes" xml:space="preserve">
          <source>Using components vs services from other modules</source>
          <target state="translated">다른 모듈의 구성 요소와 서비스 사용</target>
        </trans-unit>
        <trans-unit id="a5d277d826e502273f12e8b03216771a9c8b14ca" translate="yes" xml:space="preserve">
          <source>Using containers for native elements</source>
          <target state="translated">기본 요소에 컨테이너 사용</target>
        </trans-unit>
        <trans-unit id="dcca472daafb75114b08b61eb39f9ca73d6a3a8d" translate="yes" xml:space="preserve">
          <source>Using corporate proxy</source>
          <target state="translated">회사 프록시 사용</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">맞춤 요소 사용</target>
        </trans-unit>
        <trans-unit id="d9d0d750c5305782eba2c313f6df5f97406ecfca" translate="yes" xml:space="preserve">
          <source>Using directives with &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule에&lt;/a&gt; 지시문 사용</target>
        </trans-unit>
        <trans-unit id="59731cbdea4e70d97215a2a24c9617e473f8ae07" translate="yes" xml:space="preserve">
          <source>Using environment-specific variables in your app</source>
          <target state="translated">앱에서 환경 별 변수 사용</target>
        </trans-unit>
        <trans-unit id="dbf5a34485d6afcadda2f26d6136cf55d8a92517" translate="yes" xml:space="preserve">
          <source>Using ngModel on a standalone control</source>
          <target state="translated">독립형 컨트롤에서 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="9a7f37dd828f83348b0672d7bb9204b26a305b1d" translate="yes" xml:space="preserve">
          <source>Using ngModel within a form</source>
          <target state="translated">양식 내에서 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="767134f57267e4073023d69bfe85a0ae385d07cf" translate="yes" xml:space="preserve">
          <source>Using observables to handle events and asynchronous operations can have the advantage of greater consistency in contexts such as HTTP requests.</source>
          <target state="translated">옵저버 블을 사용하여 이벤트 및 비동기 작업을 처리하면 HTTP 요청과 같은 컨텍스트에서 일관성이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525cb205ecf77ef26071eabcc120a080cdae4b66" translate="yes" xml:space="preserve">
          <source>Using one of our &lt;code&gt;options&lt;/code&gt; is very straightforward, we did this in the previous section when we accessed &lt;code&gt;options.command&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 중 하나를 사용하는 것은 매우 간단합니다. 이전 섹션에서 &lt;code&gt;options.command&lt;/code&gt; 에 액세스했을 때이 작업을 수행했습니다 .</target>
        </trans-unit>
        <trans-unit id="54dca9e5d7f69c01aedf3f75ceb5a7cb672bb0ac" translate="yes" xml:space="preserve">
          <source>Using pipes</source>
          <target state="translated">파이프 사용</target>
        </trans-unit>
        <trans-unit id="89ebc794fed95d63f9561d0bda00bb5d55f1a0f8" translate="yes" xml:space="preserve">
          <source>Using radio buttons with reactive form directives</source>
          <target state="translated">반응 형 지시문에 라디오 버튼 사용</target>
        </trans-unit>
        <trans-unit id="2e5b826e5d221359e0500389d0018c9bdd597f16" translate="yes" xml:space="preserve">
          <source>Using route information</source>
          <target state="translated">경로 정보 사용</target>
        </trans-unit>
        <trans-unit id="881f18e8deeb52c2a18dfc164af0a161e22b725b" translate="yes" xml:space="preserve">
          <source>Using runtime-global libraries inside your app</source>
          <target state="translated">앱 내에서 런타임 전역 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="9bd2ff97908a0c09c2d63474c3cfcc5434417451" translate="yes" xml:space="preserve">
          <source>Using select controls in a reactive form</source>
          <target state="translated">반응 형으로 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="832a53e426313323000169f37f744b9b7aa99d81" translate="yes" xml:space="preserve">
          <source>Using select controls in a template-driven form</source>
          <target state="translated">템플릿 기반 양식에서 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="88275c4f479097c72fb4415e38dc5583792a3082" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 배열</target>
        </trans-unit>
        <trans-unit id="8cd2ad1f42cec0fd44d2b578a1a5e65f273ee4d6" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property is preferable to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; array because with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt;, optimization tools can perform tree-shaking, which removes services that your app isn't using and results in smaller bundle sizes.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 재산은에 바람직하다 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 에 있기 때문에 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; , 최적화 도구는 나무 떨고, 작은 번들 크기로 앱이 사용되지 않도록 서비스 및 결과를 제거 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e7ac3035137317853416afbb770970d2510fd53" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property to refer to &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;, or &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 특성은 참조하는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; , 또는 &lt;code&gt;root&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e75e4bed92d2b5bcba6a93626663647ccf1ee802" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 배열을.</target>
        </trans-unit>
        <trans-unit id="0c704679875decd7bc5e10cd52d8163394039311" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; decorator, the injector only looks at the component's injector for its providers. The &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The &lt;code&gt;sessionStorageService&lt;/code&gt; instance interacts with the &lt;code&gt;BrowserStorageService&lt;/code&gt; using the &lt;code&gt;sessionStorage&lt;/code&gt; browser API, while the &lt;code&gt;localStorageService&lt;/code&gt; skips the local injector and uses the root &lt;code&gt;BrowserStorageService&lt;/code&gt; that uses the &lt;code&gt;localStorage&lt;/code&gt; browser API.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; 데코레이터, 인젝터는 그 공급자에 대한 구성 요소의 인젝터 본다. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; 장식은 공급자 만족이 종속성을 찾을 수있는 지역 인젝터를 건너 뛰고 계층 구조에서 찾아 볼 수 있습니다. &lt;code&gt;sessionStorageService&lt;/code&gt; 의 와 인스턴스 상호 작용 &lt;code&gt;BrowserStorageService&lt;/code&gt; 은 Using &lt;code&gt;sessionStorage&lt;/code&gt; 의 그동안, 브라우저 API를 &lt;code&gt;localStorageService&lt;/code&gt; 이 루트 로컬 인젝터를 건너 뛰고 사용 &lt;code&gt;BrowserStorageService&lt;/code&gt; 이 사용하는 &lt;code&gt;localStorage&lt;/code&gt; 브라우저 API를.</target>
        </trans-unit>
        <trans-unit id="9c2ddaa9a4477a0d280fe7ff4b0889ca96f1260c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;providers&lt;/code&gt; array</source>
          <target state="translated">은 Using &lt;code&gt;providers&lt;/code&gt; 배열을</target>
        </trans-unit>
        <trans-unit id="87db3d87246b0ba7b1f6a1e65402304267c078f0" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate class&lt;/code&gt;&lt;/a&gt;, generate a new class named &lt;code&gt;Hero&lt;/code&gt;:</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate class&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Hero&lt;/code&gt; 라는 새 클래스를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="24653eb83b101fbb344fe1dd41060b459319c087" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt;, generate a new component named &lt;code&gt;HeroForm&lt;/code&gt;:</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;HeroForm&lt;/code&gt; 이라는 새 컴포넌트를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="81efa0d631504c35459bdd579b8b05a652508d3a" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI, create a service called &lt;code&gt;hero&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 &lt;code&gt;hero&lt;/code&gt; 라는 서비스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965eb7867ed11aa022c0e42434572bd02fabfa4" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI, generate a new component named &lt;code&gt;heroes&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 &lt;code&gt;heroes&lt;/code&gt; 라는 새 컴포넌트를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5adb7aa313a235cb09657ba564b95feb23f9777" translate="yes" xml:space="preserve">
          <source>Using the Angular Unified Location Service</source>
          <target state="translated">각도 통합 위치 서비스 사용</target>
        </trans-unit>
        <trans-unit id="3385d7778ed34c624bab677d8b93113048ea3d70" translate="yes" xml:space="preserve">
          <source>Using the Hero class</source>
          <target state="translated">Hero 클래스 사용</target>
        </trans-unit>
        <trans-unit id="78f7880d324d4d6b362277b5293f7d5e81175744" translate="yes" xml:space="preserve">
          <source>Using the RxJS scheduler inside fakeAsync()</source>
          <target state="translated">fakeAsync () 내에서 RxJS 스케줄러 사용</target>
        </trans-unit>
        <trans-unit id="460ffdb79528b543b65d0023597d166efc0e6187" translate="yes" xml:space="preserve">
          <source>Using the Unified Angular Location Service</source>
          <target state="translated">통합 각도 위치 서비스 사용</target>
        </trans-unit>
        <trans-unit id="9a66563e1975c2187a0773744f035412c7a0c811" translate="yes" xml:space="preserve">
          <source>Using the default value accessor</source>
          <target state="translated">기본값 액세서 사용</target>
        </trans-unit>
        <trans-unit id="d8d0dd351b925abe0013872e2187d3ac63a5f4b4" translate="yes" xml:space="preserve">
          <source>Using the graphviz optional dependency, you'll have a program &lt;code&gt;dot&lt;/code&gt;, which you can use with &lt;code&gt;bazel &lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">graphviz 선택적 의존성 을 사용하면 &lt;code&gt;bazel &lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/animations/query&quot;&gt;쿼리&lt;/a&gt; 와 함께 사용할 수 있는 프로그램 &lt;code&gt;dot&lt;/code&gt; 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="701a7ae767b31ad4b44a0cd1aae2842c56741ee2" translate="yes" xml:space="preserve">
          <source>Using the key &lt;code&gt;$implicit&lt;/code&gt; in the context object will set its value as default.</source>
          <target state="translated">컨텍스트 객체에서 &lt;code&gt;$implicit&lt;/code&gt; 키를 사용하면 해당 값이 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="97fd999fe0f9f9e0225af291a35e80bbf1a2a5cb" translate="yes" xml:space="preserve">
          <source>Using the template binding syntax, the form control is now registered to the &lt;code&gt;name&lt;/code&gt; input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view.</source>
          <target state="translated">템플릿 바인딩 구문을 사용하여 양식 컨트롤이 이제 템플릿 의 &lt;code&gt;name&lt;/code&gt; 입력 요소에 등록됩니다 . 폼 컨트롤과 DOM 요소는 서로 통신합니다. 뷰는 모델의 변경 사항을 반영하고 모델은 뷰의 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a73267180af548e33b36453222ddbcd0a9cd7a26" translate="yes" xml:space="preserve">
          <source>Using wildcard state with multiple transition states</source>
          <target state="translated">다중 전이 상태와 함께 와일드 카드 상태 사용</target>
        </trans-unit>
        <trans-unit id="f5248445a88890c526dc548b5736616908228cef" translate="yes" xml:space="preserve">
          <source>Using wildcards with styles</source>
          <target state="translated">스타일과 함께 와일드 카드 사용</target>
        </trans-unit>
        <trans-unit id="3732652b5c565611a56c0e8b0ff175f176f6e899" translate="yes" xml:space="preserve">
          <source>Using your own library in apps</source>
          <target state="translated">앱에서 자신의 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="36b3c5921b9dbb0818575770f742474b0a62f5c5" translate="yes" xml:space="preserve">
          <source>Usually there's only one component in this list, the &lt;em&gt;root component&lt;/em&gt; of the application.</source>
          <target state="translated">일반적으로이 목록 에는 응용 프로그램 의 &lt;em&gt;루트 구성 요소&lt;/em&gt; 인 구성 요소가 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a319f5c807a99dec0b4916cda29f6050d992dd8" translate="yes" xml:space="preserve">
          <source>Usually, setting an element property with a &lt;a href=&quot;template-syntax#property-binding&quot;&gt;property binding&lt;/a&gt; is preferable to setting the attribute with a string. However, sometimes there is no element property to bind, so attribute binding is the solution.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;template-syntax#property-binding&quot;&gt;특성 바인딩을&lt;/a&gt; 사용하여 요소 특성 을 설정하는 것이 문자열로 특성을 설정하는 것이 좋습니다. 그러나 바인딩 할 요소 속성이없는 경우가 있으므로 속성 바인딩이 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="0da3a16df4f1cfe00ccae4cb470106238ee3f50d" translate="yes" xml:space="preserve">
          <source>Validate against a maximum of 15</source>
          <target state="translated">최대 15 개에 대해 검증</target>
        </trans-unit>
        <trans-unit id="b626a91102f28dde09ef4feac857a53784030579" translate="yes" xml:space="preserve">
          <source>Validate against a minimum of 3</source>
          <target state="translated">최소 3에 대해 검증</target>
        </trans-unit>
        <trans-unit id="5f2d339a1d7ad3e7b42679e5d838c4f7db0e2db1" translate="yes" xml:space="preserve">
          <source>Validate that the field has a minimum of 3 characters</source>
          <target state="translated">필드가 3 자 이상인지 확인</target>
        </trans-unit>
        <trans-unit id="365af241d710fd38bb8fc6a89e93b90b0d1db454" translate="yes" xml:space="preserve">
          <source>Validate that the field has maximum of 5 characters</source>
          <target state="translated">필드가 최대 5 자인지 확인</target>
        </trans-unit>
        <trans-unit id="0506ee2af8e063c56ec116feb2754facf42c90d0" translate="yes" xml:space="preserve">
          <source>Validate that the field is non-empty</source>
          <target state="translated">필드가 비어 있지 않은지 확인</target>
        </trans-unit>
        <trans-unit id="a3381e343a3617a4bb231a512be6fc59fa34d569" translate="yes" xml:space="preserve">
          <source>Validate that the field matches a valid email pattern</source>
          <target state="translated">필드가 유효한 이메일 패턴과 일치하는지 확인</target>
        </trans-unit>
        <trans-unit id="403d97dc000145ae46f642bb7353f29a0deade7a" translate="yes" xml:space="preserve">
          <source>Validate that the field only contains letters or spaces</source>
          <target state="translated">필드에 문자 나 공백 만 포함되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="b1d42fbeab767bb81064a062ffe20d0f69ea59f2" translate="yes" xml:space="preserve">
          <source>Validate that the field value is true</source>
          <target state="translated">필드 값이 true인지 확인</target>
        </trans-unit>
        <trans-unit id="23b8880400d5deddab1250ea0a0ef87bbdae38db" translate="yes" xml:space="preserve">
          <source>Validate the correctness of user input.</source>
          <target state="translated">사용자 입력의 정확성을 검증하십시오.</target>
        </trans-unit>
        <trans-unit id="f43a0dc6633797adf7396b6cf232151d02e24338" translate="yes" xml:space="preserve">
          <source>Validation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.</source>
          <target state="translated">유효성 검사는 모든 양식 집합을 관리하는 데 필수적인 부분입니다. 필수 필드를 확인하거나 기존 사용자 이름에 대한 외부 API를 쿼리 할 때 Angular는 기본 제공 유효성 검사기 세트와 사용자 지정 유효성 검사기를 만들 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70933a459fa1beb4c3976a98043f612aca8bc6ae" translate="yes" xml:space="preserve">
          <source>Validation is set up through validation functions rather than valdation directives.</source>
          <target state="translated">유효성 검사는 유효성 검사 지시문이 아닌 유효성 검사 기능을 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="42b88cee0411df854ab9ab8680b74f241740fc3c" translate="yes" xml:space="preserve">
          <source>ValidationErrors</source>
          <target state="translated">ValidationErrors</target>
        </trans-unit>
        <trans-unit id="6e5b7a60980482ab39ae77b25489457b817517cd" translate="yes" xml:space="preserve">
          <source>Validator</source>
          <target state="translated">Validator</target>
        </trans-unit>
        <trans-unit id="e37939a31ae2f93a355efd2e41823a0ccd0104e8" translate="yes" xml:space="preserve">
          <source>Validator functions</source>
          <target state="translated">검사기 기능</target>
        </trans-unit>
        <trans-unit id="0b6adf9f43ac26d416c0fe91c7ae74d404335f9c" translate="yes" xml:space="preserve">
          <source>Validator that performs no operation.</source>
          <target state="translated">작업을 수행하지 않는 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="bf6a47ff451c3b9d71ebb71124e408131e842715" translate="yes" xml:space="preserve">
          <source>Validator that requires the control have a non-empty value.</source>
          <target state="translated">제어가 필요한 유효성 검사기는 비어 있지 않은 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9b247107c6248f97a52d72465eaa594dac9f871b" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value be true. This validator is commonly used for required checkboxes.</source>
          <target state="translated">컨트롤 값이 필요한 유효성 검사기입니다. 이 유효성 검사기는 일반적으로 필수 확인란에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae1c5182294db9a183f7aa482d9d8a206c1d386" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value pass an email validation test.</source>
          <target state="translated">컨트롤 값이 필요한 유효성 검사기는 전자 메일 유효성 검사 테스트를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="0106b5809c999beadaacdf16e65d183947be2d35" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to be greater than or equal to the provided number. The validator exists only as a function and not as a directive.</source>
          <target state="translated">컨트롤 값이 제공된 숫자보다 크거나 같아야하는 유효성 검사기 유효성 검사기는 지시문이 아닌 함수로만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="162dfec38e764abc2921d5b06f86d1bcbeadf02b" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to be less than or equal to the provided number. The validator exists only as a function and not as a directive.</source>
          <target state="translated">컨트롤 값이 제공된 숫자보다 작거나 같아야하는 유효성 검사기입니다. 유효성 검사기는 지시문이 아닌 함수로만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="52c39a07c7e7121efa3eaeb3fbe77b7575251296" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to match a regex pattern. This validator is also provided by default if you use the HTML5 &lt;code&gt;&lt;a href=&quot;patternvalidator&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">정규식 패턴과 일치하는 컨트롤 값이 필요한 검사기입니다. HTML5 &lt;code&gt;&lt;a href=&quot;patternvalidator&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="76256d2b6665f1a3f3640f2890572f05710a20d7" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be greater than or equal to the provided minimum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최소 길이 이상이어야하는 유효성 검사기. HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9d855798656a116c1182141d94fad28454e4e72" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be less than or equal to the provided maximum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최대 길이보다 작거나 같아야하는 유효성 검사기입니다. HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d29f76e695670cc31b55309fdad4de99247e6232" translate="yes" xml:space="preserve">
          <source>ValidatorFn</source>
          <target state="translated">ValidatorFn</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="d2f1e7eaab356f70c51f6149188803cfa1f41bd2" translate="yes" xml:space="preserve">
          <source>Value providers</source>
          <target state="translated">가치 제공자</target>
        </trans-unit>
        <trans-unit id="20f9ff3e7294e59511661cc02c6349a3f6b1ebb7" translate="yes" xml:space="preserve">
          <source>Value providers: &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">가치 제공자 : &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fe3282b947225da293afc6b4fd0512f85bae210" translate="yes" xml:space="preserve">
          <source>ValueProvider</source>
          <target state="translated">ValueProvider</target>
        </trans-unit>
        <trans-unit id="e16f3c18243dc608a013837c5a79a4d00bdb7bc7" translate="yes" xml:space="preserve">
          <source>ValueSansProvider</source>
          <target state="translated">ValueSansProvider</target>
        </trans-unit>
        <trans-unit id="5d5c6b67c9db0e498e790e883c5de52f385275d8" translate="yes" xml:space="preserve">
          <source>Verify that no unmatched requests are outstanding.</source>
          <target state="translated">일치하지 않는 요청이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="81c258b63dad449560a58fedcf568dc6b8a49576" translate="yes" xml:space="preserve">
          <source>Version from which to migrate from. Only available with a single package being updated, and only on migration only.</source>
          <target state="translated">마이그레이션 할 버전입니다. 단일 패키지가 업데이트되고 마이그레이션에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fc66ec0d0963a90667a2ecf160141fe6e6b47961" translate="yes" xml:space="preserve">
          <source>Version up to which to apply migrations. Only available with a single package being updated, and only on migrations only. Requires from to be specified. Default to the installed version detected.</source>
          <target state="translated">마이그레이션을 적용 할 버전입니다. 단일 패키지가 업데이트되고 마이그레이션에서만 사용 가능합니다. from을 지정해야합니다. 설치된 버전으로 기본 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad05dbfb7d147c73816ab1fecdddddf16429566f" translate="yes" xml:space="preserve">
          <source>Versioning, release, support, and deprecation practices: &lt;a href=&quot;releases&quot;&gt;Angular versioning and releases&lt;/a&gt;</source>
          <target state="translated">버전 관리, 릴리스, 지원 및 사용 중단 사례 : &lt;a href=&quot;releases&quot;&gt;각도 버전 관리 및 릴리스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40e309254a1c09b7db3fd4b9af2fa9ecaa53129a" translate="yes" xml:space="preserve">
          <source>View encapsulation</source>
          <target state="translated">캡슐화보기</target>
        </trans-unit>
        <trans-unit id="63a105276cb081db80a13c002ab391c84407745d" translate="yes" xml:space="preserve">
          <source>View hierarchies can be loaded and unloaded dynamically as the user navigates through the application, typically under the control of a &lt;a href=&quot;glossary#router&quot;&gt;router&lt;/a&gt;.</source>
          <target state="translated">사용자가 일반적으로 &lt;a href=&quot;glossary#router&quot;&gt;라우터&lt;/a&gt; 의 제어하에 애플리케이션을 탐색 할 때 뷰 계층을 동적으로로드 및 언로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ced146390f04d6176a1c9baafe3663557cd5bb9c" translate="yes" xml:space="preserve">
          <source>View queries are set before the &lt;code&gt;ngAfterViewInit&lt;/code&gt; callback is called.</source>
          <target state="translated">&lt;code&gt;ngAfterViewInit&lt;/code&gt; 콜백이 호출 되기 전에 뷰 쿼리가 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="70b22bdcbbd499b2cd172768582a04965d178285" translate="yes" xml:space="preserve">
          <source>ViewChild</source>
          <target state="translated">ViewChild</target>
        </trans-unit>
        <trans-unit id="731e75cc493e2b3f0e1520064261281cd209667b" translate="yes" xml:space="preserve">
          <source>ViewChildren</source>
          <target state="translated">ViewChildren</target>
        </trans-unit>
        <trans-unit id="c0b27cd972ffd1977642761def1f7be9a42f5afa" translate="yes" xml:space="preserve">
          <source>ViewContainerRef</source>
          <target state="translated">ViewContainerRef</target>
        </trans-unit>
        <trans-unit id="e5240a7ff11b6693e9588a24feef5960dd5495b8" translate="yes" xml:space="preserve">
          <source>ViewEncapsulation</source>
          <target state="translated">ViewEncapsulation</target>
        </trans-unit>
        <trans-unit id="bb27c41c6081cf7c9006a0c2e01017e596206e38" translate="yes" xml:space="preserve">
          <source>ViewRef</source>
          <target state="translated">ViewRef</target>
        </trans-unit>
        <trans-unit id="85787f7a1fbf5317a97c6316e18e928d4f590507" translate="yes" xml:space="preserve">
          <source>ViewportScroller</source>
          <target state="translated">ViewportScroller</target>
        </trans-unit>
        <trans-unit id="aa8824d0dbe6def19d33585bef0db1c629139af5" translate="yes" xml:space="preserve">
          <source>Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's &lt;em&gt;host view&lt;/em&gt;. The component can also define a &lt;em&gt;view hierarchy&lt;/em&gt;, which contains &lt;em&gt;embedded views&lt;/em&gt;, hosted by other components.</source>
          <target state="translated">보기는 일반적으로 계층 적으로 정렬되므로 전체 UI 섹션 또는 페이지를 한 단위로 수정하거나 표시하거나 숨길 수 있습니다. 컴포넌트와 즉시 연관된 템플리트는 해당 컴포넌트의 &lt;em&gt;호스트보기를&lt;/em&gt; 정의합니다 . 구성 요소는 다른 구성 요소에서 호스팅 하는 포함 &lt;em&gt;된 뷰&lt;/em&gt; 가 포함 &lt;em&gt;된 &lt;/em&gt;&lt;em&gt;뷰 계층 구조를&lt;/em&gt; 정의 할 수도 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1386eabb408835f08cb05d409256f611a521fdc" translate="yes" xml:space="preserve">
          <source>Visibility decorators influence where the search for the injection token begins and ends in the logic tree. To do this, place visibility decorators at the point of injection, that is, the &lt;code&gt;constructor()&lt;/code&gt;, rather than at a point of declaration.</source>
          <target state="translated">가시성 데코레이터는 주입 토큰 검색이 로직 트리에서 시작하고 끝나는 위치에 영향을줍니다. 이렇게하려면 가시성 데코레이터를 선언 지점이 아닌 주입 지점, 즉 &lt;code&gt;constructor()&lt;/code&gt; 에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="01354e09c47bfba10344c316d3973dd8d8c0c124" translate="yes" xml:space="preserve">
          <source>Visibility of provided tokens</source>
          <target state="translated">제공된 토큰의 가시성</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">비주얼 스튜디오 코드</target>
        </trans-unit>
        <trans-unit id="5bd87aebeff1926fd4da28c306978ef7e958002f" translate="yes" xml:space="preserve">
          <source>Visual Studio now looks first for external tools in the current workspace and if it doesn't find them, it looks in the global path. If Visual Studio doesn't find them in either location, it will use its own versions of the tools.</source>
          <target state="translated">Visual Studio는 현재 현재 작업 공간에서 외부 도구를 먼저 찾고, 찾지 못하면 전역 경로를 찾습니다. Visual Studio가 어느 위치에서나 찾지 못하면 자체 버전의 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf912685bcd3b8695b78564cf9cc45a83ef11075" translate="yes" xml:space="preserve">
          <source>Visual Studio ships with IIS Express, which has the rewrite module baked in. However, if you're using regular IIS you'll have to install the rewrite module.</source>
          <target state="translated">Visual Studio에는 다시 쓰기 모듈이 포함 된 IIS Express가 제공됩니다. 그러나 일반 IIS를 사용하는 경우 다시 쓰기 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a00dd5a3fe4b1a6a174763f1ccc3255c559d786" translate="yes" xml:space="preserve">
          <source>Visualize a &lt;em&gt;banana in a box&lt;/em&gt; to remember that the parentheses go &lt;em&gt;inside&lt;/em&gt; the brackets.</source>
          <target state="translated">시각화 &lt;em&gt;상자에 바나나를&lt;/em&gt; 괄호가는 것을 기억하는 것이 &lt;em&gt;내부에&lt;/em&gt; 괄호.</target>
        </trans-unit>
        <trans-unit id="ae20d0dcd36854dd9c33ee0729b11a0b952fd48f" translate="yes" xml:space="preserve">
          <source>Void state</source>
          <target state="translated">무효 상태</target>
        </trans-unit>
        <trans-unit id="363d01361c13e93cb5c5849c62cc7a9e5fb2a36f" translate="yes" xml:space="preserve">
          <source>Voil&amp;agrave;! &lt;code&gt;['/crisis-center']&lt;/code&gt;.</source>
          <target state="translated">oil! &lt;code&gt;['/crisis-center']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="7d863250597b39573e59f2dd5bbdb466dcefa3eb" translate="yes" xml:space="preserve">
          <source>W3C - Web Accessibility Initiative</source>
          <target state="translated">W3C-웹 접근성 이니셔티브</target>
        </trans-unit>
        <trans-unit id="a8973c4ad76d66d81020d94041af9480559aca02" translate="yes" xml:space="preserve">
          <source>WARNING: this pipe uses the Internationalization API which is not yet available in all browsers and may require a polyfill. See &lt;a href=&quot;../../guide/browser-support&quot;&gt;Browser Support&lt;/a&gt; for details.</source>
          <target state="translated">경고 :이 파이프는 아직 모든 브라우저에서 사용할 수없는 국제화 API를 사용하며 폴리 필이 필요할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../guide/browser-support&quot;&gt;브라우저 지원&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c07ec44ed7c7c12105929adc7842d7938752526a" translate="yes" xml:space="preserve">
          <source>WARNINGS:</source>
          <target state="translated">WARNINGS:</target>
        </trans-unit>
        <trans-unit id="6c1d5662bd95a1bc248614055dd45cd2c7c74fae" translate="yes" xml:space="preserve">
          <source>WORKER_APP_LOCATION_PROVIDERS</source>
          <target state="translated">WORKER_APP_LOCATION_PROVIDERS</target>
        </trans-unit>
        <trans-unit id="82986323ee9a26fe8f93325355793336b70d0475" translate="yes" xml:space="preserve">
          <source>WORKER_UI_LOCATION_PROVIDERS</source>
          <target state="translated">WORKER_UI_LOCATION_PROVIDERS</target>
        </trans-unit>
        <trans-unit id="fc298440e65c9e288e74a2aa8c9b6a8c4ae86157" translate="yes" xml:space="preserve">
          <source>WORKSPACE CONFIG FILES</source>
          <target state="translated">작업 공간 구성 파일</target>
        </trans-unit>
        <trans-unit id="9ecaf9bcefceb097a640b14a0a1ef2fe6fb7fab4" translate="yes" xml:space="preserve">
          <source>Wait for 100ms and then run for 200ms: &lt;code&gt;'0.2s 100ms'&lt;/code&gt;</source>
          <target state="translated">100ms 동안 기다린 다음 200ms 동안 실행하십시오 : &lt;code&gt;'0.2s 100ms'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bc78e562cbe874c8773d19cf4be97f0463bbc5e" translate="yes" xml:space="preserve">
          <source>Wait for 100ms, run for 200ms. Use a deceleration curve to start out fast and slowly decelerate to a resting point: &lt;code&gt;'0.2s 100ms ease-out'&lt;/code&gt;</source>
          <target state="translated">100ms 동안 기다렸다가 200ms 동안 실행하십시오. 감속 곡선을 사용하여 빠르게 시작하고 휴식 점으로 천천히 감속하십시오 : &lt;code&gt;'0.2s 100ms ease-out'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b5586b3bb95ca7c31cb3c22819d08ba3bebb1c3" translate="yes" xml:space="preserve">
          <source>Wait for the application to be stable with a timeout. If the timeout is reached before that happens, the callback receives a list of the macro tasks that were pending, otherwise null.</source>
          <target state="translated">시간 종료로 응용 프로그램이 안정 될 때까지 기다리십시오. 이 시간이 초과되기 전에 시간 초과에 도달하면 콜백은 보류중인 매크로 작업 목록을받습니다. 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="5397416bedc6dd6eb062cf6b283a2ffe2c518c96" translate="yes" xml:space="preserve">
          <source>Warning (default): show a 'Missing translation' warning in the console or shell.</source>
          <target state="translated">경고 (기본값) : 콘솔 또는 셸에 '번역 누락'경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="05c345e4ec19aba46a5943dc0f547f62c9342ec1" translate="yes" xml:space="preserve">
          <source>Warning (default): show a warning in the console and/or shell.</source>
          <target state="translated">경고 (기본값) : 콘솔 및 / 또는 셸에 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="88b85d9988679e4293fa4ac6a48242d90d816934" translate="yes" xml:space="preserve">
          <source>Watch mode</source>
          <target state="translated">시계 모드</target>
        </trans-unit>
        <trans-unit id="049327f20280160e2798ffbfea9f0196b9c52a75" translate="yes" xml:space="preserve">
          <source>We also share with you the desire for Angular to keep evolving. We strive to ensure that the foundation on top of which you are building is continuously improving and enabling you to stay up-to-date with the rest of the web ecosystem and your user needs.</source>
          <target state="translated">또한 Angular가 계속 발전하기를 원합니다. 우리는 귀하가 구축하고있는 기초가 지속적으로 개선되고 귀하가 나머지 웹 생태계와 사용자 요구에 대해 최신 상태를 유지할 수 있도록 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="367ba1138b6b56e08c59f2f66d2ac44e4a858807" translate="yes" xml:space="preserve">
          <source>We are working on custom elements that can be used by web apps built on other frameworks. A minimal, self-contained version of the Angular framework will be injected as a service to support the component's change-detection and data-binding functionality. For more about the direction of development, check out this &lt;a href=&quot;https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;amp;t=4s&quot;&gt;video presentation&lt;/a&gt;.</source>
          <target state="translated">다른 프레임 워크를 기반으로 구축 된 웹 앱에서 사용할 수있는 사용자 지정 요소를 연구하고 있습니다. 자체 포함 된 최소한의 Angular 프레임 워크 버전은 구성 요소의 변경 감지 및 데이터 바인딩 기능을 지원하는 서비스로 삽입됩니다. 개발 방향에 대한 자세한 내용은이 &lt;a href=&quot;https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;amp;t=4s&quot;&gt;비디오 프레젠테이션을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6a5c87a2d5a877756756b0475d44bae01c02874" translate="yes" xml:space="preserve">
          <source>We ask all contributing authors to adhere to three aspects of style:</source>
          <target state="translated">모든 기고자에게 스타일의 세 가지 측면을 준수하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="ec11a33a55c211bc5d98f96df3c7c4a5d0617287" translate="yes" xml:space="preserve">
          <source>We can delay updating the form validity by changing the &lt;code&gt;updateOn&lt;/code&gt; property from &lt;code&gt;change&lt;/code&gt; (default) to &lt;code&gt;submit&lt;/code&gt; or &lt;code&gt;blur&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updateOn&lt;/code&gt; 속성을 &lt;code&gt;change&lt;/code&gt; (기본값)에서 &lt;code&gt;submit&lt;/code&gt; 또는 &lt;code&gt;blur&lt;/code&gt; 로 변경하여 양식 유효성 업데이트를 지연시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd8e866ad285f0dc9892217e61259175ebd3fd46" translate="yes" xml:space="preserve">
          <source>We can provide the following schema for type validation of these values.</source>
          <target state="translated">이러한 값의 형식 유효성 검사를 위해 다음 스키마를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2931f0896f596ff16cc12f410c35306a64670a62" translate="yes" xml:space="preserve">
          <source>We can publish the builder to npm (see &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;Publishing your Library&lt;/a&gt;), and install it using the following command:</source>
          <target state="translated">빌더를 npm에 공개하고 ( &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;라이브러리 공개&lt;/a&gt; 참조 ) 다음 명령을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee14b2f048236515de09f569a5537a505db84ddc" translate="yes" xml:space="preserve">
          <source>We can retrieve a Logger instance from the context.</source>
          <target state="translated">컨텍스트에서 Logger 인스턴스를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed979d867401216782d14206d29678b5df7afa90" translate="yes" xml:space="preserve">
          <source>We follow the deprecation policy described here, so you have time to update your apps to the latest APIs and best practices.</source>
          <target state="translated">여기에 설명 된 지원 중단 정책을 따르므로 앱을 최신 API 및 모범 사례로 업데이트 할 시간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b76a51b7a99c79ff1cc0f3f2bebb68cb9f17f8" translate="yes" xml:space="preserve">
          <source>We have discussed the basic HTTP functionality in &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt;, but sometimes you need to do more than make simple requests and get data back.</source>
          <target state="translated">&lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; 의 기본 HTTP 기능에 대해 논의 했지만 때로는 간단한 요청을하고 데이터를 다시 가져 오는 것 이상을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3da62ac46ab52ae87815d94ca4d56bf01a862f1" translate="yes" xml:space="preserve">
          <source>We let you preview what's coming by providing Beta releases and Release Candidates (&lt;code&gt;rc&lt;/code&gt;) for each major and minor release:</source>
          <target state="translated">각 주 및 부 릴리스에 대해 베타 릴리스 및 릴리스 후보 ( &lt;code&gt;rc&lt;/code&gt; )를 제공하여 예정된 내용을 미리 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b91a3f18bcf41bca5f95939f116cf6e3d59216ba" translate="yes" xml:space="preserve">
          <source>We meet this goal by displaying code snippets that are derived directly from standalone code samples, written specifically for these guide pages.</source>
          <target state="translated">이 가이드 페이지를 위해 특별히 작성된 독립형 코드 샘플에서 직접 파생 된 코드 스 니펫을 표시하여이 목표를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="3137f17ffcf69ea0fc771d5e9d7c10273ff1f4f9" translate="yes" xml:space="preserve">
          <source>We must create a &lt;code&gt;&lt;a href=&quot;../../core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; that will make this AngularJS component available inside Angular templates.</source>
          <target state="translated">이 AngularJS 컴포넌트를 Angular 템플릿 내에서 사용할 수 있도록 &lt;code&gt;&lt;a href=&quot;../../core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf1fc25d3116f8dea78230e2816ca8675a89a9fe" translate="yes" xml:space="preserve">
          <source>We must create an AngularJS &lt;a href=&quot;https://docs.angularjs.org/guide/directive&quot;&gt;directive&lt;/a&gt; that will make this Angular component available inside AngularJS templates. The &lt;code&gt;&lt;a href=&quot;downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; function returns a factory function that we can use to define the AngularJS directive that wraps the &quot;downgraded&quot; component.</source>
          <target state="translated">이 Angular 컴포넌트를 AngularJS 템플릿 내에서 사용할 수있게 하는 AngularJS &lt;a href=&quot;https://docs.angularjs.org/guide/directive&quot;&gt;지시문&lt;/a&gt; 을 작성해야합니다 . &lt;code&gt;&lt;a href=&quot;downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; 함수가 반환은 우리가 AngularJS와를 정의하는 데 사용할 수있는 공장 함수는이 (가) 구성 요소를 &quot;다운 그레이드&quot;래핑 지시어.</target>
        </trans-unit>
        <trans-unit id="4f0b3a7bbc11be9ec5f1d0d0772101f30b20afa5" translate="yes" xml:space="preserve">
          <source>We need to update the &lt;code&gt;angular.json&lt;/code&gt; file to add a target for this builder to the &quot;architect&quot; section of our new project.</source>
          <target state="translated">이 빌더의 대상을 새 프로젝트의 &quot;architect&quot;섹션에 추가 하려면 &lt;code&gt;angular.json&lt;/code&gt; 파일 을 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f07def30e46276be4e20aec308dade0a77d9924" translate="yes" xml:space="preserve">
          <source>We now have the framework in place for creating the code that actually modifies the user's application to set it up for the service defined in your library.</source>
          <target state="translated">이제 사용자의 응용 프로그램을 실제로 수정하여 라이브러리에 정의 된 서비스에 맞게 설정하는 코드를 작성하기위한 프레임 워크가 마련되었습니다.</target>
        </trans-unit>
        <trans-unit id="fdfba83206c23f3c099770c464e3ad4b48b0dbb9" translate="yes" xml:space="preserve">
          <source>We recognize that you need stability from the Angular framework. Stability ensures that reusable components and libraries, tutorials, tools, and learned practices don't become obsolete unexpectedly. Stability is essential for the ecosystem around Angular to thrive.</source>
          <target state="translated">Angular 프레임 워크의 안정성이 필요하다는 것을 알고 있습니다. 안정성은 재사용 가능한 컴포넌트 및 라이브러리, 학습서, 도구 및 학습 된 실습이 예기치 않게 사용되지 않도록합니다. Angular 주변의 생태계가 번창하기 위해서는 안정성이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="77d09fc97147b2ef90d76928341a69ca7bde154c" translate="yes" xml:space="preserve">
          <source>We recommend that you always update to the latest patch version, as it contains fixes we released since the initial major release. For example, use the following command to take the latest 7.x.x version and use that to update.</source>
          <target state="translated">초기 주요 릴리스 이후 출시 된 수정 프로그램이 포함되어 있으므로 항상 최신 패치 버전으로 업데이트하는 것이 좋습니다. 예를 들어, 다음 명령을 사용하여 최신 7.xx 버전을 가져 와서 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="775687186195b9a3e24a2f53506fea1a527d8ea0" translate="yes" xml:space="preserve">
          <source>We recommend that you do not force an update of all dependencies by default. Try updating specific dependencies first.</source>
          <target state="translated">기본적으로 모든 종속성을 강제로 업데이트하지 않는 것이 좋습니다. 특정 종속성을 먼저 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="80be1bb38ec0ca675a20185b65c4dba9e98272bb" translate="yes" xml:space="preserve">
          <source>We recommend that you use integration tests to test Architect builders. You can use unit tests to validate the logic that the builder executes.</source>
          <target state="translated">통합 테스트를 사용하여 Architect 빌더를 테스트하는 것이 좋습니다. 단위 테스트를 사용하여 빌더가 실행하는 논리를 유효성 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310cfdcf5af5f6be333c6538a69706c32e03c366" translate="yes" xml:space="preserve">
          <source>We want the user to click a product name to display the details for that product.</source>
          <target state="translated">사용자가 제품 이름을 클릭하여 해당 제품의 세부 사항을 표시하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="963319a4bbeb2a266dbe49a9dbba7d16c6c97bad" translate="yes" xml:space="preserve">
          <source>We want to hear from you. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;Report problems or submit suggestions for future docs.&lt;/a&gt;</source>
          <target state="translated">우리는 당신의 의견을 듣고 싶습니다. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;문제를보고하거나 향후 문서에 대한 제안을 제출하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08ccad7003f1e35885c0a7207dc4655e386f189a" translate="yes" xml:space="preserve">
          <source>We work hard to minimize the number of breaking changes and to provide migration tools when possible.</source>
          <target state="translated">우리는 주요 변경 사항의 수를 최소화하고 가능한 경우 마이그레이션 도구를 제공하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ef513b5b64fa187df26f2b88bdd0df53b470f9" translate="yes" xml:space="preserve">
          <source>We work toward a regular schedule of releases, so that you can plan and coordinate your updates with the continuing evolution of Angular.</source>
          <target state="translated">우리는 정기적 인 릴리스 일정을 향해 노력하고 있으므로 Angular의 지속적인 진화로 업데이트를 계획하고 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7ca8850d7d3e95260cdb1a36e87b1bd5a2f9ab" translate="yes" xml:space="preserve">
          <source>We'll add a new target section to the &quot;architect&quot; object for our project.</source>
          <target state="translated">프로젝트의 &quot;architect&quot;객체에 새로운 대상 섹션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1f0e521cbcb2ebaba4d1dd2e5a53e9662e8db9ca" translate="yes" xml:space="preserve">
          <source>We'll assume that your library defines a service, &lt;code&gt;my-service&lt;/code&gt;, that requires some setup. You want your users to be able to generate it using the following CLI command.</source>
          <target state="translated">라이브러리 가 설정이 필요한 &lt;code&gt;my-service&lt;/code&gt; 정의한다고 가정합니다 . 다음 CLI 명령을 사용하여 사용자가이를 생성 할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="455855d6e204ab91263b75701fa13e1551077ff1" translate="yes" xml:space="preserve">
          <source>We'll be using &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome#cli&quot;&gt;Headless Chrome&lt;/a&gt; in these examples.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome#cli&quot;&gt;헤드리스 크롬&lt;/a&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0023425c9a40172e734cbb5e99d9df3d9f24d37a" translate="yes" xml:space="preserve">
          <source>We'll create the cart page in two steps:</source>
          <target state="translated">카트 페이지를 두 단계로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9c13304de9fb7403344d19d9edc7669863094bb9" translate="yes" xml:space="preserve">
          <source>We've added a &lt;code&gt;builders.json&lt;/code&gt; file next to the builder's &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json&quot;&gt;&lt;code&gt;package.json&lt;/code&gt; file&lt;/a&gt;, and modified the package file to point to it.</source>
          <target state="translated">우리는 추가 한 &lt;code&gt;builders.json&lt;/code&gt; 의 옆 빌더의에 파일을 &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; 의 파일&lt;/a&gt; , 그리고 그것에 지점에 패키지 파일을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="229504c90b2ed36005a13f0891c6ea34dd49cee8" translate="yes" xml:space="preserve">
          <source>Web Animations</source>
          <target state="translated">웹 애니메이션</target>
        </trans-unit>
        <trans-unit id="c689af566e60edb050fba04883329a2b969d41aa" translate="yes" xml:space="preserve">
          <source>Web Tracing Framework integration</source>
          <target state="translated">웹 추적 프레임 워크 통합</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="96c7816359b06d625431375d1cbdc07ed4556d66" translate="yes" xml:space="preserve">
          <source>Week day</source>
          <target state="translated">요일</target>
        </trans-unit>
        <trans-unit id="6cb4f0e33b17b0f52c241793df12a1dd4d39da62" translate="yes" xml:space="preserve">
          <source>Week of month</source>
          <target state="translated">매주</target>
        </trans-unit>
        <trans-unit id="b634011cda59925fcb33d601d8b1227879d65bbc" translate="yes" xml:space="preserve">
          <source>Week of year</source>
          <target state="translated">연중 주</target>
        </trans-unit>
        <trans-unit id="09cfafc979eda38b81da9ec21690558d2edcbfd0" translate="yes" xml:space="preserve">
          <source>WeekDay</source>
          <target state="translated">WeekDay</target>
        </trans-unit>
        <trans-unit id="ec1d4a2eb821d65b5f91f9b7b510a0c9033552d6" translate="yes" xml:space="preserve">
          <source>Welcome to Angular!</source>
          <target state="translated">Angular에 오신 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="f31d5caf28c1c07d1ee03f259600799b9c986539" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive? You didn't add an &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; directive.</source>
          <target state="translated">어떤 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시어? &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; 지시문을 추가하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="550389c79bd6aad13b8b970d4d70593adcb978c0" translate="yes" xml:space="preserve">
          <source>What are structural directives?</source>
          <target state="translated">구조적 지시문이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f9f442481556abfd102cc7155daba690e1a9a733" translate="yes" xml:space="preserve">
          <source>What changed?</source>
          <target state="translated">무엇이 바뀌 었습니까?</target>
        </trans-unit>
        <trans-unit id="f8328397c60c8af6da98225a51e8980b05f6b4e4" translate="yes" xml:space="preserve">
          <source>What classes should I &lt;code&gt;not&lt;/code&gt; add to &lt;code&gt;declarations&lt;/code&gt;?</source>
          <target state="translated">어떻게 수업을해야 &lt;code&gt;not&lt;/code&gt; 에 추가 &lt;code&gt;declarations&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6d27e0d2fc8a84f6cbfebe6fe7c1d1ca3170ab86" translate="yes" xml:space="preserve">
          <source>What classes should I add to the &lt;code&gt;declarations&lt;/code&gt; array?</source>
          <target state="translated">&lt;code&gt;declarations&lt;/code&gt; 배열에 어떤 클래스를 추가해야 합니까?</target>
        </trans-unit>
        <trans-unit id="057eaac6f0deedde6be1f19bfebd7864c77aaaea" translate="yes" xml:space="preserve">
          <source>What do you do about unapproved, unsaved changes when the user navigates away? You can't just leave and risk losing the user's changes; that would be a terrible experience.</source>
          <target state="translated">사용자가 다른 곳으로 이동할 때 승인되지 않은 저장되지 않은 변경 사항에 대해 어떻게합니까? 사용자의 변경 사항을 그대로두고 잃을 위험이 없습니다. 그것은 끔찍한 경험이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="473d6c927a1e922bb838df64558b20be71bcb2f4" translate="yes" xml:space="preserve">
          <source>What does &quot;Can't bind to 'x' since it isn't a known property of 'y'&quot; mean?</source>
          <target state="translated">&quot; 'y'의 알려진 속성이 아니기 때문에 'x'에 바인딩 할 수 없습니다&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="2a4d6e81b7048543cdc7f0bf6420334628995a10" translate="yes" xml:space="preserve">
          <source>What good are these tests?</source>
          <target state="translated">이 테스트는 어떤 점이 좋습니까?</target>
        </trans-unit>
        <trans-unit id="e9ef659a9f0dd7f7a57fd0812697b64f3b70b6ea" translate="yes" xml:space="preserve">
          <source>What happened?</source>
          <target state="translated">어떻게 된 거예요?</target>
        </trans-unit>
        <trans-unit id="a8ce06e7c8801f5352d9b466e0f76fb6c3c8a84b" translate="yes" xml:space="preserve">
          <source>What happens if the request fails on the server, or if a poor network connection prevents it from even reaching the server? &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; will return an &lt;em&gt;error&lt;/em&gt; object instead of a successful response.</source>
          <target state="translated">요청이 서버에서 실패하거나 네트워크 연결 상태가 좋지 않아 서버에 도달하지 못하는 경우 어떻게됩니까? &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 성공적인 응답 대신 &lt;em&gt;오류&lt;/em&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="10d9fbb31e05693074cbd05ef7c4fa4b5d4cc854" translate="yes" xml:space="preserve">
          <source>What happens on top of this is that components and services managed by one framework can interoperate with those from the other framework. This happens in three main areas: Dependency injection, the DOM, and change detection.</source>
          <target state="translated">무엇보다 한 프레임 워크에서 관리하는 구성 요소 및 서비스가 다른 프레임 워크의 구성 요소 및 서비스와 상호 운용 될 수 있습니다. 이는 의존성 주입, DOM 및 변경 감지의 세 가지 주요 영역에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15d57a03ad72e64e2f967c9b58b84e47c42f4e56" translate="yes" xml:space="preserve">
          <source>What if I import the same module twice?</source>
          <target state="translated">동일한 모듈을 두 번 가져 오면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="67698516018294ce714cfa0910ed88df86860dcc" translate="yes" xml:space="preserve">
          <source>What if the service is optional?</source>
          <target state="translated">서비스가 선택 사항 인 경우 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="fdf373766dbd491f797bd75ad9a27bc85492ffa5" translate="yes" xml:space="preserve">
          <source>What if the user tries to navigate away without saving or canceling? The user could push the browser back button or click the heroes link. Both actions trigger a navigation. Should the app save or cancel automatically?</source>
          <target state="translated">사용자가 저장하거나 취소하지 않고 이동하려고하면 어떻게합니까? 사용자는 브라우저 뒤로 버튼을 누르거나 영웅 링크를 클릭 할 수 있습니다. 두 작업 모두 탐색을 트리거합니다. 앱이 자동으로 저장 또는 취소해야합니까?</target>
        </trans-unit>
        <trans-unit id="3fc3074fd43e313b68435dd9d3eccbad57fbacca" translate="yes" xml:space="preserve">
          <source>What if two modules provide the same service?</source>
          <target state="translated">두 개의 모듈이 동일한 서비스를 제공하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="84612cf3c8dbe22a08e1d681d1e151867a37c306" translate="yes" xml:space="preserve">
          <source>What if you &lt;em&gt;don't&lt;/em&gt; know the concrete parent component class?</source>
          <target state="translated">구체적인 부모 구성 요소 클래스를 모른다 면 어떻게 &lt;em&gt;해야&lt;/em&gt; 합니까?</target>
        </trans-unit>
        <trans-unit id="9571231b9a6513e5bda3f63b2546e2f10a6caf27" translate="yes" xml:space="preserve">
          <source>What if you aren't so lucky. What if faking the &lt;code&gt;HeroService&lt;/code&gt; is hard? What if &lt;code&gt;HeroDetailService&lt;/code&gt; makes its own server requests?</source>
          <target state="translated">운이 좋지 않으면 어떻게 될까요? &lt;code&gt;HeroService&lt;/code&gt; 를 가짜로 만드는 것이 어려운 경우 어떻게해야 합니까? 만약에 &lt;code&gt;HeroDetailService&lt;/code&gt; 는 자체 서버 요청을 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2af22762107db85dc423fbbae7b2defe8142ea5a" translate="yes" xml:space="preserve">
          <source>What is a &lt;code&gt;declarable&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;declarable&lt;/code&gt; 있는 것은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="f22c2deef328e587dff4aa9d84977cb40974b2b3" translate="yes" xml:space="preserve">
          <source>What is an &lt;code&gt;entry component&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;entry component&lt;/code&gt; 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="42a60fa4661b031df7525d26e30ae45290feeb4f" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; method?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 메소드 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="393dcffc17ce162eb4715e7887f6986bef77f253" translate="yes" xml:space="preserve">
          <source>What is the Angular compiler?</source>
          <target state="translated">Angular 컴파일러 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ca032b5844df22ede2117e0697547ac14af77ed3" translate="yes" xml:space="preserve">
          <source>What it does</source>
          <target state="translated">그것이하는 일</target>
        </trans-unit>
        <trans-unit id="ce3efec53dfa7b3f17d8b379e8bb6f5b1fe81172" translate="yes" xml:space="preserve">
          <source>What kinds of modules should I have and how should I use them?</source>
          <target state="translated">어떤 종류의 모듈이 있어야하며 어떻게 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="8492f572f03fd01c98f764f87b2ecfafaba6438b" translate="yes" xml:space="preserve">
          <source>What should I &lt;code&gt;not&lt;/code&gt; export?</source>
          <target state="translated">나는 무엇을해야 &lt;code&gt;not&lt;/code&gt; 내보내?</target>
        </trans-unit>
        <trans-unit id="272547099bb1eafdb8c114cedd1c025f49babd8d" translate="yes" xml:space="preserve">
          <source>What should I export?</source>
          <target state="translated">무엇을 내 보내야합니까?</target>
        </trans-unit>
        <trans-unit id="2fba818e3c12cdfea661b9e5031ad159d26edea6" translate="yes" xml:space="preserve">
          <source>What should I import?</source>
          <target state="translated">무엇을 가져와야합니까?</target>
        </trans-unit>
        <trans-unit id="f56cc84fec0aec96345c31e5e364bd0bf53c27f7" translate="yes" xml:space="preserve">
          <source>What this means is that applications using &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</source>
          <target state="translated">이것이 의미하는 바는 &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 사용하는 응용 프로그램 은 가능한 변경에 대해 두 프레임 워크 모두에 올바르게 알림을 전달하기 위해 더 자주 변경 감지를 실행한다는 것입니다. 필연적으로 필요한 것보다 더 많은 변경 감지 실행이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e748865fabf06ac85d0efb3686d535f7edbe194" translate="yes" xml:space="preserve">
          <source>What to do if Angular doesn't find what you're looking for, that is &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">Angular가 당신이 찾고있는 것을 찾지 못하면, 즉 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e88cb973cd5369993be64ec9b2cc3ad10b9b55a" translate="yes" xml:space="preserve">
          <source>What was previously done in the controller function is now done in the class constructor function. The dependency injection annotations are attached to the class using a static property &lt;code&gt;$inject&lt;/code&gt;. At runtime this becomes the &lt;code&gt;PhoneListController.$inject&lt;/code&gt; property.</source>
          <target state="translated">이전에 컨트롤러 함수에서 수행 된 작업은 이제 클래스 생성자 함수에서 수행됩니다. 종속성 인젝션 주석은 &lt;code&gt;$inject&lt;/code&gt; 정적 속성을 사용하여 클래스에 첨부됩니다 . 런타임에 이것은 &lt;code&gt;PhoneListController.$inject&lt;/code&gt; 특성이됩니다.</target>
        </trans-unit>
        <trans-unit id="36bcf3cf57500860c4fe2fa7525f4f11a0d1ee9c" translate="yes" xml:space="preserve">
          <source>What went wrong? Nothing, actually. The Angular service worker is doing its job and serving the version of the application that it has &lt;strong&gt;installed&lt;/strong&gt;, even though there is an update available. In the interest of speed, the service worker doesn't wait to check for updates before it serves the application that it has cached.</source>
          <target state="translated">무엇이 잘못 되었나요? 사실은 없습니다. 사용 가능한 업데이트가 있더라도 Angular 서비스 워커는 작업을 수행하고 &lt;strong&gt;설치된&lt;/strong&gt; 애플리케이션 버전을 제공하고 있습니다. 속도 향상을 위해 서비스 워커는 캐시 된 응용 프로그램에 서비스를 제공하기 전에 업데이트 확인을 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f165c8fe830c74b722cf3c40b0f1a6351cc255e" translate="yes" xml:space="preserve">
          <source>What you include in your library is determined by the kind of task you are trying to accomplish. For example, if you want a dropdown with some canned data to show how to add it to your app, your library could define a schematic to create it. For a component like a dropdown that would contain different passed-in values each time, you could provide it as a component in a shared library.</source>
          <target state="translated">라이브러리에 포함하는 것은 수행하려는 작업의 종류에 따라 결정됩니다. 예를 들어 통조림 데이터가있는 드롭 다운에 앱에 데이터를 추가하는 방법을 보여 주려면 라이브러리에서 회로도를 정의하여이를 만들 수 있습니다. 매번 다른 전달 된 값을 포함하는 드롭 다운과 같은 구성 요소의 경우 공유 라이브러리에서 구성 요소로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7efedb21f9cc31360041f1387aa92e01cf8751ea" translate="yes" xml:space="preserve">
          <source>What you'll build</source>
          <target state="translated">무엇을 만들 것인가</target>
        </trans-unit>
        <trans-unit id="206c37a11b4ea4cf13bb051d8b88deddea5ec07c" translate="yes" xml:space="preserve">
          <source>What's being cached?</source>
          <target state="translated">캐시되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b0da2957891f63fe85f0b681e42bc7c99353b6ac" translate="yes" xml:space="preserve">
          <source>What's in the QuickStart seed?</source>
          <target state="translated">빠른 시작 시드에는 무엇이 있습니까?</target>
        </trans-unit>
        <trans-unit id="bbe4cab88394b14ba3632e2b2dcf364b507a5fba" translate="yes" xml:space="preserve">
          <source>What's new? What's changed? We share the most important things you need to know on the Angular blog in &lt;a href=&quot;https://blog.angular.io/tagged/release%20notes&quot;&gt;release announcements&lt;/a&gt;.</source>
          <target state="translated">새로운 소식 무엇이 바뀌 었습니까? &lt;a href=&quot;https://blog.angular.io/tagged/release%20notes&quot;&gt;릴리스 발표&lt;/a&gt; 에서 Angular 블로그에서 알아야 할 가장 중요한 사항을 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="46fdeff62267a834862780ae0326b4c1aaa4483d" translate="yes" xml:space="preserve">
          <source>What's next</source>
          <target state="translated">무엇 향후 계획</target>
        </trans-unit>
        <trans-unit id="c9d5de0ac54b4a1d6831c0c5c8cc8b083df30290" translate="yes" xml:space="preserve">
          <source>What's the difference between NgModules and JavaScript Modules?</source>
          <target state="translated">NgModules와 JavaScript 모듈의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="df4456b644d2af7318557209dc4f1b5237c4e5d9" translate="yes" xml:space="preserve">
          <source>What's the difference between a &lt;code&gt;bootstrap&lt;/code&gt; component and an &lt;code&gt;entry component&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;bootstrap&lt;/code&gt; 구성 요소와 &lt;code&gt;entry component&lt;/code&gt; 요소 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="a2003b1e0230fe60f289921936009ec90172775d" translate="yes" xml:space="preserve">
          <source>Whatever the source, the doc viewer renders them as &quot;code snippets&quot;, either individually with the &lt;a href=&quot;docs-style-guide#code-example&quot;&gt;&lt;em&gt;code-example&lt;/em&gt;&lt;/a&gt; component or as a tabbed collection with the &lt;a href=&quot;docs-style-guide#code-tabs&quot;&gt;&lt;em&gt;code-tabs&lt;/em&gt;&lt;/a&gt; component.</source>
          <target state="translated">소스가 무엇이든 문서 뷰어는 &lt;a href=&quot;docs-style-guide#code-example&quot;&gt;&lt;em&gt;코드 예제&lt;/em&gt;&lt;/a&gt; 구성 요소를 사용하여 개별적으로 또는 &lt;a href=&quot;docs-style-guide#code-tabs&quot;&gt;&lt;em&gt;코드 탭&lt;/em&gt;&lt;/a&gt; 구성 요소를 사용하여 탭 모음 으로 &quot;코드 스 니펫&quot;으로 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="d40735da03c29f6121c2a672d8e066562771fdbb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glossary#server-side-rendering&quot;&gt;server-side rendering&lt;/a&gt; (SSR) is used, the &lt;a href=&quot;../api/platform-server&quot;&gt;&lt;code&gt;platform-server&lt;/code&gt;&lt;/a&gt; package provides web server implementations of the &lt;code&gt;DOM&lt;/code&gt;, &lt;code&gt;XMLHttpRequest&lt;/code&gt;, and other low-level features that don't rely on a browser.</source>
          <target state="translated">때 &lt;a href=&quot;glossary#server-side-rendering&quot;&gt;서버 측 렌더링&lt;/a&gt; (SSR)를 사용하는 경우, &lt;a href=&quot;../api/platform-server&quot;&gt; &lt;code&gt;platform-server&lt;/code&gt; &lt;/a&gt; 패키지의 웹 서버 구현 제공 &lt;code&gt;DOM&lt;/code&gt; , &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의 브라우저에 의존하지 않는, 그리고 다른 하위 수준 기능을.</target>
        </trans-unit>
        <trans-unit id="8914c537808edf1a7a626676a069039b9f296c22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; requests the &lt;code&gt;FlowerService&lt;/code&gt;, the injector begins its search at the &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; belonging to &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; (&lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; is included because it is injected from &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt;) and ends with &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;. In this case, the &lt;code&gt;FlowerService&lt;/code&gt; is resolved in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;'s &lt;code&gt;providers&lt;/code&gt; array with sunflower 🌻. The injector doesn't have to look any further in the injector tree. It stops as soon as it finds the &lt;code&gt;FlowerService&lt;/code&gt; and never sees the 🌺 (red hibiscus).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 요청 &lt;code&gt;FlowerService&lt;/code&gt; 는 상기 인젝터는 상기의 검색 시작 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에 속하는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; ( &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 는 그것이로부터 분사되기 때문에 포함 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 와 단부) &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; . 이 경우 &lt;code&gt;FlowerService&lt;/code&gt; 는 해바라기를 가진 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 의 &lt;code&gt;providers&lt;/code&gt; 배열에서 확인됩니다. 인젝터는 인젝터 트리에서 더 이상 볼 필요가 없습니다. 그것은 &lt;code&gt;FlowerService&lt;/code&gt; 를 발견하자마자 멈추고 🌺 (빨간색 히비스커스)을 보지 못합니다.</target>
        </trans-unit>
        <trans-unit id="3a290ab7d29486d5dec0940d7942415d6fab40d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; requests the &lt;code&gt;FlowerService&lt;/code&gt;, it is the injector's job to resolve the &lt;code&gt;FlowerService&lt;/code&gt; token. The resolution of the token happens in two phases:</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 요청 &lt;code&gt;FlowerService&lt;/code&gt; 를 , 그것을 해결하기 위해 인젝터의 일이다 &lt;code&gt;FlowerService&lt;/code&gt; 의 토큰. 토큰의 해결은 두 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="21374804442ed472300ccdecb64c9e08c0ae1478" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; is not provided, uses query results to determine the timing of query resolution. If any query results are inside a nested view (such as &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;), the query is resolved after change detection runs. Otherwise, it is resolved before change detection runs.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 제공되지 않는 쿼리 해상도의 타이밍을 결정하는 쿼리 결과를 사용합니다. 쿼리 결과가 중첩 뷰 내에있는 경우 (예 : &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; ) 변경 감지가 실행 된 후 쿼리가 해결됩니다. 그렇지 않으면 변경 감지가 실행되기 전에 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="53e5281d1686a6ec68990211a7fd328735128905" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; is not provided, uses the query results to determine the timing of query resolution. If any query results are inside a nested view (such as &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;), the query is resolved after change detection runs. Otherwise, it is resolved before change detection runs.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 제공되지 않는 쿼리 해상도의 타이밍을 결정하기 위해 쿼리 결과를 사용합니다. 쿼리 결과가 중첩 뷰 내에있는 경우 (예 : &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; ) 변경 감지가 실행 된 후 쿼리가 해결됩니다. 그렇지 않으면 변경 감지가 실행되기 전에 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="9f2951b5265473e47083f23251a243f2533334e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@.disabled&lt;/code&gt; is true, it prevents the &lt;code&gt;@childAnimation&lt;/code&gt; trigger from animating, along with any inner animations.</source>
          <target state="translated">경우 &lt;code&gt;@.disabled&lt;/code&gt; 사실, 상기 방지 &lt;code&gt;@childAnimation&lt;/code&gt; 의 모든 내부 애니메이션과 함께 살리는에서 트리거.</target>
        </trans-unit>
        <trans-unit id="aae654a850870dc683e195d0d86f434df815ab22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; were applied to the &lt;code&gt;FlowerService&lt;/code&gt;, which is in the &lt;code&gt;providers&lt;/code&gt; array, the result was &lt;code&gt;null&lt;/code&gt; because &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; starts its search in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; injector, but &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; stops searching at &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;&amp;mdash;where there is no &lt;code&gt;FlowerService&lt;/code&gt;. In the logical tree, you can see that the &lt;code&gt;FlowerService&lt;/code&gt; is visible in &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;, not its &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에인가 된 &lt;code&gt;FlowerService&lt;/code&gt; 에, &lt;code&gt;providers&lt;/code&gt; 어레이 결과였다 &lt;code&gt;null&lt;/code&gt; 때문에 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에서의 검색 시작 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 인젝터하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 검색을 중지 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 -FlowerService 가없는 &lt;code&gt;FlowerService&lt;/code&gt; . 논리 트리에서 &lt;code&gt;FlowerService&lt;/code&gt; 가 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 가 아니라 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 에 표시되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bdf758a1a9690d4ad83702a2aa70dc21cb575b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;addHero()&lt;/code&gt; saves successfully, the &lt;code&gt;subscribe()&lt;/code&gt; callback receives the new hero and pushes it into to the &lt;code&gt;heroes&lt;/code&gt; list for display.</source>
          <target state="translated">때 &lt;code&gt;addHero()&lt;/code&gt; 성공적으로 저장의은 &lt;code&gt;subscribe()&lt;/code&gt; 콜백은 새로운 영웅을 수신하고에로 밀어 &lt;code&gt;heroes&lt;/code&gt; 표시 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f10aac19bd7597b8018bacfe0f5ef7081c6eb8a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bindingProperty&lt;/code&gt; is not provided, it is assumed to be equal to &lt;code&gt;directiveProperty&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bindingProperty&lt;/code&gt; 가 제공되지 않으며,이를 동일한 것으로 간주 &lt;code&gt;directiveProperty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed12b19518c977a855a7af5f7bcbb3780eb478a3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;false&lt;/code&gt;, disables this rewriting, requiring the rewriting to be done manually.</source>
          <target state="translated">때 &lt;code&gt;false&lt;/code&gt; , 수동으로 수행 할 재 작성 요구,이 재 작성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0a78206a1f0896e2816ea253bc9930ac1c56dfe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ngc&lt;/code&gt; runs, it compiles &lt;code&gt;AppModule&lt;/code&gt; into a module factory, which contains definitions for all the providers declared in all the modules it includes. At runtime, this factory becomes an injector that instantiates these services.</source>
          <target state="translated">&lt;code&gt;ngc&lt;/code&gt; 는 실행될 때 &lt;code&gt;AppModule&lt;/code&gt; 을 모듈 팩토리로 컴파일합니다 . 여기에는 포함 된 모든 모듈에 선언 된 모든 공급자에 대한 정의가 들어 있습니다. 런타임시이 팩토리는 이러한 서비스를 인스턴스화하는 인젝터가됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b2139d05d2a8c8f3fc1f7405ee8a5d8b302144" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;selectedHero&lt;/code&gt; is undefined, the &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; removes the hero detail from the DOM. There are no &lt;code&gt;selectedHero&lt;/code&gt; bindings to consider.</source>
          <target state="translated">경우 &lt;code&gt;selectedHero&lt;/code&gt; 가 정의되지는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 DOM을 행 영웅 내용을 제거한다. 고려할 &lt;code&gt;selectedHero&lt;/code&gt; 바인딩 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e05e0539b42ad79b46d59d705a37b7a3d0c21c93" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the compiler does not check the TypeScript version and does not report an error when an unsupported version of TypeScript is used. Not recommended, as unsupported versions of TypeScript might have undefined behavior. Default is false.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 컴파일러는 타이프 라이터 버전을 확인하지 않고 타이프의 지원되지 않는 버전을 사용하는 경우 오류를보고하지 않습니다. 지원되지 않는 버전의 TypeScript에 정의되지 않은 동작이있을 수 있으므로 권장되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="548c1033b7a8da41ee5f0961ac1576b4e9faa14a" translate="yes" xml:space="preserve">
          <source>When Angular creates &lt;code&gt;AppComponent&lt;/code&gt;, the DI framework creates an instance of &lt;code&gt;LoggerService&lt;/code&gt; and starts to create &lt;code&gt;UserContextService&lt;/code&gt;. &lt;code&gt;UserContextService&lt;/code&gt; also needs &lt;code&gt;LoggerService&lt;/code&gt;, which the framework already has, so the framework can provide the same instance. &lt;code&gt;UserContextService&lt;/code&gt; also needs &lt;code&gt;UserService&lt;/code&gt;, which the framework has yet to create. &lt;code&gt;UserService&lt;/code&gt; has no further dependencies, so the framework can simply use &lt;code&gt;new&lt;/code&gt; to instantiate the class and provide the instance to the &lt;code&gt;UserContextService&lt;/code&gt; constructor.</source>
          <target state="translated">Angular가 &lt;code&gt;AppComponent&lt;/code&gt; 를 만들면 DI 프레임 워크는 &lt;code&gt;LoggerService&lt;/code&gt; 의 인스턴스 를 만들고 &lt;code&gt;UserContextService&lt;/code&gt; 를 만들기 시작합니다 . &lt;code&gt;UserContextService&lt;/code&gt; 에는 또한 프레임 워크에 이미있는 &lt;code&gt;LoggerService&lt;/code&gt; 가 필요 하므로 프레임 워크가 동일한 인스턴스를 제공 할 수 있습니다. &lt;code&gt;UserContextService&lt;/code&gt; 에는 프레임 워크가 아직 작성하지 않은 &lt;code&gt;UserService&lt;/code&gt; 도 필요합니다 . &lt;code&gt;UserService&lt;/code&gt; 는 더 이상 종속성이 없으므로 프레임 워크는 단순히 &lt;code&gt;new&lt;/code&gt; 를 사용 하여 클래스를 인스턴스화하고 인스턴스를 &lt;code&gt;UserContextService&lt;/code&gt; 생성자에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c46546530ec2305526bbe60f113e24d64bb2ea5" translate="yes" xml:space="preserve">
          <source>When Angular creates &lt;code&gt;HeroesBaseComponent&lt;/code&gt;, it also creates a new instance of &lt;code&gt;HeroService&lt;/code&gt; that is visible only to that component and its children, if any.</source>
          <target state="translated">Angular는 &lt;code&gt;HeroesBaseComponent&lt;/code&gt; 를 만들 때 해당 구성 요소 및 해당 하위 항목 (있는 경우) 만 볼 수 있는 새로운 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d75141e96ff6cc6af5c2f22e153bb8b7726c8439" translate="yes" xml:space="preserve">
          <source>When Angular creates a &lt;code&gt;HeroesComponent&lt;/code&gt;, the &lt;a href=&quot;../guide/dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt; system sets the &lt;code&gt;heroService&lt;/code&gt; parameter to the singleton instance of &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">Angular가 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 만들 때 &lt;a href=&quot;../guide/dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt; 시스템은 &lt;code&gt;heroService&lt;/code&gt; 매개 변수를 HeroService 의 단일 인스턴스로 &lt;code&gt;HeroService&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="edfe45fd7cd5a3d35587c22b5138369ceba935e9" translate="yes" xml:space="preserve">
          <source>When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service. If Angular can't find that parameter information, it throws an error. Angular can only find the parameter information &lt;em&gt;if the class has a decorator of some kind&lt;/em&gt;. The &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator is the standard decorator for service classes.</source>
          <target state="translated">Angular는 생성자에 매개 변수가있는 클래스를 만들면 해당 매개 변수에 대한 형식 및 주입 메타 데이터를 찾아 올바른 서비스를 주입 할 수 있습니다. Angular가 해당 매개 변수 정보를 찾을 수 없으면 오류가 발생합니다. Angular는 &lt;em&gt;클래스에 데코레이터가있는 경우&lt;/em&gt; 에만 매개 변수 정보를 찾을 수 있습니다 . &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터 서비스 클래스에 대한 표준 장식입니다.</target>
        </trans-unit>
        <trans-unit id="b60a04b551961ac33eb89dab15ee5fc3d96de088" translate="yes" xml:space="preserve">
          <source>When Angular creates a lazy component for that module and injects &lt;code&gt;UserService&lt;/code&gt;, it finds a &lt;code&gt;UserService&lt;/code&gt; provider in the lazy module's &lt;em&gt;child injector&lt;/em&gt; and creates a &lt;em&gt;new&lt;/em&gt; instance of the &lt;code&gt;UserService&lt;/code&gt;. This is an entirely different &lt;code&gt;UserService&lt;/code&gt; instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</source>
          <target state="translated">각도가 모듈과를 분사에 대한 게으른 구성 요소를 만들 때 &lt;code&gt;UserService&lt;/code&gt; 를 , 그것은 발견 &lt;code&gt;UserService&lt;/code&gt; 의 게으른 모듈의에서 제공 &lt;em&gt;자식 인젝터를&lt;/em&gt; 하고 생성 &lt;em&gt;새&lt;/em&gt; 의 인스턴스를 &lt;code&gt;UserService&lt;/code&gt; 를 . 이것은 Angular가 열악하게로드 된 구성 요소 중 하나에 주입 한 앱 전체 싱글 톤 버전과 완전히 다른 &lt;code&gt;UserService&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="dc69520190e3c83c55a291c33fca092b47e14bd0" translate="yes" xml:space="preserve">
          <source>When Angular creates a new instance of a component class, it determines which services or other dependencies that component needs by looking at the constructor parameter types. For example, the constructor of &lt;code&gt;HeroListComponent&lt;/code&gt; needs &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">Angular는 구성 요소 클래스의 새 인스턴스를 만들 때 생성자 매개 변수 유형을보고 구성 요소에 필요한 서비스 또는 기타 종속성을 결정합니다. 예를 들어 &lt;code&gt;HeroListComponent&lt;/code&gt; 의 생성자는 HeroService 가 필요 &lt;code&gt;HeroService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daa80d0bedfc508acd3e345644f12519bac5df05" translate="yes" xml:space="preserve">
          <source>When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</source>
          <target state="translated">Angular는 컴포넌트가 서비스에 의존한다는 것을 발견하면 먼저 인젝터에 해당 서비스의 기존 인스턴스가 있는지 확인합니다. 요청 된 서비스 인스턴스가 아직 없으면 인젝터는 등록 된 제공자를 사용하여 인젝터를 작성하고 인젝터에 추가 한 후 서비스를 Angular로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15fbac2ad05bb1b878e9b6aaaddf5c2a92440c52" translate="yes" xml:space="preserve">
          <source>When Angular first introduced lazy routes, there wasn't browser support for dynamically loading additional JavaScript. Angular created our own scheme using the syntax &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;: './lazy/lazy.module#LazyModule'&lt;/code&gt; and built tooling to support it. Now that ECMAScript dynamic import is supported in many browsers, Angular is moving toward this new syntax.</source>
          <target state="translated">Angular가 처음 게으른 경로를 도입했을 때 추가 JavaScript를 동적으로로드하기위한 브라우저 지원은 없었습니다. Angular는 &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;: './lazy/lazy.module#LazyModule'&lt;/code&gt; 구문을 사용하여 자체 스키마를 작성하고 이를 지원하는 도구를 빌드했습니다. ECMAScript 동적 가져 오기가 많은 브라우저에서 지원되므로 Angular는이 새로운 구문으로 이동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532a909b137883ff1cc53d2b0c6b4c9086b273e" translate="yes" xml:space="preserve">
          <source>When Angular looks to inject a service for that token, it creates and delivers the instance created by the second provider.</source>
          <target state="translated">Angular는 해당 토큰에 대한 서비스를 주입하려고 할 때 두 번째 제공자가 작성한 인스턴스를 작성하고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0a3b387e0d7ce6256900c30fd7083a52d270aa24" translate="yes" xml:space="preserve">
          <source>When Angular sees this dev dependency, it provides the language service in the WebStorm environment. WebStorm then gives you colorization inside the template and autocomplete in addition to the Angular Language Service.</source>
          <target state="translated">Angular는이 dev 의존성을 볼 때 WebStorm 환경에서 언어 서비스를 제공합니다. 그런 다음 WebStorm은 Angular Language Service 외에도 템플릿 내에서 색상을 지정하고 자동 완성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33dad2f9fbf951339a3296d3326f729bb3e085c0" translate="yes" xml:space="preserve">
          <source>When AngularJS content gets projected inside an Angular component, it still remains in &quot;AngularJS land&quot; and is managed by the AngularJS framework.</source>
          <target state="translated">AngularJS 컨텐츠가 Angular 컴포넌트 내부에 투영 될 때 여전히 &quot;AngularJS 랜드&quot;로 유지되고 AngularJS 프레임 워크에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed767ca456340b0d66612ee5b397caf978c20ac" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test ends with pending &lt;em&gt;micro-tasks&lt;/em&gt; such as unresolved promises, the test fails with a clear error message.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 대기와 테스트 끝에 &lt;em&gt;마이크로 작업&lt;/em&gt; 등 해결되지 않은 약속 등이 테스트는 명확한 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="706c0acd77c834e1aad2b340fca6016f1fa6d670" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test ends with pending timer event &lt;em&gt;tasks&lt;/em&gt; (queued &lt;code&gt;setTimeOut&lt;/code&gt; and &lt;code&gt;setInterval&lt;/code&gt; callbacks), the test fails with a clear error message.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 대기 타이머 이벤트와 테스트 종료 &lt;em&gt;작업&lt;/em&gt; (대기 &lt;code&gt;setTimeOut&lt;/code&gt; 과 &lt;code&gt;setInterval&lt;/code&gt; 을 콜백), 시험은 분명한 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c0f510f249ea7d1ebc16b4ca9b7274ea4dccefc" translate="yes" xml:space="preserve">
          <source>When a child of this component asks for the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; service, Angular provides the local &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; service, not the version provided in the application root injector. Child components make proper HTTP requests no matter what other modules do to &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소의 자식이 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 서비스를 요청 하면 Angular는 응용 프로그램 루트 인젝터에 제공된 버전이 아닌 로컬 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 서비스를 제공합니다 . 자식 구성 요소는 다른 모듈이 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 에 관계없이 적절한 HTTP 요청을 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f50727eaded505f27a2039589063405b5098511" translate="yes" xml:space="preserve">
          <source>When a class requires a dependency, that dependency is added to the constructor as a parameter. When Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency. By default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector of the component, and if necessary bubbling up through the injector tree until it reaches the root injector.</source>
          <target state="translated">클래스에 종속성이 필요한 경우 해당 종속성이 생성자에 매개 변수로 추가됩니다. Angular는 클래스를 인스턴스화해야 할 때 종속성을 제공하기 위해 DI 프레임 워크를 호출합니다. 기본적으로 DI 프레임 워크는 구성 요소의 구성 요소 로컬 인젝터에서 시작하여 인젝터 계층 구조에서 공급자를 검색하고 필요한 경우 인젝터 트리를 통해 루트 인젝터에 도달 할 때까지 버블 링합니다.</target>
        </trans-unit>
        <trans-unit id="cdcac278185f690641e0973ca2f176befc8267b8" translate="yes" xml:space="preserve">
          <source>When a component declares a dependency, Angular tries to satisfy that dependency with its own &lt;code&gt;ElementInjector&lt;/code&gt;. If the component's injector lacks the provider, it passes the request up to its parent component's &lt;code&gt;ElementInjector&lt;/code&gt;.</source>
          <target state="translated">구성 요소가 종속성을 선언하면 Angular는 자체 &lt;code&gt;ElementInjector&lt;/code&gt; 로 해당 종속성을 충족 시키려고 시도합니다 . 컴포넌트 인젝터에 제공자가 없으면 요청을 상위 컴포넌트의 &lt;code&gt;ElementInjector&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="fa934dc7384f20c5899aeb7143c3e042d42bada1" translate="yes" xml:space="preserve">
          <source>When a component has dependencies, you may wish to use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; to both create the component and its dependencies.</source>
          <target state="translated">구성 요소에 종속성이있는 경우 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 사용하여 구성 요소와 해당 종속성을 모두 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c0d48aa6b194f35fb1a95277c8c0e3c66d70a2" translate="yes" xml:space="preserve">
          <source>When a component is instantiated, Angular creates a change detector, which is responsible for propagating the component's bindings. The strategy is one of:</source>
          <target state="translated">컴포넌트가 인스턴스화되면 Angular는 컴포넌트의 바인딩 전파를 담당하는 변경 감지기를 작성합니다. 전략은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cc7c94e41269c2b8dc0737122e64dd38c738de77" translate="yes" xml:space="preserve">
          <source>When a component or service declares a dependency, the class constructor takes that dependency as a parameter. You can tell Angular that the dependency is optional by annotating the constructor parameter with &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">컴포넌트 또는 서비스가 종속성을 선언하면 클래스 생성자는 해당 종속성을 매개 변수로 사용합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 생성자 매개 변수에 주석을 달아 의존성을 선택적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c92f91e13ec5352ca2d9208b3c8260e92af91884" translate="yes" xml:space="preserve">
          <source>When a module is loaded at application launch, its &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; have &lt;em&gt;application-wide scope&lt;/em&gt;; that is, they are available for injection throughout the application.</source>
          <target state="translated">응용 프로그램 시작시 모듈이로드되면 해당 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;응용 프로그램 전체 범위를&lt;/em&gt; 갖습니다 . 즉, 응용 프로그램 전체에서 사출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6422ede5f8ed58042863b6f652f29c592c282af7" translate="yes" xml:space="preserve">
          <source>When a sequence is used within a &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, execution continues to the next instruction only after each of the inner animation steps have completed.</source>
          <target state="translated">시퀀스가 &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출 내에서 사용되면 각 내부 애니메이션 단계가 완료된 후에 만 ​​다음 명령어로 실행이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c3cbb8c4d353fced8240d3f69c79bebf4d68b840" translate="yes" xml:space="preserve">
          <source>When a user clicks a &lt;em&gt;Dashboard&lt;/em&gt; hero, the &lt;code&gt;DashboardComponent&lt;/code&gt; tells the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; to navigate to &lt;code&gt;heroes/:id&lt;/code&gt;. The &lt;code&gt;:id&lt;/code&gt; is a route parameter whose value is the &lt;code&gt;id&lt;/code&gt; of the hero to edit.</source>
          <target state="translated">사용자가 클릭하면 &lt;em&gt;대시 보드&lt;/em&gt; 영웅의 &lt;code&gt;DashboardComponent&lt;/code&gt; 는 알려줍니다 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 로 이동 &lt;code&gt;heroes/:id&lt;/code&gt; . &lt;code&gt;:id&lt;/code&gt; 그 값이있는 경로 매개 변수 &lt;code&gt;id&lt;/code&gt; 편집 할 영웅.</target>
        </trans-unit>
        <trans-unit id="72ff44014ef60a516903197c78b674811bdbbea1" translate="yes" xml:space="preserve">
          <source>When a user clicks the button, the &lt;code&gt;profileForm&lt;/code&gt; model is updated with new values for &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;street&lt;/code&gt;. Notice that &lt;code&gt;street&lt;/code&gt; is provided in an object inside the &lt;code&gt;address&lt;/code&gt; property. This is necessary because the &lt;code&gt;patchValue()&lt;/code&gt; method applies the update against the model structure. &lt;code&gt;PatchValue()&lt;/code&gt; only updates properties that the form model defines.</source>
          <target state="translated">사용자가 버튼을 클릭하면 &lt;code&gt;profileForm&lt;/code&gt; 모델이 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;street&lt;/code&gt; 의 새 값으로 업데이트됩니다 . 통지 &lt;code&gt;street&lt;/code&gt; 내부 객체에 제공되는 &lt;code&gt;address&lt;/code&gt; 속성입니다. &lt;code&gt;patchValue()&lt;/code&gt; 메소드는 모델 구조에 대한 업데이트를 적용 하기 때문에 필요합니다 . &lt;code&gt;PatchValue()&lt;/code&gt; 는 양식 모델이 정의한 속성 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="5e7904f8fa1f1502df6bd3b94de8f69ab0c6c02d" translate="yes" xml:space="preserve">
          <source>When a user presses and releases a key, the &lt;code&gt;keyup&lt;/code&gt; event occurs, and Angular provides a corresponding DOM event object in the &lt;code&gt;$event&lt;/code&gt; variable which this code passes as a parameter to the component's &lt;code&gt;onKey()&lt;/code&gt; method.</source>
          <target state="translated">사용자가 키를 눌렀다가 &lt;code&gt;keyup&lt;/code&gt; 이벤트가 발생하고 Angular는 &lt;code&gt;$event&lt;/code&gt; 변수 에 해당 DOM 이벤트 객체를 제공합니다. 이 이벤트 는이 코드가 구성 요소의 &lt;code&gt;onKey()&lt;/code&gt; 메서드에 매개 변수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="d3234f0499ea9f65642e43dacff906896c520058" translate="yes" xml:space="preserve">
          <source>When a view uses the &lt;a href=&quot;changedetectionstrategy#OnPush&quot;&gt;OnPush&lt;/a&gt; (checkOnce) change detection strategy, explicitly marks the view as changed so that it can be checked again.</source>
          <target state="translated">뷰가 &lt;a href=&quot;changedetectionstrategy#OnPush&quot;&gt;OnPush&lt;/a&gt; (checkOnce) 변경 감지 전략을 사용하는 경우 다시 확인할 수 있도록 뷰를 변경된 것으로 명시 적으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f2a58965900b52ff44960aeb5d3b1ab8663f125a" translate="yes" xml:space="preserve">
          <source>When all dependencies are in place, &lt;code&gt;AppComponent&lt;/code&gt; displays the user information.</source>
          <target state="translated">모든 종속성이 있으면 &lt;code&gt;AppComponent&lt;/code&gt; 에 사용자 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd8f6d53233742cc77fab54767b182e5f57eee9a" translate="yes" xml:space="preserve">
          <source>When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments.</source>
          <target state="translated">요청 된 모든 서비스가 해결되고 반환되면 Angular는 해당 서비스를 인수로 사용하여 구성 요소의 생성자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42dedf76e9162b85f232959c900f4d227b64bc8" translate="yes" xml:space="preserve">
          <source>When all routes were in one &lt;code&gt;AppRoutingModule&lt;/code&gt;, you put the default and &lt;a href=&quot;router#wildcard&quot;&gt;wildcard&lt;/a&gt; routes last, after the &lt;code&gt;/heroes&lt;/code&gt; route, so that the router had a chance to match a URL to the &lt;code&gt;/heroes&lt;/code&gt; route &lt;em&gt;before&lt;/em&gt; hitting the wildcard route and navigating to &quot;Page not found&quot;.</source>
          <target state="translated">모든 경로가 하나의 &lt;code&gt;AppRoutingModule&lt;/code&gt; 에 있으면 &lt;code&gt;/heroes&lt;/code&gt; 경로 다음에 기본 및 &lt;a href=&quot;router#wildcard&quot;&gt;와일드 카드&lt;/a&gt; 경로를 마지막에 배치하여 라우터가 와일드 카드 경로에 도달하고 &quot;페이지가 아닌 페이지로 이동 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;/heroes&lt;/code&gt; 경로에 URL을 일치시킬 수 있습니다. 녹이다&quot;.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d84e128eb398288da3157378d60b0938fa2d8fd" translate="yes" xml:space="preserve">
          <source>When an AngularJS component directive supports transclusion, it may use the &lt;code&gt;ng-transclude&lt;/code&gt; directive in its template to mark the transclusion point:</source>
          <target state="translated">AngularJS 컴포넌트 지시어가 변환을 지원할 때 템플리트에서 &lt;code&gt;ng-transclude&lt;/code&gt; 지시어를 사용하여 변환점을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b810ca0a0152d462508ed51e0332b20030ce21c" translate="yes" xml:space="preserve">
          <source>When an application is laid out feature per feature in this way, it can also be migrated one feature at a time. For applications that don't already look like this, applying the rules in the AngularJS style guide is a highly recommended preparation step. And this is not just for the sake of the upgrade - it is just solid advice in general!</source>
          <target state="translated">이러한 방식으로 기능별로 기능이 배치 된 애플리케이션은 한 번에 하나의 기능으로 마이그레이션 할 수도 있습니다. 아직 이렇게 보이지 않는 응용 프로그램의 경우 AngularJS 스타일 가이드의 규칙을 적용하는 것이 좋습니다. 그리고 이것은 단지 업그레이드를위한 것이 아니라 일반적으로 확실한 조언입니다!</target>
        </trans-unit>
        <trans-unit id="47d77d1d4a7d81017ab7a88f89771a6bc5639dd4" translate="yes" xml:space="preserve">
          <source>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules &lt;em&gt;before&lt;/em&gt; creating its first component and injecting any of the provided services. Once the application begins, the app root injector is closed to new providers.</source>
          <target state="translated">응용 프로그램이 시작되면 Angular는 먼저 첫 번째 구성 요소 &lt;em&gt;를&lt;/em&gt; 만들고 제공된 서비스를 주입 &lt;em&gt;하기 전에&lt;/em&gt; 열심히로드 된 모든 NgModules의 공급자로 루트 인젝터를 구성합니다. 응용 프로그램이 시작되면 응용 프로그램 루트 인젝터가 새로운 공급자에게 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="de05fecb69b29988cfd38b015be38ee5c1e10d06" translate="yes" xml:space="preserve">
          <source>When an area of the template is set to have animations disabled, &lt;strong&gt;all&lt;/strong&gt; inner components have their animations disabled as well. This means that you can disable all animations for an app by placing a host binding set on &lt;code&gt;@.disabled&lt;/code&gt; on the topmost Angular component.</source>
          <target state="translated">템플릿 영역에서 애니메이션을 비활성화하도록 설정하면 &lt;strong&gt;모든&lt;/strong&gt; 내부 구성 요소에서도 애니메이션이 비활성화됩니다. 즉 , 최상위 Angular 구성 요소의 &lt;code&gt;@.disabled&lt;/code&gt; 에 호스트 바인딩 세트를 배치하여 앱의 모든 애니메이션을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2158e7ac2d535c8a0d73be64130946207704b5dd" translate="yes" xml:space="preserve">
          <source>When an eagerly loaded module provides a service, for example a &lt;code&gt;UserService&lt;/code&gt;, that service is available application-wide. If the root module provides &lt;code&gt;UserService&lt;/code&gt; and imports another module that provides the same &lt;code&gt;UserService&lt;/code&gt;, Angular registers one of them in the root app injector (see &lt;a href=&quot;ngmodule-faq#q-reimport&quot;&gt;What if I import the same module twice?&lt;/a&gt;).</source>
          <target state="translated">열성적으로로드 된 모듈이 서비스 (예 : &lt;code&gt;UserService&lt;/code&gt; )를 제공하면 해당 서비스를 응용 프로그램 전체에서 사용할 수 있습니다. 루트 모듈이 &lt;code&gt;UserService&lt;/code&gt; 를 제공하고 동일한 &lt;code&gt;UserService&lt;/code&gt; 를 제공하는 다른 모듈을 가져 오는 경우 Angular는 루트 앱 인젝터에 그 중 하나를 등록 &lt;a href=&quot;ngmodule-faq#q-reimport&quot;&gt;합니다 (동일한 모듈을 두 번 가져 오면 어떻게합니까? 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05aae7978db62e7e7c9429220e2ca190a4d0d35e" translate="yes" xml:space="preserve">
          <source>When an element is repeated within &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, the context is an &lt;code&gt;NgForRow&lt;/code&gt; whose &lt;code&gt;$implicit&lt;/code&gt; property is the value of the row instance value. For example, the &lt;code&gt;hero&lt;/code&gt; in &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let hero of heroes&quot;&lt;/code&gt;.</source>
          <target state="translated">요소가 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 내에서 반복 되면 컨텍스트는 &lt;code&gt;$implicit&lt;/code&gt; 특성이 행 인스턴스 값의 값인 &lt;code&gt;NgForRow&lt;/code&gt; 입니다 . 예를 들어, &lt;code&gt;hero&lt;/code&gt; 의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let hero of heroes&quot;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor은&lt;/a&gt; &quot;영웅의 영웅을하자&quot;= .</target>
        </trans-unit>
        <trans-unit id="2c546d06df1559440a1db83b4e5c1db73f342fce" translate="yes" xml:space="preserve">
          <source>When an element within an HTML template has animations disabled using the &lt;code&gt;@.disabled&lt;/code&gt; host binding, animations are disabled on all inner elements as well. You can't selectively disable multiple animations on a single element.</source>
          <target state="translated">HTML 템플릿 내의 요소에 &lt;code&gt;@.disabled&lt;/code&gt; 호스트 바인딩을 사용하여 애니메이션을 비활성화하면 모든 내부 요소에서도 애니메이션이 비활성화됩니다. 단일 요소에서 여러 애니메이션을 선택적으로 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d91d5acbcb6e8adb1db7278d2b85940b8c059799" translate="yes" xml:space="preserve">
          <source>When an item is added, a new instance of the template is added to the DOM.</source>
          <target state="translated">항목이 추가되면 템플릿의 새 인스턴스가 DOM에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6812fd0a944e938e939802bbf208e98821182752" translate="yes" xml:space="preserve">
          <source>When an item is removed, its template instance is removed from the DOM.</source>
          <target state="translated">항목이 제거되면 해당 템플리트 인스턴스가 DOM에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5a9a8569048e0b049afa4c46c8590c8fbf5d8867" translate="yes" xml:space="preserve">
          <source>When an output property emits an event, an event handler attached to that event in the template is invoked.</source>
          <target state="translated">출력 특성이 이벤트를 생성하면 템플리트에서 해당 이벤트에 첨부 된 이벤트 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a21063df73c511a2f56f2ef1bf9a8ff345822c" translate="yes" xml:space="preserve">
          <source>When animations are disabled, &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; styles can be skipped, but &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; styles can't.</source>
          <target state="translated">애니메이션이 비활성화되면 &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 스타일은 건너 뛸 수 있지만 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 스타일은 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="29c152c927172bc42277bd311cf9c51039c351e7" translate="yes" xml:space="preserve">
          <source>When autodetect is &lt;code&gt;true&lt;/code&gt;, the test fixture calls &lt;code&gt;detectChanges&lt;/code&gt; immediately after creating the component. Then it listens for pertinent zone events and calls &lt;code&gt;detectChanges&lt;/code&gt; accordingly. When your test code modifies component property values directly, you probably still have to call &lt;code&gt;fixture.detectChanges&lt;/code&gt; to trigger data binding updates.</source>
          <target state="translated">autodetect가 &lt;code&gt;true&lt;/code&gt; 인 경우 테스트 픽스처 는 구성 요소를 &lt;code&gt;detectChanges&lt;/code&gt; 후 즉시 detectChanges를 호출 합니다. 그런 다음 관련 영역 이벤트를 수신하고 &lt;code&gt;detectChanges&lt;/code&gt; 따라 detectChanges를 호출합니다 . 테스트 코드가 구성 요소 속성 값을 직접 수정 하는 경우 데이터 바인딩 업데이트를 트리거하기 위해 &lt;code&gt;fixture.detectChanges&lt;/code&gt; 를 호출해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2068eaf5a2c701ccbfce60b3646bbea4685601e" translate="yes" xml:space="preserve">
          <source>When binding to ARIA attributes in Angular, you must use the &lt;code&gt;attr.&lt;/code&gt; prefix, as the ARIA specification depends specifically on HTML attributes rather than properties on DOM elements.</source>
          <target state="translated">Angular에서 ARIA 속성에 바인딩 할 때는 &lt;code&gt;attr.&lt;/code&gt; 사용해야합니다 . ARIA 사양은 DOM 요소의 속성이 아닌 HTML 속성에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="1d403c7f0a15567441991f43194df4dfc6f894d3" translate="yes" xml:space="preserve">
          <source>When bootstrapping a new root component into an application, Angular mounts the specified application component onto DOM elements identified by the componentType's selector and kicks off automatic change detection to finish initializing the component.</source>
          <target state="translated">새 루트 구성 요소를 응용 프로그램에 부트 스트랩 할 때 Angular는 지정된 응용 프로그램 구성 요소를 componentType의 선택기로 식별 된 DOM 요소에 마운트하고 자동 변경 감지를 시작하여 구성 요소 초기화를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="2b86c2426923dc82f318377489363981eae2a0e1" translate="yes" xml:space="preserve">
          <source>When building Angular applications you can take advantage of sophisticated first-party libraries, such as &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt;, as well as rich ecosystem of third-party libraries. See the &lt;a href=&quot;https://angular.io/resources&quot;&gt;Angular Resources&lt;/a&gt; page for links to the most popular ones.</source>
          <target state="translated">Angular 애플리케이션을 빌드 할 때 &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt; 과 같은 정교한 자사 라이브러리 및 타사 라이브러리의 풍부한 에코 시스템을 활용할 수 있습니다 . 가장 인기있는 것들에 대한 링크 는 &lt;a href=&quot;https://angular.io/resources&quot;&gt;Angular Resources&lt;/a&gt; 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89bb95bbe2563b71f388aa0a0055510166a2c680" translate="yes" xml:space="preserve">
          <source>When building applications, you want to ensure that only the required resources are loaded when necessary. Whether that be loading of assets or code, making sure everything that can be deferred until needed keeps your application running efficiently. This is especially true when running different frameworks in the same application.</source>
          <target state="translated">응용 프로그램을 빌드 할 때 필요한 경우 필요한 자원 만로드되도록하려고합니다. 자산로드 또는 코드로드 여부에 관계없이 필요할 때까지 지연 될 수있는 모든 항목으로 인해 애플리케이션이 효율적으로 실행됩니다. 동일한 응용 프로그램에서 다른 프레임 워크를 실행할 때 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="9386092cd495cfdab016752500f432eb023edc15" translate="yes" xml:space="preserve">
          <source>When building complex forms, managing the different areas of information is easier in smaller sections, and some groups of information naturally fall into the same group. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.</source>
          <target state="translated">복잡한 양식을 작성할 때 여러 섹션의 정보를보다 쉽게 ​​관리 할 수 ​​있으며 일부 정보 그룹은 자연스럽게 동일한 그룹에 속합니다. 중첩 된 양식 그룹 인스턴스를 사용하면 큰 양식 그룹을보다 작고 관리하기 쉬운 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc20bd4d6affd513b7a83567c797dc2341e8f77" translate="yes" xml:space="preserve">
          <source>When building forms in Angular, it's important to understand how the framework handles data flowing from the user or from programmatic changes. Reactive and template-driven forms follow two different strategies when handling form input. The data flow examples below begin with the favorite color input field example from above, and then show how changes to favorite color are handled in reactive forms compared to template-driven forms.</source>
          <target state="translated">Angular에서 양식을 작성할 때 프레임 워크가 사용자 또는 프로그래밍 방식 변경에서 흐르는 데이터를 처리하는 방법을 이해하는 것이 중요합니다. 반응 형 및 템플릿 기반 양식은 양식 입력을 처리 할 때 두 가지 전략을 따릅니다. 아래의 데이터 흐름 예제는 위에서 선호하는 색상 입력 필드 예제로 시작한 다음 템플릿 기반 양식과 비교하여 선호하는 색상의 변경이 반응 형으로 처리되는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6fc9bc402f56e1c96af7199e1d509f4661b9855c" translate="yes" xml:space="preserve">
          <source>When building web applications, making sure your application is compatible with the majority of browsers is a goal. Even as JavaScript continues to evolve, with new features being introduced, not all browsers are updated with support for these new features at the same pace.</source>
          <target state="translated">웹 애플리케이션을 빌드 할 때 애플리케이션이 대부분의 브라우저와 호환되는지 확인하는 것이 목표입니다. 새로운 기능이 도입되면서 JavaScript가 계속 발전하더라도 모든 브라우저가 이러한 새로운 기능을 동일한 속도로 지원하도록 업데이트되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f8b8eff21bbd0f8e5d36d2990adb2865268b95d6" translate="yes" xml:space="preserve">
          <source>When building with the CLI, be sure to include the linked style file among the assets to be copied to the server as described in the &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-asset-configuration&quot;&gt;CLI wiki&lt;/a&gt;.</source>
          <target state="translated">CLI로 빌드 할 때 &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-asset-configuration&quot;&gt;CLI 위키에&lt;/a&gt; 설명 된대로 서버에 복사 할 자산간에 링크 된 스타일 파일을 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="bab6d7c828b83308f18a53ca8a90ddce5abb3f87" translate="yes" xml:space="preserve">
          <source>When building with the CLI, you must configure the &lt;code&gt;angular.json&lt;/code&gt; to include &lt;em&gt;all external assets&lt;/em&gt;, including external style files.</source>
          <target state="translated">CLI를 사용하여 빌드 할 때 외부 스타일 파일을 포함하여 &lt;em&gt;모든 외부 자산&lt;/em&gt; 을 포함 하도록 &lt;code&gt;angular.json&lt;/code&gt; 을 구성해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bf2af4af56d10c85356870b1e312679a109012f" translate="yes" xml:space="preserve">
          <source>When called with unknown elements, such as a custom element name (&lt;code&gt;popup-element&lt;/code&gt; in our example), the methods will return a generic type, such as &lt;code&gt;HTMLElement&lt;/code&gt;, since TypeScript can't infer the correct type of the returned element.</source>
          <target state="translated">사용자 정의 요소 이름 ( 예 : &lt;code&gt;popup-element&lt;/code&gt; 요소)과 같은 알 수없는 요소로 호출되면 TypeScript는 반환 된 요소의 올바른 유형을 유추 할 수 없으므로 &lt;code&gt;HTMLElement&lt;/code&gt; 와 같은 일반 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63d51b615b5761b9b503679d40bc888ba4267a20" translate="yes" xml:space="preserve">
          <source>When called within a &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, does not continue to the next instruction until all of the inner animation steps have completed.</source>
          <target state="translated">내에서 호출 할 때 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출 내부 애니메이션의 모든 단계가 완료 될 때까지, 다음 명령어로 계속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc86cf8f39cfd1795f74b2f88d47a1dafd6a033a" translate="yes" xml:space="preserve">
          <source>When compiling a template, you need to determine a set of selectors which should be used for triggering their corresponding directives.</source>
          <target state="translated">템플릿을 컴파일 할 때 해당 지시문을 트리거하는 데 사용해야하는 선택기 집합을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="eff0e89b5209a2cd9fe83f63b8126db2c132d8ea" translate="yes" xml:space="preserve">
          <source>When creating an &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt;, you can optionally specify a factory function which returns (possibly by creating) a default value of the parameterized type &lt;code&gt;T&lt;/code&gt;. This sets up the &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; using this factory as a provider as if it was defined explicitly in the application's root injector. If the factory function, which takes zero arguments, needs to inject dependencies, it can do so using the &lt;code&gt;inject&lt;/code&gt; function. See below for an example.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 생성 할 때 매개 변수화 된 유형 &lt;code&gt;T&lt;/code&gt; 의 기본값을 작성하여 (가능한 경우) 팩토리 함수를 선택적으로 지정할 수 있습니다 . 이것은 어플리케이션의 루트 인젝터에 명시 적으로 정의 된 것처럼이 팩토리를 제공자로 사용 하여 &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 설정합니다 . 인수가 0 인 팩토리 함수가 종속성을 주입해야하는 경우, &lt;code&gt;inject&lt;/code&gt; 기능을 사용하여 수행 할 수 있습니다 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a06654762cbf15c6a7d824d62d5f3ff30f8cd430" translate="yes" xml:space="preserve">
          <source>When creating an observable you should determine how you want that observable to be used and whether or not you want to multicast its values.</source>
          <target state="translated">Observable을 생성 할 때 Observable의 사용 방법과 값을 멀티 캐스트할지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="749c6b45f20c32758d29b06fe77e09e8859f0280" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of a &lt;a href=&quot;template-syntax#property-binding&quot;&gt;property binding&lt;/a&gt;. Data values flow into an input property from the data source identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 경우 &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; 은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 도파 특성에 장식은 그 속성으로서 사용할 수 있도록 &lt;em&gt;타겟&lt;/em&gt; (A)의 &lt;a href=&quot;template-syntax#property-binding&quot;&gt;결합 속성&lt;/a&gt; . 데이터 값은 &lt;a href=&quot;glossary#template-expression&quot;&gt;등식&lt;/a&gt; 의 오른쪽 에있는 템플릿 표현식 에서 식별 된 데이터 소스에서 입력 특성으로 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="4307d2cc44bc7a97d4a4418574bb1547f7624e08" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of &lt;a href=&quot;template-syntax#event-binding&quot;&gt;event binding&lt;/a&gt;. Events stream &lt;em&gt;out&lt;/em&gt; of this property to the receiver identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 때 &lt;a href=&quot;glossary#directive&quot;&gt;지시문을&lt;/a&gt; 의 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; 지시어 재산에 장식은으로 그 속성을 사용할 수 있도록 &lt;em&gt;대상&lt;/em&gt; 의 &lt;a href=&quot;template-syntax#event-binding&quot;&gt;이벤트 바인딩&lt;/a&gt; . 이 속성에서 이벤트 는 등호 오른쪽의 &lt;a href=&quot;glossary#template-expression&quot;&gt;템플릿 표현식&lt;/a&gt; 에서 식별 된 수신자에게 스트리밍 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cef3cb91c2c647878c9cddaa3fa8393736c0a9d" translate="yes" xml:space="preserve">
          <source>When do I add components to &lt;code&gt;entryComponents&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;entryComponents&lt;/code&gt; 에 구성 요소를 언제 추가 합니까?</target>
        </trans-unit>
        <trans-unit id="e4be4307e52967d21c990d182cfe4e0ac164bd6d" translate="yes" xml:space="preserve">
          <source>When enabled, the &lt;code&gt;.js&lt;/code&gt; output of &lt;code&gt;ngc&lt;/code&gt; does not include any lazy-loaded template or style URLs.</source>
          <target state="translated">활성화하면 &lt;code&gt;ngc&lt;/code&gt; 의 &lt;code&gt;.js&lt;/code&gt; 출력에 지연로드 된 템플릿 또는 스타일 URL이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78cfd68dc9b0bf523c79b28df0b08d4cf40e6063" translate="yes" xml:space="preserve">
          <source>When false (the default), removes blank text nodes from compiled templates, which results in smaller emitted template factory modules. Set to true to preserve blank text nodes.</source>
          <target state="translated">false 인 경우 (기본값) 컴파일 된 템플릿에서 빈 텍스트 노드를 제거하여 더 작은 방출 템플릿 팩토리 모듈을 생성합니다. 빈 텍스트 노드를 유지하려면 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a48aec62988f1ccca24b1925a6fcfd92ea3a485f" translate="yes" xml:space="preserve">
          <source>When false, disables interactive input prompts.</source>
          <target state="translated">false 인 경우 대화식 입력 프롬프트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="187407e31db6569d8a862bbe786d50251332d665" translate="yes" xml:space="preserve">
          <source>When false, factory files are generated only for &lt;code&gt;.ts&lt;/code&gt; files. Do this when using factory summaries.</source>
          <target state="translated">false 인 경우 팩토리 파일은 &lt;code&gt;.ts&lt;/code&gt; 파일에 대해서만 생성됩니다 . 팩토리 요약을 사용할 때이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ef603dd1a4473adca892b6e5005cb3af75201392" translate="yes" xml:space="preserve">
          <source>When generating a component file with &lt;code&gt;ng generate component&lt;/code&gt;, the CLI emits an empty CSS styles file (&lt;code&gt;.css&lt;/code&gt;) by default. You can configure the CLI to default to your preferred CSS preprocessor as explained in the &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-css-preprocessors&quot;&gt;CLI wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ng generate component&lt;/code&gt; 로 구성 요소 파일을 생성 할 때 CLI 는 기본적으로 빈 CSS 스타일 파일 ( &lt;code&gt;.css&lt;/code&gt; )을 생성합니다. &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-css-preprocessors&quot;&gt;CLI 위키에&lt;/a&gt; 설명 된대로 기본 CSS 프리 프로세서를 기본값으로 CLI를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e66e299f045744162ddfe45522dbce7add492b38" translate="yes" xml:space="preserve">
          <source>When given a tuple with x and y position value, the router uses that offset each time it scrolls. When given a function, the router invokes the function every time it restores scroll position.</source>
          <target state="translated">x 및 y 위치 값이있는 튜플이 제공되면 라우터는 스크롤 할 때마다 해당 오프셋을 사용합니다. 함수가 주어지면 라우터는 스크롤 위치를 복원 할 때마다 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7ef92686417b75b5cbea84d910778edba78cd2a4" translate="yes" xml:space="preserve">
          <source>When given an activated route, applies the given commands starting from the route. Otherwise, applies the given command starting from the root.</source>
          <target state="translated">활성화 된 경로가 지정되면 경로에서 시작하여 지정된 명령을 적용합니다. 그렇지 않으면 루트에서 시작하여 지정된 명령을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="53849b6fde8d2206f676efc5f57c1bff53663e80" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;registerOnTouched&lt;/code&gt; in your own value accessor, save the given function so your class calls it when the control should be considered blurred or &quot;touched&quot;.</source>
          <target state="translated">자신의 값 접근 자에서 &lt;code&gt;registerOnTouched&lt;/code&gt; 를 구현할 때 컨트롤이 흐리게 표시되거나 &quot;터치&quot;된 것으로 간주 될 때 클래스가 호출하도록 지정된 함수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="6659f36f8906d9b6df663ed12a7ea8edf531eaf8" translate="yes" xml:space="preserve">
          <source>When implementing the &lt;code&gt;registerOnChange&lt;/code&gt; method in your own value accessor, save the given function so your class calls it at the appropriate time.</source>
          <target state="translated">고유 한 값 접근 자에서 &lt;code&gt;registerOnChange&lt;/code&gt; 메소드를 구현할 때 클래스가 적절한 시간에 호출하도록 지정된 함수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="e24b1f3a3c5786e4d0e0b368b389c36801747d1a" translate="yes" xml:space="preserve">
          <source>When injected, &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; dispatches requests directly to the backend, without going through the interceptor chain.</source>
          <target state="translated">삽입되면 &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 는 인터셉터 체인을 거치지 않고 직접 백엔드로 요청을 발송합니다.</target>
        </trans-unit>
        <trans-unit id="580455f83a9bed03f0a9761dbfac0d9fa7233a45" translate="yes" xml:space="preserve">
          <source>When instantiating a &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, pass in a collection of child controls as the first argument. The key for each child registers the name for the control.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 인스턴스화 할 때 하위 컨트롤 컬렉션을 첫 번째 인수로 전달하십시오. 각 자식의 키는 컨트롤의 이름을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="1dd82c5d8059bec900275dede8a10d9747aa6216" translate="yes" xml:space="preserve">
          <source>When it appears in &lt;strong&gt;square brackets&lt;/strong&gt; ([ ]) to the &lt;strong&gt;left&lt;/strong&gt; of the equals (=), the property belongs to some &lt;em&gt;other&lt;/em&gt; component or directive; that property must be adorned with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">이 나타나면 &lt;strong&gt;각괄호&lt;/strong&gt; ([])가로 &lt;strong&gt;왼쪽&lt;/strong&gt; 등호 (=)의 일부 속성에 속하는 &lt;em&gt;다른&lt;/em&gt; 성분 또는 지시자; 이 속성은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 데코레이터 로 장식해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9f1c7ae270dcf8ed2fb36e356720b2282a2234b" translate="yes" xml:space="preserve">
          <source>When it appears in the template expression to the &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; of the equals (=), it belongs to the template's component and does not require the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">등호 (=) 의 &lt;strong&gt;&lt;em&gt;오른쪽&lt;/em&gt;&lt;/strong&gt; 에있는 템플리트 표현식에 표시되면 템플리트의 구성 요소에 속하며 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 데코레이터가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="726cccf06c149c75e2bcbaec1213fc068eb64d58" translate="yes" xml:space="preserve">
          <source>When it returns true, the router will execute the regular navigation. When it returns false, the router will set the router state to an empty state. As a result, all the active components will be destroyed.</source>
          <target state="translated">true를 반환하면 라우터는 일반 탐색을 실행합니다. false를 반환하면 라우터는 라우터 상태를 빈 상태로 설정합니다. 결과적으로 모든 활성 구성 요소가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="65bc0e8f54c69a39293ba4c95d5c5b7ea95eb9e8" translate="yes" xml:space="preserve">
          <source>When items are added, moved, or removed in the iterable, the directive must re-render the appropriate DOM nodes. To minimize churn in the DOM, only nodes that have changed are re-rendered.</source>
          <target state="translated">iterable에서 항목을 추가, 이동 또는 제거 할 때 지시문은 적절한 DOM 노드를 다시 렌더링해야합니다. DOM에서 이탈을 최소화하기 위해 변경된 노드 만 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="3383a24d31d85f720ecee22674153dda0032675f" translate="yes" xml:space="preserve">
          <source>When items are reordered, their respective templates are reordered in the DOM.</source>
          <target state="translated">항목이 재정렬되면 해당 템플리트가 DOM에서 재정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="4e46635cb6851d2c8daac2e8a56141906f6c0a57" translate="yes" xml:space="preserve">
          <source>When migrating large applications from AngularJS to Angular using a hybrid approach, you want to migrate some of the most commonly used features first, and only use the less commonly used features if needed. Doing so helps you ensure that the application is still providing a seamless experience for your users while you are migrating.</source>
          <target state="translated">하이브리드 방식을 사용하여 대규모 애플리케이션을 AngularJS에서 Angular로 마이그레이션 할 때 가장 일반적으로 사용되는 기능 중 일부를 먼저 마이그레이션하고 필요한 경우 덜 일반적으로 사용되는 기능 만 사용하려고합니다. 이렇게하면 마이그레이션하는 동안 응용 프로그램이 사용자에게 완벽한 환경을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f693ef9f80d346bdc6a2cb671a6ac073cf6c8c15" translate="yes" xml:space="preserve">
          <source>When moving applications into production, module loaders also make it easier to package them all up into production bundles with batteries included.</source>
          <target state="translated">응용 프로그램을 생산 환경으로 옮길 때 모듈 로더를 사용하면 배터리가 포함 된 생산 번들로 모두 포장하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="974ce48422781e5e8f141c93cec08580c47ded29" translate="yes" xml:space="preserve">
          <source>When navigating to '/team/11/legacy/user/jim', the router changes the URL segment '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates the Team component with the User child component in it.</source>
          <target state="translated">'/ team / 11 / legacy / user / jim'으로 이동하면 라우터는 URL 세그먼트 '/ team / 11 / legacy / user / jim'을 '/ team / 11 / user / jim'으로 변경 한 다음 사용자 하위 구성 요소가 포함 된 팀 구성 요소.</target>
        </trans-unit>
        <trans-unit id="4dabd38c86ae8f6fd64bd5a719e2864ff58a5263" translate="yes" xml:space="preserve">
          <source>When navigating to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; you specified the &lt;em&gt;required&lt;/em&gt;&lt;code&gt;id&lt;/code&gt; of the hero-to-edit in the &lt;em&gt;route parameter&lt;/em&gt; and made it the second item of the &lt;a href=&quot;router#link-parameters-array&quot;&gt;&lt;em&gt;link parameters array&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 탐색 할 때 &lt;em&gt;route 매개 변수에&lt;/em&gt; 편집 할 hero-edit 의 &lt;em&gt;필수 &lt;/em&gt; &lt;code&gt;id&lt;/code&gt; 를 지정 하고 &lt;a href=&quot;router#link-parameters-array&quot;&gt;&lt;em&gt;링크 매개 변수 array&lt;/em&gt;&lt;/a&gt; 의 두 번째 항목으로 지정하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b596202b93519fa83ba3e0636fbd745a12579c58" translate="yes" xml:space="preserve">
          <source>When navigating within the page, you can omit the page URL when specifying the link that &lt;a href=&quot;docs-style-guide#anchors&quot;&gt;scrolls up&lt;/a&gt; to the beginning of this section.</source>
          <target state="translated">페이지 내에서 탐색 할 때이 섹션의 시작 부분으로 &lt;a href=&quot;docs-style-guide#anchors&quot;&gt;스크롤&lt;/a&gt; 되는 링크를 지정할 때 페이지 URL을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47e71f5eac56adacb97cdaa135062c7be281d29c" translate="yes" xml:space="preserve">
          <source>When operating on a blank value, the pipe returns the blank value.</source>
          <target state="translated">공백 값으로 작업 할 때 파이프는 공백 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9470fc75d4f16eb75457c7c0701e316180391ae8" translate="yes" xml:space="preserve">
          <source>When operating on an &lt;code&gt;Array&lt;/code&gt;, the returned &lt;code&gt;Array&lt;/code&gt; is always a copy even when all the elements are being returned.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 에서 작업 할 때 반환 된 &lt;code&gt;Array&lt;/code&gt; 는 모든 요소가 반환되는 경우에도 항상 사본입니다.</target>
        </trans-unit>
        <trans-unit id="af8a1731fb61ac75119cbee0bc7096781d75858e" translate="yes" xml:space="preserve">
          <source>When possible, every snippet of code on a guide page should be derived from a code sample file. You tell the Angular documentation engine which code file - or fragment of a code file - to display by configuring &lt;code&gt;&amp;lt;code-example&amp;gt;&lt;/code&gt; attributes.</source>
          <target state="translated">가능하면 가이드 페이지의 모든 코드 스 니펫은 코드 샘플 파일에서 파생되어야합니다. &lt;code&gt;&amp;lt;code-example&amp;gt;&lt;/code&gt; 속성 을 구성하여 표시 할 코드 파일 또는 코드 파일의 조각 인 Angular 문서 엔진에 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b1e14412852555d0dead8387cd5e4230c5c2210" translate="yes" xml:space="preserve">
          <source>When reasoning about how a hybrid application works it is useful to have a mental model which describes what is happening and explains what is happening at the lowest level.</source>
          <target state="translated">하이브리드 응용 프로그램의 작동 방식을 추론 할 때 발생하는 일을 설명하고 가장 낮은 수준에서 발생하는 일을 설명하는 정신 모델을 갖는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="910d857793129df45ce010da90a7c320c1e97758" translate="yes" xml:space="preserve">
          <source>When registered at the root, the module should be used as follows</source>
          <target state="translated">루트에 등록 할 때 다음과 같이 모듈을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="3a43104f732ee923f94742e9dafb4569962350fe" translate="yes" xml:space="preserve">
          <source>When resolving a token for a component/directive, Angular resolves it in two phases:</source>
          <target state="translated">컴포넌트 / 지시문에 대한 토큰을 분석 할 때 Angular는 다음 두 단계로 토큰을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="c2ae9e9637b2b33a1688e28b8fbf98ba2ef54d5d" translate="yes" xml:space="preserve">
          <source>When running a hybrid app, you may encounter situations where you need to inject some AngularJS dependencies into your Angular code. Maybe you have some business logic still in AngularJS services. Maybe you want access to AngularJS's built-in services like &lt;code&gt;$location&lt;/code&gt; or &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="translated">하이브리드 앱을 실행할 때 일부 AngularJS 종속성을 Angular 코드에 주입해야하는 상황이 발생할 수 있습니다. 어쩌면 AngularJS 서비스에 여전히 몇 가지 비즈니스 논리가 있습니다. 아마도 &lt;code&gt;$location&lt;/code&gt; 또는 &lt;code&gt;$timeout&lt;/code&gt; 과 같은 AngularJS의 내장 서비스에 액세스하고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bed0140c9176f2a5f051b579d76e69efbabf955" translate="yes" xml:space="preserve">
          <source>When running in a web browser, &lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;&lt;code&gt;BrowserModule&lt;/code&gt;&lt;/a&gt; is imported from the &lt;code&gt;platform-browser&lt;/code&gt; package, and supports services that simplify security and event processing, and allows applications to access browser-specific features, such as interpreting keyboard input and controlling the title of the document being displayed. All applications running in the browser use the same platform service.</source>
          <target state="translated">웹 브라우저에서 실행될 때 &lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt; &lt;code&gt;BrowserModule&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;platform-browser&lt;/code&gt; 패키지에서 가져오고 보안 및 이벤트 처리를 단순화하는 서비스를 지원하며 애플리케이션이 키보드 입력 해석 및 문서 제목 제어와 같은 브라우저 특정 기능에 액세스 할 수 있도록합니다. 표시됩니다. 브라우저에서 실행되는 모든 응용 프로그램은 동일한 플랫폼 서비스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3b9496755bdbefbc04d83cf169903cd6a85e935" translate="yes" xml:space="preserve">
          <source>When running this test in your repo, you need the &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt;&lt;code&gt;ts-node&lt;/code&gt;&lt;/a&gt; package. You can avoid this by renaming &lt;code&gt;index.spec.ts&lt;/code&gt; to &lt;code&gt;index.spec.js&lt;/code&gt;.</source>
          <target state="translated">리포지토리에서이 테스트를 실행할 때는 &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt; &lt;code&gt;ts-node&lt;/code&gt; &lt;/a&gt; 패키지 가 필요합니다 . 당신은 이름을 변경하여이 문제를 피할 수 &lt;code&gt;index.spec.ts&lt;/code&gt; 을 에 &lt;code&gt;index.spec.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca1e00f7ccb695467c2c1c8bdcb6dc3a59945ddf" translate="yes" xml:space="preserve">
          <source>When set to 'enabled', scrolls to the anchor element when the URL has a fragment. Anchor scrolling is disabled by default.</source>
          <target state="translated">'enabled'로 설정하면 URL에 조각이있을 때 앵커 요소로 스크롤됩니다. 앵커 스크롤은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="df46a80b7b23d043f67f6a3e6c0f76498ecbceda" translate="yes" xml:space="preserve">
          <source>When steps are defined by &lt;code&gt;&lt;a href=&quot;style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function calls, each call within the group is executed instantly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 함수 호출로 단계를 정의 하면 그룹 내의 각 호출이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec7e8de6c9a711c3fd504943c4759732a87b530d" translate="yes" xml:space="preserve">
          <source>When subscribing to an observable in a component, you almost always arrange to unsubscribe when the component is destroyed.</source>
          <target state="translated">컴포넌트에서 옵저버 블을 구독 할 때는 컴포넌트가 소멸 될 때 거의 항상 구독을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="c84a9e640ad95d9f4b83e468d1eed71718bb7381" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for a completion notification from this emitter.</source>
          <target state="translated">제공된 경우이 이미 터로부터 완료 알림을위한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="4df8413e1037a7ffe9bd25f1c95460fff8733865" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for an error notification from this emitter.</source>
          <target state="translated">제공된 경우이 이미 터의 오류 알림에 대한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="00c39ac45b462ecb37bcc3a021a4360c58c40852" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for emitted events.</source>
          <target state="translated">제공된 경우 생성 된 이벤트에 대한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="9e9d2f5c611c356028dee0d50c203b929a7a14e8" translate="yes" xml:space="preserve">
          <source>When switching between the two routes, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt; will ease in from the left when routed to and will slide to the right when navigating away.</source>
          <target state="translated">두 경로 사이를 전환 할 때 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 &lt;code&gt;HeroListComponent&lt;/code&gt; 는 경로가 지정 될 때 왼쪽에서 쉽게 들어가고 탐색 할 때 오른쪽으로 미끄러집니다.</target>
        </trans-unit>
        <trans-unit id="6d869f89c0032b7d502684b0c42e737ad757a361" translate="yes" xml:space="preserve">
          <source>When testing a component, only the service's public API should matter. In general, tests themselves should not make calls to remote servers. They should emulate such calls. The setup in this &lt;code&gt;app/twain/twain.component.spec.ts&lt;/code&gt; shows one way to do that:</source>
          <target state="translated">구성 요소를 테스트 할 때는 서비스의 공용 API 만 중요합니다. 일반적으로 테스트 자체는 원격 서버를 호출해서는 안됩니다. 그들은 그러한 부름을 모방해야합니다. 이 &lt;code&gt;app/twain/twain.component.spec.ts&lt;/code&gt; 의 설정은이 를 수행하는 한 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef0f0acd351b519e1bdbe282aaf9c197ad051fd4" translate="yes" xml:space="preserve">
          <source>When testing a service with a dependency, provide the mock in the &lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">종속성이있는 서비스를 테스트 할 때 &lt;code&gt;providers&lt;/code&gt; 배열에 모의를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0860f03444a0fc7aa7e1b3fb17143a54bae674bc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; expression returns a truthy value, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; adds the &lt;code&gt;ItemDetailComponent&lt;/code&gt; to the DOM. When the expression is falsy, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; removes the &lt;code&gt;ItemDetailComponent&lt;/code&gt; from the DOM, destroying that component and all of its sub-components.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; 표현식이 truthy 값을 반환, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 추가 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 는 DOM에 있습니다. 식이 falsy되면 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 제거 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 을 해당 구성 요소 및 하위 구성 요소를 모두 파괴 상기 DOM에서.</target>
        </trans-unit>
        <trans-unit id="7210ba167993f8f770531f5c2b064669c209d5dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;@.disabled&lt;/code&gt; binding is true, the &lt;code&gt;@childAnimation&lt;/code&gt; trigger doesn't kick off.</source>
          <target state="translated">때 &lt;code&gt;@.disabled&lt;/code&gt; 입니다 사실 바인딩의 &lt;code&gt;@childAnimation&lt;/code&gt; 의 트리거는 킥오프하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8caa4e29d9b4d974dd5d9041992426ba9ac8a426" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;base&lt;/code&gt; tag is mis-configured, the app fails to load and the browser console displays &lt;code&gt;404 - Not Found&lt;/code&gt; errors for the missing files. Look at where it &lt;em&gt;tried&lt;/em&gt; to find those files and adjust the base tag appropriately.</source>
          <target state="translated">하면 &lt;code&gt;base&lt;/code&gt; 태그가 잘못 구성되어 있습니다, 응용 프로그램은로드되지 브라우저 콘솔 디스플레이 &lt;code&gt;404 - Not Found&lt;/code&gt; 누락 된 파일에 대한 오류. 그것은 어디 봐 &lt;em&gt;노력&lt;/em&gt; 해당 파일을 찾아 적절하게 기본 태그를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e75c241922935cbd3ea5df02a84d5245d7cf9eba" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;condition&lt;/code&gt; is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears. When the &lt;code&gt;condition&lt;/code&gt; is truthy, the top (A) paragraph is removed and the bottom (B) paragraph appears.</source>
          <target state="translated">때 &lt;code&gt;condition&lt;/code&gt; falsy이며, 상단 (A) 단락 나타나고 저부 (B) 단락 사라진다. 때 &lt;code&gt;condition&lt;/code&gt; truthy이며, 상단 (A) 항을 제거하고, 저부 (B) 단락 나타나있다.</target>
        </trans-unit>
        <trans-unit id="3dc1efd9593828d0e01af36e18c84dde19f4956e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;deleteRequest&lt;/code&gt; event fires, Angular calls the parent component's &lt;code&gt;deleteItem()&lt;/code&gt; method, passing the &lt;em&gt;item-to-delete&lt;/em&gt; (emitted by &lt;code&gt;ItemDetail&lt;/code&gt;) in the &lt;code&gt;$event&lt;/code&gt; variable.</source>
          <target state="translated">때 &lt;code&gt;deleteRequest&lt;/code&gt; 이벤트 화재, 각도는 부모 구성 요소의 호출 &lt;code&gt;deleteItem()&lt;/code&gt; 통과, 방법을 &lt;em&gt;항목 - 투 - 삭제&lt;/em&gt; (방출 &lt;code&gt;ItemDetail&lt;/code&gt; 을 에서) &lt;code&gt;$event&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c9a2b3437891fb18901b8b21686790b30e088379" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;id&lt;/code&gt; cannot be found, the component should re-route to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;id&lt;/code&gt; 찾을 수없는 구성 요소는 간 경로를 다시해야 &lt;code&gt;HeroListComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d2e3d77dbe8594275e223d51b36cd1f3be8ab17c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;false&lt;/code&gt; (the default), and if the compiler cannot infer the variable type based on how it's used, the compiler silently defaults the type to &lt;code&gt;any&lt;/code&gt;. That's what is meant by &lt;em&gt;implicit &lt;code&gt;any&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 플래그가 &lt;code&gt;false&lt;/code&gt; (기본), 컴파일러는 변수 유형 추론이 사용되는 방법에 따라 할 수없는 경우, 컴파일러 자동으로 기본값으로 유형 &lt;code&gt;any&lt;/code&gt; . 이것이 &lt;em&gt;암시 적 &lt;code&gt;any&lt;/code&gt; 의&lt;/em&gt; 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="1d4a388447e5472702495919fcaedf96a0b5cef4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt; and the TypeScript compiler cannot infer the type, it still generates the JavaScript files, but it also &lt;strong&gt;reports an error&lt;/strong&gt;. Many seasoned developers prefer this stricter setting because type checking catches more unintentional errors at compile time.</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 과 타이프 스크립트 컴파일러가 타입을 추론 할 수없는, 여전히 자바 스크립트 파일을 생성뿐만 아니라 &lt;strong&gt;오류를보고합니다&lt;/strong&gt; . 많은 노련한 개발자는 유형 검사시 컴파일시 의도하지 않은 오류가 더 많이 발생하므로이 엄격한 설정을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="acd1794f17ea94afe9bc086e9963108f4a25ba69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, you may get &lt;em&gt;implicit index errors&lt;/em&gt; as well. Most developers feel that &lt;em&gt;this particular error&lt;/em&gt; is more annoying than helpful. You can suppress them with the following additional flag:</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 의 플래그가 &lt;code&gt;true&lt;/code&gt; , 당신은 얻을 수 있습니다 &lt;em&gt;암시 인덱스 오류가&lt;/em&gt; 아니라. 대부분의 개발자는 &lt;em&gt;이 특정 오류&lt;/em&gt; 가 도움이되는 것보다 더 성가신 것이라고 생각합니다 . 다음 추가 플래그를 사용하여이를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1221ec7078025cb9fbeced33a7c810ee121599ea" translate="yes" xml:space="preserve">
          <source>When the Angular Router matches a route that uses AngularJS, the &lt;code&gt;AngularJSComponent&lt;/code&gt; is rendered, and the content is rendered within the AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ngRoute/directive/ngView&quot;&gt;&lt;code&gt;ng-view&lt;/code&gt;&lt;/a&gt; directive. When the user navigates away from the route, the &lt;code&gt;$rootScope&lt;/code&gt; is destroyed on the AngularJS application.</source>
          <target state="translated">Angular 라우터가 AngularJS를 사용하는 경로와 일치하면 &lt;code&gt;AngularJSComponent&lt;/code&gt; 가 렌더링되고 컨텐츠는 AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ngRoute/directive/ngView&quot;&gt; &lt;code&gt;ng-view&lt;/code&gt; &lt;/a&gt; 지시문 내에서 렌더링됩니다 . 사용자가 경로를 벗어나 면 AngularJS 응용 프로그램에서 &lt;code&gt;$rootScope&lt;/code&gt; 가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="080f2859f1d13e16f7fe1af393eea801d31826ab" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns this template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;bestByDate&lt;/code&gt; is not a member of the &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; object when it runs type checking on the template.</source>
          <target state="translated">Angular 컴파일러는이 템플릿을 TypeScript 코드로 변환하면 템플릿에서 유형 검사를 실행할 때 &lt;code&gt;bestByDate&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 객체 의 멤버가 아니라고 TypeScript에서보고 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0289ecc8b0efe9a3b03fd5c608e586c950afcad" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns your template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; might be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Angular 컴파일러는 템플릿을 TypeScript 코드로 변환 할 때 TypeScript가 해당 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 음을보고하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="7b523d4946336137aa2dbed657d1c4be4adcefae" translate="yes" xml:space="preserve">
          <source>When the Angular router lazy-loads a module, it creates a new execution context. That &lt;a href=&quot;ngmodule-faq#q-why-child-injector&quot;&gt;context has its own injector&lt;/a&gt;, which is a direct child of the application injector.</source>
          <target state="translated">Angular 라우터가 모듈을 지연로드하면 새로운 실행 컨텍스트가 생성됩니다. 해당 &lt;a href=&quot;ngmodule-faq#q-why-child-injector&quot;&gt;컨텍스트에는 자체 인젝터가&lt;/a&gt; 있으며 이는 애플리케이션 인젝터의 직접적인 하위입니다.</target>
        </trans-unit>
        <trans-unit id="2cf28989035e8b08a947a71d640454a09e99a9b3" translate="yes" xml:space="preserve">
          <source>When the Angular router lazy-loads a module, it creates a new injector. This injector is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.</source>
          <target state="translated">Angular 라우터가 모듈을 지연 로딩하면 새로운 인젝터가 생성됩니다. 이 인젝터는 루트 애플리케이션 인젝터의 하위입니다. 인젝터 나무를 상상해보십시오. 하나의 루트 인젝터와 각 게으른로드 된 모듈에 대한 하위 인젝터가 있습니다. 라우터는 루트 인젝터의 모든 제공자를 하위 인젝터에 추가합니다. 라우터가 느리게로드 된 컨텍스트 내에서 컴포넌트를 작성할 때 Angular는 이러한 제공자에서 작성된 서비스 인스턴스를 애플리케이션 루트 인젝터의 서비스 인스턴스보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="a59c1220766a1692e2ac330d5b21be92fc1db6a9" translate="yes" xml:space="preserve">
          <source>When the CLI commands &lt;code&gt;ng test&lt;/code&gt; and &lt;code&gt;ng e2e&lt;/code&gt; are generally running the CI tests in your environment, you might still need to adjust your configuration to run the Chrome browser tests.</source>
          <target state="translated">CLI 명령 &lt;code&gt;ng test&lt;/code&gt; 및 &lt;code&gt;ng e2e&lt;/code&gt; 가 일반적으로 환경에서 CI 테스트를 실행하는 경우 Chrome 브라우저 테스트를 실행하도록 구성을 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88b7c40f460e73c24fa3f0de74d16ad21ad9d2c" translate="yes" xml:space="preserve">
          <source>When the CLI generated the &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; for the feature module, it included a template, &lt;code&gt;customer-dashboard.component.html&lt;/code&gt;, with the following markup:</source>
          <target state="translated">CLI 가 기능 모듈에 대한 &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; 를 생성 할 때 &lt;code&gt;customer-dashboard.component.html&lt;/code&gt; 템플리트를 다음 마크 업과 함께 포함했습니다 .</target>
        </trans-unit>
        <trans-unit id="59925ab392dd758a0d023368a837b4147d92ef54" translate="yes" xml:space="preserve">
          <source>When the CLI generated the &lt;code&gt;HeroesComponent&lt;/code&gt;, it created an empty &lt;code&gt;heroes.component.css&lt;/code&gt; stylesheet for the &lt;code&gt;HeroesComponent&lt;/code&gt; and pointed to it in &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; like this.</source>
          <target state="translated">CLI를 생성 할 때 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 , 그것은 빈 생성 &lt;code&gt;heroes.component.css&lt;/code&gt; 의 에 대한 스타일 시트 &lt;code&gt;HeroesComponent&lt;/code&gt; 을 하고 그것을 지적 &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; 같이.</target>
        </trans-unit>
        <trans-unit id="aa5fd6c00e755291fcd1e8dfd434052f8247fbca" translate="yes" xml:space="preserve">
          <source>When the ES5 Browserslist result is &lt;code&gt;disabled&lt;/code&gt;, then ES5 browser support is not required. Otherwise, ES5 browser support is required.</source>
          <target state="translated">ES5 Browserslist 결과가 &lt;code&gt;disabled&lt;/code&gt; 되면 ES5 브라우저 지원이 필요하지 않습니다. 그렇지 않으면 ES5 브라우저 지원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d409951125980096e2daa76599fa79723877f3d7" translate="yes" xml:space="preserve">
          <source>When the app starts, the &lt;code&gt;selectedHero&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;by design&lt;/em&gt;.</source>
          <target state="translated">앱이 시작되면 &lt;code&gt;selectedHero&lt;/code&gt; 는 &lt;em&gt;디자인에 의해 &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85cce31634dd108961a3fd7d6540d6c70f895fff" translate="yes" xml:space="preserve">
          <source>When the app starts, the browser's address bar points to the web site's root. That doesn't match any existing route so the router doesn't navigate anywhere. The space below the &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; is blank.</source>
          <target state="translated">앱이 시작되면 브라우저의 주소 표시 줄이 웹 사이트의 루트를 가리 킵니다. 기존 경로와 일치하지 않으므로 라우터가 아무 곳이나 탐색하지 않습니다. &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 아래의 공백이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bea55775588ba5cf5d20de8360b1abd2270286d" translate="yes" xml:space="preserve">
          <source>When the application launches, the initial URL in the browser bar is something like:</source>
          <target state="translated">응용 프로그램이 시작되면 브라우저 표시 줄의 초기 URL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="229415848028c721168bbcfe230abe07e6e4c7d2" translate="yes" xml:space="preserve">
          <source>When the application requests navigation to the path &lt;code&gt;/crisis-center&lt;/code&gt;, the router activates an instance of &lt;code&gt;CrisisListComponent&lt;/code&gt;, displays its view, and updates the browser's address location and history with the URL for that path.</source>
          <target state="translated">응용 프로그램이 &lt;code&gt;/crisis-center&lt;/code&gt; 경로 탐색을 요청 하면 라우터는 &lt;code&gt;CrisisListComponent&lt;/code&gt; 인스턴스를 활성화하고 해당 뷰를 표시하며 브라우저의 주소 위치 및 기록을 해당 경로의 URL로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c361606b02a6340c1440983835104942a028a4c0" translate="yes" xml:space="preserve">
          <source>When the bootstrap method is switched from that of &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; to pure Angular, AngularJS ceases to exist on the page completely. At this point, you need to tell Protractor that it should not be looking for an AngularJS app anymore, but instead it should find &lt;em&gt;Angular apps&lt;/em&gt; from the page.</source>
          <target state="translated">부트 스트랩 방법을 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 의 방법 에서 순수한 Angular 로 전환 하면 AngularJS가 페이지에서 완전히 존재하지 않습니다. 이 시점에서 Protractor에 AngularJS 앱을 더 이상 찾지 말고 대신 페이지에서 &lt;em&gt;Angular 앱&lt;/em&gt; 을 찾아야한다고 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="390621ac2e07fd3b6f4546222f0b4c3bdc079e78" translate="yes" xml:space="preserve">
          <source>When the browser refreshes, the app should work again. You can edit the hero's name and see the changes reflected immediately in the &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; above the textbox.</source>
          <target state="translated">브라우저가 새로 고침되면 앱이 다시 작동해야합니다. 영웅의 이름을 편집 하고 텍스트 상자 위의 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; 에 즉시 반영된 변경 사항을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f7fdc0a3d021ba9aefb9ebd7e31adbe1a20f6b3" translate="yes" xml:space="preserve">
          <source>When the browser renders &lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;Sarah&quot;&amp;gt;&lt;/code&gt;, it creates a corresponding DOM node with a &lt;code&gt;value&lt;/code&gt; property initialized to &quot;Sarah&quot;.</source>
          <target state="translated">브라우저는 &lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;Sarah&quot;&amp;gt;&lt;/code&gt; 렌더링 할 때 &lt;code&gt;value&lt;/code&gt; 특성이 &quot;Sarah&quot;로 초기화 된 해당 DOM 노드를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="df2233bf5455bd5715e7600e6f1195db0c477e2f" translate="yes" xml:space="preserve">
          <source>When the browser's location URL changes to match the path segment &lt;code&gt;/crisis-center&lt;/code&gt;, then the router activates an instance of the &lt;code&gt;CrisisListComponent&lt;/code&gt; and displays its view.</source>
          <target state="translated">브라우저의 위치 URL이 경로 세그먼트 &lt;code&gt;/crisis-center&lt;/code&gt; 와 일치하도록 변경 되면 라우터는 &lt;code&gt;CrisisListComponent&lt;/code&gt; 의 인스턴스를 활성화하고 해당보기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6169562d3c2a62b330d6c334a1f65f9b57448074" translate="yes" xml:space="preserve">
          <source>When the build is complete, make a copy of &lt;code&gt;docs/index.html&lt;/code&gt; and name it &lt;code&gt;docs/404.html&lt;/code&gt;.</source>
          <target state="translated">빌드가 완료되면 &lt;code&gt;docs/index.html&lt;/code&gt; 의 사본을 작성 하고 이름을 &lt;code&gt;docs/404.html&lt;/code&gt; 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f89de102a1abb74769837f142272c4ff2f6b0f07" translate="yes" xml:space="preserve">
          <source>When the component instance is destroyed, so is that service instance.</source>
          <target state="translated">구성 요소 인스턴스가 파괴되면 해당 서비스 인스턴스도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="2311871b7205a5129ce3ee5c983030b3867b7bc9" translate="yes" xml:space="preserve">
          <source>When the condition is false, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; removes its host element from the DOM, detaches it from DOM events (the attachments that it made), detaches the component from Angular change detection, and destroys it. The component and DOM nodes can be garbage-collected and free up memory.</source>
          <target state="translated">조건이 false 인 경우 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 호스트 요소를 DOM에서 제거하고 DOM 이벤트 (연결된 첨부 파일)에서 분리하고 각도 변경 감지에서 구성 요소를 분리하여 제거합니다. 컴포넌트 및 DOM 노드는 가비지 수집되어 메모리를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4524392797b14c325b60bac95b96ec334a2b3e1a" translate="yes" xml:space="preserve">
          <source>When the contents of the iterator changes, &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; makes the corresponding changes to the DOM:</source>
          <target state="translated">반복자의 내용이 변경되면 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; 는 DOM을 해당 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0e5038380ebb787d300a2c9eb39551f139a04fd3" translate="yes" xml:space="preserve">
          <source>When the current row hero is the same as the &lt;code&gt;selectedHero&lt;/code&gt;, Angular adds the &lt;code&gt;selected&lt;/code&gt; CSS class. When the two heroes are different, Angular removes the class.</source>
          <target state="translated">현재 행 히어로가 &lt;code&gt;selectedHero&lt;/code&gt; 와 동일 하면 Angular는 &lt;code&gt;selected&lt;/code&gt; CSS 클래스를 추가합니다 . 두 영웅이 다르면 Angular는 클래스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="88f7dc097723856c6451253157ead9cee3d512b4" translate="yes" xml:space="preserve">
          <source>When the default change detector detects changes, it invokes &lt;code&gt;ngOnChanges()&lt;/code&gt; if supplied, regardless of whether you perform additional change detection. Typically, you should not use both &lt;code&gt;&lt;a href=&quot;docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; to respond to changes on the same input.</source>
          <target state="translated">기본 변경 감지기는 변경을 감지하면 추가 변경 감지를 수행하는지 여부에 관계없이 제공된 경우 &lt;code&gt;ngOnChanges()&lt;/code&gt; 호출합니다 . 일반적으로 동일한 입력의 변경에 응답하기 위해 &lt;code&gt;&lt;a href=&quot;docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; 를 모두 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="87eced2ba76fd26a75fedaeb26d1a231925e3980" translate="yes" xml:space="preserve">
          <source>When the event is raised, the handler executes the template statement. The template statement typically involves a receiver, which performs an action in response to the event, such as storing a value from the HTML control into a model.</source>
          <target state="translated">이벤트가 발생하면 핸들러는 템플리트 명령문을 실행합니다. 템플릿 문은 일반적으로 수신자에 관련되며, HTML 컨트롤의 값을 모델에 저장하는 것과 같이 이벤트에 응답하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e6dde887a621ed7d8cda22827f17a6b04470ac49" translate="yes" xml:space="preserve">
          <source>When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not applied and the formatted text will have the same day, month and year of the expression.</source>
          <target state="translated">식이 시간이없는 ISO 문자열 (예 : 2016-09-19) 인 경우 표준 시간대 오프셋이 적용되지 않으며 서식이 지정된 텍스트는 식의 일, 월 및 연도가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="37ece522a490a41d305f59b9d00b58e362fecb66" translate="yes" xml:space="preserve">
          <source>When the given name is non-blank, the handler creates a &lt;code&gt;Hero&lt;/code&gt;-like object from the name (it's only missing the &lt;code&gt;id&lt;/code&gt;) and passes it to the services &lt;code&gt;addHero()&lt;/code&gt; method.</source>
          <target state="translated">주어진 이름이 비어 있지 않으면 핸들러 는 이름에서 &lt;code&gt;Hero&lt;/code&gt; 와 유사한 객체를 생성하고 ( &lt;code&gt;id&lt;/code&gt; 만 누락 됨 ) 서비스 &lt;code&gt;addHero()&lt;/code&gt; 메소드에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="15483efa7611420de43a81a7b88feacee6eacb09" translate="yes" xml:space="preserve">
          <source>When the key is a property of the host element, the property value is the propagated to the specified DOM property.</source>
          <target state="translated">키가 호스트 요소의 속성 인 경우 속성 값은 지정된 DOM 속성으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2b2a15239650c80bd61cf3a7c4a6838674078b" translate="yes" xml:space="preserve">
          <source>When the key is a static attribute in the DOM, the attribute value is propagated to the specified property in the host element.</source>
          <target state="translated">키가 DOM에서 정적 속성 인 경우 속성 값은 호스트 요소의 지정된 특성으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a68099d4829af5c295f8308c3e9d58baf906ee" translate="yes" xml:space="preserve">
          <source>When the old component logs a message with &lt;code&gt;OldLogger&lt;/code&gt;, you want the singleton instance of &lt;code&gt;NewLogger&lt;/code&gt; to handle it instead. In this case, the dependency injector should inject that singleton instance when a component asks for either the new or the old logger. &lt;code&gt;OldLogger&lt;/code&gt; should be an &lt;em&gt;alias&lt;/em&gt; for &lt;code&gt;NewLogger&lt;/code&gt;.</source>
          <target state="translated">이전 컴포넌트가 &lt;code&gt;OldLogger&lt;/code&gt; 로 메시지를 로그 할 때 NewLogger 의 싱글 톤 인스턴스가 대신 &lt;code&gt;NewLogger&lt;/code&gt; 를 처리하기를 원합니다 . 이 경우 종속성 인젝터는 구성 요소가 새 또는 이전 로거를 요청할 때 해당 단일 인스턴스를 주입해야합니다. &lt;code&gt;OldLogger&lt;/code&gt; 는 해야 &lt;em&gt;별칭&lt;/em&gt; 에 대한 &lt;code&gt;NewLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ff128e54a9e6628bf482f076b33ee1b1b627b6f" translate="yes" xml:space="preserve">
          <source>When the parent component &lt;em&gt;class&lt;/em&gt; requires that kind of access, &lt;strong&gt;&lt;em&gt;inject&lt;/em&gt;&lt;/strong&gt; the child component into the parent as a &lt;em&gt;ViewChild&lt;/em&gt;.</source>
          <target state="translated">부모 구성 요소 &lt;em&gt;클래스&lt;/em&gt; 에 이러한 종류의 액세스가 필요한 경우 자식 구성 요소를 &lt;em&gt;ViewChild&lt;/em&gt; 로 부모에 &lt;strong&gt;&lt;em&gt;주입&lt;/em&gt;&lt;/strong&gt; 하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9900aa1ed0b5e38fbcd32f4da40c0c5d962adb0" translate="yes" xml:space="preserve">
          <source>When the restore is finished, a message in the bottom message bar of Visual Studio should say: &lt;code&gt;Installing packages complete&lt;/code&gt;. Be patient. This could take a while.</source>
          <target state="translated">복원이 완료되면 Visual Studio의 하단 메시지 표시 줄에 다음과 같은 메시지가 표시 &lt;code&gt;Installing packages complete&lt;/code&gt; . 패키지 설치 완료 . 인내심을 가지십시오. 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1050711c1fd12fb5b6f194938f3e8579a393e6" translate="yes" xml:space="preserve">
          <source>When the router lazy loads a module, it creates a child injector and registers the &lt;code&gt;UserService&lt;/code&gt; provider with that child injector. The child injector is &lt;em&gt;not&lt;/em&gt; the root injector.</source>
          <target state="translated">라우터 지연은 모듈을로드 할 때 하위 인젝터를 작성하고 해당 하위 인젝터에 &lt;code&gt;UserService&lt;/code&gt; 제공자를 등록합니다 . 자식 인젝터는 루트 인젝터가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bec743e0774188316c4607e7d48359e06eca207a" translate="yes" xml:space="preserve">
          <source>When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. This is a strictly local URL. The browser shouldn't send this URL to the server and should not reload the page.</source>
          <target state="translated">라우터가 새 구성 요소보기로 이동하면 브라우저의 위치 및 히스토리가 해당보기의 URL로 업데이트됩니다. 이것은 엄격하게 로컬 URL입니다. 브라우저는이 URL을 서버로 보내지 않아야하며 페이지를 다시로드해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="90b902ee771a51ea4c2789f717ed041922a6f1b5" translate="yes" xml:space="preserve">
          <source>When the router navigates to this route, it uses the &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; string to dynamically load the &lt;code&gt;AdminModule&lt;/code&gt;. Then it adds the &lt;code&gt;AdminModule&lt;/code&gt; routes to its current route configuration. Finally, it loads the requested route to the destination admin component.</source>
          <target state="translated">라우터가이 경로를 탐색 할 때 &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; 문자열을 사용 하여 &lt;code&gt;AdminModule&lt;/code&gt; 을 동적으로로드합니다 . 그런 다음 &lt;code&gt;AdminModule&lt;/code&gt; 경로를 현재 경로 구성에 추가 합니다. 마지막으로 요청 된 경로를 대상 관리자 구성 요소로로드합니다.</target>
        </trans-unit>
        <trans-unit id="c4793c657e648cd962d6756a48cf39fb9572cc40" translate="yes" xml:space="preserve">
          <source>When the server is ready, you'll detach the In-memory Web API, and the app's requests will go through to the server.</source>
          <target state="translated">서버가 준비되면 메모리 내 웹 API를 분리하면 앱 요청이 서버로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5e1c6cb471ba84681d4eec768f8daf9aee7300" translate="yes" xml:space="preserve">
          <source>When the server responds successfully with the newly added hero, the component adds that hero to the displayed &lt;code&gt;heroes&lt;/code&gt; list.</source>
          <target state="translated">서버가 새로 추가 된 영웅으로 응답하면 컴포넌트는 해당 영웅을 표시된 &lt;code&gt;heroes&lt;/code&gt; 목록에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="7f5488c0527bdc65788bef91441700006f51550b" translate="yes" xml:space="preserve">
          <source>When the tests are complete, the command creates a new &lt;code&gt;/coverage&lt;/code&gt; folder in the project. Open the &lt;code&gt;index.html&lt;/code&gt; file to see a report with your source code and code coverage values.</source>
          <target state="translated">테스트가 완료되면 명령은 프로젝트에 새 &lt;code&gt;/coverage&lt;/code&gt; 폴더를 만듭니다 . &lt;code&gt;index.html&lt;/code&gt; 파일을 열어 소스 코드 및 코드 범위 값이 포함 된 보고서를보십시오.</target>
        </trans-unit>
        <trans-unit id="cc433f6ebd5153ea48b6acb9758c8f35454ca692" translate="yes" xml:space="preserve">
          <source>When the url is either '/user' or '/user/bob', the active-link class will be added to the &lt;code&gt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt; tag. If the url changes, the class will be removed.</source>
          <target state="translated">URL이 중 '/ 사용자'또는 '/ 사용자 / 밥'일 때, 활성 링크 클래스에 추가됩니다 태그입니다. URL이 변경되면 클래스가 제거됩니다. &lt;code&gt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56e24b86fc8dc4eb7c05899793fc749916e2d93a" translate="yes" xml:space="preserve">
          <source>When the user clicks a hero in the &lt;strong&gt;master&lt;/strong&gt; list, the component should display the selected hero's &lt;strong&gt;details&lt;/strong&gt; at the bottom of the page.</source>
          <target state="translated">사용자가 &lt;strong&gt;마스터&lt;/strong&gt; 목록 에서 영웅을 클릭 하면 구성 요소가 선택한 영웅의 &lt;strong&gt;세부 정보&lt;/strong&gt; 를 페이지 하단에 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0da528ae2bbf4606a802931b278d60a04b127084" translate="yes" xml:space="preserve">
          <source>When the user clicks a hero item in the &lt;code&gt;HeroesComponent&lt;/code&gt;, the app should navigate to the &lt;code&gt;HeroDetailComponent&lt;/code&gt;, replacing the heroes list view with the hero detail view. The heroes list view should no longer show hero details as it does now.</source>
          <target state="translated">사용자가 &lt;code&gt;HeroesComponent&lt;/code&gt; 에서 영웅 항목을 클릭 하면 앱이 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 로 이동 하여 영웅 목록보기를 영웅 세부 사항보기로 바꿔야 합니다. 영웅 목록보기에는 더 이상 영웅 세부 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="965cc4386347869f8766b8bd6c03a51c94b256a1" translate="yes" xml:space="preserve">
          <source>When the user clicks the back button, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; constructs another &lt;em&gt;link parameters array&lt;/em&gt; which it uses to navigate back to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">사용자가 뒤로 가기 버튼을 클릭하면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 는 다른 구축 &lt;em&gt;링크 파라미터 어레이&lt;/em&gt; 는 행 위로 이동하기 위해 사용 &lt;code&gt;HeroListComponent&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b5381f2dbc392678bc72803a41a04f59cc4b7028" translate="yes" xml:space="preserve">
          <source>When the user clicks the button, Angular calls the &lt;code&gt;onClickMe&lt;/code&gt; method from &lt;code&gt;ClickMeComponent&lt;/code&gt;.</source>
          <target state="translated">사용자가 버튼을 클릭하면 Angular는 &lt;code&gt;onClickMe&lt;/code&gt; 에서 &lt;code&gt;ClickMeComponent&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="09f436cef939df335d96f2d5d3fa0d239641f9a3" translate="yes" xml:space="preserve">
          <source>When the user deletes the name, the form should look like this:</source>
          <target state="translated">사용자가 이름을 삭제하면 양식은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="60767066f8c768e0937e2414770db47911b50141" translate="yes" xml:space="preserve">
          <source>When the user enters &quot;Sally&quot; into the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, the DOM element &lt;code&gt;value&lt;/code&gt;&lt;em&gt;property&lt;/em&gt; becomes &quot;Sally&quot;. However, if you look at the HTML attribute &lt;code&gt;value&lt;/code&gt; using &lt;code&gt;input.getAttribute('value')&lt;/code&gt;, you can see that the &lt;em&gt;attribute&lt;/em&gt; remains unchanged&amp;mdash;it returns &quot;Sarah&quot;.</source>
          <target state="translated">사용자가 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 &quot;Sally&quot;를 입력 하면 DOM 요소 &lt;code&gt;value&lt;/code&gt; &lt;em&gt;특성&lt;/em&gt; 이 &quot;Sally&quot;가됩니다. 그러나 &lt;code&gt;input.getAttribute('value')&lt;/code&gt; 를 사용하여 HTML 속성 &lt;code&gt;value&lt;/code&gt; 을 보면 &lt;em&gt;속성&lt;/em&gt; 이 변경되지 않고 &quot;Sarah&quot;를 반환 한다는 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45684a41a52534dc3a21a13492006994cdd3ce14" translate="yes" xml:space="preserve">
          <source>When the user enters a name in a search-box, the &lt;code&gt;PackageSearchComponent&lt;/code&gt; sends a search request for a package with that name to the NPM web API.</source>
          <target state="translated">사용자가 검색 상자에 이름을 입력하면 &lt;code&gt;PackageSearchComponent&lt;/code&gt; 가 해당 이름의 패키지에 대한 검색 요청을 NPM 웹 API로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="24612cfd1409a4d5460abc7f2935bcce9977ee3f" translate="yes" xml:space="preserve">
          <source>When the user navigates from the heroes list to the &quot;Magneta&quot; hero and back, &quot;Magneta&quot; appears selected:</source>
          <target state="translated">사용자가 영웅 목록에서 &quot;Magneta&quot;영웅으로 이동 한 후 &quot;Magneta&quot;가 선택된 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="20759cd95c7b4ee15d25a5ac38dd65f7086028c9" translate="yes" xml:space="preserve">
          <source>When the user picks a hero, &lt;code&gt;selectedHero&lt;/code&gt; has a value and &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; puts the hero detail into the DOM.</source>
          <target state="translated">사용자가 영웅을 &lt;code&gt;selectedHero&lt;/code&gt; 때 selectedHero 는 값을 가지며 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 영웅 세부 정보를 DOM에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="d3a252aba875b8f256c6decf33f58be856151e22" translate="yes" xml:space="preserve">
          <source>When the user selects a hero from the list, the app should navigate to the detail view and show that hero. You tell the detail view which hero to display by including the selected hero's id in the route URL.</source>
          <target state="translated">사용자가 목록에서 영웅을 선택하면 앱이 상세보기로 이동하여 해당 영웅을 표시해야합니다. 라우트 URL에 선택한 영웅의 ID를 포함시켜 표시 할 영웅을 세부 정보보기에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a510d7fcc215eca3c7dadb10daf2bda07de4c2f2" translate="yes" xml:space="preserve">
          <source>When the value changes in the UI, call the registered function to allow the forms API to update itself:</source>
          <target state="translated">UI에서 값이 변경되면 등록 된 함수를 호출하여 양식 API가 자체적으로 업데이트되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="8f3a890a779d79ad9661c7749d679f59723a6996" translate="yes" xml:space="preserve">
          <source>When the workspace file structure is in place, you can use the &lt;code&gt;ng generate&lt;/code&gt; command on the command line to add functionality and data to the application. This initial root-level application is the &lt;em&gt;default app&lt;/em&gt; for CLI commands (unless you change the default after creating &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;additional apps&lt;/a&gt;).</source>
          <target state="translated">작업 공간 파일 구조가 있으면 명령 행 에서 &lt;code&gt;ng generate&lt;/code&gt; 명령을 사용하여 기능 및 데이터를 애플리케이션에 추가 할 수 있습니다 . 이 초기 루트 수준 응용 프로그램은 CLI 명령 의 &lt;em&gt;기본 응용 프로그램&lt;/em&gt; 입니다 ( &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;추가 응용 프로그램&lt;/a&gt; 을 만든 후 기본값을 변경하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="3732bd2e415ded41d84e9da700bfbe65d89ef57d" translate="yes" xml:space="preserve">
          <source>When there isn't a host element, you can usually wrap the content in a native HTML container element, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, and attach the directive to that wrapper.</source>
          <target state="translated">호스트 요소가없는 경우 일반적으로 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 같은 기본 HTML 컨테이너 요소로 컨텐츠를 랩핑 하고 지시자를 해당 랩퍼에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fc8a283755738e86c35338fd89146a3972eeed2" translate="yes" xml:space="preserve">
          <source>When true (recommended), enables the &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;binding expression validation&lt;/a&gt; phase of the template compiler, which uses TypeScript to validate binding expressions.</source>
          <target state="translated">true (권장) 인 경우 TypeScript를 사용하여 &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;바인딩 표현식의 유효성을 검사&lt;/a&gt; 하는 템플릿 컴파일러 의 바인딩 표현식 유효성 검사 단계를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="878269276c4b94291dba5557e0c330a0c66c6fb8" translate="yes" xml:space="preserve">
          <source>When true (recommended), reports an error for a supplied parameter whose injection type cannot be determined. When false (currently the default), constructor parameters of classes marked with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; whose type cannot be resolved produce a warning.</source>
          <target state="translated">true (권장) 인 경우 주입 유형을 결정할 수없는 제공된 매개 변수에 대한 오류를보고합니다. false (현재 기본값) 인 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 로 표시된 클래스의 생성자 매개 변수에서 유형을 확인할 수없는 경우 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b212849a159920cad7420629011f7a9864bdde5b" translate="yes" xml:space="preserve">
          <source>When true (the default) creates files at the top level of the project.</source>
          <target state="translated">true 인 경우 (기본값) 프로젝트의 최상위 레벨에 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b398aee58d8c1adc60ea74f0c726ecef38afbcac" translate="yes" xml:space="preserve">
          <source>When true (the default), creates a new initial app project in the src folder of the new workspace. When false, creates an empty workspace with no initial app. You can then use the generate application command so that all apps are created in the projects folder.</source>
          <target state="translated">true 인 경우 (기본값) 새 작업 공간의 src 폴더에 새 초기 앱 프로젝트를 만듭니다. false 인 경우 초기 앱없이 빈 작업 공간을 만듭니다. 그런 다음 generate application 명령을 사용하여 모든 앱이 프로젝트 폴더에 작성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604d90449f9af601695e42adb4b369217d014677" translate="yes" xml:space="preserve">
          <source>When true (the default), creates files at the top level of the project.</source>
          <target state="translated">true 인 경우 (기본값) 프로젝트의 최상위 레벨에 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7dcf5b75b56e6b05b97927c0c576164a022fcc31" translate="yes" xml:space="preserve">
          <source>When true (the default), creates the new files at the top level of the current project.</source>
          <target state="translated">true 인 경우 (기본값) 현재 프로젝트의 최상위 레벨에 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c73f51ee5cd9b796be53e6056b6cf273b83aea52" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new class.</source>
          <target state="translated">true 인 경우 (기본값) 새 클래스에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ee4fe2980cd47d4b732694bd3792325d274c7180" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new component.</source>
          <target state="translated">true 인 경우 (기본값) 새 구성 요소에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d9eb4be401f613f74c8a47c2093669fd19d2a62c" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new directive.</source>
          <target state="translated">true 인 경우 (기본값) 새 지시문에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6481d790b1dddc693cad7c9e147a4da0a6eb5138" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new guard.</source>
          <target state="translated">true 인 경우 (기본값) 새 가드에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a7a7c6e8767122c13c74f42b5133e29df9ca038a" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new pipe.</source>
          <target state="translated">true 인 경우 (기본값) 새 파이프에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67bfaa3ef25e8db2f0c7f855a6f34e4bb636d36e" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new service.</source>
          <target state="translated">true 인 경우 (기본값) 새 서비스에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13601450e9623940a233839335f1507064324df7" translate="yes" xml:space="preserve">
          <source>When true (the default), generates factory files (&lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt;) for &lt;code&gt;.d.ts&lt;/code&gt; files with a corresponding &lt;code&gt;.metadata.json&lt;/code&gt; file.</source>
          <target state="translated">true (기본값) 인 경우 해당 &lt;code&gt;.metadata.json&lt;/code&gt; 파일 이있는 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 대한 팩토리 파일 ( &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; )을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9112845e3cd524c5442bdae74800c9bc5fcdd4" translate="yes" xml:space="preserve">
          <source>When true (the default), transforms code that is or could be used in an annotation, to allow it to be imported from template factory modules. See &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;metadata rewriting&lt;/a&gt; for more information.</source>
          <target state="translated">true (기본값) 인 경우 주석에 사용되거나 사용되는 코드를 변환하여 템플릿 팩토리 모듈에서 가져올 수 있도록합니다. 자세한 내용은 &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;메타 데이터 재 작성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e2eb7a4ced22adde9d0624fe6eddd94fe05b5f" translate="yes" xml:space="preserve">
          <source>When true, accesses the global configuration in the caller's home directory.</source>
          <target state="translated">true 인 경우 호출자의 홈 디렉토리에서 글로벌 구성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="bb60a760b14a85a1bcf7a224a79ad3a0f0de50f6" translate="yes" xml:space="preserve">
          <source>When true, adds more details to output logging.</source>
          <target state="translated">true 인 경우 출력 로깅에 세부 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ab5469a20d0799c4f5bb3006c5ea578a0eca87e5" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the application.</source>
          <target state="translated">true 인 경우 응용 프로그램을 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="65e6119dd752e0e555791a9d0884d1adaeeefb3e" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the class.</source>
          <target state="translated">true 인 경우 클래스를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0adb7edc861426173459ea0ac523eb007f0c6759" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the component.</source>
          <target state="translated">true 인 경우 구성 요소를 생성 한 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="7a95d82cb423357b0496282514270de200f32d94" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the directive.</source>
          <target state="translated">true 인 경우 지시문을 생성 한 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ef7b46aab6c8559b742e340fc987833a15211ca" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the enum.</source>
          <target state="translated">true 인 경우 열거를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0c51368d0aa738deb6b05772bdbedf82c36e2946" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the guard.</source>
          <target state="translated">참이면 가드를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3c7d56418b815742975279a27504721340d37164" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the interface.</source>
          <target state="translated">true 인 경우 인터페이스를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9df5ce1e8f7684c6a8dc523cf880a5980072d9b1" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the library.</source>
          <target state="translated">true 인 경우 라이브러리 생성 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="ea80c5d299d07258dde76aab64937de197bfd6f4" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the module.</source>
          <target state="translated">true 인 경우, 모듈 생성 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="d3ea9a477728c77e2d1847ebc54f96051234cae6" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the pipe.</source>
          <target state="translated">참이면 파이프를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="568d7e9013f771f110a76cdd6a84b6900cb5a879" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the service.</source>
          <target state="translated">true 인 경우 서비스 생성 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3a45da43566e855927acf38adb2c984647ee7977" translate="yes" xml:space="preserve">
          <source>When true, creates a bare-bones project without any testing frameworks. (Use for learning purposes only.)</source>
          <target state="translated">true 인 경우 테스트 프레임 워크없이 베어 본 프로젝트를 작성합니다. (학습 목적으로 만 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="6003cdbbdfe68bec3d9470eff199fcd83c109def" translate="yes" xml:space="preserve">
          <source>When true, creates a new app that uses the Ivy rendering engine.</source>
          <target state="translated">true 인 경우 아이비 렌더링 엔진을 사용하는 새 앱을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2cd0a15167f0e4812f706fd666aae705c50d746b" translate="yes" xml:space="preserve">
          <source>When true, creates a project without any testing frameworks. (Use for learning purposes only.)</source>
          <target state="translated">true 인 경우 테스트 프레임 워크없이 프로젝트를 작성합니다. (학습 목적으로 만 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="cbf6fb323dee4d1c82a080508b0dc4b0f8607fed" translate="yes" xml:space="preserve">
          <source>When true, creates a routing NgModule.</source>
          <target state="translated">참이면 라우팅 NgModule을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="56dbc63b0ec51cd8cb74b3a1a9ad4fe8e0e83b50" translate="yes" xml:space="preserve">
          <source>When true, creates a routing module.</source>
          <target state="translated">true 인 경우 라우팅 모듈을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c2ec0ae9d8c5507501033cd46944cba3283bfeae" translate="yes" xml:space="preserve">
          <source>When true, creates the new files at the top level of the current project root.</source>
          <target state="translated">true이면 현재 프로젝트 루트의 최상위에 새 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e8e353066e54d59ddc751dbc9d0c297d8b85adb" translate="yes" xml:space="preserve">
          <source>When true, creates the new files at the top level of the current project.</source>
          <target state="translated">true 인 경우 현재 프로젝트의 최상위 레벨에 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f5a93a3117cd8f1514feec73f24850b724350d92" translate="yes" xml:space="preserve">
          <source>When true, deliver events asynchronously.</source>
          <target state="translated">true 인 경우 이벤트를 비동기 적으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="18f021c0fe33a328d88b865734d1717e7626889b" translate="yes" xml:space="preserve">
          <source>When true, disables interactive input prompts for options with a default.</source>
          <target state="translated">true 인 경우 대화식 입력 프롬프트에서 기본값으로 옵션을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6ada5bdef828fa760b365e6b7b776cf6b17adb4" translate="yes" xml:space="preserve">
          <source>When true, does not add dependencies to the &quot;package.json&quot; file.</source>
          <target state="translated">true 인 경우 &quot;package.json&quot;파일에 종속성을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8d98eca32aeaddff19b79ab0b97e3b4f44f897f" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the app.</source>
          <target state="translated">true 인 경우 앱에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5f0ff4b1329f81e381ce2feefd91e48e03360c" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new class.</source>
          <target state="translated">true 인 경우 새 클래스에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="787db2ebf3b6d9a9cfcb5d65d02ca9380b758bf7" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new component.</source>
          <target state="translated">true 인 경우 새 구성 요소에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a05daffc1a3871cce336c9e222772d0c5768aeb" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new guard.</source>
          <target state="translated">true 인 경우 새 가드에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec16b43282885c383a356226cf0f90b2d403309" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new pipe.</source>
          <target state="translated">true 인 경우 새 파이프에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84d13244f42f45e24f366a7c34846f7ff3ad9285" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new service.</source>
          <target state="translated">true 인 경우 새 서비스에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff22a4e958e901d487c01fddcd1c261ea77d1f94" translate="yes" xml:space="preserve">
          <source>When true, does not emit &lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt; files. This turns off most of the template compiler and disables the reporting of template diagnostics.</source>
          <target state="translated">true 인 경우 &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; 파일을 내 보내지 않습니다 . 이렇게하면 대부분의 템플릿 컴파일러가 꺼지고 템플릿 진단보고가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="85d57e2a3768528616abacc66eeeda04f86cb197" translate="yes" xml:space="preserve">
          <source>When true, does not generate &quot;spec.ts&quot; test files for the new project.</source>
          <target state="translated">true 인 경우 새 프로젝트에 대한 &quot;spec.ts&quot;테스트 파일을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021531593a5857b6b634ffa7110b7e09677de92f" translate="yes" xml:space="preserve">
          <source>When true, does not import this component into the owning NgModule.</source>
          <target state="translated">true 인 경우이 컴포넌트를 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dce1aa639bae69ca39cbea2281f5ab52e2f5810" translate="yes" xml:space="preserve">
          <source>When true, does not import this directive into the owning NgModule.</source>
          <target state="translated">true이면이 지시문을 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e39a45636deab57166780dec3288520cc3551132" translate="yes" xml:space="preserve">
          <source>When true, does not import this pipe into the owning NgModule.</source>
          <target state="translated">참이면이 파이프를 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="541c18226ee8c59f40f232cd042028e33b0de587" translate="yes" xml:space="preserve">
          <source>When true, does not initialize a git repository.</source>
          <target state="translated">true 인 경우 git 저장소를 초기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521a0120a95b14866025640c398ce8f7ff310fa4" translate="yes" xml:space="preserve">
          <source>When true, does not install dependency packages.</source>
          <target state="translated">true 인 경우 종속성 패키지를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3578b18def83dc2da16f045d899e718695cd50d" translate="yes" xml:space="preserve">
          <source>When true, does not install packages for dependencies.</source>
          <target state="translated">true 인 경우 종속성을위한 패키지를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0646ee7c8071d504a9e696eab789659e9bc1e696" translate="yes" xml:space="preserve">
          <source>When true, does not to produce &lt;code&gt;.metadata.json&lt;/code&gt; files. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 &lt;code&gt;.metadata.json&lt;/code&gt; 파일 을 생성하지 않습니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c9ab2f848c6e3f1274c18107fe7541116d4de99" translate="yes" xml:space="preserve">
          <source>When true, does not update &quot;tsconfig.json&quot; to add a path mapping for the new library. The path mapping is needed to use the library in an app, but can be disabled here to simplify development.</source>
          <target state="translated">true 인 경우 &quot;tsconfig.json&quot;을 업데이트하여 새 라이브러리에 대한 경로 맵핑을 추가하지 마십시오. 앱에서 라이브러리를 사용하려면 경로 매핑이 필요하지만 개발을 단순화하기 위해 여기서 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c6bdc8aeeb938a24e46cc58eb1bf0b651c1bf5" translate="yes" xml:space="preserve">
          <source>When true, enable the location strategy that uses the URL fragment instead of the history API.</source>
          <target state="translated">true 인 경우 히스토리 API 대신 URL 단편을 사용하는 위치 전략을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="261fe77e1b294ce4d3a98b31adb772ddea771256" translate="yes" xml:space="preserve">
          <source>When true, enables use of the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, which was deprecated in Angular 4.0, in favor of &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; (to avoid colliding with the DOM's element of the same name). Default is false. Might be required by some third-party Angular libraries.</source>
          <target state="translated">true이면 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 에 찬성하여 Angular 4.0에서 사용되지 않는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 사용할 수 있습니다 (같은 이름의 DOM 요소와 충돌하지 않기 위해). 기본값은 false입니다. 일부 타사 Angular 라이브러리에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0d541d696d1f15840d7575ea4f510c48c941cb" translate="yes" xml:space="preserve">
          <source>When true, forces overwriting of existing files.</source>
          <target state="translated">true 인 경우 기존 파일을 강제로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1aaf874ced3ebb154b21f8167d3778c1794023b3" translate="yes" xml:space="preserve">
          <source>When true, generate all possible files even if they are empty. Default is false. Used by the Bazel build rules to simplify how Bazel rules track file dependencies. Do not use this option outside of the Bazel rules.</source>
          <target state="translated">true 인 경우 가능한 모든 파일이 비어 있어도 생성하십시오. 기본값은 false입니다. Bazel 규칙이 파일 종속성을 추적하는 방법을 단순화하기 위해 Bazel 빌드 규칙에서 사용됩니다. Bazel 규칙 외부에서이 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5b7e7bf350c9fcf27596aa20973b3db4fd6e8bb1" translate="yes" xml:space="preserve">
          <source>When true, generates a flat module index of the given file name and the corresponding flat module metadata. Use to create flat modules that are packaged similarly to &lt;code&gt;@angular/core&lt;/code&gt; and &lt;code&gt;@angular/common&lt;/code&gt;. When this option is used, the &lt;code&gt;package.json&lt;/code&gt; for the library should refer to the generated flat module index instead of the library index file.</source>
          <target state="translated">true 인 경우 지정된 파일 이름의 플랫 모듈 색인 및 해당 플랫 모듈 메타 데이터를 생성합니다. &lt;code&gt;@angular/core&lt;/code&gt; 및 &lt;code&gt;@angular/common&lt;/code&gt; 과 유사하게 패키지 된 플랫 모듈을 작성하는 데 사용하십시오 . 이 옵션을 사용 하는 경우 라이브러리 의 &lt;code&gt;package.json&lt;/code&gt; 은 라이브러리 색인 파일 대신 생성 된 플랫 모듈 색인을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b819323f8f18793bab01506d1b5f14bbec5acf" translate="yes" xml:space="preserve">
          <source>When true, generates a routing module for the initial project.</source>
          <target state="translated">true 인 경우 초기 프로젝트에 대한 라우팅 모듈을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ae14fe320ea896a875f632dbc4bff5abbda0c2a2" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the component TS file. By default, an external styles file is created and referenced in the component TS file.</source>
          <target state="translated">true 인 경우 구성 요소 TS 파일에 스타일을 인라인으로 포함시킵니다. 기본적으로 외부 스타일 파일은 구성 요소 TS 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3beaf924cf679384a2ed4d3854a933a4318a5b" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the component.ts file. Only CSS styles can be included inline. By default, an external styles file is created and referenced in the component.ts file.</source>
          <target state="translated">true 인 경우 component.ts 파일에 스타일을 인라인으로 포함시킵니다. CSS 스타일 만 인라인으로 포함 할 수 있습니다. 기본적으로 외부 스타일 파일이 component.ts 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc4893016b862f1f6cb51410f367ec8369a5e97" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the root component.ts file. Only CSS styles can be included inline. Default is false, meaning that an external styles file is created and referenced in the root component.ts file.</source>
          <target state="translated">true 인 경우 루트 component.ts 파일에 스타일을 인라인으로 포함합니다. CSS 스타일 만 인라인으로 포함 할 수 있습니다. 기본값은 false입니다. 이는 외부 스타일 파일이 작성되어 루트 component.ts 파일에서 참조됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="33247607dda0b14efd7380854b7d1b95cb8b707e" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the component TS file. By default, an external template file is created and referenced in the component TS file.</source>
          <target state="translated">true 인 경우 구성 요소 TS 파일에 템플리트 인라인을 포함시킵니다. 기본적으로 외부 템플리트 파일은 구성 요소 TS 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="d5899d892e6bf561e02447910478d247955babab" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the component.ts file. By default, an external template file is created and referenced in the component.ts file.</source>
          <target state="translated">true 인 경우 component.ts 파일에 인라인 템플리트를 포함시킵니다. 기본적으로 외부 템플리트 파일이 component.ts 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddaf69f17ee1d461ed6364788294b2a4b709ebc" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the root component.ts file. Default is false, meaning that an external template file is created and referenced in the root component.ts file.</source>
          <target state="translated">true 인 경우 루트 component.ts 파일에 템플리트를 인라인으로 포함합니다. 기본값은 false입니다. 이는 외부 component 파일이 루트 component.ts 파일에서 작성되고 참조됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9fe87a52ceeabbe44e5c515a3228147cbc64b6f3" translate="yes" xml:space="preserve">
          <source>When true, injector returns an array of instances. This is useful to allow multiple providers spread across many files to provide configuration information to a common token.</source>
          <target state="translated">true 인 경우 인젝터는 인스턴스 배열을 리턴합니다. 이는 여러 공급자가 여러 파일에 분산되어 구성 정보를 공통 토큰에 제공 할 수 있도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f2bf503a52e77886a9df9b3b721629b7bdd83f5d" translate="yes" xml:space="preserve">
          <source>When true, log all internal navigation events to the console. Use for debugging.</source>
          <target state="translated">true 인 경우 모든 내부 탐색 이벤트를 콘솔에 로그하십시오. 디버깅에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ba98b8ba818a019d7726ea3cd743749164694e0" translate="yes" xml:space="preserve">
          <source>When true, navigates while replacing the current state in history.</source>
          <target state="translated">true 인 경우 히스토리에서 현재 상태를 바꾸면서 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="100b728dbc5957ef91ab9a8121d4653d7ee51209" translate="yes" xml:space="preserve">
          <source>When true, navigates without pushing a new state into history.</source>
          <target state="translated">true 인 경우 새로운 상태를 히스토리로 푸시하지 않고 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="008db015d7015b6513b946d13e89a45905cf3dd3" translate="yes" xml:space="preserve">
          <source>When true, preserves the URL fragment for the next navigation</source>
          <target state="translated">true 인 경우 다음 탐색을 위해 URL 조각을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e7053f3ec9579533ad57553df2fc44aae15cfd47" translate="yes" xml:space="preserve">
          <source>When true, prints extra information while compiling templates. Default is false.</source>
          <target state="translated">true 인 경우 템플릿을 컴파일하는 동안 추가 정보를 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="470599a91818785c5ee58a0f113cae7c96500252" translate="yes" xml:space="preserve">
          <source>When true, replaces the &lt;code&gt;templateUrl&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; property in all &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorators with inlined contents in &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;styles&lt;/code&gt; properties.</source>
          <target state="translated">true 인 경우 모든 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터 의 &lt;code&gt;templateUrl&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 속성 을 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;styles&lt;/code&gt; 속성의 인라인 된 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="1a4f8c074303da2d063c77492f8e15e05b86f00c" translate="yes" xml:space="preserve">
          <source>When true, reports an error to the &lt;code&gt;.metadata.json&lt;/code&gt; file if &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Default is false. Use only when &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is false and &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; is true.</source>
          <target state="translated">true 인 경우 &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;.metadata.json&lt;/code&gt; 파일에 오류를보고합니다 . 기본값은 false입니다. &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 가 false이고 &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; 이 true 인 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fee2c0f9c227cd936e7e0ec7fde35afd7a82fa14" translate="yes" xml:space="preserve">
          <source>When true, runs through and reports activity without writing out results.</source>
          <target state="translated">true 인 경우 결과를 쓰지 않고 활동을보고합니다.</target>
        </trans-unit>
        <trans-unit id="248e093ad4093bf849e9a2bb8ea6c61115311429" translate="yes" xml:space="preserve">
          <source>When true, searches all of angular.io. Otherwise, searches only API reference documentation.</source>
          <target state="translated">true이면 angular.io를 모두 검색합니다. 그렇지 않으면 API 참조 문서 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d2052aabfdb00eb60b3def41e228c021090d18cd" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this component.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 구성 요소를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="474f66dc7056c6ae634ff04631017e86490c737b" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this directive.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 지시문을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="89179c30c022a69730027b86caf1462ba77a87db" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this pipe.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 파이프를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="04e0e74efef0d3f502332b17196bd16fef5f0f39" translate="yes" xml:space="preserve">
          <source>When true, the new component is the entry component of the declaring NgModule.</source>
          <target state="translated">참이면 새로운 컴포넌트는 NgModule 선언의 엔트리 컴포넌트입니다.</target>
        </trans-unit>
        <trans-unit id="6fbefb81d5660c920378ce16f4fcf3f36378b0ac" translate="yes" xml:space="preserve">
          <source>When true, the pipe is pure, meaning that the &lt;code&gt;transform()&lt;/code&gt; method is invoked only when its input arguments change. Pipes are pure by default.</source>
          <target state="translated">true 인 경우 파이프가 순수 하므로 입력 인수가 변경 될 때만 &lt;code&gt;transform()&lt;/code&gt; 메소드가 호출됩니다. 파이프는 기본적으로 순수합니다.</target>
        </trans-unit>
        <trans-unit id="56b0467d9b50fc15e1b147ea8d738c249762a269" translate="yes" xml:space="preserve">
          <source>When true, the special animation control binding &lt;code&gt;@.disabled&lt;/code&gt; binding prevents all animations from rendering. Place the &lt;code&gt;@.disabled&lt;/code&gt; binding on an element to disable animations on the element itself, as well as any inner animation triggers within the element.</source>
          <target state="translated">true 인 경우 특수 애니메이션 컨트롤 바인딩 &lt;code&gt;@.disabled&lt;/code&gt; 바인딩은 모든 애니메이션이 렌더링되지 않도록합니다. 장소 &lt;code&gt;@.disabled&lt;/code&gt; 소자 자체 비활성화 애니메이션뿐만 아니라, 소자 내의 내부 애니메이션을 트리거 요소에 바인딩.</target>
        </trans-unit>
        <trans-unit id="685f4a008223a0507d20fd336655976d7b7efaea" translate="yes" xml:space="preserve">
          <source>When true, use &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle&lt;/a&gt; to annotate the emitted JavaScript with &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc&lt;/a&gt; comments needed by the &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure Compiler&lt;/a&gt;. Default is false.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle&lt;/a&gt; 을 사용 하여 &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure Compiler에&lt;/a&gt; 필요한 &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc&lt;/a&gt; 주석으로 생성 된 JavaScript에 주석을 답니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8fc2c813522ec25fd67580fe8ed8634f057ad051" translate="yes" xml:space="preserve">
          <source>When two imported modules, loaded at the same time, list a provider with the same token, the second module's provider &quot;wins&quot;. That's because both providers are added to the same injector.</source>
          <target state="translated">가져온 두 개의 모듈이 동시에로드되면 동일한 토큰을 가진 공급자를 나열하면 두 번째 모듈의 공급자가 &quot;승리&quot;합니다. 두 공급자가 동일한 인젝터에 추가 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8a38590f055a7be9417ecb7107a61245f38e62ba" translate="yes" xml:space="preserve">
          <source>When updating the value for a form group instance that contains multiple controls, you may only want to update parts of the model. This section covers how to update specific parts of a form control data model.</source>
          <target state="translated">여러 컨트롤이 포함 된 양식 그룹 인스턴스의 값을 업데이트 할 때 모델의 일부만 업데이트 할 수 있습니다. 이 섹션에서는 폼 컨트롤 데이터 모델의 특정 부분을 업데이트하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0cb80c294f2ac7a6f549a1f6b747ec2a760b7c8e" translate="yes" xml:space="preserve">
          <source>When users click a &lt;em&gt;deep link&lt;/em&gt; in an email, open the detail view for a particular hero.</source>
          <target state="translated">사용자 가 이메일에서 &lt;em&gt;딥 링크&lt;/em&gt; 를 클릭 하면 특정 영웅에 대한 상세보기를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="06df6a1b0b43e2a627825e02e4d731eb142a9abd" translate="yes" xml:space="preserve">
          <source>When users click a hero name in either view, navigate to a detail view of the selected hero.</source>
          <target state="translated">사용자가 어느보기에서든 영웅 이름을 클릭하면 선택한 영웅의 상세보기로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d2720a13b038e3604df3e775da3153607bd18d08" translate="yes" xml:space="preserve">
          <source>When users refresh the application, they see the latest fully cached version. New tabs load the latest cached code.</source>
          <target state="translated">사용자가 응용 프로그램을 새로 고치면 완전히 캐시 된 최신 버전이 표시됩니다. 새 탭은 최신 캐시 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="89ee168cd559f7f8ec103bc580870b5f544559ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../core/platformref#bootstrapmodule&quot;&gt;`bootstrapModule()`&lt;/a&gt; or &lt;a href=&quot;../../core/platformref#bootstrapmodulefactory&quot;&gt;`bootstrapModuleFactory()`&lt;/a&gt; to bootstrap the downgraded modules, each one is considered a &quot;root&quot; module. As a consequence, a new instance will be created for every injectable provided in &lt;code&gt;&quot;root&quot;&lt;/code&gt; (via &lt;a href=&quot;../../core/injectable#providedIn&quot;&gt;`providedIn`&lt;/a&gt;). If this is not your intention, you can have a shared module (that will act as act as the &quot;root&quot; module) and create all downgraded modules using that module's injector:</source>
          <target state="translated">사용시 &lt;a href=&quot;../../core/platformref#bootstrapmodule&quot;&gt;`bootstrapModule을 ()`&lt;/a&gt; 또는 &lt;a href=&quot;../../core/platformref#bootstrapmodulefactory&quot;&gt;`bootstrapModuleFactory () '&lt;/a&gt; 각각은 &quot;루트&quot;모듈로 간주되며, 다운 그레이드 모듈 부트 스트랩. 결과적으로 &lt;code&gt;&quot;root&quot;&lt;/code&gt; 로 제공되는 모든 인젝터 블에 대해 &lt;a href=&quot;../../core/injectable#providedIn&quot;&gt;`providedIn`을&lt;/a&gt; 통해 새로운 인스턴스가 생성 됩니다 . 이것이 의도가 아닌 경우, 공유 모듈 ( &quot;루트&quot;모듈로 작동 할 것)을 갖고 해당 모듈의 인젝터를 사용하여 다운 그레이드 된 모든 모듈을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ded6d3e9bc80e46e3525defd91a7c6252307962" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;HttpClient#request()&lt;/code&gt;&lt;/a&gt; with an HTTP method, configure with &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;observe: 'events'&lt;/code&gt;&lt;/a&gt; to see all events, including the progress of transfers.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;HttpClient#request()&lt;/code&gt; &lt;/a&gt; 과 HTTP 방식으로, 구성 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;observe: 'events'&lt;/code&gt; &lt;/a&gt; 전송의 진행을 포함하여 모든 이벤트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e9cb3c6b273bb12f381bfd95b5afdab0eb5729" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;, downgraded injectables will not be available until the Angular module that provides them is instantiated. In order to be safe, you need to ensure that the downgraded injectables are not used anywhere &lt;em&gt;outside&lt;/em&gt; the part of the app where it is guaranteed that their module has been instantiated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용하는 경우 다운 그레이드 된 인젝터 블은이를 제공하는 Angular 모듈이 인스턴스화 될 때까지 사용할 수 없습니다. 안전을 위해, 다운 그레이드 된 인젝터 블이 앱의 &lt;em&gt;외부&lt;/em&gt; 에서 모듈이 인스턴스화되었다는 보장 이없는 곳에서 사용되지 않도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75f082f4a2a9292bee0a6ec7fcdcf08c245efeae" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;, your code must be prepared for a null value. If you don't register a logger provider anywhere, the injector sets the value of &lt;code&gt;logger&lt;/code&gt; to null.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 사용할 때 코드는 null 값을 준비해야합니다. 로거 공급자를 어디에도 등록하지 않으면 인젝터가 &lt;code&gt;logger&lt;/code&gt; 값 을 null로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="20476825f82847cd1a9f8b625992073f31914a1b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;bypassSecurityTrust...&lt;/code&gt;, make sure to call the method as early as possible and as close as possible to the source of the value, to make it easy to verify no security bug is created by its use.</source>
          <target state="translated">&lt;code&gt;bypassSecurityTrust...&lt;/code&gt; 사용할 때는 가능한 빨리 값의 소스에 메소드를 호출하여 사용으로 보안 버그가 작성되지 않았는지 쉽게 확인할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="1b0737e35a4e2a89a802c7501f9bcde999f119f8" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; to navigate instead of the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service, you'd use the &lt;em&gt;same&lt;/em&gt; link parameters array, but you wouldn't provide the object with the &lt;code&gt;&lt;a href=&quot;../api/router/navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; property. The &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; is implicit in a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 대신 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 를 사용하여 탐색 할 때 &lt;em&gt;동일한&lt;/em&gt; 링크 매개 변수 배열을 사용하지만 객체에 &lt;code&gt;&lt;a href=&quot;../api/router/navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; 속성을 제공하지는 않습니다 . &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 는 A의 암시이다 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 의 지시어.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1b489e199dd0f47c8d42b6e961935b6f956c657" translate="yes" xml:space="preserve">
          <source>When using absolute redirects, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; will use the query parameters and the fragment from the redirectTo in the route config.</source>
          <target state="translated">절대 리디렉션 을 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 경로 구성에서 redirectTo의 쿼리 매개 변수와 조각을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="26ed9b82d17457df64013b9eb1fbbaccf7274474" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;intervalTimer()&lt;/code&gt; such as &lt;code&gt;setInterval()&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt;, remember to cancel the timer with &lt;code&gt;clearInterval()&lt;/code&gt; after the test, otherwise the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; never ends.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;intervalTimer()&lt;/code&gt; 와 같은 &lt;code&gt;setInterval()&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 와 타이머 취소 기억 &lt;code&gt;clearInterval()&lt;/code&gt; , 시험 후를 달리 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 결코 끝.</target>
        </trans-unit>
        <trans-unit id="134ada82c1bf109630654ad3274d0beaed098194" translate="yes" xml:space="preserve">
          <source>When using developer tools, the service worker is kept running in the background and never restarts. This can cause behavior with Dev Tools open to differ from behavior a user might experience.</source>
          <target state="translated">개발자 도구를 사용할 때 서비스 워커는 백그라운드에서 계속 실행되며 다시 시작되지 않습니다. 이로 인해 개발자 도구가 열려있는 동작이 사용자가 경험할 수있는 동작과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d7701f04dbf3278e6bca7d61dec82d10b279c4" translate="yes" xml:space="preserve">
          <source>When using emulated view encapsulation, Angular preprocesses all component styles so that they approximate the standard shadow CSS scoping rules.</source>
          <target state="translated">에뮬레이트 된 뷰 캡슐화를 사용하는 경우 Angular는 모든 구성 요소 스타일을 표준 그림자 CSS 범위 지정 규칙에 근접하도록 사전 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f476c990cc992dd16e94e4d7fcc49cfd01a3387d" translate="yes" xml:space="preserve">
          <source>When using hidden source maps, source maps will not be referenced in the bundle. These are useful if you only want source maps to map error stack traces in error reporting tools, but don't want to expose your source maps in the browser developer tools.</source>
          <target state="translated">숨겨진 소스 맵을 사용하는 경우 번들에서 소스 맵이 참조되지 않습니다. 이 기능은 오류보고 도구에서 소스 맵만 오류 스택 추적을 매핑하도록하지만 브라우저 개발자 도구에서 소스 맵을 노출하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="054db0ee1823c84752e38fc7a84cd6430df5dfe9" translate="yes" xml:space="preserve">
          <source>When using reactive forms:</source>
          <target state="translated">반응 형을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a828cec6b58e6cb53d2d46a10e8a8e3c000ea7e3" translate="yes" xml:space="preserve">
          <source>When using relative redirects, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; use the query params and the fragment from the source URL.</source>
          <target state="translated">상대 리디렉션을 사용할 때 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 쿼리 매개 변수와 소스 URL의 조각을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4bf6376b9afea8589f45d2366477e10bd15c8b4c" translate="yes" xml:space="preserve">
          <source>When using template expressions follow these guidelines:</source>
          <target state="translated">템플릿 표현식을 사용하는 경우 다음 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="fd4419420c68cdc2d776a0c6bc7ea6c5c98b6a97" translate="yes" xml:space="preserve">
          <source>When using template-driven forms:</source>
          <target state="translated">템플릿 기반 양식을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="bb75301a3f57d2766a42cb47b657dd6174d1abe3" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags, you'll also need to supply a &lt;code&gt;name&lt;/code&gt; attribute so that the control can be registered with the parent form under that name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 내 에서 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용하는 경우 해당 이름 아래의 부모 양식으로 컨트롤을 등록 할 수 있도록 &lt;code&gt;name&lt;/code&gt; 속성 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffcf1c257cc809ebc12f8b82bc6e12b17f71b98" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;controller as&lt;/code&gt; syntax, the binding is prefixed with the controller alias (&lt;code&gt;vm&lt;/code&gt; or &lt;code&gt;$ctrl&lt;/code&gt;) because you have to be specific about the source of the binding.</source>
          <target state="translated">&lt;code&gt;controller as&lt;/code&gt; 구문 으로 사용하는 경우 바인딩 소스를 구체적으로 지정해야하기 때문에 바인딩에 컨트롤러 별칭 ( &lt;code&gt;vm&lt;/code&gt; 또는 &lt;code&gt;$ctrl&lt;/code&gt; ) 이 접두어로 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="c56383a8e88adb805d2997bbc9ee6587fb9288df" translate="yes" xml:space="preserve">
          <source>When using the component from AngularJS, you can supply contents for it. Just like they would be transcluded in AngularJS, they get projected to the location of the &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; tag in Angular:</source>
          <target state="translated">AngularJS에서 컴포넌트를 사용할 때 컨텐츠를 제공 할 수 있습니다. AngularJS에서 변환되는 것처럼 Angular에서 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 태그 의 위치에 투영됩니다 .</target>
        </trans-unit>
        <trans-unit id="af40b2a4b9fbeccafb0fb2865807c495201f126f" translate="yes" xml:space="preserve">
          <source>When using the shorthand syntax, Angular allows only &lt;a href=&quot;../../guide/structural-directives#one-structural-directive-per-host-element&quot;&gt;one structural directive on an element&lt;/a&gt;. If you want to iterate conditionally, for example, put the &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; on a container element that wraps the &lt;code&gt;*&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; element. For futher discussion, see &lt;a href=&quot;../../guide/structural-directives#one-per-element&quot;&gt;Structural Directives&lt;/a&gt;.</source>
          <target state="translated">속기 구문을 사용할 때 Angular는 &lt;a href=&quot;../../guide/structural-directives#one-structural-directive-per-host-element&quot;&gt;요소에 하나의 구조적 지시문&lt;/a&gt; 만 허용합니다 . 조건부 반복하려는 경우, 예를 들어, 넣어 &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 을 감쌈 컨테이너 요소에 &lt;code&gt;*&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 요소를. 추가 설명은 &lt;a href=&quot;../../guide/structural-directives#one-per-element&quot;&gt;구조 지시문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6535dd674dcfb46d5113fb884e93a5283000217b" translate="yes" xml:space="preserve">
          <source>When would I put specs in a test folder?</source>
          <target state="translated">언제 테스트 폴더에 사양을 넣을까요?</target>
        </trans-unit>
        <trans-unit id="1c89837031479519507a2b713b0588a162366ed7" translate="yes" xml:space="preserve">
          <source>When writing a binding, be aware of a template statement's &lt;strong&gt;execution context&lt;/strong&gt;. The identifiers in a template statement belong to a specific context object, usually the Angular component controlling the template. The example above shows a single line of HTML, but that HTML belongs to a larger component:</source>
          <target state="translated">바인딩을 작성할 때 템플릿 문의 &lt;strong&gt;실행 컨텍스트를&lt;/strong&gt; 알고 있어야 합니다. 템플릿 문의 식별자는 특정 컨텍스트 객체, 일반적으로 템플릿을 제어하는 ​​각도 구성 요소에 속합니다. 위의 예제는 한 줄의 HTML을 보여 주지만 HTML은 더 큰 구성 요소에 속합니다.</target>
        </trans-unit>
        <trans-unit id="0f96cd01fd00c2449a0dbebceeb658bd4c59c3e1" translate="yes" xml:space="preserve">
          <source>When you add a hero to the list of heroes, it appears to fly onto the page from the left.</source>
          <target state="translated">영웅 목록에 영웅을 추가하면 왼쪽에서 페이지로 이동하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="482aa2abe869c9716a8cb6d5ccd25b994760f22c" translate="yes" xml:space="preserve">
          <source>When you add a package with deployment capability, it'll automatically update your workspace configuration (&lt;code&gt;angular.json&lt;/code&gt; file) with a &lt;code&gt;deploy&lt;/code&gt; section for the selected project. You can then use the &lt;code&gt;ng deploy&lt;/code&gt; command to deploy that project.</source>
          <target state="translated">배포 기능이있는 패키지를 추가 하면 선택한 프로젝트 의 &lt;code&gt;deploy&lt;/code&gt; 섹션으로 작업 영역 구성 ( &lt;code&gt;angular.json&lt;/code&gt; 파일) 이 자동으로 업데이트됩니다 . 그런 다음 &lt;code&gt;ng deploy&lt;/code&gt; 명령을 사용하여 해당 프로젝트를 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2441d7ee90ea32ef89ecf67cc9c5bacf216961" translate="yes" xml:space="preserve">
          <source>When you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its &lt;code&gt;status&lt;/code&gt; property.</source>
          <target state="translated">양식 컨트롤에 필수 필드를 추가하면 초기 상태가 유효하지 않습니다. 이 유효하지 않은 상태는 상위 양식 그룹 요소로 전파되어 상태를 유효하지 않게합니다. &lt;code&gt;status&lt;/code&gt; 속성을 통해 양식 그룹 인스턴스의 현재 상태에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="72131c2667f7d78aa1a158277222438a08f970ea" translate="yes" xml:space="preserve">
          <source>When you add a schematic to the collection, you have to point to it in the collection's schema, and provide configuration files to define options that a user can pass to the command.</source>
          <target state="translated">컬렉션에 회로도를 추가 할 때 컬렉션 스키마에서 회로도를 가리키고 사용자가 명령에 전달할 수있는 옵션을 정의하는 구성 파일을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b5fd936cf7003790ec725548e5e7c1c4a0a8937" translate="yes" xml:space="preserve">
          <source>When you add a service provider to the root application injector, it&amp;rsquo;s available throughout the app. Additionally, these providers are also available to all the classes in the app as long they have the lookup token.</source>
          <target state="translated">루트 응용 프로그램 인젝터에 서비스 공급자를 추가하면 앱 전체에서 사용할 수 있습니다. 또한 이러한 공급자는 조회 토큰이있는 한 앱의 모든 클래스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="792a549ee7899276b88f55470bc47a22c686cdb5" translate="yes" xml:space="preserve">
          <source>When you add or remove a validator at run time, you must call &lt;code&gt;&lt;a href=&quot;abstractcontrol#updateValueAndValidity&quot;&gt;updateValueAndValidity()&lt;/a&gt;&lt;/code&gt; for the new validation to take effect.</source>
          <target state="translated">런타임시 유효성 검사기를 추가하거나 제거 할 때 새 유효성 검사를 적용하려면 &lt;code&gt;&lt;a href=&quot;abstractcontrol#updateValueAndValidity&quot;&gt;updateValueAndValidity()&lt;/a&gt;&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7cbfc37168ba6757c88e3fb4728e2529d6a7c3c" translate="yes" xml:space="preserve">
          <source>When you add the &lt;code&gt;disabled&lt;/code&gt;&lt;em&gt;attribute&lt;/em&gt;, its presence alone initializes the button's &lt;code&gt;disabled&lt;/code&gt;&lt;em&gt;property&lt;/em&gt; to &lt;code&gt;true&lt;/code&gt; so the button is disabled.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; &lt;em&gt;속성&lt;/em&gt; 을 추가하면 해당 &lt;em&gt;속성&lt;/em&gt; 만으로도 버튼의 &lt;code&gt;disabled&lt;/code&gt; &lt;em&gt;속성&lt;/em&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 초기화 되어 버튼이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a5c3f1765a8d85f609278eb91d784b7c5f3577" translate="yes" xml:space="preserve">
          <source>When you are ready to deploy your Angular application to a remote server, you have various options for deployment.</source>
          <target state="translated">Angular 응용 프로그램을 원격 서버에 배포 할 준비가되면 다양한 배포 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b03ce57cce7fb1d00de43901f7939bfd562588" translate="yes" xml:space="preserve">
          <source>When you are using a downgraded Angular component from an AngularJS template, the need may arise to &lt;em&gt;transclude&lt;/em&gt; some content into it. This is also possible. While there is no such thing as transclusion in Angular, there is a very similar concept called &lt;em&gt;content projection&lt;/em&gt;. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; is able to make these two features interoperate.</source>
          <target state="translated">AngularJS 템플릿에서 다운 그레이드 된 Angular 구성 요소를 사용하는 경우 일부 컨텐츠 를 &lt;em&gt;포함&lt;/em&gt; 해야 할 수 있습니다 . 이것도 가능합니다. Angular에는 transclusion과 같은 것이 없지만 &lt;em&gt;content projection&lt;/em&gt; 이라는 매우 유사한 개념이 &lt;em&gt;있습니다&lt;/em&gt; . &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; 은이 두 기능을 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d88d2533db99d9ce2333dbaed8801d8f09a063" translate="yes" xml:space="preserve">
          <source>When you bootstrap with the &lt;code&gt;AppComponent&lt;/code&gt; class (in &lt;code&gt;main.ts&lt;/code&gt;), Angular looks for a &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; in the &lt;code&gt;index.html&lt;/code&gt;, finds it, instantiates an instance of &lt;code&gt;AppComponent&lt;/code&gt;, and renders it inside the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; 클래스 ( &lt;code&gt;main.ts&lt;/code&gt; )로 부트 스트랩하면 Angular는 &lt;code&gt;index.html&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 를 찾아서 찾은 다음 &lt;code&gt;AppComponent&lt;/code&gt; 인스턴스를 인스턴스화 하여 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 태그 안에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="45bcb2f61ee4422957ba07b063ee711b3fe965bf" translate="yes" xml:space="preserve">
          <source>When you break application code down into one component per file, you often end up with a project structure with a large number of relatively small files. This is a much neater way to organize things than a small number of large files, but it doesn't work that well if you have to load all those files to the HTML page with &amp;lt;script&amp;gt; tags. Especially when you also have to maintain those tags in the correct order. That's why it's a good idea to start using a &lt;em&gt;module loader&lt;/em&gt;.</source>
          <target state="translated">응용 프로그램 코드를 파일 당 하나의 구성 요소로 나눌 때 종종 상대적으로 작은 파일 수가 많은 프로젝트 구조가 생깁니다. 이 방법은 적은 수의 큰 파일보다 훨씬 깔끔한 방법이지만 &amp;lt;script&amp;gt; 태그를 사용하여 모든 파일을 HTML 페이지에로드해야하는 경우에는 효과가 없습니다. 특히 해당 태그를 올바른 순서로 유지해야 할 때. 그렇기 때문에 &lt;em&gt;모듈 로더&lt;/em&gt; 사용을 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ce8f1b7eb5f289aae723194ecf63f4999761d3d5" translate="yes" xml:space="preserve">
          <source>When you change the translatable text, the extractor tool generates a new id for that translation unit. You must then update the translation file with the new id.</source>
          <target state="translated">번역 가능한 텍스트를 변경하면 추출기 도구가 해당 번역 단위의 새 ID를 생성합니다. 그런 다음 새 ID로 번역 파일을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f39ca9d36c3ca35868c2a4c88abbba55a005690" translate="yes" xml:space="preserve">
          <source>When you click a different hero name, the read-only mini detail beneath the list reflects the new choice.</source>
          <target state="translated">다른 영웅 이름을 클릭하면 목록 아래의 읽기 전용 미니 세부 정보가 새로운 선택을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="617f657be9899b52fe5f49ef3b6d85c4d25fd73f" translate="yes" xml:space="preserve">
          <source>When you click the &lt;em&gt;Edit&lt;/em&gt; button, this block disappears and the editable form reappears.</source>
          <target state="translated">&lt;em&gt;편집&lt;/em&gt; 버튼 을 클릭하면 이 블록이 사라지고 편집 가능한 양식이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="37af15b64770c912fc52e08bb3cce469c7b29f47" translate="yes" xml:space="preserve">
          <source>When you click the &lt;em&gt;Submit&lt;/em&gt; button, the &lt;code&gt;submitted&lt;/code&gt; flag becomes true and the form disappears as planned.</source>
          <target state="translated">&lt;em&gt;제출&lt;/em&gt; 단추 를 클릭하면 &lt;em&gt;제출 &lt;/em&gt; &lt;code&gt;submitted&lt;/code&gt; 플래그가 true가되고 양식이 계획대로 사라집니다.</target>
        </trans-unit>
        <trans-unit id="706ebc53dfab50fb06336852da92a5c4919861b5" translate="yes" xml:space="preserve">
          <source>When you configure a budget, the build system warns or reports an error when a given part of the app reaches or exceeds a boundary size that you set.</source>
          <target state="translated">예산을 구성 할 때 앱의 지정된 부분이 설정 한 경계 크기에 도달하거나 초과하면 빌드 시스템에서 오류를 경고하거나보고합니다.</target>
        </trans-unit>
        <trans-unit id="869269037e3115c244f09bd94306aa003338c106" translate="yes" xml:space="preserve">
          <source>When you configure an injector with a provider, you associate that provider with a &lt;a href=&quot;glossary#di-token&quot;&gt;DI token&lt;/a&gt;. The injector maintains an internal &lt;em&gt;token-provider&lt;/em&gt; map that it references when asked for a dependency. The token is the key to the map.</source>
          <target state="translated">인젝터를 제공자와 구성 할 때 해당 제공자를 &lt;a href=&quot;glossary#di-token&quot;&gt;DI 토큰&lt;/a&gt; 과 연관 시키십시오 . 인젝터 는 종속성을 요청할 때 참조 하는 내부 &lt;em&gt;토큰 제공자&lt;/em&gt; 맵을 유지 보수합니다 . 토큰은지도의 열쇠입니다.</target>
        </trans-unit>
        <trans-unit id="bb138bee1b4372f1119c751a572188b350f1deaa" translate="yes" xml:space="preserve">
          <source>When you create a component, it's associated directly with a single view, called the &lt;em&gt;host view&lt;/em&gt;. The host view can be the root of a view hierarchy, which can contain &lt;em&gt;embedded views&lt;/em&gt;, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth.</source>
          <target state="translated">구성 요소를 작성할 때 구성 요소는 &lt;em&gt;호스트보기&lt;/em&gt; 라는 단일보기와 직접 연관됩니다 . 호스트 뷰는 뷰 계층 구조의 루트 일 수 있으며, 여기에는 &lt;em&gt;내장 된 뷰&lt;/em&gt; 가 포함될 수 있으며 ,이 뷰는 다른 구성 요소의 호스트 뷰입니다. 이러한 구성 요소는 동일한 NgModule에 있거나 다른 NgModules에서 가져올 수 있습니다. 트리의 뷰는 깊이에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b86bbfff494f9e2b0676f3988b1ce5be5ce2704e" translate="yes" xml:space="preserve">
          <source>When you create a new blank schematic with the &lt;a href=&quot;schematics-authoring#cli&quot;&gt;Schematics CLI&lt;/a&gt;, the generated entry function is a &lt;em&gt;rule factory&lt;/em&gt;. A &lt;code&gt;RuleFactory&lt;/code&gt; object defines a higher-order function that creates a &lt;code&gt;Rule&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;schematics-authoring#cli&quot;&gt;Schematics CLI&lt;/a&gt; 를 사용하여 새 회로도를 작성 하면 생성 된 입력 기능이 &lt;em&gt;규칙 팩토리&lt;/em&gt; 입니다. &lt;code&gt;RuleFactory&lt;/code&gt; 객체는 생성하는 고차 함수를 정의하는 &lt;code&gt;Rule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77925d78fe0fa613a0f65a6981a75a2da4ed2cd4" translate="yes" xml:space="preserve">
          <source>When you create a project with the &lt;code&gt;ng new&lt;/code&gt; command, a &lt;code&gt;src/polyfills.ts&lt;/code&gt; configuration file is created as part of your project folder. This file incorporates the mandatory and many of the optional polyfills as JavaScript &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;ng new&lt;/code&gt; 명령 으로 프로젝트를 만들면 &lt;code&gt;src/polyfills.ts&lt;/code&gt; 구성 파일이 프로젝트 폴더의 일부로 생성됩니다. 이 파일은 필수 및 많은 선택적 polyfill을 JavaScript &lt;code&gt;import&lt;/code&gt; 문 으로 통합합니다 .</target>
        </trans-unit>
        <trans-unit id="17999f2ec47c4715e77d4f497e7d7048405a374d" translate="yes" xml:space="preserve">
          <source>When you create an Angular library, you can provide and package it with schematics that integrate it with the Angular CLI. With your schematics, your users can use &lt;code&gt;ng add&lt;/code&gt; to install an initial version of your library, &lt;code&gt;ng generate&lt;/code&gt; to create artifacts defined in your library, and &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; to adjust their project for a new version of your library that introduces breaking changes.</source>
          <target state="translated">Angular 라이브러리를 작성할 때 Angular CLI와 통합하는 회로도를 제공하고 패키지화 할 수 있습니다. 회로도를 통해 사용자는 &lt;code&gt;ng add&lt;/code&gt; 를 사용 하여 라이브러리의 초기 버전을 설치하고, &lt;code&gt;ng generate&lt;/code&gt; 를 사용하여 라이브러리에 정의 된 아티팩트를 작성하고, &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; 를 사용하여 새로운 버전의 라이브러리에 맞게 프로젝트를 조정하여 변경 사항을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed0a480cce150ae491407a6f681a39b6dcf0a9e" translate="yes" xml:space="preserve">
          <source>When you define an environment variable &lt;code&gt;http_proxy&lt;/code&gt; or &lt;code&gt;HTTP_PROXY&lt;/code&gt;, an agent is automatically added to pass calls through your corporate proxy when running &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;http_proxy&lt;/code&gt; 또는 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 를 정의하면 &lt;code&gt;npm start&lt;/code&gt; 를 실행할 때 회사 프록시를 통해 호출을 전달하도록 에이전트가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e26780ada0ccc3b637f4b01f21aad05ca8123bc7" translate="yes" xml:space="preserve">
          <source>When you do, set the &lt;code&gt;class&lt;/code&gt; to &lt;code&gt;avoid&lt;/code&gt;. The code snippet will be framed in bright red to grab the reader's attention.</source>
          <target state="translated">그렇게 할 때 &lt;code&gt;class&lt;/code&gt; 를 &lt;code&gt;avoid&lt;/code&gt; 하도록 설정하십시오 . 코드 스 니펫은 독자의주의를 끌기 위해 밝은 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea188763675648ea90f96f233e7a9e4f9446785b" translate="yes" xml:space="preserve">
          <source>When you downgrade an Angular component and then use it from AngularJS, the component's inputs will be watched using AngularJS change detection. When those inputs change, the corresponding properties in the component are set. You can also hook into the changes by implementing the &lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt; interface in the component, just like you could if it hadn't been downgraded.</source>
          <target state="translated">Angular 구성 요소를 다운 그레이드 한 다음 AngularJS에서 사용하면 AngularJS 변경 감지를 사용하여 구성 요소의 입력을 감시합니다. 이러한 입력이 변경되면 구성 요소의 해당 속성이 설정됩니다. 다운 그레이드되지 않은 경우와 마찬가지로 구성 요소에서 &lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt; 인터페이스를 구현하여 변경 사항에 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4453dc4621733c6328eda35ed3ad7fa789798ece" translate="yes" xml:space="preserve">
          <source>When you enable production builds via &lt;code&gt;--prod&lt;/code&gt; command line flag, the runtime production mode is enabled as well.</source>
          <target state="translated">&lt;code&gt;--prod&lt;/code&gt; 명령 줄 플래그 를 통해 프로덕션 빌드를 활성화 하면 런타임 프로덕션 모드도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9b4238aa6d95593d6729819db45182901c2e3e" translate="yes" xml:space="preserve">
          <source>When you generate a library using the CLI (with a command such as &lt;code&gt;ng generate library my-lib&lt;/code&gt;), the generated files go into the projects/ folder of the workspace. For more information about creating your own libraries, see &lt;a href=&quot;creating-libraries&quot;&gt;Creating Libraries&lt;/a&gt;.</source>
          <target state="translated">CLI를 사용하여 라이브러리를 생성 할 때 ( &lt;code&gt;ng generate library my-lib&lt;/code&gt; 와 같은 명령으로 ) 생성 된 파일은 작업 공간의 프로젝트 / 폴더로 이동합니다. 자체 라이브러리 작성에 대한 자세한 정보는 라이브러리 &lt;a href=&quot;creating-libraries&quot;&gt;작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c3de61ed943055bf0458f7d0abfbe8083dac68f" translate="yes" xml:space="preserve">
          <source>When you hide an element, that element and all of its descendants remain in the DOM. All components for those elements stay in memory and Angular may continue to check for changes. You could be holding onto considerable computing resources and degrading performance unnecessarily.</source>
          <target state="translated">요소를 숨기면 해당 요소와 모든 하위 요소가 DOM에 남아 있습니다. 해당 요소의 모든 구성 요소는 메모리에 유지되며 Angular는 계속 변경 사항을 확인할 수 있습니다. 상당한 컴퓨팅 리소스를 보유하고 불필요하게 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410ecc95479ff5928d45d83d664c30ac0fed7800" translate="yes" xml:space="preserve">
          <source>When you import an NgModule, Angular adds the module's service providers (the contents of its &lt;code&gt;providers&lt;/code&gt; list) to the application root injector.</source>
          <target state="translated">NgModule을 가져 오면 Angular는 모듈의 서비스 공급자 ( &lt;code&gt;providers&lt;/code&gt; 목록 의 내용 )를 응용 프로그램 루트 인젝터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d8644a4f230a744f101351dd00d0bf4a1e1125a5" translate="yes" xml:space="preserve">
          <source>When you import something from a library in an Angular app, Angular looks for a mapping between the library name and a location on disk. When you install a library package, the mapping is in the &lt;code&gt;node_modules&lt;/code&gt; folder. When you build your own library, it has to find the mapping in your &lt;code&gt;tsconfig&lt;/code&gt; paths.</source>
          <target state="translated">Angular 앱의 라이브러리에서 무언가를 가져 오면 Angular는 라이브러리 이름과 디스크 위치 간의 매핑을 찾습니다. 라이브러리 패키지를 설치할 때 맵핑은 &lt;code&gt;node_modules&lt;/code&gt; 폴더에 있습니다. 자체 라이브러리를 빌드 할 때 &lt;code&gt;tsconfig&lt;/code&gt; 경로 에서 맵핑을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d0bf5343123ad54489af22b2a94d022755e308e" translate="yes" xml:space="preserve">
          <source>When you internationalize with the AOT compiler, you must pre-build a separate application package for each language and serve the appropriate package based on either server-side language detection or URL parameters.</source>
          <target state="translated">AOT 컴파일러를 사용하여 국제화 할 때는 각 언어마다 별도의 응용 프로그램 패키지를 미리 빌드하고 서버 측 언어 감지 또는 URL 매개 변수를 기반으로 적절한 패키지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="362d06f664aaa8348af755e5fbfb12b4e2256623" translate="yes" xml:space="preserve">
          <source>When you know for certain that a &lt;code&gt;HeroDetailComponent&lt;/code&gt; instance will &lt;em&gt;never, never, ever&lt;/em&gt; be re-used, you can simplify the code with the &lt;em&gt;snapshot&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 인스턴스가 &lt;em&gt;절대&lt;/em&gt; 재사용 &lt;em&gt;되지 않을&lt;/em&gt; 것이라는 것을 확실히 알고 있으면 &lt;em&gt;snapshot으로&lt;/em&gt; 코드를 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5fecd6f95f828bcccda31df86790f8c129c7ea0" translate="yes" xml:space="preserve">
          <source>When you migrate from AngularJS to Angular you will want to move as much responsibility as possible to Angular, so that you can take advantage of new APIs. To help with the transition, Angular provides the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgrademodule&quot;&gt;LocationUpgradeModule&lt;/a&gt;&lt;/code&gt;. This module enables a &lt;em&gt;unified&lt;/em&gt; location service that shifts responsibilities from the AngularJS &lt;code&gt;$location&lt;/code&gt; service to the Angular &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; service.</source>
          <target state="translated">AngularJS에서 Angular로 마이그레이션 할 때 가능한 한 많은 책임을 Angular로 이동하여 새 API를 활용할 수 있습니다. 전환을 돕기 위해 Angular는 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgrademodule&quot;&gt;LocationUpgradeModule&lt;/a&gt;&lt;/code&gt; 을 제공합니다 . 이 모듈은 책임을 AngularJS &lt;code&gt;$location&lt;/code&gt; 서비스에서 Angular &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 서비스 로 전환 하는 &lt;em&gt;통합&lt;/em&gt; 위치 서비스를 가능하게합니다 .</target>
        </trans-unit>
        <trans-unit id="e14e60be15cfb3e29e23e3adf7c79ee29e0d7947" translate="yes" xml:space="preserve">
          <source>When you move the source (inevitable), you remember to move the test.</source>
          <target state="translated">소스를 이동할 때 (필연적) 테스트를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe438ebbcd8a35cf245928a1c983b9efddf4900e" translate="yes" xml:space="preserve">
          <source>When you pass an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; uses it to instantiate the module using &lt;a href=&quot;../api/platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt;'s &lt;a href=&quot;../api/core/platformref#bootstrapModuleFactory&quot;&gt;bootstrapModuleFactory()&lt;/a&gt;, which is compatible with ahead-of-time (AOT) compilation. AOT compilation helps make your apps load faster. For more about AOT and how to create an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt;, see the &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time Compilation&lt;/a&gt; guide.</source>
          <target state="translated">당신이 통과하면 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 를 사용하여 모듈을 인스턴스화하는 데 사용 &lt;a href=&quot;../api/platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt; 의 &lt;a href=&quot;../api/core/platformref#bootstrapModuleFactory&quot;&gt;bootstrapModuleFactory ()&lt;/a&gt; 앞서-의 시간 (AOT) 컴파일과 호환됩니다. AOT 컴파일은 앱을 더 빠르게로드하는 데 도움이됩니다. AOT 및 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; 작성 방법에 대한 자세한 내용은 &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time Compilation&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21d13688782c8b5894b32af1b23cd5c8e43f6163" translate="yes" xml:space="preserve">
          <source>When you pass an array of steps to a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, the steps run sequentially by default. Compare this to the &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; call, which runs animation steps in parallel.</source>
          <target state="translated">단계 배열을 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출에 전달하면 단계가 기본적으로 순차적으로 실행됩니다. 이것을 애니메이션 단계를 병렬로 실행 하는 &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 호출과 비교 하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad1c2e84d6f136b6a8a42ad3ccb44378641d0aa" translate="yes" xml:space="preserve">
          <source>When you pass an interface as a type parameter to the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; method, use the RxJS &lt;code&gt;map&lt;/code&gt; operator to transform the response data as needed by the UI. You can then pass the transformed data to the &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async pipe&lt;/a&gt;.</source>
          <target state="translated">인터페이스를 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 메소드에 유형 매개 변수로 전달할 때 RxJS &lt;code&gt;map&lt;/code&gt; 연산자를 사용 하여 UI에 필요한 응답 데이터를 변환하십시오. 그런 다음 변환 된 데이터를 &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;비동기 파이프&lt;/a&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2307ff4288c2d124a3fdc1efa06e1678b46c8e2" translate="yes" xml:space="preserve">
          <source>When you provide services in a component, that service is available via the &lt;code&gt;ElementInjector&lt;/code&gt; at that component instance. It may also be visible at child component/directives based on visibility rules described in the &lt;a href=&quot;hierarchical-dependency-injection#resolution-rules&quot;&gt;resolution rules&lt;/a&gt; section.</source>
          <target state="translated">컴포넌트에서 서비스를 제공하면 해당 컴포넌트 인스턴스 의 &lt;code&gt;ElementInjector&lt;/code&gt; 를 통해 해당 서비스를 사용할 수 있습니다 . &lt;a href=&quot;hierarchical-dependency-injection#resolution-rules&quot;&gt;해결 규칙&lt;/a&gt; 섹션에 설명 된 가시성 규칙에 따라 하위 구성 요소 / 지시문에서도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56f91c3af039a87e2e5b1894a0d410dde809e81e" translate="yes" xml:space="preserve">
          <source>When you provide services in the component class, services are visible within the &lt;code&gt;ElementInjector&lt;/code&gt; tree relative to where and how you provide those services.</source>
          <target state="translated">컴포넌트 클래스에서 서비스 를 제공하면 서비스를 제공하는 위치 및 방법과 관련 하여 &lt;code&gt;ElementInjector&lt;/code&gt; 트리 내에서 서비스를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8852b03eafeb6d489c8a0d7dc06b14852ad1e11c" translate="yes" xml:space="preserve">
          <source>When you provide the service at the root level, Angular creates a single, shared instance of &lt;code&gt;HeroService&lt;/code&gt; and injects into any class that asks for it. Registering the provider in the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; metadata also allows Angular to optimize an app by removing the service if it turns out not to be used after all.</source>
          <target state="translated">루트 수준에서 서비스를 제공하면 Angular는 하나의 공유 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 생성 하고이를 요청하는 모든 클래스에 주입합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 메타 데이터에 공급자를 등록 하면 Angular는 서비스를 전혀 사용하지 않는 경우 서비스를 제거하여 앱을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f953905bda44980a6a9f0d5b1b3e121019580b78" translate="yes" xml:space="preserve">
          <source>When you provide the service at the root level, Angular creates a single, shared instance of &lt;code&gt;HeroService&lt;/code&gt; and injects it into any class that asks for it. Registering the provider in the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; metadata also allows Angular to optimize an app by removing the service from the compiled app if it isn't used.</source>
          <target state="translated">루트 수준에서 서비스를 제공하면 Angular는 하나의 공유 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 생성하여 이를 요청하는 모든 클래스에 주입합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 메타 데이터에 공급자를 등록 하면 Angular는 컴파일 된 앱이 서비스를 사용하지 않는 경우 서비스를 제거하여 앱을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b343fcf4d13bc8d991f156872899c3099cdb142c" translate="yes" xml:space="preserve">
          <source>When you register a provider at the component level, you get a new instance of the service with each new instance of that component. At the component level, register a service provider in the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; metadata.</source>
          <target state="translated">구성 요소 수준에서 공급자를 등록하면 해당 구성 요소의 새 인스턴스마다 서비스의 새 인스턴스가 제공됩니다. 컴포넌트 레벨에서 서비스 제공자를 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 메타 데이터 의 &lt;code&gt;providers&lt;/code&gt; 특성에 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="46450f6e014a67295680762b08aaaf21e1fc79bc" translate="yes" xml:space="preserve">
          <source>When you register a provider with a &lt;a href=&quot;architecture-modules&quot;&gt;specific NgModule&lt;/a&gt;, the same instance of a service is available to all components in that NgModule. To register at this level, use the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; decorator,</source>
          <target state="translated">&lt;a href=&quot;architecture-modules&quot;&gt;특정 NgModule에&lt;/a&gt; 공급자를 등록하면 해당 NgModule의 모든 구성 요소에서 동일한 서비스 인스턴스를 사용할 수 있습니다. 이 레벨에서 등록하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; () 데코레이터 의 &lt;code&gt;providers&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="162521642a27b1e5827c9301cf0ed78f5244aa15" translate="yes" xml:space="preserve">
          <source>When you remove a hero from the list, it appears to fly out to the right.</source>
          <target state="translated">목록에서 영웅을 제거하면 오른쪽으로 날아가는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="4f1ba5f6a26ffaff14e70574d6d3162b35b43f43" translate="yes" xml:space="preserve">
          <source>When you rename the source file (inevitable), you remember to rename the test file.</source>
          <target state="translated">소스 파일의 이름을 바꿀 때 (필연적) 테스트 파일의 이름을 바꾸는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="76143769b73c5f43fc6f3a3c4f5be082f00a281f" translate="yes" xml:space="preserve">
          <source>When you resolve an instance of &lt;code&gt;Car&lt;/code&gt; at the deepest component (C), its injector produces an instance of &lt;code&gt;Car&lt;/code&gt; resolved by injector (C) with an &lt;code&gt;Engine&lt;/code&gt; resolved by injector (B) and &lt;code&gt;Tires&lt;/code&gt; resolved by the root injector (A).</source>
          <target state="translated">가장 깊은 구성 요소 (C)에서 &lt;code&gt;Car&lt;/code&gt; 인스턴스를 해결하면 인젝터는 인젝터 (B)로 분석 된 &lt;code&gt;Engine&lt;/code&gt; 과 루트 인젝터 (A)로 해결 된 &lt;code&gt;Tires&lt;/code&gt; 로 인젝터 (C)로 해결 된 &lt;code&gt;Car&lt;/code&gt; 인스턴스를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c7af032d22de01c80130fb9a41ddd3718e7e974c" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;ng new my-first-project&lt;/code&gt; a new folder, named &lt;code&gt;my-first-project&lt;/code&gt;, will be created in the current working directory. Since you want to be able to create files inside that folder, make sure you have sufficient rights in the current working directory before running the command.</source>
          <target state="translated">실행할 때 &lt;code&gt;ng new my-first-project&lt;/code&gt; 라는 이름의 새 폴더 &lt;code&gt;my-first-project&lt;/code&gt; 현재 작업 디렉토리에 생성됩니다. 해당 폴더 내에 파일을 작성할 수 있으려면 명령을 실행하기 전에 현재 작업 디렉토리에 대한 충분한 권한이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5ede23bce1607d06e6f4c7d8342b9df484546033" translate="yes" xml:space="preserve">
          <source>When you run this command, the CLI installs the necessary Angular npm packages and other dependencies in a new workspace, with a root-level application named &lt;em&gt;my-project&lt;/em&gt;. The workspace root folder contains various support and configuration files, and a README file with generated descriptive text that you can customize.</source>
          <target state="translated">이 명령을 실행하면 CLI는 루트 레벨 응용 프로그램 &lt;em&gt;my-project를 사용&lt;/em&gt; 하여 필요한 Angular npm 패키지 및 기타 종속성을 새 작업 공간에 설치합니다 . 작업 공간 루트 폴더에는 다양한 지원 및 구성 파일과 사용자 정의 할 수있는 설명 텍스트가있는 README 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f89db8d780edd6ff5fede7d7a2e6d3d19f61f83" translate="yes" xml:space="preserve">
          <source>When you specify a custom id, the extractor tool and compiler generate a translation unit with that custom id.</source>
          <target state="translated">사용자 정의 ID를 지정하면 추출기 도구 및 컴파일러가 해당 사용자 정의 ID로 변환 단위를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ff5318340747063c6cfc4c93e9fb64e1d986e7b" translate="yes" xml:space="preserve">
          <source>When you start to upgrade components and their templates to Angular, you'll make more changes because the E2E tests have matchers that are specific to AngularJS. For PhoneCat you need to make the following changes in order to make things work with Angular:</source>
          <target state="translated">구성 요소 및 해당 템플릿을 Angular로 업그레이드하기 시작하면 E2E 테스트에 AngularJS와 일치하는 일치 항목이 있으므로 더 많은 변경을 수행하게됩니다. PhoneCat의 경우 Angular에서 작동하도록 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6527e816afc32aa43b4cbfafcff471db1bf82256" translate="yes" xml:space="preserve">
          <source>When you trigger a completion list within a template, the editor first parses the template into an HTML &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax tree (AST)&lt;/a&gt;. The Angular compiler interprets that tree to determine the context: which module the template is part of, the current scope, the component selector, and where your cursor is in the template AST. It can then determine the symbols that could potentially be at that position..</source>
          <target state="translated">템플리트 내에서 완료 목록을 트리거하면 편집기는 먼저 템플리트를 HTML &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;추상 구문 트리 (AST)&lt;/a&gt; 로 구문 분석합니다 . Angular 컴파일러는 해당 트리를 해석하여 컨텍스트를 결정합니다. 템플릿이 속한 모듈, 현재 범위, 구성 요소 선택기 및 커서가 템플릿 AST에있는 위치. 그런 다음 해당 위치에있을 수있는 기호를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab73fe04628483ac0b3d2a9834dda0390777b014" translate="yes" xml:space="preserve">
          <source>When you try this,</source>
          <target state="translated">이걸 시도하면</target>
        </trans-unit>
        <trans-unit id="caa532613dfbcc5fb88bd71c451bea3780c7f5bb" translate="yes" xml:space="preserve">
          <source>When you update Angular to a new version, you need to make sure that any libraries you are using are current. If libraries have interdependencies, you might have to update them in a particular order. See the &lt;a href=&quot;https://update.angular.io/&quot;&gt;Angular Update Guide&lt;/a&gt; for help.</source>
          <target state="translated">Angular를 새 버전으로 업데이트 할 때는 사용중인 라이브러리가 최신 버전인지 확인해야합니다. 라이브러리에 상호 종속성이있는 경우 특정 순서로 업데이트해야 할 수 있습니다. 도움이 필요 하면 &lt;a href=&quot;https://update.angular.io/&quot;&gt;Angular Update Guide&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="427748cf35ba8629915556d00d80d9456785d7fd" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;aot-compiler&quot;&gt;AoT compilation&lt;/a&gt;, you can control how your application is compiled by specifying &lt;em&gt;template&lt;/em&gt; compiler options in the &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript configuration file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;aot-compiler&quot;&gt;AoT 컴파일&lt;/a&gt; 을 사용 하는 경우 &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성 파일&lt;/a&gt; 에서 &lt;em&gt;템플릿&lt;/em&gt; 컴파일러 옵션 을 지정하여 애플리케이션 컴파일 방법을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d76d4cdd08e8ca0fc27a2d6c81a99fd7dd8f163" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;, edit these parts of your app:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 을 사용할 때 앱의 다음 부분을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="4580e5ffc3fd526fbaef265fb610c52859c60f63" translate="yes" xml:space="preserve">
          <source>When you use a class this way, it's called a &lt;em&gt;class interface&lt;/em&gt;.</source>
          <target state="translated">이런 방식으로 클래스를 사용하는 경우이를 &lt;em&gt;클래스 인터페이스&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="f94a253b102233220fd281a30bb6f39b56a66d5a" translate="yes" xml:space="preserve">
          <source>When you use an SVG as the template, you are able to use directives and bindings just like with HTML templates. This means that you will be able to dynamically generate interactive graphics.</source>
          <target state="translated">SVG를 템플릿으로 사용하면 HTML 템플릿과 마찬가지로 지시문과 바인딩을 사용할 수 있습니다. 즉, 대화식 그래픽을 동적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5db936a4f10347d77d439673f77743a5c795d4" translate="yes" xml:space="preserve">
          <source>When you use an editor with a language service, the editor starts a separate language-service process and communicates with it through an &lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;, using the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol&lt;/a&gt;. When you type into the editor, the editor sends information to the language-service process to track the state of your project.</source>
          <target state="translated">언어 서비스와 함께 편집기를 사용하는 경우 편집기는 별도의 언어 서비스 프로세스를 시작 하고 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;언어 서버 프로토콜을&lt;/a&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC를&lt;/a&gt; 통해 해당 프로세스와 통신합니다 . 편집기에 입력하면 편집기는 프로젝트의 상태를 추적하기 위해 언어 서비스 프로세스에 정보를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7091693d92ad9fcbdbcc9479803eb8ea1f9c1565" translate="yes" xml:space="preserve">
          <source>When you use ngUpgrade, what you're really doing is &lt;em&gt;running both AngularJS and Angular at the same time&lt;/em&gt;. All Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework. Both of these are the actual, fully featured versions of the frameworks. There is no emulation going on, so you can expect to have all the features and natural behavior of both frameworks.</source>
          <target state="translated">ngUpgrade를 사용할 때 실제로 수행하는 작업은 &lt;em&gt;AngularJS와 Angular를 동시에 실행&lt;/em&gt; 하는 것입니다 . 모든 Angular 코드는 Angular 프레임 워크에서 실행되고 AngularJS 코드는 AngularJS 프레임 워크에서 실행됩니다. 둘 다 프레임 워크의 실제 기능을 갖춘 버전입니다. 에뮬레이션이 진행되지 않으므로 두 프레임 워크의 모든 기능과 자연스러운 동작을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2eec843f1d023d68567197d0f57ed566b9116ea" translate="yes" xml:space="preserve">
          <source>When you use the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt; without the &lt;code&gt;--inline-style&lt;/code&gt; flag, it creates an empty styles file for you and references that file in the component's generated &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inline-style&lt;/code&gt; 플래그 없이 Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 를 사용하면 비어있는 스타일 파일을 작성하고 해당 파일을 컴포넌트의 생성 된 &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 에서 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="247bac8024638798cef5c1812110dc811b6aae31" translate="yes" xml:space="preserve">
          <source>When you use the CLI &lt;code&gt;build&lt;/code&gt; or &lt;code&gt;serve&lt;/code&gt; command to build your application for different locales, change the output path using the &lt;code&gt;--outputPath&lt;/code&gt; command option (along with the i18n-specific command options), so that the translation files are saved to different locations. When you are serving a locale-specific version from a subdirectory, you can also change the base URL used by your app by specifying the &lt;code&gt;--baseHref&lt;/code&gt; option.</source>
          <target state="translated">CLI &lt;code&gt;build&lt;/code&gt; 또는 &lt;code&gt;serve&lt;/code&gt; 명령을 사용하여 다른 로케일에 대한 응용 프로그램을 빌드 할 때 변환 파일이 다른 위치에 저장되도록 &lt;code&gt;--outputPath&lt;/code&gt; 명령 옵션 (i18n 특정 명령 옵션과 함께)을 사용하여 출력 경로를 변경하십시오 . 하위 디렉토리에서 로케일 특정 버전을 제공하는 경우 &lt;code&gt;--baseHref&lt;/code&gt; 옵션 을 지정하여 앱에서 사용하는 기본 URL을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2e97de1383d763b5d6a77c6e6a143039f881b94" translate="yes" xml:space="preserve">
          <source>When you use the Schematics CLI to create a blank schematics project, the new blank schematic is the first member of the collection, and has the same name as the collection. When you add a new named schematic to this collection, it is automatically added to the &lt;code&gt;collection.json&lt;/code&gt; schema.</source>
          <target state="translated">Schematics CLI를 사용하여 빈 회로도 프로젝트를 작성하는 경우 새 빈 회로도는 콜렉션의 첫 번째 구성원이며 콜렉션과 이름이 같습니다. 이 컬렉션에 새로운 명명 된 회로도를 추가하면 자동으로 &lt;code&gt;collection.json&lt;/code&gt; 스키마에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8e927f93087617fa5e2ad0d1654b43c538c0e7e" translate="yes" xml:space="preserve">
          <source>When you use these Angular modules, import them in &lt;code&gt;AppModule&lt;/code&gt;, or your feature module as appropriate, and list them in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;&lt;code&gt;imports&lt;/code&gt; array. For example, in the basic app generated by the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; is the first import at the top of the &lt;code&gt;AppModule&lt;/code&gt;, &lt;code&gt;app.module.ts&lt;/code&gt;.</source>
          <target state="translated">이러한 Angular 모듈을 사용하는 경우 &lt;code&gt;AppModule&lt;/code&gt; 또는 기능 모듈에서 해당 모듈을 &lt;code&gt;imports&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; @ NgModule imports 배열에 나열하십시오. 예를 들어 &lt;a href=&quot;cli&quot;&gt;Angular CLI에&lt;/a&gt; 의해 생성 된 기본 앱 에서 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;AppModule&lt;/code&gt; 맨 위에있는 첫 번째 가져 오기 인 &lt;code&gt;app.module.ts&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="080cd8e0ffd40797678bd6db1b07ecb17508c1bf" translate="yes" xml:space="preserve">
          <source>When you visit &lt;code&gt;http://localhost:4200&lt;/code&gt;, the &lt;code&gt;/heroes&lt;/code&gt; route loads immediately upon launch and the router starts loading the &lt;code&gt;CrisisCenterModule&lt;/code&gt; right after the &lt;code&gt;HeroesModule&lt;/code&gt; loads.</source>
          <target state="translated">당신이 방문 할 때 &lt;code&gt;http://localhost:4200&lt;/code&gt; 의 &lt;code&gt;/heroes&lt;/code&gt; 실행하는 즉시 경로로드와로드 라우터 시작 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 의 사후이 바로 &lt;code&gt;HeroesModule&lt;/code&gt; 의 부하를.</target>
        </trans-unit>
        <trans-unit id="44c77ca06e436ba06a76204c91665ded53e10a97" translate="yes" xml:space="preserve">
          <source>When you want to build reactive forms</source>
          <target state="translated">반응 형 양식을 작성하려는 경우</target>
        </trans-unit>
        <trans-unit id="48f76a44e44194717a9e946c5feb9c2e6b0b52cd" translate="yes" xml:space="preserve">
          <source>When you want to build template driven forms (includes &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">템플릿 기반 양식을 작성하려는 경우 ( &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="4e5214feaf2e0f2b028e9529ca13429a1279a360" translate="yes" xml:space="preserve">
          <source>When you want to run your app in a browser</source>
          <target state="translated">브라우저에서 앱을 실행하려는 경우</target>
        </trans-unit>
        <trans-unit id="79cd32fcf10e349cacf13610bd6576229e1c2cc5" translate="yes" xml:space="preserve">
          <source>When you want to talk to a server</source>
          <target state="translated">서버와 대화하고 싶을 때</target>
        </trans-unit>
        <trans-unit id="9b1b99eea8d22a5434f0d6b37e29a9e079c7a914" translate="yes" xml:space="preserve">
          <source>When you want to use &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;NgFor&lt;/code&gt;</source>
          <target state="translated">사용할 때 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 을 , &lt;code&gt;NgFor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="896f69bcc45a08c492c179d02b221484e8842f42" translate="yes" xml:space="preserve">
          <source>When you want to use &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.forRoot()&lt;/code&gt;, and &lt;code&gt;.forChild()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.forRoot()&lt;/code&gt; 및 &lt;code&gt;.forChild()&lt;/code&gt; 를 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="dfa0b324bbeaa7902d962fb62864b60a9b21dc09" translate="yes" xml:space="preserve">
          <source>When you write a data-binding, you're dealing exclusively with the &lt;em&gt;DOM properties&lt;/em&gt; and &lt;em&gt;events&lt;/em&gt; of the target object.</source>
          <target state="translated">데이터 바인딩을 작성할 때 대상 객체 의 &lt;em&gt;DOM 속성&lt;/em&gt; 및 &lt;em&gt;이벤트&lt;/em&gt; 만 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="4bb0f31a361efec853e39b49bafb65056beed48a" translate="yes" xml:space="preserve">
          <source>When you write your own structural directives, use the following grammar:</source>
          <target state="translated">고유 한 구조적 지시문을 작성할 때는 다음 문법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4e579e2078171bbeaf4e91de26fcbce3bcc959d" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done, users will be able to navigate the app like this:</source>
          <target state="translated">완료되면 사용자는 다음과 같이 앱을 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17951df2c8400929e977efa4744c0c861fc58da2" translate="yes" xml:space="preserve">
          <source>When you're done it looks like this.</source>
          <target state="translated">완료되면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef010cb6e75978e36467b31a7285fb58053efd7b" translate="yes" xml:space="preserve">
          <source>When you're done with this page, the app should look like this live example.</source>
          <target state="translated">이 페이지를 마치면 앱이 실제 예제와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a96be9b1ba1110aa029cf80016d7fb5e9e1068" translate="yes" xml:space="preserve">
          <source>When you're done, it should look like this:</source>
          <target state="translated">완료되면 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="30a40655f733f6e41e3030f2d31ddd6f2dbe644f" translate="yes" xml:space="preserve">
          <source>When you're done, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; template should look like this:</source>
          <target state="translated">완료되면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 템플릿은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ea335dad3c01c816d9ed76f23c43e1124bac391a" translate="yes" xml:space="preserve">
          <source>When you're done, you'll have these &lt;em&gt;hero management&lt;/em&gt; files:</source>
          <target state="translated">완료되면 다음과 같은 &lt;em&gt;영웅 관리&lt;/em&gt; 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="503695908e0b2be5d18ab6d1e3b8706361e129c4" translate="yes" xml:space="preserve">
          <source>When you're familiar with these fundamental building blocks, you can explore them in more detail in the documentation. To learn about more tools and techniques that are available to help you build and deploy Angular applications, see &lt;a href=&quot;architecture-next-steps&quot;&gt;Next steps: tools and techniques&lt;/a&gt;.</source>
          <target state="translated">이러한 기본 구성 요소에 익숙하면 설명서에서이를 자세히 살펴볼 수 있습니다. Angular 응용 프로그램을 구축 및 배포하는 데 사용할 수있는 추가 도구 및 기술에 대한 자세한 내용은 &lt;a href=&quot;architecture-next-steps&quot;&gt;다음 단계 : 도구 및 기술을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0dae56146bb8eee79b34c8c03a03fc066445b7" translate="yes" xml:space="preserve">
          <source>When you're filtering by CSS selector and only testing properties of a browser's &lt;em&gt;native element&lt;/em&gt;, the &lt;code&gt;By.css&lt;/code&gt; approach may be overkill.</source>
          <target state="translated">CSS 선택기로 필터링하고 브라우저 &lt;em&gt;기본 요소&lt;/em&gt; 의 속성 만 테스트하는 경우 &lt;code&gt;By.css&lt;/code&gt; 접근 방식이 과도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6dec613091e0293026f13a73d50239981c86f57" translate="yes" xml:space="preserve">
          <source>When you're ready to activate the marble observables, you tell the &lt;code&gt;TestScheduler&lt;/code&gt; to &lt;em&gt;flush&lt;/em&gt; its queue of prepared tasks like this.</source>
          <target state="translated">대리석 관찰 가능 항목을 활성화 할 준비가되면 &lt;code&gt;TestScheduler&lt;/code&gt; 에게 준비된 작업 대기열 을 &lt;em&gt;플러시&lt;/em&gt; 하도록 지시 합니다 .</target>
        </trans-unit>
        <trans-unit id="7661aa2fca4df31ccc337d89f54c6916141df825" translate="yes" xml:space="preserve">
          <source>When you've defined an animation trigger for a component, you can attach it to an element in that component's template by wrapping the trigger name in brackets and preceding it with an &lt;code&gt;@&lt;/code&gt; symbol. Then, you can bind the trigger to a template expression using standard Angular property binding syntax as shown below, where &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt; is the name of the trigger, and &lt;code&gt;expression&lt;/code&gt; evaluates to a defined animation state.</source>
          <target state="translated">구성 요소에 대한 애니메이션 트리거를 정의한 경우 트리거 이름을 괄호로 묶고 &lt;code&gt;@&lt;/code&gt; 기호를 앞에 붙여 해당 구성 요소의 템플릿에서 요소에 연결할 수 있습니다 . 그런 다음 아래와 같이 표준 Angular 속성 바인딩 구문을 사용하여 트리거를 템플릿 표현식에 바인딩 할 수 있습니다. 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt; 은 트리거의 이름이며 &lt;code&gt;expression&lt;/code&gt; 은 정의 된 애니메이션 상태로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="06d0715c9e5e8fde1b326bf82fa7f414cd43a882" translate="yes" xml:space="preserve">
          <source>When your app is ready, you can use the Angular CLI to extract the text messages marked with &lt;code&gt;i18n&lt;/code&gt; and attributes marked with &lt;code&gt;i18n-x&lt;/code&gt; into a translation source file. Open a terminal window at the root of the app project and run the CLI command &lt;code&gt;xi18n&lt;/code&gt;.</source>
          <target state="translated">앱이 준비되면 Angular CLI를 사용하여 &lt;code&gt;i18n&lt;/code&gt; 으로 표시된 문자 메시지 와 &lt;code&gt;i18n-x&lt;/code&gt; 로 표시된 속성을 번역 소스 파일 로 추출 할 수 있습니다 . 앱 프로젝트의 루트에서 터미널 창을 열고 CLI 명령 &lt;code&gt;xi18n&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="155587edb5946e5b07a5f26004e5f36b972bf50e" translate="yes" xml:space="preserve">
          <source>When your application matches a route that needs AngularJS, the AngularJS app is loaded and bootstrapped, the AngularJS routes match the necessary URL to render their content, and your application continues to run with both AngularJS and Angular frameworks.</source>
          <target state="translated">애플리케이션이 AngularJS가 필요한 경로와 일치하면 AngularJS 앱이로드 및 부트 스트랩되고 AngularJS 경로는 콘텐츠를 렌더링하는 데 필요한 URL과 일치하며 AngularJS 및 Angular 프레임 워크 모두에서 애플리케이션이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1112737823346d69526849d251d05ee8229526b6" translate="yes" xml:space="preserve">
          <source>When your builder calls &lt;code&gt;BuilderRun.stop()&lt;/code&gt; to exit watch mode, Architect unsubscribes from the builder&amp;rsquo;s Observable and calls the builder&amp;rsquo;s teardown logic to clean up. (This behavior also allows for long running builds to be stopped and cleaned up.)</source>
          <target state="translated">빌더가 &lt;code&gt;BuilderRun.stop()&lt;/code&gt; 모드를 종료하기 위해 BuilderRun.stop () 을 호출하면 Architect는 빌더의 Observable을 구독 취소하고 빌더의 정리 로직을 호출하여 정리합니다. (이 동작은 또한 장기 실행 빌드를 중지하고 정리할 수있게합니다.)</target>
        </trans-unit>
        <trans-unit id="40126e45c19e856e37cb61d50f01cae678591e52" translate="yes" xml:space="preserve">
          <source>When your custom element is placed on a page, the browser creates an instance of the registered class and adds it to the DOM. The content is provided by the component's template, which uses Angular template syntax, and is rendered using the component and DOM data. Input properties in the component correspond to input attributes for the element.</source>
          <target state="translated">사용자 정의 요소가 페이지에 배치되면 브라우저는 등록 된 클래스의 인스턴스를 작성하여 DOM에 추가합니다. 콘텐츠는 Angular 템플릿 구문을 사용하는 구성 요소 템플릿에서 제공되며 구성 요소와 DOM 데이터를 사용하여 렌더링됩니다. 컴포넌트의 입력 특성은 요소의 입력 속성에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b8a317fa05b7d048a76b55b7cf3677a9fa2860a5" translate="yes" xml:space="preserve">
          <source>Whenever an &quot;upgraded&quot;/&quot;downgraded&quot; component is instantiated the host element is owned by the framework doing the instantiation. The other framework then instantiates and owns the view for that component.</source>
          <target state="translated">&quot;업그레이드 된&quot;/ &quot;다운 그레이드 된&quot;컴포넌트가 인스턴스화 될 때마다 호스트 요소는 인스턴스화를 수행하는 프레임 워크가 소유합니다. 다른 프레임 워크는 해당 구성 요소에 대한보기를 인스턴스화하고 소유합니다.</target>
        </trans-unit>
        <trans-unit id="c4fef1a1adbf1c56b8cc3ecbb53a52b91dc97ae7" translate="yes" xml:space="preserve">
          <source>Whenever an adapter component is instantiated the host element is owned by the framework doing the instantiation. The other framework then instantiates and owns the view for that component. This implies that component bindings will always follow the semantics of the instantiation framework. The syntax is always that of Angular syntax.</source>
          <target state="translated">어댑터 구성 요소가 인스턴스화 될 때마다 호스트 요소는 인스턴스화를 수행하는 프레임 워크에서 소유합니다. 다른 프레임 워크는 해당 구성 요소에 대한보기를 인스턴스화하고 소유합니다. 이는 컴포넌트 바인딩이 항상 인스턴스화 프레임 워크의 시맨틱을 따릅니다. 구문은 항상 Angular 구문입니다.</target>
        </trans-unit>
        <trans-unit id="bb18456bba2c2a76c99b73d09dd270a2142bfc64" translate="yes" xml:space="preserve">
          <source>Whenever you use a component that belongs to the other framework, a switch between framework boundaries occurs. However, that switch only happens to the elements in the template of that component. Consider a situation where you use an Angular component from AngularJS like this:</source>
          <target state="translated">다른 프레임 워크에 속하는 구성 요소를 사용할 때마다 프레임 워크 경계 간 전환이 발생합니다. 그러나 해당 스위치는 해당 구성 요소 템플릿의 요소에만 적용됩니다. AngularJS의 Angular 컴포넌트를 다음과 같이 사용하는 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="37c5edffc9d8dd9268e9bb4d3e92e12fb900ef58" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;catchError&lt;/code&gt; operator provides a simple path of recovery, the &lt;code&gt;retry&lt;/code&gt; operator lets you retry a failed request.</source>
          <target state="translated">를 Where &lt;code&gt;catchError&lt;/code&gt; 의 운영자가 복구하는 간단한 경로를 제공의 &lt;code&gt;retry&lt;/code&gt; 연산자를 사용하면 실패한 요청을 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e42f4f2adbf1be1d8f547f899caad64fb9b8c9" translate="yes" xml:space="preserve">
          <source>Where to find this element in the source component template.</source>
          <target state="translated">소스 컴포넌트 템플리트에서이 요소를 찾을 수있는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="899e84e9c1a23f3a65ea931518f5051ef6f15a09" translate="yes" xml:space="preserve">
          <source>Where to start looking, that is &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">어디서부터 시작해야 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; @ SkipSelf ()입니다.</target>
        </trans-unit>
        <trans-unit id="dbc3168449a7edc3ef42f05f473e45c12862c64f" translate="yes" xml:space="preserve">
          <source>Where to stop looking, &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt; ()를 찾는 곳</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2e665d9a41999f37f1f7c2d3f4a29a44a6cd8103" translate="yes" xml:space="preserve">
          <source>Whether an associated application is stable</source>
          <target state="translated">관련 응용 프로그램이 안정적인지 여부</target>
        </trans-unit>
        <trans-unit id="eb474db37cd039fcdb74ad381d29c8362cc8e3e8" translate="yes" xml:space="preserve">
          <source>Whether the ServiceWorker will be registered and the related services (such as &lt;code&gt;&lt;a href=&quot;swpush&quot;&gt;SwPush&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt;) will attempt to communicate and interact with it.</source>
          <target state="translated">ServiceWorker 등록 여부 및 관련 서비스 (예 : &lt;code&gt;&lt;a href=&quot;swpush&quot;&gt;SwPush&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; )는 통신 및 상호 작용을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2efc288f3df18953bf9fb23fadb91dbc28bef3db" translate="yes" xml:space="preserve">
          <source>Whether the contents of the root element should be preserved, or cleared upon bootstrap (default behavior). Use with &lt;code&gt;&lt;a href=&quot;viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt; to allow simple native content projection via &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">루트 요소의 내용을 보존해야하는지 또는 부트 스트랩시 지워야하는지 여부 (기본 동작) &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소 를 통해 간단한 기본 컨텐츠 투영을 허용 하려면 &lt;code&gt;&lt;a href=&quot;viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt; 과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="50cfde31657c9b1fe2fdf40030fe9a96ff38a3c3" translate="yes" xml:space="preserve">
          <source>Whether the request was cancelled after it was sent.</source>
          <target state="translated">요청이 전송 된 후 취소되었는지 여부</target>
        </trans-unit>
        <trans-unit id="4bd45560b76a4dce3c8ea0111cc1f62d210247d6" translate="yes" xml:space="preserve">
          <source>Whether the router is configured properly to navigate with that route definition is a question for a separate set of tests.</source>
          <target state="translated">라우터가 해당 경로 정의를 탐색하도록 올바르게 구성되어 있는지 여부는 별도의 테스트 세트에 대한 질문입니다.</target>
        </trans-unit>
        <trans-unit id="a4ae306143b886081b256a0cf1522d64a7dc41b4" translate="yes" xml:space="preserve">
          <source>Whether the segment has child segments</source>
          <target state="translated">세그먼트에 하위 세그먼트가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="456355a8ff33ce384c5db09a8d5dcfc2098e26a3" translate="yes" xml:space="preserve">
          <source>Whether the status code falls in the 2xx range.</source>
          <target state="translated">상태 코드가 2xx 범위에 속하는지 여부</target>
        </trans-unit>
        <trans-unit id="c1e28eb611de2479c2121cff8123da6d11a13577" translate="yes" xml:space="preserve">
          <source>Whether there are no outstanding microtasks or macrotasks.</source>
          <target state="translated">미시적 마이크로 태스크 또는 매크로 태스크가 없는지 여부</target>
        </trans-unit>
        <trans-unit id="8c95f88ef6319a806a46dcf12f9b346039ef053e" translate="yes" xml:space="preserve">
          <source>Whether this request should be made in a way that exposes progress events.</source>
          <target state="translated">이 요청이 진행 이벤트를 노출시키는 방식으로 이루어져야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="98f2e0d781390a03ccdfde20254e6c9d4fb73bb1" translate="yes" xml:space="preserve">
          <source>Whether this request should be sent with outgoing credentials (cookies).</source>
          <target state="translated">이 요청을 발신 자격 증명 (쿠키)과 함께 보내야하는지 여부</target>
        </trans-unit>
        <trans-unit id="e67c5849260e2c1b0ff2264f25feeb3c55f8f10c" translate="yes" xml:space="preserve">
          <source>Whether to allow updating when the repository contains modified or untracked files.</source>
          <target state="translated">저장소에 수정되거나 추적되지 않은 파일이 포함 된 경우 업데이트를 허용할지 여부</target>
        </trans-unit>
        <trans-unit id="70687b848d56f420e192e687505aa7a7298367bc" translate="yes" xml:space="preserve">
          <source>Whether to reload the page on change, using live-reload.</source>
          <target state="translated">실시간 새로 고침을 사용하여 변경시 페이지를 새로 고침할지 여부</target>
        </trans-unit>
        <trans-unit id="432f58be7461d276173b0b45a590420621ebf868" translate="yes" xml:space="preserve">
          <source>Whether to update all packages in package.json.</source>
          <target state="translated">package.json의 모든 패키지를 업데이트할지 여부</target>
        </trans-unit>
        <trans-unit id="1de26d1834040d0a83cfb31ff38330472c5f00df" translate="yes" xml:space="preserve">
          <source>Whether using exactMatch</source>
          <target state="translated">exactMatch 사용 여부</target>
        </trans-unit>
        <trans-unit id="4c0616b2607e4abaa27bed4b0ad642dc7df038cf" translate="yes" xml:space="preserve">
          <source>Whether you came here directly from &lt;a href=&quot;https://angular.io/start/start&quot;&gt;Your First App&lt;/a&gt;, or completed the entire online store application through the &lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;Routing&lt;/a&gt;, &lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;Managing Data&lt;/a&gt;, and &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;Forms&lt;/a&gt; sections, you have an application that you can deploy by following the instructions in this section.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start&quot;&gt;첫 번째 앱&lt;/a&gt; 에서 직접 왔 거나 &lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;라우팅&lt;/a&gt; , &lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;데이터&lt;/a&gt; 및 &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;양식&lt;/a&gt; 섹션을 통해 전체 온라인 상점 애플리케이션을 완료 했는지 여부에 관계 없이이 섹션의 지시 사항에 따라 배치 할 수있는 애플리케이션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6730e737d171af53aac08d450ed36cf222714c7" translate="yes" xml:space="preserve">
          <source>Whether you decide to package functionality as a library is an architectural decision, similar to deciding whether a piece of functionality is a component or a service, or deciding on the scope of a component.</source>
          <target state="translated">기능을 라이브러리로 패키징할지 여부는 기능적 요소가 구성 요소인지 서비스인지를 결정하거나 구성 요소의 범위를 결정하는 것과 유사한 구조적 결정입니다.</target>
        </trans-unit>
        <trans-unit id="2038878dfc5e4e17b17bfe1516c1eeefe95f5b86" translate="yes" xml:space="preserve">
          <source>Which strategy is best?</source>
          <target state="translated">어떤 전략이 가장 좋습니까?</target>
        </trans-unit>
        <trans-unit id="5dfd5deece18b3254cac9f524fac29bd76a83d05" translate="yes" xml:space="preserve">
          <source>While Visual Studio Update 3 ships with TypeScript support out of the box, it currently doesn&amp;rsquo;t ship with more recent versions of TypeScript, which you need to develop Angular applications.</source>
          <target state="translated">Visual Studio Update 3에는 기본적으로 TypeScript 지원이 포함되어 있지만 현재는 최신 버전의 TypeScript가 제공되지 않으므로 Angular 응용 프로그램을 개발해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f1154cb47e7f3f095cf5a680d8c709aaf901f86" translate="yes" xml:space="preserve">
          <source>While a list of items exists in another file, &lt;code&gt;mock-items.ts&lt;/code&gt;, you can specify a different item in &lt;code&gt;app.component.ts&lt;/code&gt; so that the new item will render:</source>
          <target state="translated">항목 목록이 다른 파일 인 &lt;code&gt;mock-items.ts&lt;/code&gt; 에 &lt;code&gt;app.component.ts&lt;/code&gt; 다른 항목을 지정 하여 새 항목이 렌더링되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aaf540a86b02d7ab5f5ad8d445e241cd8492b75" translate="yes" xml:space="preserve">
          <source>While a small application might have only one NgModule, most apps have many more &lt;em&gt;feature modules&lt;/em&gt;. The &lt;em&gt;root&lt;/em&gt; NgModule for an app is so named because it can include child NgModules in a hierarchy of any depth.</source>
          <target state="translated">소규모 응용 프로그램에는 NgModule이 하나만있을 수 있지만 대부분의 응용 프로그램에는 더 많은 &lt;em&gt;기능 모듈이&lt;/em&gt; 있습니다. 앱 의 &lt;em&gt;루트&lt;/em&gt; NgModule은 자식 NgModules를 모든 깊이의 계층에 포함 할 수 있기 때문에 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="de3a579f287c79f1f8e62ef5741cd82572da8246" translate="yes" xml:space="preserve">
          <source>While building out the crisis center feature, you navigated to the crisis detail route using an &lt;strong&gt;absolute path&lt;/strong&gt; that begins with a &lt;em&gt;slash&lt;/em&gt;.</source>
          <target state="translated">위기 센터 기능을 구축하는 동안 &lt;em&gt;슬래시로&lt;/em&gt; 시작 하는 &lt;strong&gt;절대 경로&lt;/strong&gt; 를 사용하여 위기 세부 경로로 이동했습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af0f9bfe35490be85414a0791401df3fcf8622a8" translate="yes" xml:space="preserve">
          <source>While components in dedicated folders are widely preferred, another option for small apps is to keep components flat (not in a dedicated folder). This adds up to four files to the existing folder, but also reduces the folder nesting. Whatever you choose, be consistent.</source>
          <target state="translated">전용 폴더의 구성 요소가 널리 선호되는 반면 작은 앱의 또 다른 옵션은 구성 요소를 전용 폴더가 아닌 평평하게 유지하는 것입니다. 이렇게하면 기존 폴더에 최대 4 개의 파일이 추가되지만 폴더 중첩도 줄어 듭니다. 무엇을 선택하든 일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="af144108b7f59db013ae2561d54c81a42f70f29c" translate="yes" xml:space="preserve">
          <source>While declaring &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; in the &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata is possible, it is a better practice to use the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; class decorators instead, as follows:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/directive&quot;&gt;지시문&lt;/a&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;구성 요소&lt;/a&gt; 메타 데이터 에서 &lt;code&gt;inputs&lt;/code&gt; 및 &lt;code&gt;outputs&lt;/code&gt; 을 선언하는 것이 가능 하지만 다음과 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt; () 클래스 데코레이터를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2bed2bf619f46d9561a69d126f76aa9c4fcbbd5e" translate="yes" xml:space="preserve">
          <source>While developing a library, you must install all peer dependencies through &lt;code&gt;devDependencies&lt;/code&gt; to ensure that the library compiles properly. A linked library will then have its own set of Angular libraries that it uses for building, located in its &lt;code&gt;node_modules&lt;/code&gt; folder. However, this can cause problems while building or running your application.</source>
          <target state="translated">라이브러리를 개발하는 동안 라이브러리가 올바르게 컴파일되도록 &lt;code&gt;devDependencies&lt;/code&gt; 를 통해 모든 피어 종속성을 설치해야합니다 . 그런 다음 연결된 라이브러리는 &lt;code&gt;node_modules&lt;/code&gt; 폴더 에있는 자체 라이브러리 라이브러리를 빌드에 사용 합니다. 그러나 응용 프로그램을 빌드하거나 실행하는 동안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a0bf45b753eb2788a0f144fc1399ff08d7a339" translate="yes" xml:space="preserve">
          <source>While documentation guide pages ultimately render as HTML, almost all of them are written in &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;markdown&lt;/a&gt;.</source>
          <target state="translated">문서 가이드 페이지는 궁극적으로 HTML로 렌더링되지만 대부분은 &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;마크 다운&lt;/a&gt; 으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bb660e2b074f370e7dfa660e9e07c484771bd07" translate="yes" xml:space="preserve">
          <source>While invisible, the element remains in the DOM.</source>
          <target state="translated">보이지 않지만 요소는 DOM에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ee0811bb131e7a95292c475b6b02aee8293f49" translate="yes" xml:space="preserve">
          <source>While it is possible to downgrade injectables, downgraded injectables will not be available until the Angular module that provides them is instantiated. In order to be safe, you need to ensure that the downgraded injectables are not used anywhere &lt;em&gt;outside&lt;/em&gt; the part of the app where it is guaranteed that their module has been instantiated.</source>
          <target state="translated">인젝터 블을 다운 그레이드 할 수는 있지만 다운 그레이드 인젝터 블은 제공되는 Angular 모듈이 인스턴스화 될 때까지 사용할 수 없습니다. 안전을 위해, 다운 그레이드 된 인젝터 블이 앱의 &lt;em&gt;외부&lt;/em&gt; 에서 모듈이 인스턴스화되었다는 보장 이없는 곳에서 사용되지 않도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b21f1ae1393795395e1d8727d35b23f3416670eb" translate="yes" xml:space="preserve">
          <source>While some may not care to minify this aggressively, the Angular product shouldn't prevent anyone from minifying aggressively. Therefore, the Angular team decided that everything Angular provides will minify safely.</source>
          <target state="translated">일부는 이것을 적극적으로 축소하지 않아도되지만 Angular 제품은 다른 사람이 적극적으로 축소하는 것을 막지 않아야합니다. 따라서 Angular 팀은 Angular가 제공하는 모든 것을 안전하게 축소하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="9deda132ffe29c742d81e186d165961fa24ce75f" translate="yes" xml:space="preserve">
          <source>While testing a component this simple has little intrinsic value, it's worth knowing how. You can use one of these approaches:</source>
          <target state="translated">이 간단한 구성 요소를 테스트하는 동안 본질적인 가치는 거의 없지만 방법을 아는 것이 좋습니다. 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922eaf22cdef6cf248a96c62535e56e742dd60f1" translate="yes" xml:space="preserve">
          <source>While that seems redundant, these properties have different functions. Membership in one list doesn't imply membership in another list.</source>
          <target state="translated">중복되는 것처럼 보이지만 이러한 속성에는 다른 기능이 있습니다. 한 목록의 멤버십이 다른 목록의 멤버십을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbaae74b0ebf41a6f36354e5583ce138e38a4b27" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; functions greatly simplify Angular asynchronous testing, you can still fall back to the traditional technique and pass &lt;code&gt;it&lt;/code&gt; a function that takes a &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt;&lt;code&gt;done&lt;/code&gt; callback&lt;/a&gt;.</source>
          <target state="translated">그동안 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 함수는 크게 각도 비동기 테스트를 단순화, 당신은 여전히 기존의 기술로 후퇴하고 전달할 수 있습니다 &lt;code&gt;it&lt;/code&gt; 받는 함수 &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt; &lt;code&gt;done&lt;/code&gt; 콜백을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94a171d6c589715e1067bf2483ed94b5ae7d39ea" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;AppComponent&lt;/code&gt;&lt;em&gt;class&lt;/em&gt; is empty, you may want to write unit tests to confirm that the links are wired properly to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directives, perhaps for the reasons &lt;a href=&quot;testing#why-stubbed-routerlink-tests&quot;&gt;explained below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt; 가 비어 있는 동안 &lt;a href=&quot;testing#why-stubbed-routerlink-tests&quot;&gt;아래 설명&lt;/a&gt; 된 이유로 링크가 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 지시문에 올바르게 연결되었는지 확인하기 위해 단위 테스트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3223a994c3c8a4823a7603409c5fb5030bcfbb" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;HeroesComponent&lt;/code&gt; class still works, the &lt;code&gt;onSelect()&lt;/code&gt; method and &lt;code&gt;selectedHero&lt;/code&gt; property are no longer used.</source>
          <target state="translated">&lt;code&gt;HeroesComponent&lt;/code&gt; 클래스는 여전히 작동 하지만 &lt;code&gt;onSelect()&lt;/code&gt; 메서드와 &lt;code&gt;selectedHero&lt;/code&gt; 속성은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfa741a35ff4ba4dd3d245eeb234b8097b7ea83" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;ngDoCheck()&lt;/code&gt; hook can detect when the hero's &lt;code&gt;name&lt;/code&gt; has changed, it has a frightful cost. This hook is called with enormous frequency&amp;mdash;after &lt;em&gt;every&lt;/em&gt; change detection cycle no matter where the change occurred. It's called over twenty times in this example before the user can do anything.</source>
          <target state="translated">&lt;code&gt;ngDoCheck()&lt;/code&gt; 훅은 영웅의 &lt;code&gt;name&lt;/code&gt; 이 변경된 시기를 감지 할 수 있지만 비용이 많이 듭니다. 이 후크는 변경이 발생한 위치에 관계없이 &lt;em&gt;모든&lt;/em&gt; 변경 감지주기 후에 막대한 빈도로 호출됩니다 . 이 예제에서는 사용자가 무엇이든 할 수 있기 전에 20 번 이상 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="a55beda27c00248790e49417c4dcaaa586bb7541" translate="yes" xml:space="preserve">
          <source>While the &lt;em&gt;code sample&lt;/em&gt; accompanying this guide demonstrates &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt;, this page defers to the &lt;a href=&quot;http#testing-http-requests&quot;&gt;Http guide&lt;/a&gt;, which covers testing with the &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; in detail.</source>
          <target state="translated">그동안 &lt;em&gt;코드 샘플&lt;/em&gt; 이 가이드를 동반 보여줍니다 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 받는 사람,이 페이지는 연기 &lt;a href=&quot;http#testing-http-requests&quot;&gt;의 HTTP 가이드&lt;/a&gt; 커버는 함께 테스트, &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 자세히를.</target>
        </trans-unit>
        <trans-unit id="e236f6fd7d6a981d056dc092480c2d9f7cd0493a" translate="yes" xml:space="preserve">
          <source>While the bootstrapped and routed components are &lt;em&gt;entry components&lt;/em&gt;, you don't have to add them to a module's &lt;code&gt;entryComponents&lt;/code&gt; list, as they are added implicitly.</source>
          <target state="translated">부트 스트랩되고 라우팅 된 구성 요소는 &lt;em&gt;항목 구성 요소&lt;/em&gt; 이지만 모듈 은 암시 적으로 추가 &lt;code&gt;entryComponents&lt;/code&gt; 모듈의 entryComponents 목록 에 추가 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b948c3298099054af5c43499c67fd799579eafd" translate="yes" xml:space="preserve">
          <source>While the following guidelines describe the use of each type and their typical characteristics, in real world apps, you may see hybrids.</source>
          <target state="translated">다음 지침에서는 각 유형의 사용과 일반적인 특성에 대해 설명하지만 실제 앱에서는 하이브리드가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322f024cb227e4947bae54501a104f55a7646140" translate="yes" xml:space="preserve">
          <source>While the name &lt;code&gt;root&lt;/code&gt; is a special alias, other &lt;code&gt;ModuleInjector&lt;/code&gt;s don't have aliases. You have the option to create &lt;code&gt;ModuleInjector&lt;/code&gt;s whenever a dynamically loaded component is created, such as with the Router, which will create child &lt;code&gt;ModuleInjector&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 이름 은 특수한 별칭이지만 다른 &lt;code&gt;ModuleInjector&lt;/code&gt; 에는 별칭이 없습니다. 당신이 만들 수있는 옵션이 &lt;code&gt;ModuleInjector&lt;/code&gt; 의 동적으로로드 된 구성 요소는 이러한 아동이 생성됩니다 라우터와 같이 생성 될 때마다 &lt;code&gt;ModuleInjector&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="1d767a5a85783201556264a61318d016cc2125ea" translate="yes" xml:space="preserve">
          <source>While the router uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; style by default, you &lt;em&gt;must&lt;/em&gt; configure that strategy with a &lt;strong&gt;base href&lt;/strong&gt;.</source>
          <target state="translated">라우터는 기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; 스타일을 사용하지만 &lt;strong&gt;base href로&lt;/strong&gt; 해당 전략을 구성 &lt;em&gt;해야&lt;/em&gt; 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01d95e9caebba56bfe90c85d978bfaab15d3c180" translate="yes" xml:space="preserve">
          <source>While the subscription is active, Service Worker listens for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PushEvent&quot;&gt;PushEvent&lt;/a&gt; occurrences and creates &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; instances in response.</source>
          <target state="translated">구독이 활성화 된 동안 Service Worker는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PushEvent&quot;&gt;PushEvent&lt;/a&gt; 발생을 수신 하고 응답으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e91af09c132542b901dc969980ed9ae882ac1705" translate="yes" xml:space="preserve">
          <source>While there's rarely a good reason to apply a structural directive in template &lt;em&gt;attribute&lt;/em&gt; or &lt;em&gt;element&lt;/em&gt; form, it's still important to know that Angular creates a &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; and to understand how it works. You'll refer to the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; when you &lt;a href=&quot;structural-directives#unless&quot;&gt;write your own structural directive&lt;/a&gt;.</source>
          <target state="translated">템플릿 &lt;em&gt;속성&lt;/em&gt; 또는 &lt;em&gt;요소&lt;/em&gt; 형식 으로 구조적 지시문을 적용 할만한 이유는 거의 없지만 Angular는 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 을 만들고 작동 방식을 이해해야합니다. &lt;a href=&quot;structural-directives#unless&quot;&gt;자신 만의 구조적 지시문&lt;/a&gt; 을 작성할 때 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13ac445e8a260522faf3df163997d45a5d55783f" translate="yes" xml:space="preserve">
          <source>While these default criteria are fine in most cases, it is sometimes desirable to configure different rules. For example, you may want to ignore specific routes (that are not part of the Angular app) and pass them through to the server.</source>
          <target state="translated">대부분의 경우 이러한 기본 기준이 적합하지만 다른 규칙을 구성하는 것이 바람직한 경우가 있습니다. 예를 들어 Angular 앱의 일부가 아닌 특정 경로를 무시하고 서버로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9227406655f727bc3b335fbb57e7ecad4435de" translate="yes" xml:space="preserve">
          <source>While this app doesn't have a route to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; that omits the &lt;code&gt;id&lt;/code&gt; parameter, it might add such a route someday. The component should do something reasonable when there is no &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">이 앱에는 &lt;code&gt;id&lt;/code&gt; 매개 변수 를 생략하는 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 에 대한 경로가 없지만 언젠가는 해당 경로를 추가 할 수 있습니다. 구성 요소는 &lt;code&gt;id&lt;/code&gt; 가없는 경우 합리적인 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3db01e5de077841c6ee63df60c8eb095a471b993" translate="yes" xml:space="preserve">
          <source>While this is a base class that NgClass extends from, the class itself acts as a container for non-VE code to setup a link to the &lt;code&gt;[class]&lt;/code&gt; host binding (via the static &lt;code&gt;ngDirectiveDef&lt;/code&gt; property on the class).</source>
          <target state="translated">이 클래스는 NgClass가 확장하는 기본 클래스이지만 클래스 자체는 &lt;code&gt;[class]&lt;/code&gt; VE ] 호스트 바인딩에 대한 링크 (클래스 의 정적 &lt;code&gt;ngDirectiveDef&lt;/code&gt; 속성을 통해)에 대한 링크를 설정하기 위해 비 VE 코드의 컨테이너 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="40a33dd6773969d82d18d1f0e4b8284401f3f3fa" translate="yes" xml:space="preserve">
          <source>While this is a base class that NgStyle extends from, the class itself acts as a container for non-VE code to setup a link to the &lt;code&gt;[&lt;a href=&quot;../animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; host binding (via the static &lt;code&gt;ngDirectiveDef&lt;/code&gt; property on the class).</source>
          <target state="translated">이 클래스는 NgStyle이 확장하는 기본 클래스이지만 클래스 자체는 VE가 아닌 코드의 컨테이너 역할을하여 클래스 의 정적 &lt;code&gt;ngDirectiveDef&lt;/code&gt; 속성을 통해 &lt;code&gt;[&lt;a href=&quot;../animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; 호스트 바인딩에 대한 링크를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1557d255fa555f2461a9fc1ea6d89f6d4f9550b5" translate="yes" xml:space="preserve">
          <source>While this technique is suitable for toggling a single class name, consider the &lt;a href=&quot;template-syntax#ngClass&quot;&gt;&lt;code&gt;NgClass&lt;/code&gt;&lt;/a&gt; directive when managing multiple class names at the same time.</source>
          <target state="translated">이 기술은 단일 클래스 이름을 토글하는 데 적합하지만 동시에 여러 클래스 이름을 관리 할 때 &lt;a href=&quot;template-syntax#ngClass&quot;&gt; &lt;code&gt;NgClass&lt;/code&gt; &lt;/a&gt; 지시문을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="d971e439874c00bf97336a91204c83d31c4d88b7" translate="yes" xml:space="preserve">
          <source>While working on a published library, you can use &lt;a href=&quot;https://docs.npmjs.com/cli/link&quot;&gt;npm link&lt;/a&gt; to avoid reinstalling the library on every build.</source>
          <target state="translated">게시 된 라이브러리에서 작업하는 동안 &lt;a href=&quot;https://docs.npmjs.com/cli/link&quot;&gt;npm 링크&lt;/a&gt; 를 사용 하여 모든 빌드에서 라이브러리를 다시 설치하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="b24ca2e39219949e690787fe118cba513f0fcb23" translate="yes" xml:space="preserve">
          <source>While you can put more than one component tree on a host web page, most applications have only one component tree and bootstrap a single root component.</source>
          <target state="translated">호스트 웹 페이지에 둘 이상의 구성 요소 트리를 둘 수 있지만 대부분의 응용 프로그램에는 하나의 구성 요소 트리 만 있고 단일 루트 구성 요소를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="7e225fb4c7e87b7b1778b247651d232843aa3aba" translate="yes" xml:space="preserve">
          <source>While you could call &lt;code&gt;getHeroes()&lt;/code&gt; in the constructor, that's not the best practice.</source>
          <target state="translated">생성자에서 &lt;code&gt;getHeroes()&lt;/code&gt; 를 호출 할 수 있지만 최선의 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a0fae3fec8db9b133701c092b5757d24ffb7e3ae" translate="yes" xml:space="preserve">
          <source>While you could continue to add files to the &lt;code&gt;src/app/&lt;/code&gt; folder, that is unrealistic and ultimately not maintainable. Most developers prefer to put each feature area in its own folder.</source>
          <target state="translated">&lt;code&gt;src/app/&lt;/code&gt; 폴더 에 파일을 계속 추가 할 수는 있지만 비현실적이며 궁극적으로는 유지 관리 할 수 ​​없습니다. 대부분의 개발자는 각 기능 영역을 자체 폴더에 배치하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ab6a43c0bf8f0d40672e23efd7b8429687eb1e22" translate="yes" xml:space="preserve">
          <source>Why &quot;ngModel&quot;? A directive's &lt;a href=&quot;../api/core/directive&quot;&gt;exportAs&lt;/a&gt; property tells Angular how to link the reference variable to the directive. You set &lt;code&gt;name&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; because the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive's &lt;code&gt;exportAs&lt;/code&gt; property happens to be &quot;ngModel&quot;.</source>
          <target state="translated">왜 &quot;ngModel&quot;입니까? 지시문의 &lt;a href=&quot;../api/core/directive&quot;&gt;exportAs&lt;/a&gt; 속성은 Angular에 참조 변수를 지시문에 연결하는 방법을 알려줍니다. &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 지시문의 &lt;code&gt;exportAs&lt;/code&gt; 속성이 &quot;ngModel&quot; 이므로 &lt;code&gt;name&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 로 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="d318f1063bfb5cd9dacbb5931bfa402cc527970e" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;remove&lt;/code&gt; rather than &lt;code&gt;hide&lt;/code&gt;?</source>
          <target state="translated">왜 &lt;code&gt;hide&lt;/code&gt; 않고 &lt;code&gt;remove&lt;/code&gt; 해야 합니까?</target>
        </trans-unit>
        <trans-unit id="5e5069bc0dde0d06f00638f22a1b23e5b6061f68" translate="yes" xml:space="preserve">
          <source>Why check &lt;em&gt;dirty&lt;/em&gt; and &lt;em&gt;touched&lt;/em&gt;?</source>
          <target state="translated">왜 체크 &lt;em&gt;오염&lt;/em&gt; 과 &lt;em&gt;감동&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="cdde1e44b5df9e7b5ee6f951fb7ffd01c1fe5ee3" translate="yes" xml:space="preserve">
          <source>Why declare &lt;em&gt;angular&lt;/em&gt; as &lt;em&gt;angular.IAngularStatic&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;angular&lt;/em&gt; 를 &lt;em&gt;angular.IAngularStatic으로&lt;/em&gt; 선언하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="77edc57f32ccba69520fd34fd76f444ba728688a" translate="yes" xml:space="preserve">
          <source>Why does Angular need &lt;code&gt;entryComponents&lt;/code&gt;?</source>
          <target state="translated">Angular에 &lt;code&gt;entryComponents&lt;/code&gt; 가 필요한 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="51611ead610693f8035df03d882f55fdb9029100" translate="yes" xml:space="preserve">
          <source>Why does lazy loading create a child injector?</source>
          <target state="translated">왜 게으른 로딩이 하위 인젝터를 생성합니까?</target>
        </trans-unit>
        <trans-unit id="4eec386f35248e79e61fc00c25f2064798d6b68d" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;doSomething()&lt;/code&gt; method wait a tick before updating &lt;code&gt;comment&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;doSomething()&lt;/code&gt; 메소드가 &lt;code&gt;comment&lt;/code&gt; 을 업데이트하기 전에 틱을 기다리는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="eb31703be46c50bbc7eaa00a5535907610777ee9" translate="yes" xml:space="preserve">
          <source>Why doesn't Angular add lazy-loaded providers to the app root injector as it does for eagerly loaded NgModules?</source>
          <target state="translated">Angular는 열악하게로드 된 NgModules와 같이 앱 루트 인젝터에 게으른로드 된 공급자를 추가하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1854ce5e4b6793b5d1ae83050374ba97c6c3c00c" translate="yes" xml:space="preserve">
          <source>Why is a service provided in a feature module visible everywhere?</source>
          <target state="translated">기능 모듈에서 제공되는 서비스가 모든 곳에 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7f854e990dd8ef12c3bfdefa6688b2c3721f6c5b" translate="yes" xml:space="preserve">
          <source>Why is a service provided in a lazy-loaded module visible only to that module?</source>
          <target state="translated">지연로드 된 모듈로 제공되는 서비스가 해당 모듈에만 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8c6b2ade23fd30b08eb34573829d5d3555214a81" translate="yes" xml:space="preserve">
          <source>Why is it bad if a shared module provides a service to a lazy-loaded module?</source>
          <target state="translated">공유 모듈이 지연로드 된 모듈에 서비스를 제공하는 경우 왜 나쁜가요?</target>
        </trans-unit>
        <trans-unit id="2e4580536b0f2359910adb76e50ba348f206ca0a" translate="yes" xml:space="preserve">
          <source>Why it works</source>
          <target state="translated">작동하는 이유</target>
        </trans-unit>
        <trans-unit id="c61aec305e608a6380d5ef5d9610794a4acd19c7" translate="yes" xml:space="preserve">
          <source>Why list the same component in multiple &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; properties?</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 속성 에 동일한 구성 요소를 나열하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="4b4def911c2cbfb92404d9a60708df645ca4036b" translate="yes" xml:space="preserve">
          <source>Why not &quot;highlight&quot;?</source>
          <target state="translated">왜 &quot;강조 표시&quot;하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="9e9f3c21f34bc99e2a0bc838edaf643242816b11" translate="yes" xml:space="preserve">
          <source>Why not defer DOM integration tests to end-to-end (E2E) testing?</source>
          <target state="translated">DOM 통합 테스트를 엔드 투 엔드 (E2E) 테스트로 연기하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f0c9e7d2fbfbc176f66d88e4130920bb0d8e5e6d" translate="yes" xml:space="preserve">
          <source>Why not rely on E2E tests of DOM integration?</source>
          <target state="translated">DOM 통합의 E2E 테스트에 의존하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ba6cd6fa33a570d67aedda554c42dca77ff31e43" translate="yes" xml:space="preserve">
          <source>Why put spec file next to the file it tests?</source>
          <target state="translated">사양 파일을 테스트하는 파일 옆에 배치해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="12078275c72479f3331dcc17b12caa18d03a9c98" translate="yes" xml:space="preserve">
          <source>Why services</source>
          <target state="translated">왜 서비스</target>
        </trans-unit>
        <trans-unit id="430ea9adf8d91815946ba4f13ebf65a6528dc6b9" translate="yes" xml:space="preserve">
          <source>Why use server-side rendering?</source>
          <target state="translated">서버 측 렌더링을 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="58eb6efb5ee2ce76380afc566adebeb87b29c2a6" translate="yes" xml:space="preserve">
          <source>Why would you use SVG as template, instead of simply adding it as image to your application?</source>
          <target state="translated">SVG를 단순히 이미지를 응용 프로그램에 이미지로 추가하는 대신 템플릿으로 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5e348a70aa9504ebb9cd2767488ed852755a1934" translate="yes" xml:space="preserve">
          <source>Why write a service?</source>
          <target state="translated">왜 서비스를 작성해야합니까?</target>
        </trans-unit>
        <trans-unit id="7320f16356458f846b9605ef64b13b7ecdd83423" translate="yes" xml:space="preserve">
          <source>Why you &lt;a href=&quot;structural-directives#the-asterisk--prefix&quot;&gt;prefix the directive name with an asterisk (*)&lt;/a&gt;.</source>
          <target state="translated">당신은 왜 &lt;a href=&quot;structural-directives#the-asterisk--prefix&quot;&gt;별표 (*)로 지시어 이름 앞에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c5b9f3361fe794e0551a73d476d4c73d87a3a4" translate="yes" xml:space="preserve">
          <source>Why you use it</source>
          <target state="translated">왜 사용 하는가</target>
        </trans-unit>
        <trans-unit id="9ec4d86f6bc5dfade050672f98a8b077a3af7db8" translate="yes" xml:space="preserve">
          <source>Wide</source>
          <target state="translated">Wide</target>
        </trans-unit>
        <trans-unit id="b920e278db060d5132eb85b067e6489cd9df8c17" translate="yes" xml:space="preserve">
          <source>Wide (fallback to &lt;code&gt;&lt;a href=&quot;../router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt; when missing)</source>
          <target state="translated">와이드 (에 폴백 없는 경우) &lt;code&gt;&lt;a href=&quot;../router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be7eb77ab67a75bdfd5c6e1433e701036125c95c" translate="yes" xml:space="preserve">
          <source>Wide images can be a problem. Most browsers try to rescale the image but wide images may overflow the document in certain viewports.</source>
          <target state="translated">넓은 이미지는 문제가 될 수 있습니다. 대부분의 브라우저는 이미지의 크기를 조정하려고하지만 특정 이미지에서 넓은 이미지로 인해 문서가 오버플로 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="e5ea2dcd242e9e2f7f8046f8332e2e4f97aa61fc" translate="yes" xml:space="preserve">
          <source>Widget feature modules.</source>
          <target state="translated">위젯 기능 모듈.</target>
        </trans-unit>
        <trans-unit id="4b22636bf684877a2ca0fddff96647d96827436c" translate="yes" xml:space="preserve">
          <source>Wild Cards</source>
          <target state="translated">와일드 카드</target>
        </trans-unit>
        <trans-unit id="e7838d3e850762e34afbc40f2627be6c7bd374b2" translate="yes" xml:space="preserve">
          <source>Wildcard state</source>
          <target state="translated">와일드 카드 상태</target>
        </trans-unit>
        <trans-unit id="019592ebc26ebe6bf40f0c3a3d02f90af2815eb4" translate="yes" xml:space="preserve">
          <source>Will be called for every request, so the token may change between requests.</source>
          <target state="translated">모든 요청에 ​​대해 호출되므로 토큰이 요청간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="0fdc144c92056ab7d5f102c3d50ea2cefa690d68" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;i18n#merge-aot&quot;&gt;AOT&lt;/a&gt;, you pass the information as configuration settings.</source>
          <target state="translated">함께 &lt;a href=&quot;i18n#merge-aot&quot;&gt;AOT&lt;/a&gt; , 당신은 구성 설정과 같은 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1d09f298abe9a7fc875ef158d461d408d20664a6" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;i18n#merge-jit&quot;&gt;JIT&lt;/a&gt;, you provide the information at bootstrap time.</source>
          <target state="translated">으로 &lt;a href=&quot;i18n#merge-jit&quot;&gt;JIT&lt;/a&gt; , 당신은 부트 스트랩 시간에 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="200c19c0c9f56cf91684c9502f9b1d3d09288928" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;*&lt;a href=&quot;api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; repeats for each product in the list.</source>
          <target state="translated">함께 &lt;code&gt;*&lt;a href=&quot;api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 상기 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 반복 목록에서 각 제품.</target>
        </trans-unit>
        <trans-unit id="0ecc3b0f037e8e08430e46acd7c70c807c3b3ffb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt;, the two change detection systems are tied together more tightly. Whenever something happens in the AngularJS part of the app, change detection is automatically triggered on the Angular part and vice versa. This is convenient as it ensures that neither framework misses an important change. Most of the time, though, these extra change detection runs are unnecessary.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; , 두 변경 감지 시스템은 더 단단하게 연결되어 있습니다. 앱의 AngularJS 부분에서 무언가가 발생할 때마다 변경 감지가 Angular 부분에서 자동으로 트리거되며 그 반대도 마찬가지입니다. 이것은 어느 프레임 워크도 중요한 변화를 놓치지 않도록하기 때문에 편리합니다. 그러나 대부분의 경우 이러한 추가 변경 감지 실행이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ab2c912f60573267ca8c0c610d5904df837d8b8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, Angular passes the value for &lt;code&gt;currentItem&lt;/code&gt; to the child so that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; renders as &lt;code&gt;Television&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 각도를 값 통과 &lt;code&gt;currentItem&lt;/code&gt; 하도록 아이에게이 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 으로 렌더링 &lt;code&gt;Television&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1571093943d515929c4d2ad37e20dc85fb0cb242" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;, the injector begins its search for the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ElementInjector&lt;/code&gt; and finds 🐳 (whale).</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; , 인젝터는 자사 검색을 시작 &lt;code&gt;AnimalService&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ElementInjector&lt;/code&gt; 및 발견 🐳 (고래).</target>
        </trans-unit>
        <trans-unit id="514263be0a675439b526ac2db882f2028e8a6caa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;, the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; injector doesn't look to itself for the &lt;code&gt;FlowerService&lt;/code&gt;. Instead, the injector starts looking for the &lt;code&gt;FlowerService&lt;/code&gt; at the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;'s &lt;code&gt;ElementInjector&lt;/code&gt;, where it finds nothing. Then, it goes back to the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; and finds the 🌺 (red hibiscus) value, which is available because the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; and the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; are flattened into one &lt;code&gt;ModuleInjector&lt;/code&gt;. Thus, the UI renders the following:</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 인젝터는 대한 자체에 보이지 않는 &lt;code&gt;FlowerService&lt;/code&gt; . 대신, 인젝터 는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 의 &lt;code&gt;ElementInjector&lt;/code&gt; 에서 &lt;code&gt;FlowerService&lt;/code&gt; 를 찾기 시작합니다 . 여기서 아무것도 찾지 않습니다. 그런 다음 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 로 돌아가서 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 및 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 가 하나의 &lt;code&gt;ModuleInjector&lt;/code&gt; 로 전개 되어 사용 가능한 🌺 (빨간색 히비스커스) 값을 찾습니다 . 따라서 UI는 다음을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="6aa81c5fc739583ab2d3afe1487e3a1975b85894" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;trackBy&lt;/code&gt;, only changing the &lt;code&gt;id&lt;/code&gt; triggers element replacement.</source>
          <target state="translated">&lt;code&gt;trackBy&lt;/code&gt; 를 사용 하면 &lt;code&gt;id&lt;/code&gt; 변경 만 요소 교체를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="2b2022ad5e54a76cb4f206c08caf298b2a25eec7" translate="yes" xml:space="preserve">
          <source>With Angular Universal, you can generate landing pages for the app that look like the complete app. The pages are pure HTML, and can display even if JavaScript is disabled. The pages don't handle browser events, but they &lt;em&gt;do&lt;/em&gt; support navigation through the site using &lt;a href=&quot;router#router-link&quot;&gt;&lt;code&gt;routerLink&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Angular Universal을 사용하면 완전한 앱처럼 보이는 앱의 랜딩 페이지를 생성 할 수 있습니다. 페이지는 순수한 HTML이며 JavaScript가 비활성화되어 있어도 표시 할 수 있습니다. 페이지는 브라우저 이벤트를 처리하지 않습니다,하지만 그들은 &lt;em&gt;어떻게&lt;/em&gt; 사용하여 사이트를 통해 지원 탐색을 &lt;a href=&quot;router#router-link&quot;&gt; &lt;code&gt;routerLink&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8fe2ab51d493e8db841e87168ff2a0ac6f0c3e" translate="yes" xml:space="preserve">
          <source>With Angular version 8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands. For example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</source>
          <target state="translated">Angular 버전 8에서는 CLI Builder API가 안정적이며 명령을 추가하거나 수정하여 Angular CLI를 사용자 정의하려는 개발자가 사용할 수 있습니다. 예를 들어 완전히 새로운 작업을 수행하거나 기존 명령에서 사용하는 타사 도구를 변경하도록 빌더를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a88e1a0148b4a6869805a7a6ac97dde9e0ff28" translate="yes" xml:space="preserve">
          <source>With CSS imports.</source>
          <target state="translated">CSS 가져 오기</target>
        </trans-unit>
        <trans-unit id="bf0a79766c3bc1ba070745fe39181ae5fe7be150" translate="yes" xml:space="preserve">
          <source>With data-binding, you can control things like the state of a button:</source>
          <target state="translated">데이터 바인딩을 사용하면 버튼 상태와 같은 것을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3e8732f285a06169348c283028ee3640fff4b7a" translate="yes" xml:space="preserve">
          <source>With its &lt;code&gt;getAds()&lt;/code&gt; method, &lt;code&gt;AdBannerComponent&lt;/code&gt; cycles through the array of &lt;code&gt;AdItems&lt;/code&gt; and loads a new component every 3 seconds by calling &lt;code&gt;loadComponent()&lt;/code&gt;.</source>
          <target state="translated">그와 &lt;code&gt;getAds()&lt;/code&gt; 메소드 &lt;code&gt;AdBannerComponent&lt;/code&gt; 의 배열을 통해 순환 &lt;code&gt;AdItems&lt;/code&gt; 호출하여로드 새로운 컴포넌트를 매 3 초마다 &lt;code&gt;loadComponent()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ceb2407ccef6b0bf3e482eb7d304bbdcd717820" translate="yes" xml:space="preserve">
          <source>With no &lt;code&gt;trackBy&lt;/code&gt;, both buttons trigger complete DOM element replacement.</source>
          <target state="translated">&lt;code&gt;trackBy&lt;/code&gt; 가 없으면 두 버튼 모두 완전한 DOM 요소 교체를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="536e3572a460f32cd6bdb3410223e623acf76f40" translate="yes" xml:space="preserve">
          <source>With reactive forms, the &lt;strong&gt;&lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance&lt;/strong&gt; always returns a new value when the control's value is updated.</source>
          <target state="translated">반응 형을 사용 하면 컨트롤 값이 업데이트 될 때 &lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스가&lt;/strong&gt; 항상 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e2c684a98820d22704c39326e7146086ace1878" translate="yes" xml:space="preserve">
          <source>With reactive forms, the form model is explicitly defined in the component class. The reactive form directive (in this case, &lt;code&gt;&lt;a href=&quot;../api/forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt;) then links the existing &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance to a specific form element in the view using a value accessor (&lt;code&gt;&lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; instance).</source>
          <target state="translated">반응 양식을 사용하면 양식 모델이 컴포넌트 클래스에 명시 적으로 정의됩니다. 반응 형 지시문 (이 경우 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt; ) 은 값 접근 자 ( &lt;code&gt;&lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 인스턴스)를 사용하여 기존 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스를보기의 특정 양식 요소에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="2d05e69e43f92be76d996dab286009e2290f7866" translate="yes" xml:space="preserve">
          <source>With reactive forms:</source>
          <target state="translated">반응성 형태 :</target>
        </trans-unit>
        <trans-unit id="019eb643284aded107e069dd6344db97a92357fe" translate="yes" xml:space="preserve">
          <source>With template-driven forms, the &lt;strong&gt;favorite color property&lt;/strong&gt; is always modified to its new value.</source>
          <target state="translated">템플릿 기반 양식을 사용하면 &lt;strong&gt;자주 사용하는 색상 속성&lt;/strong&gt; 이 항상 새 값으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="19e073dfecca90c0a9f77a20bb44682814b67a82" translate="yes" xml:space="preserve">
          <source>With template-driven forms:</source>
          <target state="translated">템플릿 기반 양식으로 :</target>
        </trans-unit>
        <trans-unit id="be8d82817001ae7961e2f4110b21a1426c5b5835" translate="yes" xml:space="preserve">
          <source>With that concern in mind, implement an impure pipe with great care. An expensive, long-running pipe could destroy the user experience.</source>
          <target state="translated">이러한 우려를 염두에두고 불순한 파이프를 신중하게 구현하십시오. 고가의 장기 배관은 사용자 경험을 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f5cfc92b9e57c5269817cc98d1f5ea4a41a524" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;http://www.learnrxjs.io/operators/transformation/switchmap.html&quot;&gt;switchMap operator&lt;/a&gt;, every qualifying key event can trigger an &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; method call. Even with a 300ms pause between requests, you could have multiple HTTP requests in flight and they may not return in the order sent.</source>
          <target state="translated">&lt;a href=&quot;http://www.learnrxjs.io/operators/transformation/switchmap.html&quot;&gt;switchMap 연산자를&lt;/a&gt; 사용하면 모든 규정 키 이벤트가 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 메소드 호출을 트리거 할 수 있습니다 . 요청간에 300ms의 일시 중지가 있어도 여러 HTTP 요청이 비행 중일 수 있으며 전송 된 순서대로 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2352f11932b7bff23ba7057bd735b9f485a4af13" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;ngUpgrade&lt;/code&gt; library in Angular you can upgrade an existing AngularJS app incrementally by building a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can mix and match AngularJS and Angular components and services and have them interoperate seamlessly. That means you don't have to do the upgrade work all at once as there is a natural coexistence between the two frameworks during the transition period.</source>
          <target state="translated">Angular 의 &lt;code&gt;ngUpgrade&lt;/code&gt; 라이브러리를 사용하면 두 프레임 워크를 나란히 실행할 수있는 하이브리드 앱을 빌드하여 기존 AngularJS 앱을 점진적으로 업그레이드 할 수 있습니다. 이러한 하이브리드 앱에서는 AngularJS와 Angular 구성 요소 및 서비스를 혼합하여 일치시키고 원활하게 상호 운용 할 수 있습니다. 즉, 전환 기간 동안 두 프레임 워크간에 자연스러운 공존이 있기 때문에 업그레이드 작업을 한 번에 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="074ab19623556f09735ac122589456a92b46c9ef" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;value&lt;/code&gt; property. which gives you a snapshot of the current value.</source>
          <target state="translated">와 &lt;code&gt;value&lt;/code&gt; 속성입니다. 현재 값의 스냅 샷을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3e2859d149c00a8c70f651753088ada705938fd" translate="yes" xml:space="preserve">
          <source>With the Angular CLI, you can configure your global styles in the &lt;code&gt;angular.json&lt;/code&gt; file. You can rename the extension to &lt;code&gt;.scss&lt;/code&gt; to use sass.</source>
          <target state="translated">Angular CLI를 사용하면 &lt;code&gt;angular.json&lt;/code&gt; 파일 에서 글로벌 스타일을 구성 할 수 있습니다 . sass를 사용하기 위해 확장자를 &lt;code&gt;.scss&lt;/code&gt; 로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cc1b5658039f71e373c05a8c2d298408717f4a9" translate="yes" xml:space="preserve">
          <source>With the addition of an Angular service worker, the application behavior changes. On a refresh, the page loads normally.</source>
          <target state="translated">Angular 서비스 워커를 추가하면 응용 프로그램 동작이 변경됩니다. 새로 고침하면 페이지가 정상적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="1ed3fd9bd4c1f256dcc104023a64d45285ef0146" translate="yes" xml:space="preserve">
          <source>With the following code:</source>
          <target state="translated">다음 코드로</target>
        </trans-unit>
        <trans-unit id="e4ba2bf51920e50ddd76d0b8ce235609e5ca3f00" translate="yes" xml:space="preserve">
          <source>With the redirects setup, all previous routes now point to their new destinations and both URLs still function as intended.</source>
          <target state="translated">리디렉션 설정을 사용하면 이전의 모든 경로가 이제 새로운 목적지를 가리키고 두 URL이 여전히 의도 한대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7b7e14ba85f043cc2153d669ef641d59ce2ba6dc" translate="yes" xml:space="preserve">
          <source>With the safe navigation operator, &lt;code&gt;?&lt;/code&gt;, Angular stops evaluating the expression when it hits the first &lt;code&gt;null&lt;/code&gt; value and renders the view without errors.</source>
          <target state="translated">안전한 탐색 연산자를 사용하면 &lt;code&gt;?&lt;/code&gt; , Angular는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값에 도달하면 표현식 평가를 중지 하고 오류없이 뷰를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="e6501ec771a7fc4bae077d3c02ffac0e8b32870f" translate="yes" xml:space="preserve">
          <source>With the server running, you can point your browser at &lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080/&lt;/a&gt;. Your application should load normally.</source>
          <target state="translated">서버가 실행 중이면 &lt;a href=&quot;http://localhost:8080/&quot;&gt;http : // localhost : 8080 /&lt;/a&gt; 에서 브라우저를 가리킬 수 있습니다 . 응용 프로그램이 정상적으로로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe7cf705023fd1c89ebb3c647e04c69d1bb4ec3" translate="yes" xml:space="preserve">
          <source>With the versioning behavior of the Angular service worker, an application server can ensure that the Angular app always has a consistent set of files.</source>
          <target state="translated">응용 프로그램 서버는 Angular 서비스 워커의 버전 관리 동작을 통해 Angular 앱에 항상 일관된 파일 세트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2849f0172ab7aa7e6a7d8293fb4ce2777526ea4a" translate="yes" xml:space="preserve">
          <source>With this content:</source>
          <target state="translated">이 내용으로 :</target>
        </trans-unit>
        <trans-unit id="089eb5172d3965ed3cdbcf88655204f69aa78b7a" translate="yes" xml:space="preserve">
          <source>WithProperties</source>
          <target state="translated">WithProperties</target>
        </trans-unit>
        <trans-unit id="9bda55462ad09ef63ca623f6eb47fb05236ec79c" translate="yes" xml:space="preserve">
          <source>Within a switch container, &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; statements specify the match expressions as attributes. Include &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; as the final case.</source>
          <target state="translated">스위치 컨테이너 내에서 &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; 문은 일치 표현식을 속성으로 지정합니다. 마지막 경우 &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e7fc2910f937115866b1508ba85cfd25173fbfe" translate="yes" xml:space="preserve">
          <source>Within such a factory function, using this function to request injection of a dependency is faster and more type-safe than providing an additional array of dependencies (as has been common with &lt;code&gt;&lt;a href=&quot;factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; providers).</source>
          <target state="translated">이러한 팩토리 함수 내에서이 함수를 사용하여 종속성 주입을 요청하는 것은 추가적인 의존성 배열을 제공하는 것보다 더 빠르며 유형 안전합니다 ( &lt;code&gt;&lt;a href=&quot;factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 제공자 와 공통적 임 ).</target>
        </trans-unit>
        <trans-unit id="22803a3b39417d3e155ecdc540584686725394b8" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 함수 내에서 :</target>
        </trans-unit>
        <trans-unit id="7d1d21894554520cbe70ca3161889946066e8693" translate="yes" xml:space="preserve">
          <source>Within the container, &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; statements specify the match expressions as attributes. Include &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; as the final case.</source>
          <target state="translated">컨테이너 내에서 &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; 문은 일치 표현식을 속성으로 지정합니다. 마지막 경우 &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7276b58b727c6c410427f99bc15652f439a152d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; 없이</target>
        </trans-unit>
        <trans-unit id="7fcf4d2f6736413b0fdde7ba35c562ec2b3ed296" translate="yes" xml:space="preserve">
          <source>Without a framework, you would be responsible for pushing data values into the HTML controls and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.</source>
          <target state="translated">프레임 워크가 없으면 데이터 값을 HTML 컨트롤로 푸시하고 사용자 응답을 작업 및 값 업데이트로 전환해야합니다. 경험이 많은 프론트 엔드 JavaScript 프로그래머가 증명할 수 있듯이 이러한 푸시 앤 풀 로직을 손으로 작성하는 것은 지루하고 오류가 발생하기 쉽고 악의적입니다.</target>
        </trans-unit>
        <trans-unit id="43acf4885e6d5e8186042e70023c71257f30d8b8" translate="yes" xml:space="preserve">
          <source>Without animations, web page transitions can seem abrupt and jarring.</source>
          <target state="translated">애니메이션이 없으면 웹 페이지 전환이 갑작스럽고 혼란스럽게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb1b66992897f9d72d43a66457c712e7332958e" translate="yes" xml:space="preserve">
          <source>Without interception, developers would have to implement these tasks &lt;em&gt;explicitly&lt;/em&gt; for each &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; method call.</source>
          <target state="translated">가로 채기없이 개발자는 각 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 메서드 호출 에 대해 이러한 작업을 &lt;em&gt;명시 적으로&lt;/em&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8159db5355a8ad440e87c125107146e2f6c4bc2" translate="yes" xml:space="preserve">
          <source>Without rewriting, this would be invalid because lambdas are not supported and &lt;code&gt;TypicalServer&lt;/code&gt; is not exported. To allow this, the compiler automatically rewrites this to something like:</source>
          <target state="translated">다시 쓰지 않으면 람다는 지원 되지 않고 &lt;code&gt;TypicalServer&lt;/code&gt; 가 내보내 지지 않기 때문에 유효하지 않습니다. 이를 허용하기 위해 컴파일러는이를 다음과 같이 자동으로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1929ccbff6f54303435c9d6a6e88229d090523b4" translate="yes" xml:space="preserve">
          <source>Without that tag, the browser may not be able to load resources (images, CSS, scripts) when &quot;deep linking&quot; into the app. Bad things could happen when someone pastes an application link into the browser's address bar or clicks such a link in an email.</source>
          <target state="translated">해당 태그가 없으면 앱에 &quot;딥 링크&quot;할 때 브라우저가 리소스 (이미지, CSS, 스크립트)를로드하지 못할 수 있습니다. 누군가가 응용 프로그램 링크를 브라우저의 주소 표시 줄에 붙여 넣거나 전자 메일에서 해당 링크를 클릭하면 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="010c5880bd6415296c88290b8d4aadcb9cfb803c" translate="yes" xml:space="preserve">
          <source>Without those braces, JavaScript would only execute the first statement when you intend to conditionally execute all of them as a single block. The &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; satisfies a similar need in Angular templates.</source>
          <target state="translated">이러한 중괄호가 없으면 JavaScript는 모든 명령문을 단일 블록으로 조건부로 실행하려는 경우에만 첫 번째 명령문을 실행합니다. &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 만족 각도 템플릿에서 비슷한 필요성을.</target>
        </trans-unit>
        <trans-unit id="76958a0cd41a3ca4e5779435c35a550beb1958a9" translate="yes" xml:space="preserve">
          <source>WorkerAppModule</source>
          <target state="translated">WorkerAppModule</target>
        </trans-unit>
        <trans-unit id="01b0947f98451f2111dec9ae4e4392144c3513b4" translate="yes" xml:space="preserve">
          <source>Working around the browser APIs</source>
          <target state="translated">브라우저 API 해결</target>
        </trans-unit>
        <trans-unit id="2eb34458f36c3030ba79d7147278dcb7f42f56ba" translate="yes" xml:space="preserve">
          <source>Working on an implementation.</source>
          <target state="translated">구현 작업.</target>
        </trans-unit>
        <trans-unit id="6268699d3bbeb1ad3dd8fe27d8c8cd586c39fb67" translate="yes" xml:space="preserve">
          <source>Workspace and project configuration</source>
          <target state="translated">작업 공간 및 프로젝트 구성</target>
        </trans-unit>
        <trans-unit id="753540644098b968997d9756ca9f709602fc348a" translate="yes" xml:space="preserve">
          <source>Workspace and project file structure</source>
          <target state="translated">작업 공간 및 프로젝트 파일 구조</target>
        </trans-unit>
        <trans-unit id="c352c45f9dfd8d810dc06724fc085c520f1ecafa" translate="yes" xml:space="preserve">
          <source>Workspace configuration files</source>
          <target state="translated">작업 공간 구성 파일</target>
        </trans-unit>
        <trans-unit id="85aa6b445eca0c0cf6c798a83ec5dedaa7b66a19" translate="yes" xml:space="preserve">
          <source>Workspace npm dependencies</source>
          <target state="translated">작업 공간 npm 종속성</target>
        </trans-unit>
        <trans-unit id="5a0d418778672b7618a4ff2f76ab69dd1900780f" translate="yes" xml:space="preserve">
          <source>Workspaces and project files</source>
          <target state="translated">작업 공간 및 프로젝트 파일</target>
        </trans-unit>
        <trans-unit id="c4758386676c54543b72740b050edd6b5164b8d6" translate="yes" xml:space="preserve">
          <source>Wrap the form in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and bind its &lt;code&gt;hidden&lt;/code&gt; property to the &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; property.</source>
          <target state="translated">A의 양식을 감싸 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 바인딩의 &lt;code&gt;hidden&lt;/code&gt; 받는 재산 &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="16d56174bd7b0125fea2dcc2c06879628dc61f7b" translate="yes" xml:space="preserve">
          <source>Wrap the hero detail HTML in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. Add Angular's &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; directive to the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and set it to &lt;code&gt;selectedHero&lt;/code&gt;.</source>
          <target state="translated">영웅 세부 사항 HTML을 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 로 랩핑하십시오 . Angular의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 지시문을 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 추가 하고 &lt;code&gt;selectedHero&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="80af69bfe43ca69dcb3f2fb2aa59e64fa426c886" translate="yes" xml:space="preserve">
          <source>Wrap up and final app</source>
          <target state="translated">마무리 및 최종 앱</target>
        </trans-unit>
        <trans-unit id="27cf5d4683d47a0de40a3f27346a5f855469b310" translate="yes" xml:space="preserve">
          <source>Wrapped values are unwrapped automatically during the change detection, and the unwrapped value is stored.</source>
          <target state="translated">변경 감지 중에 랩핑 된 값은 자동으로 랩핑 해제되고 랩핑되지 않은 값이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b618e5b1103fc5a7e8d976cd3a42fcb09070c8d7" translate="yes" xml:space="preserve">
          <source>WrappedValue</source>
          <target state="translated">WrappedValue</target>
        </trans-unit>
        <trans-unit id="57b9cb2cebc443cd6088f1e833e85368057ca6eb" translate="yes" xml:space="preserve">
          <source>Wraps a function to be executed in the fakeAsync zone:</source>
          <target state="translated">fakeAsync 영역에서 실행될 함수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="22a50d995cd4156654361cd37c38f681e8d33b3b" translate="yes" xml:space="preserve">
          <source>Wraps a test function in an asynchronous test zone. The test will automatically complete when all asynchronous calls within this zone are done. Can be used to wrap an &lt;a href=&quot;inject&quot;&gt;&lt;code&gt;inject&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">테스트 기능을 비동기 테스트 영역에 래핑합니다. 이 영역 내에서 모든 비동기 호출이 완료되면 테스트가 자동으로 완료됩니다. 포장하는 데 사용할 수 있습니다 &lt;a href=&quot;inject&quot;&gt; &lt;code&gt;inject&lt;/code&gt; &lt;/a&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="100b402dceaf296612af0eb5e4e6515e25039258" translate="yes" xml:space="preserve">
          <source>Wraps a test function in an asynchronous test zone. The test will automatically complete when all asynchronous calls within this zone are done. Can be used to wrap an &lt;a href=&quot;testing/inject&quot;&gt;&lt;code&gt;inject&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">테스트 기능을 비동기 테스트 영역에 래핑합니다. 이 영역 내에서 모든 비동기 호출이 완료되면 테스트가 자동으로 완료됩니다. 포장하는 데 사용할 수 있습니다 &lt;a href=&quot;testing/inject&quot;&gt; &lt;code&gt;inject&lt;/code&gt; &lt;/a&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="ea8f25d1acfd326e0dad7d7c32fcc318bdf66542" translate="yes" xml:space="preserve">
          <source>Write DOM tests too</source>
          <target state="translated">DOM 테스트 작성</target>
        </trans-unit>
        <trans-unit id="a20cce9d728aa06f528fda67055ff0c86a09b2b3" translate="yes" xml:space="preserve">
          <source>Write a harness to try it</source>
          <target state="translated">그것을 시도 하네스를 작성</target>
        </trans-unit>
        <trans-unit id="a8d0c494c88477774037634897be250615132ba0" translate="yes" xml:space="preserve">
          <source>Write a second component that &lt;em&gt;binds&lt;/em&gt; the pipe's format parameter to the component's &lt;code&gt;format&lt;/code&gt; property. Here's the template for that component:</source>
          <target state="translated">파이프의 형식 매개 변수를 컴포넌트의 &lt;code&gt;format&lt;/code&gt; 특성에 &lt;em&gt;바인딩&lt;/em&gt; 하는 두 번째 컴포넌트를 작성하십시오 . 해당 구성 요소의 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c475564c93474169eccff5a8c6fbbae81a32d868" translate="yes" xml:space="preserve">
          <source>Write a structural directive</source>
          <target state="translated">구조적 지시문 작성</target>
        </trans-unit>
        <trans-unit id="0b5b915cb79464c96b638b4b04076ae4512fcc2b" translate="yes" xml:space="preserve">
          <source>Write a value to the element</source>
          <target state="translated">요소에 값을 씁니다</target>
        </trans-unit>
        <trans-unit id="50ab6e47b6478470b9f03185206a16d9f0dcd98d" translate="yes" xml:space="preserve">
          <source>Write an &lt;a href=&quot;dependency-injection-in-action#useexisting&quot;&gt;&lt;em&gt;alias provider&lt;/em&gt;&lt;/a&gt;&amp;mdash;a &lt;code&gt;provide&lt;/code&gt; object literal with a &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt; definition&amp;mdash;that creates an &lt;em&gt;alternative&lt;/em&gt; way to inject the same component instance and add that provider to the &lt;code&gt;providers&lt;/code&gt; array of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; metadata for the &lt;code&gt;AlexComponent&lt;/code&gt;.</source>
          <target state="translated">쓰기 &lt;a href=&quot;dependency-injection-in-action#useexisting&quot;&gt;&lt;em&gt;별명 제공&lt;/em&gt;&lt;/a&gt; -a &lt;code&gt;provide&lt;/code&gt; 하는 개체의 리터 2 &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt; 정의-있다는 생성 &lt;em&gt;대안&lt;/em&gt; 동일한 요소 인스턴스를 주입하고, 해당 업체를 추가하는 방법은 &lt;code&gt;providers&lt;/code&gt; 의 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 메타 데이터 &lt;code&gt;AlexComponent&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f03d8a78e9142ec11fa984d17b5bba0431278bdc" translate="yes" xml:space="preserve">
          <source>Write an interceptor</source>
          <target state="translated">인터셉터 작성</target>
        </trans-unit>
        <trans-unit id="11f4e18a688e5fb137dcbb0b8fc5b283a82a6f5a" translate="yes" xml:space="preserve">
          <source>Write one more impure pipe, a pipe that makes an HTTP request.</source>
          <target state="translated">HTTP 요청을하는 불순한 파이프를 하나 더 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="98d4c2f5112b9165b3d77fe1bbc4810bdb11e157" translate="yes" xml:space="preserve">
          <source>Write the directive code</source>
          <target state="translated">지시문 코드 작성</target>
        </trans-unit>
        <trans-unit id="328305f528e33187a05ed913c4cdfd6835ff639a" translate="yes" xml:space="preserve">
          <source>Write the first async &lt;code&gt;beforeEach&lt;/code&gt; like this.</source>
          <target state="translated">최초의 비동기 쓰기 &lt;code&gt;beforeEach&lt;/code&gt; 과 같이합니다.</target>
        </trans-unit>
        <trans-unit id="4a8c5b07a378d0e9997a7ab9a6bc9d3eb9fe12c2" translate="yes" xml:space="preserve">
          <source>Write the template</source>
          <target state="translated">템플릿 작성</target>
        </trans-unit>
        <trans-unit id="3460c1b32f74351fdabb7b72f175001fb3641df8" translate="yes" xml:space="preserve">
          <source>Write-Only</source>
          <target state="translated">Write-Only</target>
        </trans-unit>
        <trans-unit id="db8bc67982568e392f688d4f65b76786016e30fa" translate="yes" xml:space="preserve">
          <source>Writes a new value to the element.</source>
          <target state="translated">요소에 새로운 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a2cee97467095242641dce6e6e2e22f7a3d2d50a" translate="yes" xml:space="preserve">
          <source>Writing test functions with &lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt;, is more cumbersome than &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt;, but it is occasionally necessary when code involves the &lt;code&gt;intervalTimer()&lt;/code&gt; like &lt;code&gt;setInterval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt; 테스트 함수를 작성 하는 것은 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 보다 성가 시지만 , 코드에 &lt;code&gt;setInterval&lt;/code&gt; 과 같은 &lt;code&gt;intervalTimer()&lt;/code&gt; 포함되는 경우가 종종 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="869fbcd2d8f7216089e804c7e02a4532a37cae00" translate="yes" xml:space="preserve">
          <source>Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.</source>
          <target state="translated">템플릿 기반 양식을 사용하여 테스트를 작성하려면 변경 감지 프로세스에 대한 자세한 지식과 각주기에서 지시문이 실행되는 방식을 이해해야 요소가 올바른 시간에 쿼리, 테스트 또는 변경되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fba633555fbdefb41b26b54e2d1ae5197e6018a8" translate="yes" xml:space="preserve">
          <source>Writing this in full JavaScript can be quite involved. With observables, you can use a simple series of RxJS operators:</source>
          <target state="translated">이것을 완전한 JavaScript로 작성하는 것은 상당히 관련이 있습니다. 관찰 가능 항목을 사용하면 간단한 일련의 RxJS 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d7b693cbfc10c6be0691f24671f3dea15cd67fa" translate="yes" xml:space="preserve">
          <source>Writing variations of the same parent &lt;em&gt;alias provider&lt;/em&gt; gets old quickly, especially this awful mouthful with a &lt;a href=&quot;dependency-injection-in-action#forwardref&quot;&gt;&lt;em&gt;forwardRef&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">동일한 부모 &lt;em&gt;별명 제공자&lt;/em&gt; 의 변형을 작성하는 것은 특히 오래되었습니다. 특히 &lt;a href=&quot;dependency-injection-in-action#forwardref&quot;&gt;&lt;em&gt;forwardRef를&lt;/em&gt;&lt;/a&gt; 사용하면이 끔찍 합니다.</target>
        </trans-unit>
        <trans-unit id="6615fce0f673668cfcbf040e610b3f243f6a5f0f" translate="yes" xml:space="preserve">
          <source>Writing your own structural directives</source>
          <target state="translated">자신 만의 구조적 지시문 작성</target>
        </trans-unit>
        <trans-unit id="bda3d503ab6e71da4ecdc7ba9799876a869c7f5d" translate="yes" xml:space="preserve">
          <source>WtfScopeFn</source>
          <target state="translated">WtfScopeFn</target>
        </trans-unit>
        <trans-unit id="0bedb6a0b3ee1a4586748a1afd482fdab6cd810e" translate="yes" xml:space="preserve">
          <source>XLIFF 1.2 (default)</source>
          <target state="translated">XLIFF 1.2 (기본값)</target>
        </trans-unit>
        <trans-unit id="7ac17d1faac505f349f9755e05f6be22993a3065" translate="yes" xml:space="preserve">
          <source>XLIFF 2</source>
          <target state="translated">XLIFF 2</target>
        </trans-unit>
        <trans-unit id="09d92a1a0c75cee4b1621a6ca1a7fc5f5e596627" translate="yes" xml:space="preserve">
          <source>XLIFF files have the extension .xlf. The XMB format generates .xmb source files but uses .xtb (XML Translation Bundle: XTB) translation files.</source>
          <target state="translated">XLIFF 파일의 확장자는 .xlf입니다. XMB 형식은 .xmb 소스 파일을 생성하지만 .xtb (XML 변환 번들 : XTB) 변환 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d6931c6ae08210e1032ff16fc8dc25545ff4dd5" translate="yes" xml:space="preserve">
          <source>XML Message Bundle (XMB)</source>
          <target state="translated">XML 메시지 번들 (XMB)</target>
        </trans-unit>
        <trans-unit id="599e87f8ed02dd15253f65e02b7486f06eafc4c7" translate="yes" xml:space="preserve">
          <source>XSRF protection</source>
          <target state="translated">XSRF 보호</target>
        </trans-unit>
        <trans-unit id="6fd5227911e073f0f3b8abbe36af4c0966e7d31e" translate="yes" xml:space="preserve">
          <source>XhrFactory</source>
          <target state="translated">XhrFactory</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="d7d90dedbe56729ff46d489e7ed07371a54fa88f" translate="yes" xml:space="preserve">
          <source>Yes (Guards)</source>
          <target state="translated">예 (가드)</target>
        </trans-unit>
        <trans-unit id="507cb15cae91e9b102e4c4639f56689d54efb2b2" translate="yes" xml:space="preserve">
          <source>Yet another is setting the model property of a custom component&amp;mdash;a great way for parent and child components to communicate:</source>
          <target state="translated">또 다른 방법은 부모 및 자식 구성 요소가 통신 할 수있는 좋은 방법 인 사용자 지정 구성 요소의 모델 속성을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5184f834d5e61356c1186f5476ca3e95650f0f36" translate="yes" xml:space="preserve">
          <source>Yet any test that creates the &lt;code&gt;AppComponent&lt;/code&gt; in the DOM will also create instances of these three components and, if you let that happen, you'll have to configure the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; to create them.</source>
          <target state="translated">그러나 DOM 에서 &lt;code&gt;AppComponent&lt;/code&gt; 를 생성하는 테스트 는 이러한 세 가지 구성 요소의 인스턴스도 생성하며,이를 허용하면 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 구성하여 구성 해야합니다.</target>
        </trans-unit>
        <trans-unit id="09c5b3c020b8419aa1859d0421105d3bc9f79c89" translate="yes" xml:space="preserve">
          <source>You &lt;a href=&quot;dependency-injection-in-action#class-interface&quot;&gt;learned earlier&lt;/a&gt; that a class interface is an abstract class used as an interface rather than as a base class.</source>
          <target state="translated">당신은 &lt;a href=&quot;dependency-injection-in-action#class-interface&quot;&gt;이전에 배운&lt;/a&gt; 클래스 인터페이스는 인터페이스가 아닌 기본 클래스로 사용되는 추상 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9eb8bdd95a2a0842fc38fcf43de28230ccdaaa64" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; export any declarable class&amp;mdash;components, directives, and pipes&amp;mdash;whether it's declared in this NgModule or in an imported NgModule.</source>
          <target state="translated">선언 된 클래스 (구성 요소, 지시문 및 파이프)를이 NgModule 또는 가져온 NgModule에 선언했는지 여부에 관계없이 내보낼 수 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="787ea929d005d74a273414ae116216e5df9c88b8" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; re-export entire imported NgModules, which effectively re-exports all of their exported classes. An NgModule can even export a module that it doesn't import.</source>
          <target state="translated">당신은 &lt;em&gt;할 수&lt;/em&gt; 다시 수출 전체 효율적으로 모든 수출 클래스의-수출을 다시 가져 NgModules을. NgModule은 가져 오지 않은 모듈을 내보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53efccf4d2256507a396e122e4b6a85b6cb4087d" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; add this provider directly to the providers array of the &lt;code&gt;AppModule&lt;/code&gt;. However, it's rather verbose and there's a good chance that you'll create more interceptors and provide them in the same way. You must also pay &lt;a href=&quot;http#interceptor-order&quot;&gt;close attention to the order&lt;/a&gt; in which you provide these interceptors.</source>
          <target state="translated">당신은 &lt;em&gt;수&lt;/em&gt; 의 공급자 배열에 직접 공급자를 추가 &lt;code&gt;AppModule&lt;/code&gt; . 그러나 다소 장황하며 더 많은 인터셉터를 만들고 동일한 방식으로 제공 할 가능성이 큽니다. 또한 이러한 인터셉터를 제공 &lt;a href=&quot;http#interceptor-order&quot;&gt;하는 순서&lt;/a&gt; 에 주의를 기울여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b85a893fd767c61c0814c4709da16cc28cf81f13" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; handle in the component by adding a second callback to the &lt;code&gt;.subscribe()&lt;/code&gt;:</source>
          <target state="translated">당신은 &lt;em&gt;할 수&lt;/em&gt; 에 두 번째 콜백을 추가하여 구성 요소에서 처리 &lt;code&gt;.subscribe()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83686f5d76aa5b58d68b9684ddb16975afa647d0" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;import&lt;/em&gt; other NgModules so you can use their exported classes in component templates. You &lt;em&gt;export&lt;/em&gt; this NgModule's classes so they can be imported and used by components of &lt;em&gt;other&lt;/em&gt; NgModules.</source>
          <target state="translated">당신은 &lt;em&gt;가져&lt;/em&gt; 당신이 구성 요소 템플릿에 자신의 수출 클래스를 사용할 수 있도록 다른 NgModules합니다. 당신은 &lt;em&gt;수출&lt;/em&gt; 들은 수입의 구성 요소에서 사용할 수 있도록이 NgModule의 클래스를 &lt;em&gt;다른&lt;/em&gt; NgModules.</target>
        </trans-unit>
        <trans-unit id="09c14240b7508350608a5ba18e2c5814bd0a661d" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;may&lt;/em&gt; also be able to get the service from the root injector via &lt;code&gt;TestBed.get()&lt;/code&gt;. This is easier to remember and less verbose. But it only works when Angular injects the component with the service instance in the test's root injector.</source>
          <target state="translated">당신은 &lt;em&gt;할 수있다&lt;/em&gt; 또한을 통해 루트 인젝터에서 서비스를받을 수 &lt;code&gt;TestBed.get()&lt;/code&gt; . 이것은 기억하기 쉽고 덜 장황하다. 그러나 Angular가 테스트의 루트 인젝터에서 서비스 인스턴스로 구성 요소를 주입 할 때만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8602a4c4173ea23f45ba3fcc342dec01b1dabf44" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;should&lt;/em&gt; omit the brackets when all of the following are true:</source>
          <target state="translated">당신은 &lt;em&gt;해야&lt;/em&gt; 다음 모두에 해당하면 괄호를 생략 :</target>
        </trans-unit>
        <trans-unit id="e6278239350d29c6aa9b279ad51935f18b8320d6" translate="yes" xml:space="preserve">
          <source>You achieve this effect by adding these class definitions to a new &lt;code&gt;forms.css&lt;/code&gt; file that you add to the project as a sibling to &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">이러한 클래스 정의 를 &lt;code&gt;index.html&lt;/code&gt; 의 형제로 프로젝트에 추가 하는 새 &lt;code&gt;forms.css&lt;/code&gt; 파일 에 추가하여이 효과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="ca6798fadac41315d6be90467029b23c51b0bdf9" translate="yes" xml:space="preserve">
          <source>You add &lt;em&gt;guards&lt;/em&gt; to the route configuration to handle these scenarios.</source>
          <target state="translated">이러한 시나리오를 처리하기 위해 경로 구성에 &lt;em&gt;보호&lt;/em&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="8d6bbb540bb935e899c2208f09a1d394e5d0ac6c" translate="yes" xml:space="preserve">
          <source>You add context by beginning the &lt;code&gt;i18n&lt;/code&gt; attribute value with the &lt;em&gt;meaning&lt;/em&gt; and separating it from the &lt;em&gt;description&lt;/em&gt; with the &lt;code&gt;|&lt;/code&gt; character: &lt;code&gt;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;의미로 &lt;/em&gt; &lt;code&gt;i18n&lt;/code&gt; 속성 값을 시작 하고 &lt;code&gt;|&lt;/code&gt; &lt;em&gt;설명을&lt;/em&gt; 사용하여 &lt;em&gt;설명&lt;/em&gt; 에서 분리 하여 컨텍스트를 추가 합니다. 캐릭터 : &lt;code&gt;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3430c566917b8b85e306dc99e17ab8c6aa42b22" translate="yes" xml:space="preserve">
          <source>You add the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; to the list of &lt;code&gt;imports&lt;/code&gt; defined in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator. This gives the application access to all of the template-driven forms features, including &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; 데코레이터에 정의 된 &lt;code&gt;imports&lt;/code&gt; 목록에 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 추가합니다 . 이를 통해 응용 프로그램은 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 포함한 모든 템플릿 기반 양식 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="438bdad8fdf45e3082ebef8f1d0b53feb1474fc0" translate="yes" xml:space="preserve">
          <source>You add the hero into the &lt;code&gt;heroes&lt;/code&gt; array. The reference to the array hasn't changed. It's the same array. That's all Angular cares about. From its perspective, &lt;em&gt;same array, no change, no display update&lt;/em&gt;.</source>
          <target state="translated">영웅을 &lt;code&gt;heroes&lt;/code&gt; 배열에 추가합니다 . 배열에 대한 참조는 변경되지 않았습니다. 같은 배열입니다. 이것이 Angular의 모든 관심사입니다. 관점에서 볼 때 &lt;em&gt;동일한 배열, 변경 사항 없음, 디스플레이 업데이트 없음&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca70762d285d9a3feb0f42adf3ad26cf94a9f1b" translate="yes" xml:space="preserve">
          <source>You added a &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; guard to the route in the &lt;code&gt;AdminModule&lt;/code&gt; a few steps back to block loading of that module until the user is authorized. That &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; guard takes precedence over the preload strategy.</source>
          <target state="translated">사용자에게 권한이 부여 될 때까지 해당 모듈의로드를 차단하기 위해 몇 단계 전에 &lt;code&gt;AdminModule&lt;/code&gt; 의 경로에 &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; 가드를 추가했습니다 . 해당 &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; 가드는 사전로드 전략보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="c7f1f5fee6b108edd5d8482048cf967be2ffe741" translate="yes" xml:space="preserve">
          <source>You added a &lt;code&gt;diagnostic&lt;/code&gt; property to return a JSON representation of the model. It'll help you see what you're doing during development; you've left yourself a cleanup note to discard it later.</source>
          <target state="translated">모델의 JSON 표현을 리턴하기 위해 &lt;code&gt;diagnostic&lt;/code&gt; 특성을 추가했습니다 . 개발하는 동안 무엇을하고 있는지 알 수 있습니다. 나중에 버릴 정리 메모를 남겼습니다.</target>
        </trans-unit>
        <trans-unit id="6b2cd77924cadb7ab1174142cd5459f8db5909c1" translate="yes" xml:space="preserve">
          <source>You added a &lt;em&gt;Submit&lt;/em&gt; button at the bottom with some classes on it for styling.</source>
          <target state="translated">스타일링을 위해 클래스와 함께 &lt;em&gt;제출&lt;/em&gt; 단추를 맨 아래에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="361569c7fe3d5fe1eec3f680494febf8867dddc2" translate="yes" xml:space="preserve">
          <source>You added a diagnostic interpolation after the input tag so you can see what you're doing. You left yourself a note to throw it away when you're done.</source>
          <target state="translated">입력 태그 뒤에 진단 보간을 추가하여 수행중인 작업을 확인할 수 있습니다. 끝났을 때 버리라는 메모를 남겼습니다.</target>
        </trans-unit>
        <trans-unit id="cad9e1c57dbea9ac68e5f90137a78136490ac8aa" translate="yes" xml:space="preserve">
          <source>You added a header to tell the reader where to find the file by setting the &lt;code&gt;header&lt;/code&gt; attribute. Following convention, you set the &lt;code&gt;header&lt;/code&gt; attribute to the file's location within the sample's root folder.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 속성 을 설정하여 파일을 찾을 위치를 리더에게 알리기 위해 헤더를 추가했습니다 . 규칙에 따라 &lt;code&gt;header&lt;/code&gt; 속성을 샘플 루트 폴더 내의 파일 위치로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7797833099f6da73568d1a71b02ca4c623672629" translate="yes" xml:space="preserve">
          <source>You added the &lt;code&gt;id&lt;/code&gt; of the &lt;em&gt;Dragon Crisis&lt;/em&gt; as the second item in the array (&lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;드래곤 위기&lt;/em&gt; 의 &lt;code&gt;id&lt;/code&gt; 를 배열의 두 번째 항목으로 추가했습니다 ( &lt;code&gt;1&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70027f72129f3cc67318ed5489214e1c09ac777e" translate="yes" xml:space="preserve">
          <source>You added the Angular router to navigate among different components.</source>
          <target state="translated">다른 구성 요소를 탐색하기 위해 Angular 라우터를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="55e3767f013032dca85f37dcfbbb03f3c20ed728" translate="yes" xml:space="preserve">
          <source>You added the necessary dependencies to use HTTP in the app.</source>
          <target state="translated">앱에서 HTTP를 사용하는 데 필요한 종속성을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="b80bca51135e569f2275ee3e366cf402ec3c1fd9" translate="yes" xml:space="preserve">
          <source>You added two properties to the formerly empty component: &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;myHero&lt;/code&gt;.</source>
          <target state="translated">이전에 비어있는 구성 요소에 &lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;myHero&lt;/code&gt; 의 두 가지 특성을 추가 했습니다 .</target>
        </trans-unit>
        <trans-unit id="7546ffdac7d49a159cc2a7bfd8a978c1ac8ae6e9" translate="yes" xml:space="preserve">
          <source>You also added a button to the template and bound its click event to the component's &lt;code&gt;toggleFormat()&lt;/code&gt; method. That method toggles the component's &lt;code&gt;format&lt;/code&gt; property between a short form (&lt;code&gt;'shortDate'&lt;/code&gt;) and a longer form (&lt;code&gt;'fullDate'&lt;/code&gt;).</source>
          <target state="translated">또한 템플릿에 버튼을 추가하고 해당 클릭 이벤트를 구성 요소의 &lt;code&gt;toggleFormat()&lt;/code&gt; 메서드에 바인딩했습니다 . 이 메서드는 구성 요소의 &lt;code&gt;format&lt;/code&gt; 속성을 짧은 형식 ( &lt;code&gt;'shortDate'&lt;/code&gt; )과 긴 형식 ( &lt;code&gt;'fullDate'&lt;/code&gt; ) 간에 전환합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce0e1b0da9f5a59dd44832d0898a715f4653bdb" translate="yes" xml:space="preserve">
          <source>You also can add a meaning, as shown in this example:</source>
          <target state="translated">이 예에 표시된 것처럼 의미를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b2632ca3271e0f77756a23cb72af8d5bb04a25" translate="yes" xml:space="preserve">
          <source>You also can assign a meaning, description, and id with the &lt;code&gt;i18n-x=&quot;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;@@&amp;lt;id&amp;gt;&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;i18n-x=&quot;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;@@&amp;lt;id&amp;gt;&quot;&lt;/code&gt; 구문을 사용 하여 의미, 설명 및 id를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10a98da0cae7c6adb8bd68337d54cdb31a63cea8" translate="yes" xml:space="preserve">
          <source>You also get this error if you call a function or method in a provider's &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공급자의 &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt; 에서 함수 또는 메서드를 호출하면이 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2089b8dae07d8e82ca84631e97bd1bbb16dd5f08" translate="yes" xml:space="preserve">
          <source>You also have a CSS style rule that happens to apply to a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; within a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;aragraph.</source>
          <target state="translated">&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; aragraph 내의 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 에 적용되는 CSS 스타일 규칙도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b5c030003397159acdb465424b902cba7eb3348" translate="yes" xml:space="preserve">
          <source>You also import NgModules from Angular &lt;em&gt;libraries&lt;/em&gt; using JavaScript import statements. For example, the following code imports the &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; NgModule from the &lt;code&gt;platform-browser&lt;/code&gt; library.</source>
          <target state="translated">JavaScript import 문을 사용하여 Angular &lt;em&gt;라이브러리&lt;/em&gt; 에서 NgModules를 가져올 수도 있습니다 . 예를 들어 다음 코드 는 &lt;code&gt;platform-browser&lt;/code&gt; 라이브러리 에서 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; NgModule을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="80df427e4dcb3187ce4d09900c34780b3fa685e0" translate="yes" xml:space="preserve">
          <source>You also need to install the &lt;code&gt;@angular/upgrade&lt;/code&gt; package via &lt;code&gt;npm install @angular/upgrade --save&lt;/code&gt; and add a mapping for the &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; package:</source>
          <target state="translated">또한 &lt;code&gt;npm install @angular/upgrade --save&lt;/code&gt; 를 통해 &lt;code&gt;@angular/upgrade&lt;/code&gt; 패키지를 설치 하고 &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 패키지 에 대한 매핑을 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="29781a32c599c88be9b3977e94a9fdb2f316fc17" translate="yes" xml:space="preserve">
          <source>You also need to make a couple of adjustments to the &lt;code&gt;systemjs.config.js&lt;/code&gt; file installed during &lt;a href=&quot;upgrade-setup&quot;&gt;upgrade setup&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;upgrade-setup&quot;&gt;업그레이드 설정&lt;/a&gt; 중에 설치된 &lt;code&gt;systemjs.config.js&lt;/code&gt; 파일 을 몇 가지 조정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8555706e03df7109f8967d156364f0a6dc13a6a4" translate="yes" xml:space="preserve">
          <source>You also need to pass the generated &lt;code&gt;MainAngularModuleFactory&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; instead of the custom bootstrap function:</source>
          <target state="translated">또한 사용자 정의 부트 스트랩 함수 대신 생성 된 &lt;code&gt;MainAngularModuleFactory&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 로 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ad188e1c952ebf71da0537e0d4585377e064e1f1" translate="yes" xml:space="preserve">
          <source>You always import the &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; symbol from the Angular core library and annotate the component class with &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">항상 Angular 코어 라이브러리에서 &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 기호를 가져오고 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 컴포넌트 클래스에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9333b7537e83c795a95ae1a57e1fff6c4a74f8" translate="yes" xml:space="preserve">
          <source>You appear to be inserting the result between element tags and assigning it to attributes. However, interpolation is a special syntax that Angular converts into a &lt;em&gt;property binding&lt;/em&gt;.</source>
          <target state="translated">요소 태그 사이에 결과를 삽입하여 속성에 할당 한 것으로 보입니다. 그러나 보간은 Angular가 &lt;em&gt;속성 바인딩&lt;/em&gt; 으로 변환하는 특수 구문입니다 .</target>
        </trans-unit>
        <trans-unit id="5a7e393cc3d71ada2d51725c68312b4ec17e75c0" translate="yes" xml:space="preserve">
          <source>You applied the &lt;code&gt;UppercasePipe&lt;/code&gt; to format the name.</source>
          <target state="translated">&lt;code&gt;UppercasePipe&lt;/code&gt; 를 적용하여 이름을 형식화했습니다.</target>
        </trans-unit>
        <trans-unit id="f5ed36a67e5c64f7e17a2572545a399b3efa1ad5" translate="yes" xml:space="preserve">
          <source>You are about to break up the app into different &lt;em&gt;feature modules&lt;/em&gt;, each with its own concerns. Then you'll import into the main module and navigate among them.</source>
          <target state="translated">각각 고유 한 관심사를 가진 앱을 여러 &lt;em&gt;기능 모듈&lt;/em&gt; 로 분할하려고합니다 . 그런 다음 메인 모듈로 가져 와서 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="e2970b459e19dea069d0b7a89007485bb9215544" translate="yes" xml:space="preserve">
          <source>You are in effect saying, &lt;em&gt;when the user clicks this link, display the component associated with the &lt;code&gt;compose&lt;/code&gt; route in the &lt;code&gt;popup&lt;/code&gt; outlet&lt;/em&gt;.</source>
          <target state="translated">실제로 &lt;em&gt;사용자가이 링크를 클릭 하면 &lt;code&gt;popup&lt;/code&gt; 콘센트 에 &lt;code&gt;compose&lt;/code&gt; 경로 와 연관된 구성 요소가 표시됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="102f041c09d56efa28154c4310d8010c538086e8" translate="yes" xml:space="preserve">
          <source>You are now an Angular developer! &lt;a href=&quot;https://twitter.com/intent/tweet?url=https://angular.io/start&amp;amp;text=I%20just%20finished%20the%20Angular%20Getting%20Started%20Tutorial&quot;&gt;Share this moment&lt;/a&gt;, tell us what you thought of this Getting Started, or submit &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;suggestions for future editions&lt;/a&gt;.</source>
          <target state="translated">이제 Angular 개발자입니다! &lt;a href=&quot;https://twitter.com/intent/tweet?url=https://angular.io/start&amp;amp;text=I%20just%20finished%20the%20Angular%20Getting%20Started%20Tutorial&quot;&gt;이 순간을 공유하고&lt;/a&gt; , 시작하기에 &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;대한 의견을&lt;/a&gt; 알려주거나 향후 개정판에 대한 제안을 제출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d491e7cb90554a81c9e013fa43d65daa0885c8cb" translate="yes" xml:space="preserve">
          <source>You are now running a pure Angular application!</source>
          <target state="translated">이제 순수한 Angular 응용 프로그램을 실행하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="7cdcb9196438a46fde40f714f28ea46a2eda0776" translate="yes" xml:space="preserve">
          <source>You begin by creating an initial application using the Angular CLI. Throughout this tutorial, you&amp;rsquo;ll modify and extend that starter application to create the Tour of Heroes app.</source>
          <target state="translated">Angular CLI를 사용하여 초기 애플리케이션을 작성하여 시작하십시오. 이 자습서에서는 해당 시작 응용 프로그램을 수정 및 확장하여 Tour of Heroes 앱을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="81c902f92fef1f4a20873ab5f68ce68a50ae4af5" translate="yes" xml:space="preserve">
          <source>You can &lt;em&gt;upgrade&lt;/em&gt; this component to Angular using the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; class. By creating a new Angular &lt;strong&gt;directive&lt;/strong&gt; that extends &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; and doing a &lt;code&gt;super&lt;/code&gt; call inside its constructor, you have a fully upgraded AngularJS component to be used inside Angular. All that is left is to add it to &lt;code&gt;AppModule&lt;/code&gt;'s &lt;code&gt;declarations&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여이 구성 요소를 Angular로 &lt;em&gt;업그레이드&lt;/em&gt; 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; 를 확장 하는 새로운 Angular &lt;strong&gt;지시문&lt;/strong&gt; 을 만들고 생성자 내 에서 &lt;code&gt;super&lt;/code&gt; 호출을 수행하면 Angular 내에서 사용할 완전히 업그레이드 된 AngularJS 구성 요소가 있습니다. 남은 것은 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;declarations&lt;/code&gt; 배열 에 추가하는 것 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="20998ab36110d70249d73d4c59eba8c8f430ac99" translate="yes" xml:space="preserve">
          <source>You can achieve the same effect by putting the label between the &lt;code&gt;&amp;lt;live-example&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">&lt;code&gt;&amp;lt;live-example&amp;gt;&lt;/code&gt; 태그 사이에 레이블을 넣어 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a976e450ce6baa257a935451c00a03775ec464f6" translate="yes" xml:space="preserve">
          <source>You can add a &lt;code&gt;styles&lt;/code&gt; array property to the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터에 &lt;code&gt;styles&lt;/code&gt; 배열 속성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8b236444d154157691e47dd5ec8758e169dd7b3" translate="yes" xml:space="preserve">
          <source>You can add a custom user ID to the global configuration, in order to identify unique usage of commands and flags. If that user enables CLI analytics for their own project, your analytics display tracks and labels their individual usage.</source>
          <target state="translated">명령 및 플래그의 고유 한 사용법을 식별하기 위해 글로벌 구성에 사용자 정의 사용자 ID를 추가 할 수 있습니다. 해당 사용자가 자신의 프로젝트에 대해 CLI 분석을 활성화하면 분석 디스플레이가 개별 사용량을 추적하고 레이블을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c41d8625f722b6d12ab3d0d9d1fd15eab13e8f61" translate="yes" xml:space="preserve">
          <source>You can add a description of the text message as the value of the &lt;code&gt;i18n&lt;/code&gt; attribute, as shown in the example below:</source>
          <target state="translated">아래 예와 같이 문자 메시지에 대한 설명을 &lt;code&gt;i18n&lt;/code&gt; 속성 값으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a548aa6072e8a5f389f60ba7255c8c982ed70fb" translate="yes" xml:space="preserve">
          <source>You can add a named schematic to your collection that lets your users use the &lt;code&gt;ng generate&lt;/code&gt; command to create an artifact that is defined in your library.</source>
          <target state="translated">컬렉션에 명명 된 회로도를 추가하여 사용자가 &lt;code&gt;ng generate&lt;/code&gt; 명령을 사용하여 라이브러리에 정의 된 아티팩트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="804aa402eea0a5f3636f449289ff3d8e1c5d5070" translate="yes" xml:space="preserve">
          <source>You can add a web worker anywhere in your application. If the file that contains your expensive computation is &lt;code&gt;src/app/app.component.ts&lt;/code&gt;, you can add a Web Worker using &lt;code&gt;ng generate web-worker app&lt;/code&gt;.</source>
          <target state="translated">애플리케이션의 어느 곳에 나 웹 워커를 추가 할 수 있습니다. 값 비싼 계산이 포함 된 파일이 &lt;code&gt;src/app/app.component.ts&lt;/code&gt; 인 경우 &lt;code&gt;ng generate web-worker app&lt;/code&gt; 을 사용하여 웹 워커를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c35cf3736ef659ee5c6923017457205d7fff81b0" translate="yes" xml:space="preserve">
          <source>You can add additional configurations as required. To add a staging environment, create a copy of &lt;code&gt;src/environments/environment.ts&lt;/code&gt; called &lt;code&gt;src/environments/environment.staging.ts&lt;/code&gt;, then add a &lt;code&gt;staging&lt;/code&gt; configuration to &lt;code&gt;angular.json&lt;/code&gt;:</source>
          <target state="translated">필요에 따라 추가 구성을 추가 할 수 있습니다. 스테이징 환경을 추가하려면 &lt;code&gt;src/environments/environment.ts&lt;/code&gt; 라는 &lt;code&gt;src/environments/environment.staging.ts&lt;/code&gt; 사본을 작성한 후 &lt;code&gt;angular.json&lt;/code&gt; 에 &lt;code&gt;staging&lt;/code&gt; 구성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d0cdd4cae89177221a5eb596d76443fb9dc5975" translate="yes" xml:space="preserve">
          <source>You can add heroes and Angular updates the display when you do. If you click the &lt;code&gt;reset&lt;/code&gt; button, Angular replaces &lt;code&gt;heroes&lt;/code&gt; with a new array of the original heroes and updates the display. If you added the ability to remove or change a hero, Angular would detect those changes and update the display as well.</source>
          <target state="translated">할 때 영웅을 추가하고 디스플레이를 업데이트 할 수 있습니다. &lt;code&gt;reset&lt;/code&gt; 버튼 을 클릭하면 Angular는 &lt;code&gt;heroes&lt;/code&gt; 을 새로운 원본 영웅으로 교체 하고 디스플레이를 업데이트합니다. 영웅을 제거하거나 변경하는 기능을 추가하면 Angular는 이러한 변경 사항을 감지하고 디스플레이도 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f9da851a0ebf29126cb8c0a95f65d2989eaf1228" translate="yes" xml:space="preserve">
          <source>You can add interceptors to the chain behind &lt;code&gt;&lt;a href=&quot;httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; by binding them to the multiprovider for built-in &lt;a href=&quot;../../../guide/glossary#di-token&quot;&gt;DI token&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;http_interceptors&quot;&gt;HTTP_INTERCEPTORS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내장 &lt;a href=&quot;../../../guide/glossary#di-token&quot;&gt;DI 토큰 &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;http_interceptors&quot;&gt;HTTP_INTERCEPTORS&lt;/a&gt;&lt;/code&gt; 의 멀티 프로 바이더 에 인터셉터를 바인딩하여 &lt;code&gt;&lt;a href=&quot;httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 뒤의 체인에 인터셉터를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f0aadeba9307e5167e25a0728630eec62b5fc43" translate="yes" xml:space="preserve">
          <source>You can add many more outlets and routes, at the top level and in nested levels, creating a navigation tree with many branches. The router will generate the URL to go with it.</source>
          <target state="translated">최상위 레벨과 중첩 레벨에서 더 많은 콘센트와 경로를 추가하여 많은 분기가있는 탐색 트리를 만들 수 있습니다. 라우터는 함께 갈 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2b46fe91e4d8999030b4a841fb198dd2c9bbb590" translate="yes" xml:space="preserve">
          <source>You can add more configuration options to this target environment as well. Any option that your build supports can be overridden in a build target configuration.</source>
          <target state="translated">이 대상 환경에 더 많은 구성 옵션을 추가 할 수 있습니다. 빌드 대상 구성에서 빌드가 지원하는 모든 옵션을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="624073ff88178c49ce6ac9f3f53dc62b5ef55ce0" translate="yes" xml:space="preserve">
          <source>You can add or remove an element from the DOM by applying an &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; directive to a host element. Bind the directive to a condition expression like &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; in this example.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 지시문을 호스트 요소 에 적용하여 DOM에서 요소를 추가하거나 제거 할 수 있습니다 . 이 예제에서 지시문을 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; 와 같은 조건식에 바인딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9314d95d3d912f79fd878707764d9ea61a6b87" translate="yes" xml:space="preserve">
          <source>You can add or remove plural cases, with each language having its own cardinality. (See &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html&quot;&gt;CLDR plural rules&lt;/a&gt;.)</source>
          <target state="translated">각 언어마다 고유 한 카디널리티가있는 복수 사례를 추가하거나 제거 할 수 있습니다. ( &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html&quot;&gt;CLDR 복수 규칙을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3eb016549380e1871f3b0d3d837dfe5451882379" translate="yes" xml:space="preserve">
          <source>You can add target-specific configuration files, such as &lt;code&gt;environment.prod.ts&lt;/code&gt;. The following sets content sets default values for the production build target:</source>
          <target state="translated">&lt;code&gt;environment.prod.ts&lt;/code&gt; 와 같은 대상별 구성 파일을 추가 할 수 있습니다 . 다음은 컨텐츠가 프로덕션 빌드 대상의 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c9a1d641689d7ce9b785cf821dfd72080140b408" translate="yes" xml:space="preserve">
          <source>You can also add &lt;em&gt;optional&lt;/em&gt; information to a route request. For example, when returning to the hero-detail.component.ts list from the hero detail view, it would be nice if the viewed hero was preselected in the list.</source>
          <target state="translated">경로 요청에 &lt;em&gt;선택적&lt;/em&gt; 정보를 추가 할 수도 있습니다 . 예를 들어, 영웅 상세보기에서 hero-detail.component.ts 목록으로 돌아갈 때, 조회 된 영웅이 목록에서 미리 선택되어 있으면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5759614dda58e9a847b95f8209881d0ee2692b09" translate="yes" xml:space="preserve">
          <source>You can also add a &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; method in the &lt;code&gt;GreetingModule&lt;/code&gt; that configures the greeting &lt;code&gt;UserService&lt;/code&gt;.</source>
          <target state="translated">인사말 &lt;code&gt;UserService&lt;/code&gt; 를 구성하는 &lt;code&gt;GreetingModule&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 메서드를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a526b25408266d3968827df1221d6347e7f6b85" translate="yes" xml:space="preserve">
          <source>You can also add append a class to an element without overwriting the classes already on the element:</source>
          <target state="translated">요소에 이미있는 클래스를 덮어 쓰지 않고 요소에 클래스를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb6f621b2e971f7bf9abb6ff993457b4191a15a" translate="yes" xml:space="preserve">
          <source>You can also apply an &lt;code&gt;NgFor&lt;/code&gt; to a component element, as in the following example.</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;NgFor&lt;/code&gt; 를 구성 요소에 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bed0049739f1e932b1f46657a5c193451b2bba9" translate="yes" xml:space="preserve">
          <source>You can also configure the &lt;code&gt;serve&lt;/code&gt; command to use the targeted build configuration if you add it to the &quot;serve:configurations&quot; section of &lt;code&gt;angular.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;angular.json&lt;/code&gt; 의 &quot;serve : configurations&quot;섹션에 대상 빌드 구성을 추가 한 경우 대상 빌드 구성을 사용 &lt;code&gt;serve&lt;/code&gt; 명령을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e55eaa66fa3c788b5a42077334a80ec5aa552608" translate="yes" xml:space="preserve">
          <source>You can also create HTTP parameters directly from a query string by using the &lt;code&gt;fromString&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;fromString&lt;/code&gt; 변수 를 사용하여 쿼리 문자열에서 직접 HTTP 매개 변수를 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb31cb6aa4a816fa40c42f7a6a8064d99b7ca9e3" translate="yes" xml:space="preserve">
          <source>You can also define a custom builder, and add a target to the project configuration that uses your custom builder. You can then run the target using the &lt;a href=&quot;cli/run&quot;&gt;&lt;code&gt;ng run&lt;/code&gt;&lt;/a&gt; CLI command.</source>
          <target state="translated">사용자 정의 빌더를 정의하고 사용자 정의 빌더를 사용하는 프로젝트 구성에 대상을 추가 할 수도 있습니다. 그런 다음 &lt;a href=&quot;cli/run&quot;&gt; &lt;code&gt;ng run&lt;/code&gt; &lt;/a&gt; CLI 명령을 사용하여 대상을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ef2b8d18e1c53c75e1aec40dd395cf2864bc75c" translate="yes" xml:space="preserve">
          <source>You can also do this in AngularJS, using &lt;em&gt;component directives&lt;/em&gt;. These are directives that define their own templates, controllers, and input/output bindings - the same things that Angular components define. Applications built with component directives are much easier to migrate to Angular than applications built with lower-level features like &lt;code&gt;ng-controller&lt;/code&gt;, &lt;code&gt;ng-include&lt;/code&gt;, and scope inheritance.</source>
          <target state="translated">&lt;em&gt;component 지시문을&lt;/em&gt; 사용하여 AngularJS에서도이를 수행 할 수 있습니다 . 이것들은 Angular 컴포넌트가 정의하는 것과 같은 자체 템플릿, 컨트롤러 및 입력 / 출력 바인딩을 정의하는 지시문입니다. 구성 요소 지시문으로 작성된 응용 프로그램은 &lt;code&gt;ng-controller&lt;/code&gt; , &lt;code&gt;ng-include&lt;/code&gt; 및 범위 상속과 같은 하위 수준 기능으로 작성된 응용 프로그램보다 Angular로 마이그레이션하기가 훨씬 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="d59f82a05714d92030f73af63da0c791cf2c2cc9" translate="yes" xml:space="preserve">
          <source>You can also experience and download the .</source>
          <target state="translated">을 체험하고 다운로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aef1bbcbbd5075a517ac29931b7d7add135f643" translate="yes" xml:space="preserve">
          <source>You can also find the most current version of Angular by using the CLI command &lt;a href=&quot;cli/update&quot;&gt;&lt;code&gt;ng update&lt;/code&gt;&lt;/a&gt;. By default, &lt;a href=&quot;cli/update&quot;&gt;&lt;code&gt;ng update&lt;/code&gt;&lt;/a&gt;(without additional arguments) lists the updates that are available to you.</source>
          <target state="translated">CLI 명령 &lt;a href=&quot;cli/update&quot;&gt; &lt;code&gt;ng update&lt;/code&gt; 를&lt;/a&gt; 사용하여 최신 버전의 Angular를 찾을 수도 있습니다 . 기본적으로 &lt;a href=&quot;cli/update&quot;&gt; &lt;code&gt;ng update&lt;/code&gt; &lt;/a&gt; (추가 인수없이)는 사용 가능한 업데이트를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="40bc080f90a040b1296b66e89d909d307d95b9c2" translate="yes" xml:space="preserve">
          <source>You can also import CSS files into the CSS files using the standard CSS &lt;code&gt;@import&lt;/code&gt; rule. For details, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/CSS/@import&quot;&gt;&lt;code&gt;@import&lt;/code&gt;&lt;/a&gt; on the &lt;a href=&quot;https://developer.mozilla.org&quot;&gt;MDN&lt;/a&gt; site.</source>
          <target state="translated">표준 CSS &lt;code&gt;@import&lt;/code&gt; 규칙을 사용하여 CSS 파일을 CSS 파일로 가져올 수도 있습니다 . 자세한 내용 은 &lt;a href=&quot;https://developer.mozilla.org&quot;&gt;MDN&lt;/a&gt; 사이트 에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/CSS/@import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad1215013608ffc7cdc8d41f51b20172f6860bd3" translate="yes" xml:space="preserve">
          <source>You can also invoke a builder directly from another builder or test by calling &lt;code&gt;BuilderContext.scheduleBuilder()&lt;/code&gt;. You pass an &lt;code&gt;options&lt;/code&gt; object directly to the method, and those option values are validated against the schema of the builder without further adjustment.</source>
          <target state="translated">&lt;code&gt;BuilderContext.scheduleBuilder()&lt;/code&gt; 를 호출하여 다른 빌더에서 직접 빌더를 호출하거나 테스트 할 수도 있습니다 . &lt;code&gt;options&lt;/code&gt; 오브젝트를 메소드에 직접 전달하면 해당 옵션 값이 추가 조정없이 빌더의 스키마에 대해 유효성 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="a5e5de366b60dd156e8eee1160484d4e7c3e8972" translate="yes" xml:space="preserve">
          <source>You can also make Angular services available for injection to AngularJS code by &lt;em&gt;downgrading&lt;/em&gt; them. Only services from the Angular root injector can be downgraded. Again, the same singleton instances are shared between the frameworks. When you register a downgraded service, you must explicitly specify a &lt;em&gt;string token&lt;/em&gt; that you want to use in AngularJS.</source>
          <target state="translated">또한 Angular 서비스를 &lt;em&gt;다운 그레이드&lt;/em&gt; 하여 AngularJS 코드로 주입 할 수 있습니다. Angular root 인젝터의 서비스 만 다운 그레이드 할 수 있습니다. 다시, 동일한 싱글 톤 인스턴스가 프레임 워크간에 공유됩니다. 다운 그레이드 된 서비스를 등록 할 때 AngularJS에서 사용하려는 &lt;em&gt;문자열 토큰&lt;/em&gt; 을 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c5cfeb0e0b76ee9743bba9a4035c4a07642e5c5" translate="yes" xml:space="preserve">
          <source>You can also nest different ICU expressions together, as shown in this example:</source>
          <target state="translated">이 예제와 같이 다른 ICU 표현식을 함께 중첩 할 수도 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
