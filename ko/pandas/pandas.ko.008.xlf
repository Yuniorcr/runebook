<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="902b44edc63b15cf2b27d7f9c8b037f4c244432a" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;mask&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;인덱싱&lt;/a&gt; 의 &lt;code&gt;mask&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2bcb4c081d2c20234d293359cc695af15e903af" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;query&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-query&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-query&quot;&gt;인덱싱&lt;/a&gt; 의 &lt;code&gt;query&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f143995453a00fe6d03094e989011811f9955e" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;where&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;색인화 &lt;/a&gt; &lt;code&gt;where&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="561b283987d4cf733b9db1d454e282ce47e5c4fb" translate="yes" xml:space="preserve">
          <source>For further details see Wikipedia&amp;rsquo;s entry for &lt;a href=&quot;https://en.wikipedia.org/wiki/Box_plot&quot;&gt;boxplot&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 Wikipedia의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Box_plot&quot;&gt;boxplot&lt;/a&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6348b513eb36c3c730e52d3d6019959489fce286" translate="yes" xml:space="preserve">
          <source>For indexes, an ndarray of booleans is returned.</source>
          <target state="translated">인덱스의 경우 부울 ndarray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7adad8c65d360dc936e8663cd8abea67d035de" translate="yes" xml:space="preserve">
          <source>For internal compatibility with numpy arrays.</source>
          <target state="translated">numpy 배열과의 내부 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="f8def0800904e304ec124f027edd8aa6dddd1377" translate="yes" xml:space="preserve">
          <source>For internal compatibility with with the Index API.</source>
          <target state="translated">인덱스 API와의 내부 호환성</target>
        </trans-unit>
        <trans-unit id="de1cb23caf7dbeb301ffad25e4368576f7f6f007" translate="yes" xml:space="preserve">
          <source>For keyword arguments with a default value, the default will be listed after a comma at the end of the type. The exact form of the type in this case will be &amp;ldquo;int, default 0&amp;rdquo;. In some cases it may be useful to explain what the default argument means, which can be added after a comma &amp;ldquo;int, default -1, meaning all cpus&amp;rdquo;.</source>
          <target state="translated">기본값이있는 키워드 인수의 경우 기본값은 유형 끝에서 쉼표 뒤에 표시됩니다. 이 경우 형식의 정확한 형식은 &quot;int, default 0&quot;입니다. 어떤 경우에는 기본 인수가 무엇을 의미하는지 설명하는 것이 유용 할 수 있는데, 쉼표 &quot;int, default -1, 모든 CPU를 의미&quot;뒤에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0adaeb3f1106850f9ae3027ebeacc87af327953c" translate="yes" xml:space="preserve">
          <source>For labeled, non-time series data, you may wish to produce a bar plot:</source>
          <target state="translated">비 계열 계열 레이블이 지정된 데이터의 경우 막대 플롯을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a2566df3f5bed78f1243c5dc7500605adea3ed" translate="yes" xml:space="preserve">
          <source>For many ExtensionArrays, there will be two representations of &lt;code&gt;fill_value&lt;/code&gt;: a user-facing &amp;ldquo;boxed&amp;rdquo; scalar, and a low-level physical NA value. &lt;code&gt;fill_value&lt;/code&gt; should be the user-facing version, and the implementation should handle translating that to the physical version for processing the take if necessary.</source>
          <target state="translated">많은 ExtensionArray에는 &lt;code&gt;fill_value&lt;/code&gt; 의 두 가지 표현, 즉 사용자가 직면 한 &quot;박스형&quot;스칼라와 낮은 수준의 물리적 NA 값이 있습니다. &lt;code&gt;fill_value&lt;/code&gt; 는 사용자를 향한 버전이어야하며 구현시 필요한 경우 테이크를 처리하기 위해 실제 버전으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5a3b988b41d8a805c3b5e20e1224d6a8d441736" translate="yes" xml:space="preserve">
          <source>For many use cases writing pandas in pure Python and NumPy is sufficient. In some computationally heavy applications however, it can be possible to achieve sizable speed-ups by offloading work to &lt;a href=&quot;http://cython.org/&quot;&gt;cython&lt;/a&gt;.</source>
          <target state="translated">많은 유스 케이스의 경우 순수 Python 및 NumPy로 팬더를 작성하면 충분합니다. 그러나 계산량이 많은 일부 응용 프로그램에서는 작업을 &lt;a href=&quot;http://cython.org/&quot;&gt;cython&lt;/a&gt; 으로 오프로드하여 상당한 속도 향상을 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b71da563397dbd40337aa5b8a20ea61b78174cf4" translate="yes" xml:space="preserve">
          <source>For memory savings, this should be the most common value in the array.</source>
          <target state="translated">메모리 절약을 위해서는 이것이 어레이에서 가장 일반적인 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e8109079167e80b0f5a798a2cb12312edf4b9b2b" translate="yes" xml:space="preserve">
          <source>For mixed data types provided via a &lt;code&gt;DataFrame&lt;/code&gt;, the default is to return only an analysis of numeric columns. If the dataframe consists only of object and categorical data without any numeric columns, the default is to return an analysis of both the object and categorical columns. If &lt;code&gt;include='all'&lt;/code&gt; is provided as an option, the result will include a union of attributes of each type.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 을 통해 제공된 혼합 데이터 유형의 경우 기본값은 숫자 열 분석 만 리턴하는 것입니다. 데이터 프레임이 숫자 열이없는 개체 및 범주 형 데이터로만 구성된 경우 기본값은 개체와 범주 형 열의 분석을 반환하는 것입니다. 경우 &lt;code&gt;include='all'&lt;/code&gt; 옵션으로 제공되며, 결과는 각 유형의 특성의 조합을 포함 할 것이다.</target>
        </trans-unit>
        <trans-unit id="0cc4b2e84755ddb87399e5f342442911a74e62e0" translate="yes" xml:space="preserve">
          <source>For more complex examples (grouping for example), avoid using data without interpretation, like a matrix of random numbers with columns A, B, C, D&amp;hellip; And instead use a meaningful example, which makes it easier to understand the concept. Unless required by the example, use names of animals, to keep examples consistent. And numerical properties of them.</source>
          <target state="translated">보다 복잡한 예 (예를 들어 그룹화)의 경우 열 A, B, C, D가 포함 된 난수 행렬과 같이 해석없이 데이터를 사용하지 말고 의미있는 예를 사용하면 개념을보다 쉽게 ​​이해할 수 있습니다. 예제에서 요구하지 않는 한 예제의 일관성을 유지하기 위해 동물의 이름을 사용하십시오. 그리고 그것들의 수치 적 특성.</target>
        </trans-unit>
        <trans-unit id="4db1d203723f6466ff69cafd19c4560dc311a579" translate="yes" xml:space="preserve">
          <source>For more details see the API documentation for &lt;a href=&quot;pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;. For detailed examples see &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;enhancing performance with eval&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 대한 API 설명서를 참조하십시오 . 자세한 예 &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;는 eval을 사용하여 성능 향상을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d3e7354134ce3638855035adb4756aa18bf7c5d" translate="yes" xml:space="preserve">
          <source>For more examples, see &lt;a href=&quot;../../user_guide/text#text-concatenate&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;../../user_guide/text#text-concatenate&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="75d8a30e5a3e9e26068bd5b1759c6cd940d19352" translate="yes" xml:space="preserve">
          <source>For more formatting and styling options, see &lt;a href=&quot;#visualization-formatting&quot;&gt;formatting&lt;/a&gt; below.</source>
          <target state="translated">형식 및 스타일 옵션에 대한 자세한 내용은 아래 &lt;a href=&quot;#visualization-formatting&quot;&gt;형식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f03fb9ac8d9595a76234b65ebd564c7f8bb01d3" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;.at&lt;/code&gt;, &lt;code&gt;.iat&lt;/code&gt;, &lt;code&gt;.loc&lt;/code&gt;, and &lt;code&gt;.iloc&lt;/code&gt;, see the &lt;a href=&quot;../user_guide/indexing#indexing&quot;&gt;indexing documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.at&lt;/code&gt; , &lt;code&gt;.iat&lt;/code&gt; , &lt;code&gt;.loc&lt;/code&gt; 및 &lt;code&gt;.iloc&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;../user_guide/indexing#indexing&quot;&gt;인덱싱 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29357f73f549c2753f04d0dbde59a45aa498cd61" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query&quot;&gt;BigQuery REST API Reference&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query&quot;&gt;BigQuery REST API 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe06d20afcf584afd6d8be687c4bdbdf203fd1f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;../../user_guide/io#io-hdf5&quot;&gt;user guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../user_guide/io#io-hdf5&quot;&gt;사용 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9540bf72078abdec18fd1e6942000ba9e55ad949" translate="yes" xml:space="preserve">
          <source>For more information see: &lt;a href=&quot;http://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;http://en.wikipedia.org/wiki/4-4-5_calendar&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오 : &lt;a href=&quot;http://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;http://en.wikipedia.org/wiki/4-4-5_calendar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0494704c2cb9de594939f986fa369462e9cc13d" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;http://python3statement.org/&quot;&gt;Python 3 statement&lt;/a&gt; and the &lt;a href=&quot;https://docs.python.org/3/howto/pyporting.html&quot;&gt;Porting to Python 3 guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://python3statement.org/&quot;&gt;Python 3 문&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/howto/pyporting.html&quot;&gt;Python 3으로 이식 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9866dac8fb4a1bccca6e4fe3e355cb710c5015a2" translate="yes" xml:space="preserve">
          <source>For more, see the &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a373615513c61887ba3ada5e17c999e8311450d0" translate="yes" xml:space="preserve">
          <source>For most data types, pandas uses NumPy arrays as the concrete objects contained with a &lt;a href=&quot;api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 데이터 유형에서 팬더는 NumPy 배열을 &lt;a href=&quot;api/pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 에&lt;/a&gt; 포함 된 콘크리트 객체로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bf82910e3187b0e3669f2a8c729d0ceaa8011d63" translate="yes" xml:space="preserve">
          <source>For multiple groupings, the result index will be a MultiIndex</source>
          <target state="translated">여러 그룹화의 경우 결과 색인은 다중 색인이됩니다</target>
        </trans-unit>
        <trans-unit id="fc74d8fe9ecf9df39ac50ccaee4b3bfb5cd0f210" translate="yes" xml:space="preserve">
          <source>For multiple groupings, the result index will be a MultiIndex.</source>
          <target state="translated">여러 그룹화의 경우 결과 색인은 다중 색인이됩니다.</target>
        </trans-unit>
        <trans-unit id="c7bdf4112ee3b72a8371413300cae34f0a234b00" translate="yes" xml:space="preserve">
          <source>For numeric data, the result&amp;rsquo;s index will include &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt; as well as lower, &lt;code&gt;50&lt;/code&gt; and upper percentiles. By default the lower percentile is &lt;code&gt;25&lt;/code&gt; and the upper percentile is &lt;code&gt;75&lt;/code&gt;. The &lt;code&gt;50&lt;/code&gt; percentile is the same as the median.</source>
          <target state="translated">숫자 데이터의 경우 결과 색인에는 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;mean&lt;/code&gt; , &lt;code&gt;std&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; 및 낮은 백분위 수 및 &lt;code&gt;50&lt;/code&gt; 백분위 수가 포함됩니다. 기본적으로 하위 백분위 수는 &lt;code&gt;25&lt;/code&gt; 이고 상위 백분위 수는 &lt;code&gt;75&lt;/code&gt; 입니다. &lt;code&gt;50&lt;/code&gt; 백분위 평균과 동일하다.</target>
        </trans-unit>
        <trans-unit id="138f514bb9ae738a899ea24cc00269630443f802" translate="yes" xml:space="preserve">
          <source>For object data (e.g. strings or timestamps), the result&amp;rsquo;s index will include &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;unique&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, and &lt;code&gt;freq&lt;/code&gt;. The &lt;code&gt;top&lt;/code&gt; is the most common value. The &lt;code&gt;freq&lt;/code&gt; is the most common value&amp;rsquo;s frequency. Timestamps also include the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; items.</source>
          <target state="translated">객체 데이터 (예 : 문자열 또는 타임 스탬프)의 경우 결과 색인에 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;unique&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;freq&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;top&lt;/code&gt; 가장 일반적인 값입니다. &lt;code&gt;freq&lt;/code&gt; 가장 일반적인 값의 주파수이다. 타임 스탬프에는 &lt;code&gt;first&lt;/code&gt; 항목 과 &lt;code&gt;last&lt;/code&gt; 항목 도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="465bdc736a1f8e5e2efd89ddbb84b0ec01f99c18" translate="yes" xml:space="preserve">
          <source>For objects to be considered file-like, they must be an iterator AND have either a &lt;code&gt;read&lt;/code&gt; and/or &lt;code&gt;write&lt;/code&gt; method as an attribute.</source>
          <target state="translated">객체가 파일과 같은 것으로 간주 되려면 객체는 반복자이어야하며 속성으로 &lt;code&gt;read&lt;/code&gt; 및 / 또는 &lt;code&gt;write&lt;/code&gt; 메소드 가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="5807479643017470f979a29619731b84195733dd" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo; and &lt;code&gt;filepath_or_buffer&lt;/code&gt; is path-like, then detect compression from the following extensions: &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo; (otherwise no decompression). If using &amp;lsquo;zip&amp;rsquo;, the ZIP file must contain only one data file to be read in. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. 'infer'및 &lt;code&gt;filepath_or_buffer&lt;/code&gt; 가 경로와 같은 경우 '.gz', '.bz2', '.zip'또는 '.xz'(또는 압축 해제 없음) 확장자에서 압축을 감지하십시오. 'zip'을 사용하는 경우 ZIP 파일은 읽을 데이터 파일을 하나만 포함해야합니다. 압축 해제하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4b1a54b61b3512074fd4f647bc4bc9c5a146e3bc" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo;, then use gzip, bz2, xz or zip if path ends in &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.xz&amp;rsquo;, or &amp;lsquo;.zip&amp;rsquo; respectively, and no decompression otherwise. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. '추천'인 경우 경로가 각각 '.gz', '.bz2', '.xz'또는 '.zip'으로 끝나는 경우 gzip, bz2, xz 또는 zip을 사용하고 그렇지 않으면 압축 해제하지 마십시오. 감압하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acdaedcb04def73a0b184a8c9893ab1d4272fe4e" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo;, then use gzip, bz2, zip or xz if path_or_buf is a string ending in &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;xz&amp;rsquo;, respectively, and no decompression otherwise. If using &amp;lsquo;zip&amp;rsquo;, the ZIP file must contain only one data file to be read in. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. '추천'인 경우 path_or_buf가 각각 '.gz', '.bz2', '.zip'또는 'xz'로 끝나는 문자열 인 경우 gzip, bz2, zip 또는 xz를 사용하고 그렇지 않으면 압축 해제하지 마십시오. 'zip'을 사용하는 경우 ZIP 파일은 읽을 데이터 파일을 하나만 포함해야합니다. 압축 해제하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="987b76ecb692d8818b42d3971149d7bff3260d70" translate="yes" xml:space="preserve">
          <source>For periods that span over multiple days, the day at the beginning of the period is returned.</source>
          <target state="translated">여러 날에 걸쳐있는 기간의 경우 기간 시작일이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="662b7bf8341d7b362e53abb22b5202de24ac90e2" translate="yes" xml:space="preserve">
          <source>For periods with a frequency higher than days, the last day of the period is returned.</source>
          <target state="translated">빈도가 일보다 높은 기간의 경우 기간의 마지막 날이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f20cb9d6aaa1f319d0fbe424ca0488540400e731" translate="yes" xml:space="preserve">
          <source>For potential users coming from &lt;a href=&quot;https://en.wikipedia.org/wiki/SAS_(software)&quot;&gt;SAS&lt;/a&gt; this page is meant to demonstrate how different SAS operations would be performed in pandas.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/SAS_(software)&quot;&gt;SAS&lt;/a&gt; 에서 오는 잠재적 인 사용자를 위해이 페이지는 팬더에서 다른 SAS 작업이 수행되는 방법을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="91a32cce48835b020148b4ec8bdcadea3e77d396" translate="yes" xml:space="preserve">
          <source>For potential users coming from &lt;a href=&quot;https://en.wikipedia.org/wiki/Stata&quot;&gt;Stata&lt;/a&gt; this page is meant to demonstrate how different Stata operations would be performed in pandas.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Stata&quot;&gt;Stata&lt;/a&gt; 에서 온 잠재적 사용자를 위해이 페이지는 팬더에서 다양한 Stata 작업이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e1d215f8c65e8806b64b9f99bdc1753adfd8238b" translate="yes" xml:space="preserve">
          <source>For regular NumPy types like int, and float, a PandasArray is returned.</source>
          <target state="translated">int 및 float와 같은 일반 NumPy 유형의 경우 PandasArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d42b9c8d29b7e7711acb1a5fe60fadbbcd7180b4" translate="yes" xml:space="preserve">
          <source>For row and column slicing, any valid indexer to &lt;code&gt;.loc&lt;/code&gt; will work.</source>
          <target state="translated">행 및 열 슬라이싱의 경우 &lt;code&gt;.loc&lt;/code&gt; 에 대한 유효한 인덱서 가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="377224ee8831a7f9bc64d03588b90fd9349eee4d" translate="yes" xml:space="preserve">
          <source>For scalar input, returns a scalar boolean. For array input, returns an array of boolean indicating whether each corresponding element is missing.</source>
          <target state="translated">스칼라 입력의 경우 스칼라 부울을 리턴합니다. 배열 입력의 경우, 해당하는 각 요소가 누락되었는지 여부를 나타내는 부울 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd021b2414eea09b75e93e704e6c0735c3100766" translate="yes" xml:space="preserve">
          <source>For scalar input, returns a scalar boolean. For array input, returns an array of boolean indicating whether each corresponding element is valid.</source>
          <target state="translated">스칼라 입력의 경우 스칼라 부울을 리턴합니다. 배열 입력의 경우, 해당하는 각 요소가 유효한지 여부를 나타내는 부울 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="22ee1a4d311a6da50dd1b6cd2e58ca99cdcd9710" translate="yes" xml:space="preserve">
          <source>For slightly more complex use cases like splitting the html document name from a url, a combination of parameter settings can be used.</source>
          <target state="translated">URL에서 html 문서 이름을 분할하는 것과 같이 약간 더 복잡한 사용 사례의 경우 매개 변수 설정 조합을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1abd5590458316fea2deba3093e3133026d1e28" translate="yes" xml:space="preserve">
          <source>For some data types, pandas extends NumPy&amp;rsquo;s type system.</source>
          <target state="translated">일부 데이터 유형의 경우 팬더는 NumPy의 유형 시스템을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="b5a7819e8c98c63ecde6229bddc35e97e9662c1a" translate="yes" xml:space="preserve">
          <source>For the curious here is how the above &lt;code&gt;DataFrame&lt;/code&gt; was created:</source>
          <target state="translated">궁금한 &lt;code&gt;DataFrame&lt;/code&gt; 은 위의 DataFrame 이 어떻게 생성 되었는지 입니다.</target>
        </trans-unit>
        <trans-unit id="6c3b0ae4cbaee1f14bc076c6ff074b9aaae229c7" translate="yes" xml:space="preserve">
          <source>For the first approach, you define selected operators, e.g., &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__le__&lt;/code&gt;, etc. that you want your &lt;code&gt;ExtensionArray&lt;/code&gt; subclass to support.</source>
          <target state="translated">첫 번째 접근 방식의 경우 &lt;code&gt;ExtensionArray&lt;/code&gt; 서브 클래스에서 지원 하려는 선택된 연산자 (예 : &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__le__&lt;/code&gt; 등)를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b0b6112cc4e69119fbb1bf4e165ae88af1e5ad40" translate="yes" xml:space="preserve">
          <source>For the meaning of &lt;code&gt;closed&lt;/code&gt; and &lt;code&gt;open&lt;/code&gt; see &lt;a href=&quot;pandas.interval#pandas.Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;closed&lt;/code&gt; 및 &lt;code&gt;open&lt;/code&gt; 의미는 &lt;a href=&quot;pandas.interval#pandas.Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74ac61de50539871dfbab253279ae8765fe97c4e" translate="yes" xml:space="preserve">
          <source>For timezone-aware data, the timezones may be retained with &lt;code&gt;dtype='object'&lt;/code&gt;</source>
          <target state="translated">시간대 인식 데이터의 경우 시간대는 &lt;code&gt;dtype='object'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75be1964312826cb48015a9c43b800814759e61f" translate="yes" xml:space="preserve">
          <source>For transfer of &lt;code&gt;DataFrame&lt;/code&gt; objects from &lt;code&gt;pandas&lt;/code&gt; to R, one option is to use HDF5 files, see &lt;a href=&quot;../../user_guide/io#io-external-compatibility&quot;&gt;External compatibility&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;pandas&lt;/code&gt; 에서 R 로 &lt;code&gt;DataFrame&lt;/code&gt; 객체 를 전송 하려면 한 가지 옵션이 HDF5 파일을 사용 하는 것입니다. 예는 &lt;a href=&quot;../../user_guide/io#io-external-compatibility&quot;&gt;외부 호환성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff03dc61e8b56825526bfc637603ddd6f373fb81" translate="yes" xml:space="preserve">
          <source>For types other than these, the &lt;code&gt;'metadata'&lt;/code&gt; key can be omitted. Implementations can assume &lt;code&gt;None&lt;/code&gt; if the key is not present.</source>
          <target state="translated">이들 이외의 유형의 경우 &lt;code&gt;'metadata'&lt;/code&gt; 키를 생략 할 수 있습니다. 키가 존재하지 않는 경우 구현에서는 &lt;code&gt;None&lt;/code&gt; 을 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59129113fd44c434ea738ba42e4842a3b812fe08" translate="yes" xml:space="preserve">
          <source>Force Google BigQuery to re-authenticate the user. This is useful if multiple accounts are used.</source>
          <target state="translated">Google BigQuery가 사용자를 다시 인증하도록합니다. 여러 계정을 사용하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c4804c6e847cb63899d9044dc2761688f1c5e4bc" translate="yes" xml:space="preserve">
          <source>Force encoded string to be ASCII.</source>
          <target state="translated">인코딩 된 문자열을 ASCII로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="4414e35b15eeb7579a39fef63b8a78c106f2a378" translate="yes" xml:space="preserve">
          <source>Form the intersection of two Index objects.</source>
          <target state="translated">두 개의 Index 객체의 교차점을 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="abe27f9f1159d82b0faf0bca0ea35285e1dc9c91" translate="yes" xml:space="preserve">
          <source>Form the union of two Index objects.</source>
          <target state="translated">두 개의 Index 객체를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="3274c425c17a043f22ff3df0df8b6b0da09b1e17" translate="yes" xml:space="preserve">
          <source>Format Timedelta as ISO 8601 Duration like &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt;, where the &lt;code&gt;[n]&lt;/code&gt; s are replaced by the values.</source>
          <target state="translated">Timedelta를 ISO 8601로 포맷 &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt; 와 같은 지속 시간 . 여기서 &lt;code&gt;[n]&lt;/code&gt; 은 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="11f20deeb76af0ec70327a877ea886ce6705aeb6" translate="yes" xml:space="preserve">
          <source>Format Timedelta as ISO 8601 Duration like &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt;, where the &lt;code&gt;[n]&lt;/code&gt; s are replaced by the values. See &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations&lt;/a&gt;</source>
          <target state="translated">Timedelta를 ISO 8601로 포맷 &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt; 와 같은 지속 시간 . 여기서 &lt;code&gt;[n]&lt;/code&gt; 은 값으로 대체됩니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="de2e34068366c3b66447d1e40d8ed3cff721d57a" translate="yes" xml:space="preserve">
          <source>Format Type</source>
          <target state="translated">체재 유형</target>
        </trans-unit>
        <trans-unit id="27b42a61c9970832b8b186790fa35509873d2e8d" translate="yes" xml:space="preserve">
          <source>Format specified values of &lt;code&gt;self&lt;/code&gt; and return them.</source>
          <target state="translated">지정된 &lt;code&gt;self&lt;/code&gt; 값을 형식화 하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6d34b872a816aa7076abe13f14e014dee1ff70d4" translate="yes" xml:space="preserve">
          <source>Format string for dates written into Excel files (e.g. &amp;lsquo;YYYY-MM-DD&amp;rsquo;)</source>
          <target state="translated">Excel 파일에 기록 된 날짜의 형식 문자열 (예 : 'YYYY-MM-DD')</target>
        </trans-unit>
        <trans-unit id="b020f5c5a2e9e8e57385dd78f284cb6b4b7505c3" translate="yes" xml:space="preserve">
          <source>Format string for datetime objects written into Excel files (e.g. &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo;)</source>
          <target state="translated">Excel 파일에 기록 된 날짜 / 시간 개체의 형식 문자열 (예 : 'YYYY-MM-DD HH : MM : SS')</target>
        </trans-unit>
        <trans-unit id="d1f9c220a86b204985f6534d8f24dc3625fd9b63" translate="yes" xml:space="preserve">
          <source>Format string for datetime objects.</source>
          <target state="translated">날짜 / 시간 객체의 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="61792b236b0b98b0b29b2f1c1226613a42ed772e" translate="yes" xml:space="preserve">
          <source>Format string for floating point numbers.</source>
          <target state="translated">부동 소수점 숫자의 형식 문자열</target>
        </trans-unit>
        <trans-unit id="12d5ff452c1eb10875717600710c2fc8385f11ce" translate="yes" xml:space="preserve">
          <source>Format string for floating point numbers. For example &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; will format 0.1234 to 0.12.</source>
          <target state="translated">부동 소수점 숫자의 형식 문자열 예를 들어 &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; 는 0.1234에서 0.12로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5852d75118543757450d402f17dda1d0d4df2d" translate="yes" xml:space="preserve">
          <source>Format the text display value of cells.</source>
          <target state="translated">셀의 텍스트 표시 값을 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="5438a2d879f16b19a503d6ae97eb8801b8ce2d4b" translate="yes" xml:space="preserve">
          <source>Formatted values.</source>
          <target state="translated">형식화 된 값.</target>
        </trans-unit>
        <trans-unit id="9caf844b46e108a2e316a48cc142a86b7fedc524" translate="yes" xml:space="preserve">
          <source>Formatter for floating point numbers. For example &lt;code&gt;float_format=&quot;%%.2f&quot;&lt;/code&gt; and &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; will both result in 0.1234 being formatted as 0.12.</source>
          <target state="translated">부동 소수점 숫자를위한 포매터. 예를 들어 &lt;code&gt;float_format=&quot;%%.2f&quot;&lt;/code&gt; 및 &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; 은 모두 0.1234가 0.12로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="cf268a12d163a61d0b25d6155bb9831413a55f75" translate="yes" xml:space="preserve">
          <source>Formatter function to apply to columns&amp;rsquo; elements if they are floats, default None.</source>
          <target state="translated">열 요소가 부동 소수점 인 경우에 적용되는 포맷터 함수, 기본값 없음</target>
        </trans-unit>
        <trans-unit id="a1a3182087a75f77562965d92f3cc94f1e89d474" translate="yes" xml:space="preserve">
          <source>Formatter function to apply to columns&amp;rsquo; elements if they are floats. The result of this function must be a unicode string.</source>
          <target state="translated">부동 소수점 인 경우 열 요소에 적용 할 포맷터 함수입니다. 이 함수의 결과는 유니 코드 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="153d92209f6160e2c7bf2b09525797a6d5ee079c" translate="yes" xml:space="preserve">
          <source>Formatter functions to apply to columns&amp;rsquo; elements by position or name. The result of each function must be a unicode string. List must be of length equal to the number of columns.</source>
          <target state="translated">포맷터 기능은 위치 또는 이름별로 열 요소에 적용됩니다. 각 함수의 결과는 유니 코드 문자열이어야합니다. 목록의 길이는 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1df875b791663b3fee445ce8e30ff16d10c8bc6c" translate="yes" xml:space="preserve">
          <source>Formatting function for scalar values.</source>
          <target state="translated">스칼라 값에 대한 형식화 기능.</target>
        </trans-unit>
        <trans-unit id="3c976e6b46c484aaf12d4a3efc98fd6cb2858df6" translate="yes" xml:space="preserve">
          <source>Forward fill &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">정방향 채우기 &lt;code&gt;NaN&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="e86dc7f86849980e77b3a231273a8c263b89cb76" translate="yes" xml:space="preserve">
          <source>Forward fill NaN values in the resampled data.</source>
          <target state="translated">리샘플링 된 데이터에서 NaN 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c053305e5069585c8d36770eff2795aee72f8356" translate="yes" xml:space="preserve">
          <source>Forward fill NaN values.</source>
          <target state="translated">정방향 채우기 NaN 값.</target>
        </trans-unit>
        <trans-unit id="fc16c19e4a628a86db057e19b2fd0c18596d082d" translate="yes" xml:space="preserve">
          <source>Forward fill the values.</source>
          <target state="translated">값을 앞으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="e3037e63bf6849b84a9a65234ff16b35b8d4cade" translate="yes" xml:space="preserve">
          <source>Fraction</source>
          <target state="translated">Fraction</target>
        </trans-unit>
        <trans-unit id="12bdf318c0d4581b90440467582f220b0fc4edf0" translate="yes" xml:space="preserve">
          <source>Fraction of axis items to return. Cannot be used with &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">반환 할 축 항목의 비율입니다. &lt;code&gt;n&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="40128863b5b7df9bd5589b4004c946c4e2ca5c66" translate="yes" xml:space="preserve">
          <source>Frequencies</source>
          <target state="translated">Frequencies</target>
        </trans-unit>
        <trans-unit id="2aa6132ea33484a73b5908ff5440273e93a2e9be" translate="yes" xml:space="preserve">
          <source>Frequency alias. By default the freq is taken from &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; if those are Period objects. Otherwise, the default is &lt;code&gt;&quot;D&quot;&lt;/code&gt; for daily frequency.</source>
          <target state="translated">주파수 별칭. 기본적으로 freq는 Period 객체 인 경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 에서 가져옵니다 . 그렇지 않으면 일일 빈도 의 기본값은 &lt;code&gt;&quot;D&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48b5cc5f2864213d55478931fee6feb9bd830124" translate="yes" xml:space="preserve">
          <source>Frequency associated with the PeriodIndex.</source>
          <target state="translated">PeriodIndex와 관련된 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="29501b6e79441445d620b18c8d698ebe6a42d233" translate="yes" xml:space="preserve">
          <source>Frequency conversion</source>
          <target state="translated">주파수 변환</target>
        </trans-unit>
        <trans-unit id="0704c83dcc1e70b7b2e157acfe7c07f6efc4fcd6" translate="yes" xml:space="preserve">
          <source>Frequency conversion and resampling of time series.</source>
          <target state="translated">시계열의 주파수 변환 및 리샘플링.</target>
        </trans-unit>
        <trans-unit id="23edad8221b7cc76aa71e3a857e9e58b10925dd4" translate="yes" xml:space="preserve">
          <source>Frequency increment to shift by. If None, the index is shifted by its own &lt;code&gt;freq&lt;/code&gt; attribute. Offset aliases are valid strings, e.g., &amp;lsquo;D&amp;rsquo;, &amp;lsquo;W&amp;rsquo;, &amp;lsquo;M&amp;rsquo; etc.</source>
          <target state="translated">전환 할 주파수 증분. None이면 인덱스는 고유 한 &lt;code&gt;freq&lt;/code&gt; 특성 으로 이동 합니다. 오프셋 별칭은 유효한 문자열입니다 (예 : 'D', 'W', 'M'등).</target>
        </trans-unit>
        <trans-unit id="f2eb99c55cf2b7999d81428a54976938c2e82ab4" translate="yes" xml:space="preserve">
          <source>Frequency of the PeriodIndex.</source>
          <target state="translated">PeriodIndex의 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="38627bd3804c3d1ef864563ce2ba5cc088ff5255" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;</source>
          <target state="translated">주파수 스트링은 배수를 가질 수 있습니다 (예 : '5H'</target>
        </trans-unit>
        <trans-unit id="b3d68d4e36f22234f436146bef664e61b007edfd" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;.</source>
          <target state="translated">주파수 스트링은 '5H'와 같은 배수를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021618b637dd7059f0d0d646eeeec2971166407a" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;. See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;here&lt;/a&gt; for a list of frequency aliases.</source>
          <target state="translated">주파수 스트링은 '5H'와 같은 배수를 가질 수 있습니다. 주파수 별명 목록은 &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608af1de5eb7b093505effa772485c6b312751be" translate="yes" xml:space="preserve">
          <source>Frequently Used Options</source>
          <target state="translated">자주 사용하는 옵션</target>
        </trans-unit>
        <trans-unit id="51dbe984842c639f798cf4c00682fec24a67ec27" translate="yes" xml:space="preserve">
          <source>From an internal implementation point of view, the relevant methods that an &lt;code&gt;Index&lt;/code&gt; must define are one or more of the following (depending on how incompatible the new object internals are with the &lt;code&gt;Index&lt;/code&gt; functions):</source>
          <target state="translated">내부 구현 관점에서 &lt;code&gt;Index&lt;/code&gt; 이 정의해야하는 관련 메소드 는 다음 중 하나 이상입니다 (새 객체 내부가 &lt;code&gt;Index&lt;/code&gt; 함수 와 호환되지 않는 방법에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="195142b655d4793088d75afe93e4bcce5136989a" translate="yes" xml:space="preserve">
          <source>From dicts of Series, arrays, or dicts.</source>
          <target state="translated">시리즈, 배열 또는 dict의 dict에서.</target>
        </trans-unit>
        <trans-unit id="b7196b008f44353e6c5efec802c5f896714ff2ec" translate="yes" xml:space="preserve">
          <source>From sequence of (key, value) pairs read_csv, pandas.read_table, pandas.read_clipboard.</source>
          <target state="translated">일련의 (키, 값) 쌍에서 read_csv, pandas.read_table, pandas.read_clipboard.</target>
        </trans-unit>
        <trans-unit id="ee6da781dd3904b7e5324e87d8cdc1f6b64b8c1d" translate="yes" xml:space="preserve">
          <source>Full path to a group (without trailing &amp;lsquo;/&amp;rsquo;)</source>
          <target state="translated">그룹의 전체 경로 ( '/'뒤에없는)</target>
        </trans-unit>
        <trans-unit id="11ffc7ddf9ec01349c70b6e01a334bdb40a54b4c" translate="yes" xml:space="preserve">
          <source>Full reStructuredText specification</source>
          <target state="translated">전체 reStructuredText 사양</target>
        </trans-unit>
        <trans-unit id="47f6c7a8bbc55714acb71726d9a2028cdf551f0e" translate="yes" xml:space="preserve">
          <source>Fun stuff</source>
          <target state="translated">재미있는 것들</target>
        </trans-unit>
        <trans-unit id="e78ad1b15dcf0a18aac08b8e177988aeb54619f9" translate="yes" xml:space="preserve">
          <source>Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don&amp;rsquo;t throw an error.</source>
          <target state="translated">함수 / dict 값은 고유해야합니다 (1 대 1). 사전 / 시리즈에 포함되지 않은 라벨은 그대로 유지됩니다. 나열된 추가 레이블은 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edac3e16cb277f3cd2986b45d81bff72a02fa44a" translate="yes" xml:space="preserve">
          <source>Function application</source>
          <target state="translated">기능 적용</target>
        </trans-unit>
        <trans-unit id="4953fe85849a4b51652d26a6190276f3b0adedb3" translate="yes" xml:space="preserve">
          <source>Function application, GroupBy &amp;amp; window</source>
          <target state="translated">기능 적용, GroupBy 및 창</target>
        </trans-unit>
        <trans-unit id="a091b8028bdfd2490bbdbbdf923aa3850451fd0e" translate="yes" xml:space="preserve">
          <source>Function application, groupby &amp;amp; window</source>
          <target state="translated">기능 적용, 그룹 별 및 창</target>
        </trans-unit>
        <trans-unit id="a80564ae1eb2beea69c09657eb462f01bfee8a88" translate="yes" xml:space="preserve">
          <source>Function calls other than math functions.</source>
          <target state="translated">수학 함수 이외의 함수 호출</target>
        </trans-unit>
        <trans-unit id="76af48c83189116cc762e906885f196893a97afa" translate="yes" xml:space="preserve">
          <source>Function is not implemented.</source>
          <target state="translated">기능이 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b6e2f37f0394b81471cc213a2d7016e539b351b4" translate="yes" xml:space="preserve">
          <source>Function is not implemented. Use pd.to_datetime().</source>
          <target state="translated">기능이 구현되지 않았습니다. pd.to_datetime ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e73952036e9be9558f2dca02b9e30a7942bfd1fe" translate="yes" xml:space="preserve">
          <source>Function of one argument that reduces all the values in a bin to a single number (e.g. &lt;code&gt;np.mean&lt;/code&gt;, &lt;code&gt;np.max&lt;/code&gt;, &lt;code&gt;np.sum&lt;/code&gt;, &lt;code&gt;np.std&lt;/code&gt;).</source>
          <target state="translated">빈의 모든 값을 단일 숫자로 줄이는 하나의 인수 기능 (예 : &lt;code&gt;np.mean&lt;/code&gt; , &lt;code&gt;np.max&lt;/code&gt; , &lt;code&gt;np.sum&lt;/code&gt; , &lt;code&gt;np.std&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ed43094428b13e552f75bb19800d19e26830b08" translate="yes" xml:space="preserve">
          <source>Function that takes two scalars as inputs and returns an element.</source>
          <target state="translated">두 스칼라를 입력으로 받아서 요소를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="142d58ab1106ca3f8240ae97dc04e4232324301a" translate="yes" xml:space="preserve">
          <source>Function that takes two series as inputs and return a Series or a scalar. Used to merge the two dataframes column by columns.</source>
          <target state="translated">두 개의 계열을 입력으로 사용하여 계열 또는 스칼라를 반환하는 함수입니다. 두 데이터 프레임을 열별로 병합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec927c6a3a44c57ebbeeaccb4cfeca58715e990" translate="yes" xml:space="preserve">
          <source>Function to apply to each column or row.</source>
          <target state="translated">각 열 또는 행에 적용하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="13a104de8c013e516c73b5bde235fc7ced562e5a" translate="yes" xml:space="preserve">
          <source>Function to apply to each subframe. Should return True or False.</source>
          <target state="translated">각 서브 프레임에 적용하는 기능. True 또는 False를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc74e4c0ad913c56ace7ee8175764f419629352e" translate="yes" xml:space="preserve">
          <source>Function to apply to the Styler. Alternatively, a &lt;code&gt;(callable, keyword)&lt;/code&gt; tuple where &lt;code&gt;keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the Styler.</source>
          <target state="translated">스타일러에 적용하는 기능입니다. 또는 &lt;code&gt;keyword&lt;/code&gt; 가 스타일러 가 필요한 &lt;code&gt;callable&lt;/code&gt; 키워드를 나타내는 문자열 인 &lt;code&gt;(callable, keyword)&lt;/code&gt; 튜플 입니다.</target>
        </trans-unit>
        <trans-unit id="23bacc378f21eac868fee1ea31be046691dd5073" translate="yes" xml:space="preserve">
          <source>Function to apply to this GroupBy object or, alternatively, a &lt;code&gt;(callable, data_keyword)&lt;/code&gt; tuple where &lt;code&gt;data_keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the GroupBy object.</source>
          <target state="translated">이 GroupBy 객체 또는 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플에 적용하는 &lt;code&gt;data_keyword&lt;/code&gt; 입니다. 여기서 data_keyword 는 GroupBy 객체를 예상하는 &lt;code&gt;callable&lt;/code&gt; 의 키워드를 나타내는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="9dee26726482f3a7276da8f145a7cb4652d03675" translate="yes" xml:space="preserve">
          <source>Function to apply to this Resampler object or, alternatively, a &lt;code&gt;(callable, data_keyword)&lt;/code&gt; tuple where &lt;code&gt;data_keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the Resampler object.</source>
          <target state="translated">이 Resampler 객체 또는 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플에 적용하는 &lt;code&gt;data_keyword&lt;/code&gt; 입니다. 여기서 data_keyword 는 Resampler 객체를 예상하는 &lt;code&gt;callable&lt;/code&gt; 의 키워드를 나타내는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="f90ee47a0b391d4586e24293aff42d41b421e638" translate="yes" xml:space="preserve">
          <source>Function to create a fixed frequency IntervalIndex.</source>
          <target state="translated">고정 주파수 IntervalIndex를 생성하는 기능.</target>
        </trans-unit>
        <trans-unit id="6a6b05ecfb5d80d3726eb6df8f3e820f01fcb088" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a DataFrame or when passed to DataFrame.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 DataFrame을 전달하거나 DataFrame.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e33e26c4e1b172a8d6959e1cb71afa79a34061a" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a Series or when passed to Series.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 Series를 전달하거나 Series.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="4128f18fca69a96ee57714dbd347b51c07c908de" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a Series/Dataframe or when passed to Series/Dataframe.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 Series / Dataframe을 전달하거나 Series / Dataframe.apply에 전달 될 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="262d965883765f2bd1799b280b7f33844c253c56" translate="yes" xml:space="preserve">
          <source>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses &lt;code&gt;dateutil.parser.parser&lt;/code&gt; to do the conversion. Pandas will try to call &lt;code&gt;date_parser&lt;/code&gt; in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by &lt;code&gt;parse_dates&lt;/code&gt;) as arguments; 2) concatenate (row-wise) the string values from the columns defined by &lt;code&gt;parse_dates&lt;/code&gt; into a single array and pass that; and 3) call &lt;code&gt;date_parser&lt;/code&gt; once for each row using one or more strings (corresponding to the columns defined by &lt;code&gt;parse_dates&lt;/code&gt;) as arguments.</source>
          <target state="translated">일련의 문자열 열을 datetime 인스턴스 배열로 변환하는 데 사용되는 함수입니다. 기본값은 &lt;code&gt;dateutil.parser.parser&lt;/code&gt; 를 사용 하여 변환을 수행합니다. 팬더는 예외가 발생하면 다음과 같이 세 가지 방법으로 &lt;code&gt;date_parser&lt;/code&gt; 를 호출하려고 시도 합니다. 1) 하나 이상의 배열 ( &lt;code&gt;parse_dates&lt;/code&gt; 에 정의 된 대로 )을 인수로 전달합니다. 2) &lt;code&gt;parse_dates&lt;/code&gt; 에 의해 정의 된 열의 문자열 값을 단일 배열로 연결하고 행으로 전달합니다. 3) 하나 이상의 문자열 ( &lt;code&gt;parse_dates&lt;/code&gt; 에 의해 정의 된 열에 해당 )을 인수로 사용하여 각 행에 대해 &lt;code&gt;date_parser&lt;/code&gt; 를 한 번 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0bbc6d6ba1a4e5c4f41ee18d817a7042c102770" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a DataFrame or when passed to DataFrame.apply.</source>
          <target state="translated">데이터 변환에 사용하는 기능. 함수 인 경우 DataFrame을 전달하거나 DataFrame.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bcef89ad9a8ddd55a53f46f2c926e9dbbbeea63" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a Series or when passed to Series.apply.</source>
          <target state="translated">데이터 변환에 사용하는 기능. 함수 인 경우 Series를 전달하거나 Series.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7b3d071160f92e9defe001e7d5385571e245c98" translate="yes" xml:space="preserve">
          <source>Function will return &lt;code&gt;NaN&lt;/code&gt; for correlations of equal valued sequences; this is the result of a 0/0 division error.</source>
          <target state="translated">함수는 값이 같은 시퀀스의 상관 관계에 대해 &lt;code&gt;NaN&lt;/code&gt; 을 반환합니다. 이것은 0/0 나누기 오류의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0a8b514ba071637dc2eae1bbef0e3daa98c4e2db" translate="yes" xml:space="preserve">
          <source>Further information on any specific method can be obtained in the &lt;a href=&quot;../reference/index#api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">특정 메소드에 대한 추가 정보는 &lt;a href=&quot;../reference/index#api&quot;&gt;API 참조 서&lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64b02f12cf377018a98a9dbbd642420a521d1c1e" translate="yes" xml:space="preserve">
          <source>Furthermore one can run</source>
          <target state="translated">또한 하나를 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="e19a59f9e8e15c4d1d11e2e68babca36e9d045c0" translate="yes" xml:space="preserve">
          <source>GROUP BY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4081b8f9a028626a8abc9781488d7aad98742eab" translate="yes" xml:space="preserve">
          <source>General 2D labeled, size-mutable tabular structure with potentially heterogeneously-typed column</source>
          <target state="translated">이종 형식의 컬럼이있는 일반 2D 레이블이 있고 크기를 변경할 수있는 테이블 형식 구조</target>
        </trans-unit>
        <trans-unit id="98ef0f4152a1d979296580f796428b16d22667e1" translate="yes" xml:space="preserve">
          <source>General function to concatenate DataFrame or Series objects.</source>
          <target state="translated">DataFrame 또는 Series 객체를 연결하는 일반 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4cb5fd0bbde100c5b28a657a95eaed1a4ad8e85f" translate="yes" xml:space="preserve">
          <source>General functions</source>
          <target state="translated">일반 기능</target>
        </trans-unit>
        <trans-unit id="58cc07cd05c6958c9a8410023fc828dc507072f7" translate="yes" xml:space="preserve">
          <source>General purpose method to trim DataFrame values to given threshold(s).</source>
          <target state="translated">DataFrame 값을 지정된 임계 값으로 자르는 범용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3eaf5b37af932297d69a43c5413cf092f404a995" translate="yes" xml:space="preserve">
          <source>General purpose method to trim Series values to given threshold(s).</source>
          <target state="translated">주어진 임계 값으로 시리즈 값을 트리밍하는 범용 방법.</target>
        </trans-unit>
        <trans-unit id="bf6bda4587aff077462187186bdf6576ccc550c7" translate="yes" xml:space="preserve">
          <source>General rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7132be444a9c9f8523f39e425eb87d35bf051d" translate="yes" xml:space="preserve">
          <source>General terminology translation</source>
          <target state="translated">일반적인 용어 번역</target>
        </trans-unit>
        <trans-unit id="e3bbd1c83b028d0c18e790d49d124c58e3c9099b" translate="yes" xml:space="preserve">
          <source>General utility functions</source>
          <target state="translated">일반적인 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e9d9d0c2fbe32089f49833ef17574a0cc5c7ff9a" translate="yes" xml:space="preserve">
          <source>Generalization of pivot that can handle duplicate values for one index/column pair.</source>
          <target state="translated">하나의 인덱스 / 열 쌍에 대한 중복 값을 처리 할 수있는 피벗의 일반화.</target>
        </trans-unit>
        <trans-unit id="97aaccee0280623c7908ba738eb125f70fa8c65f" translate="yes" xml:space="preserve">
          <source>Generate Kernel Density Estimate plot using Gaussian kernels.</source>
          <target state="translated">가우스 커널을 사용하여 커널 밀도 추정 플롯을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="55bb3b6a0825402faffa6d15a4e5ec851195083a" translate="yes" xml:space="preserve">
          <source>Generate a DataFrame with default index.</source>
          <target state="translated">기본 인덱스를 사용하여 DataFrame을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="219ad59288654be2d791655c7c1cdc5738d4811d" translate="yes" xml:space="preserve">
          <source>Generate a Series with duplicated entries.</source>
          <target state="translated">항목이 중복 된 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f8e2fd0b69d0700fdc99adbe82bc0b097e71b8b0" translate="yes" xml:space="preserve">
          <source>Generate a hexagonal binning plot of &lt;code&gt;x&lt;/code&gt; versus &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default), this is a histogram of the number of occurrences of the observations at &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 대 &lt;code&gt;y&lt;/code&gt; 의 6 각형 비닝 플롯을 생성합니다 . 경우 &lt;code&gt;C&lt;/code&gt; 는 없다 &lt;code&gt;None&lt;/code&gt; (디폴트), 이것의 관찰 된 발생 수의 히스토그램 &lt;code&gt;(x[i], y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c45a875a76fb480480e0754f59178b9694f259b" translate="yes" xml:space="preserve">
          <source>Generate a hexagonal binning plot.</source>
          <target state="translated">육각형 비닝 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7a09d459f15db9c183018d83be8c00048ad13270" translate="yes" xml:space="preserve">
          <source>Generate a matplotlib plot of Andrews curves, for visualising clusters of multivariate data.</source>
          <target state="translated">다변량 데이터의 군집을 시각화하기 위해 Andrews 곡선의 matplotlib 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="910f71e6e699fa038e133873ca6183eec8514f9d" translate="yes" xml:space="preserve">
          <source>Generate a new DataFrame or Series with the index reset.</source>
          <target state="translated">인덱스 재설정으로 새 DataFrame 또는 Series를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="e1b8bb8546d849110ebb781111358327c8d49294" translate="yes" xml:space="preserve">
          <source>Generate a pie plot for a Series.</source>
          <target state="translated">시리즈에 대한 원형 그림을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7f4e98c69008bba302d5b7a908b67a16908b81" translate="yes" xml:space="preserve">
          <source>Generate a pie plot.</source>
          <target state="translated">파이 플롯을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="de7da30319f200e71b5c69df93949125d5970388" translate="yes" xml:space="preserve">
          <source>Generate an pandas.Index with duplicate values.</source>
          <target state="translated">중복 값으로 pandas.Index를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7548e1b4ba3d5faf268b55256de1d16a5a1494d4" translate="yes" xml:space="preserve">
          <source>Generate descriptive statistics of DataFrame columns.</source>
          <target state="translated">DataFrame 열에 대한 설명 통계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7038c3cc7a3edb83499619ad3f141f927977174a" translate="yes" xml:space="preserve">
          <source>Generate descriptive statistics that summarize the central tendency, dispersion and shape of a dataset&amp;rsquo;s distribution, excluding &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 값을 제외하고 데이터 세트 분포의 중심 경향, 분산 및 모양을 요약하는 설명 통계를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="76ba3c68ce4f31e83b645e6806741f73c57161bd" translate="yes" xml:space="preserve">
          <source>Generate sequences of fixed-frequency dates and time spans</source>
          <target state="translated">고정 빈도 날짜 및 시간 범위의 시퀀스 생성</target>
        </trans-unit>
        <trans-unit id="8825d513eda107425c4db37ecc245cbce4bd8d15" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D numpy array.</source>
          <target state="translated">주어진 1 차원 numpy 배열에서 무작위 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb9b080c4a972cdca3ac39c4646147c92b34cc" translate="yes" xml:space="preserve">
          <source>Generating ranges of timestamps</source>
          <target state="translated">타임 스탬프 범위 생성</target>
        </trans-unit>
        <trans-unit id="d0bf3a03bd47b9dd9ed6c94d4c73789b10776bf3" translate="yes" xml:space="preserve">
          <source>Generator expressions</source>
          <target state="translated">생성기 표현식</target>
        </trans-unit>
        <trans-unit id="e6ffe0b73bdf76de6a54e29b687da0fb0cc766d3" translate="yes" xml:space="preserve">
          <source>Generator yielding sequence of (name, subsetted object)</source>
          <target state="translated">(이름, 부분 집합 객체)의 생성기 생성 순서</target>
        </trans-unit>
        <trans-unit id="b01f6cccf5c430a83b24dca76d9975bcf356977c" translate="yes" xml:space="preserve">
          <source>Geopandas</source>
          <target state="translated">Geopandas</target>
        </trans-unit>
        <trans-unit id="cb776443950280f6cba9d022306b92a37aebde5d" translate="yes" xml:space="preserve">
          <source>Geopandas extends pandas data objects to include geographic information which support geometric operations. If your work entails maps and geographical coordinates, and you love pandas, you should take a close look at Geopandas.</source>
          <target state="translated">Geopandas는 팬더 데이터 오브젝트를 확장하여 기하학적 조작을 지원하는 지리 정보를 포함합니다. 작품에지도와 지리적 좌표가 필요하고 팬더를 좋아한다면 Geopandas를 자세히 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="ae2b7868a7d16c6026fb9f6641c4c055febc08c7" translate="yes" xml:space="preserve">
          <source>Get Addition of dataframe and other, element-wise (binary operator &lt;code&gt;add&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 &lt;code&gt;add&lt;/code&gt; (이진 연산자 add ) 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="dadbf9ed77fbdc257016c633c7e291e7b73e7cd7" translate="yes" xml:space="preserve">
          <source>Get Addition of dataframe and other, element-wise (binary operator &lt;code&gt;radd&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 추가 (바이너리 연산자 &lt;code&gt;radd&lt;/code&gt; )를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6881b850c3c986532c08fb363c53b2eb0225116b" translate="yes" xml:space="preserve">
          <source>Get Equal to of dataframe and other, element-wise (binary operator &lt;code&gt;eq&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위 (이진 연산자 &lt;code&gt;eq&lt;/code&gt; )와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8eb4c6e43f6b5f7f1f412175306b6bb201708cee" translate="yes" xml:space="preserve">
          <source>Get Exponential power of dataframe and other, element-wise (binary operator &lt;code&gt;pow&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 지수 (이진 연산자 &lt;code&gt;pow&lt;/code&gt; )의 지수를 구합니다 .</target>
        </trans-unit>
        <trans-unit id="9e2adf723c6a76eeacda639340be16ce67a6fb1b" translate="yes" xml:space="preserve">
          <source>Get Exponential power of dataframe and other, element-wise (binary operator &lt;code&gt;rpow&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 지수 (이진 연산자 &lt;code&gt;rpow&lt;/code&gt; )의 지수를 구합니다 .</target>
        </trans-unit>
        <trans-unit id="727dbad4ab0d8474a93248f1508b0cc0c9f1b307" translate="yes" xml:space="preserve">
          <source>Get Floating division of dataframe and other, element-wise (binary operator &lt;code&gt;rtruediv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 부동 나누기를 &lt;code&gt;rtruediv&lt;/code&gt; (이진 연산자 rtruediv ).</target>
        </trans-unit>
        <trans-unit id="d8378a422387e375d08740b312f9be047a2f00a1" translate="yes" xml:space="preserve">
          <source>Get Floating division of dataframe and other, element-wise (binary operator &lt;code&gt;truediv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 부동 나누기를 &lt;code&gt;truediv&lt;/code&gt; (이진 연산자 truediv ).</target>
        </trans-unit>
        <trans-unit id="44b0e6b5f85380abfebaa39e25b3823f213b24b9" translate="yes" xml:space="preserve">
          <source>Get Greater than of dataframe and other, element-wise (binary operator &lt;code&gt;gt&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;gt&lt;/code&gt; ) 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="b92efef83c131fe503d93b81d6d7dcfaa3ebbec3" translate="yes" xml:space="preserve">
          <source>Get Greater than or equal to of dataframe and other, element-wise (binary operator &lt;code&gt;ge&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;ge&lt;/code&gt; ) 보다 크거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3b3323a949a6f3b8c35324c9770c44dcf422805f" translate="yes" xml:space="preserve">
          <source>Get Integer division of dataframe and other, element-wise (binary operator &lt;code&gt;floordiv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 정수 나누기를 &lt;code&gt;floordiv&lt;/code&gt; (이진 연산자 floordiv ).</target>
        </trans-unit>
        <trans-unit id="a9a9d2b9cdcb9c5d2b98c51cd705b440d80846d3" translate="yes" xml:space="preserve">
          <source>Get Integer division of dataframe and other, element-wise (binary operator &lt;code&gt;rfloordiv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 정수 나누기를 &lt;code&gt;rfloordiv&lt;/code&gt; (이진 연산자 rfloordiv ).</target>
        </trans-unit>
        <trans-unit id="42cad2ed7313d6b9b23637df759f19fa00d341fc" translate="yes" xml:space="preserve">
          <source>Get Less than of dataframe and other, element-wise (binary operator &lt;code&gt;lt&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위보다 적습니다 (이진 연산자 &lt;code&gt;lt&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="043ee0ad8a1d3fa93c2d6c75fa60bc7c570d85ef" translate="yes" xml:space="preserve">
          <source>Get Less than or equal to of dataframe and other, element-wise (binary operator &lt;code&gt;le&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임보다 작거나 같고 다른 요소 별 (이진 연산자 &lt;code&gt;le&lt;/code&gt; )을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="ce91129ba136f0463638b325f7b4a5fc85531dd6" translate="yes" xml:space="preserve">
          <source>Get Modulo of dataframe and other, element-wise (binary operator &lt;code&gt;mod&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;mod&lt;/code&gt; )의 Modulo를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2166c9895afda2fe3805a4ed6a37715f8be994ff" translate="yes" xml:space="preserve">
          <source>Get Modulo of dataframe and other, element-wise (binary operator &lt;code&gt;rmod&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;rmod&lt;/code&gt; )의 Modulo를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a9db3feb3586f1258e403412cc555b754ab3c92a" translate="yes" xml:space="preserve">
          <source>Get Multiplication of dataframe and other, element-wise (binary operator &lt;code&gt;mul&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 곱셈 (이진 연산자 &lt;code&gt;mul&lt;/code&gt; )을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="1388d2cf2af80e17317c08f9770b52a49f9c2f2d" translate="yes" xml:space="preserve">
          <source>Get Multiplication of dataframe and other, element-wise (binary operator &lt;code&gt;rmul&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 곱셈 (이진 연산자 &lt;code&gt;rmul&lt;/code&gt; )을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8d2d574ef5c8590ffef550e6bdd72a846a37f4c8" translate="yes" xml:space="preserve">
          <source>Get Not equal to of dataframe and other, element-wise (binary operator &lt;code&gt;ne&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위 (이진 연산자 &lt;code&gt;ne&lt;/code&gt; ) 와 같지 않음</target>
        </trans-unit>
        <trans-unit id="5d7a3ecd88fdea915d9e5f10e4a4bf57cd19868a" translate="yes" xml:space="preserve">
          <source>Get Subtraction of dataframe and other, element-wise (binary operator &lt;code&gt;rsub&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 빼기 (이진 연산자 &lt;code&gt;rsub&lt;/code&gt; )를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3146ba91d874f9eec6369574348eb7294ec036ef" translate="yes" xml:space="preserve">
          <source>Get Subtraction of dataframe and other, element-wise (binary operator &lt;code&gt;sub&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 빼기 (이진 연산자 &lt;code&gt;sub&lt;/code&gt; ) 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5ffb03ddea42699557317c0964d22c0679b431fc" translate="yes" xml:space="preserve">
          <source>Get both the location for the requested label(s) and the resulting sliced index.</source>
          <target state="translated">요청 된 레이블의 위치와 결과로 생성 된 슬라이스 인덱스를 모두 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d7e7e84fb35f14833cafb97389a3676c8f6152f2" translate="yes" xml:space="preserve">
          <source>Get day of the month that a Period falls on.</source>
          <target state="translated">기간이 속하는 월의 일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="23dc3a30559b7e6e6eedb5f3c3b58fd37774290b" translate="yes" xml:space="preserve">
          <source>Get integer location, slice or boolean mask for requested label.</source>
          <target state="translated">요청 된 레이블에 대한 정수 위치, 슬라이스 또는 부울 마스크를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1495512810109b6180c84bd6f543e79e38733811" translate="yes" xml:space="preserve">
          <source>Get item from object for given key (ex: DataFrame column).</source>
          <target state="translated">주어진 키에 대해 객체에서 항목을 가져옵니다 (예 : DataFrame 열).</target>
        </trans-unit>
        <trans-unit id="8b71bfe2d62d2b197499002a79677564b6bb8b4f" translate="yes" xml:space="preserve">
          <source>Get just the index locations for values at particular time of the day.</source>
          <target state="translated">하루 중 특정 시간의 값에 대한 색인 위치 만 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="71c260bc2dc68edd80f8a6e385cc5f4a28047b23" translate="yes" xml:space="preserve">
          <source>Get just the index locations for values between particular times of the day.</source>
          <target state="translated">하루 중 특정 시간 사이의 값에 대한 색인 위치 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="573ad3e027b86128c73222c5a4a405ad9e017adb" translate="yes" xml:space="preserve">
          <source>Get level values by supplying &lt;code&gt;level&lt;/code&gt; as integer:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 을 정수 로 제공하여 레벨 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1111149ddd1953c3acf759b763c942dd6aebdb5c" translate="yes" xml:space="preserve">
          <source>Get level values by supplying level as either integer or name:</source>
          <target state="translated">레벨을 정수 또는 이름으로 제공하여 레벨 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6a307c9491073aca10dcc83b9998b926c3f1eacf" translate="yes" xml:space="preserve">
          <source>Get location for a label or a tuple of labels as an integer, slice or boolean mask.</source>
          <target state="translated">레이블, 레이블 튜플의 위치를 ​​정수, 슬라이스 또는 부울 마스크로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="04948c999aacd8c60e4754df05b4fa1f888c796a" translate="yes" xml:space="preserve">
          <source>Get location for a label or a tuple of labels.</source>
          <target state="translated">레이블 또는 튜플 레이블 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="029e778ca715f569b320678ab17a54cf332a28ca" translate="yes" xml:space="preserve">
          <source>Get location for a label/slice/list/mask or a sequence of such.</source>
          <target state="translated">레이블 / 슬라이스 / 목록 / 마스크 또는 일련의 해당 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="824b3bc5f378073942323556dbc08c4d67ff1704" translate="yes" xml:space="preserve">
          <source>Get location for a single label.</source>
          <target state="translated">단일 라벨의 위치를 ​​확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e8470b50a051d8c2a1e07f71b2068d0272a87805" translate="yes" xml:space="preserve">
          <source>Get minute of the hour component of the Period.</source>
          <target state="translated">기간의 분 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="61c884339a71957b8fa72a90bf638fe5fdb4f3e5" translate="yes" xml:space="preserve">
          <source>Get slice location given start label(s) and end label(s).</source>
          <target state="translated">시작 레이블과 끝 레이블이 주어진 슬라이스 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="32e22c5444ec637133057a762bc46d660f56e619" translate="yes" xml:space="preserve">
          <source>Get the &amp;lsquo;info axis&amp;rsquo; (see Indexing for more)</source>
          <target state="translated">'정보 축'가져 오기 (자세한 내용은 색인 생성 참조)</target>
        </trans-unit>
        <trans-unit id="e9b674ec2f37a30b7d5417d9d9378cd3eba5604d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;n&lt;/code&gt; largest elements.</source>
          <target state="translated">가져 오기 &lt;code&gt;n&lt;/code&gt; 개의 가장 큰 요소.</target>
        </trans-unit>
        <trans-unit id="eca332631315a697ab2dadd0c683ad9188881f34" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;n&lt;/code&gt; smallest elements.</source>
          <target state="translated">가져 오기 &lt;code&gt;n&lt;/code&gt; 개의 작은 요소.</target>
        </trans-unit>
        <trans-unit id="4601ee7e2fc8bf47de5b97b0291cc9199dcbd1f0" translate="yes" xml:space="preserve">
          <source>Get the Timestamp for the start of the period.</source>
          <target state="translated">기간 시작에 대한 타임 스탬프를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="07f7d1de1063ebe9947bb90e5cdae317654a67e9" translate="yes" xml:space="preserve">
          <source>Get the actual data stored within.</source>
          <target state="translated">저장된 실제 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="99634341ab162b4a7396497551aed6dd030cfe5b" translate="yes" xml:space="preserve">
          <source>Get the day component of the Period.</source>
          <target state="translated">기간의 요일 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4a98cce76b327ba3b387b56ccf083be789e26381" translate="yes" xml:space="preserve">
          <source>Get the day of the week.</source>
          <target state="translated">요일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="189df6716b5a6b1d989b4c51ba0f2748cb480e4d" translate="yes" xml:space="preserve">
          <source>Get the day of the year.</source>
          <target state="translated">일의 날을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="3deee4a9d34c0e6128411af19bb5850492ac27ff" translate="yes" xml:space="preserve">
          <source>Get the hour component of the Period.</source>
          <target state="translated">기간의 시간 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="62648ef6be87d89f5f8136953dd96632265809c2" translate="yes" xml:space="preserve">
          <source>Get the hour of the day component of the Period.</source>
          <target state="translated">기간의 하루 중 시간 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4f664bca93b0209423129c921a083c98b2152f5d" translate="yes" xml:space="preserve">
          <source>Get the minute component of the Period.</source>
          <target state="translated">기간의 분 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e5068a6788db19fad22f4e850406d75cc69f2210" translate="yes" xml:space="preserve">
          <source>Get the mode(s) of each element along the selected axis.</source>
          <target state="translated">선택한 축을 따라 각 요소의 모드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="17b8d7dc3d99a3a7619e34b598ea2a54a9b136e0" translate="yes" xml:space="preserve">
          <source>Get the rows for the first 3 days:</source>
          <target state="translated">처음 3 일 동안 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6a1dd6ed89163a698fe72b6a036b624ca3dfd259" translate="yes" xml:space="preserve">
          <source>Get the rows for the last 3 days:</source>
          <target state="translated">지난 3 일 동안 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e8d5ed0b60b1464f225b6afd929fe0b75bc9b685" translate="yes" xml:space="preserve">
          <source>Get the second component of the Period.</source>
          <target state="translated">기간의 두 번째 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7b83fc8ba8d64c22a2ea6d6c1df748bef59fdfc" translate="yes" xml:space="preserve">
          <source>Get the total number of days in the month that this period falls on.</source>
          <target state="translated">이 기간이 속하는 달의 총 일수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8c6497692eca0d6502e69e194009ad5c889b26f0" translate="yes" xml:space="preserve">
          <source>Get the total number of days of the month that the Period falls in.</source>
          <target state="translated">기간이 속하는 달의 총 일 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ec5e090f583787b867bee0f65078446f1ea000fa" translate="yes" xml:space="preserve">
          <source>Get the week of the year on the given Period.</source>
          <target state="translated">주어진 기간에 연중 주를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f4b514c04c85dbc73a28873d10a5448e0822974" translate="yes" xml:space="preserve">
          <source>Get value at specified row/column pair</source>
          <target state="translated">지정된 행 / 열 쌍에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="e9db42f4395fcd5fb0233badf519ef8ac271a5f0" translate="yes" xml:space="preserve">
          <source>Get value within a Series</source>
          <target state="translated">시리즈 내에서 가치 창출</target>
        </trans-unit>
        <trans-unit id="f196f6bda0f581e85f5082a9236f74807e223dbe" translate="yes" xml:space="preserve">
          <source>Get value within a series</source>
          <target state="translated">시리즈 내에서 가치를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="59cd54cc529534492d232423983da9f637e45a87" translate="yes" xml:space="preserve">
          <source>Get values at several indexes</source>
          <target state="translated">여러 인덱스에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="13203bb9c3a173284d2d8adbcf5dfbfd5b23a1ad" translate="yes" xml:space="preserve">
          <source>Get values at several indexes and levels</source>
          <target state="translated">여러 지수와 수준에서 가치를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="7737c7550574f5e4bba8b3eb93e76f282e82a8bd" translate="yes" xml:space="preserve">
          <source>Get values at specified column and axis</source>
          <target state="translated">지정된 열과 축에서 값을 얻습니다</target>
        </trans-unit>
        <trans-unit id="c3cf089d4fdd1a573c5c5d9ef92841253297d6ed" translate="yes" xml:space="preserve">
          <source>Get values at specified index</source>
          <target state="translated">지정된 인덱스에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="1b70443afd4b6214bb9fbf7909cd12798c9821c6" translate="yes" xml:space="preserve">
          <source>Get values at specified index and level</source>
          <target state="translated">지정된 색인 및 수준에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3eef0696906c70598950c0cf85ca15d449e50d3d" translate="yes" xml:space="preserve">
          <source>Get values for a level of a MultiIndex.</source>
          <target state="translated">MultiIndex 수준의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="907aece8915b1fd3f6cf9d65eb58f61fcf680c08" translate="yes" xml:space="preserve">
          <source>Gets the number of days in the month.</source>
          <target state="translated">해당 월의 일 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f5e032919594a9cf02d07af96697f2910cd6272d" translate="yes" xml:space="preserve">
          <source>Getting and setting options</source>
          <target state="translated">옵션 얻기 및 설정</target>
        </trans-unit>
        <trans-unit id="608052c50c86b3eb1e82a7ca328a285e362cdc4c" translate="yes" xml:space="preserve">
          <source>Getting data in/out</source>
          <target state="translated">데이터 입 / 출력</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="dc7206940ee12f67d6eae829d10799db2074f500" translate="yes" xml:space="preserve">
          <source>Getting started with Git</source>
          <target state="translated">Git 시작하기</target>
        </trans-unit>
        <trans-unit id="141c851d4caafbc68efdb1a768132c88f34d77f5" translate="yes" xml:space="preserve">
          <source>Getting support</source>
          <target state="translated">지원 받기</target>
        </trans-unit>
        <trans-unit id="21f6ceca1bbf6fe07b539a2f576e14d457783d96" translate="yes" xml:space="preserve">
          <source>Getting the &lt;code&gt;Index&lt;/code&gt; values of a &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 &lt;code&gt;Index&lt;/code&gt; 값 얻기 :</target>
        </trans-unit>
        <trans-unit id="6581ebf227a8e26691ae34c23b5c2a21e509085d" translate="yes" xml:space="preserve">
          <source>Getting the examples pass the doctests in the validation script can sometimes be tricky. Here are some attention points:</source>
          <target state="translated">예제가 유효성 검사 스크립트의 doctest를 통과시키는 것은 까다로울 수 있습니다. 다음은 몇 가지주의 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1be10a2c118e99a528e8d10b29eff17ab62e2d96" translate="yes" xml:space="preserve">
          <source>Getting values from an object with multi-axes selection uses the following notation (using &lt;code&gt;.loc&lt;/code&gt; as an example, but the following applies to &lt;code&gt;.iloc&lt;/code&gt; as well). Any of the axes accessors may be the null slice &lt;code&gt;:&lt;/code&gt;. Axes left out of the specification are assumed to be &lt;code&gt;:&lt;/code&gt;, e.g. &lt;code&gt;p.loc['a']&lt;/code&gt; is equivalent to &lt;code&gt;p.loc['a', :, :]&lt;/code&gt;.</source>
          <target state="translated">다중 축을 선택하여 객체에서 값을 &lt;code&gt;.loc&lt;/code&gt; &lt;code&gt;.iloc&lt;/code&gt; 다음 표기법을 사용합니다 ( 예를 들어 .loc 을 사용 하지만 .iloc 에도 적용됨 ). 축에 접근 중 어떤 널 조각 될 수있다 &lt;code&gt;:&lt;/code&gt; . 사양에서 제외 된 축은 다음과 같이 가정합니다 &lt;code&gt;:&lt;/code&gt; 예를 들어 &lt;code&gt;p.loc['a']&lt;/code&gt; 는 &lt;code&gt;p.loc['a', :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd711296b40c18649d46559dd68b1ee0da737bc5" translate="yes" xml:space="preserve">
          <source>Given a 1d array, return an array of deterministic integers.</source>
          <target state="translated">1d 배열이 주어지면 결정적 정수 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="3a3796a0f5fe11d12313dd4f66af267c77c58905" translate="yes" xml:space="preserve">
          <source>Given a Series of points randomly sampled from an unknown distribution, estimate its PDF using KDE with automatic bandwidth determination and plot the results, evaluating them at 1000 equally spaced points (default):</source>
          <target state="translated">알 수없는 분포에서 무작위로 샘플링 된 일련의 점이 주어지면 자동 대역폭 결정과 함께 KDE를 사용하여 PDF를 추정하고 결과를 플로팅하여 1000 개의 동일한 간격 점으로 평가합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="3f46c4cef009aef06e3694e93a8139836dbe2191" translate="yes" xml:space="preserve">
          <source>Given a grouper, the function resamples it according to a string &amp;ldquo;string&amp;rdquo; -&amp;gt; &amp;ldquo;frequency&amp;rdquo;.</source>
          <target state="translated">그룹화가 주어지면이 함수는 문자열 &quot;string&quot;-&amp;gt; &quot;frequency&quot;에 따라 리샘플링합니다.</target>
        </trans-unit>
        <trans-unit id="a7c6bf9d23675574ea35af12d4bd450996ba46af" translate="yes" xml:space="preserve">
          <source>Given a table name and a SQLAlchemy connectable, returns a DataFrame. This function does not support DBAPI connections.</source>
          <target state="translated">테이블 이름과 SQLAlchemy 연결 가능이 주어지면 DataFrame을 리턴합니다. 이 기능은 DBAPI 연결을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b87d15eecdea8eb7653c12b4e51c23d4fea5052c" translate="yes" xml:space="preserve">
          <source>Given equal-length arrays of row and column labels, return an array of the values corresponding to each (row, col) pair.</source>
          <target state="translated">동일한 길이의 행 및 열 레이블 배열이 제공되면 각 (행, 열) 쌍에 해당하는 값의 배열을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="453762880d5aba77583acd766f4497e2fda5fc63" translate="yes" xml:space="preserve">
          <source>Going forward, we are moving to a more &lt;em&gt;functional&lt;/em&gt; style using the &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; framework, which offers a richer testing framework that will facilitate testing and developing. Thus, instead of writing test classes, we will write test functions like this:</source>
          <target state="translated">앞으로 우리는 &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; 프레임 워크를 사용하여 보다 &lt;em&gt;기능적인&lt;/em&gt; 스타일로 전환하고 있습니다. pytest 프레임 워크는 테스트 및 개발을 용이하게하는 풍부한 테스트 프레임 워크를 제공합니다. 따라서 테스트 클래스를 작성하는 대신 다음과 같은 테스트 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a5f07bcb9bd2209b6891a0a5088f4aee79499a3e" translate="yes" xml:space="preserve">
          <source>Going from long back to wide just takes some creative use of &lt;code&gt;unstack&lt;/code&gt;</source>
          <target state="translated">오래전부터 넓게 돌아 가면 &lt;code&gt;unstack&lt;/code&gt; 창의적으로 사용하기 만하면됩니다</target>
        </trans-unit>
        <trans-unit id="c0cda22631dd1ea825c1317ced801a160bf0d263" translate="yes" xml:space="preserve">
          <source>Google Big Query</source>
          <target state="translated">구글 빅 쿼리</target>
        </trans-unit>
        <trans-unit id="2aa23a69a54076f50966d834705f7f8b7c75fb86" translate="yes" xml:space="preserve">
          <source>Google Big Query access</source>
          <target state="translated">Google Big Query 액세스</target>
        </trans-unit>
        <trans-unit id="e7a072101b6dc4cffd92e0691a040783403ff051" translate="yes" xml:space="preserve">
          <source>Google BigQuery</source>
          <target state="translated">Google BigQuery</target>
        </trans-unit>
        <trans-unit id="baba5872dc3b988b52803423439f4bd3bf204801" translate="yes" xml:space="preserve">
          <source>Google BigQuery Account project ID. Optional when available from the environment.</source>
          <target state="translated">Google BigQuery 계정 프로젝트 ID 환경에서 사용 가능한 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1e15a0e47310034f5db3e8c25f23a00ccb08922b" translate="yes" xml:space="preserve">
          <source>Google Cloud Storage access</source>
          <target state="translated">Google 클라우드 저장소 액세스</target>
        </trans-unit>
        <trans-unit id="d887b25f7c1a45f4ebe5a21e2237262384db2f4e" translate="yes" xml:space="preserve">
          <source>Google Finance</source>
          <target state="translated">Google 금융</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="55e73c0f5407b8794ebbf6f430bb0b67ff6270a1" translate="yes" xml:space="preserve">
          <source>Greater than of series and other.</source>
          <target state="translated">시리즈와 다른 것보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="37b28639298b1f085109978610256242435a1984" translate="yes" xml:space="preserve">
          <source>Group By: split-apply-combine</source>
          <target state="translated">분류 기준 : split-apply-combine</target>
        </trans-unit>
        <trans-unit id="3ad5aa335bf8f7a15b17daec2eb082dce11e523f" translate="yes" xml:space="preserve">
          <source>Group DataFrame or Series using a mapper or by a Series of columns.</source>
          <target state="translated">매퍼를 사용하거나 일련의 열을 기준으로 DataFrame 또는 Series를 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="936a26a0e5b573119c16b0b168b4db2a80507b68" translate="yes" xml:space="preserve">
          <source>Group by mapping, function, label, or list of labels.</source>
          <target state="translated">매핑, 기능, 레이블 또는 레이블 목록별로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="7296f39827af27186dc97498d3664bcda7a0278b" translate="yes" xml:space="preserve">
          <source>Group left DataFrame by group columns and merge piece by piece with right DataFrame</source>
          <target state="translated">왼쪽 열을 그룹 열별로 그룹화하고 오른쪽 DataFrame을 사용하여 조각별로 병합</target>
        </trans-unit>
        <trans-unit id="52590aceb82999e5cffb23f0d3a8acd6d395ff36" translate="yes" xml:space="preserve">
          <source>Group right DataFrame by group columns and merge piece by piece with left DataFrame</source>
          <target state="translated">그룹 열별로 오른쪽 DataFrame을 그룹화하고 왼쪽 DataFrame으로 조각별로 병합</target>
        </trans-unit>
        <trans-unit id="5a98397137ec4e2773eeafe47898de4f7267c4f7" translate="yes" xml:space="preserve">
          <source>Group the index labels by a given array of values.</source>
          <target state="translated">주어진 값 배열로 색인 레이블을 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="41b5a96267dccb4d82371d385b32a0d7df0a44e1" translate="yes" xml:space="preserve">
          <source>Group where to start walking. If not supplied, the root group is used.</source>
          <target state="translated">걷기 시작하는 그룹. 제공되지 않으면 루트 그룹이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="280e0dcd01a74e9f2971dc15e9ea5e4fed9ba1e7" translate="yes" xml:space="preserve">
          <source>GroupBy objects are returned by groupby calls: &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt;&lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt;&lt;code&gt;pandas.Series.groupby()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">GroupBy 객체는 &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt; &lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt; &lt;code&gt;pandas.Series.groupby()&lt;/code&gt; &lt;/a&gt; 등의 그룹 호출로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab29307976ccacc26ac65efc4e37aa349c72454e" translate="yes" xml:space="preserve">
          <source>Groupby iterator.</source>
          <target state="translated">그룹 별 반복자.</target>
        </trans-unit>
        <trans-unit id="e63f7dc74d42e24a6af9901ab8b42b7aa13d4a1a" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of only particular column in the group.</source>
          <target state="translated">하나의 열로 그룹화하고 그룹의 특정 열만 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1791776b439188ec61725cdf5b05148568043324" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of the remaining columns in each group.</source>
          <target state="translated">하나의 열을 그룹화하고 각 그룹의 나머지 열의 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d720fc80687d90ae00e0ff29c33e68654b9f8d9c" translate="yes" xml:space="preserve">
          <source>Groupby two columns and return the mean of the remaining column.</source>
          <target state="translated">두 개의 열을 그룹화하고 나머지 열의 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42c8f672af9a6da3268b6f4a99958d6e735607b1" translate="yes" xml:space="preserve">
          <source>Grouper</source>
          <target state="translated">Grouper</target>
        </trans-unit>
        <trans-unit id="439ef5b4855b51a20d486556cd3d53a3ceee4963" translate="yes" xml:space="preserve">
          <source>Grouper()</source>
          <target state="translated">Grouper()</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="3360636443934b7226aa2d127f6a2ac58e7d4669" translate="yes" xml:space="preserve">
          <source>Grouping and summarizing</source>
          <target state="translated">그룹화 및 요약</target>
        </trans-unit>
        <trans-unit id="79300cb379b299ff45fb8750bc24f22896f49f6d" translate="yes" xml:space="preserve">
          <source>Guaranteed return of an indexer even when non-unique.</source>
          <target state="translated">고유하지 않은 경우에도 인덱서의 반환을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4d0784f9d9f96af76bb1f3d1e361bf164aa153e1" translate="yes" xml:space="preserve">
          <source>HDF5 (PyTables)</source>
          <target state="translated">HDF5 (PyTables)</target>
        </trans-unit>
        <trans-unit id="92aab64c23220250c4b7eff53be23edf32d43f26" translate="yes" xml:space="preserve">
          <source>HDF5 Format</source>
          <target state="translated">HDF5 형식</target>
        </trans-unit>
        <trans-unit id="13e3758fc9538b8efd6e347d1be18dbf1cbc68fd" translate="yes" xml:space="preserve">
          <source>HDF5 reading / writing</source>
          <target state="translated">HDF5 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="2042ab10d2a6b286f6f10f05830da036077c6714" translate="yes" xml:space="preserve">
          <source>HDF5-based reading / writing</source>
          <target state="translated">HDF5 기반 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="2315b78c90521194806e6ff15e4519be29290f8e" translate="yes" xml:space="preserve">
          <source>HDFStore.append()</source>
          <target state="translated">HDFStore.append()</target>
        </trans-unit>
        <trans-unit id="3c06f7762f6274d7f755a35a5ece2d1938d4d16f" translate="yes" xml:space="preserve">
          <source>HDFStore.get()</source>
          <target state="translated">HDFStore.get()</target>
        </trans-unit>
        <trans-unit id="cf1d970069f4505ca66af47560075f080d7fdebb" translate="yes" xml:space="preserve">
          <source>HDFStore.groups()</source>
          <target state="translated">HDFStore.groups()</target>
        </trans-unit>
        <trans-unit id="2ac4435c6ecd4445adfd51cc1924d3128de8464c" translate="yes" xml:space="preserve">
          <source>HDFStore.info()</source>
          <target state="translated">HDFStore.info()</target>
        </trans-unit>
        <trans-unit id="a63dab9ef218085a01b08427a9709a9da31fdd26" translate="yes" xml:space="preserve">
          <source>HDFStore.keys()</source>
          <target state="translated">HDFStore.keys()</target>
        </trans-unit>
        <trans-unit id="3adc308c4363c6063de35b9f347d5df2b4b2dd55" translate="yes" xml:space="preserve">
          <source>HDFStore.put()</source>
          <target state="translated">HDFStore.put()</target>
        </trans-unit>
        <trans-unit id="f47662db7950975a5ae22dcd0f80f911933903e7" translate="yes" xml:space="preserve">
          <source>HDFStore.select()</source>
          <target state="translated">HDFStore.select()</target>
        </trans-unit>
        <trans-unit id="1832f491303fd89a2974748d322daf584ae70a42" translate="yes" xml:space="preserve">
          <source>HDFStore.walk()</source>
          <target state="translated">HDFStore.walk()</target>
        </trans-unit>
        <trans-unit id="a7b6ae83f2cc25f8ad0ff53d17f8388b4154d54e" translate="yes" xml:space="preserve">
          <source>HDFStore: PyTables (HDF5)</source>
          <target state="translated">HDFStore : PyTables (HDF5)</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="bec8b87bbf1ceb04748df519c09bdd4a4242e7e8" translate="yes" xml:space="preserve">
          <source>HTML parser for read_html (see &lt;a href=&quot;#optional-html&quot;&gt;note&lt;/a&gt;)</source>
          <target state="translated">read_html 용 HTML 파서 (참고 &lt;a href=&quot;#optional-html&quot;&gt;사항&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="dc1a076811de9231220364407db78fe7dff1efa1" translate="yes" xml:space="preserve">
          <source>Hadley Wickham&amp;rsquo;s &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; is a foundational exploratory visualization package for the R language. Based on &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;The Grammar of Graphics&amp;rdquo;&lt;/a&gt; it provides a powerful, declarative and extremely general way to generate bespoke plots of any kind of data. It&amp;rsquo;s really quite incredible. Various implementations to other languages are available, but a faithful implementation for Python users has long been missing. Although still young (as of Jan-2014), the &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat/ggpy&lt;/a&gt; project has been progressing quickly in that direction.</source>
          <target state="translated">Hadley Wickham의 &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; 는 R 언어를위한 기본 탐색 시각화 패키지입니다. &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&quot;그래픽 문법&quot;을&lt;/a&gt; 기반으로 모든 종류의 데이터에 대한 맞춤형 플롯을 생성하는 강력하고 선언적이며 매우 일반적인 방법을 제공합니다. 정말 대단합니다. 다른 언어에 대한 다양한 구현이 가능하지만 Python 사용자를위한 충실한 구현은 오랫동안 누락되었습니다. 아직은 젊지 만 (2014 년 1 월 현재) &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat / ggpy&lt;/a&gt; 프로젝트는 그 방향으로 빠르게 진행되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c197bf13850693a62be0f9cbc4ad92a5ec806fd" translate="yes" xml:space="preserve">
          <source>Handler to call if object cannot otherwise be converted to a suitable format for JSON. Should receive a single argument which is the object to convert and return a serialisable object.</source>
          <target state="translated">그렇지 않으면 객체를 JSON에 적합한 형식으로 변환 할 수없는 경우 호출 할 핸들러입니다. 직렬화 가능한 객체를 변환하고 반환 할 객체 인 단일 인수를 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc3b2505837662fcbdfc517f2a1895b70ef262d" translate="yes" xml:space="preserve">
          <source>Handles the leap year case as well:</source>
          <target state="translated">윤년 사례도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8ebd411c16de03f824e7e963a0ca15fcfc23c034" translate="yes" xml:space="preserve">
          <source>Has no effect but is accepted for compatibility with numpy.</source>
          <target state="translated">효과는 없지만 numpy와의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3008b93348839f05f66696fd64d26af09f702629" translate="yes" xml:space="preserve">
          <source>Has the correct &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; class attributes set.</source>
          <target state="translated">올바른 &lt;code&gt;env&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; 클래스 속성이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d2254d4a789d989c2b2664108442e3526a1101" translate="yes" xml:space="preserve">
          <source>Hash table-based unique.</source>
          <target state="translated">해시 테이블 기반 고유.</target>
        </trans-unit>
        <trans-unit id="6425f543a801b25f82203571fd175fdf4730a76a" translate="yes" xml:space="preserve">
          <source>Hash table-based unique. Uniques are returned in order of appearance. This does NOT sort.</source>
          <target state="translated">해시 테이블 기반 고유. 모양 순서대로 고유 항목이 반환됩니다. 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="880b58b88e88151082e731678ce3c724dafb7219" translate="yes" xml:space="preserve">
          <source>Head and tail</source>
          <target state="translated">머리와 꼬리</target>
        </trans-unit>
        <trans-unit id="ef6feb04d2cc1517b1a7d23c7680888c4feb48d2" translate="yes" xml:space="preserve">
          <source>Helps style a DataFrame or Series according to the data with HTML and CSS.</source>
          <target state="translated">HTML 및 CSS를 사용하여 데이터에 따라 DataFrame 또는 Series 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158ccd51d8c878205e5636d3f99db16bf05effe5" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;c&amp;rsquo; and &amp;lsquo;f&amp;rsquo; are not represented in the data and will not be shown in the output because dropna is True by default. Set dropna=False to preserve categories with no data.</source>
          <target state="translated">여기서 'c'와 'f'는 데이터에 표시되지 않으며 dropna가 기본적으로 True이므로 출력에 표시되지 않습니다. 데이터가없는 카테고리를 유지하려면 dropna = False로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="eb498dc0133a396e16fbab2a4cc64715ce635afe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;'type'&lt;/code&gt; is optional, and can be a nested pandas type specification here (but not categorical)</source>
          <target state="translated">여기서 &lt;code&gt;'type'&lt;/code&gt; 은 선택 사항이며 여기에서 중첩 팬더 유형 사양 일 수 있습니다 (단, 범주는 아님).</target>
        </trans-unit>
        <trans-unit id="1d0d20df741a19de9966e743d9965ede0d8c2325" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;origin&lt;/code&gt; is the default name given to your remote repository on GitHub. You can see the remote repositories:</source>
          <target state="translated">여기서 &lt;code&gt;origin&lt;/code&gt; 은 GitHub의 원격 저장소에 지정된 기본 이름입니다. 원격 저장소를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd7acc3d2934c47bf767aabcf0a0a1045090fcba" translate="yes" xml:space="preserve">
          <source>Here are a few interesting examples.</source>
          <target state="translated">다음은 몇 가지 흥미로운 예입니다.</target>
        </trans-unit>
        <trans-unit id="57c90bbd4cc0875781c24f250ae82def1a858909" translate="yes" xml:space="preserve">
          <source>Here are just a few of the things that pandas does well:</source>
          <target state="translated">팬더가 잘하는 몇 가지 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4aeaea13540388e074b786658dd6cb588265e66" translate="yes" xml:space="preserve">
          <source>Here is a basic tenet to keep in mind: &lt;strong&gt;data alignment is intrinsic&lt;/strong&gt;. The link between labels and data will not be broken unless done so explicitly by you.</source>
          <target state="translated">다음은 명심해야 할 기본 원칙입니다. &lt;strong&gt;데이터 정렬은 본질적&lt;/strong&gt; 입니다. 사용자가 명시 적으로하지 않으면 레이블과 데이터 간의 연결이 끊어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ea58d8d9e42af87e8caa9d68ed8a547761d5bb4" translate="yes" xml:space="preserve">
          <source>Here is a more complicated example with multiple join keys. Only the keys appearing in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are present (the intersection), since &lt;code&gt;how='inner'&lt;/code&gt; by default.</source>
          <target state="translated">다음은 여러 개의 조인 키가있는보다 복잡한 예입니다. 기본적으로 &lt;code&gt;how='inner'&lt;/code&gt; 이므로 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 나타나는 키 (교차점) 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5643537f0f51a6854fc58eb3352e4428cfc1a6" translate="yes" xml:space="preserve">
          <source>Here is a real-world times-series example</source>
          <target state="translated">다음은 실제 시계열 예제입니다.</target>
        </trans-unit>
        <trans-unit id="3f944828834dd16d5151a4915c604fb981122b37" translate="yes" xml:space="preserve">
          <source>Here is an example of a self-contained set of tests that illustrate multiple features that we like to use.</source>
          <target state="translated">다음은 우리가 사용하고자하는 여러 기능을 보여주는 자체 포함 테스트 세트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="23a618ab8a95adb5ee1b90429b7d557f8f970e97" translate="yes" xml:space="preserve">
          <source>Here is an example of each of these methods. First, the default &lt;code&gt;join='outer'&lt;/code&gt; behavior:</source>
          <target state="translated">다음은 이러한 각 방법의 예입니다. 먼저 기본 &lt;code&gt;join='outer'&lt;/code&gt; 동작 :</target>
        </trans-unit>
        <trans-unit id="22ebc10164acf0daf0825fdd5c161702fb625bfa" translate="yes" xml:space="preserve">
          <source>Here is another example with duplicate join keys in DataFrames:</source>
          <target state="translated">다음은 DataFrames에 중복 조인 키가있는 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="f00ebbc96feac952e5b8441f93f7abf964a535a4" translate="yes" xml:space="preserve">
          <source>Here is how to view the top and bottom rows of the frame:</source>
          <target state="translated">프레임의 상단 및 하단 행을 보는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba4bad7934460a80f863bfdba98774b48472faf0" translate="yes" xml:space="preserve">
          <source>Here is the same thing with &lt;code&gt;join='inner'&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;join='inner'&lt;/code&gt; 와 같은 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a130bb6d2b269db357d8376f97e1107e7ce04d4c" translate="yes" xml:space="preserve">
          <source>Here we construct a simple time series data set to use for illustrating the indexing functionality:</source>
          <target state="translated">다음은 인덱싱 기능을 설명하는 데 사용할 간단한 시계열 데이터 집합을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="fd9b2cf6332d18d9140f68e40ee723e9daac96ff" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. Here&amp;rsquo;s how to create some of the objects used in the examples from the previous section:</source>
          <target state="translated">여기서는 팬더 데이터 구조에 공통적 인 필수 기능을 많이 설명합니다. 이전 섹션의 예제에서 사용 된 일부 개체를 만드는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1962f1379801e34e3473e040d888c5d732cbc345" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with a Series.</source>
          <target state="translated">여기서는 DataFrame과 Series를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="217a16b260162c6b9ecb75aafaf0420285c29b8e" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with another DataFrame.</source>
          <target state="translated">여기서는 DataFrame과 다른 DataFrame을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="901b74d6c5c2ab9f7fb4f6269ab16305edfca5b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a boring example of rendering a DataFrame, without any (visible) styles:</source>
          <target state="translated">다음은 (보이는) 스타일없이 DataFrame을 렌더링하는 지루한 예입니다.</target>
        </trans-unit>
        <trans-unit id="ade488284bcb2d315b9857b5a71d06a045b7e2a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example implementation, which relies on casting the extension array to object dtype. This uses the helper method &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt;.</source>
          <target state="translated">다음은 확장 배열을 객체 dtype으로 캐스팅하는 구현 예제입니다. 이것은 도우미 메소드 &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fa4e641ba9561c10a3cc502bc8073154340d3577" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the index metadata is structured in pyarrow:</source>
          <target state="translated">다음은 인덱스 메타 데이터가 pyarrow에서 어떻게 구성되는지에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f572a71811f0f563fe73dd42aa90e9196d2abf9f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can change the above with the new &lt;code&gt;align='mid'&lt;/code&gt; option:</source>
          <target state="translated">새로운 &lt;code&gt;align='mid'&lt;/code&gt; 옵션으로 위의 내용을 변경하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ab62496d5c665ac1b5f50c1319d13221f4ea9788" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the function in pure Python:</source>
          <target state="translated">순수한 파이썬의 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d56691ee65295aa8cd217efc5f1fb0ec7a019f8" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the template structure:</source>
          <target state="translated">템플릿 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd5f260a168827626f78de5b53f7fbc115fd0ce9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; and so forth are dictionaries containing the metadata for each column, &lt;em&gt;including the index columns&lt;/em&gt;. This has JSON form:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; &lt;em&gt;등은 인덱스 열을 포함하여&lt;/em&gt; 각 열의 메타 데이터를 포함하는 사전 입니다. 이것은 JSON 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ea88593cb4a459ae35a505f3a4797efa4ba41e7d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;data&lt;/code&gt; can be many different things:</source>
          <target state="translated">여기서 &lt;code&gt;data&lt;/code&gt; 는 여러 가지가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8578a243d227600659d59a488618d0fcbdeafb33" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of &lt;code&gt;a + 2&lt;/code&gt;.</source>
          <target state="translated">여기에는 여러 줄에 표현식이있어 여러 줄로 표시되지만 마지막 줄에는 &lt;code&gt;a + 2&lt;/code&gt; 의 출력에 지정된 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="29aaaf58b1b7c87af3da68daa99b0dc678b41d70" translate="yes" xml:space="preserve">
          <source>Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood.</source>
          <target state="translated">후드 아래에 사용되는 matplotlib 함수 인 matplotlib를 사용하는 6 각 비닝 플롯.</target>
        </trans-unit>
        <trans-unit id="4b2faf5cd777f9e9a92fe8907b82dcdf0f0474e9" translate="yes" xml:space="preserve">
          <source>Hide any indices from rendering.</source>
          <target state="translated">렌더링에서 인덱스를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="78d0b0e4e9c34ece1c9f3157d86d6d1ecb4d874b" translate="yes" xml:space="preserve">
          <source>Hide columns from rendering.</source>
          <target state="translated">렌더링에서 열을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="bd353e1c956b727376767cec3296c124209a3bf3" translate="yes" xml:space="preserve">
          <source>Hiding the Index or Columns</source>
          <target state="translated">인덱스 또는 열 숨기기</target>
        </trans-unit>
        <trans-unit id="9bfcf47106d24e26c8f6da4717ec31b0b2fed3e9" translate="yes" xml:space="preserve">
          <source>Hierarchical / Multi-level indexing is very exciting as it opens the door to some quite sophisticated data analysis and manipulation, especially for working with higher dimensional data. In essence, it enables you to store and manipulate data with an arbitrary number of dimensions in lower dimensional data structures like &lt;code&gt;Series&lt;/code&gt; (1d) and &lt;code&gt;DataFrame&lt;/code&gt; (2d).</source>
          <target state="translated">계층 적 / 다중 레벨 인덱싱은 특히 더 높은 차원의 데이터로 작업 할 때 매우 정교한 데이터 분석 및 조작의 문을 열어 주므로 매우 흥미 롭습니다. 본질적으로 &lt;code&gt;Series&lt;/code&gt; (1d) 및 &lt;code&gt;DataFrame&lt;/code&gt; (2d) 와 같은 저 차원 데이터 구조에서 임의의 수의 차원으로 데이터를 저장하고 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26c08f6047ab488a2eab24b98eb1681296096769" translate="yes" xml:space="preserve">
          <source>Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of related objects which can be accessed as a group or as individual objects.</source>
          <target state="translated">HDF (Hierarchical Data Format)는 자체 설명이므로 응용 프로그램에서 외부 정보없이 파일의 구조와 내용을 해석 할 수 있습니다. 하나의 HDF 파일에는 그룹 또는 개별 객체로 액세스 할 수있는 관련 객체가 혼합되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67724216d805a96555340d07e6d2a1f2633c2f46" translate="yes" xml:space="preserve">
          <source>Hierarchical indexing (MultiIndex)</source>
          <target state="translated">계층 적 인덱싱 (MultiIndex)</target>
        </trans-unit>
        <trans-unit id="3837ce83f3d8a13c3570b62b1a2b446adaff328e" translate="yes" xml:space="preserve">
          <source>Highlight the maximum by shading the background.</source>
          <target state="translated">배경을 음영 처리하여 최대 값을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="95eeff0d7f01c83d8e331dfa7e0642eef83365e6" translate="yes" xml:space="preserve">
          <source>Highlight the minimum by shading the background.</source>
          <target state="translated">배경을 음영 처리하여 최소값을 강조 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="28572094b6f31e2425178183c31a01aadfbfa89f" translate="yes" xml:space="preserve">
          <source>Hint to the hashtable sizer.</source>
          <target state="translated">해시 테이블 사이 저에 힌트</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="63bf65c682511a4e911a035e53ebaec3bd640815" translate="yes" xml:space="preserve">
          <source>Histograms can be drawn by using the &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt;&lt;code&gt;DataFrame.plot.hist()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt;&lt;code&gt;Series.plot.hist()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">히스토그램은 &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt; &lt;code&gt;DataFrame.plot.hist()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt; &lt;code&gt;Series.plot.hist()&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798d45d4f1a4e0cb111c2c75f0fa48db95a41bbc" translate="yes" xml:space="preserve">
          <source>Horizontal bar plot.</source>
          <target state="translated">가로 막대 플롯.</target>
        </trans-unit>
        <trans-unit id="c37cf838b0b980da78f19ac1366359fb80951f62" translate="yes" xml:space="preserve">
          <source>Hour</source>
          <target state="translated">Hour</target>
        </trans-unit>
        <trans-unit id="425c6644ee61c9a230fcbf65d7494b117f494021" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a decimal number [01,12].</source>
          <target state="translated">십진수로 표시되는 시간 (12 시간제) [01,12].</target>
        </trans-unit>
        <trans-unit id="fb9eb08a7d5aa5786e2bc10ef029f16e805c8a84" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a decimal number [00,23].</source>
          <target state="translated">십진수로 된 시간 (24 시간제) [00,23].</target>
        </trans-unit>
        <trans-unit id="53ac924a77d55d00e79592ebf70cc9ed9ee316d5" translate="yes" xml:space="preserve">
          <source>Hour.apply()</source>
          <target state="translated">Hour.apply()</target>
        </trans-unit>
        <trans-unit id="35bdb37831e82b82f92a864b1de84dce868b6263" translate="yes" xml:space="preserve">
          <source>Hour.apply_index()</source>
          <target state="translated">Hour.apply_index()</target>
        </trans-unit>
        <trans-unit id="1f7e570565de4188139ce1f495f0a4a767e428ee" translate="yes" xml:space="preserve">
          <source>Hour.base</source>
          <target state="translated">Hour.base</target>
        </trans-unit>
        <trans-unit id="8e585e3df04c4eec4de525fdca327fd2ba65e241" translate="yes" xml:space="preserve">
          <source>Hour.copy()</source>
          <target state="translated">Hour.copy()</target>
        </trans-unit>
        <trans-unit id="0b44862c33cc1a129b4117e0a1d4417ca66ca4c7" translate="yes" xml:space="preserve">
          <source>Hour.delta</source>
          <target state="translated">Hour.delta</target>
        </trans-unit>
        <trans-unit id="74c19e92ad107036eb344727623e1624200ae97c" translate="yes" xml:space="preserve">
          <source>Hour.freqstr</source>
          <target state="translated">Hour.freqstr</target>
        </trans-unit>
        <trans-unit id="691d0fbccd1823943092dfae8501b40efd199b1b" translate="yes" xml:space="preserve">
          <source>Hour.isAnchored()</source>
          <target state="translated">Hour.isAnchored()</target>
        </trans-unit>
        <trans-unit id="acea6d808fb787e2e979f0a7998c4c3df4d8fdd5" translate="yes" xml:space="preserve">
          <source>Hour.kwds</source>
          <target state="translated">Hour.kwds</target>
        </trans-unit>
        <trans-unit id="151d0e20cbd270cc7fb43e6f25553f0878a45a70" translate="yes" xml:space="preserve">
          <source>Hour.name</source>
          <target state="translated">Hour.name</target>
        </trans-unit>
        <trans-unit id="58d34fac168d93b38466a203549a3caebb9ae352" translate="yes" xml:space="preserve">
          <source>Hour.nanos</source>
          <target state="translated">Hour.nanos</target>
        </trans-unit>
        <trans-unit id="0105783696e6fdc9e5a7987c9699f50e93cff23e" translate="yes" xml:space="preserve">
          <source>Hour.normalize</source>
          <target state="translated">Hour.normalize</target>
        </trans-unit>
        <trans-unit id="739f2fb0b17377837145e941edbf36e33fdcc828" translate="yes" xml:space="preserve">
          <source>Hour.onOffset()</source>
          <target state="translated">Hour.onOffset()</target>
        </trans-unit>
        <trans-unit id="ef471ab00360fbd9ee97bd21ccfb08b1d39e4f2e" translate="yes" xml:space="preserve">
          <source>Hour.rollback()</source>
          <target state="translated">Hour.rollback()</target>
        </trans-unit>
        <trans-unit id="5f509dd688e4275ebcb58828f5df610b3c98968c" translate="yes" xml:space="preserve">
          <source>Hour.rollforward()</source>
          <target state="translated">Hour.rollforward()</target>
        </trans-unit>
        <trans-unit id="ab0f7f4231f94b918d559de375fb69ef0eca4951" translate="yes" xml:space="preserve">
          <source>Hour.rule_code</source>
          <target state="translated">Hour.rule_code</target>
        </trans-unit>
        <trans-unit id="2a3dfca25bfb019117c3cc536806011800c9abd7" translate="yes" xml:space="preserve">
          <source>Hours: &amp;lsquo;H&amp;rsquo;</source>
          <target state="translated">시간 : 'H'</target>
        </trans-unit>
        <trans-unit id="9242a5cf1124466c24859cdaf585816d21ba9d1b" translate="yes" xml:space="preserve">
          <source>Hover to highlight.</source>
          <target state="translated">강조 표시하려면 마우스를 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="a49764fca3c1e25986ac974c8d8c40659e3823f6" translate="yes" xml:space="preserve">
          <source>Hover to magnify</source>
          <target state="translated">마우스로 확대</target>
        </trans-unit>
        <trans-unit id="283b111b642f8a04124a8e358013df41d1234238" translate="yes" xml:space="preserve">
          <source>How to align the bars with the cells.</source>
          <target state="translated">막대를 셀에 맞추는 방법</target>
        </trans-unit>
        <trans-unit id="db6e9be9081ca92d77c03fe26dd79592e8be869b" translate="yes" xml:space="preserve">
          <source>How to behave if the table already exists.</source>
          <target state="translated">테이블이 이미 존재하는 경우 동작 방법</target>
        </trans-unit>
        <trans-unit id="5d737c62270b3a47acff25bef86300e61500eac8" translate="yes" xml:space="preserve">
          <source>How to build the pandas documentation</source>
          <target state="translated">팬더 문서를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="c0e83970905861dcc3c10030c88fffa02a03906c" translate="yes" xml:space="preserve">
          <source>How to find the values that will be replaced.</source>
          <target state="translated">대체 할 값을 찾는 방법</target>
        </trans-unit>
        <trans-unit id="ef1fa5b11035bf1f8ae6577f9a0c105ba2e2b145" translate="yes" xml:space="preserve">
          <source>How to handle NAs before computing percent changes.</source>
          <target state="translated">퍼센트 변경을 계산하기 전에 NA를 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="a27a42eb28b5e559a07433ac0d391873cf2dd91a" translate="yes" xml:space="preserve">
          <source>How to handle indexes on other axis (or axes).</source>
          <target state="translated">다른 축 (또는 축)에서 인덱스를 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="f8266c50c74c6156dfafa87c97ec3af24485274c" translate="yes" xml:space="preserve">
          <source>How to handle negative values in &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">마이너스 값을 처리하는 방법 &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a517432712fa10fd0ef073277ee02f0df0c11e06" translate="yes" xml:space="preserve">
          <source>How to handle non-NA values for overlapping keys:</source>
          <target state="translated">겹치는 키에 대해 비 NA 값을 처리하는 방법 :</target>
        </trans-unit>
        <trans-unit id="f43e18e889c91ca8e330be78e88e8778e041728c" translate="yes" xml:space="preserve">
          <source>How to handle the operation of the two objects.</source>
          <target state="translated">두 개체의 작동을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="4216b24f1023ffed1547bba13339a0671760163f" translate="yes" xml:space="preserve">
          <source>How to justify the column labels. If None uses the option from the print configuration (controlled by set_option), &amp;lsquo;right&amp;rsquo; out of the box. Valid values are</source>
          <target state="translated">열 레이블을 정당화하는 방법. 없음이 인쇄 구성의 옵션 (set_option으로 제어)을 사용하는 경우 상자에서 '오른쪽'. 유효한 값은</target>
        </trans-unit>
        <trans-unit id="02811e68280934a244076bbee273988252e2decb" translate="yes" xml:space="preserve">
          <source>How to rank NaN values:</source>
          <target state="translated">NaN 값 순위를 매기는 방법 :</target>
        </trans-unit>
        <trans-unit id="c81e5ee5f61ddfa3a78d5f341fad4ecdb5dbf234" translate="yes" xml:space="preserve">
          <source>How to rank the group of records that have the same value (i.e. ties):</source>
          <target state="translated">동일한 값 (예 : 동점)을 가진 레코드 그룹의 순위를 매기는 방법 :</target>
        </trans-unit>
        <trans-unit id="a7c0b091654e5dfa38cb05b8014dccae44bda9da" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">그러나 많은 응용 분야의 경우 추정 공분산 행렬이 양의 반정의 값을 보장하지 않기 때문에이 추정은 허용되지 않을 수 있습니다. 이는 1보다 큰 절대 값 및 / 또는 비가역 공분산 행렬을 갖는 상관을 추정 할 수있다. 자세한 내용 &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;은 공분산 행렬 추정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97abfa2058c4b2b46bd77047bcea7c55ad0f19cb" translate="yes" xml:space="preserve">
          <source>However, if the same element in both dataframes is None, that None is preserved</source>
          <target state="translated">그러나 두 데이터 프레임에서 동일한 요소가 None이면 None이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ba7929059d6edf0d7eddc551cc797b90990c10c2" translate="yes" xml:space="preserve">
          <source>However, when an axis is integer based, ONLY label based access and not positional access is supported. Thus, in such cases, it&amp;rsquo;s usually better to be explicit and use &lt;code&gt;.iloc&lt;/code&gt; or &lt;code&gt;.loc&lt;/code&gt;.</source>
          <target state="translated">그러나 축이 정수 기반 인 경우 위치 기반 액세스가 아닌 레이블 기반 액세스 만 지원됩니다. 따라서 이러한 경우 일반적으로 명시 적이며 &lt;code&gt;.iloc&lt;/code&gt; 또는 &lt;code&gt;.loc&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bffc9ca5ad36fbad3b3a0f25c38eeb95a3771bef" translate="yes" xml:space="preserve">
          <source>However, you can do (notice the comment that needs to be added)</source>
          <target state="translated">그러나 할 수 있습니다 (추가해야 할 주석에 유의하십시오)</target>
        </trans-unit>
        <trans-unit id="f8ac6f61c1aa59daf66de62601615682e1049435" translate="yes" xml:space="preserve">
          <source>Hypothesis is a library for property-based testing. Instead of explicitly parametrizing a test, you can describe &lt;em&gt;all&lt;/em&gt; valid inputs and let Hypothesis try to find a failing input. Even better, no matter how many random examples it tries, Hypothesis always reports a single minimal counterexample to your assertions - often an example that you would never have thought to test.</source>
          <target state="translated">가설은 속성 기반 테스트를위한 라이브러리입니다. 테스트를 명시 적으로 매개 변수화하는 대신 &lt;em&gt;모든&lt;/em&gt; 유효한 입력을 설명 하고 가설이 실패한 입력을 찾으려고 시도 할 수 있습니다. 더 좋은 방법은 시도하는 임의의 예제 수에 관계없이 가설에 항상 하나의 최소 반대 예를보고하는 경우가 종종 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b4059c9b5820041f826f688b6e57c7201e42d5f" translate="yes" xml:space="preserve">
          <source>IDE</source>
          <target state="translated">IDE</target>
        </trans-unit>
        <trans-unit id="f8fd4493c0520c4dc8242f0098e35eb107cc179d" translate="yes" xml:space="preserve">
          <source>IEX</source>
          <target state="translated">IEX</target>
        </trans-unit>
        <trans-unit id="ca6691485e94f29b172edd1428309ac2c47100cc" translate="yes" xml:space="preserve">
          <source>IO tools</source>
          <target state="translated">IO 도구</target>
        </trans-unit>
        <trans-unit id="a462e1e327253efa119d5a0e2286d8d8d84ef77d" translate="yes" xml:space="preserve">
          <source>IO tools (text, CSV, HDF5, &amp;hellip;)</source>
          <target state="translated">IO 도구 (텍스트, CSV, HDF5 등)</target>
        </trans-unit>
        <trans-unit id="571ae8f12e56e6a82f24791cda171d0b8fd05d68" translate="yes" xml:space="preserve">
          <source>IPython</source>
          <target state="translated">IPython</target>
        </trans-unit>
        <trans-unit id="e81acf4cb4ac2f9dfa0516461c3ce5a6c992dff8" translate="yes" xml:space="preserve">
          <source>IPython Vega</source>
          <target state="translated">IPython 베가</target>
        </trans-unit>
        <trans-unit id="991bf056dd16995f47856efd54d6471c32029dfb" translate="yes" xml:space="preserve">
          <source>IPython is an interactive command shell and distributed computing environment. IPython tab completion works with Pandas methods and also attributes like DataFrame columns.</source>
          <target state="translated">IPython은 대화식 명령 셸 및 분산 컴퓨팅 환경입니다. IPython 탭 완성은 Pandas 메소드 및 DataFrame 열과 같은 속성과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ce0c669ac9952944e64534615185377818bf4dd" translate="yes" xml:space="preserve">
          <source>IX indexer is deprecated</source>
          <target state="translated">IX 인덱서가 더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="837958207e911e1a986e234409c61e629d2c52b7" translate="yes" xml:space="preserve">
          <source>Ideally, the attributes in &lt;code&gt;_metadata&lt;/code&gt; will match the parameters to your &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (if any). If any of the attributes in &lt;code&gt;_metadata&lt;/code&gt; don&amp;rsquo;t implement the standard &lt;code&gt;__eq__&lt;/code&gt; or &lt;code&gt;__hash__&lt;/code&gt;, the default implementations here will not work.</source>
          <target state="translated">이상적으로 &lt;code&gt;_metadata&lt;/code&gt; 의 속성 은 매개 변수를 &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (있는 경우) 와 일치시킵니다 . &lt;code&gt;_metadata&lt;/code&gt; 의 속성 중 하나라도 표준 &lt;code&gt;__eq__&lt;/code&gt; 또는 &lt;code&gt;__hash__&lt;/code&gt; 를 구현하지 않으면 기본 구현이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed000ba923e4837b5f64d072ac83b369b8bbc564" translate="yes" xml:space="preserve">
          <source>Identifier for the group in the store.</source>
          <target state="translated">상점에서 그룹의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="cc70bdac5409cb9636fe71b4171d38f1636e5344" translate="yes" xml:space="preserve">
          <source>Identifier of column that should be used as index of the DataFrame.</source>
          <target state="translated">DataFrame의 인덱스로 사용해야하는 열의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="d1693517b90bc1546304cd1fb892ae941d720a6b" translate="yes" xml:space="preserve">
          <source>Identifies data (i.e. provides &lt;em&gt;metadata&lt;/em&gt;) using known indicators, important for analysis, visualization, and interactive console display.</source>
          <target state="translated">분석, 시각화 및 대화식 콘솔 디스플레이에 중요한 알려진 지표를 사용하여 데이터를 식별합니다 (즉, &lt;em&gt;메타 데이터&lt;/em&gt; 제공 ).</target>
        </trans-unit>
        <trans-unit id="7b2b315db6cb8b61d91ac6d610561c15d151098e" translate="yes" xml:space="preserve">
          <source>Identity method.</source>
          <target state="translated">신원 방법.</target>
        </trans-unit>
        <trans-unit id="ec04bd386a626dbd6df1f3954dfd578f058ce091" translate="yes" xml:space="preserve">
          <source>Idioms</source>
          <target state="translated">Idioms</target>
        </trans-unit>
        <trans-unit id="e8cae4bf30e27a1848901c64267dcac0e2ff75cd" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaN으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="6702a592aaa4545f91194718e2267ecc33a26886" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaT로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e327c3620244d73e8137e7777edd3944c79b840d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT.</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaT로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8cc6e9c326cf3572f065a17f177306c8775d049" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;first&amp;rsquo; puts NaNs at the beginning, &amp;lsquo;last&amp;rsquo; puts NaNs at the end. Not implemented for MultiIndex.</source>
          <target state="translated">'first'가 NaN을 처음에 놓으면 'last'는 NaN을 끝에 놓습니다. MultiIndex에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="85a05c0ef3ed46dcadbc8af33ffe40bbea47052f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NA values, without passing them to the mapping correspondence.</source>
          <target state="translated">'무시'인 경우 NA 값을 매핑 통신에 전달하지 않고 전파합니다.</target>
        </trans-unit>
        <trans-unit id="66b7f9b117c829902f069c8250ee1dcbed71f06f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to the mapping correspondence.</source>
          <target state="translated">'무시'인 경우 NaN 값을 매핑 대응으로 전달하지 않고 전파합니다.</target>
        </trans-unit>
        <trans-unit id="22afdde341e33ad8a79ea55dc5be1cbcc7e96d01" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and existing labels are dropped.</source>
          <target state="translated">'무시'이면 오류를 억제하고 기존 레이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="d430013a0236928d816f5189528441973b498e09" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and only existing labels are dropped.</source>
          <target state="translated">'무시'인 경우 오류를 억제하고 기존 레이블 만 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="55ef49bb1d9190e26977a4e97151c2887af3928e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input</source>
          <target state="translated">'무시'인 경우 유효하지 않은 구문 분석은 입력을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd3b02bde7d23065b5493af3d78edab92d8661c6" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input.</source>
          <target state="translated">'무시'인 경우 유효하지 않은 구문 분석은 입력을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff34e86f499a6da13800cd52b6acf8d0206bc8b4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;julian&amp;rsquo;, unit must be &amp;lsquo;D&amp;rsquo;, and origin is set to beginning of Julian Calendar. Julian day number 0 is assigned to the day starting at noon on January 1, 4713 BC.</source>
          <target state="translated">'julian'인 경우 단위는 'D'여야하며 원점은 Julian Calendar의 시작으로 설정됩니다. Julian 일 번호 0은 BC 4713 년 1 월 1 일 정오에 시작하는 날에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="3b55e654d50b8ad774057f6ba47ce5789398ba97" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">'왼쪽'이면 발견 된 첫 번째 적합한 위치의 색인이 제공됩니다. '오른쪽'이면 마지막 인덱스를 반환하십시오. 적합한 색인이 없으면 0 또는 N을 리턴하십시오 (여기서 N은 &lt;code&gt;self&lt;/code&gt; 의 길이 임 ).</target>
        </trans-unit>
        <trans-unit id="199d3e9cf5e8512896d9d482541e87cadcde8682" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;orient&amp;rsquo; is &amp;lsquo;records&amp;rsquo; write out line delimited json format. Will throw ValueError if incorrect &amp;lsquo;orient&amp;rsquo; since others are not list like.</source>
          <target state="translated">'orient'가 'records'인 경우 행으로 구분 된 json 형식을 작성하십시오. 다른 사람들이 목록에 없기 때문에 잘못된 '동향'인 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7a715eced952aac9082838419cee8dbd64346a0c" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a &lt;code&gt;KeyError&lt;/code&gt; when a dict-like &lt;code&gt;mapper&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, or &lt;code&gt;columns&lt;/code&gt; contains labels that are not present in the Index being transformed. If &amp;lsquo;ignore&amp;rsquo;, existing keys will be renamed and extra keys will be ignored.</source>
          <target state="translated">' &lt;code&gt;KeyError&lt;/code&gt; ' dict-like &lt;code&gt;mapper&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 또는 &lt;code&gt;columns&lt;/code&gt; 변환중인 인덱스에없는 레이블이 포함되어 있으면 KeyError가 발생합니다 . '무시'하면 기존 키의 이름이 바뀌고 추가 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0485157b5ba13ba379ff6892b6733f96842f0855" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception</source>
          <target state="translated">'일으키면'잘못된 구문 분석은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="00849af26e0f3b9e37f7a382187cd7e59f774f16" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception.</source>
          <target state="translated">'일으키면'유효하지 않은 구문 분석은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3839ee4020555f4a90cf6574c343569184832636" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and &lt;code&gt;other&lt;/code&gt; both contain non-NA data in the same place.</source>
          <target state="translated">'수행'하면 DataFrame과 &lt;code&gt;other&lt;/code&gt; 둘 다 같은 장소에 비 NA 데이터가 포함 된 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3dcbf99c91197fe50065b8c2d1bbfb5fb4697702" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;unix&amp;rsquo; (or POSIX) time; origin is set to 1970-01-01.</source>
          <target state="translated">'유닉스'(또는 POSIX) 시간 인 경우; 원점은 1970-01-01로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d61e029440c96cda1e26ffdb0c5f6446bc64ce" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each &lt;strong&gt;row&lt;/strong&gt;.</source>
          <target state="translated">각 열에 대해 0 또는 '인덱스'수가 생성되는 경우 각 &lt;strong&gt;행&lt;/strong&gt; 에 대해 1 또는 '열'수가 생성되는 경우 .</target>
        </trans-unit>
        <trans-unit id="6e7da5c288c9e6258ab4bc7bde9bc7e6455b66f5" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo;: apply function to each column. If 1 or &amp;lsquo;columns&amp;rsquo;: apply function to each row.</source>
          <target state="translated">0 또는 '인덱스'인 경우 : 각 열에 함수를 적용하십시오. 1 또는 '열'인 경우 : 각 행에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="9100712e07a1a3144bf279ca0131c5328bb20fae" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with &lt;code&gt;categories&lt;/code&gt; or &lt;code&gt;ordered&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 &lt;code&gt;categories&lt;/code&gt; 또는 &lt;code&gt;ordered&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="957f4921f3fe1f14cc5e0972c2a9f63db875fa60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is specified, specifies values at given coordinates &lt;code&gt;(x[i], y[i])&lt;/code&gt;. These values are accumulated for each hexagonal bin and then reduced according to &lt;code&gt;reduce_C_function&lt;/code&gt;, having as default the NumPy&amp;rsquo;s mean function (&lt;code&gt;numpy.mean()&lt;/code&gt;). (If &lt;code&gt;C&lt;/code&gt; is specified, it must also be a 1-D sequence of the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or a column label.)</source>
          <target state="translated">경우 &lt;code&gt;C&lt;/code&gt; 는 , 주어진 좌표 지정 값 지정되어 &lt;code&gt;(x[i], y[i])&lt;/code&gt; . 이 값은 각 육각형 &lt;code&gt;reduce_C_function&lt;/code&gt; 에 대해 누적 된 다음 기본적으로 NumPy의 평균 함수 ( &lt;code&gt;numpy.mean()&lt;/code&gt; )를 갖는 reduce_C_function 에 따라 줄어 듭니다 . (경우 &lt;code&gt;C&lt;/code&gt; 가 지정되고, 또한 동일한 길이의 1-D 서열이어야 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; , 또는 열 라벨).</target>
        </trans-unit>
        <trans-unit id="6499e3dc9a031482752c69e5eecddd3f70eff0f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, return Series/Index, containing lists of strings.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 인 경우 문자열 목록이 포함 된 Series / Index를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da8ba51c7b0b90045082965fc49ef9200c0d1945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; is one of the accepted values, it always needs to be the last in the list.</source>
          <target state="translated">경우 &lt;code&gt;None&lt;/code&gt; 허용되는 값 중 하나입니다, 항상 목록의 마지막이 될 필요가있다.</target>
        </trans-unit>
        <trans-unit id="d31355248f274c3070a84b13f60346c84b6ae353" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, the behavior depends on the chosen engine.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 파일 출력에 데이터 프레임의 인덱스를 포함시킵니다. &lt;code&gt;False&lt;/code&gt; 인 경우 파일에 기록되지 않습니다. 경우 &lt;code&gt;None&lt;/code&gt; , 동작은 선택한 엔진에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="db9c68e2c0847c2648159936067c9e97bd68d778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs operation inplace and returns None.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 작업을 수행하고 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cb94c12a9c4ef4e915d043b0131ab965753c6c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, return DataFrame/MultiIndex expanding dimensionality.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 DataFrame / MultiIndex 확장 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="970376fd9f251fcf7442a3e8dc1c7f205bfd8a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; and/or &lt;code&gt;level&lt;/code&gt; are passed as keywords to both &lt;code&gt;Grouper&lt;/code&gt; and &lt;code&gt;groupby&lt;/code&gt;, the values passed to &lt;code&gt;Grouper&lt;/code&gt; take precedence.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 및 / 또는 &lt;code&gt;level&lt;/code&gt; 모두 키워드로 전달되는 &lt;code&gt;Grouper&lt;/code&gt; 및 &lt;code&gt;groupby&lt;/code&gt; , 값이 전달 &lt;code&gt;Grouper&lt;/code&gt; 보다 우선.</target>
        </trans-unit>
        <trans-unit id="f3bd838dfe683144e93c449ff32d03c1dfd018a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is an ndarray, &lt;strong&gt;index&lt;/strong&gt; must be the same length as &lt;strong&gt;data&lt;/strong&gt;. If no index is passed, one will be created having values &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; ndarray이며, &lt;strong&gt;지수는&lt;/strong&gt; 같은 길이해야합니다 &lt;strong&gt;데이터&lt;/strong&gt; . 인덱스가 전달되지 않으면 &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt; 값을 갖는 인덱스가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ab813b7fd3b3d65ecd4fb06b280ae7968617f53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; have overlapping elements</source>
          <target state="translated">경우 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 요소에 중복</target>
        </trans-unit>
        <trans-unit id="a7da045296675e29f8161fcdf9df7881d520bb33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt; 하면 ! = 'left'</target>
        </trans-unit>
        <trans-unit id="f265a8f044bf232fffa85812d820574c8444bbe7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 은 거짓이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정되지 않은 어떤 문자열은 NaN의로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a282745eb357ce0d97179f43d5f0ca158631ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 은 거짓이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정, 지정 만의 NaN 값 &lt;code&gt;na_values&lt;/code&gt; 는 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ef3b4bb67919e2a3c220c269aec10ecbb92263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 는 사실이며, &lt;code&gt;na_values&lt;/code&gt; 이 지정되지 않은, 단지 기본 NaN의 값은 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4119b503697716799e0d3d53bb23a09257bc768a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 는 사실이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정되어, &lt;code&gt;na_values&lt;/code&gt; 는 NaN의 구문 분석을 위해 사용하는 값 기본에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="14eafb6125c72331ed6931749a85a2bfe869b0fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is not set, all levels are removed from the Index.</source>
          <target state="translated">경우 &lt;code&gt;level&lt;/code&gt; 설정되어 있지 않은 모든 수준은 인덱스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb5a110126584a428bb870b81494275cb5c1371" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is specified:</source>
          <target state="translated">만약 &lt;code&gt;level&lt;/code&gt; 지정됩니다</target>
        </trans-unit>
        <trans-unit id="60f1e6635b0a341e3238693e8e1f6f09613ae56b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is None, missing values in the Series/Index are omitted from the result.</source>
          <target state="translated">경우 &lt;code&gt;na_rep&lt;/code&gt; 은 아무도 없으며, &lt;code&gt;others&lt;/code&gt; 아무도 없다, 시리즈 / 인덱스에서 누락 된 값은 결과에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="444db6399518d3b249738d624701c4ac6b47e94e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is not None, a row containing a missing value in any of the columns (before concatenation) will have a missing value in the result.</source>
          <target state="translated">경우 &lt;code&gt;na_rep&lt;/code&gt; 는 것도없고, &lt;code&gt;others&lt;/code&gt; 없음], (연결) 전에 모든 열에서 누락 값을 포함하는 행이 결과에서 누락 값을 가질 것이다.</target>
        </trans-unit>
        <trans-unit id="5b7230c53dd34c840119bd5592d141943fc9eb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original Series.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; NaN이 포함 된 경우 해당 값이 원래 시리즈에서 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="deb8809ee611aa9a981b6b0843436b17f4eb152b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original dataframe.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 에 NaN이 포함되어 있으면 해당 값이 원래 데이터 프레임에서 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25b2a3bb2e641aa80e4bd798d256b6357269c5bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is None, &lt;code&gt;str&lt;/code&gt; is returned, otherwise a &lt;code&gt;Series/Index&lt;/code&gt; (same type as caller) of objects is returned.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 없음이다 &lt;code&gt;str&lt;/code&gt; 반환되지 않습니다, 그렇지 않으면 &lt;code&gt;Series/Index&lt;/code&gt; 오브젝트 (호출자와 같은 종류)가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09719fe597a3b1238ba510411ad64aa8b9b27a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, corresponding values are concatenated with the separator. Result will be a Series of strings.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 지정되고, 대응하는 값은 분리기와 연결되어있다. 결과는 일련의 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="403aef7dbc0efb83661ae14475ba2c1f617d536d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, this function concatenates the Series/Index and elements of &lt;code&gt;others&lt;/code&gt; element-wise. If &lt;code&gt;others&lt;/code&gt; is not passed, then all values in the Series/Index are concatenated into a single string with a given &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 지정되어,이 함수는 시리즈 / 지수와의 요소를 연결 한 &lt;code&gt;others&lt;/code&gt; 요소 현명한. 경우 &lt;code&gt;others&lt;/code&gt; 전달되지 다음 시리즈 / 색인의 모든 값은 주어진 단일 문자열로 연결됩니다 &lt;code&gt;sep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3baa765246b3745f60bd4ee59b2f98ce470debc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt;, then an array of size len(self) is returned, with all values filled with &lt;code&gt;self.dtype.na_value&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt; , 다음 (자기) 렌 크기의 배열로 채워진 모든 값으로 반환된다 &lt;code&gt;self.dtype.na_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961740cc92f0fc03f28c95a8a238e4dbbce71c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a Series will be returned where the index is &lt;code&gt;q&lt;/code&gt; and the values are the quantiles, otherwise a float will be returned.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 배열하고, 일련의 인덱스이고 반환한다 &lt;code&gt;q&lt;/code&gt; 는 상기 값을, 그렇지 않은 플로트 반환 될 분위수이다.</target>
        </trans-unit>
        <trans-unit id="50282aa940212018e61f3deecb959d20f87fb9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;regex&lt;/code&gt; is not a &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;to_replace&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;regex&lt;/code&gt; 되지 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;to_replace&lt;/code&gt; 은 하지 않습니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81766fdd49633266642838e7da2bdf12aca59fae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;return_type&lt;/code&gt; 가 없는 &lt;code&gt;None&lt;/code&gt; , 동일한 형상으로되는 축 NumPy와 어레이 &lt;code&gt;layout&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="f81d6e8038a65cfec7ed666581c73e2227881317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned:</source>
          <target state="translated">경우 &lt;code&gt;return_type&lt;/code&gt; 가 없는 &lt;code&gt;None&lt;/code&gt; , 동일한 형상으로되는 축 NumPy와 배열로 &lt;code&gt;layout&lt;/code&gt; 반환된다 :</target>
        </trans-unit>
        <trans-unit id="9403f65e0291ebfce3b893ca7ef9f39c4702bafd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is empty or &lt;code&gt;periods&lt;/code&gt; is 0, a copy of &lt;code&gt;self&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 비어 있거나 &lt;code&gt;periods&lt;/code&gt; 0의 사본 &lt;code&gt;self&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6c9ebf0aff8358da4c22aadcc4e5af5797dd0abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified, the values are concatenated without separation.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되지 않은 숫자가 분리없이 연결된다.</target>
        </trans-unit>
        <trans-unit id="be88e00b6cd2ee9590d0a2d751007eb4876a853c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipna&lt;/code&gt; is False and there is an NA value in the data, the function returns &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;skipna&lt;/code&gt; 가 False 인 데이터의 NA의 값이 함수는 반환 &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d07c799aa985555aa80944ae394ade3e6e41e965" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;period_range&lt;/code&gt; constructor.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 있는 &lt;code&gt;Period&lt;/code&gt; 목적, 이들은 앵커에 대한 엔드 포인트로 사용될 &lt;code&gt;PeriodIndex&lt;/code&gt; 그 주파수 일치 &lt;code&gt;period_range&lt;/code&gt; 의 생성자.</target>
        </trans-unit>
        <trans-unit id="b7b0a663d9250908bec356033f00f39037ab14b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is provided, and the expression mutates &lt;code&gt;target&lt;/code&gt;, whether to modify &lt;code&gt;target&lt;/code&gt; inplace. Otherwise, return a copy of &lt;code&gt;target&lt;/code&gt; with the mutation.</source>
          <target state="translated">경우 &lt;code&gt;target&lt;/code&gt; 제공되고 발현 변이는 &lt;code&gt;target&lt;/code&gt; 수정 여부, &lt;code&gt;target&lt;/code&gt; 인플레 이스를. 그렇지 않으면 돌연변이가있는 &lt;code&gt;target&lt;/code&gt; 의 사본을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1e7c5e72393131f2654387c48d329fe2921498d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;text_color_threshold&lt;/code&gt; is not a value from 0 to 1.</source>
          <target state="translated">&lt;code&gt;text_color_threshold&lt;/code&gt; 가 0에서 1 사이의 값이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="704cdb74002773b3b579c1c3d6d7936011db63ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;regex&lt;/code&gt; is not compilable into a regular expression or is a list, dict, ndarray, or Series.</source>
          <target state="translated">경우 &lt;code&gt;to_replace&lt;/code&gt; 는 없다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;regex&lt;/code&gt; 정규 표현식으로 컴파일 가능한 없거나 목록, 딕셔너리, ndarray, 또는 시리즈입니다.</target>
        </trans-unit>
        <trans-unit id="d03447781d080adef5a2a9380fc861eeabc92417" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is not a &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;ndarray&lt;/code&gt;, or &lt;code&gt;Series&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;to_replace&lt;/code&gt; 는 A는 &lt;code&gt;dict&lt;/code&gt; 하고 &lt;code&gt;value&lt;/code&gt; 하지 않은 것입니다 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;ndarray&lt;/code&gt; , 또는 &lt;code&gt;Series&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c278841e9bef34e1e1bd4a72a3426ae68586bd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a string</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 문자열입니다</target>
        </trans-unit>
        <trans-unit id="d9b7a5e40e9f52d62b19692bf3dcad2166cfe945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt; all points are evenly weighted. To learn more about different window types see &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal window functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;win_type=None&lt;/code&gt; 이면 모든 포인트에 균등 한 가중치가 적용됩니다. 다른 창 유형에 대한 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal 창 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82a6323b295fa22008498d6df468eee6b83c1cb8" translate="yes" xml:space="preserve">
          <source>If DataFrame contains only NaNs, it is still not considered empty. See the example below.</source>
          <target state="translated">DataFrame에 NaN 만 포함되어 있으면 여전히 비어있는 것으로 간주되지 않습니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc64a7e5f7b013c75ec87dad61798a0bf364de27" translate="yes" xml:space="preserve">
          <source>If DataFrame is empty, return True, if not return False.</source>
          <target state="translated">DataFrame이 비어 있으면 False를 반환하지 않으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9db46c5d4b42b8c5a58b772328c51b664e184ae7" translate="yes" xml:space="preserve">
          <source>If Datetime Array/Index is tz-naive.</source>
          <target state="translated">Datetime Array / Index가 tz-naive 인 경우</target>
        </trans-unit>
        <trans-unit id="d1f885919f4b6084a26832cb39a10a880fe30e9f" translate="yes" xml:space="preserve">
          <source>If False (default), the SparseSeries index consists of only the coords of the non-null entries of the original coo_matrix. If True, the SparseSeries index consists of the full sorted (row, col) coordinates of the coo_matrix.</source>
          <target state="translated">False (기본값) 인 경우 SparseSeries 색인은 원래 coo_matrix의 널이 아닌 항목의 좌표만으로 구성됩니다. True 인 경우 SparseSeries 인덱스는 coo_matrix의 전체 정렬 (행, 열) 좌표로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="af4968ab538593a91313d8dbcdb3666d290ea5ad" translate="yes" xml:space="preserve">
          <source>If False returns a numpy.timedelta64 or numpy.darray of values of dtype timedelta64[ns].</source>
          <target state="translated">False가 dtype timedelta64 [ns] 값의 numpy.timedelta64 또는 numpy.darray를 리턴하는 경우</target>
        </trans-unit>
        <trans-unit id="19cb14e4bedf8bda1fb770c21ea9563b40397a07" translate="yes" xml:space="preserve">
          <source>If False returns ndarray of values.</source>
          <target state="translated">False가 ndarray 값을 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="c4ef3d2ab2c9c4543800461df47e4edf64d59fdc" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndex DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">False이면 self와 other 사이의 일치하는 열만 사용되며 출력은 DataFrame이됩니다. True이면 모든 쌍 조합이 계산되고 DataFrame 입력의 경우 출력이 MultiIndex DataFrame이됩니다. 요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a787dc4a36cd7a1fb843fad1ef9b45ebd6788d" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndexed DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">False이면 self와 other 사이의 일치하는 열만 사용되며 출력은 DataFrame이됩니다. True이면 모든 페어 와이즈 조합이 계산되고 DataFrame 입력의 경우 출력이 MultiIndexed DataFrame이됩니다. 요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a089d4a3cab4ec051531af18ca8716ac15f227f1" translate="yes" xml:space="preserve">
          <source>If False then underlying input data is not copied.</source>
          <target state="translated">False이면 기본 입력 데이터가 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f4768ce69348aa654b6f78c372d4c73bce62c22" translate="yes" xml:space="preserve">
          <source>If False, allow the format to match anywhere in the target string.</source>
          <target state="translated">False이면 형식이 대상 문자열의 임의의 위치와 일치하게하십시오.</target>
        </trans-unit>
        <trans-unit id="30010fa9b0dacd4bae2d42840bc8bc8330f1bc61" translate="yes" xml:space="preserve">
          <source>If False, avoid copy if possible.</source>
          <target state="translated">False이면 가능하면 복사하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="291d4f114810ff3b85734eb9c885f67fb9461220" translate="yes" xml:space="preserve">
          <source>If False, do not copy data unnecessarily.</source>
          <target state="translated">False이면 불필요하게 데이터를 복사하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="713b0af025da394c1dfc7bcc4b8e6a4fc01b89b5" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than)</source>
          <target state="translated">False 인 경우 동일한 'on'값과 일치하지 않습니다 (즉,보다 작게 /보다 크게 초과)</target>
        </trans-unit>
        <trans-unit id="6b2899b63827cccc80ce7f0849090ad8a00a13fe" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from length of group - 1 to 0.</source>
          <target state="translated">False이면 그룹의 길이-1에서 0까지 역순으로 번호를 매 깁니다.</target>
        </trans-unit>
        <trans-unit id="18d85815ef65505f4da3c47d9d292cf07677ec50" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from number of group - 1 to 0.</source>
          <target state="translated">False이면 그룹 수-1에서 0까지 역순으로 번호를 매 깁니다.</target>
        </trans-unit>
        <trans-unit id="eee400988b3add06c7b8d82d92a5db12cafc5df8" translate="yes" xml:space="preserve">
          <source>If False, returns object with same levels as self.</source>
          <target state="translated">False이면 self와 동일한 수준의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93f8cbc94b6ecff2910e70c613725fd41f719aa1" translate="yes" xml:space="preserve">
          <source>If False, the quantile of datetime and timedelta data will be computed as well.</source>
          <target state="translated">False이면 날짜 / 시간 델타 데이터의 Quantile도 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1a855233ec9b42057ad4f3f0a22d197f5cc6c27a" translate="yes" xml:space="preserve">
          <source>If False, treats the pat as a literal string.</source>
          <target state="translated">False이면 pat을 리터럴 문자열로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="d42e87de00086a1c6e6f625064f6fded12c14393" translate="yes" xml:space="preserve">
          <source>If False, treats the pattern as a literal string</source>
          <target state="translated">False 인 경우 패턴을 리터럴 문자열로 처리</target>
        </trans-unit>
        <trans-unit id="6823fe124c6d762f846db12c9b7eb432cef57e38" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1</source>
          <target state="translated">None이면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="7a198b80d00181744c0b52dce1e2d43c14c2ff18" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning</source>
          <target state="translated">None 인 경우 기본값은 시작입니다</target>
        </trans-unit>
        <trans-unit id="d75f9174710ceedaeffa648b72cbbd3e8b87a0b5" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end</source>
          <target state="translated">None 인 경우 기본적으로 끝</target>
        </trans-unit>
        <trans-unit id="99befa70db36b844698b11450c67335fe8946fc0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred</source>
          <target state="translated">None이면 dtype이 유추됩니다</target>
        </trans-unit>
        <trans-unit id="305e45bf0f534becf08e10a608173f7b64e54cf0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred.</source>
          <target state="translated">None이면 dtype이 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="33245c017268287ad9b24177b04ead223d178eae" translate="yes" xml:space="preserve">
          <source>If None, file format is inferred from file extension. If &amp;lsquo;xport&amp;rsquo; or &amp;lsquo;sas7bdat&amp;rsquo;, uses the corresponding format.</source>
          <target state="translated">None이면 파일 형식에서 파일 형식이 유추됩니다. 'xport'또는 'sas7bdat'인 경우 해당 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f40dfbb91453fe35b8691d9034b77ccdc78058b8" translate="yes" xml:space="preserve">
          <source>If None, return all columns, otherwise, returns specified columns.</source>
          <target state="translated">None이면 모든 열을 반환하고, 그렇지 않으면 지정된 열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d3b9a2dcf0b8b571245f92f0d02282c76972d82" translate="yes" xml:space="preserve">
          <source>If None, then parse all columns.</source>
          <target state="translated">None이면 모든 열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="cede37750460f29cb4fa52c7fec665577cfd52b2" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">Numba에 무언가를 포함하는 함수가 전달되면, 현재 세트, 목록, 사전 또는 문자열 함수를 포함하는 범주와 함께 작동하는 방법을 모르는 &lt;code&gt;object mode&lt;/code&gt; 돌아갑니다 . 에서 &lt;code&gt;object mode&lt;/code&gt; , Numba는 실행되지만 코드는 크게 속도를하지 않습니다. 코드 속도를 &lt;code&gt;nopython=True&lt;/code&gt; 방식으로 함수를 컴파일 할 수없는 경우 Numba에서 오류를 발생 시키려면 nopython = True 인수 (예 : &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; )를 Numba에 전달하십시오 . Numba 모드 문제 해결에 대한 자세한 내용은 &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba 문제 해결 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1f8f822f180177bfde53d3b1ec7bf4e05cab5e" translate="yes" xml:space="preserve">
          <source>If Timestamp convertible, origin is set to Timestamp identified by origin.</source>
          <target state="translated">타임 스탬프가 변환 가능한 경우 오리진은 오리진으로 식별 된 타임 스탬프로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="302ec23d134fa94295f5a5b21bbe57333cc5ba71" translate="yes" xml:space="preserve">
          <source>If Timestamp is tz-naive.</source>
          <target state="translated">타임 스탬프가 tz-naive 인 경우</target>
        </trans-unit>
        <trans-unit id="877daf2c60c584794d63f9ddbf4bb796256b13ee" translate="yes" xml:space="preserve">
          <source>If True (default) the description(s) will be printed to stdout. Otherwise, the description(s) will be returned as a unicode string (for testing).</source>
          <target state="translated">True (기본값)이면 설명이 표준 출력으로 인쇄됩니다. 그렇지 않으면 설명이 유니 코드 문자열로 반환됩니다 (테스트 용).</target>
        </trans-unit>
        <trans-unit id="6d916b7ecf5b34c978b87a1cac148ea4e85e0797" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; is enabled, pandas will attempt to infer the format of the datetime strings in the columns, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by 5-10x.</source>
          <target state="translated">True 및 &lt;code&gt;parse_dates&lt;/code&gt; 를 사용하면 팬더가 열에서 날짜 시간 문자열의 형식을 유추하려고 시도하고 추론 가능한 경우 더 빠른 구문 분석 방법으로 전환합니다. 경우에 따라 파싱 속도가 5-10 배 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c1e57d23e26869dc0e2062acc23c857f4141f1" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">True 및 &lt;code&gt;parse_dates&lt;/code&gt; 가 여러 열 결합을 지정하면 원래 열을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="cdbd44edb95eb1919d0e70e68013314a95652069" translate="yes" xml:space="preserve">
          <source>If True and no &lt;code&gt;format&lt;/code&gt; is given, attempt to infer the format of the datetime strings, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x.</source>
          <target state="translated">True이고 &lt;code&gt;format&lt;/code&gt; 이 지정 되지 않은 경우 날짜 시간 문자열의 형식을 유추하려고 시도하고 유추 할 수있는 경우 더 빠른 구문 분석 방법으로 전환하십시오. 경우에 따라 파싱 속도가 ~ 5-10 배 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ce3205c3816ae877ac9af3cf60622cf6b06aa7" translate="yes" xml:space="preserve">
          <source>If True and sorting by level and index is multilevel, sort by other levels too (in order) after sorting by specified level.</source>
          <target state="translated">True 및 레벨 및 인덱스 별 정렬이 다중 레벨 인 경우 지정된 레벨을 기준으로 정렬 한 후 다른 레벨도 순서대로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="262d40ea87b315db865b2f76fe9cef275e5b9327" translate="yes" xml:space="preserve">
          <source>If True parse dates in &lt;code&gt;data&lt;/code&gt; with the year first order</source>
          <target state="translated">True가 첫 번째 연도의 &lt;code&gt;data&lt;/code&gt; 로 날짜를 구문 분석하는 경우</target>
        </trans-unit>
        <trans-unit id="d875c9e78a8f10c4070a76617db0aea9c9581c5c" translate="yes" xml:space="preserve">
          <source>If True parses dates with the year first, eg 10/11/12 is parsed as 2010-11-12.</source>
          <target state="translated">True가 연도를 기준으로 날짜를 구문 분석하는 경우 (예 : 10/11/12)는 2010-11-12로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="bb627fc931d5d5697f56d7a0202d4eeb9eb2c217" translate="yes" xml:space="preserve">
          <source>If True returns a DatetimeIndex or Index-like object</source>
          <target state="translated">True가 DatetimeIndex 또는 Index-like 객체를 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="e55faf7a09074a6a866ad052dfba8d934e2a620c" translate="yes" xml:space="preserve">
          <source>If True returns a Timedelta/TimedeltaIndex of the results.</source>
          <target state="translated">True이면 결과의 Timedelta / TimedeltaIndex를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="460a87b8b136bb4a2b3c54602f91c633b0e77bca" translate="yes" xml:space="preserve">
          <source>If True then the object returned will contain the relative frequencies of the unique values.</source>
          <target state="translated">True이면 반환 된 객체에 고유 값의 상대 빈도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6899875f0d289bc3d7921ca50f8266c60d0690" translate="yes" xml:space="preserve">
          <source>If True, adds a column to output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. If string, column with information on source of each row will be added to output DataFrame, and column will be named value of string. Information column is Categorical-type and takes on a value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;left&amp;rsquo; DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;right&amp;rsquo; DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both.</source>
          <target state="translated">True 인 경우 각 행의 소스에 대한 정보와 함께 &quot;_merge&quot;라는 출력 DataFrame에 열을 추가합니다. 문자열 인 경우 각 행의 소스에 대한 정보가있는 열이 출력 DataFrame에 추가되고 열의 이름은 string의 값입니다. 정보 열은 범주 형이며 병합 키가 'left'DataFrame에만 나타나는 관측에 대해서는 &quot;left_only&quot;값을 취하고, 병합 키가 'right'DataFrame에만 나타나는 관측에 대해서는&amp;ldquo;right_only&amp;rdquo;를, 관측치의 병합 키는 둘 다에 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a0d8d2165cdc25ae287fecadf2dc5419cb8c90" translate="yes" xml:space="preserve">
          <source>If True, allow matching with the same &amp;lsquo;on&amp;rsquo; value (i.e. less-than-or-equal-to / greater-than-or-equal-to)</source>
          <target state="translated">True 인 경우 동일한 'on'값 (즉,보다 작거나 같음 /보다 크거나 같음)과 일치하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="4660645b9175a4b6c992d8f895126a90fe4a50a3" translate="yes" xml:space="preserve">
          <source>If True, assumes the passed-in pattern is a regular expression.</source>
          <target state="translated">True 인 경우 전달 된 패턴이 정규식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1e74a09f271b28537768cc8961b39d335e31e6de" translate="yes" xml:space="preserve">
          <source>If True, assumes the pat is a regular expression.</source>
          <target state="translated">True이면 pat이 정규식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7fc051579ade2d30effac2d7f975b7af0eaf1117" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if &lt;code&gt;pat&lt;/code&gt; is a string)</source>
          <target state="translated">True 인 경우 대소 문자 구분 ( &lt;code&gt;pat&lt;/code&gt; 가 문자열 인 경우 기본값 )</target>
        </trans-unit>
        <trans-unit id="9f69db8a36129425d43c6f59fe632f1d4ad16ea5" translate="yes" xml:space="preserve">
          <source>If True, case sensitive.</source>
          <target state="translated">True이면 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="963a559726df468b6da10ccb14a21fec119cd396" translate="yes" xml:space="preserve">
          <source>If True, columns in &lt;code&gt;self&lt;/code&gt; that do not exist in &lt;code&gt;other&lt;/code&gt; will be overwritten with NaNs.</source>
          <target state="translated">True이면 &lt;code&gt;other&lt;/code&gt; 곳에 존재하지 않는 &lt;code&gt;self&lt;/code&gt; 열은 NaN으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="0072997ec6faf6f05624c4fd43f7c2c5957f60e6" translate="yes" xml:space="preserve">
          <source>If True, copy the underlying data.</source>
          <target state="translated">True 인 경우 기본 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="beef21df15134efbd5ef8eaa6cfbb8bd6ce0957e" translate="yes" xml:space="preserve">
          <source>If True, do not use the index labels.</source>
          <target state="translated">True 인 경우 색인 레이블을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="39eabebf10ef842b50bf2b46f976dd96a678bf6f" translate="yes" xml:space="preserve">
          <source>If True, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, &amp;hellip;, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.</source>
          <target state="translated">True 인 경우 연결 축을 따라 인덱스 값을 사용하지 마십시오. 결과 축에는 0,&amp;hellip;, n-1로 레이블이 지정됩니다. 이는 연결 축에 의미있는 색인 정보가없는 개체를 연결하는 경우에 유용합니다. 다른 축의 인덱스 값은 여전히 ​​조인에서 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="2be78667d971f765edd09b5dcf231a83202213b7" translate="yes" xml:space="preserve">
          <source>If True, do operation inplace and return None.</source>
          <target state="translated">True이면 작업을 수행하고 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28b1d2c85f895aef12f78ff43875c24af96a30a5" translate="yes" xml:space="preserve">
          <source>If True, each cell will have an &lt;code&gt;id&lt;/code&gt; attribute in their HTML tag. The &lt;code&gt;id&lt;/code&gt; takes the form &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; is the unique identifier, &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; is the row number and &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; is the column number.</source>
          <target state="translated">True이면 각 셀 의 HTML 태그에 &lt;code&gt;id&lt;/code&gt; 속성 이 있습니다 . &lt;code&gt;id&lt;/code&gt; 형태를 취 &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; 고유 식별자 인 &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; 행 번호이고 &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; 열 번호이다.</target>
        </trans-unit>
        <trans-unit id="c187de18efb1034db0f173b43d135203505eb0f2" translate="yes" xml:space="preserve">
          <source>If True, each whitespace character (as defined by string.whitespace) remaining after tab expansion will be replaced by a single space (default: True).</source>
          <target state="translated">True 인 경우 탭 확장 후 남은 각 공백 문자 (string.whitespace로 정의 됨)는 단일 공백 ​​(기본값 : True)으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7bc41a15bead4034e53881eb90092ca96d9054c1" translate="yes" xml:space="preserve">
          <source>If True, fill in-place. Note: this will modify any other views on this object (e.g., a no-copy slice for a column in a DataFrame).</source>
          <target state="translated">True 인 경우 제자리에 채우십시오. 참고 :이 객체의 다른보기 (예 : DataFrame의 열에 대한 무 복사 슬라이스)가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="779f470c819fe4b8c76c9ffe041585b2a57ed854" translate="yes" xml:space="preserve">
          <source>If True, ignore the order of index &amp;amp; columns. Note: index labels must match their respective rows (same as in columns) - same labels must be with the same data.</source>
          <target state="translated">True 인 경우 인덱스 및 열 순서를 무시하십시오. 참고 : 색인 레이블은 각 행과 일치해야합니다 (열과 동일). 동일한 레이블은 동일한 데이터를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c1fb42cadb1475602cce6ec757150306fd56fb02" translate="yes" xml:space="preserve">
          <source>If True, in place. Note: this will modify any other views on this object (e.g. a column from a DataFrame). Returns the caller if this is True.</source>
          <target state="translated">True 인 경우 참고 :이 객체의 다른보기 (예 : DataFrame의 열)가 수정됩니다. 이것이 참이면 발신자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f32cc95594d1282134f1d68f351ad29dfeba40d" translate="yes" xml:space="preserve">
          <source>If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don&amp;rsquo;t infer dtypes at all, applies only to the data.</source>
          <target state="translated">True이면 dtypes를 유추합니다. 열에 대한 ddict가 dtype 인 경우이를 사용하십시오. False이면 dtype을 전혀 추론하지 않고 데이터에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="28a638dbfeb78f983bc652085d7b9c8a2d0bd1c8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned value.</source>
          <target state="translated">True 인 경우, 시스템 레벨 메모리 소비에 대한 &lt;code&gt;object&lt;/code&gt; dtype을 조사하여 데이터를 자세히 조사 하고 리턴 된 값에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="11c935c8f1af11c12f350eee790d77bcc513b2a8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned values.</source>
          <target state="translated">True 인 경우, 시스템 레벨 메모리 소비에 대해 &lt;code&gt;object&lt;/code&gt; dtype을 조사하여 데이터를 자세히 조사 하고 리턴 된 값에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="e79427f24ce68d71e994b467383dc8a5a268616c" translate="yes" xml:space="preserve">
          <source>If True, only apply to numeric columns.</source>
          <target state="translated">True 인 경우 숫자 열에 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="12c714b402a0f7d59a93c0a1d85e385c49190143" translate="yes" xml:space="preserve">
          <source>If True, parse dates in &lt;code&gt;data&lt;/code&gt; with the day first order</source>
          <target state="translated">True 인 경우 &lt;code&gt;data&lt;/code&gt; 에서 날짜를 첫 번째 날짜 순서로 구문 분석 하십시오.</target>
        </trans-unit>
        <trans-unit id="11a6adfd18dc986d6ff6528d42e29ae888e6d526" translate="yes" xml:space="preserve">
          <source>If True, perform operation in-place.</source>
          <target state="translated">True 인 경우 작업을 제자리에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7b35ea2160939c711232caacbe9ffc59471f5f6b" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">True 인 경우, 접두사 (?) 경로로 레코드를 접 두부로 묶습니다 (예 : 메타가 [ 'foo', 'bar'] 인 경우 foo.bar.field).</target>
        </trans-unit>
        <trans-unit id="918691faec44a66f1b1c5ddaf68832370f5563d0" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">True 인 경우 점으로 구분 된 (?) 경로가있는 레코드를 접 두부로 사용하십시오 (예 : 레코드 경로가 [ 'foo', 'bar'] 인 경우 foo.bar.field).</target>
        </trans-unit>
        <trans-unit id="1b787f2412a9a56f4f2d0a2789a8e490bc7bd97a" translate="yes" xml:space="preserve">
          <source>If True, raise Exception on creating index with duplicates.</source>
          <target state="translated">True 인 경우 중복 인덱스 생성시 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f92c7eaff72b81ab6a7f6f3c046d665142253fca" translate="yes" xml:space="preserve">
          <source>If True, raise ValueError on creating index with duplicates.</source>
          <target state="translated">True 인 경우 중복 인덱스 생성시 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="65688aa40ea915fb917db04985ab684fb4b0d10f" translate="yes" xml:space="preserve">
          <source>If True, require an exact format match.</source>
          <target state="translated">True 인 경우 정확한 형식 일치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a51ee754f13842cc1c7503238049ba90f6317028" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame with one column per capture group. If False, return a Series/Index if there is one capture group or DataFrame if there are multiple capture groups.</source>
          <target state="translated">True 인 경우 캡처 그룹당 하나의 열이있는 DataFrame을 반환합니다. False이면 캡처 그룹이 하나 있으면 Series / Index를, 캡처 그룹이 여러 개이면 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="752a06fc414514adb4cbae9fe15c30471375abcf" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index.</source>
          <target state="translated">True 인 경우 DataFrame / MultiIndex 확장 차원을 반환합니다. False이면 Series / Index를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fceb9f4dd2f49705ce97835f6760fabf3db79d64" translate="yes" xml:space="preserve">
          <source>If True, return the index as the first element of the tuple.</source>
          <target state="translated">True 인 경우 인덱스를 튜플의 첫 번째 요소로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="db6a2a7946d7a74ee079d7db1cd5033117192d16" translate="yes" xml:space="preserve">
          <source>If True, returns an iterator for reading the file incrementally.</source>
          <target state="translated">True 인 경우 파일을 점차적으로 읽는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e9f098b0cebf828eaf4b7145977c959411d29fa" translate="yes" xml:space="preserve">
          <source>If True, skip NaN values.</source>
          <target state="translated">True이면 NaN 값을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="2c7785df59be40ed32a0a30ad986c482f4b9104c" translate="yes" xml:space="preserve">
          <source>If True, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">True 인 경우 NaN 값으로 해석하지 않고 빈 줄을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="45dc4286e28963ebfaf419f2ca82e19caa47ad55" translate="yes" xml:space="preserve">
          <source>If True, sort values in ascending order, otherwise descending.</source>
          <target state="translated">True이면 값을 오름차순으로 정렬하고 그렇지 않으면 내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="b4c0dbb1de303429c5f1585939b0e85294386572" translate="yes" xml:space="preserve">
          <source>If True, tab characters will be expanded to spaces (default: True).</source>
          <target state="translated">True이면 탭 문자가 공백으로 확장됩니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="c4133671064687e871d2078ebf94e5b70a1263d8" translate="yes" xml:space="preserve">
          <source>If True, the underlying data is copied. Otherwise (default), no copy is made if possible.</source>
          <target state="translated">True 인 경우 기본 데이터가 복사됩니다. 그렇지 않으면 (기본값) 가능한 경우 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdead9bb7da05f8a6a1234e7274e5a9b654351b0" translate="yes" xml:space="preserve">
          <source>If True, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width (default: True).</source>
          <target state="translated">True 인 경우 너비보다 긴 선이 없는지 확인하기 위해 너비보다 긴 단어가 분리됩니다. False 인 경우 긴 단어가 깨지지 않으며 일부 줄이 너비보다 길 수 있습니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="96caf78b1c5986e9400372061306220c9af20aa7" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</source>
          <target state="translated">True 인 경우 변환 된 고유 한 날짜 캐시를 사용하여 날짜 / 시간 변환을 적용하십시오. 중복 날짜 문자열, 특히 시간대 오프셋이있는 문자열을 구문 분석 할 때 속도가 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc5966567744c9deec0817e54ad119ae9eb8051" translate="yes" xml:space="preserve">
          <source>If True, whitespace that, after wrapping, happens to end up at the beginning or end of a line is dropped (default: True).</source>
          <target state="translated">True 인 경우 줄 바꿈 후 줄의 시작 또는 끝에서 발생하는 공백이 삭제됩니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="af63c1972ac9e275096f086bf4dbabfd22a77fc3" translate="yes" xml:space="preserve">
          <source>If True, wrapping will occur preferably on whitespace and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words (default: True).</source>
          <target state="translated">True 인 경우 줄 바꿈은 영어에서 관례 적으로 복합 단어에서 공백과 하이픈 바로 뒤에 발생하는 것이 좋습니다. false 인 경우 공백 만 줄 바꿈에 적합한 위치로 간주되지만 실제로 절제 할 수없는 단어를 원할 경우 break_long_words를 false로 설정해야합니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="b671a6d1db2b1bde6a5afb6d8028d31c59543e99" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; is used, all unmapped categories are mapped to &lt;code&gt;NaN&lt;/code&gt; and the result is an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;code&gt;dict&lt;/code&gt; 사용하는 모든 매핑되지 않은 범주에 매핑되는 &lt;code&gt;NaN&lt;/code&gt; 를 하고 결과는이다 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3fc417177302a9cebffe9152263446b535b47d84" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; or &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; is used any unmapped category is mapped to &lt;code&gt;NaN&lt;/code&gt;. Note that if this happens an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;dict&lt;/code&gt; 또는 &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 가 사용 되면 매핑되지 않은 범주가 &lt;code&gt;NaN&lt;/code&gt; 에 매핑됩니다 . 이런 일이 발생하면 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cbad76c3179a700e058557a45022426a6d90e9b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to &lt;code&gt;to_replace&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; but they are not the same length.</source>
          <target state="translated">경우 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;ndarray&lt;/code&gt; 이 전달됩니다 &lt;code&gt;to_replace&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 하지만 그들은 같은 길이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5059a3623e6ca9dc7f9b266d2608545843106902" translate="yes" xml:space="preserve">
          <source>If a class cannot be constructed from this &amp;lsquo;string&amp;rsquo;.</source>
          <target state="translated">이 '문자열'에서 클래스를 구성 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="c8c5f0454c9ec1fde1714f17e1d952b9f7a5cc52" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparseable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">열 또는 인덱스를 날짜 시간 배열로 표현할 수없는 경우 (예 : 구문 분석 할 수없는 값 또는 시간대 혼합으로 인해) 열 또는 인덱스는 변경되지 않은 개체 데이터 형식으로 반환됩니다. 비표준 날짜 시간 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 뒤에 &lt;code&gt;pd.read_csv&lt;/code&gt; 사용 하십시오 . 시간대를 혼합하여 인덱스 또는 열을 구문 분석하려면 &lt;code&gt;date_parser&lt;/code&gt; 를 &lt;code&gt;utc=True&lt;/code&gt; 와 함께 부분적으로 적용되는 &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt; 으로 지정 하십시오 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;시간대가 혼합 된 CSV 구문 분석을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="024994997113b185624470243df16f27242d166f" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">열 또는 인덱스에 구문 분석 할 수없는 날짜가 포함되어 있으면 전체 열 또는 인덱스가 변경되지 않은 상태로 개체 데이터 형식으로 반환됩니다. 비표준 날짜 시간 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 뒤에 &lt;code&gt;pd.read_excel&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d2a0936634decaa45bcdb1077adb50caa2399d8" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">날짜가 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;타임 스탬프 제한을&lt;/a&gt; 충족하지 않으면 errors = 'ignore'를 전달하면 예외가 발생하지 않고 원래 입력이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78077d7035e3e1bf386c562ad6a6026d3c197e60" translate="yes" xml:space="preserve">
          <source>If a date is not on a valid date, the rollback and rollforward methods can be used to roll the date to the nearest valid date before/after the date.</source>
          <target state="translated">날짜가 유효한 날짜가 아닌 경우 롤백 및 롤 포워드 방법을 사용하여 날짜 전 / 후에 가장 가까운 유효한 날짜로 날짜를 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d1bab9d594a6b54ccef73be2232f54e1cae5a4c" translate="yes" xml:space="preserve">
          <source>If a dict is passed, the sorted keys will be used as the &lt;code&gt;keys&lt;/code&gt; argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.</source>
          <target state="translated">dict가 전달되면 정렬 된 키 가 전달되지 않으면 &lt;code&gt;keys&lt;/code&gt; 인수 로 사용되며, 이 경우 값이 선택됩니다 (아래 참조). 모든 None 객체는 모두 None이 아니면 자동으로 삭제됩니다.이 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c64f440bc1e2f9dad75b50704b6ed07e14d9e40e" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, &lt;code&gt;data&lt;/code&gt; is passed through to &lt;code&gt;numpy.array()&lt;/code&gt;, and a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">dtype을 지정하지 않으면 &lt;code&gt;data&lt;/code&gt; 가 &lt;code&gt;numpy.array()&lt;/code&gt; 전달 되고 &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a6eb6c7d1e4657646b6302b848a8747082bbc0" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for &lt;code&gt;filepath_or_buffer&lt;/code&gt;, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</source>
          <target state="translated">파일 경로가 제공되면 &lt;code&gt;filepath_or_buffer&lt;/code&gt; , 메모리에 직접 파일 객체를지도하고 거기에서 데이터를 직접 액세스 할 수 있습니다. 이 옵션을 사용하면 더 이상 I / O 오버 헤드가 없으므로 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b0e7c1c6bb842c26a2ad6521207d7b659ebca7" translate="yes" xml:space="preserve">
          <source>If a function with the same arguments as the one being deprecated exist, you can use the &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt;:</source>
          <target state="translated">사용되지 않는 것과 동일한 인수를 가진 함수가 존재하면 &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a55f5c7d16f500e6da16614d2adb42965248f34" translate="yes" xml:space="preserve">
          <source>If a label is in several intervals, you get the locations of all the relevant intervals.</source>
          <target state="translated">레이블이 여러 간격으로 있으면 모든 관련 간격의 위치를 ​​얻습니다.</target>
        </trans-unit>
        <trans-unit id="f0da20aab515eb31a5cffcf23bf1728563e5abe6" translate="yes" xml:space="preserve">
          <source>If a list of dict/series is passed and the keys are all contained in the DataFrame&amp;rsquo;s index, the order of the columns in the resulting DataFrame will be unchanged.</source>
          <target state="translated">dict / series 목록이 전달되고 키가 모두 DataFrame의 색인에 포함 된 경우 결과 DataFrame의 열 순서는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a932b347122ba17dc03c8f35de7e3581545858f" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed it is used to fill all missing values. Alternatively, an array-like &amp;lsquo;value&amp;rsquo; can be given. It&amp;rsquo;s expected that the array-like have the same length as &amp;lsquo;self&amp;rsquo;.</source>
          <target state="translated">스칼라 값이 전달되면 누락 된 모든 값을 채우는 데 사용됩니다. 또는 배열과 같은 '값'을 지정할 수 있습니다. 배열과 같은 길이는 'self'와 동일한 길이를 가질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f43ebe72554d837c1947c44cf9fbf7743e493fcf" translate="yes" xml:space="preserve">
          <source>If a str is passed, the color is the same for both negative and positive numbers. If 2-tuple/list is used, the first element is the color_negative and the second is the color_positive (eg: [&amp;lsquo;#d65f5f&amp;rsquo;, &amp;lsquo;#5fba7d&amp;rsquo;]).</source>
          <target state="translated">str이 전달되면 색상은 음수와 양수 모두 동일합니다. 2- 튜플 /리스트를 사용하는 경우 첫 번째 요소는 color_negative이고 두 번째 요소는 color_positive입니다 (예 : [ '# d65f5f', '# 5fba7d']).</target>
        </trans-unit>
        <trans-unit id="664c221db1d1a044cd6be831ba5898cec1c6e906" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level If list-like must be names or ints of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다.리스트와 같은 경우 이름 또는 레벨의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a1949bae823faece7ef8021ce74e5c7a237a24cd" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or indexes of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다. 목록과 같은 경우 요소는 레벨의 이름 또는 색인이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2bd170078f20dc52e06bd86e8da7a8f33d73c15a" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다. 목록과 같은 경우 요소는 이름 또는 레벨의 위치 인덱스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ab59153983f88bd3ac8734604519b5c38d644805" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all columns. If a dictionary, a mapping of column names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">문자열 또는 유형 인 경우 모든 열을 저장할 데이터 유형입니다. 사전 인 경우 열 이름 및 인덱스 (인덱싱 된)를 특정 데이터 유형에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="2cbe87791c4a51a042d70e2afa4264d8fe2def9f" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all index levels. If a dictionary, a mapping of index level names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">문자열 또는 유형 인 경우 모든 색인 레벨을 저장할 데이터 유형입니다. 사전 인 경우 색인 레벨 이름 및 색인 (0 색인)을 특정 데이터 유형에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="17ceab91a6aa8289bb5b8021e866580a53c5a0f2" translate="yes" xml:space="preserve">
          <source>If all elements are non-NA/null, returns None. Also returns None for empty Series/DataFrame.</source>
          <target state="translated">모든 요소가 비 NA / 널인 경우 없음을 리턴합니다. 빈 Series / DataFrame에 대해서도 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7703cb2a81c8223e4ff309ac97d763111e01337d" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in &lt;code&gt;where&lt;/code&gt;, -1 is returned.</source>
          <target state="translated">색인의 모든 레이블이 &lt;code&gt;where&lt;/code&gt; 의 레이블보다 늦으면 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ba174535c6272f0b997374d38b2209ea810429e1" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than the passed label, NaN is returned.</source>
          <target state="translated">인덱스의 모든 레이블이 전달 된 레이블보다 늦으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c1e29cecb8deb1bb9249dfbe69e58b24b5165bd3" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError</source>
          <target state="translated">allow_fill = True이고 fill_value가 None이 아닌 경우, -1로 지정된 인덱스는 NA로 간주됩니다. Index가 NA를 보유하지 않으면 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ff14634826d79012ed764cfa8de5a9838978cc57" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table column. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">배열이 전달되면 데이터와 길이가 같아야합니다. 목록은 다른 유형을 포함 할 수 있습니다 (목록 제외). 피벗 테이블 열에서 그룹화 할 키입니다. 배열이 전달되면 열 값과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c5ee36569ccce557bf8297b686d33c4ab619682" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table index. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">배열이 전달되면 데이터와 길이가 같아야합니다. 목록은 다른 유형을 포함 할 수 있습니다 (목록 제외). 피벗 테이블 인덱스에서 그룹화 할 키입니다. 배열이 전달되면 열 값과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af8c676f3147891a205dd28d61aaddbbe77519ec" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no &lt;code&gt;categories&lt;/code&gt; and the &lt;code&gt;values&lt;/code&gt; are not sortable.</source>
          <target state="translated">명시 적 경우 &lt;code&gt;ordered=True&lt;/code&gt; 주어진다하지만 &lt;code&gt;categories&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a811d63c53b8811ca58b647eaf1fc34cafb5488e" translate="yes" xml:space="preserve">
          <source>If any kind of string dtype is passed in.</source>
          <target state="translated">문자열 dtype이 전달 된 경우</target>
        </trans-unit>
        <trans-unit id="737e8df6f3276db9f6615ef85a21d500c5c61d47" translate="yes" xml:space="preserve">
          <source>If any method argument other than the default of None is specified as these are not yet implemented.</source>
          <target state="translated">기본값 None이 아닌 메소드 인수가 아직 구현되지 않았으므로 지정된 경우.</target>
        </trans-unit>
        <trans-unit id="70c61d6e01ff0aae044349ecdba7bbb1250fe8c6" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis and &amp;ldquo;errors=&amp;rsquo;raise&amp;rsquo;&amp;rdquo;.</source>
          <target state="translated">선택한 축에 레이블이 없으면 &quot;errors = 'raise'&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f11beca5c6ae8017f4b7406cc4296549080b22d3" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis.</source>
          <target state="translated">선택한 축에 레이블이없는 경우.</target>
        </trans-unit>
        <trans-unit id="47983fc844672129f9ac1881a49d6e66e982428b" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">목록 항목 중 하나라도 문자열 객체가 아닌 경우 조인 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1979d89f7de4b9fbb39ec05f540083098724a80f" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="translated">접두사를 추가하는 경우 사용할 구분 기호 / 구분 기호입니다. 또는 &lt;code&gt;prefix&lt;/code&gt; 와 같이 목록이나 사전을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="a11a511e2ae2cc8424f72edc278dc39628207610" translate="yes" xml:space="preserve">
          <source>If applicable, we highly recommend that you implement &lt;code&gt;__array_ufunc__&lt;/code&gt; in your extension array to avoid coercion to an ndarray. See &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;the numpy documentation&lt;/a&gt; for an example.</source>
          <target state="translated">해당되는 경우 확장 배열에 &lt;code&gt;__array_ufunc__&lt;/code&gt; 를 구현하여 ndarray 에 대한 강제를 피하는 것이 좋습니다 . 예제 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;는 numpy 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="072e26cb4593102e0bb6adf3546c35bd36d7bb05" translate="yes" xml:space="preserve">
          <source>If applying compression use the fletcher32 checksum.</source>
          <target state="translated">압축을 적용하는 경우 fletcher32 체크섬을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f8772725018c792397868923cdb717ae3175a40" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, convert a specific level. Otherwise must be None</source>
          <target state="translated">축이 다중 인덱스 인 경우 특정 수준을 변환합니다. 그렇지 않으면 없음이어야합니다</target>
        </trans-unit>
        <trans-unit id="87391f1e1e648bf058bee7a9654161130eecfc7b" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None</source>
          <target state="translated">축이 다중 인덱스 인 경우 특정 수준을 지역화합니다. 그렇지 않으면 없음이어야합니다</target>
        </trans-unit>
        <trans-unit id="e69e66617e975b4f927b06bc80c35783ba32c625" translate="yes" xml:space="preserve">
          <source>If bin edges are not unique, raise ValueError or drop non-uniques.</source>
          <target state="translated">빈 가장자리가 고유하지 않으면 ValueError를 높이거나 고유하지 않은 것을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="253d364dc8215c289f304194e1235e5c7cb7fc6c" translate="yes" xml:space="preserve">
          <source>If both dayfirst and yearfirst are True, yearfirst is preceded (same as dateutil).</source>
          <target state="translated">dayfirst와 yearfirst가 모두 True이면 yearfirst가 선행됩니다 (dateutil과 동일).</target>
        </trans-unit>
        <trans-unit id="20ec4100e04e070e2add532e3371209cd96960d1" translate="yes" xml:space="preserve">
          <source>If both of &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; are empty</source>
          <target state="translated">모두 경우 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 비어 있습니다</target>
        </trans-unit>
        <trans-unit id="ab952ef7ef22e79ae1ce8234aa416ed5979fad75" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the resulting LateX format as a string. Otherwise returns None.</source>
          <target state="translated">buf가 None이면 결과 LateX 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9d07940e53f336322c19c2cd577417a583dce50" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be &lt;code&gt;lambda x: x.upper() in
['AAA', 'BBB', 'DDD']&lt;/code&gt;. Using this parameter results in much faster parsing time and lower memory usage.</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 열 이름과 비교하여 호출 가능 함수가 True로 평가되는 이름을 리턴합니다. 유효한 호출 가능한 인수의 예는 &lt;code&gt;lambda x: x.upper() in ['AAA', 'BBB', 'DDD']&lt;/code&gt; . 이 매개 변수를 사용하면 구문 분석 시간이 훨씬 빨라지고 메모리 사용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f28da403364b3ca9b72b658dafe69a7d983229a8" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 열 이름과 비교하여 호출 가능 함수가 True로 평가되는 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9cc56eeda19feaa07d8092a737946e7c1b49b405" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt;.</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 행 인덱스에 대해 평가되어 행을 건너 뛰어야하면 True를, 그렇지 않으면 False를 리턴합니다. 유효한 호출 가능한 인수의 예는 &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="513ede3f3a8cf7e7586af86037ccc686ffc6ba4a" translate="yes" xml:space="preserve">
          <source>If callable, then evaluate each column name against it and parse the column if the callable returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">호출 가능하면 각 열 이름을 평가하고 호출 가능이 &lt;code&gt;True&lt;/code&gt; 를 리턴하면 열을 구문 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="685d3f02d43beae9f293bf9f8747df3c13b4c5c6" translate="yes" xml:space="preserve">
          <source>If columns are a MultiIndex then use this level to melt.</source>
          <target state="translated">열이 다중 인덱스 인 경우이 수준을 사용하여 녹입니다.</target>
        </trans-unit>
        <trans-unit id="73f524f5a96443526a0f752ccc0a0f45d33e2689" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timedelta data.</source>
          <target state="translated">데이터가 없음 인 경우 일반 타임 델타 데이터 생성시 시작점으로 시작이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff093965800686fc456d1ec74cddd873c03a2a06" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timestamp data.</source>
          <target state="translated">데이터가 없음 인 경우 일반 타임 스탬프 데이터를 생성 할 때 시작점이 시작으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dae62288e37f2c075b791322d9beac67a5a2965c" translate="yes" xml:space="preserve">
          <source>If data is None, used as the start point in generating regular period data.</source>
          <target state="translated">데이터가 없음 인 경우 정규 기간 데이터 생성시 시작점으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f945356c77bbf782bb9b78eeeea13f0a8f770df9" translate="yes" xml:space="preserve">
          <source>If datetimes contain timezone information</source>
          <target state="translated">날짜 시간에 시간대 정보가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="151a8d67020136db3746f6fd54d019f0751e502a" translate="yes" xml:space="preserve">
          <source>If dropna, will take the nth non-null row, dropna is either &amp;lsquo;all&amp;rsquo; or &amp;lsquo;any&amp;rsquo;; this is equivalent to calling dropna(how=dropna) before the groupby.</source>
          <target state="translated">dropna가 null이 아닌 n 번째 행을 취하는 경우 dropna는 'all'또는 'any'입니다. 이것은 그룹별로 dropna (how = dropna)를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec063cf3e1fb3772513c2c6ae92ef2ab32d9ee75" translate="yes" xml:space="preserve">
          <source>If dtype is None, we find the dtype that best fits the data. If an actual dtype is provided, we coerce to that dtype if it&amp;rsquo;s safe. Otherwise, an error will be raised.</source>
          <target state="translated">dtype이 None이면 데이터에 가장 적합한 dtype을 찾습니다. 실제 dtype이 제공되면 안전하다면 dtype으로 강제 변환합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5291444796253761cd9ba2fe4457299e7f8a08a6" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is False, and warn_bad_lines is True, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">error_bad_lines가 False이고 warn_bad_lines가 True 인 경우 각&amp;ldquo;잘못된 라인&amp;rdquo;에 대한 경고가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c76ec1a67aef33e908ab260e62c8b2c8f08ade" translate="yes" xml:space="preserve">
          <source>If everything looks good, you are ready to make a pull request. A pull request is how code from a local repository becomes available to the GitHub community and can be looked at and eventually merged into the master version. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. To submit a pull request:</source>
          <target state="translated">모든 것이 좋아 보인다면, 풀 요청을 할 준비가 된 것입니다. 풀 요청은 로컬 리포지토리의 코드가 GitHub 커뮤니티에서 사용 가능해지면서 마스터 버전으로보고 병합 될 수있는 방법입니다. 이 풀 요청 및 관련 변경 사항은 결국 마스터 브랜치에 커밋되어 다음 릴리스에서 사용할 수 있습니다. 풀 요청을 제출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="23c9060c54c6bb6c39f0e98425258486180b9e59" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt; &lt;code&gt;n&lt;/code&gt;, append &lt;code&gt;None&lt;/code&gt; for padding up to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;expand=True&lt;/code&gt;</source>
          <target state="translated">특정 행에 대해 발견 된 분할 수가 &amp;lt; &lt;code&gt;n&lt;/code&gt; 인 경우 &lt;code&gt;expand=True&lt;/code&gt; 인 경우 최대 &lt;code&gt;n&lt;/code&gt; 까지 채우기 위해 &lt;code&gt;None&lt;/code&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6211ffb8fa3fb2fd37ec09f2b6296b76ea53b066" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt; &lt;code&gt;n&lt;/code&gt;, make first &lt;code&gt;n&lt;/code&gt; splits only</source>
          <target state="translated">찾은 splits&amp;gt; &lt;code&gt;n&lt;/code&gt; 이면 처음 &lt;code&gt;n&lt;/code&gt; 개의 스플릿 만 만드십시오.</target>
        </trans-unit>
        <trans-unit id="b37fc31feaa05a56a504bc57a3dc5a6d1aa79bdc" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;= &lt;code&gt;n&lt;/code&gt;, make all splits</source>
          <target state="translated">발견 된 분할이 &amp;lt;= &lt;code&gt;n&lt;/code&gt; 이면 모든 분할을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="faedb07d74ab41f0e6f62f0f259b9779f728a236" translate="yes" xml:space="preserve">
          <source>If freq is an invalid frequency</source>
          <target state="translated">주파수가 유효하지 않은 주파수 인 경우</target>
        </trans-unit>
        <trans-unit id="803c3a3090c279b46259470fbbb792974d7f901b" translate="yes" xml:space="preserve">
          <source>If freq is not specified then tries to use the freq or inferred_freq attributes of the index. If neither of those attributes exist, a ValueError is thrown</source>
          <target state="translated">freq를 지정하지 않으면 인덱스의 freq 또는 inferred_freq 속성을 사용하려고합니다. 이러한 속성 중 어느 것도 존재하지 않으면 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e199c3229ad1a29b7396ccb73cb9b8b33ec4f" translate="yes" xml:space="preserve">
          <source>If func returns a Series object the result will be a DataFrame.</source>
          <target state="translated">func이 Series 객체를 반환하면 결과는 DataFrame이됩니다.</target>
        </trans-unit>
        <trans-unit id="97e40162438268f3434fb42f4961c0381c5a410b" translate="yes" xml:space="preserve">
          <source>If given, it will use the &lt;code&gt;fig&lt;/code&gt; reference for plotting instead of creating a new one with default parameters.</source>
          <target state="translated">주어진 경우, 기본 매개 변수로 새 참조를 작성하는 대신 플로팅에 &lt;code&gt;fig&lt;/code&gt; 참조를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4f948fed8d6912efb15a4f875d827717c7e831f0" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and &lt;code&gt;freq&lt;/code&gt; parameter is passed.</source>
          <target state="translated">그룹화가 PeriodIndex이고 &lt;code&gt;freq&lt;/code&gt; 매개 변수가 전달 된 경우.</target>
        </trans-unit>
        <trans-unit id="2153311a52299005ad6b900f85d75a5bc89c102d" translate="yes" xml:space="preserve">
          <source>If implementing NumPy&amp;rsquo;s &lt;code&gt;__array_ufunc__&lt;/code&gt; interface, pandas expects that</source>
          <target state="translated">NumPy의 &lt;code&gt;__array_ufunc__&lt;/code&gt; 인터페이스를 구현하면 팬더는 다음을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="9b5b6c6275ac36d8c29c9ef0f491f5feaa9d6ffc" translate="yes" xml:space="preserve">
          <source>If int and &amp;ldquo;stop&amp;rdquo; is not given, interpreted as &amp;ldquo;stop&amp;rdquo; instead.</source>
          <target state="translated">int 및 &quot;stop&quot;이 제공되지 않으면 대신 &quot;stop&quot;으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7b2547e4136f8605b954d25571fea98abec426" translate="yes" xml:space="preserve">
          <source>If int, then indicates last column to be parsed.</source>
          <target state="translated">int이면 구문 분석 할 마지막 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bb72fad3e82acae71dc7993a1447557d62c8a5b" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Acceptable values are None or xlrd.</source>
          <target state="translated">io가 버퍼 또는 경로가 아닌 경우 io를 식별하도록 설정해야합니다. 허용 가능한 값은 None 또는 xlrd입니다.</target>
        </trans-unit>
        <trans-unit id="e7b90b33df08c56801541d97b52863d5cc1a2208" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. This is new in 0.19.0</source>
          <target state="translated">오프셋이면 각 창의 시간이됩니다. 각 기간은 기간에 포함 된 관측치에 따라 다양한 크기로 조정됩니다. datetimelike 인덱스에만 유효합니다. 0.19.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="ad91bd2fcbc8853d5dc9cba2938f0dd911cf8a6d" translate="yes" xml:space="preserve">
          <source>If keep_tz is False:</source>
          <target state="translated">keep_tz가 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="baf1483fae1fac9f24a7c2ddac2906ea600716bb" translate="yes" xml:space="preserve">
          <source>If keep_tz is True:</source>
          <target state="translated">keep_tz가 True 인 경우 :</target>
        </trans-unit>
        <trans-unit id="5bb59e5d8fa791e8b043037739659a61a93a3a51" translate="yes" xml:space="preserve">
          <source>If label is contained, will be reference to calling Series, otherwise a new object.</source>
          <target state="translated">label이 포함 된 경우 Series 호출에 대한 참조이며, 그렇지 않으면 새 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d8f134714528b444920506c4fe5aa496b4202bff" translate="yes" xml:space="preserve">
          <source>If label is not contained, a new object is created with the label placed at the end of the result index.</source>
          <target state="translated">label이 포함되어 있지 않으면 결과 색인의 끝에 레이블이있는 새 오브젝트가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a824931c7f88c06d3b1aacfaeeb1337548e955e0" translate="yes" xml:space="preserve">
          <source>If label pair is contained, will be reference to calling DataFrame, otherwise a new object.</source>
          <target state="translated">레이블 쌍이 포함 된 경우 DataFrame 호출에 대한 참조이며, 그렇지 않으면 새 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c00e1450820324efbc32fd35d064eb356db799b1" translate="yes" xml:space="preserve">
          <source>If level is specified, then, DataFrame is returned; otherwise, Series is returned.</source>
          <target state="translated">레벨이 지정되면 DataFrame이 리턴됩니다. 그렇지 않으면 Series가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7877da1e50e258680542b6af26d6fd85ecae2065" translate="yes" xml:space="preserve">
          <source>If level is specified, then, Series is returned; otherwise, scalar is returned.</source>
          <target state="translated">레벨이 지정되면 Series가 리턴됩니다. 그렇지 않으면 스칼라가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ca17fab71c58fc25bab74d5c9db224c9c0dc9b57" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled in this direction.</source>
          <target state="translated">한계가 지정되면 연속 NaN이이 방향으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="eed73a2e297bebfb2ce480434de0e2542a0badfc" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled with this restriction.</source>
          <target state="translated">제한이 지정되면 연속 NaN이이 제한으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7caf98f1a23fbe99f3eecc43311325e017b47681" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions</source>
          <target state="translated">함수 목록이 전달되면 결과 피벗 테이블에는 최상위 수준이 함수 이름 인 계층 열이 있습니다 (함수 개체 자체에서 유추 됨) dict가 전달되면 키는 집계 할 열이고 값은 함수 또는 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1d66f9c3628338003e89214bb889ccfda13c37c0" translate="yes" xml:space="preserve">
          <source>If list of int, then indicates list of column numbers to be parsed.</source>
          <target state="translated">int의 목록 인 경우 구문 분석 할 열 번호 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fe49dea595acc90377978d171ab9c0a0e7439a2" translate="yes" xml:space="preserve">
          <source>If list of string, then indicates list of column names to be parsed.</source>
          <target state="translated">문자열 목록 인 경우 구문 분석 할 열 이름 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d433683ef161d07d541b7f8a919bcca2325d430" translate="yes" xml:space="preserve">
          <source>If margins is &lt;code&gt;True&lt;/code&gt;, will also normalize margin values.</source>
          <target state="translated">여백이 &lt;code&gt;True&lt;/code&gt; 이면 여백 값도 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="2a02a553bcee455a6ab31e5dbd189b43939c5bad" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled.</source>
          <target state="translated">method가 지정되면, 앞으로 / 뒤로 채울 최대 연속 NaN 값 수입니다. 즉,이 수의 연속 NaN보다 많은 간격이 있으면 부분적으로 만 채워집니다. method가 지정되지 않은 경우 NaN이 채워지는 전체 축을 따라 최대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="64b5d3200781c8ed371e1e797a995a4f75b1dcb3" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None.</source>
          <target state="translated">method가 지정되면, 앞으로 / 뒤로 채울 최대 연속 NaN 값 수입니다. 즉,이 수의 연속 NaN보다 많은 간격이 있으면 부분적으로 만 채워집니다. method가 지정되지 않은 경우 NaN이 채워지는 전체 축을 따라 최대 항목 수입니다. None이 아닌 경우 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7f7d613c787dbb21e15f1dcf963bf265292c5edc" translate="yes" xml:space="preserve">
          <source>If more than one type is accepted, separate them by commas, except the last two types, that need to be separated by the word &amp;lsquo;or&amp;rsquo;:</source>
          <target state="translated">둘 이상의 유형이 허용되는 경우 마지막 두 유형을 제외하고 'or'라는 단어로 구분해야하는 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="052f2f856a6dfb7a8830bd4e0484cb7b2be454e4" translate="yes" xml:space="preserve">
          <source>If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level.</source>
          <target state="translated">여러 레벨이 통과 한 경우 튜플을 포함해야합니다. 전달 된 키를 최 외곽 레벨로 사용하여 계층 적 인덱스를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6501af21994846ec90e14ed89e7a813350f8d52c" translate="yes" xml:space="preserve">
          <source>If multiple object values have the highest count, then the &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; results will be arbitrarily chosen from among those with the highest count.</source>
          <target state="translated">여러 개체 값이 가장 높은 개수를 가진 경우 가장 높은 개수의 개체 중에서 &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 결과가 임의로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="34d7f3599c01ed87631ef489cca8da2b4308aa21" translate="yes" xml:space="preserve">
          <source>If multiple values equal the maximum, the first row label with that value is returned.</source>
          <target state="translated">여러 값이 최대 값과 같으면 해당 값을 가진 첫 번째 행 레이블이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12828981e6321f886a33ba30627df341eba8d652" translate="yes" xml:space="preserve">
          <source>If multiple values equal the minimum, the first row label with that value is returned.</source>
          <target state="translated">여러 값이 최소값과 같으면 해당 값을 가진 첫 번째 행 레이블이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="22f182e9b6624459ce684e4c8ed64ff090a2529a" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to</source>
          <target state="translated">na_values가 지정되고 keep_default_na가 False이면 기본 NaN 값이 재정의됩니다. 그렇지 않으면 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a517305158ceac1628f92ad56b945b90297339" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to.</source>
          <target state="translated">na_values가 지정되고 keep_default_na가 False이면 기본 NaN 값이 재정의되고 그렇지 않으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7000054cf48292d0455a5b9aca5bf89643b6c472" translate="yes" xml:space="preserve">
          <source>If new categories are list-like and do not have the same number of items than the current categories or do not validate as categories</source>
          <target state="translated">새 카테고리가 목록과 유사하고 현재 카테고리와 동일한 수의 항목이 없거나 카테고리로 유효성 검증되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="56ab769c4964e541ce9265684d378bc3a0d09287" translate="yes" xml:space="preserve">
          <source>If new_categories does not validate as categories</source>
          <target state="translated">new_categories가 카테고리로 유효하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="cbed0bbea58dcdb206a837899ad95a4ba77dcd33" translate="yes" xml:space="preserve">
          <source>If no names are provided, use the column names, or tuple of column names if the columns is a MultiIndex. If a sequence, overwrite names with the given sequence.</source>
          <target state="translated">이름이 제공되지 않으면 열 이름을 사용하거나 열이 MultiIndex 인 경우 열 이름 튜플을 사용하십시오. 시퀀스 인 경우 지정된 시퀀스로 이름을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a5bad26bee04e3ba222956c2c796e863be42591" translate="yes" xml:space="preserve">
          <source>If none of the labels are found in the index.</source>
          <target state="translated">색인에 레이블이없는 경우</target>
        </trans-unit>
        <trans-unit id="27841c0014abcd0463ff2861c53f354a6a34facc" translate="yes" xml:space="preserve">
          <source>If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:</source>
          <target state="translated">None이 아니고 데이터가 숫자 dtype으로 성공적으로 캐스트 된 경우 (또는 데이터가 숫자로 시작하는 경우) 다음 규칙에 따라 결과 데이터를 가능한 가장 작은 숫자 dtype으로 다운 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e361817d859e555a419bc1371e6268617ba32d96" translate="yes" xml:space="preserve">
          <source>If not None, only these columns will be read from the file.</source>
          <target state="translated">None이 아닌 경우 파일에서이 열만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cfe9cce3f8330a3251ed95d788697677222e7323" translate="yes" xml:space="preserve">
          <source>If not None, sort on values in specified index level(s).</source>
          <target state="translated">None이 아닌 경우 지정된 인덱스 수준에서 값을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="9376aca00f183cc74c267ce0caa80bff2fb817d1" translate="yes" xml:space="preserve">
          <source>If not all of the labels are found in the selected axis</source>
          <target state="translated">선택한 축에 모든 레이블이없는 경우</target>
        </trans-unit>
        <trans-unit id="d0a22f48a5959f07a3692660fc0f335e8e4e36ac" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca()</source>
          <target state="translated">전달되지 않으면 gca ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="605ce58ce37edd99b2cbc7ee655fc1a9f67c5f6c" translate="yes" xml:space="preserve">
          <source>If not provided, all columns are read.</source>
          <target state="translated">제공하지 않으면 모든 열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a29100beab681308f154ad5a4be5b3b89fb544c7" translate="yes" xml:space="preserve">
          <source>If not specified, there are two possibilities:</source>
          <target state="translated">지정하지 않으면 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67d8b502538e17d92597d391d70ada0247caada5" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self and produce pairwise output.</source>
          <target state="translated">제공되지 않으면 기본값은 자체로 설정되고 쌍별 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17e1ffdad774475011f6787cf4716965a7dadec6" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self.</source>
          <target state="translated">제공되지 않으면 기본값은 self입니다.</target>
        </trans-unit>
        <trans-unit id="a7b3cbcd2ecfdfe645e2c20769e281ebccbcc3e3" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Serie. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">other가 Series 인 경우, 자기 자신과 다른 사람 사이에서 매트릭스 제품을 Serie로 반환하십시오. other가 DataFrame 또는 numpy.array 인 경우 self 및 other의 행렬 곱을 np.array의 DataFrame에 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="236a44b890a6ba0afca4e7206977a422c9384304" translate="yes" xml:space="preserve">
          <source>If others is None, the method returns the concatenation of all strings in the calling Series/Index.</source>
          <target state="translated">others가 None 인 경우, 메소드는 호출하는 Series / Index에있는 모든 문자열의 연결을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b6f15e903f0777b1e7f0e9efd0f00fdc7d5f16dc" translate="yes" xml:space="preserve">
          <source>If others is a list-like that contains a combination of Series, Index or np.ndarray (1-dim), then all elements will be unpacked and must satisfy the above criteria individually.</source>
          <target state="translated">다른 요소가 Series, Index 또는 np.ndarray (1dim)의 조합을 포함하는 목록과 같은 경우 모든 요소의 압축이 풀리고 위의 기준을 개별적으로 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="7aa4696f9d9f11d69bd7c0bc73e4bd0736b1ad80" translate="yes" xml:space="preserve">
          <source>If parsing dates, then parse the default datelike columns.</source>
          <target state="translated">날짜를 구문 분석하는 경우 기본 날짜 유사 열을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="6ab98323b9cd6c707ec25d2e47620cf585b844dc" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or &lt;code&gt;True&lt;/code&gt;, will normalize over all values.</source>
          <target state="translated">'all'또는 &lt;code&gt;True&lt;/code&gt; 를 전달하면 모든 값에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a89a0012ee03a22f72bd2860e27eba43a13982b3" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;columns&amp;rsquo; will normalize over each column.</source>
          <target state="translated">통과되면 '열'이 각 열에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="e234887ca1ae0a80fa1868664dd0238d5d04ba79" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;index&amp;rsquo; will normalize over each row.</source>
          <target state="translated">'index'를 전달하면 각 행에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="cdbafc7d17980ded598ce2f6b941b4de6b162f7f" translate="yes" xml:space="preserve">
          <source>If passed, must match number of column arrays passed.</source>
          <target state="translated">전달 된 경우 전달 된 열 배열의 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f97f42e1389db9548ed46ba6d3fe5d917a8fa133" translate="yes" xml:space="preserve">
          <source>If passed, must match number of row arrays passed.</source>
          <target state="translated">전달 된 경우 전달 된 행 배열 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fa12f2a0ca4016bad2139234c3a9ac376f53792" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups</source>
          <target state="translated">통과하면 별도의 그룹에 대한 히스토그램을 형성하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="2a4b782f57e19abcb2aa77b54645db0e489c6b42" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups.</source>
          <target state="translated">통과하면 별도의 그룹에 대한 히스토그램을 형성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1c91474589b55c524f8116422575c56dae40f7" translate="yes" xml:space="preserve">
          <source>If passed, will be used to limit data to a subset of columns.</source>
          <target state="translated">전달되면 데이터를 열의 하위 집합으로 제한하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf13cb19b460c1c30c4e0e63d016fc04e393c052" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting csv format as a string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 csv 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="467786b2cc9f24142a326f141e5e9998e551f79b" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting json format as a string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 json 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ab35a4e69cd5e00e62bc40ef695d80398b3047f" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting msgpack format as a byte string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 msgpack 형식을 바이트 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fe82b619e0bf64745c86d941d95a0506e74aff0" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming period on or just past end argument</source>
          <target state="translated">기간이 없으면 생성 된 색인은 첫 번째 인수 기간 또는 종료 시점의 첫 번째 준수 기간으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d32965fa894336b076cce4f85e7e48d5894d1d82" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming time on or just past end argument</source>
          <target state="translated">마침표가 없으면 생성 된 색인은 첫 번째 인수 시점 또는 종료 시점의 첫 번째 준수 시간으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="be9cd18b4c26564dea3305689f1e4726a3a1fb03" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See csv.Dialect documentation for more details.</source>
          <target state="translated">: 제공 한 경우,이 매개 변수는 다음 매개 변수의 값 (디폴트 여부를) 무시합니다 &lt;code&gt;delimiter&lt;/code&gt; , &lt;code&gt;doublequote&lt;/code&gt; , &lt;code&gt;escapechar&lt;/code&gt; , &lt;code&gt;skipinitialspace&lt;/code&gt; , &lt;code&gt;quotechar&lt;/code&gt; 및 &lt;code&gt;quoting&lt;/code&gt; . 값을 대체해야하는 경우 ParserWarning이 발행됩니다. 자세한 내용은 csv.Dialect 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a05339991167e0e6c730f03164ad020504ffa9b3" translate="yes" xml:space="preserve">
          <source>If resulting index has only 1 level left, the result will be of Index type, not MultiIndex.</source>
          <target state="translated">결과 색인에 1 레벨 만 남으면 결과는 다중 색인이 아닌 색인 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1d17d6d3193f2c431cd73525c42fc1232029c3d2" translate="yes" xml:space="preserve">
          <source>If returning an ExtensionArray, then</source>
          <target state="translated">ExtensionArray를 반환하면</target>
        </trans-unit>
        <trans-unit id="881d4fbdc1e7a8b7ba5ab81f1479cb45ced59e14" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]display.memory_usage : bool, string or None This specifies if the memory usage of a DataFrame should be displayed when df.info() is called. Valid values True,False,&amp;rsquo;deep&amp;rsquo; [default: True] [currently: True]display.min_rows : int The numbers of rows to show in a truncated view (when &lt;code&gt;max_rows&lt;/code&gt; is exceeded). Ignored when &lt;code&gt;max_rows&lt;/code&gt; is set to None or 0. When set to None, follows the value of &lt;code&gt;max_rows&lt;/code&gt;. [default: 10] [currently: 10]display.multi_sparse : boolean &amp;ldquo;sparsify&amp;rdquo; MultiIndex display (don&amp;rsquo;t display repeated elements in outer levels within groups) [default: True] [currently: True]display.notebook_repr_html : boolean When True, IPython notebook will use html representation for pandas objects (if it is available). [default: True] [currently: True]display.pprint_nest_depth : int Controls the number of nested levels to process when pretty-printing [default: 3] [currently: 3]display.precision : int Floating point output precision (number of significant digits). This is only a suggestion [default: 6] [currently: 6]display.show_dimensions : boolean or &amp;lsquo;truncate&amp;rsquo; Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) [default: truncate] [currently: truncate]display.unicode.ambiguous_as_wide : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.unicode.east_asian_width : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.width : int Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. [default: 80] [currently: 80]io.excel.ods.reader : string The default Excel reader engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]io.excel.xls.reader : string The default Excel reader engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlrd. [default: auto] [currently: auto]io.excel.xls.writer : string The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlwt. [default: auto] [currently: auto]io.excel.xlsm.reader : string The default Excel reader engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsm.writer : string The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.reader : string The default Excel reader engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.writer : string The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, openpyxl, xlsxwriter. [default: auto] [currently: auto]io.hdf.default_format : format default format writing format, if None, then put will default to &amp;lsquo;fixed&amp;rsquo; and append will default to &amp;lsquo;table&amp;rsquo; [default: None] [currently: None]io.hdf.dropna_table : boolean drop ALL nan rows when appending to a table [default: False] [currently: False]io.parquet.engine : string The default parquet reader/writer engine. Available options: &amp;lsquo;auto&amp;rsquo;, &amp;lsquo;pyarrow&amp;rsquo;, &amp;lsquo;fastparquet&amp;rsquo;, the default is &amp;lsquo;auto&amp;rsquo; [default: auto] [currently: auto]mode.chained_assignment : string Raise an exception, warn, or no action if trying to use chained assignment, The default is warn [default: warn] [currently: warn]mode.sim_interactive : boolean Whether to simulate interactive mode for purposes of testing [default: False] [currently: False]mode.use_inf_as_na : boolean True means treat None, NaN, INF, -INF as NA (old way), False means None and NaN are null, but INF, -INF are not NA (new way). [default: False] [currently: False]mode.use_inf_as_null : boolean use_inf_as_null had been deprecated and will be removed in a future version. Use &lt;code&gt;use_inf_as_na&lt;/code&gt; instead. [default: False] [currently: False] (Deprecated, use &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; instead.)plotting.backend : str The plotting backend to use. The default value is &amp;ldquo;matplotlib&amp;rdquo;, the backend provided with pandas. Other backends can be specified by prodiving the name of the module that implements the backend. [default: matplotlib] [currently: matplotlib]plotting.matplotlib.register_converters : bool Whether to register converters with matplotlib&amp;rsquo;s units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. [default: True] [currently: True]</source>
          <target state="translated">없음으로 설정하면 인쇄 할 항목 수는 무제한입니다. [default : 100] [현재 : 100] display.memory_usage : bool, string 또는 None df.info ()를 호출 할 때 DataFrame의 메모리 사용량을 표시해야하는지 여부를 지정합니다. 유효한 값 True, False, 'deep'[default : True] [현재 : True] display.min_rows : int 잘린 뷰에 표시 할 행 수입니다 ( &lt;code&gt;max_rows&lt;/code&gt; 를 초과 한 경우). 때 무시 &lt;code&gt;max_rows&lt;/code&gt; 없음으로 설정되면 유료 또는 0으로 설정되고, 다음의 값 &lt;code&gt;max_rows&lt;/code&gt; . [default : 10] [현재 : 10] display.multi_sparse : 부울 &quot;스파 르즈&quot;다중 인덱스 표시 (그룹 내에서 외부 레벨에 반복 된 요소를 표시하지 않음) [default : True] [현재 : True] display.notebook_repr_html : 부울 True 일 때 IPython 노트북은 팬더 객체에 html 표현을 사용합니다 (사용 가능한 경우). [default : True] [현재 : True] display.pprint_nest_depth : int 예쁜 인쇄시 처리 할 중첩 레벨 수를 제어합니다. [default : 3] [현재 : 3] display.precision : int 부동 소수점 출력 정밀도 (유의 한 수) 자릿수). 이것은 단지 제안 일뿐입니다 [기본값 : 6] [현재 : 6] display.show_dimensions : 부울 또는 '잘라 내기'DataFrame repr의 끝에 치수를 인쇄할지 여부입니다. '잘라 내기'가 지정된 경우 프레임이 잘린 경우에만 치수를 인쇄하십시오 (예 :모든 행 및 / 또는 열을 표시하지는 않음) [default : truncate] [현재 : truncate] display.unicode.ambiguous_as_wide : boolean 유니 코드 동아시아 너비를 사용하여 표시 텍스트 너비를 계산할지 여부입니다. 이를 사용하면 성능에 영향을 줄 수 있습니다 (기본값 : False) [default : False] [현재 : False] display.unicode.east_asian_width : boolean 유니 코드 동아시아 너비를 사용하여 표시 텍스트 너비를 계산할지 여부입니다. 이 기능을 사용하면 성능에 영향을 줄 수 있습니다 (기본값 : False) [default : False] [현재 : False] display.width : int 문자의 디스플레이 너비입니다. python / IPython이 터미널에서 실행중인 경우 None으로 설정 될 수 있으며 팬더는 너비를 올바르게 자동 감지합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 너비를 올바르게 감지 할 수 없습니다. [기본:80] [현재 : 80] io.excel.ods.reader : string 'ods'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, odf. [default : auto] [현재 : auto] io.excel.xls.reader : string 'xls'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd. [default : auto] [현재 : auto] io.excel.xls.writer : string 'xls'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : auto, xlwt. [default : auto] [현재 : auto] io.excel.xlsm.reader : string 'xlsm'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd, openpyxl. [default : auto] [현재 : auto] io.excel.xlsm.writer : string 'xlsm'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : 자동, openpyxl. [default : auto] [현재 : auto] io.excel.xlsx.reader : string 'xlsx'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd,openpyxl. [default : auto] [현재 : auto] io.excel.xlsx.writer : string 'xlsx'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : 자동, openpyxl, xlsxwriter. [default : auto] [현재 : auto] io.hdf.default_format : 형식 기본 형식 쓰기 형식입니다. None 인 경우 기본적으로 'fixed'가되고 append가 기본적으로 'table'이됩니다. [default : None] [현재 : None ] io.hdf.dropna_table : 테이블에 추가 할 때 nanlean 모든 nan 행을 삭제합니다. [default : False] [현재 : False] io.parquet.engine : string 기본 마루 판독기 / 작성기 엔진입니다. 사용 가능한 옵션 : 'auto', 'pyarrow', 'fastparquet', 기본값은 'auto'입니다. [default : auto] [현재 : auto] mode.chained_assignment : string 연결을 사용하려는 경우 예외를 발생 시키거나 경고하거나 조치를 수행하지 않습니다. 할당, 기본값은 경고입니다 [기본값 : 경고] [현재 : 경고] mode.sim_interactive :boolean 테스트 목적으로 대화식 모드를 시뮬레이트할지 여부 [default : False] [현재 : False] mode.use_inf_as_na : boolean True는 None, NaN, INF, -INF를 NA (old way)로 처리하고 False는 None 및 NaN이 null임을 의미합니다. , 그러나 INF, -INF는 NA가 아닙니다 (새로운 방식). [default : False] [현재 : False] mode.use_inf_as_null : 부울 use_inf_as_null은 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다. 사용하다 &lt;code&gt;use_inf_as_na&lt;/code&gt; 대신 use_inf_as_na를 사용하십시오. [default : False] [현재 : False] (더 이상 사용되지 않음, 대신 &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; 를 사용하십시오.) plotting.backend : str 사용할 플로팅 백엔드. 기본값은 팬더와 함께 제공되는 백엔드 인&amp;ldquo;matplotlib&amp;rdquo;입니다. 백엔드를 구현하는 모듈의 이름을 제공하여 다른 백엔드를 지정할 수 있습니다. [default : matplotlib] [현재 : matplotlib] plotting.matplotlib.register_converters : bool matplotlib의 단위 레지스트리를 사용하여 날짜, 시간, 날짜 시간 및 기간에 변환기를 등록할지 여부. False로 전환하면 변환기가 제거되어 팬더가 덮어 쓴 변환기가 복원됩니다. [기본값 : True] [현재 : True]</target>
        </trans-unit>
        <trans-unit id="fa12ba58c2be2f71104408a510d4489d9b0c6ffa" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size</source>
          <target state="translated">지정된 경우 x 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="97863624dbef3656142375cfc414d8c6db270d6b" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size.</source>
          <target state="translated">지정된 경우 x 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7873740ccf0410b3fb0bea93346ff13ec92e92" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size</source>
          <target state="translated">지정된 경우 y 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="581f8ddceda8e96b28aea9467091a054fc8fcba4" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size.</source>
          <target state="translated">지정된 경우 y 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7820aaef54858d9fe6f835280f13f8d7b53a28bd" translate="yes" xml:space="preserve">
          <source>If specified only options matching &lt;code&gt;prefix*&lt;/code&gt; will be reset. Note: partial matches are supported for convenience, but unless you use the full option name (e.g. x.y.z.option_name), your code may break in future versions if new options with similar names are introduced.</source>
          <target state="translated">지정된 경우 &lt;code&gt;prefix*&lt;/code&gt; 일치하는 옵션 만 재설정됩니다. 참고 : 편의상 부분 일치가 지원되지만 전체 옵션 이름 (egxyzoption_name)을 사용하지 않으면 유사한 이름의 새 옵션이 도입되면 이후 버전에서 코드가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2fd14b30360e01bd1925a87fecdb829dae8c45" translate="yes" xml:space="preserve">
          <source>If specified, checks if merge is of specified type.</source>
          <target state="translated">지정된 경우 병합이 지정된 유형인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="195f4d58de033a32ef9e0ed103f9771ba227ede5" translate="yes" xml:space="preserve">
          <source>If specified, requires &lt;code&gt;values&lt;/code&gt; be specified as well.</source>
          <target state="translated">지정된 경우 &lt;code&gt;values&lt;/code&gt; 도 지정 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="50b212e57ff80a7164ca948bedf3a2c591bca4f5" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">지정된 경우 &lt;code&gt;chunksize&lt;/code&gt; 가 각 청크에 포함 할 행 수인 반복자를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="78439b54e5e60a975149f48cea5f22c188ad305b" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">지정된 경우 &lt;code&gt;chunksize&lt;/code&gt; 가 각 청크에 포함 할 행 수인 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="04bcdac7e76a787e1fbea8ae01f3869fac3ea6f8" translate="yes" xml:space="preserve">
          <source>If str, then indicates comma separated list of Excel column letters and column ranges (e.g. &amp;ldquo;A:E&amp;rdquo; or &amp;ldquo;A,C,E:F&amp;rdquo;). Ranges are inclusive of both sides.</source>
          <target state="translated">str 인 경우 쉼표로 구분 된 Excel 열 문자 및 열 범위 목록을 나타냅니다 (예 : &quot;A : E&quot;또는 &quot;A, C, E : F&quot;). 범위는 양쪽을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f4a7f4d474e4d7426374eb27e2b8239df04809bb" translate="yes" xml:space="preserve">
          <source>If table exists, do nothing.</source>
          <target state="translated">테이블이 존재하면 아무것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ca3b25179b041d34301bc35b333ae308c33e09c" translate="yes" xml:space="preserve">
          <source>If table exists, drop it, recreate it, and insert data.</source>
          <target state="translated">테이블이 존재하면 테이블을 삭제하고 다시 작성하고 데이터를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="8c60747c3d8c8c498c4f7ba4c804063996419ee9" translate="yes" xml:space="preserve">
          <source>If table exists, insert data. Create if does not exist.</source>
          <target state="translated">테이블이 존재하면 데이터를 삽입하십시오. 존재하지 않는 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cb65b84a0ed9ca7d9ee485a9567cc369b8c9fcac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;values&lt;/code&gt; argument is omitted, and the input &lt;code&gt;DataFrame&lt;/code&gt; has more than one column of values which are not used as column or index inputs to &lt;code&gt;pivot&lt;/code&gt;, then the resulting &amp;ldquo;pivoted&amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; will have &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical columns&lt;/a&gt; whose topmost level indicates the respective value column:</source>
          <target state="translated">상기 중간 &lt;code&gt;values&lt;/code&gt; 인수가 생략되고, 상기 입력 &lt;code&gt;DataFrame&lt;/code&gt; 는 에 컬럼 인덱스 입력으로 사용되지 않는 값 이상의 열 보유 &lt;code&gt;pivot&lt;/code&gt; 다음은 &quot;요동&quot;얻어진 &lt;code&gt;DataFrame&lt;/code&gt; 는 것이다 &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;계층 열&lt;/a&gt; 그 최상위 레벨의 각 값의 열을 나타냄을 :</target>
        </trans-unit>
        <trans-unit id="42ecf87fc244588bee56119972b559fcabe156fa" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.Series(range(2), index=pd.DatetimeIndex([ &amp;hellip; &amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 2015-03-29 03:00:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 2015-03-29 01:59:59.999999999+01:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 2015-03-29 03:30:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64</source>
          <target state="translated">DST 전환으로 인해 존재하지 않는 시간이 발생하면 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 객체 또는 'shift_forward' 또는 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 이러한 날짜를 앞뒤로 이동할 수 있습니다 . &amp;gt;&amp;gt;&amp;gt; s = pd.Series (range (2), index = pd.DatetimeIndex ([&amp;hellip; '2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00']) ) &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( '유럽 / 전세계', 존재하지 않는 = 'shift_forward') 2015-03-29 03 : 00 : 00 + 02 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( 'Europe / Warsaw', nonexistent = 'shift_backward') 2015-03-29 01 : 59 : 59.999999999 + 01 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( 'Europe / Warsaw', nonexistent = pd. Timedelta ( '1H')) 2015-03-29 03 : 30 : 00 + 02 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64</target>
        </trans-unit>
        <trans-unit id="1efef3e25f01393c1708b5d04424ad93e6acad6e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime(pd.Series([&amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 0 2015-03-29 03:00:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 0 2015-03-29 01:59:59.999999999+01:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 0 2015-03-29 03:30:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;]</source>
          <target state="translated">DST 전환으로 인해 존재하지 않는 시간이 발생하면 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 객체 또는 'shift_forward' 또는 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 이러한 날짜를 앞뒤로 이동할 수 있습니다 . &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime (pd.Series ([ '2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00'])) &amp;gt;&amp;gt;&amp;gt; s.dt. tz_localize ( 'Europe / Warsaw', nonexistent = 'shift_forward') 0 2015-03-29 03 : 00 : 00 + 02 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, 'Europe / Warsaw'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ( 'Europe / Warsaw', 존재하지 않음 = 'shift_backward') 0 2015-03-29 01 : 59 : 59.999999999 + 01 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, 'Europe / Warsaw'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ( 'Europe / Warsaw', nonexistent = pd.Timedelta ( '1H')) 0 2015-03- 29 03 : 30 : 00 + 02 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, '유럽 / 바르샤바']</target>
        </trans-unit>
        <trans-unit id="0cded44943bc29f11107a3fa48812fe3fd18029d" translate="yes" xml:space="preserve">
          <source>If the DataFrame index has no label then the recarray field name is set to &amp;lsquo;index&amp;rsquo;. If the index has a label then this is used as the field name:</source>
          <target state="translated">DataFrame 색인에 레이블이 없으면 recarray 필드 이름이 'index'로 설정됩니다. 색인에 레이블이 있으면 필드 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d214ff5505dcc3df58ad0b05017eb7e67d620183" translate="yes" xml:space="preserve">
          <source>If the Datetime Array/Index is tz-aware and tz is not None.</source>
          <target state="translated">Datetime Array / Index가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="b9d9791f0508f684363d699b80bee52d000f007a" translate="yes" xml:space="preserve">
          <source>If the Index is a MultiIndex, drop the value when any or all levels are NaN.</source>
          <target state="translated">색인이 다중 색인 인 경우, 일부 또는 모든 레벨이 NaN 인 경우 값을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="be05eaa0dbbfb873520e230604c6d5204e61826b" translate="yes" xml:space="preserve">
          <source>If the Index objects are incompatible, both Index objects will be cast to dtype(&amp;lsquo;object&amp;rsquo;) first.</source>
          <target state="translated">Index 객체가 호환되지 않으면 두 Index 객체 모두 먼저 dtype ( 'object')로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="6155bdd87909d66e388cdbb2e09aeed48e81654e" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined return &amp;lsquo;NaN&amp;rsquo;.</source>
          <target state="translated">Pearson 상관 관계가 제대로 정의되지 않은 경우 'NaN'을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef45e6ec64f5bd071dc24f8d1e69cc1e5cd8b83" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined, then &amp;lsquo;NaN&amp;rsquo; is returned.</source>
          <target state="translated">Pearson 상관 관계가 제대로 정의되지 않으면 'NaN'이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="93c56163ba997d495339f68cf9109d1071720ba6" translate="yes" xml:space="preserve">
          <source>If the Series is empty.</source>
          <target state="translated">시리즈가 비어있는 경우.</target>
        </trans-unit>
        <trans-unit id="a8f2ab2c508af24c8a42b9be04bbb0ee02647fda" translate="yes" xml:space="preserve">
          <source>If the Series is of dtype &lt;code&gt;CategoricalDtype&lt;/code&gt;, &lt;code&gt;Series.cat&lt;/code&gt; can be used to change the categorical data. See &lt;a href=&quot;series#api-series-cat&quot;&gt;Categorical accessor&lt;/a&gt; for more.</source>
          <target state="translated">Series가 dtype &lt;code&gt;CategoricalDtype&lt;/code&gt; 인 경우 &lt;code&gt;Series.cat&lt;/code&gt; 을 사용하여 범주 형 데이터를 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;series#api-series-cat&quot;&gt;범주 형 접근&lt;/a&gt; 자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c83fd268af8fe1a16e48c3a1ab2791b08629b1d" translate="yes" xml:space="preserve">
          <source>If the TimeSeries is tz-aware and tz is not None.</source>
          <target state="translated">TimeSeries가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="166773b46d18bb469c09bcac6b289439b56e7d14" translate="yes" xml:space="preserve">
          <source>If the Timestamp is tz-aware and tz is not None.</source>
          <target state="translated">타임 스탬프가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="31df692ed74865cf46655ed034fdaf4f052a8d85" translate="yes" xml:space="preserve">
          <source>If the axis is a &lt;code&gt;MultiIndex&lt;/code&gt; (hierarchical), count along a particular &lt;code&gt;level&lt;/code&gt;, collapsing into a &lt;code&gt;DataFrame&lt;/code&gt;. A &lt;code&gt;str&lt;/code&gt; specifies the level name.</source>
          <target state="translated">축이 &lt;code&gt;MultiIndex&lt;/code&gt; (계층 적) 인 경우 특정 &lt;code&gt;level&lt;/code&gt; 따라 계산 하여 &lt;code&gt;DataFrame&lt;/code&gt; 으로 축소합니다 . &lt;code&gt;str&lt;/code&gt; 수준 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cb176b6dcd2c00fd60079bc8af02e9483c7b2358" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 시리즈로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="769c2b618c37d94ee04a6ed2f86ca3697aa771ee" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 시리즈로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="5c874bca9b0f22f8a1cb6ace88f3bf9ba4eb54d3" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 스칼라로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="9cfa60e80d738cd1ce2e3e1ca125d513cb5b51b9" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 스칼라로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="acc1c61e1d22ff923e52dd41f329881f26c8cde0" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a smaller Series.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 작은 시리즈로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="67fb26f3d36635371a47ec0c1a6253a35906fe24" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), group by a particular level or levels.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준으로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5361e8b12cba57093a4bca7b1ba4eecbc07f527" translate="yes" xml:space="preserve">
          <source>If the axis is tz-naive.</source>
          <target state="translated">축이 tz-naive 인 경우.</target>
        </trans-unit>
        <trans-unit id="aeceb5d896fc9cb6f840f781402681ca9e0cca6b" translate="yes" xml:space="preserve">
          <source>If the caller is heterogeneous and contains booleans or objects, the result will be of dtype=object. See Notes.</source>
          <target state="translated">호출자가 이기종이고 부울 또는 오브젝트를 포함하는 경우 결과는 dtype = object입니다. 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78dfb04301d7d11f06e3b14acf5990d58d0a43a0" translate="yes" xml:space="preserve">
          <source>If the categories do not validate.</source>
          <target state="translated">카테고리가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="37b7a652ec11f0c6a680c6d296b342bf36963ce7" translate="yes" xml:space="preserve">
          <source>If the columns have a &lt;code&gt;MultiIndex&lt;/code&gt;, you can choose which level to stack. The stacked level becomes the new lowest level in a &lt;code&gt;MultiIndex&lt;/code&gt; on the columns:</source>
          <target state="translated">열에 &lt;code&gt;MultiIndex&lt;/code&gt; 가있는 경우 스택 할 수준을 선택할 수 있습니다. 누적 수준은 열의 &lt;code&gt;MultiIndex&lt;/code&gt; 에서 새로운 최저 수준이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6bab78d983e5853d00e346d9f3278a1b337046e" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines how the other levels are named. If None then the index name is repeated.</source>
          <target state="translated">열에 여러 수준이있는 경우 다른 수준의 이름을 지정하는 방법을 결정합니다. None이면 인덱스 이름이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="16f324de3f6d44a6d155ca6a0800716c76d8fdf8" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines which level the labels are inserted into. By default it is inserted into the first level.</source>
          <target state="translated">열에 여러 수준이있는 경우 레이블을 삽입 할 수준을 결정합니다. 기본적으로 첫 번째 레벨에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="2a8d59c818fd41f1886de03e2a0e8206d7189f0d" translate="yes" xml:space="preserve">
          <source>If the data are tz-aware, then every value in the array must have the same timezone.</source>
          <target state="translated">데이터가 TZ를 인식하는 경우 배열의 모든 값은 동일한 시간대를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="d39bced8875c9d4daed1623756606adbd29a4918" translate="yes" xml:space="preserve">
          <source>If the default template doesn&amp;rsquo;t quite suit your needs, you can subclass Styler and extend or override the template. We&amp;rsquo;ll show an example of extending the default template to insert a custom header before each table.</source>
          <target state="translated">기본 템플릿이 사용자 요구에 맞지 않으면 Styler를 서브 클래 싱하고 템플릿을 확장하거나 재정의 할 수 있습니다. 각 테이블 앞에 사용자 지정 헤더를 삽입하도록 기본 템플릿을 확장하는 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b474e8292463ff3d6dc397cb12f9e866f037fd93" translate="yes" xml:space="preserve">
          <source>If the elements of a Series are lists themselves, join the content of these lists using the delimiter passed to the function. This function is an equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Series의 요소 자체가 목록 인 경우 함수에 전달 된 구분 기호를 사용하여 이러한 목록의 컨텐츠를 결합하십시오. 이 함수는 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b5cd27d9aa0745a9023fb6c25cf1ae1d3bf731d3" translate="yes" xml:space="preserve">
          <source>If the exact type is not relevant, but must be compatible with a numpy array, array-like can be specified. If Any type that can be iterated is accepted, iterable can be used:</source>
          <target state="translated">정확한 유형이 관련이 없지만 numpy 배열과 호환되어야하는 경우 배열과 같이 지정할 수 있습니다. 반복 할 수있는 모든 유형이 승인되면 반복 가능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be5ff8f8c878d0a8afe3f068aed76c34baa9e8b2" translate="yes" xml:space="preserve">
          <source>If the expression contains an assignment, whether to perform the operation inplace and mutate the existing DataFrame. Otherwise, a new DataFrame is returned.</source>
          <target state="translated">식에 대입이 포함 된 경우 작업을 수행하고 기존 DataFrame을 변경하는지 여부입니다. 그렇지 않으면 새 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ff9c19369126c9e7394a827328229c91b340d6" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (&lt;code&gt;Q-MAR&lt;/code&gt;), the first quarter of 2018 will start in April 2017. &lt;code&gt;year&lt;/code&gt; will then be 2018, but &lt;code&gt;qyear&lt;/code&gt; will be the fiscal year, 2018.</source>
          <target state="translated">회계 연도가 4 월에 시작되면 ( &lt;code&gt;Q-MAR&lt;/code&gt; ) 2018 년 1 분기는 2017 &lt;code&gt;year&lt;/code&gt; 4 월에 시작합니다. 연도 는 2018이지만, &lt;code&gt;qyear&lt;/code&gt; 는 2018 회계 연도입니다.</target>
        </trans-unit>
        <trans-unit id="b59db1d7abf5d61294ac0431e0b446551a515714" translate="yes" xml:space="preserve">
          <source>If the frequency is higher than daily (e.g. monthly), the last day of the period is used.</source>
          <target state="translated">빈도가 매일 (예 : 월간)보다 높으면 기간의 마지막 날이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d726bbcf68dc737c3aca6d41e599a28b3f5d3ff8" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values, &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; may be specified as strings instead of Timestamps.</source>
          <target state="translated">잘리지 인덱스 만 날짜 값을 포함 할 경우 &lt;code&gt;before&lt;/code&gt; 및 &lt;code&gt;after&lt;/code&gt; 대신에 타임 스탬프 문자열로 지정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="26ab44fcadd1b6b21a6d87e3f94d723582cab96b" translate="yes" xml:space="preserve">
          <source>If the index consists of dates, it calls &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt;&lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt;&lt;/a&gt; to try to format the x-axis nicely as per above.</source>
          <target state="translated">인덱스가 날짜로 구성되어 있으면 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt; &lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 위와 같이 x 축을 멋지게 형식화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="62bf561852f13e8a7992a8390ffa6b918215b325" translate="yes" xml:space="preserve">
          <source>If the index has multiple levels, we can reset a subset of them:</source>
          <target state="translated">인덱스에 여러 수준이있는 경우 하위 집합을 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda1d90ab4aeda16d9fd7875489389b8cf6ae137" translate="yes" xml:space="preserve">
          <source>If the index is a MultiIndex, level(s) to set (None for all levels). Otherwise level must be None.</source>
          <target state="translated">인덱스가 다중 인덱스 인 경우 설정할 수준 (모든 수준에 대해 없음)입니다. 그렇지 않으면 레벨은 없음이어야합니다.</target>
        </trans-unit>
        <trans-unit id="067743019a50efb3de30de5e7db206d81efd2bfc" translate="yes" xml:space="preserve">
          <source>If the index is not a &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인덱스가 &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; &lt;/a&gt; 가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="1927dd8f9c19eb08ec5a860837248b90f251a58b" translate="yes" xml:space="preserve">
          <source>If the index is not a MultiIndex, the output will be a Series (the analogue of stack when the columns are not a MultiIndex).</source>
          <target state="translated">인덱스가 MultiIndex가 아닌 경우 출력은 Series (컬럼이 MultiIndex가 아닌 경우 스택의 아날로그)가됩니다.</target>
        </trans-unit>
        <trans-unit id="0474835e1da4e14d4e8fd21bedd592901f57b6d7" translate="yes" xml:space="preserve">
          <source>If the index is not sorted, an error is raised.</source>
          <target state="translated">인덱스가 정렬되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab6a27e99c67cc04b243466ae25a20129613f55a" translate="yes" xml:space="preserve">
          <source>If the key is past the lexsort depth, the return may be a boolean mask array, otherwise it is always a slice or int.</source>
          <target state="translated">키가 lexsort 심도를 지난 경우 반환 값은 부울 마스크 배열 일 수 있으며, 그렇지 않으면 항상 슬라이스 또는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="23363d65d1a6bf0f3c3353ab3f1570ee49ce97bd" translate="yes" xml:space="preserve">
          <source>If the label is in the index, the method returns the passed label.</source>
          <target state="translated">레이블이 색인에 있으면이 메소드는 전달 된 레이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="22dfc540b19512c01f76cdc319937a5edf13e1d7" translate="yes" xml:space="preserve">
          <source>If the mapping is not one-to-one an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; is returned:</source>
          <target state="translated">맵핑이 일대일이 아닌 경우 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f30e3b28f5a53e1916fb432f6e3f20ec400af36a" translate="yes" xml:space="preserve">
          <source>If the mapping is one-to-one the ordering of the categories is preserved:</source>
          <target state="translated">매핑이 일대일이면 범주의 순서가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="29594b7fad55aba80e626335052ebbda64589beb" translate="yes" xml:space="preserve">
          <source>If the method returns a value, it will be documented in this section. Also if the method yields its output.</source>
          <target state="translated">메소드가 값을 리턴하면이 섹션에 문서화됩니다. 또한 메소드가 출력을 생성하는 경우.</target>
        </trans-unit>
        <trans-unit id="1c7fa85a4950fc4db50e956b853116480dbe2810" translate="yes" xml:space="preserve">
          <source>If the method yields its value:</source>
          <target state="translated">메소드가 그 값을 산출하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2be314f975c703a2d0fb14d5a08ed837b5ac3d17" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same, &lt;code&gt;qyear&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; will be the same.</source>
          <target state="translated">자연과 회계 연도가 같은 경우, &lt;code&gt;qyear&lt;/code&gt; 와 &lt;code&gt;year&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c2d7883a841125b807eecd00b3c3af4f438f2ede" translate="yes" xml:space="preserve">
          <source>If the new categories do not contain all old category items or any new ones</source>
          <target state="translated">새 범주에 이전 범주 항목이 모두 포함되어 있지 않거나 새 범주가없는 경우</target>
        </trans-unit>
        <trans-unit id="b8ff9a9bc1a204944889d9f9ab64cff13098ce04" translate="yes" xml:space="preserve">
          <source>If the new categories do not validate as categories or if the number of new categories is unequal the number of old categories</source>
          <target state="translated">새 범주가 범주로 유효하지 않거나 새 범주의 수가 같지 않은 경우 이전 범주의 수</target>
        </trans-unit>
        <trans-unit id="e5bb30293ce2058c6ee007b1c0630a5f11c11af8" translate="yes" xml:space="preserve">
          <source>If the new categories include old categories or do not validate as categories</source>
          <target state="translated">새 카테고리에 이전 카테고리가 포함되거나 카테고리로 검증되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="dc97c541d898a4ba589bd072c2b06a7b9a9ba55c" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a Series.</source>
          <target state="translated">구문 분석 된 데이터에 열이 하나만 있으면 Series를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fce5176c2e9226fd8f8db2e0305dd4e81c28cba" translate="yes" xml:space="preserve">
          <source>If the pattern is found more than once in the same string, then a list of multiple strings is returned:</source>
          <target state="translated">동일한 문자열에서 패턴이 두 번 이상 발견되면 여러 문자열 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="862fb94e4f74981a38a343060cd76373e4ac1593" translate="yes" xml:space="preserve">
          <source>If the period frequency is lower than daily (e.g. hourly), and the period spans over multiple days, the day at the start of the period is used.</source>
          <target state="translated">기간 빈도가 매일 (예 : 시간별)보다 낮고 기간이 여러 날에 걸쳐 있으면 기간 시작 날짜가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24931cba16f8d7d23729af82afc7b5cf33a8ab54" translate="yes" xml:space="preserve">
          <source>If the removals are not contained in the categories</source>
          <target state="translated">제거가 카테고리에 포함되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="a91b79ba0a48641f561804353a8466ad061c6ff1" translate="yes" xml:space="preserve">
          <source>If the row/column is empty</source>
          <target state="translated">행 / 열이 비어있는 경우</target>
        </trans-unit>
        <trans-unit id="d2fbbcf4ba212002b0c61ef4fa072fb2a25199bd" translate="yes" xml:space="preserve">
          <source>If the supplied Series contains neither strings nor lists.</source>
          <target state="translated">제공된 시리즈에 문자열이나 목록이없는 경우.</target>
        </trans-unit>
        <trans-unit id="e0f175e63735de751d2d7b89f97ca4eea1b0abeb" translate="yes" xml:space="preserve">
          <source>If the test generates a warning of class &lt;code&gt;category&lt;/code&gt; whose message starts with &lt;code&gt;msg&lt;/code&gt;, the warning will be ignored and the test will pass.</source>
          <target state="translated">테스트에서 메시지가 &lt;code&gt;msg&lt;/code&gt; 로 시작하는 클래스 &lt;code&gt;category&lt;/code&gt; 의 경고를 생성하면 경고 가 무시되고 테스트가 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="14413eaf87552171ee2c64255914c3d985a6b0cb" translate="yes" xml:space="preserve">
          <source>If the timezone is not set, the resulting Series will have a datetime64[ns] dtype.</source>
          <target state="translated">시간대가 설정되지 않은 경우 결과 시리즈에는 datetime64 [ns] dtype이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f68536b5e696d5ad33c88c279512e394794e07" translate="yes" xml:space="preserve">
          <source>If the type is a pandas type, also specify pandas except for Series and DataFrame:</source>
          <target state="translated">유형이 팬더 유형 인 경우 Series 및 DataFrame을 제외하고 팬더도 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2c463cab0f756d454178e69be623cfa933046f80" translate="yes" xml:space="preserve">
          <source>If the type is defined in a Python module, the module must be specified:</source>
          <target state="translated">유형이 Python 모듈에 정의 된 경우 모듈을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa3ae3c0858082628b417918cb8ce07cd4ca5f45" translate="yes" xml:space="preserve">
          <source>If the type is in a package, the module must be also specified:</source>
          <target state="translated">유형이 패키지에있는 경우 모듈도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a03f05686c0d02f3139ecf76b3027fa808e62cc" translate="yes" xml:space="preserve">
          <source>If the user is aware of the duplicates in the right &lt;code&gt;DataFrame&lt;/code&gt; but wants to ensure there are no duplicates in the left DataFrame, one can use the &lt;code&gt;validate='one_to_many'&lt;/code&gt; argument instead, which will not raise an exception.</source>
          <target state="translated">사용자가 오른쪽 &lt;code&gt;DataFrame&lt;/code&gt; 의 중복을 알고 있지만 왼쪽 DataFrame에 중복이 없는지 확인하려는 경우 &lt;code&gt;validate='one_to_many'&lt;/code&gt; 인수를 대신 사용할 수 있으며 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46f25d66dfb27cdf7e82e3397b599f84e8bbd166" translate="yes" xml:space="preserve">
          <source>If there are merge conflicts, you need to solve those conflicts. See for example at &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; for an explanation on how to do this. Once the conflicts are merged and the files where the conflicts were solved are added, you can run &lt;code&gt;git commit&lt;/code&gt; to save those fixes.</source>
          <target state="translated">병합 충돌이있는 경우 해당 충돌을 해결해야합니다. 이를 수행하는 방법에 대한 설명 은 &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; 을 참조하십시오 . 충돌이 병합되고 충돌이 해결 된 파일이 추가되면 &lt;code&gt;git commit&lt;/code&gt; 을 실행 하여 해당 수정 사항을 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f267a36da468b5ae5ceb8cafd473d483c3fe55df" translate="yes" xml:space="preserve">
          <source>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</source>
          <target state="translated">충돌이없는 경우 (또는 자동으로 수정 될 수있는 경우) 기본 커밋 메시지가있는 파일이 열리므로이 파일을 저장하고 종료하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f642e67158a066fd10cb787b665aedb36dbf5c3d" translate="yes" xml:space="preserve">
          <source>If there are people interested in continued support for Python 2.7 past December 31, 2018 (either backporting bug fixes or funding) please reach out to the maintainers on the issue tracker.</source>
          <target state="translated">2018 년 12 월 31 일 이후 Python 2.7에 대한 지속적인 지원 (백 포트 버그 수정 또는 자금 지원)에 관심이있는 사람이있는 경우 이슈 트래커의 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="df8b99601c3ccae4df1dcef1c8a935236cdb7582" translate="yes" xml:space="preserve">
          <source>If there is a small part of the result that can vary (e.g. a hash in an object representation), you can use &lt;code&gt;...&lt;/code&gt; to represent this part.</source>
          <target state="translated">결과의 일부가 다를 수있는 경우 (예 : 객체 표현의 해시), &lt;code&gt;...&lt;/code&gt; 을 사용 하여이 부분을 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79166ffe4f486692983ad25c9bb5a734e08993de" translate="yes" xml:space="preserve">
          <source>If there is no good value, NaN is returned for a Series or a Series of NaN values for a DataFrame</source>
          <target state="translated">적절한 값이 없으면 DataFrame에 대한 Series 또는 Series의 NaN 값에 대해 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4e4a825180bf8808a64195ae6d697226e17fa3" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like</source>
          <target state="translated">이 매개 변수가 False이면 세트는 목록과 같은 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cde86769fd29b3bc205b6c427ec8870bad01f3ff" translate="yes" xml:space="preserve">
          <source>If true, ALL nan rows will not be written to store.</source>
          <target state="translated">true 인 경우 모든 nan 행은 저장하도록 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3282649a37ac55c74db8a5a1b1a27ca8c630f36d" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks</source>
          <target state="translated">true 인 경우 열이 xticks로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a761e46b1b0da1fd384002ba5d9bdd4de4efda77" translate="yes" xml:space="preserve">
          <source>If true, resulting categories will be lexsorted, otherwise they will be ordered as they appear in the data.</source>
          <target state="translated">true 인 경우 결과 카테고리가 어휘 분류되며 그렇지 않으면 데이터에 표시되는대로 순서가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fcaa7b2fe91e543e75e6441530fd4b5d810bb7f" translate="yes" xml:space="preserve">
          <source>If true, the ordered attribute of the Categoricals will be ignored. Results in an unordered categorical.</source>
          <target state="translated">true 인 경우 범주의 정렬 된 속성이 무시됩니다. 순서가없는 범주 형이됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fe920431a3d41d651dfbcc77af70b504aee8c8" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick</source>
          <target state="translated">true 인 경우 각 xtick에 세로선이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ce59a050f48126ce6320c30610faaa9c86fc199e" translate="yes" xml:space="preserve">
          <source>If two CategoricalIndex objects have equal elements True, otherwise False.</source>
          <target state="translated">두 CategoricalIndex 객체에 동일한 요소가 True이면 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="d639547142f390403b221695989f0de239dbb7b1" translate="yes" xml:space="preserve">
          <source>If two Index objects have equal elements and same type True, otherwise False.</source>
          <target state="translated">두 개의 Index 객체에 동일한 요소와 동일한 유형의 True가 있으면 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="626c6821778795ed6605d4fcfb4d554d4bb3ee62" translate="yes" xml:space="preserve">
          <source>If unnamed &lt;code&gt;Series&lt;/code&gt; are passed they will be numbered consecutively.</source>
          <target state="translated">명명되지 않은 &lt;code&gt;Series&lt;/code&gt; 가 전달되면 연속적으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="952e2dee711cdb4ef88782a2cd0578a6a6843049" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;expand=True&lt;/code&gt;, Series and Index callers return DataFrame and MultiIndex objects, respectively.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;expand=True&lt;/code&gt; , 시리즈 및 색인 발신자가 DataFrame 및 MultiIndex 각각 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1cf23a69f82311296b7504255332812bccf16b4" translate="yes" xml:space="preserve">
          <source>If using in the Jupyter notebook, Styler has defined a &lt;code&gt;_repr_html_&lt;/code&gt; to automatically render itself. Otherwise call Styler.render to get the generated HTML.</source>
          <target state="translated">Jupyter 노트북에서 사용하는 경우 Styler는 자동으로 렌더링 &lt;code&gt;_repr_html_&lt;/code&gt; 을 정의했습니다 . 그렇지 않으면 Styler.render를 호출하여 생성 된 HTML을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="302e92543f3f0f75ce924bc7f9f8aa88c440b3a5" translate="yes" xml:space="preserve">
          <source>If warn=True, issue a warning if nanoseconds is nonzero.</source>
          <target state="translated">warn = True 인 경우 나노초가 0이 아닌 경우 경고를 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="260f17759a03e9b11140d2b1e686eb99c682c39b" translate="yes" xml:space="preserve">
          <source>If we also have a MultiIndex on columns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, we can group by all but the specified columns</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 열에 MultiIndex가있는 경우 지정된 열을 제외한 모든 열을 기준으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82061eba4d9b00cf01b3ade310c01171b0a5cc2f" translate="yes" xml:space="preserve">
          <source>If we are not dropping the index, by default, it is placed in the top level. We can place it in another level:</source>
          <target state="translated">인덱스를 삭제하지 않으면 기본적으로 최상위 레벨에 배치됩니다. 다른 레벨에 배치 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b79fd67d25657db5cfcdb0ceff92c9e8f9633182" translate="yes" xml:space="preserve">
          <source>If we have many columns, we could also use a regex to find our stubnames and pass that list on to wide_to_long</source>
          <target state="translated">열이 많은 경우 정규식을 사용하여 스텁 이름을 찾아 해당 목록을 wide_to_long에 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3059eebcb64938e4b7a073e1ffb4bda57975fc0" translate="yes" xml:space="preserve">
          <source>If we only have NaNs in our DataFrame, it is not considered empty! We will need to drop the NaNs to make the DataFrame empty:</source>
          <target state="translated">DataFrame에 NaN 만있는 경우 비어있는 것으로 간주되지 않습니다! DataFrame을 비우려면 NaN을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7bb5bb11f2ff2055c13b48cfec8d32f8a45a2e2" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for &lt;code&gt;col_fill&lt;/code&gt;, it is created:</source>
          <target state="translated">&lt;code&gt;col_fill&lt;/code&gt; 에 존재하지 않는 레벨을 지정하면 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ebde3340d88dc78a7515ebac165ad4cba048950" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. The joined DataFrame will have key as its index.</source>
          <target state="translated">키 열을 사용하여 조인하려면 key를 &lt;code&gt;df&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 모두의 인덱스로 설정해야합니다 . 결합 된 DataFrame은 인덱스로 키를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3f5b50b561b3e7aa33c127ffbfebf0a7133f79a8" translate="yes" xml:space="preserve">
          <source>If you added the upstream repository as described above you will see something like:</source>
          <target state="translated">위에서 설명한대로 업스트림 저장소를 추가 한 경우 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a901823fe7ea06c8a1cd9a222f4bb095acb15157" translate="yes" xml:space="preserve">
          <source>If you are brand new to pandas or open-source development, we recommend going through the &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;GitHub &amp;ldquo;issues&amp;rdquo; tab&lt;/a&gt; to find issues that interest you. There are a number of issues listed under &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;Docs&lt;/a&gt; and &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;good first issue&lt;/a&gt; where you could start out. Once you&amp;rsquo;ve found an interesting issue, you can return here to get your development environment setup.</source>
          <target state="translated">팬더 또는 오픈 소스 개발에 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;익숙하지 않은&lt;/a&gt; 경우 GitHub&amp;ldquo;문제&amp;rdquo;탭 을 통해 관심있는 문제를 찾으십시오. 아래에 나열된 문제가 있습니다 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;문서 도구&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;좋은 첫 번째 문제&lt;/a&gt; 당신이 밖으로 시작할 수 있습니다. 흥미로운 문제가 발견되면 여기로 돌아와 개발 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="104adf5a4c3ea5cc99dad3c496195368e599955a" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using conda for your development environment, follow these instructions. You&amp;rsquo;ll need to have at least python3.5 installed on your system.</source>
          <target state="translated">개발 환경에 conda를 사용하지 않는 경우 다음 지침을 따르십시오. 시스템에 python3.5 이상이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5a95ce05a5137b543597ab970b813363417ec7" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">이 위에 훌륭한 라이브러리를 구축하면 알려 주시면 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;링크&lt;/a&gt; 해 드리겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a6d12092a100fe501656091bdf566b30b2ed9abe" translate="yes" xml:space="preserve">
          <source>If you have a code snippet that wraps multiple lines, you need to use &amp;lsquo;&amp;hellip;&amp;rsquo; on the continued lines:</source>
          <target state="translated">여러 줄을 감싸는 코드 스 니펫이 있으면 계속 줄에 '&amp;hellip;'를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce1c3f4a8b1303b2233ce9f8b61542133b12817a" translate="yes" xml:space="preserve">
          <source>If you have a function that takes the data as (say) the second argument, pass a tuple indicating which keyword expects the data. For example, suppose &lt;code&gt;f&lt;/code&gt; takes its data as &lt;code&gt;arg2&lt;/code&gt;:</source>
          <target state="translated">데이터를 두 번째 인수로 사용하는 함수가 있으면 데이터를 기대하는 키워드를 나타내는 튜플을 전달하십시오. 예를 들어, 가정하자 &lt;code&gt;f&lt;/code&gt; 로 데이터를 얻어 &lt;code&gt;arg2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4bce04d77a3695fe541ba97dbace1da91706c1a3" translate="yes" xml:space="preserve">
          <source>If you have a test that would emit a warning, but you aren&amp;rsquo;t actually testing the warning itself (say because it&amp;rsquo;s going to be removed in the future, or because we&amp;rsquo;re matching a 3rd-party library&amp;rsquo;s behavior), then use &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; to ignore the error.</source>
          <target state="translated">경고를 발생시키는 테스트가 있지만 실제로 경고 자체를 테스트하지 않는 경우 (예 : 향후 제거 될 예정이거나 타사 라이브러리의 동작과 일치하기 때문에) &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; 를 사용 하십시오. .mark.filterwarnings 는 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1e53b0f81dd0d27916b9567f3537fac3de69986c" translate="yes" xml:space="preserve">
          <source>If you have created a new file, it is not being tracked by git. Add it by typing:</source>
          <target state="translated">새 파일을 만든 경우 git에서 파일을 추적하지 않습니다. 다음을 입력하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="88a4ccdcf75e8833f91575d8840de48cc6dfbca8" translate="yes" xml:space="preserve">
          <source>If you have multi-index columns:</source>
          <target state="translated">다중 색인 열이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="5ad80e0520119e0bea6b4d13398628db73a1bdcc" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes at the moment you want to update the branch with master, you will need to &lt;code&gt;stash&lt;/code&gt; them prior to updating (see the &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt;). This will effectively store your changes and they can be reapplied after updating.</source>
          <target state="translated">master로 분기를 업데이트하려는 시점에 커밋되지 않은 변경 사항이있는 경우 업데이트 하기 전에 변경 사항을 &lt;code&gt;stash&lt;/code&gt; 합니다 ( &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt; 참조 ). 변경 사항이 효과적으로 저장되며 업데이트 후에 다시 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1285b10e07e025b0f5ded4a959a18da26d5f6127" translate="yes" xml:space="preserve">
          <source>If you need finer-grained control, you can use Python&amp;rsquo;s usual &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;warnings module&lt;/a&gt; to control whether a warning is ignored / raised at different places within a single test.</source>
          <target state="translated">보다 세밀한 제어가 필요한 경우 Python의 일반 &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;경고 모듈&lt;/a&gt; 을 사용 하여 단일 테스트 내의 다른 위치에서 경고를 무시 / 발생 시킬지 여부를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9abdfc1c00b5fd40564a95fa7255b69eb7054961" translate="yes" xml:space="preserve">
          <source>If you need packages that are available to pip but not conda, then install pip, and then use pip to install those packages:</source>
          <target state="translated">pip에는 사용할 수 있지만 conda에는없는 패키지가 필요한 경우 pip를 설치 한 다음 pip를 사용하여 해당 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a6464b5756b83cd90f8547c8b9746a2e4119403d" translate="yes" xml:space="preserve">
          <source>If you need to run a benchmark, change your directory to &lt;code&gt;asv_bench/&lt;/code&gt; and run:</source>
          <target state="translated">벤치 마크를 실행해야하는 경우 디렉토리를 &lt;code&gt;asv_bench/&lt;/code&gt; 변경 하고 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="632406b5aa18fdb674faf69296473f0d12e452b9" translate="yes" xml:space="preserve">
          <source>If you see output like the below in &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; checks:</source>
          <target state="translated">&lt;a href=&quot;#contributing-ci&quot;&gt;연속 통합&lt;/a&gt; 검사 에서 다음과 같은 출력이 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="30ed4c27edf0b54fe936d124ccd9179b9a98665c" translate="yes" xml:space="preserve">
          <source>If you want a &lt;code&gt;defaultdict&lt;/code&gt;, you need to initialize it:</source>
          <target state="translated">&lt;code&gt;defaultdict&lt;/code&gt; 를 원하면 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6b94aa79bc7cda927f9dd9bef83486c02c863c7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;em&gt;색인&lt;/em&gt; 을 원하면 &lt;code&gt;idxmax&lt;/code&gt; 를 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmax&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9b950797521b756aeaf591d6f6cec56c5160f174" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">최소 &lt;em&gt;인덱스&lt;/em&gt; 를 원하면 &lt;code&gt;idxmin&lt;/code&gt; 을 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmin&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="90ceed891230ae542e55ffbac52ad427e321e79a" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, &lt;code&gt;union_categoricals&lt;/code&gt; will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">동일한 범주를 가질 필요가없는 범주를 결합하려는 경우 &lt;code&gt;union_categoricals&lt;/code&gt; 는 목록과 같은 범주를 결합합니다. 새로운 범주는 결합되는 범주의 합집합이됩니다.</target>
        </trans-unit>
        <trans-unit id="cb077c2288f1403c4b0ecbd42403a54af7be64aa" translate="yes" xml:space="preserve">
          <source>If you want to consider &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; to be &amp;ldquo;NA&amp;rdquo; in computations, you can set &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt;.</source>
          <target state="translated">계산에서 &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 를 &quot;NA&quot; 로 간주하려는 경우 &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a494419aff90e75a65fca5fcb99703bd1e43872" translate="yes" xml:space="preserve">
          <source>If you want to do a full clean build, do:</source>
          <target state="translated">완전히 깨끗하게 빌드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2ca2aaf5871712e332fd47e4529e86f2d40fbf9d" translate="yes" xml:space="preserve">
          <source>If you want to have more control on which packages, or have a limited internet bandwidth, then installing pandas with &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; may be a better solution.</source>
          <target state="translated">어떤 패키지를 더 많이 제어하거나 인터넷 대역폭이 제한적인 경우 &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda로&lt;/a&gt; 팬더를 설치 하는 것이 더 나은 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f39c7a5a2ebd376e45bc4789c9e32d770747fa47" translate="yes" xml:space="preserve">
          <source>If you want to only run a specific group of tests from a file, you can do it using &lt;code&gt;.&lt;/code&gt; as a separator. For example:</source>
          <target state="translated">파일에서 특정 그룹의 테스트 만 실행하려면을 사용하여 수행 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 분리기로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="431c2f4b44553a66b404402f29529cfcdabf6d56" translate="yes" xml:space="preserve">
          <source>If you want to pass in a path object, pandas accepts any &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">경로 객체를 전달하려는 경우 pandas는 &lt;code&gt;os.PathLike&lt;/code&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="8e69cf53c2f90f63fca612ceaf55108d6a7645de" translate="yes" xml:space="preserve">
          <source>If you want to show a case where an exception is raised, you can do:</source>
          <target state="translated">예외가 발생한 경우를 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3444f60978a55340c6fd4266fe2afeb502624670" translate="yes" xml:space="preserve">
          <source>If you want to show that &lt;code&gt;s.plot()&lt;/code&gt; returns a matplotlib AxesSubplot object, this will fail the doctest</source>
          <target state="translated">&lt;code&gt;s.plot()&lt;/code&gt; 이 matplotlib AxesSubplot 객체를 반환 한다는 것을 보여 주려면 doctest가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a6fca580ca146fe1287a019a063eff316214cd98" translate="yes" xml:space="preserve">
          <source>If you wish to specify other levels (as will occasionally be the case), you can do so using the &lt;code&gt;levels&lt;/code&gt; argument:</source>
          <target state="translated">경우에 따라 다른 수준을 지정하려면 &lt;code&gt;levels&lt;/code&gt; 인수를 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5357656a53a0ea6cda290cc82e0cca1c51833255" translate="yes" xml:space="preserve">
          <source>If you wish to write to more than one sheet in the workbook, it is necessary to specify an ExcelWriter object:</source>
          <target state="translated">통합 문서에서 둘 이상의 시트에 쓰려면 ExcelWriter 개체를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="603667115b7f0addd355740b600caf5f30806f25" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a library that implements the interface, please publicize it on &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension data types&lt;/a&gt;.</source>
          <target state="translated">인터페이스를 구현하는 라이브러리를 구축하는 경우 &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension 데이터 유형&lt;/a&gt; 에 공개하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab47c63b2d6927d1db8e796a8720b53461c8e93d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge ipython for paste to play well with cell magics.</source>
          <target state="translated">위의 내용을 ipython에 붙여 넣는 데 문제가있는 경우 셀 마법과 잘 어울리려면 붙여 넣기 가장자리 ipython을 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8179681b12d1079bcde2bda507f3523470acc9a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in contributing, please visit the &lt;a href=&quot;../development/contributing#contributing&quot;&gt;contributing guide&lt;/a&gt;.</source>
          <target state="translated">기고에 관심이있는 경우 &lt;a href=&quot;../development/contributing#contributing&quot;&gt;기고 가이드&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="954e9c7dcd852245711eafdd97aac0e41254af2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to pandas, you might want to first read through &lt;a href=&quot;../10min#min&quot;&gt;10 Minutes to pandas&lt;/a&gt; to familiarize yourself with the library.</source>
          <target state="translated">팬더를 처음 사용하는 경우 먼저 &lt;a href=&quot;../10min#min&quot;&gt;팬더&lt;/a&gt; 에게 10 분을 읽어서 라이브러리에 익숙해지는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cf4479cf67c908330f3502d0976c6b8c094f6f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here&amp;rsquo;s a subset of the attributes that will be completed:</source>
          <target state="translated">IPython을 사용하는 경우 열 이름 (공용 속성)에 대한 탭 완성이 자동으로 활성화됩니다. 완료 될 속성의 하위 집합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea10e2f23c35ab01a19875e0da269fdf0c5585fe" translate="yes" xml:space="preserve">
          <source>If your change involves checking that a warning is actually emitted, use &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt;.</source>
          <target state="translated">변경 사항에 실제로 경고가 표시 &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt; 확인하는 경우 tm.assert_produces_warning (ExpectedWarning)을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55c057d9cb3f679f9d738d6ec8fbd7a104357a59" translate="yes" xml:space="preserve">
          <source>If your code is an enhancement, it is most likely necessary to add usage examples to the existing documentation. This can be done following the section regarding documentation &lt;a href=&quot;#contributing-documentation&quot;&gt;above&lt;/a&gt;. Further, to let users know when this feature was added, the &lt;code&gt;versionadded&lt;/code&gt; directive is used. The sphinx syntax for that is:</source>
          <target state="translated">코드가 개선 된 경우 기존 문서에 사용 예제를 추가해야합니다. 이 작업은 &lt;a href=&quot;#contributing-documentation&quot;&gt;위의&lt;/a&gt; 문서 관련 섹션에 따라 수행 할 수 있습니다 . 또한이 기능이 추가 된시기를 사용자에게 알리기 위해 &lt;code&gt;versionadded&lt;/code&gt; 지시문이 사용됩니다. 스핑크스 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17297cf285c7c41a2305959b1d4993f6c38dfb8b" translate="yes" xml:space="preserve">
          <source>If your data does not follow this convention, please use the normal constructor.</source>
          <target state="translated">데이터가이 규칙을 따르지 않으면 일반 생성자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98cbab20b6fb2abfa92fdc4fc1f66575059d0c3b" translate="yes" xml:space="preserve">
          <source>If your style function uses a &lt;code&gt;subset&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; keyword argument, consider wrapping your function in a &lt;code&gt;functools.partial&lt;/code&gt;, partialing out that keyword.</source>
          <target state="translated">스타일 함수가 &lt;code&gt;subset&lt;/code&gt; 또는 &lt;code&gt;axis&lt;/code&gt; 키워드 인수를 사용하는 경우 해당 키워드를 &lt;code&gt;functools.partial&lt;/code&gt; 감싸는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0577eb9b0205a991abdc93cdc5c980e96a949c1e" translate="yes" xml:space="preserve">
          <source>If/then logic</source>
          <target state="translated">논리</target>
        </trans-unit>
        <trans-unit id="537a32d1d7729f25747f50cd67c683b5fa307d78" translate="yes" xml:space="preserve">
          <source>Ignore NaN values when inferring the type.</source>
          <target state="translated">유형을 유추 할 때 NaN 값을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0a84d018aa4bed7f09ba656bc9b54ababd117230" translate="yes" xml:space="preserve">
          <source>Ignore differing dtypes in columns with check_dtype.</source>
          <target state="translated">check_dtype이있는 열에서 다른 dtype을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="2705a7c2d2d0fbc6c769f7fda4a47ca8dc459762" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify True to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">가중치를 계산할 때 결 측값을 무시하십시오. 0.15.0 이전의 동작을 재현하려면 True를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9ea19abc80c5f9b9a3d69ac6d138608e64b4eae7" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using &lt;code&gt;flags&lt;/code&gt; with regex.</source>
          <target state="translated">정규식에 &lt;code&gt;flags&lt;/code&gt; 를 사용하여 대소 문자 구분을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="15a016f34e155f11682e304c096f6e7fed15242d" translate="yes" xml:space="preserve">
          <source>Ignoring indexes on the concatenation axis</source>
          <target state="translated">연결 축에서 인덱스 무시</target>
        </trans-unit>
        <trans-unit id="c48163e8e369cc932393aa060be7a71ab51f15db" translate="yes" xml:space="preserve">
          <source>Immutable Index for period data.</source>
          <target state="translated">기간 데이터에 대한 불변 색인.</target>
        </trans-unit>
        <trans-unit id="fa675f0928ac3d188978d143601cfaef0581eebe" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing a monotonic integer range.</source>
          <target state="translated">단조 정수 범위를 구현하는 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="77bb5b08e773dcc647c2137be13943f11993af3a" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing an ordered, sliceable set.</source>
          <target state="translated">정렬 가능하고 슬라이스 가능한 순서를 구현하는 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="09666a0d15aa17eade5da13deaf4058fff5e91c0" translate="yes" xml:space="preserve">
          <source>Immutable index of intervals that are closed on the same side.</source>
          <target state="translated">같은 쪽에서 닫힌 간격의 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="322432105222ac065c39c51c46ac7e62258f855b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time such as particular years, quarters, months, etc.</source>
          <target state="translated">특정 연도, 분기, 월 등과 같은 일정한 시간을 나타내는 서수 값을 보유하는 불변의 ndarray</target>
        </trans-unit>
        <trans-unit id="95ddec45685f37191edce0f9c049167f337a12e2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values.</source>
          <target state="translated">서수 값을 보유하는 불변의 ndarray.</target>
        </trans-unit>
        <trans-unit id="ff5fce9b61c2b7d306def659869f8a2d0e740987" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray.</target>
        </trans-unit>
        <trans-unit id="632aea5fb4e51ab537ce029dad7185968ea1903b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a1d7735d372421181df84b4198539d11f0bd5288" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Float64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely float labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. Float64Index는 순수 부동 레이블 이있는 &lt;code&gt;Index&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="a63505fab2255dbaad9e67cc969dee30b7999644" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Int64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely integer labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. Int64Index는 순수한 정수 레이블을 가진 특별한 &lt;code&gt;Index&lt;/code&gt; 케이스입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a7d783a146ccf2aebd945545d5c4801e5a2997" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely unsigned integer labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. UInt64Index는 순수하게 부호없는 정수 레이블 이있는 특별한 &lt;code&gt;Index&lt;/code&gt; 케이스입니다 .</target>
        </trans-unit>
        <trans-unit id="3f9f35d14ce44451d11a45398cd4e7e33b22d52e" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of datetime64 data, represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata such as frequency information.</source>
          <target state="translated">내부적으로 int64로 표시되며 날짜 시간의 서브 클래스 인 타임 스탬프 객체에 상자에 넣을 수 있고 빈도 정보와 같은 메타 데이터를 전달할 수있는 datetime64 데이터의 변경 불가능한 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="a0c7ddd23ba079b38767357bd06b67a58ed2ef16" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects</source>
          <target state="translated">내부적으로 int64로 표시되고 timedelta 객체에 박스로 표시 될 수있는 timedelta64 데이터의 불변 ndarray</target>
        </trans-unit>
        <trans-unit id="5d4d9fb600d19bd44b1d23393cd235ddaf172e07" translate="yes" xml:space="preserve">
          <source>Immutable object implementing an Interval, a bounded slice-like interval.</source>
          <target state="translated">경계 슬라이스 유사 간격 인 Interval을 구현하는 불변 객체.</target>
        </trans-unit>
        <trans-unit id="31b7603ab9e328ac9ecd3a57b22b14f6ba634622" translate="yes" xml:space="preserve">
          <source>Implement the sparse version of the DataFrame meaning that any data matching a specific value it&amp;rsquo;s omitted in the representation. The sparse DataFrame allows for a more efficient storage.</source>
          <target state="translated">DataFrame의 희소 버전을 구현하여 특정 값과 일치하는 데이터가 표현에서 생략됨을 의미합니다. 스파 스 DataFrame을 사용하면보다 효율적인 스토리지가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c6745b96941850a92b0edba7a6c22b838293d405" translate="yes" xml:space="preserve">
          <source>Import Stata data files.</source>
          <target state="translated">Stata 데이터 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1e5491997dd74b680ce524f97d0882e687569640" translate="yes" xml:space="preserve">
          <source>Import all needed libraries (except for pandas and numpy, those are already imported as &lt;code&gt;import pandas as pd&lt;/code&gt; and &lt;code&gt;import numpy as np&lt;/code&gt;) and define all variables you use in the example.</source>
          <target state="translated">필요한 모든 라이브러리를 &lt;code&gt;import pandas as pd&lt;/code&gt; (pandas 및 numpy 제외) 이미 팬더를 pd 로 &lt;code&gt;import numpy as np&lt;/code&gt; 로 가져옴 ) 예제에서 사용하는 모든 변수를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d23dd8370347a27e8c15358e5d3021400237aac7" translate="yes" xml:space="preserve">
          <source>Import formatting</source>
          <target state="translated">가져 오기 형식</target>
        </trans-unit>
        <trans-unit id="72cab777e486bd355797f7e6fdade33e9f41fd52" translate="yes" xml:space="preserve">
          <source>Import required libraries (except &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;pandas&lt;/code&gt;)</source>
          <target state="translated">필요한 라이브러리 가져 오기 ( &lt;code&gt;numpy&lt;/code&gt; 및 &lt;code&gt;pandas&lt;/code&gt; 제외 )</target>
        </trans-unit>
        <trans-unit id="8caa460d7e776f14562e9da5c4c08d479a40d0c1" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; for the same input, &amp;lsquo;1&amp;rsquo;.</source>
          <target state="translated">것을 통지에 중요 &lt;code&gt;df2&lt;/code&gt; 모두 포함됩니다 &lt;code&gt;str&lt;/code&gt; 과 &lt;code&gt;int&lt;/code&gt; 동일한 입력, '1'을 위해.</target>
        </trans-unit>
        <trans-unit id="e4595506130e2cf8db40b1b6430ef7e36fa5cf73" translate="yes" xml:space="preserve">
          <source>Imports are alphabetically sorted within these sections.</source>
          <target state="translated">가져 오기는이 섹션 내에서 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8982a4b2f79ddf31cda90fa02617abd56244f09b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;missing_data#missing-data&quot;&gt;Working with missing data&lt;/a&gt;, we saw that pandas primarily uses &lt;code&gt;NaN&lt;/code&gt; to represent missing data. Because &lt;code&gt;NaN&lt;/code&gt; is a float, this forces an array of integers with any missing values to become floating point. In some cases, this may not matter much. But if your integer column is, say, an identifier, casting to float can be problematic. Some integers cannot even be represented as floating point numbers.</source>
          <target state="translated">에서 &lt;a href=&quot;missing_data#missing-data&quot;&gt;누락 된 데이터 작업&lt;/a&gt; , 우리는 팬더가 주로 사용하는 것을보고 &lt;code&gt;NaN&lt;/code&gt; 이를 누락 된 데이터를 나타냅니다. &lt;code&gt;NaN&lt;/code&gt; 은 부동 소수점 이므로 결 측값이있는 정수 배열이 부동 소수점이되도록합니다. 경우에 따라 별 문제가되지 않을 수도 있습니다. 그러나 정수 열이 식별자 인 경우 float로 캐스팅하면 문제가 될 수 있습니다. 일부 정수는 부동 소수점 숫자로 표현할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbe401f5c64aba5b5ac112f3a745ea229c800ebf" translate="yes" xml:space="preserve">
          <source>In Python 2 replacing the &lt;code&gt;range&lt;/code&gt; with its generator counterpart (&lt;code&gt;xrange&lt;/code&gt;) would mean the &lt;code&gt;range&lt;/code&gt; line would vanish. In Python 3 &lt;code&gt;range&lt;/code&gt; is already a generator.</source>
          <target state="translated">파이썬 2에서 &lt;code&gt;range&lt;/code&gt; 를 생성기 대응 물 ( &lt;code&gt;xrange&lt;/code&gt; )로 바꾸면 &lt;code&gt;range&lt;/code&gt; 줄이 사라질 것입니다. 파이썬 3에서 &lt;code&gt;range&lt;/code&gt; 는 이미 발전기입니다.</target>
        </trans-unit>
        <trans-unit id="da0a8b268dc3a515b0c25d7910a12354f6dbce4d" translate="yes" xml:space="preserve">
          <source>In Python 3.6+, you can create multiple columns within the same assign where one of the columns depends on another one defined within the same assign:</source>
          <target state="translated">Python 3.6 이상에서는 동일한 할당 내에 여러 열을 만들 수 있습니다. 여기서 열 중 하나는 동일한 할당 내에 정의 된 다른 열에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="01750648f39249d22ad4fc3c3a3a8334f0b9fee0" translate="yes" xml:space="preserve">
          <source>In SAS, if/then logic can be used to create new columns.</source>
          <target state="translated">SAS에서는 if / then 논리를 사용하여 새 열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca39c6fc3d7d80268fd46f392c1dc4b249e34950" translate="yes" xml:space="preserve">
          <source>In SQL, selection is done using a comma-separated list of columns you&amp;rsquo;d like to select (or a &lt;code&gt;*&lt;/code&gt; to select all columns):</source>
          <target state="translated">SQL에서는 선택하려는 쉼표로 구분 된 열 목록 (또는 &lt;code&gt;*&lt;/code&gt; 를 선택 하여 *) 을 사용하여 선택합니다.</target>
        </trans-unit>
        <trans-unit id="dc2683c2af6d69c783f5e1c2c60c2fb95add6385" translate="yes" xml:space="preserve">
          <source>In Stata, an &lt;code&gt;if&lt;/code&gt; clause can also be used to create new columns.</source>
          <target state="translated">Stata에서는 &lt;code&gt;if&lt;/code&gt; 절을 사용하여 새 열을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fca911336b8e64fe53b3d338ac822c1038ec5cd" translate="yes" xml:space="preserve">
          <source>In Stata, arbitrary math expressions can be used with the &lt;code&gt;generate&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; commands on new or existing columns. The &lt;code&gt;drop&lt;/code&gt; command drops the column from the data set.</source>
          <target state="translated">Stata에서는 임의의 수학 표현식 을 새 열 또는 기존 열의 &lt;code&gt;generate&lt;/code&gt; 및 &lt;code&gt;replace&lt;/code&gt; 명령 과 함께 사용할 수 있습니다 . &lt;code&gt;drop&lt;/code&gt; 명령은 데이터 세트에서 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="88d11d83548d7a8bd3e2260ac358ac93abc83c24" translate="yes" xml:space="preserve">
          <source>In addition to text/csv and Stata files, pandas supports a variety of other data formats such as Excel, SAS, HDF5, Parquet, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">text / csv 및 Stata 파일 외에도 Pandas는 Excel, SAS, HDF5, Parquet 및 SQL 데이터베이스와 같은 다양한 기타 데이터 형식을 지원합니다. 이것들은 모두 &lt;code&gt;pd.read_*&lt;/code&gt; 함수 를 통해 읽습니다 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b35d4c53f87e1ec5baecbdbc6b0b27f79f9dad9" translate="yes" xml:space="preserve">
          <source>In addition to text/csv, pandas supports a variety of other data formats such as Excel, HDF5, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">text / csv 외에도 pandas는 Excel, HDF5 및 SQL 데이터베이스와 같은 다양한 기타 데이터 형식을 지원합니다. 이것들은 모두 &lt;code&gt;pd.read_*&lt;/code&gt; 함수 를 통해 읽습니다 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f194ff577d3246f42a365dc02ca65f2f46a8b57" translate="yes" xml:space="preserve">
          <source>In addition to the top level &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; function you can also evaluate an expression in the &amp;ldquo;context&amp;rdquo; of a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상위 레벨에 추가 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 함수를 당신은 또한의 &quot;환경&quot;의 표현 평가할 수 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="344220efeaea8bac8f88606648dc5f32ff74a82e" translate="yes" xml:space="preserve">
          <source>In addition to these &lt;code&gt;kind&lt;/code&gt; s, there are the &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist()&lt;/a&gt;, and &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot()&lt;/a&gt; methods, which use a separate interface.</source>
          <target state="translated">이 외에도 &lt;code&gt;kind&lt;/code&gt; 의 상기있다 &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist ()&lt;/a&gt; 및 &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot ()&lt;/a&gt; 별도의 인터페이스를 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="461cd1c60765166195c8d8ff831032d5cc889866" translate="yes" xml:space="preserve">
          <source>In addition, because a lot of people use our library, it is important that we do not make sudden changes to the code that could have the potential to break a lot of user code as a result, that is, we need it to be as &lt;em&gt;backwards compatible&lt;/em&gt; as possible to avoid mass breakages.</source>
          <target state="translated">또한 많은 사람들이 라이브러리를 사용하기 때문에 결과적으로 많은 사용자 코드를 손상시킬 수있는 코드를 갑자기 변경하지 않는 것이 중요합니다. 대량 파손을 피하기 위해 가능한 &lt;em&gt;역 호환성&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec024bfe3b45af422e3ecb72973bb611c9bf681" translate="yes" xml:space="preserve">
          <source>In addition, downcasting will only occur if the size of the resulting data&amp;rsquo;s dtype is strictly larger than the dtype it is to be cast to, so if none of the dtypes checked satisfy that specification, no downcasting will be performed on the data.</source>
          <target state="translated">또한 다운 캐스팅은 결과 데이터의 dtype 크기가 캐스트 할 dtype보다 엄격하게 큰 경우에만 발생하므로 확인 된 dtype이 해당 사양을 충족하지 않으면 데이터에 대한 다운 캐스팅이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28dd64e14727048112de8dad7d43482313ba396c" translate="yes" xml:space="preserve">
          <source>In addition, you can perform assignment of columns within an expression. This allows for &lt;em&gt;formulaic evaluation&lt;/em&gt;. The assignment target can be a new column name or an existing column name, and it must be a valid Python identifier.</source>
          <target state="translated">또한 식 내에서 열을 할당 할 수 있습니다. 이것은 &lt;em&gt;공식적인 평가를&lt;/em&gt; 허용합니다 . 할당 대상은 새 열 이름이거나 기존 열 이름 일 수 있으며 유효한 Python 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cd532ff8699d514dc2c1ce70655231461c01cdd0" translate="yes" xml:space="preserve">
          <source>In case of a MultiIndex, only rename labels in the specified level.</source>
          <target state="translated">다중 인덱스의 경우 지정된 수준의 레이블 만 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="82d44e95df31ef34cd50671cd671f7030bd91cea" translate="yes" xml:space="preserve">
          <source>In case of a key partially contained in a MultiIndex, indicate which levels are used. Levels can be referred by label or position.</source>
          <target state="translated">다중 색인에 부분적으로 포함 된 키의 경우 어떤 레벨이 사용되는지 표시하십시오. 레벨은 레이블 또는 위치로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1052f0d8e2c2e12c931a4c0074d4560c46bfb585" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the height of the terminal and print a truncated object which fits the screen height. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 60] [currently: 15]display.max_seq_items : int or None when pretty-printing a long sequence, no more then &lt;code&gt;max_seq_items&lt;/code&gt; will be printed. If items are omitted, they will be denoted by the addition of &amp;ldquo;&amp;hellip;&amp;rdquo; to the resulting string.</source>
          <target state="translated">python / IPython이 터미널에서 실행 중이고 &lt;code&gt;large_repr&lt;/code&gt; 이 'truncate'와 같으면 이것을 0으로 설정할 수 있으며 팬더는 터미널 높이를 자동 감지하고 화면 높이에 맞는 잘린 객체를 인쇄합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 올바른 자동 감지를 수행 할 수 없습니다. [default : 60] [현재 : 15] display.max_seq_items : int 또는 None 긴 시퀀스를 예쁘게 인쇄 할 경우 &lt;code&gt;max_seq_items&lt;/code&gt; 가 더 이상 인쇄되지 않습니다 . 항목을 생략하면 결과 문자열에 &quot;&amp;hellip;&quot;가 추가되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88dc0ceb9b4e5ade156f2fb19973b762c584b547" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the width of the terminal and print a truncated object which fits the screen width. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 0] [currently: 0]display.max_colwidth : int The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. [default: 50] [currently: 50]display.max_info_columns : int max_info_columns is used in DataFrame.info method to decide if per column information will be printed. [default: 100] [currently: 100]display.max_info_rows : int or None df.info() will usually show null-counts for each column. For large frames this can be quite slow. max_info_rows and max_info_cols limit this null check only to frames with smaller dimensions than specified. [default: 1690785] [currently: 1690785]display.max_rows : int If max_rows is exceeded, switch to truncate view. Depending on &lt;code&gt;large_repr&lt;/code&gt;, objects are either centrally truncated or printed as a summary view. &amp;lsquo;None&amp;rsquo; value means unlimited.</source>
          <target state="translated">python / IPython이 터미널에서 실행되고 &lt;code&gt;large_repr&lt;/code&gt; 인 경우'잘림'과 같음이 값은 0으로 설정 될 수 있으며 팬더는 터미널 너비를 자동 감지하고 화면 너비에 맞는 잘린 객체를 인쇄합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 올바른 자동 감지를 수행 할 수 없습니다. [default : 0] [현재 : 0] display.max_colwidth : int 팬더 데이터 구조의 repr에서 열의 최대 문자 수를 나타냅니다. 열이 오버플로되면 &quot;&amp;hellip;&quot;자리 표시자가 출력에 포함됩니다. [default : 50] [현재 : 50] display.max_info_columns : int max_info_columns는 DataFrame.info 메서드에서 열별 정보를 인쇄할지 여부를 결정하는 데 사용됩니다. [default : 100] [현재 : 100] display.max_info_rows : int 또는 None df.info ()는 일반적으로 각 열의 null 수를 표시합니다. 큰 프레임의 경우 상당히 느릴 수 있습니다.max_info_rows 및 max_info_cols는이 널 검사를 지정된 크기보다 작은 크기의 프레임으로 만 제한합니다. [default : 1690785] [현재 : 1690785] display.max_rows : int max_rows를 초과하면 잘림보기로 전환하십시오. 에 따라 &lt;code&gt;large_repr&lt;/code&gt; 이면 객체가 중앙에서 잘 리거나 요약보기로 인쇄됩니다. '없음'값은 무제한을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e35d288cb0c579433cc89556209e4bed46e672a" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in. Note that passing in both an ax and sharex=True will alter all x axis labels for all subplots in a figure.</source>
          <target state="translated">subplots = True 인 경우 x 축을 공유하고 일부 x 축 레이블을 보이지 않게 설정하십시오. ax가 None이면 기본값은 True입니다. 그렇지 않으면 ax가 전달되면 False입니다. ax와 sharex = True를 모두 전달하면 그림의 모든 하위 그림에 대한 모든 x 축 레이블이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="13d4a95cd38f900c3ec733f1670b49419dc85c00" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">subplots = True 인 경우 y 축을 공유하고 일부 y 축 레이블을 보이지 않게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cde29dc4b9128386ba4e2d708cd826477c4917e9" translate="yes" xml:space="preserve">
          <source>In case when it is not possible to return designated types (e.g. when any element of input is before Timestamp.min or after Timestamp.max) return will have datetime.datetime type (or corresponding array/Series).</source>
          <target state="translated">지정된 유형을 리턴 할 수없는 경우 (예 : 입력 요소가 Timestamp.min 이전 또는 Timestamp.max 이후 인 경우) 리턴에는 datetime.datetime 유형 (또는 해당 배열 / 시리즈)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d98b509261df46a77d5170a3ea614953001361f" translate="yes" xml:space="preserve">
          <source>In case where there are just a set of values allowed, list them in curly brackets and separated by commas (followed by a space). If the values are ordinal and they have an order, list them in this order. Otherwise, list the default value first, if there is one:</source>
          <target state="translated">허용되는 값 집합이있는 경우 중괄호로 묶고 쉼표로 구분합니다 (공백). 값이 순서적이고 순서가 있으면이 순서대로 나열하십시오. 그렇지 않은 경우 기본값이 있으면 먼저 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="3faa60af9b3f807fffd055e96cd73d0da7d66524" translate="yes" xml:space="preserve">
          <source>In cases where the default value is &lt;code&gt;None&lt;/code&gt;, meaning that the value will not be used. Instead of &amp;ldquo;str, default None&amp;rdquo;, it is preferred to write &amp;ldquo;str, optional&amp;rdquo;. When &lt;code&gt;None&lt;/code&gt; is a value being used, we will keep the form &amp;ldquo;str, default None&amp;rdquo;. For example, in &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is not a value being used, but means that compression is optional, and no compression is being used if not provided. In this case we will use &lt;code&gt;str, optional&lt;/code&gt;. Only in cases like &lt;code&gt;func(value=None)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; is being used in the same way as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; would be used, then we will specify &amp;ldquo;str, int or None, default None&amp;rdquo;.</source>
          <target state="translated">기본값이 &lt;code&gt;None&lt;/code&gt; 인 경우 값이 사용 되지 않음 을 의미합니다. &quot;str, default None&quot;대신 &quot;str, optional&quot;을 쓰는 것이 좋습니다. 때 &lt;code&gt;None&lt;/code&gt; 사용되는 값입니다, 우리는 형태 &quot;STR, 기본 없음&quot;을 유지합니다. 예를 들어 &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt; 에서 &lt;code&gt;None&lt;/code&gt; 은 사용중인 값이 아니지만 압축은 선택 사항이며 제공되지 않은 경우 압축이 사용되지 않음을 의미합니다. 이 경우 &lt;code&gt;str, optional&lt;/code&gt; 합니다. 단지 같은 경우에 &lt;code&gt;func(value=None)&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 과 같은 방법으로 사용되는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;foo&lt;/code&gt; 는이 우리가 &quot;STR, INT 또는 없음, 기본 없음&quot;을 지정합니다 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="171fdac7381916cc04649667798a64026a33e0ff" translate="yes" xml:space="preserve">
          <source>In contrast to statistical categorical variables, categorical data might have an order (e.g. &amp;lsquo;strongly agree&amp;rsquo; vs &amp;lsquo;agree&amp;rsquo; or &amp;lsquo;first observation&amp;rsquo; vs. &amp;lsquo;second observation&amp;rsquo;), but numerical operations (additions, divisions, &amp;hellip;) are not possible.</source>
          <target state="translated">통계적 범주 형 변수와 달리 범주 형 데이터는 순서가있을 수 있지만 (예 : '강하게 동의'vs '동의'또는 '첫 번째 관찰'대 '두 번째 관찰') 수치 연산 (추가, 나눗셈 등)은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="f9f73b63ad75a78f67b079f95c8d6f90b73e6e7d" translate="yes" xml:space="preserve">
          <source>In most cases &amp;lsquo;block&amp;rsquo; is recommended, since it&amp;rsquo;s more memory efficient.</source>
          <target state="translated">대부분의 경우 메모리 효율이 높기 때문에 'block'이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="8336ab4b3b13dbcf220d99ce0876af633024c8e4" translate="yes" xml:space="preserve">
          <source>In most cases, there should be no functional difference from using &lt;code&gt;deep&lt;/code&gt;, but if &lt;code&gt;deep&lt;/code&gt; is passed it will attempt to deepcopy.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;deep&lt;/code&gt; 을 사용하는 것과 기능상의 차이가 없어야 하지만 &lt;code&gt;deep&lt;/code&gt; 이 전달 되면 deepcopy를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="e7236bf78d95a69537f8d46ae9cbc58792f758fb" translate="yes" xml:space="preserve">
          <source>In most cases, this should return a NumPy ndarray. For exceptional cases like &lt;code&gt;SparseArray&lt;/code&gt;, where returning an ndarray would be expensive, an ExtensionArray may be returned.</source>
          <target state="translated">대부분의 경우 NumPy ndarray를 반환해야합니다. 같은 예외적 인 경우를 들어 &lt;code&gt;SparseArray&lt;/code&gt; ndarray를 반환하는 것은 비싼 것, ExtensionArray가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="232fa83c2f577f58ba8577c3e595c730f748ca9b" translate="yes" xml:space="preserve">
          <source>In order to add another DataFrame or Series to an existing HDF file please use append mode and a different a key.</source>
          <target state="translated">기존 HDF 파일에 다른 DataFrame 또는 Series를 추가하려면 추가 모드와 다른 키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b94d9410b50138773dd5dd1be3cf191c15835cf7" translate="yes" xml:space="preserve">
          <source>In pandas there are a few objects implemented which can serve as valid containers for the axis labels:</source>
          <target state="translated">팬더에는 축 레이블의 유효한 컨테이너 역할을 할 수있는 몇 가지 객체가 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="208f80104ac64839558570440d5448887e455fb3" translate="yes" xml:space="preserve">
          <source>In pandas, if no index is specified, an integer index is also used by default (first row = 0, second row = 1, and so on). While using a labeled &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;MultiIndex&lt;/code&gt; can enable sophisticated analyses and is ultimately an important part of pandas to understand, for this comparison we will essentially ignore the &lt;code&gt;Index&lt;/code&gt; and just treat the &lt;code&gt;DataFrame&lt;/code&gt; as a collection of columns. Please see the &lt;a href=&quot;../../user_guide/indexing#indexing&quot;&gt;indexing documentation&lt;/a&gt; for much more on how to use an &lt;code&gt;Index&lt;/code&gt; effectively.</source>
          <target state="translated">팬더에서 인덱스를 지정하지 않으면 기본적으로 정수 인덱스도 사용됩니다 (첫 번째 행 = 0, 두 번째 행 = 1 등). 레이블이있는 &lt;code&gt;Index&lt;/code&gt; 또는 &lt;code&gt;MultiIndex&lt;/code&gt; 를 사용하면 정교한 분석이 가능하고 궁극적으로 팬더가 이해하는 데 중요한 부분이지만,이 비교를 위해 우리는 기본적으로 &lt;code&gt;Index&lt;/code&gt; 를 무시 하고 &lt;code&gt;DataFrame&lt;/code&gt; 을 열 컬렉션으로 취급합니다 . &lt;code&gt;Index&lt;/code&gt; 효과적으로 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;../../user_guide/indexing#indexing&quot;&gt;색인 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edb6b540969823ae01a77803b2362941a5666f2e" translate="yes" xml:space="preserve">
          <source>In particular, this allows users to define functions that take a styler object, along with other parameters, and return the styler after making styling changes (such as calling &lt;a href=&quot;pandas.io.formats.style.styler.apply#pandas.io.formats.style.Styler.apply&quot;&gt;&lt;code&gt;Styler.apply()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pandas.io.formats.style.styler.set_properties#pandas.io.formats.style.Styler.set_properties&quot;&gt;&lt;code&gt;Styler.set_properties()&lt;/code&gt;&lt;/a&gt;). Using &lt;code&gt;.pipe&lt;/code&gt;, these user-defined style &amp;ldquo;transformations&amp;rdquo; can be interleaved with calls to the built-in Styler interface.</source>
          <target state="translated">특히,이를 통해 사용자는 다른 매개 변수와 함께 스타일러 객체를 사용하고 스타일을 변경 한 후 (예 : &lt;a href=&quot;pandas.io.formats.style.styler.apply#pandas.io.formats.style.Styler.apply&quot;&gt; &lt;code&gt;Styler.apply()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pandas.io.formats.style.styler.set_properties#pandas.io.formats.style.Styler.set_properties&quot;&gt; &lt;code&gt;Styler.set_properties()&lt;/code&gt; &lt;/a&gt; 호출 ) 스타일러를 반환하는 함수를 정의 할 수 있습니다 . &lt;code&gt;.pipe&lt;/code&gt; 를 사용하면 이러한 사용자 정의 스타일 &quot;변환&quot;을 내장 스타일러 인터페이스에 대한 호출과 함께 인터리브 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aef9cc62198b3171fb1e517275a75345d3d9d0b" translate="yes" xml:space="preserve">
          <source>In rare occasions reST styles like bold text or italics will be used in docstrings, but is it common to have inline code, which is presented between backticks. It is considered inline code:</source>
          <target state="translated">드문 경우지만 굵은 텍스트 나 이탤릭체와 같은 reST 스타일이 docstring에 사용되지만 인라인 코드를 사용하는 것이 일반적이며 백틱 사이에 표시됩니다. 인라인 코드로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f193164f8ff830f495338165002ed0df364bcce" translate="yes" xml:space="preserve">
          <source>In some cases, inferring the DST is impossible. In such cases, you can pass an ndarray to the ambiguous parameter to set the DST explicitly</source>
          <target state="translated">어떤 경우에는 DST를 유추하는 것이 불가능합니다. 이러한 경우 NST를 모호한 매개 변수에 전달하여 DST를 명시 적으로 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0b41f8a671dcb59bac9331a53cb4c0003fd8ac2d" translate="yes" xml:space="preserve">
          <source>In statistics, &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;kernel density estimation&lt;/a&gt; (KDE) is a non-parametric way to estimate the probability density function (PDF) of a random variable. This function uses Gaussian kernels and includes automatic bandwidth determination.</source>
          <target state="translated">통계에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;커널 밀도 추정&lt;/a&gt; (KDE)은 랜덤 변수의 확률 밀도 함수 (PDF)를 추정하는 비모수 적 방법입니다. 이 기능은 가우스 커널을 사용하며 자동 대역폭 결정을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="259e03c33747a655ccf113b4924898904644dca6" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#r26d0aea2a9b7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency).</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#r26d0aea2a9b7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때).</target>
        </trans-unit>
        <trans-unit id="d0491d129e4f29db5d2c69ef3a8023377ee66007" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#r3ead377f0eb9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The backward fill will replace NaN values that appeared in the resampled data with the next value in the original sequence. Missing values that existed in the original data will not be modified.</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#r3ead377f0eb9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때). 뒤로 채우기는 재 샘플링 된 데이터에 나타난 NaN 값을 원래 순서의 다음 값으로 바꿉니다. 원래 데이터에 존재했던 결 측값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="365ec27a333aa600790256c375c2a9d1f665b634" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#rbbbeff54acb7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The backward fill will replace NaN values that appeared in the resampled data with the next value in the original sequence. Missing values that existed in the original data will not be modified.</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#rbbbeff54acb7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때). 뒤로 채우기는 재 샘플링 된 데이터에 나타난 NaN 값을 원래 순서의 다음 값으로 바꿉니다. 원래 데이터에 존재했던 결 측값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f180f96592c966e9d354895961cc77b54f367f90" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;DATA&lt;/code&gt; step, arbitrary math expressions can be used on new or existing columns.</source>
          <target state="translated">에서 &lt;code&gt;DATA&lt;/code&gt; 단계, 임의 연산 표현식은 신규 또는 기존 열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b145dc931b9b0873d88038293a88e6162dbf31" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;DataFrame&lt;/code&gt;, the indexes must be disjoint but the columns do not need to be:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 경우 인덱스는 분리되어야하지만 열은 다음과 같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="76a837351c5dbce74c7205b080161bdf34badf75" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;MultiIndex&lt;/code&gt; you must either specify &lt;code&gt;values&lt;/code&gt; as a list-like object containing tuples that are the same length as the number of levels, or specify &lt;code&gt;level&lt;/code&gt;. Otherwise it will raise a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">의 경우 &lt;code&gt;MultiIndex&lt;/code&gt; 당신이 중 하나를 지정해야합니다 &lt;code&gt;values&lt;/code&gt; 레벨의 수와 같은 길이 있습니다 목록과 같은 오브젝트가 포함 튜플로, 또는 지정 &lt;code&gt;level&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f42e5a7b12d256c55fa2906b61eb1a41a8c27f43" translate="yes" xml:space="preserve">
          <source>In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93c3a3c7e5f7f8c6cc129267a8f0244664f6c030" translate="yes" xml:space="preserve">
          <source>In the current implementation apply calls &lt;code&gt;func&lt;/code&gt; twice on the first column/row to decide whether it can take a fast or slow code path. This can lead to unexpected behavior if &lt;code&gt;func&lt;/code&gt; has side-effects, as they will take effect twice for the first column/row.</source>
          <target state="translated">현재 구현 에서는 첫 번째 열 / 행에서 &lt;code&gt;func&lt;/code&gt; 를 두 번 적용 하여 코드 경로가 빠르거나 느린 지 여부를 결정합니다. &lt;code&gt;func&lt;/code&gt; 에 부작용이있는 경우 첫 번째 열 / 행에 대해 두 번 적용되므로 예기치 않은 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb59999cec8f71616204455442b4171be5f75280" translate="yes" xml:space="preserve">
          <source>In the current implementation applymap calls &lt;code&gt;func&lt;/code&gt; twice on the first column/row to decide whether it can take a fast or slow code path. This can lead to unexpected behavior if &lt;code&gt;func&lt;/code&gt; has side-effects, as they will take effect twice for the first column/row.</source>
          <target state="translated">현재 구현에서 applymap 은 첫 번째 열 / 행에서 &lt;code&gt;func&lt;/code&gt; 를 두 번 호출 하여 빠른 또는 느린 코드 경로를 사용할 수 있는지 여부를 결정합니다. &lt;code&gt;func&lt;/code&gt; 에 부작용이있는 경우 첫 번째 열 / 행에 대해 두 번 적용되므로 예기치 않은 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e51e88b817ad3bcafc0c9fc36ef12166900cc138" translate="yes" xml:space="preserve">
          <source>In the default setting, the string is split by whitespace.</source>
          <target state="translated">기본 설정에서 문자열은 공백으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="4d5874c08a93fe7637eb607b79d1f52f99c5603f" translate="yes" xml:space="preserve">
          <source>In the event that there aren&amp;rsquo;t overlapping indexes an empty DataFrame will be returned.</source>
          <target state="translated">겹치는 인덱스가없는 경우 빈 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6053812ef83ad3af3bf5390b7deb7bf927dbe97a" translate="yes" xml:space="preserve">
          <source>In the example below we have a DataFrame with the information about planet&amp;rsquo;s mass and radius. We pass the the &amp;lsquo;mass&amp;rsquo; column to the pie function to get a pie plot.</source>
          <target state="translated">아래 예제에는 행성의 질량과 반경에 대한 정보가있는 DataFrame이 있습니다. 파이 질량을 얻기 위해 '질량'열을 파이 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="bebe01532250910835b2b2fabdcc554f6b7127b8" translate="yes" xml:space="preserve">
          <source>In the following example, there are duplicate values of &lt;code&gt;B&lt;/code&gt; in the right &lt;code&gt;DataFrame&lt;/code&gt;. As this is not a one-to-one merge &amp;ndash; as specified in the &lt;code&gt;validate&lt;/code&gt; argument &amp;ndash; an exception will be raised.</source>
          <target state="translated">다음 예제에서는 오른쪽 &lt;code&gt;DataFrame&lt;/code&gt; 에 중복 된 &lt;code&gt;B&lt;/code&gt; 값이 있습니다. &lt;code&gt;validate&lt;/code&gt; 인수에 지정된 일대일 병합이 아니기 때문에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18c78f24c44017f391c8bd0a0453e4110abf6899" translate="yes" xml:space="preserve">
          <source>In the following example, we will use &lt;code&gt;nlargest&lt;/code&gt; to select the three rows having the largest values in column &amp;ldquo;population&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;nlargest&lt;/code&gt; 를 사용 하여&amp;ldquo;population&amp;rdquo;열에서 가장 큰 값을 가진 3 개의 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3aa4c18ddfff7abd52cefa162c779546126fccb6" translate="yes" xml:space="preserve">
          <source>In the following example, we will use &lt;code&gt;nsmallest&lt;/code&gt; to select the three rows having the smallest values in column &amp;ldquo;a&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;nsmallest&lt;/code&gt; 를 사용 하여&amp;ldquo;a&amp;rdquo;열에서 가장 작은 값을 가진 3 개의 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a8d37ff91777bc82ff2a7c2702d2ea571e879266" translate="yes" xml:space="preserve">
          <source>In the previous example, the resulting value for duck is missing, because the maximum of a NaN and a float is a NaN. So, in the example, we set &lt;code&gt;fill_value=0&lt;/code&gt;, so the maximum value returned will be the value from some dataset.</source>
          <target state="translated">이전 예제에서 NaN 및 부동 소수점 최대 값이 NaN이므로 duck의 결과 값이 누락되었습니다. 따라서이 예에서는 &lt;code&gt;fill_value=0&lt;/code&gt; 을 설정 하므로 반환되는 최대 값은 일부 데이터 세트의 값입니다.</target>
        </trans-unit>
        <trans-unit id="afe33c5f4d23d2808699d27c791aaa9952e2622a" translate="yes" xml:space="preserve">
          <source>In this case the input is a &lt;code&gt;Series&lt;/code&gt;, one column at a time. Notice that the output shape of &lt;code&gt;highlight_max&lt;/code&gt; matches the input shape, an array with &lt;code&gt;len(s)&lt;/code&gt; items.</source>
          <target state="translated">이 경우 입력은 한 번에 하나의 열인 &lt;code&gt;Series&lt;/code&gt; 입니다. &lt;code&gt;highlight_max&lt;/code&gt; 의 출력 모양은 &lt;code&gt;len(s)&lt;/code&gt; 항목이 있는 배열 인 입력 모양과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3aef7feee0929f190d963f63e0387a5d7d3d15b6" translate="yes" xml:space="preserve">
          <source>In this case, the cell&amp;rsquo;s style depends only on it&amp;rsquo;s own value. That means we should use the &lt;code&gt;Styler.applymap&lt;/code&gt; method which works elementwise.</source>
          <target state="translated">이 경우 셀 스타일은 자체 값에만 의존합니다. 즉, 요소별로 작동 하는 &lt;code&gt;Styler.applymap&lt;/code&gt; 메소드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02ff908c94702a05c583a3f40f7d9e3bed0dd0c0" translate="yes" xml:space="preserve">
          <source>In this example, using Numba was faster than Cython.</source>
          <target state="translated">이 예에서 Numba를 사용하는 것이 Cython보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b3da24a14dac99c2ce666c7fcf23f280f2f0a9bd" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll create a parent docstring normally (this is like &lt;code&gt;pandas.core.generic.NDFrame&lt;/code&gt;. Then we&amp;rsquo;ll have two children (like &lt;code&gt;pandas.core.series.Series&lt;/code&gt; and &lt;code&gt;pandas.core.frame.DataFrame&lt;/code&gt;). We&amp;rsquo;ll substitute the children&amp;rsquo;s class names in this docstring.</source>
          <target state="translated">이 예제에서, 우리는이처럼 (일반적으로 문서화 문자열 부모를 만듭니다 &lt;code&gt;pandas.core.generic.NDFrame&lt;/code&gt; . 그리고 우리가 같은 두 아이 (해야 &lt;code&gt;pandas.core.series.Series&lt;/code&gt; 및 &lt;code&gt;pandas.core.frame.DataFrame&lt;/code&gt; 을 ). 이 docstring에서 어린이 클래스 이름을 대체 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="72373ffd4fe7734ddc860b3c260bb5bc238b113d" translate="yes" xml:space="preserve">
          <source>In this part of the tutorial, we will investigate how to speed up certain functions operating on pandas &lt;code&gt;DataFrames&lt;/code&gt; using three different techniques: Cython, Numba and &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt;. We will see a speed improvement of ~200 when we use Cython and Numba on a test function operating row-wise on the &lt;code&gt;DataFrame&lt;/code&gt;. Using &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; we will speed up a sum by an order of ~2.</source>
          <target state="translated">튜토리얼의이 부분에서는 Cython, Numba 및 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 세 가지 기술을 사용하여 팬더 &lt;code&gt;DataFrames&lt;/code&gt; 작동하는 특정 함수의 속도를 높이는 방법을 조사합니다 . &lt;code&gt;DataFrame&lt;/code&gt; 에서 행 단위로 작동하는 테스트 함수에서 Cython 및 Numba를 사용하면 속도가 ~ 200으로 향상됩니다 . &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 을 사용하면 ~ 2의 순서로 합을 가속화합니다.</target>
        </trans-unit>
        <trans-unit id="9bf63141c08371784983bff76853f338b3b741d6" translate="yes" xml:space="preserve">
          <source>In this section, we will discuss missing (also referred to as NA) values in pandas.</source>
          <target state="translated">이 섹션에서는 팬더에서 누락 된 (NA라고도 함) 값에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="73225e5cff6b5571285560e386bca15e86dff2c4" translate="yes" xml:space="preserve">
          <source>In this section, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas objects. The primary focus will be on Series and DataFrame as they have received more development attention in this area.</source>
          <target state="translated">이 섹션에서는 최종 요점, 즉 팬더 객체의 하위 집합을 슬라이스, 주사위로 만들고 일반적으로 가져오고 설정하는 방법에 중점을 둘 것입니다. 이 영역에서 더 많은 개발 관심을 받았기 때문에 Series와 DataFrame에 중점을 둘 것입니다.</target>
        </trans-unit>
        <trans-unit id="e76aae5e31e8e88b73aff1a30b64467dd9d3ff24" translate="yes" xml:space="preserve">
          <source>In this section, we will show what exactly we mean by &amp;ldquo;hierarchical&amp;rdquo; indexing and how it integrates with all of the pandas indexing functionality described above and in prior sections. Later, when discussing &lt;a href=&quot;groupby#groupby&quot;&gt;group by&lt;/a&gt; and &lt;a href=&quot;reshaping#reshaping&quot;&gt;pivoting and reshaping data&lt;/a&gt;, we&amp;rsquo;ll show non-trivial applications to illustrate how it aids in structuring data for analysis.</source>
          <target state="translated">이 섹션에서는 &quot;계층 적&quot;인덱싱이 정확히 무엇을 의미하는지와 위에서 설명한 이전 판과 모든 팬더 인덱싱 기능과 어떻게 통합되는지 보여줍니다. 논의 할 때 이후 &lt;a href=&quot;groupby#groupby&quot;&gt;로 그룹&lt;/a&gt; 및 &lt;a href=&quot;reshaping#reshaping&quot;&gt;데이터를 피벗 및 재편&lt;/a&gt; , 우리는 분석을 위해 구조화 데이터를 보조하는 방법을 설명하기 위해 적지 않은 응용 프로그램을 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="b30b00491d28032f2327d689459c13f6ce6da19e" translate="yes" xml:space="preserve">
          <source>In your library code:</source>
          <target state="translated">도서관 코드에서 :</target>
        </trans-unit>
        <trans-unit id="db347a62c1cb84befcabc203e401873d7bf60b05" translate="yes" xml:space="preserve">
          <source>Include a short, self-contained Python snippet reproducing the problem. You can format the code nicely by using &lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;GitHub Flavored Markdown&lt;/a&gt;:</source>
          <target state="translated">문제를 재현하는 짧고 독립적 인 Python 스 니펫을 포함시킵니다. &lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;GitHub Flavored Markdown&lt;/a&gt; 을 사용하여 코드를 멋지게 포맷 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b691f63704db590222c5a5a428645689bef5660" translate="yes" xml:space="preserve">
          <source>Include boundaries.</source>
          <target state="translated">경계를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="31a6ee06df15416ef3720c1aa78c55050baa48f0" translate="yes" xml:space="preserve">
          <source>Include index in resulting record array, stored in &amp;lsquo;index&amp;rsquo; field or using the index label, if set.</source>
          <target state="translated">'인덱스'필드에 저장되거나 설정된 경우 인덱스 레이블을 사용하여 결과 레코드 배열에 인덱스를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce7b2669a3c04046d4fe20cebca986183f8d25ac" translate="yes" xml:space="preserve">
          <source>Include only &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;boolean&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;boolean&lt;/code&gt; 데이터 만 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ec733e2bb248ecf061bdc5fc52a0929cda839cd" translate="yes" xml:space="preserve">
          <source>Include only boolean columns. If None, will attempt to use everything, then use only boolean data. Not implemented for Series.</source>
          <target state="translated">부울 열만 포함하십시오. None이면 모든 것을 사용하려고 시도하고 부울 데이터 만 사용합니다. 시리즈에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5b12a929622185e9bb288fead08323d30697638a" translate="yes" xml:space="preserve">
          <source>Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Not implemented for Series.</source>
          <target state="translated">float, int, boolean 열만 포함하십시오. None이면 모든 것을 사용하려고 시도하고 숫자 데이터 만 사용합니다. 시리즈에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ff085c898322da90e160c2330dcbbead8b3b2174" translate="yes" xml:space="preserve">
          <source>Include the full version string of &lt;em&gt;pandas&lt;/em&gt; and its dependencies. You can use the built-in function:</source>
          <target state="translated">&lt;em&gt;판다&lt;/em&gt; 의 풀 버전 문자열 과 그 의존성을 포함하십시오. 내장 기능을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ff01bc684733280abdc6a33c3e1f0a40ff87a068" translate="yes" xml:space="preserve">
          <source>Including only categorical columns from a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명의 범주 열만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="6b121e08046c26a73fd33f3a182f76a2ff41c033" translate="yes" xml:space="preserve">
          <source>Including only numeric columns in a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명 에 숫자 열만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3d6a3ced182d9ff7c047d6e408a1ae0d73dfdb24" translate="yes" xml:space="preserve">
          <source>Including only string columns in a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명 에 문자열 열만 포함</target>
        </trans-unit>
        <trans-unit id="13b5fc6793c568e32ad19498d5f921c75fa49a73" translate="yes" xml:space="preserve">
          <source>Increasingly, packages are being built on top of pandas to address specific needs in data preparation, analysis and visualization. This is encouraging because it means pandas is not only helping users to handle their data tasks but also that it provides a better starting point for developers to build powerful and more focused data tools. The creation of libraries that complement pandas&amp;rsquo; functionality also allows pandas development to remain focused around it&amp;rsquo;s original requirements.</source>
          <target state="translated">데이터 준비, 분석 및 시각화의 특정 요구를 해결하기 위해 팬더 위에 패키지가 점점 더 많이 구축되고 있습니다. 이는 팬더가 사용자가 데이터 작업을 처리하는 데 도움을 줄뿐만 아니라 개발자가 강력하고보다 집중된 데이터 도구를 구축 할 수있는 더 나은 출발점을 제공한다는 것을 의미하기 때문에 고무적입니다. 팬더의 기능을 보완하는 라이브러리를 만들면 팬더 개발이 원래 요구 사항에 계속 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dcd27a303504423a9e88ac04a13ca65377d4179" translate="yes" xml:space="preserve">
          <source>Increasingly, packages are being built on top of pandas to address specific needs in data preparation, analysis and visualization. Vaex is a python library for Out-of-Core DataFrames (similar to Pandas), to visualize and explore big tabular datasets. It can calculate statistics such as mean, sum, count, standard deviation etc, on an N-dimensional grid up to a billion (10&lt;sup&gt;9&lt;/sup&gt;) objects/rows per second. Visualization is done using histograms, density plots and 3d volume rendering, allowing interactive exploration of big data. Vaex uses memory mapping, zero memory copy policy and lazy computations for best performance (no memory wasted).</source>
          <target state="translated">데이터 준비, 분석 및 시각화의 특정 요구를 해결하기 위해 팬더 위에 패키지가 점점 더 많이 구축되고 있습니다. Vaex는 Out-of-Core DataFrames (Pandas와 유사)를위한 파이썬 라이브러리로, 큰 테이블 형식의 데이터 세트를 시각화하고 탐색합니다. 최대 10 억 (10 &lt;sup&gt;9&lt;/sup&gt; )의 객체 / 초당 N 차원 그리드에서 평균, 합계, 개수, 표준 편차 등과 같은 통계를 계산할 수 있습니다 . 히스토그램, 밀도 플롯 및 3D 볼륨 렌더링을 사용하여 시각화가 이루어 지므로 빅 데이터를 대화식으로 탐색 할 수 있습니다. Vaex는 최고의 성능을 위해 메모리 매핑, 제로 메모리 카피 정책 및 지연 계산을 사용합니다 (메모리 낭비 없음).</target>
        </trans-unit>
        <trans-unit id="26db5789a3db307320ead6289a9397c138320990" translate="yes" xml:space="preserve">
          <source>Increment to use from the tseries module or time rule (e.g. &amp;lsquo;EOM&amp;rsquo;)</source>
          <target state="translated">tseries 모듈 또는 시간 규칙에서 사용 증가 (예 : 'EOM')</target>
        </trans-unit>
        <trans-unit id="0b5df5508ba7385b434e62a6961ca6857f44c6b0" translate="yes" xml:space="preserve">
          <source>Increment to use from time series API (e.g. &amp;lsquo;M&amp;rsquo; or BDay()).</source>
          <target state="translated">시계열 API에서 사용하도록 증가합니다 (예 : 'M'또는 BDay ()).</target>
        </trans-unit>
        <trans-unit id="231c7f38ec6d94dc007935acbe384cf0282d72db" translate="yes" xml:space="preserve">
          <source>Increments between beginning of month dates.</source>
          <target state="translated">월 시작일 사이의 증분.</target>
        </trans-unit>
        <trans-unit id="b95c16a9ac51c0f7e39f7810c8313f53c219821f" translate="yes" xml:space="preserve">
          <source>Increments between end of month dates.</source>
          <target state="translated">월말 날짜 사이의 증분.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="2a44add6bb3ea93789807b6f66b9387cf8a079a5" translate="yes" xml:space="preserve">
          <source>Index : when the input is an Index</source>
          <target state="translated">색인 : 입력이 색인 인 경우</target>
        </trans-unit>
        <trans-unit id="0c8a552055cf4b1af8a6fef51686733239357ecb" translate="yes" xml:space="preserve">
          <source>Index and Column names include &lt;code&gt;index_name&lt;/code&gt; and &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; where &lt;code&gt;k&lt;/code&gt; is its level in a MultiIndex</source>
          <target state="translated">인덱스 및 열 이름에는 &lt;code&gt;index_name&lt;/code&gt; 및 &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;k&lt;/code&gt; 는 MultiIndex의 수준입니다.</target>
        </trans-unit>
        <trans-unit id="cd6ac17dc682d2c38066a77b16e976ff3c2ce09c" translate="yes" xml:space="preserve">
          <source>Index and header can be specified via the &lt;code&gt;index_col&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt; arguments</source>
          <target state="translated">&lt;code&gt;index_col&lt;/code&gt; 및 &lt;code&gt;header&lt;/code&gt; 인수 를 통해 인덱스 및 헤더를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="34faad5d858d4b7e89884a89d083ed8f33017377" translate="yes" xml:space="preserve">
          <source>Index based on an underlying &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 기반 인덱스 .</target>
        </trans-unit>
        <trans-unit id="af92f271aa69cd2c937dff42ef9cde6ee37cdfe5" translate="yes" xml:space="preserve">
          <source>Index based on an underlying &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 기반 인덱스 .</target>
        </trans-unit>
        <trans-unit id="adcb0c3d4f7b1a49941419accde10d7a93229a9a" translate="yes" xml:space="preserve">
          <source>Index for categorical data.</source>
          <target state="translated">범주 형 데이터에 대한 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="3a188639fe43a0a79a0742948b8551c1bd78cba5" translate="yes" xml:space="preserve">
          <source>Index implementing a monotonic integer range.</source>
          <target state="translated">단조 정수 범위를 구현하는 인덱스.</target>
        </trans-unit>
        <trans-unit id="842f096c24508918264d80e1c30ea189df13e9e8" translate="yes" xml:space="preserve">
          <source>Index keys are boxed to Period objects which carries the metadata (eg, frequency information).</source>
          <target state="translated">인덱스 키는 메타 데이터 (예 : 빈도 정보)를 전달하는 Period 객체에 박스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e277bfe290c28ec18c340b1a44e035c492f87f2b" translate="yes" xml:space="preserve">
          <source>Index label cells include</source>
          <target state="translated">인덱스 라벨 셀 포함</target>
        </trans-unit>
        <trans-unit id="fdca8fb2dd0723d97ecfeb0107e6b5a8a3a1793b" translate="yes" xml:space="preserve">
          <source>Index labels to drop.</source>
          <target state="translated">제거 할 색인 레이블.</target>
        </trans-unit>
        <trans-unit id="0666ee788b7f8718ba82db947fe0d30b9c20f60a" translate="yes" xml:space="preserve">
          <source>Index objects</source>
          <target state="translated">인덱스 객체</target>
        </trans-unit>
        <trans-unit id="f53cbdff8dd5cb499d7d24d1af81e5a33703f965" translate="yes" xml:space="preserve">
          <source>Index of &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt; s.</source>
          <target state="translated">색인 &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 의.</target>
        </trans-unit>
        <trans-unit id="56770e0bd43ee73f2eba8f0a730ea0c8e7920d9e" translate="yes" xml:space="preserve">
          <source>Index of Period data.</source>
          <target state="translated">기간 데이터 색인.</target>
        </trans-unit>
        <trans-unit id="9a66650f241bc1ae4f60df99a17e67b4b5bec78d" translate="yes" xml:space="preserve">
          <source>Index of datetime64 data.</source>
          <target state="translated">datetime64 데이터의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="8ca96bcaaba03554972454c50b497525d42f034c" translate="yes" xml:space="preserve">
          <source>Index of day names.</source>
          <target state="translated">요일 이름의 색인.</target>
        </trans-unit>
        <trans-unit id="faadd88f578df6cee31871b7dda874b805055e46" translate="yes" xml:space="preserve">
          <source>Index of formatted strings.</source>
          <target state="translated">형식화 된 문자열의 색인.</target>
        </trans-unit>
        <trans-unit id="583e9f80010c3027edc79dd38d334f00da629044" translate="yes" xml:space="preserve">
          <source>Index of int64 data.</source>
          <target state="translated">int64 데이터의 인덱스</target>
        </trans-unit>
        <trans-unit id="bc67cbdd4848572296e5148b9e3e23202fe8ceeb" translate="yes" xml:space="preserve">
          <source>Index of label.</source>
          <target state="translated">라벨 색인.</target>
        </trans-unit>
        <trans-unit id="2fa0e28586d25c85134d44435d18bc8a10b262f8" translate="yes" xml:space="preserve">
          <source>Index of month names.</source>
          <target state="translated">월 이름의 색인.</target>
        </trans-unit>
        <trans-unit id="7281850e680339a57853dba6d9c857e51597144f" translate="yes" xml:space="preserve">
          <source>Index of the Series.</source>
          <target state="translated">시리즈의 색인.</target>
        </trans-unit>
        <trans-unit id="c9f9f6a193b584c9a8e98b4efaf44235dd250eff" translate="yes" xml:space="preserve">
          <source>Index of the same type for a DatetimeIndex or TimedeltaIndex, or a Series with the same index for a Series.</source>
          <target state="translated">DatetimeIndex 또는 TimedeltaIndex에 대해 동일한 유형의 인덱스 또는 Series에 대해 동일한 인덱스를 가진 시리즈.</target>
        </trans-unit>
        <trans-unit id="019826cdb3fb98643542304c348378eec49fdfb1" translate="yes" xml:space="preserve">
          <source>Index of timedelta64 data.</source>
          <target state="translated">timedelta64 데이터의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="fbd9313d6091ac96c839a913f1173699a8ebc6ec" translate="yes" xml:space="preserve">
          <source>Index or MultiIndex</source>
          <target state="translated">인덱스 또는 다중 인덱스</target>
        </trans-unit>
        <trans-unit id="c875ef463fe284c143c8419c48f808383a7de6f9" translate="yes" xml:space="preserve">
          <source>Index or column labels to drop.</source>
          <target state="translated">제거 할 인덱스 또는 열 레이블.</target>
        </trans-unit>
        <trans-unit id="37ec8b0d3c027864c82264f650e37bc45231f7c7" translate="yes" xml:space="preserve">
          <source>Index should be similar to one of the columns in this one. If a Series is passed, its name attribute must be set, and that will be used as the column name in the resulting joined DataFrame.</source>
          <target state="translated">인덱스는이 열 중 하나와 유사해야합니다. Series가 전달되면 이름 속성을 설정해야하며 결합 된 결과 DataFrame에서 열 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea0c4acf4b23e40bdc6027bb925e7ece4846f20" translate="yes" xml:space="preserve">
          <source>Index to direct ranking.</source>
          <target state="translated">직접 순위에 대한 인덱스.</target>
        </trans-unit>
        <trans-unit id="e4e1575f2335a404e29fd2d44ad28ac2eb63c3c0" translate="yes" xml:space="preserve">
          <source>Index to use for resulting frame. Will default to RangeIndex if no indexing information part of input data and no index provided</source>
          <target state="translated">결과 프레임에 사용할 인덱스. 입력 데이터의 색인 정보가없고 색인이 제공되지 않은 경우 기본적으로 RangeIndex가됩니다.</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="132263ca33fe499e1fefbd5f4ab52b57901c7c9d" translate="yes" xml:space="preserve">
          <source>Index will be included as the first field of the record array if requested.</source>
          <target state="translated">요청 된 경우 인덱스는 레코드 배열의 첫 번째 필드로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f4acecef33c224b834072adfb597a584368d0111" translate="yes" xml:space="preserve">
          <source>Index with datetime64 data.</source>
          <target state="translated">datetime64 데이터가 포함 된 인덱스</target>
        </trans-unit>
        <trans-unit id="d0f9ff03291ad7359cbe79c48807f59ae4bcb3d2" translate="yes" xml:space="preserve">
          <source>Index with the MultiIndex data represented in Tuples.</source>
          <target state="translated">Tuples로 표현 된 MultiIndex 데이터가있는 인덱스</target>
        </trans-unit>
        <trans-unit id="2ae08452578221ac3ac96025e8fed3975af4b6fa" translate="yes" xml:space="preserve">
          <source>Index with values cast to specified dtype.</source>
          <target state="translated">지정된 dtype으로 캐스트 된 값이있는 인덱스</target>
        </trans-unit>
        <trans-unit id="6f89f1a8c4667749cd92a6f58c4201c42a229c3b" translate="yes" xml:space="preserve">
          <source>Index without duplicates</source>
          <target state="translated">중복없는 인덱스</target>
        </trans-unit>
        <trans-unit id="cdd71cd80c9d290c9a468dd9efa26b99b7ff2f8e" translate="yes" xml:space="preserve">
          <source>Index.T</source>
          <target state="translated">Index.T</target>
        </trans-unit>
        <trans-unit id="2db29e878e755947750a5416d6b29533d2d0f198" translate="yes" xml:space="preserve">
          <source>Index.all()</source>
          <target state="translated">Index.all()</target>
        </trans-unit>
        <trans-unit id="d42ccb1f02636a49f8b538e866d20b0f09ff7c4b" translate="yes" xml:space="preserve">
          <source>Index.any()</source>
          <target state="translated">Index.any()</target>
        </trans-unit>
        <trans-unit id="6643fe7b7406dbfa6af1b4565aeb2bbea3dac495" translate="yes" xml:space="preserve">
          <source>Index.append()</source>
          <target state="translated">Index.append()</target>
        </trans-unit>
        <trans-unit id="42a541775b6a11203a670551f7268a4814869896" translate="yes" xml:space="preserve">
          <source>Index.argmax()</source>
          <target state="translated">Index.argmax()</target>
        </trans-unit>
        <trans-unit id="87d989474d5559d3b36dd5800160bf3f9656a45e" translate="yes" xml:space="preserve">
          <source>Index.argmin()</source>
          <target state="translated">Index.argmin()</target>
        </trans-unit>
        <trans-unit id="8f552266a485dababae443a6fae2c3e9e83e11d1" translate="yes" xml:space="preserve">
          <source>Index.argsort()</source>
          <target state="translated">Index.argsort()</target>
        </trans-unit>
        <trans-unit id="a1fdb30d81bf0936fabfcab27c0303027f81892f" translate="yes" xml:space="preserve">
          <source>Index.array</source>
          <target state="translated">Index.array</target>
        </trans-unit>
        <trans-unit id="eed754ce326634c3140873727f5ea593fe2f35c4" translate="yes" xml:space="preserve">
          <source>Index.asi8</source>
          <target state="translated">Index.asi8</target>
        </trans-unit>
        <trans-unit id="d2cd29cb21401d11ea21f4cb41f8076e382966e6" translate="yes" xml:space="preserve">
          <source>Index.asof()</source>
          <target state="translated">Index.asof()</target>
        </trans-unit>
        <trans-unit id="199c20dd07d482f95cbf220ca2a7f42e74b379ba" translate="yes" xml:space="preserve">
          <source>Index.asof_locs()</source>
          <target state="translated">Index.asof_locs()</target>
        </trans-unit>
        <trans-unit id="41fd7d714455935421f5f4d9b47b8d2026a11eba" translate="yes" xml:space="preserve">
          <source>Index.astype()</source>
          <target state="translated">Index.astype()</target>
        </trans-unit>
        <trans-unit id="9695198546dd84741c60d2dc2e5f7927808bd80a" translate="yes" xml:space="preserve">
          <source>Index.base</source>
          <target state="translated">Index.base</target>
        </trans-unit>
        <trans-unit id="df3ceb7d36bffd44f156dbe30a939980f01c33fa" translate="yes" xml:space="preserve">
          <source>Index.contains()</source>
          <target state="translated">Index.contains()</target>
        </trans-unit>
        <trans-unit id="712612b1213ae7041ba7988df4918024034c21a1" translate="yes" xml:space="preserve">
          <source>Index.copy()</source>
          <target state="translated">Index.copy()</target>
        </trans-unit>
        <trans-unit id="7ad80e864f56fa9470edbc146fd372634069a3f4" translate="yes" xml:space="preserve">
          <source>Index.data</source>
          <target state="translated">Index.data</target>
        </trans-unit>
        <trans-unit id="ec91ad1c05256197f8c60f2da281fa396f0c6d9a" translate="yes" xml:space="preserve">
          <source>Index.delete()</source>
          <target state="translated">Index.delete()</target>
        </trans-unit>
        <trans-unit id="faf5b9b1f8570d369d4feb19d5c7852044b85934" translate="yes" xml:space="preserve">
          <source>Index.difference()</source>
          <target state="translated">Index.difference()</target>
        </trans-unit>
        <trans-unit id="42e7f9946dde54a45485adc101d97d6b16f7f409" translate="yes" xml:space="preserve">
          <source>Index.drop()</source>
          <target state="translated">Index.drop()</target>
        </trans-unit>
        <trans-unit id="0be051cd040eb2ec264d5b55580f51c8f599142b" translate="yes" xml:space="preserve">
          <source>Index.drop_duplicates()</source>
          <target state="translated">Index.drop_duplicates()</target>
        </trans-unit>
        <trans-unit id="2b12ad26e40306a335584618e9e8765839b15473" translate="yes" xml:space="preserve">
          <source>Index.droplevel()</source>
          <target state="translated">Index.droplevel()</target>
        </trans-unit>
        <trans-unit id="ed56b4f3a37cb253fdbe696af0f9d3014c831a3f" translate="yes" xml:space="preserve">
          <source>Index.dropna()</source>
          <target state="translated">Index.dropna()</target>
        </trans-unit>
        <trans-unit id="2b62528d4f5863f0eeed7a099cc5534488cbd1d7" translate="yes" xml:space="preserve">
          <source>Index.dtype</source>
          <target state="translated">Index.dtype</target>
        </trans-unit>
        <trans-unit id="4513ac87f55238987e3a62cfbcedb7736932e245" translate="yes" xml:space="preserve">
          <source>Index.dtype_str</source>
          <target state="translated">Index.dtype_str</target>
        </trans-unit>
        <trans-unit id="d126bba86106473c9aa6a8b507775593026a97fd" translate="yes" xml:space="preserve">
          <source>Index.duplicated()</source>
          <target state="translated">Index.duplicated()</target>
        </trans-unit>
        <trans-unit id="5d5ea543fea0e857f502b16d3d674ccfb9b37508" translate="yes" xml:space="preserve">
          <source>Index.empty</source>
          <target state="translated">Index.empty</target>
        </trans-unit>
        <trans-unit id="bbdd3262c5c824b5fc57e63e2024b274b8943447" translate="yes" xml:space="preserve">
          <source>Index.equals()</source>
          <target state="translated">Index.equals()</target>
        </trans-unit>
        <trans-unit id="7537cb7f2fb87bd7032798127b3fa14e4a87094c" translate="yes" xml:space="preserve">
          <source>Index.factorize()</source>
          <target state="translated">Index.factorize()</target>
        </trans-unit>
        <trans-unit id="3ad6d001e975cf52226968186ab8b929f1b2f34f" translate="yes" xml:space="preserve">
          <source>Index.fillna()</source>
          <target state="translated">Index.fillna()</target>
        </trans-unit>
        <trans-unit id="ca4c733dafa063111d3e1917deb861415c7dca7c" translate="yes" xml:space="preserve">
          <source>Index.flags</source>
          <target state="translated">Index.flags</target>
        </trans-unit>
        <trans-unit id="af04b167762ec954b256ede5966e65f06105980a" translate="yes" xml:space="preserve">
          <source>Index.format()</source>
          <target state="translated">Index.format()</target>
        </trans-unit>
        <trans-unit id="1a9aa2833bb0c1cc0b29b18ea52b274174f03095" translate="yes" xml:space="preserve">
          <source>Index.get_duplicates()</source>
          <target state="translated">Index.get_duplicates()</target>
        </trans-unit>
        <trans-unit id="86e80431dc8f6826d3a34fe6db19828973819c93" translate="yes" xml:space="preserve">
          <source>Index.get_indexer()</source>
          <target state="translated">Index.get_indexer()</target>
        </trans-unit>
        <trans-unit id="f04d404f4cdf74490fb1f5a9104d19eb0d5f6e6f" translate="yes" xml:space="preserve">
          <source>Index.get_indexer_for()</source>
          <target state="translated">Index.get_indexer_for()</target>
        </trans-unit>
        <trans-unit id="5590565b7ccce2eef74c22a12c42c9beb46890de" translate="yes" xml:space="preserve">
          <source>Index.get_indexer_non_unique()</source>
          <target state="translated">Index.get_indexer_non_unique()</target>
        </trans-unit>
        <trans-unit id="45e66bf229ef2853f0289b5ac5364d6839ea8b89" translate="yes" xml:space="preserve">
          <source>Index.get_level_values()</source>
          <target state="translated">Index.get_level_values()</target>
        </trans-unit>
        <trans-unit id="40e81e0c37a06638511ca2044947682ad788e95e" translate="yes" xml:space="preserve">
          <source>Index.get_loc()</source>
          <target state="translated">Index.get_loc()</target>
        </trans-unit>
        <trans-unit id="e06f31d250898f5e50f5313baa35f7d686f97ea7" translate="yes" xml:space="preserve">
          <source>Index.get_slice_bound()</source>
          <target state="translated">Index.get_slice_bound()</target>
        </trans-unit>
        <trans-unit id="a017c762db08e6652e606ada349388f6358ea1c0" translate="yes" xml:space="preserve">
          <source>Index.get_value()</source>
          <target state="translated">Index.get_value()</target>
        </trans-unit>
        <trans-unit id="3412f5093e174de9e668739be7bdaadbd39eb65d" translate="yes" xml:space="preserve">
          <source>Index.get_values()</source>
          <target state="translated">Index.get_values()</target>
        </trans-unit>
        <trans-unit id="5c64f9e8369fe01023f29790c28cdfdaf854182f" translate="yes" xml:space="preserve">
          <source>Index.groupby()</source>
          <target state="translated">Index.groupby()</target>
        </trans-unit>
        <trans-unit id="6d0086d9449b0f2970b1a1002559afa8be4edcc0" translate="yes" xml:space="preserve">
          <source>Index.has_duplicates</source>
          <target state="translated">Index.has_duplicates</target>
        </trans-unit>
        <trans-unit id="609ed6a9294ca8a4c59b782af30bcb4bcbfa4334" translate="yes" xml:space="preserve">
          <source>Index.hasnans</source>
          <target state="translated">Index.hasnans</target>
        </trans-unit>
        <trans-unit id="256e409ba208654bae279d531c4437036a30c3c6" translate="yes" xml:space="preserve">
          <source>Index.holds_integer()</source>
          <target state="translated">Index.holds_integer()</target>
        </trans-unit>
        <trans-unit id="27c912b1b841464548a4368b28293c6998002fa6" translate="yes" xml:space="preserve">
          <source>Index.identical()</source>
          <target state="translated">Index.identical()</target>
        </trans-unit>
        <trans-unit id="0d9cd7f3b930250338bd29771718bdadf9c52edc" translate="yes" xml:space="preserve">
          <source>Index.inferred_type</source>
          <target state="translated">Index.inferred_type</target>
        </trans-unit>
        <trans-unit id="a7c9b79b50642bfe91d87a4142b36f2acec3f301" translate="yes" xml:space="preserve">
          <source>Index.insert()</source>
          <target state="translated">Index.insert()</target>
        </trans-unit>
        <trans-unit id="383740534f674f58776d2a1d93221a9eecf0d257" translate="yes" xml:space="preserve">
          <source>Index.intersection()</source>
          <target state="translated">Index.intersection()</target>
        </trans-unit>
        <trans-unit id="cf31e7ef599ab41687ad8068a1433fd6b3634170" translate="yes" xml:space="preserve">
          <source>Index.is_()</source>
          <target state="translated">Index.is_()</target>
        </trans-unit>
        <trans-unit id="32e7b9aee15ec011aea6101aa6fd4fe3371b0113" translate="yes" xml:space="preserve">
          <source>Index.is_all_dates</source>
          <target state="translated">Index.is_all_dates</target>
        </trans-unit>
        <trans-unit id="518a358e7c6917d3e80097c35681c703d8cda02b" translate="yes" xml:space="preserve">
          <source>Index.is_boolean()</source>
          <target state="translated">Index.is_boolean()</target>
        </trans-unit>
        <trans-unit id="4ef0bbc93946d57f4d3c198be80d494d743e92ed" translate="yes" xml:space="preserve">
          <source>Index.is_categorical()</source>
          <target state="translated">Index.is_categorical()</target>
        </trans-unit>
        <trans-unit id="e422be1fa0c5049f72e6fcf32c4cd90a6b79db36" translate="yes" xml:space="preserve">
          <source>Index.is_floating()</source>
          <target state="translated">Index.is_floating()</target>
        </trans-unit>
        <trans-unit id="eedd61d66278556890bd1ef4984458d134824180" translate="yes" xml:space="preserve">
          <source>Index.is_integer()</source>
          <target state="translated">Index.is_integer()</target>
        </trans-unit>
        <trans-unit id="3449dc3646f5663091d66253c629e81ea33613a4" translate="yes" xml:space="preserve">
          <source>Index.is_interval()</source>
          <target state="translated">Index.is_interval()</target>
        </trans-unit>
        <trans-unit id="91565ce426e539ec67932b0347b377b031b9adc0" translate="yes" xml:space="preserve">
          <source>Index.is_lexsorted_for_tuple()</source>
          <target state="translated">Index.is_lexsorted_for_tuple()</target>
        </trans-unit>
        <trans-unit id="1093e68ed67b6291a2f3e105590479a859fe584f" translate="yes" xml:space="preserve">
          <source>Index.is_mixed()</source>
          <target state="translated">Index.is_mixed()</target>
        </trans-unit>
        <trans-unit id="e81c8d4943551219dae0256b5fac5fa8d60fe8c3" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic</source>
          <target state="translated">Index.is_monotonic</target>
        </trans-unit>
        <trans-unit id="234edfe9fa6e9d453a6c5f2296f7489cbdbcb562" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic_decreasing</source>
          <target state="translated">Index.is_monotonic_decreasing</target>
        </trans-unit>
        <trans-unit id="32e344e2f5d4359c74e4c5388e4e65939090fef2" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic_increasing</source>
          <target state="translated">Index.is_monotonic_increasing</target>
        </trans-unit>
        <trans-unit id="178025556525fb6fbfce91b30d313f3f582c2a97" translate="yes" xml:space="preserve">
          <source>Index.is_numeric()</source>
          <target state="translated">Index.is_numeric()</target>
        </trans-unit>
        <trans-unit id="3cc6d8a931c9fee208b8f3cf19d76d713c89dc5d" translate="yes" xml:space="preserve">
          <source>Index.is_object()</source>
          <target state="translated">Index.is_object()</target>
        </trans-unit>
        <trans-unit id="4525d0b8709d619a431b65c20da8bc6ba09b1a44" translate="yes" xml:space="preserve">
          <source>Index.is_type_compatible()</source>
          <target state="translated">Index.is_type_compatible()</target>
        </trans-unit>
        <trans-unit id="6740ddea5faa07de307632b937a998c94ca6a63a" translate="yes" xml:space="preserve">
          <source>Index.is_unique</source>
          <target state="translated">Index.is_unique</target>
        </trans-unit>
        <trans-unit id="674032d065981e78e8cd136b81b44eb45a598207" translate="yes" xml:space="preserve">
          <source>Index.isin()</source>
          <target state="translated">Index.isin()</target>
        </trans-unit>
        <trans-unit id="8f9d27858d48386a4761bc707ce7819b553d0bc3" translate="yes" xml:space="preserve">
          <source>Index.isna()</source>
          <target state="translated">Index.isna()</target>
        </trans-unit>
        <trans-unit id="5d851a0e9d76585e1b7920ebbb548a67d160c48a" translate="yes" xml:space="preserve">
          <source>Index.isnull()</source>
          <target state="translated">Index.isnull()</target>
        </trans-unit>
        <trans-unit id="c8892d9fcf76b93c0f0f4c39d6048b496935f67b" translate="yes" xml:space="preserve">
          <source>Index.item()</source>
          <target state="translated">Index.item()</target>
        </trans-unit>
        <trans-unit id="e8ea8d058133355dab3f96a87fc9ec7429cc9203" translate="yes" xml:space="preserve">
          <source>Index.itemsize</source>
          <target state="translated">Index.itemsize</target>
        </trans-unit>
        <trans-unit id="8ab0214eec07aa3bc9fcd14199b90eb2806c2746" translate="yes" xml:space="preserve">
          <source>Index.join()</source>
          <target state="translated">Index.join()</target>
        </trans-unit>
        <trans-unit id="b45fb2874f4e6a47bc1a8c669598c02756198ff8" translate="yes" xml:space="preserve">
          <source>Index.map()</source>
          <target state="translated">Index.map()</target>
        </trans-unit>
        <trans-unit id="bf243747f281253b63548f651a488e9104e5566e" translate="yes" xml:space="preserve">
          <source>Index.max()</source>
          <target state="translated">Index.max()</target>
        </trans-unit>
        <trans-unit id="dad05f0e4cf78f12f0df0617b2eca51ad76f1e3e" translate="yes" xml:space="preserve">
          <source>Index.memory_usage()</source>
          <target state="translated">Index.memory_usage()</target>
        </trans-unit>
        <trans-unit id="6f3ff971904fc6d7253ec3e53ce502d7c2bb01b0" translate="yes" xml:space="preserve">
          <source>Index.min()</source>
          <target state="translated">Index.min()</target>
        </trans-unit>
        <trans-unit id="a81409d1833143080fa7467f35ac07337a7dc88b" translate="yes" xml:space="preserve">
          <source>Index.name</source>
          <target state="translated">Index.name</target>
        </trans-unit>
        <trans-unit id="0967056855c1ae1ff95d670362e8b9cb745929aa" translate="yes" xml:space="preserve">
          <source>Index.names</source>
          <target state="translated">Index.names</target>
        </trans-unit>
        <trans-unit id="9b8bbf4a1d3548f84736a16d908199ad102ca7d1" translate="yes" xml:space="preserve">
          <source>Index.nbytes</source>
          <target state="translated">Index.nbytes</target>
        </trans-unit>
        <trans-unit id="015335b73fb556a0a95f7477349f31835996bc0e" translate="yes" xml:space="preserve">
          <source>Index.ndim</source>
          <target state="translated">Index.ndim</target>
        </trans-unit>
        <trans-unit id="1d16a9b86b35376b0fe2ceb694e880dccd624087" translate="yes" xml:space="preserve">
          <source>Index.nlevels</source>
          <target state="translated">Index.nlevels</target>
        </trans-unit>
        <trans-unit id="7aa616075b64c7fe50d3485e7309af78d33685e4" translate="yes" xml:space="preserve">
          <source>Index.notna()</source>
          <target state="translated">Index.notna()</target>
        </trans-unit>
        <trans-unit id="c054c04dd3852d7befee485647c33564f0e9c6de" translate="yes" xml:space="preserve">
          <source>Index.notnull()</source>
          <target state="translated">Index.notnull()</target>
        </trans-unit>
        <trans-unit id="95141a09ec236ad88338a788ae9bda71d9f7b6ab" translate="yes" xml:space="preserve">
          <source>Index.nunique()</source>
          <target state="translated">Index.nunique()</target>
        </trans-unit>
        <trans-unit id="732ef5ab848fd1322c65183d205ae49fe28c4ac1" translate="yes" xml:space="preserve">
          <source>Index.putmask()</source>
          <target state="translated">Index.putmask()</target>
        </trans-unit>
        <trans-unit id="0ed3c46ffc0bac1516958f6f397676c802f24042" translate="yes" xml:space="preserve">
          <source>Index.ravel()</source>
          <target state="translated">Index.ravel()</target>
        </trans-unit>
        <trans-unit id="a1497db1d34f7e9354a66c83ae2d2ac605c6bdd8" translate="yes" xml:space="preserve">
          <source>Index.reindex()</source>
          <target state="translated">Index.reindex()</target>
        </trans-unit>
        <trans-unit id="01e1d0c95c6feb54b63adae1c6464c50b621266b" translate="yes" xml:space="preserve">
          <source>Index.rename()</source>
          <target state="translated">Index.rename()</target>
        </trans-unit>
        <trans-unit id="77c10629020e8a6aa514d1106ba620916dac587c" translate="yes" xml:space="preserve">
          <source>Index.repeat()</source>
          <target state="translated">Index.repeat()</target>
        </trans-unit>
        <trans-unit id="d69eefbd97fa6081331925aba573779e7e832287" translate="yes" xml:space="preserve">
          <source>Index.searchsorted()</source>
          <target state="translated">Index.searchsorted()</target>
        </trans-unit>
        <trans-unit id="a57478d81d0711e85d7c2a0858e822448ec6cc93" translate="yes" xml:space="preserve">
          <source>Index.set_names()</source>
          <target state="translated">Index.set_names()</target>
        </trans-unit>
        <trans-unit id="624e7ac5391fcc29bb760b6f942218dfa03b0b17" translate="yes" xml:space="preserve">
          <source>Index.set_value()</source>
          <target state="translated">Index.set_value()</target>
        </trans-unit>
        <trans-unit id="9c921b4b894047ddf6a39ab0881e37296631f609" translate="yes" xml:space="preserve">
          <source>Index.shape</source>
          <target state="translated">Index.shape</target>
        </trans-unit>
        <trans-unit id="46400b31e771f708ca74d273f325af855ea6d991" translate="yes" xml:space="preserve">
          <source>Index.shift()</source>
          <target state="translated">Index.shift()</target>
        </trans-unit>
        <trans-unit id="472cefee5f15b86396f78a3a8e6aea60b8a75015" translate="yes" xml:space="preserve">
          <source>Index.size</source>
          <target state="translated">Index.size</target>
        </trans-unit>
        <trans-unit id="1df9304b1390f9267e3c387c34aac0979af35b7e" translate="yes" xml:space="preserve">
          <source>Index.slice_indexer()</source>
          <target state="translated">Index.slice_indexer()</target>
        </trans-unit>
        <trans-unit id="d662c5067630e7b727eb6b33d7ac91db2f6ee08c" translate="yes" xml:space="preserve">
          <source>Index.slice_locs()</source>
          <target state="translated">Index.slice_locs()</target>
        </trans-unit>
        <trans-unit id="db5c1e805ea14b67fd3c52e4f99be0f6a1b90b89" translate="yes" xml:space="preserve">
          <source>Index.sort()</source>
          <target state="translated">Index.sort()</target>
        </trans-unit>
        <trans-unit id="913cf43e3772ed2a8fe03575229daa1bc50dbdc4" translate="yes" xml:space="preserve">
          <source>Index.sort_values()</source>
          <target state="translated">Index.sort_values()</target>
        </trans-unit>
        <trans-unit id="10a67806a9d5ae0108e6749e42319b1d50a16e91" translate="yes" xml:space="preserve">
          <source>Index.sortlevel()</source>
          <target state="translated">Index.sortlevel()</target>
        </trans-unit>
        <trans-unit id="29905bdb7228280b70783d506e68b98b08a339d8" translate="yes" xml:space="preserve">
          <source>Index.str()</source>
          <target state="translated">Index.str()</target>
        </trans-unit>
        <trans-unit id="b6fdc18bb263150a4ad7d892c1a5003bf55ffe18" translate="yes" xml:space="preserve">
          <source>Index.strides</source>
          <target state="translated">Index.strides</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
