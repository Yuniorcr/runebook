<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="css">
    <body>
      <group id="css">
        <trans-unit id="51650b01006ec4cb00adcf67d2bf1c66587722f0" translate="yes" xml:space="preserve">
          <source>If you change the value of &lt;code&gt;direction&lt;/code&gt; to &lt;code&gt;rtl&lt;/code&gt; you will see that the alignment stays to the right for the first block, but goes to the logical end on the left in the second.</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 값 을 &lt;code&gt;rtl&lt;/code&gt; 로 변경하면 정렬이 첫 번째 블록의 오른쪽에 머 무르지 만 두 번째 블록의 왼쪽에있는 논리적 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7950c4636ae3036ed8be96f167874e48186b9f36" translate="yes" xml:space="preserve">
          <source>If you choose to hide the grippers, you should ensure that users have a mechanism for selecting text via touch. To find out how to do this using JavaScript, see the HTML5 Selection APIs.</source>
          <target state="translated">그리퍼를 숨기려면 터치를 통해 텍스트를 선택할 수있는 메커니즘이 사용자에게 있는지 확인해야합니다. JavaScript를 사용하여이 작업을 수행하는 방법을 알아 보려면 HTML5 선택 API를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="909c42079ee52086f6ffc5d9ce41b9d6c30c5ac8" translate="yes" xml:space="preserve">
          <source>If you create a media feature query without specifying a value, the nested styles will be used as long as the feature's value is not zero (or &lt;code&gt;none&lt;/code&gt;, in Level 4). For example, this CSS will apply to any device with a color screen:</source>
          <target state="translated">값을 지정하지 않고 미디어 기능 쿼리를 만들면 기능의 값이 0이 아니거나 수준 4에서 &lt;code&gt;none&lt;/code&gt; 이 아닌 한 중첩 스타일이 사용됩니다 . 예를 들어이 CSS는 컬러 스크린이있는 모든 장치에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c586ba627127e48ddb546dd656f6a6f004cdae" translate="yes" xml:space="preserve">
          <source>If you do not want space added to the items, remember that you can deal with free space between or around items using the alignment properties described in the guide to aligning items in a flex container. The &lt;a href=&quot;../justify-content&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; property will enable the distribution of free space between or around items. You can also use auto margins on flex items to absorb space and create gaps between items.</source>
          <target state="translated">항목에 공간을 추가하지 않으려면 Flex 컨테이너에서 항목을 정렬하기위한 안내서에 설명 된 정렬 속성을 사용하여 항목 사이 또는 주변의 여유 공간을 처리 할 수 ​​있습니다. &lt;a href=&quot;../justify-content&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt; 속성 사이 또는 항목 주변에 여유 공간의 분포를 가능하게 할 것이다. 플렉스 항목에 자동 여백을 사용하여 공간을 흡수하고 항목 사이에 간격을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e27635f1644f20277605a74d571d2e091f1cfbfe" translate="yes" xml:space="preserve">
          <source>If you give an item relative positioning with &lt;code&gt;position: relative&lt;/code&gt; it remains in flow, however you are then able to use the offset values to push it around. The space that it would have been placed in normal flow is reserved however, as you can see in the example below.</source>
          <target state="translated">&lt;code&gt;position: relative&lt;/code&gt; 를 사용하여 항목에 상대 위치를 지정 하면 유동 상태로 유지되지만 오프셋 값을 사용하여 항목을 밀 수 있습니다. 그러나 아래 예에서 볼 수 있듯이 일반 흐름에 배치 된 공간은 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d308654cc13ec81ffc648327ff4f42859ed0408a" translate="yes" xml:space="preserve">
          <source>If you have a situation where your grid tracks use an area that is smaller than the grid container, then you can align the grid tracks themselves, inside that container. Once again, this operates on the block and inline axes, with &lt;a href=&quot;../align-content&quot;&gt;&lt;code&gt;align-content&lt;/code&gt;&lt;/a&gt; aligning tracks on the block axis, and &lt;a href=&quot;../justify-content&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; performing alignment on the inline axis. The values for &lt;a href=&quot;../align-content&quot;&gt;&lt;code&gt;align-content&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../justify-content&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">그리드 트랙이 그리드 컨테이너보다 작은 영역을 사용하는 상황이있는 경우 해당 컨테이너 내부에서 그리드 트랙 자체를 정렬 할 수 있습니다. 다시 한 번, 이것은 블록 축에 &lt;a href=&quot;../align-content&quot;&gt; &lt;code&gt;align-content&lt;/code&gt; &lt;/a&gt; 정렬 트랙 을 사용하여 블록 및 인라인 축에서 작동하고 인라인 축에 정렬을 수행하는 &lt;a href=&quot;../justify-content&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt; 을 정당화 합니다. &lt;a href=&quot;../align-content&quot;&gt; &lt;code&gt;align-content&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../justify-content&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; &lt;/a&gt; 의 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7220bcba6dd0f08492e3de1db28f6348f3e5aa4" translate="yes" xml:space="preserve">
          <source>If you have been working with one of the many frameworks or grid systems you may be accustomed to laying out your site on a 12- or 16-column flexible grid. We can create this type of system using CSS Grid Layout. As a simple example, I am creating a 12-column flexible grid that has 12 &lt;code&gt;1fr&lt;/code&gt;-unit column tracks, they all have a start line named &lt;code&gt;col-start&lt;/code&gt;. This means that we will have twelve grid lines named &lt;code&gt;col-start&lt;/code&gt;.</source>
          <target state="translated">여러 프레임 워크 또는 그리드 시스템 중 하나를 사용하여 작업 한 경우 12 열 또는 16 열의 유연한 그리드에 사이트를 배치하는 데 익숙 할 수 있습니다. CSS 그리드 레이아웃을 사용하여 이러한 유형의 시스템을 만들 수 있습니다. 간단한 예를 들어, 12 개의 &lt;code&gt;1fr&lt;/code&gt; 단위 열 트랙 을 가진 12 열의 유연한 그리드를 만들고 있는데 모두 &lt;code&gt;col-start&lt;/code&gt; 라는 시작 줄이 있습니다. 즉, &lt;code&gt;col-start&lt;/code&gt; 라는 12 개의 그리드 선이 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="5f90ffc6ac7a29af114fd34610df8e7d396d57e3" translate="yes" xml:space="preserve">
          <source>If you have looked at the main page for &lt;a href=&quot;../css_logical_properties&quot;&gt;CSS Logical Properties and Values&lt;/a&gt; you will see there are a huge number of properties listed. This is mostly due to the fact that there are four longhand values each for margin, border, and padding side, plus all the shorthand values.</source>
          <target state="translated">&lt;a href=&quot;../css_logical_properties&quot;&gt;CSS Logical Properties and Values&lt;/a&gt; 의 메인 페이지를 살펴보면 수많은 속성이 나열되어 있음을 알 수 있습니다. 이것은 대부분 여백, 경계 및 패딩면에 대해 각각 4 개의 Longhand 값과 모든 속기 값이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a19deb1f58c35c83d5eb1a4f6d091acf93925fc2" translate="yes" xml:space="preserve">
          <source>If you have read the article &lt;a href=&quot;basic_concepts_of_flexbox&quot;&gt;Basic Concepts of Flexbox&lt;/a&gt;, then you will have already had an introduction to the properties. Here we will explore them in depth in order that you can fully understand what the browser is doing when you use them.</source>
          <target state="translated">&lt;a href=&quot;basic_concepts_of_flexbox&quot;&gt;Flexbox의 기본 개념&lt;/a&gt; 기사를 읽었다면 이미 속성에 대한 소개를 받았을 것입니다. 여기서는 브라우저를 사용할 때 브라우저가 수행하는 작업을 완전히 이해할 수 있도록 깊이있게 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0167d63366405ea20e755c29d443d2fc52131452" translate="yes" xml:space="preserve">
          <source>If you have set values using &lt;code&gt;font-variation-settings&lt;/code&gt; and want to change one of those values, you must redeclare all of them (in the same way as when you set OpenType font features using &lt;a href=&quot;../font-feature-settings&quot;&gt;&lt;code&gt;font-feature-settings&lt;/code&gt;&lt;/a&gt;). You can work around this limitation by using &lt;a href=&quot;../using_css_variables&quot;&gt;CSS Custom Properties&lt;/a&gt; (CSS variables) for the individual values, and simply modifying the value of an individual custom property. Example code follows at the end of the guide.</source>
          <target state="translated">&lt;code&gt;font-variation-settings&lt;/code&gt; 를 사용하여 값을 설정 하고 해당 값 중 하나를 변경하려면 &lt;a href=&quot;../font-feature-settings&quot;&gt; &lt;code&gt;font-feature-settings&lt;/code&gt; 를&lt;/a&gt; 사용하여 OpenType 글꼴 기능을 설정할 때와 같은 방식으로 모든 값을 다시 선언해야합니다 . 개별 값에 &lt;a href=&quot;../using_css_variables&quot;&gt;CSS 사용자 정의 특성&lt;/a&gt; (CSS 변수)을 사용하고 개별 사용자 정의 특성의 값을 간단히 수정 하여이 제한 사항을 해결할 수 있습니다 . 예제 코드는 가이드 끝에서 따릅니다.</target>
        </trans-unit>
        <trans-unit id="51428f716ebd6feb998b5bfa2474bcdc37aecaba" translate="yes" xml:space="preserve">
          <source>If you have small amounts of content and are trying to control breaks in a number of ways or on several elements, your content needs to break somewhere, so you may not always get the result you intended. To some extent your use of fragmentation is always a suggestion to the browser, to control breaks in this way if it is possible.</source>
          <target state="translated">소량의 컨텐츠가 있고 여러 가지 방법으로 또는 여러 요소로 나누기를 제어하려는 경우 컨텐츠가 어딘가에서 끊어야하므로 항상 원하는 결과를 얻지 못할 수 있습니다. 어느 정도까지는 조각화를 사용하는 것이 가능한 경우 이러한 방식으로 나누기를 제어하기 위해 항상 브라우저에 대한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="4ba056748fc09ded2f2b43ea778fcf5283e4346e" translate="yes" xml:space="preserve">
          <source>If you have used a track list then you can use the &lt;code&gt;span&lt;/code&gt; keyword not just to span a number of lines but also to span a number of lines of a certain name.</source>
          <target state="translated">트랙 목록을 사용한 경우 &lt;code&gt;span&lt;/code&gt; 키워드를 사용하여 여러 줄에 걸쳐있을뿐만 아니라 특정 이름의 여러 줄에 걸쳐있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4262891b5183e6f2940d6049ba65261e27de03" translate="yes" xml:space="preserve">
          <source>If you have worked through these initial guides you now should be in a position to create grid layouts using line-based placement or named areas. Take some time to build some common layout patterns using grid, while there are lots of new terms to learn, the syntax is relatively straightforward. As you develop examples, you are likely to come up with some questions and use cases for things we haven't covered yet. In the rest of these guides we will be looking at some more of the detail included in the specification &amp;ndash; in order that you can begin to create advanced layouts with it.</source>
          <target state="translated">이러한 초기 안내서를 살펴본 경우 이제 선 기반 배치 또는 명명 된 영역을 사용하여 그리드 레이아웃을 작성할 수 있습니다. 그리드를 사용하여 일반적인 레이아웃 패턴을 만드는 데 시간이 걸리지 만 배울 새로운 용어가 많이 있지만 구문은 비교적 간단합니다. 예제를 개발할 때 아직 다루지 않은 것들에 대한 몇 가지 질문과 사용 사례가 나올 것입니다. 이 가이드의 나머지 부분에서는 사양에 포함 된 세부 사항을 살펴보고 고급 레이아웃을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="620bfecf59c7c19a753b4741ad208017dbd677a8" translate="yes" xml:space="preserve">
          <source>If you include an SVG file in your HTML, the viewport of the SVG is the initial containing block, or the width and height of the SVG container. Using the &lt;a href=&quot;../@media&quot;&gt;&lt;code&gt;@media&lt;/code&gt;&lt;/a&gt; query in your SVG's CSS is relative to that container, not the browser.</source>
          <target state="translated">HTML에 SVG 파일을 포함하면 SVG의 뷰포트는 초기 포함 블록 또는 SVG 컨테이너의 너비와 높이입니다. SVG의 CSS에서 &lt;a href=&quot;../@media&quot;&gt; &lt;code&gt;@media&lt;/code&gt; &lt;/a&gt; 쿼리를 사용하는 것은 브라우저가 아닌 해당 컨테이너와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94aecafdb4bbe1397c906187a3ab44f1fbd5e29" translate="yes" xml:space="preserve">
          <source>If you include an SVG file in your HTML, the viewport of the SVG is the initial containing block, or the width and height of the SVG container. Using the &lt;a href=&quot;@media&quot;&gt;&lt;code&gt;@media&lt;/code&gt;&lt;/a&gt; query in your SVG's CSS is relative to that container, not the browser.</source>
          <target state="translated">HTML에 SVG 파일을 포함하면 SVG의 뷰포트는 초기 포함 블록 또는 SVG 컨테이너의 너비와 높이입니다. SVG의 CSS에서 &lt;a href=&quot;@media&quot;&gt; &lt;code&gt;@media&lt;/code&gt; &lt;/a&gt; 쿼리를 사용하는 것은 브라우저가 아닌 해당 컨테이너와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcccf030208a1a6b73ec85b32a0b25dc3c72d36" translate="yes" xml:space="preserve">
          <source>If you initially learned &lt;a href=&quot;css_flexible_box_layout&quot;&gt;Flexbox&lt;/a&gt; then you may consider these properties to be part of the Flexbox specification, and some of the properties are indeed listed in Level 1 of Flexbox. However the specification notes that the Box Alignment specification should be referred to as it may add additional capabilities over what is currently in Flexbox.</source>
          <target state="translated">&lt;a href=&quot;css_flexible_box_layout&quot;&gt;Flexbox&lt;/a&gt; 를 처음 배운 경우 이러한 속성을 Flexbox 사양의 일부로 간주 할 수 있으며 일부 속성은 실제로 Flexbox의 레벨 1에 나열되어 있습니다. 그러나이 사양에서는 Box Alignment 사양은 현재 Flexbox에있는 기능에 추가 기능을 추가 할 수있는 것으로 언급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d919716886427a7cd37e29fbf36785a827716aa0" translate="yes" xml:space="preserve">
          <source>If you need flex items to line up in the cross axis, controlling the width in this way will achieve that. In most cases however, adding widths to flex items in this way demonstrates that you would probably be better served by switching to grid layout for that component.</source>
          <target state="translated">가로축에 플렉스 항목을 정렬해야하는 경우 이러한 방식으로 너비를 제어하면됩니다. 그러나 대부분의 경우 이러한 방식으로 플렉스 아이템에 너비를 추가하면 해당 컴포넌트의 그리드 레이아웃으로 전환하여 더 나은 서비스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f30df759710f138eb167e2be95e65e4b33d1464" translate="yes" xml:space="preserve">
          <source>If you need to be aware of changes to the evaluated result of the query on an ongoing basis, it's more efficient to register a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;listener&lt;/a&gt; than to poll the query's result. To do this, call the &lt;code&gt;addListener()&lt;/code&gt; method on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;&lt;code&gt;MediaQueryList&lt;/code&gt;&lt;/a&gt; object, with a callback function to invoke when the media query status changes (e.g., the media query test goes from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;):</source>
          <target state="translated">지속적으로 평가 된 쿼리 결과에 대한 변경 사항을 알고 있어야하는 경우 쿼리 결과 를 폴링하는 것보다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;리스너&lt;/a&gt; 를 등록하는 것이 더 효율적 입니다. 이렇게하려면 미디어 쿼리 상태가 변경 될 때 호출하는 콜백 함수를 사용 하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt; &lt;code&gt;MediaQueryList&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;code&gt;addListener()&lt;/code&gt; 메서드 를 호출합니다 (예 : 미디어 쿼리 테스트가 &lt;code&gt;true&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; 로 이동 ).</target>
        </trans-unit>
        <trans-unit id="cb44beed0587d0e40f444e684a52550d5d120cbc" translate="yes" xml:space="preserve">
          <source>If you place something outside of the defined grid&amp;mdash;or due to the amount of content, more grid tracks are needed&amp;mdash;then the grid creates rows and columns in the implicit grid. These tracks will be auto-sized by default, resulting in their size being based on the content that is inside them.</source>
          <target state="translated">정의 된 그리드 외부에 무언가를 배치하거나 컨텐츠 양으로 인해 더 많은 그리드 트랙이 필요하면 그리드는 암시 적 그리드에 행과 열을 만듭니다. 이 트랙은 기본적으로 자동 크기가 조정되어 그 안에있는 내용에 따라 크기가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4b242f0254355775fcf501494e63caa680aa3e" translate="yes" xml:space="preserve">
          <source>If you reference an SVG image in a webpage (such as with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element or as a background image), the SVG image can coordinate with the embedding element (its context) to have the image adopt property values set on the embedding element. To do this the embedding element needs to list the properties that are to be made available to the image by listing them as values of the &lt;code&gt;-moz-context-properties&lt;/code&gt; property, and the image needs to opt in to using those properties by using values such as the &lt;code&gt;context-fill&lt;/code&gt; value.</source>
          <target state="translated">웹 페이지에서 SVG 이미지 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 또는 배경 이미지)를 참조하는 경우 SVG 이미지는 이미지를 포함 요소 (컨텍스트)와 조정하여 이미지가 포함 요소에 설정된 속성 값을 갖도록 할 수 있습니다. . 이를 위해 임베드 요소는 이미지를 &lt;code&gt;-moz-context-properties&lt;/code&gt; 특성의 값으로 나열하여 이미지에 사용 가능한 특성을 나열해야하며 이미지는 다음과 같은 값 을 사용하여 해당 특성을 사용하도록 선택해야합니다. 는 AS &lt;code&gt;context-fill&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="362d7332b148281bb9464c2db1104e609de16213" translate="yes" xml:space="preserve">
          <source>If you reorder things visually using grid layout, this will not change how the items are ordered if the content is being read out by a screen reader, or other text to speech user agent. In addition, the reordering will not change tab order. This means that someone navigating using the keyboard could be tabbing through links on your site and suddenly find themselves jumping from the top to the bottom of the document due to a reordered item being next in line.</source>
          <target state="translated">격자 선 레이아웃을 사용하여 시각적으로 항목을 재정렬하더라도 화면 판독기 또는 다른 텍스트-음성 사용자 에이전트가 내용을 읽는 경우 항목 순서를 변경하지 않습니다. 또한, 재정렬은 탭 순서를 변경하지 않습니다. 즉, 키보드를 사용하여 탐색하는 사람이 사이트의 링크를 통해 탭을 이동하고 다시 정렬 된 항목이 다음 줄에 있기 때문에 갑자기 문서의 상단에서 하단으로 점프하는 것을 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f896e5f162f27d90102abc9efa6aed12272b3ca5" translate="yes" xml:space="preserve">
          <source>If you repeating syntax puts two lines next to each other then they will be merged, and create the same result as giving a line multiple names in a non-repeating track definition. The following definition, creates four &lt;code&gt;1fr&lt;/code&gt; tracks, which each have a start and end line.</source>
          <target state="translated">구문을 반복하면 두 줄이 나란히 놓이면 두 줄이 병합되고 반복되지 않는 트랙 정의에 여러 줄을 지정하는 것과 동일한 결과를 만듭니다. 다음 정의는 4 개의 &lt;code&gt;1fr&lt;/code&gt; 트랙을 생성 하며 각 트랙에는 시작 및 끝 라인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71ca494cb021593fedfe11ffb405e44981ca7e3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;justify-content: space-between&lt;/code&gt; on the flex container, the available space is now shared out and placed between the items.</source>
          <target state="translated">flex 컨테이너에서 &lt;code&gt;justify-content: space-between&lt;/code&gt; 을 설정 하면 사용 가능한 공간이 공유되어 항목간에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="03ee022a8e6cf9e1883f5b82befe6f8870eb7841" translate="yes" xml:space="preserve">
          <source>If you set an alignment that cannot be fulfilled, then the &lt;strong&gt;fallback alignment&lt;/strong&gt; will come into play and deal with the available space. This fallback alignment is specified individually for each layout method and detailed on the page for that method.</source>
          <target state="translated">이행 할 수없는 정렬을 설정하면 &lt;strong&gt;대체 정렬&lt;/strong&gt; 이 작동하여 사용 가능한 공간을 처리합니다. 이 대체 정렬은 각 레이아웃 방법에 대해 개별적으로 지정되며 해당 방법에 대한 페이지에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f18c27c755e3d523b6ee9b1a4ff90851869085a" translate="yes" xml:space="preserve">
          <source>If you set an item to &lt;code&gt;display:&lt;/code&gt;&lt;code&gt;contents&lt;/code&gt; the box it would normally create disappears, and the boxes of the child elements appear as if they have risen up a level. This means that children of a grid item can become grid items. Sound odd? Here is a simple example. In the following markup, I have a grid and the first item on the grid is set to span all three column tracks. It contains three nested items. As these items are not direct children, they don&amp;rsquo;t become part of the grid layout and so display using regular block layout.</source>
          <target state="translated">당신이 항목을 설정하면 &lt;code&gt;display:&lt;/code&gt; &lt;code&gt;contents&lt;/code&gt; 들은 레벨을 상승 것처럼 일반적으로 사라을 만들 것입니다 상자와 자식 요소의 상자가 나타납니다. 즉, 그리드 항목의 하위 항목이 그리드 항목이 될 수 있습니다. 이상한 소리? 다음은 간단한 예입니다. 다음 마크 업에는 그리드가 있으며 그리드의 첫 번째 항목은 세 열 트랙 모두에 걸쳐 설정됩니다. 세 개의 중첩 된 항목이 있습니다. 이러한 항목은 직접적인 자식이 아니므로 그리드 레이아웃의 일부가 아니므로 일반 블록 레이아웃을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1734b5e8a050a443e0f3f0f43ac05d49beddde96" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;unsafe&lt;/code&gt; then the alignment will be honoured even if it would cause such data loss.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 를 지정 하면 데이터 손실이 발생하더라도 정렬이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="06c4e879473c075c28f9e3f0c9abf2f4bb9d6c24" translate="yes" xml:space="preserve">
          <source>If you specify a shorthand property (e.g., &lt;a href=&quot;background&quot;&gt;&lt;code&gt;background&lt;/code&gt;&lt;/a&gt;), all of its longhand sub-properties that can be animated will be.</source>
          <target state="translated">속기 속성 (예 : &lt;a href=&quot;background&quot;&gt; &lt;code&gt;background&lt;/code&gt; &lt;/a&gt; ) 을 지정하면 애니메이션을 적용 할 수있는 모든 장기 하위 속성이됩니다.</target>
        </trans-unit>
        <trans-unit id="4236420af2128c4d71525e5e8fdc74a9fad4d5e3" translate="yes" xml:space="preserve">
          <source>If you specify both properties on a multicol container then &lt;code&gt;column-count&lt;/code&gt; will act as a maximum number of columns. Therefore the behaviour as described for column-width will happen, until the number of columns in column-count is reached. After this point no more columns will be drawn, and the extra space is distributed evenly between the existing columns, even if there is enough room for more columns of the specified &lt;code&gt;column-width&lt;/code&gt; size.</source>
          <target state="translated">멀티 콜 컨테이너에 두 속성을 모두 지정하면 &lt;code&gt;column-count&lt;/code&gt; 는 최대 열 수로 작동합니다. 따라서 column-count의 열 수에 도달 할 때까지 열 너비에 대해 설명 된 동작이 발생합니다. 이 시점 이후에는 더 이상 열이 그려지지 않으며 지정된 &lt;code&gt;column-width&lt;/code&gt; 크기의 열이 더 충분한 공간이 있어도 기존 열 사이에 여분의 공간이 고르게 분산됩니다 .</target>
        </trans-unit>
        <trans-unit id="a62d4555def9eca3ea87e5c8d641ffc4f847f8f8" translate="yes" xml:space="preserve">
          <source>If you take a look at this layout in the Firefox Grid Highlighter you can see how the column lines are shown, and how our items are placed against these lines.</source>
          <target state="translated">Firefox Grid Highlighter에서이 레이아웃을 살펴보면 열 줄이 표시되는 방법과 이러한 줄에 대한 항목이 어떻게 배치되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d184e563a2c3cce3eabdc9416c4b5e097c88a8" translate="yes" xml:space="preserve">
          <source>If you then declare &lt;code&gt;display: flex&lt;/code&gt; on the parent item, these anonymous boxes do not get created and so your item remains a direct child and can become a flex item &amp;mdash; losing any of the table display features.</source>
          <target state="translated">그런 다음 상위 항목에 &lt;code&gt;display: flex&lt;/code&gt; 를 선언하면 이러한 익명 상자가 생성되지 않으므로 항목은 직계 하위 항목으로 유지되어 유동 항목이 될 수 있으므로 테이블 표시 기능이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ec75b051cb19be16731cb26f2cc68e5ec3e051d9" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;background-size&quot;&gt;&lt;code&gt;background-size&lt;/code&gt;&lt;/a&gt; to specify fixed lengths for both dimensions, those lengths are always used, per rule 1 above. In other words, the image will always get stretched to the dimensions you specify, regardless of whether or not the source image has specified its dimensions and/or aspect ratio.</source>
          <target state="translated">&lt;a href=&quot;background-size&quot;&gt; &lt;code&gt;background-size&lt;/code&gt; &lt;/a&gt; 를 사용하여 두 차원에 고정 길이를 지정 하면 위의 규칙 1에 따라 해당 길이가 항상 사용됩니다. 즉, 소스 이미지의 크기 및 / 또는 종횡비를 지정했는지 여부에 관계없이 이미지는 항상 지정한 크기로 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="833edff02410a8e60f2407f5ef6e0fe17b70d39d" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;display: table-cell&lt;/code&gt; on an item in your HTML it takes on the styling of an HTML table cell. CSS creates anonymous boxes to represent these items so that you do not need to wrap each item in a wrapper to represent the HTML table row, and a second one to represent the table element itself, You can&amp;rsquo;t see or style these anonymous boxes; they are there purely to fix up the tree.</source>
          <target state="translated">HTML의 항목에서 &lt;code&gt;display: table-cell&lt;/code&gt; 을 사용 하면 HTML 표 셀의 스타일이 적용됩니다. CSS는 이러한 항목을 나타내는 익명의 상자를 만들어 HTML 테이블 행을 나타 내기 위해 래퍼로 각 항목을 래핑 할 필요가없고, 테이블 요소 자체를 나타내는 두 번째 항목은 익명 상자를 보거나 스타일을 지정할 수 없습니다. 그들은 순전히 나무를 고치기 위해 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1d49d3a41e361f367a7b296779779c66acdd1f" translate="yes" xml:space="preserve">
          <source>If you use a &lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt; as the background and specify a &lt;code&gt;background-size&lt;/code&gt; to go with it, it's best not to specify a size that uses a single &lt;code&gt;auto&lt;/code&gt; component, or is specified using only a width value (for example, &lt;code&gt;background-size: 50%&lt;/code&gt;). Rendering of &lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt;s in such cases changed in Firefox 8, and at present is generally inconsistent across browsers, which do not all implement rendering in full accordance with &lt;a href=&quot;http://www.w3.org/TR/css3-background/#the-background-size&quot;&gt;the CSS3 &lt;code&gt;background-size&lt;/code&gt; specification&lt;/a&gt; and with &lt;a href=&quot;http://dev.w3.org/csswg/css3-images/#gradients&quot;&gt;the CSS3 Image Values gradient specification&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt; 배경으로하고 지정 &lt;code&gt;background-size&lt;/code&gt; , 그것은 크기를 지정하지 않는 것이 좋습니다 함께 갈을 것을 사용하는 단일 &lt;code&gt;auto&lt;/code&gt; 구성 요소 또는 단지 폭 값을 사용하여 지정됩니다 (예를 들어, &lt;code&gt;background-size: 50%&lt;/code&gt; ). 이러한 경우 &lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt; 의 렌더링은 Firefox 8에서 변경되었으며, 현재는 브라우저에서 일관되지 않으며 &lt;a href=&quot;http://www.w3.org/TR/css3-background/#the-background-size&quot;&gt;, CSS3 &lt;code&gt;background-size&lt;/code&gt; 사양&lt;/a&gt; 및 &lt;a href=&quot;http://dev.w3.org/csswg/css3-images/#gradients&quot;&gt;CSS3 이미지 값 그라데이션 사양에&lt;/a&gt; 따라 렌더링을 완전히 구현하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c1254e4953c455f2e22d20b89360cbf034a487" translate="yes" xml:space="preserve">
          <source>If you use a sibling selector such as &lt;code&gt;:visited + span&lt;/code&gt;, the adjacent element (&lt;code&gt;span&lt;/code&gt; in this example) will be styled as if the link were unvisited.</source>
          <target state="translated">&lt;code&gt;:visited + span&lt;/code&gt; 과 같은 형제 선택기를 사용하는 경우, 링크를 방문하지 않은 것처럼 인접 요소 ( 이 예에서는 &lt;code&gt;span&lt;/code&gt; )의 스타일이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7705e01007c712d0718fd5a5cfcfea0eff4f90b" translate="yes" xml:space="preserve">
          <source>If you use absolute positioning within a grid area, then you will again be using physical offsets to push the item around inside the grid area. The key thing is to be aware of, is the tension between physical and logical properties and values. For example, be aware that you may need to make changes to your CSS to cope with a switch from &lt;code&gt;ltr&lt;/code&gt; to &lt;code&gt;rtl&lt;/code&gt;.</source>
          <target state="translated">격자 영역 내에서 절대 위치를 사용하는 경우 다시 물리적 오프셋을 사용하여 격자 영역 내부로 항목을 밀어 넣습니다. 중요한 것은 물리적, 논리적 특성과 가치 사이의 긴장입니다. 예를 들어 &lt;code&gt;ltr&lt;/code&gt; 에서 &lt;code&gt;rtl&lt;/code&gt; 로의 전환에 대처하기 위해 CSS를 변경해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f79f36687b2619f2268a7bb7e4ca5067d3f0c32b" translate="yes" xml:space="preserve">
          <source>If you use viewport length units in your CSS within the iframe document, &lt;code&gt;1vh&lt;/code&gt; will be 1% of the height of the iFrame, and &lt;code&gt;1vw&lt;/code&gt; will be 1% of the width of the document.</source>
          <target state="translated">CSS에서 iframe 문서 내에서 뷰포트 길이 단위를 사용하는 경우 &lt;code&gt;1vh&lt;/code&gt; 는 iFrame 높이의 1 %가되고 &lt;code&gt;1vw&lt;/code&gt; 는 문서 너비의 1 %가됩니다.</target>
        </trans-unit>
        <trans-unit id="b2eb112d8d8e9ef904f4b9fabffa765c8ce5e700" translate="yes" xml:space="preserve">
          <source>If you want an image to size down to fit the column box, the standard responsive images solution of setting &lt;code&gt;max-width: 100%&lt;/code&gt; will achieve that for you.</source>
          <target state="translated">열 상자에 맞게 이미지의 크기를 줄이려면 &lt;code&gt;max-width: 100%&lt;/code&gt; 를 설정하는 표준 반응 형 이미지 솔루션을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="cb4f3d49fb49e187857d47d69bc92342e6e6f39f" translate="yes" xml:space="preserve">
          <source>If you want apply multiple transformations to an element, be careful about the order in which you specify your transformations. For example, if you rotate before translating, the translation will be along the new axis of rotation!</source>
          <target state="translated">요소에 여러 변환을 적용하려면 변환을 지정하는 순서에주의하십시오. 예를 들어, 번역하기 전에 회전하면 번역이 새 회전축을 따라 이동합니다!</target>
        </trans-unit>
        <trans-unit id="ad66834034e18104eb99fc256b509db3cd9b5ea4" translate="yes" xml:space="preserve">
          <source>If you want flexbox to completely ignore the size of the item when doing space distribution then set &lt;code&gt;flex-basis&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;. This essentially tells flexbox that all the space is up for grabs, and to share it out in proportion. We will see examples of this as we move on to look at &lt;code&gt;flex-grow&lt;/code&gt;.</source>
          <target state="translated">공간 분배를 수행 할 때 flexbox가 항목의 크기를 완전히 무시하도록하려면 &lt;code&gt;flex-basis&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 . 이것은 본질적으로 모든 공간이 횡령하고 그것을 비례 적으로 공유하도록 flexbox에 알려줍니다. &lt;code&gt;flex-grow&lt;/code&gt; 를 살펴보면서 이에 대한 예제를 보게 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b6dcae105cc33d09ef8fc37775d86c9e8565a133" translate="yes" xml:space="preserve">
          <source>If you want layout in two dimensions then you probably want Grid Layout. We can compare our wrapped row example above with the CSS Grid version of that layout to see the difference. The following live sample uses CSS Grid Layout to create a layout that has as many columns of at least 160 pixels as will fit, distributing the extra space between all columns. However, in this case the items stay in their grid and don&amp;rsquo;t stretch out when there are fewer of them on the final row.</source>
          <target state="translated">2 차원으로 레이아웃을 원한다면 그리드 레이아웃이 필요할 것입니다. 위의 래핑 된 행 예제를 해당 레이아웃의 CSS 그리드 버전과 비교하여 차이점을 확인할 수 있습니다. 다음 라이브 샘플은 CSS 그리드 레이아웃을 사용하여 최소 160 픽셀의 열을 가진 레이아웃을 만들어 모든 열 사이에 추가 공간을 분배합니다. 그러나이 경우 항목은 그리드에 유지되고 마지막 행에 적은 수의 항목이있을 때는 늘어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7374ec4c88074a8de190a53ec1d58a11bc2781db" translate="yes" xml:space="preserve">
          <source>If you want more control over its direction, you can give the gradient a specific angle.</source>
          <target state="translated">방향을보다 세밀하게 제어하려면 그라디언트에 특정 각도를 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6bd252161ade18f42e25d63694adf5bd32475d8" translate="yes" xml:space="preserve">
          <source>If you want to give all of the lines in your grid a unique name then you will need to write out the track definition long-hand rather than using the repeat syntax, as you need to add the name in square brackets while defining the tracks. If you do use the repeat syntax you will end up with multiple lines that have the same name, however this can be very useful too.</source>
          <target state="translated">모눈의 모든 선에 고유 한 이름을 지정하려면 트랙을 정의하는 동안 대괄호 안에 이름을 추가해야하므로 반복 구문을 사용하지 않고 트랙 정의를 길게 작성해야합니다. 반복 구문을 사용하면 이름이 같은 여러 줄이 생길 수 있지만 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51bc525cb7cbc5e8f3db33e53feb1a46aa3eddff" translate="yes" xml:space="preserve">
          <source>If you want to include very old browsers with flexbox support then you can include the vendor prefixes in your CSS in addition to the unprefixed version. This is becoming less and less of a requirement today as support is widespread.</source>
          <target state="translated">flexbox를 지원하는 매우 오래된 브라우저를 포함 시키려면 접두사없는 버전 외에 CSS에 공급 업체 접두사를 포함시킬 수 있습니다. 지원이 널리 보급됨에 따라 오늘날 요구 사항이 점점 줄어들고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6e96137836133a9434e33d8f661ba80198ca1e0" translate="yes" xml:space="preserve">
          <source>If you want to see how these work, with a right to left as well as top to bottom writing mode, switch &lt;code&gt;vertical-lr&lt;/code&gt; to &lt;code&gt;vertical-rl&lt;/code&gt;, which is a vertical writing mode running from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 그리고 위에서 아래로 쓰기 모드를 사용하여 이러한 작동 방식을 확인하려면 &lt;code&gt;vertical-lr&lt;/code&gt; 을 &lt;code&gt;vertical-rl&lt;/code&gt; 로 전환하십시오 . 이것은 수직 쓰기 모드로 오른쪽에서 왼쪽으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="db1d1f9916116afe23573c30ab224c380aea9784" translate="yes" xml:space="preserve">
          <source>If you want to visually hide the element, a more accessible alternative is to use &lt;a href=&quot;https://gomakethings.com/hidden-content-for-better-a11y/#hiding-the-link&quot;&gt;a combination of properties&lt;/a&gt; to remove it visually from the screen but keep it parseable by assistive technology such as screen readers.</source>
          <target state="translated">요소를 시각적으로 숨기려면 &lt;a href=&quot;https://gomakethings.com/hidden-content-for-better-a11y/#hiding-the-link&quot;&gt;속성 조합&lt;/a&gt; 을 사용 하여 화면에서 시각적으로 제거하지만 화면 판독기와 같은 보조 기술을 통해 구문 분석 할 수 있도록하는 것이 더 접근하기 쉬운 대안입니다 .</target>
        </trans-unit>
        <trans-unit id="120217b5cf4376406ba0ba55da68f08faa8653bd" translate="yes" xml:space="preserve">
          <source>If you were in a vertical writing mode then &lt;a href=&quot;../inline-size&quot;&gt;&lt;code&gt;inline-size&lt;/code&gt;&lt;/a&gt; would be mapped to &lt;a href=&quot;../height&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세로 쓰기 모드에 있으면 &lt;a href=&quot;../inline-size&quot;&gt; &lt;code&gt;inline-size&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../height&quot;&gt; &lt;code&gt;height&lt;/code&gt; 에&lt;/a&gt; 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa2036a2790f2a9920f40f7406dbb206e1338065" translate="yes" xml:space="preserve">
          <source>If you were using a &lt;code&gt;horizontal-tb&lt;/code&gt; writing mode with a right-to-left text direction then &lt;a href=&quot;../margin-inline-start&quot;&gt;&lt;code&gt;margin-inline-start&lt;/code&gt;&lt;/a&gt; would be the same as &lt;a href=&quot;../margin-right&quot;&gt;&lt;code&gt;margin-right&lt;/code&gt;&lt;/a&gt;, and in a vertical writing mode it would be the same as using &lt;a href=&quot;../margin-top&quot;&gt;&lt;code&gt;margin-top&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신은 사용한 경우 &lt;code&gt;horizontal-tb&lt;/code&gt; 으로 쓰기 모드를 오른쪽에서 왼쪽으로 텍스트 방향 다음 &lt;a href=&quot;../margin-inline-start&quot;&gt; &lt;code&gt;margin-inline-start&lt;/code&gt; &lt;/a&gt; 같은 것 &lt;a href=&quot;../margin-right&quot;&gt; &lt;code&gt;margin-right&lt;/code&gt; &lt;/a&gt; , 그리고 세로 쓰기 모드로 사용과 같은 것 &lt;a href=&quot;../margin-top&quot;&gt; &lt;code&gt;margin-top&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af0ad67d0b1a0f6524d2d9f81b12f95657c5c8e6" translate="yes" xml:space="preserve">
          <source>If you wish to prevent the stack from resizing automatically to accommodate its children, you can set &lt;code&gt;-moz-stack-sizing&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt; on the child element. The property is set not on the stack itself, but on the stack's children. This lets you ignore certain children, but not others.</source>
          <target state="translated">하위 요소 를 수용하기 위해 스택의 크기가 자동으로 조정되지 않도록 하려면 하위 요소에서 &lt;code&gt;-moz-stack-sizing&lt;/code&gt; 을 &lt;code&gt;ignore&lt;/code&gt; 하도록 설정할 수 있습니다 . 이 속성은 스택 자체가 아니라 스택의 자식에 설정됩니다. 이를 통해 특정 어린이는 무시할 수 있지만 다른 어린이는 무시할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="430efb59163ede887d6e02788eb2fbf02c27dabe" translate="yes" xml:space="preserve">
          <source>If you're more interested in following the Internet Explorer/Opera model, then:</source>
          <target state="translated">Internet Explorer / Opera 모델을 따르는 데 더 관심이 있다면 :</target>
        </trans-unit>
        <trans-unit id="a1da3cff9db238fd4ea5e9eed38a256926a92f3b" translate="yes" xml:space="preserve">
          <source>If your JavaScript is listening for scroll wheel Document Object Model (DOM) events, the events that occur when the user scrolls vertically will always be vertical scroll events, not horizontal scroll events. Similarly, the events that occur when the user scrolls horizontally will always be horizontal scroll events. This property enables you to change this behavior for vertical scroll events. By setting the &lt;code&gt;-ms-scroll-translation&lt;/code&gt; property to &lt;code&gt;vertical-to-horizontal&lt;/code&gt;, you are specifying that vertical scroll events should be interpreted as their corresponding horizontal scroll events.</source>
          <target state="translated">JavaScript가 스크롤 휠 DOM (문서 객체 모델) 이벤트를 수신하는 경우 사용자가 세로로 스크롤 할 때 발생하는 이벤트는 항상 가로 스크롤 이벤트가 아니라 세로 스크롤 이벤트입니다. 마찬가지로 사용자가 가로로 스크롤 할 때 발생하는 이벤트는 항상 가로 스크롤 이벤트입니다. 이 속성을 사용하면 세로 스크롤 이벤트에 대한이 동작을 변경할 수 있습니다. 설정에 따라 &lt;code&gt;-ms-scroll-translation&lt;/code&gt; 에 재산을 &lt;code&gt;vertical-to-horizontal&lt;/code&gt; , 당신은 수직 스크롤 이벤트가 해당 수평 스크롤 이벤트로 해석되어야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6b3ddb65024de0974b79332af6b8dabe73e8fc29" translate="yes" xml:space="preserve">
          <source>If your browser does not yet support these keywords both paragraphs will be rendered as normal paragraphs in block flow; the below screenshots show the expected rendering.</source>
          <target state="translated">브라우저가이 키워드를 아직 지원하지 않으면 두 단락 모두 블록 흐름에서 일반 단락으로 렌더링됩니다. 아래 스크린 샷은 예상 렌더링을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a9e64d8f958370adcf6a47e827db1033dd119b17" translate="yes" xml:space="preserve">
          <source>If your browser supports it, the above example will render a list like this:</source>
          <target state="translated">브라우저가 지원하는 경우 위 예제는 다음과 같은 목록을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8d83833c2c17204ee604e3f88956a109af17a270" translate="yes" xml:space="preserve">
          <source>If your item is instead auto-sized, then &lt;code&gt;auto&lt;/code&gt; resolves to the size of its content. At this point your knowledge of &lt;code&gt;min-&lt;/code&gt; and &lt;code&gt;max-content&lt;/code&gt; sizing becomes useful, as flexbox will take the &lt;code&gt;max-content&lt;/code&gt; size of the item as the &lt;code&gt;flex-basis&lt;/code&gt;. The following live example can help to demonstrate this.</source>
          <target state="translated">항목의 크기가 자동으로 조정되면 &lt;code&gt;auto&lt;/code&gt; 으로 해당 내용의 크기로 확인됩니다. 이 시점 에서 flexbox는 &lt;code&gt;flex-basis&lt;/code&gt; 로 항목 의 &lt;code&gt;max-content&lt;/code&gt; 크기를 가져 오기 때문에 &lt;code&gt;min-&lt;/code&gt; 및 &lt;code&gt;max-content&lt;/code&gt; 크기에 대한 지식 이 유용 합니다 . 다음 라이브 예제는이를 설명하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b26a4d706516ec3a369c510b80c8c6a2ca24150" translate="yes" xml:space="preserve">
          <source>If your items were links or some other element that the user could tab to, then the tabbing order would be the order that these items appear in the document source &amp;mdash; not your visual order.</source>
          <target state="translated">항목이 링크 또는 사용자가 탭할 수있는 다른 요소 인 경우 탭 순서는 이러한 항목이 시각적 순서가 아닌 문서 소스에 나타나는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="d681257b6bf1444bfc7cc882b415d5ef34b71c7e" translate="yes" xml:space="preserve">
          <source>If your main axis is &lt;code&gt;column&lt;/code&gt; or &lt;code&gt;column-reverse&lt;/code&gt; then the cross axis runs along the rows.</source>
          <target state="translated">기본 축이 &lt;code&gt;column&lt;/code&gt; 또는 &lt;code&gt;column-reverse&lt;/code&gt; 경우 교차 축이 행을 따라 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4a658b405f5671c6c941cfbc9079ef323d90be54" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;!important&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;!important&lt;/code&gt; 선언 무시</target>
        </trans-unit>
        <trans-unit id="6146030e455e4f055e4c78cf998f145ddd4ce458" translate="yes" xml:space="preserve">
          <source>Illustrated description of the 1-to-4-value syntax</source>
          <target state="translated">1에서 4까지의 값 구문에 대한 설명</target>
        </trans-unit>
        <trans-unit id="df33417ca4673ec00c912326634d1b5271f3e711" translate="yes" xml:space="preserve">
          <source>Illustration</source>
          <target state="translated">Illustration</target>
        </trans-unit>
        <trans-unit id="43f43afcaa6bb04be469a0fc09d4b90c270ca2f7" translate="yes" xml:space="preserve">
          <source>Image combined with text</source>
          <target state="translated">텍스트와 결합 된 이미지</target>
        </trans-unit>
        <trans-unit id="b6081c354449ae71a72ab350483b8c4630f71f2c" translate="yes" xml:space="preserve">
          <source>Image gallery</source>
          <target state="translated">이미지 갤러리</target>
        </trans-unit>
        <trans-unit id="337a7827990a4e72f47079b050a082c3a0599aec" translate="yes" xml:space="preserve">
          <source>Image reference to use for the border.</source>
          <target state="translated">테두리에 사용할 이미지 참조</target>
        </trans-unit>
        <trans-unit id="cd3b3065a2df42e1f5c530cfcf7e7f4a68a90119" translate="yes" xml:space="preserve">
          <source>Image reference to use for the mask border.</source>
          <target state="translated">마스크 테두리에 사용할 이미지 참조</target>
        </trans-unit>
        <trans-unit id="6ae89c7f31fe68afd0052be4204a1384141e4bde" translate="yes" xml:space="preserve">
          <source>Image types</source>
          <target state="translated">이미지 유형</target>
        </trans-unit>
        <trans-unit id="2fd660279df3199785c259f28542d3e12b02c341" translate="yes" xml:space="preserve">
          <source>Image-related data types: &lt;a href=&quot;image&quot;&gt;&lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;gradient&quot;&gt;&lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이미지 관련 데이터 유형 : &lt;a href=&quot;image&quot;&gt; &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;gradient&quot;&gt; &lt;code&gt;&amp;lt;gradient&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31c80169f2acd92562e3c959ee46303fbe32fc19" translate="yes" xml:space="preserve">
          <source>Image-related functions: &lt;a href=&quot;linear-gradient&quot;&gt;&lt;code&gt;linear-gradient()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;radial-gradient&quot;&gt;&lt;code&gt;radial-gradient()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;repeating-linear-gradient&quot;&gt;&lt;code&gt;repeating-linear-gradient()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;repeating-radial-gradient&quot;&gt;&lt;code&gt;repeating-radial-gradient()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;element()&quot;&gt;&lt;code&gt;element()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이미지 관련 함수 : &lt;a href=&quot;linear-gradient&quot;&gt; &lt;code&gt;linear-gradient()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;radial-gradient&quot;&gt; &lt;code&gt;radial-gradient()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;repeating-linear-gradient&quot;&gt; &lt;code&gt;repeating-linear-gradient()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;repeating-radial-gradient&quot;&gt; &lt;code&gt;repeating-radial-gradient()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;element()&quot;&gt; &lt;code&gt;element()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="0642b3a749073fb598afe8da6e135e0022eb08f1" translate="yes" xml:space="preserve">
          <source>Images and element attributes</source>
          <target state="translated">이미지 및 요소 속성</target>
        </trans-unit>
        <trans-unit id="1b389912ce30ed8eb43619c4a37fb692a39489fc" translate="yes" xml:space="preserve">
          <source>Images with &lt;em&gt;intrinsic dimensions&lt;/em&gt; (a natural size), like a JPEG, PNG, or other &lt;a href=&quot;https://en.wikipedia.org/wiki/Raster_graphics&quot;&gt;raster format&lt;/a&gt;.</source>
          <target state="translated">JPEG, PNG 또는 기타 &lt;a href=&quot;https://en.wikipedia.org/wiki/Raster_graphics&quot;&gt;래스터 형식&lt;/a&gt; 과 같은 &lt;em&gt;고유 크기&lt;/em&gt; (자연 크기)의 이미지 .</target>
        </trans-unit>
        <trans-unit id="1e3b40f82c43b451955388227907a1edcac57cc7" translate="yes" xml:space="preserve">
          <source>Images with &lt;em&gt;multiple intrinsic dimensions&lt;/em&gt;, existing in multiple versions inside a single file, like some .ico formats. (In this case, the intrinsic dimensions will be those of the image largest in area and the aspect ratio most similar to the containing box.)</source>
          <target state="translated">&lt;em&gt;여러&lt;/em&gt; .ico 형식과 같이 단일 파일 내에 여러 버전으로 존재하는 &lt;em&gt;여러 고유 크기를&lt;/em&gt; 가진 이미지 . (이 경우 고유 크기는 면적이 가장 큰 이미지와 포함 상자와 가장 유사한 종횡비의 크기입니다.)</target>
        </trans-unit>
        <trans-unit id="4b628a0fc6a9e1d5f41120b2738a5653b7deb729" translate="yes" xml:space="preserve">
          <source>Images with &lt;em&gt;neither intrinsic dimensions, nor an intrinsic aspect ratio&lt;/em&gt;, like a CSS gradient.</source>
          <target state="translated">CSS 그래디언트와 같이 &lt;em&gt;고유 치수 나 고유 종횡비&lt;/em&gt; 가 &lt;em&gt;없는&lt;/em&gt; 이미지</target>
        </trans-unit>
        <trans-unit id="318d36ae9d6c6f3bdb09df6cf228159edecb4f33" translate="yes" xml:space="preserve">
          <source>Images with no intrinsic dimensions but with &lt;em&gt;an intrinsic aspect ratio&lt;/em&gt; between its width and height, like an SVG or other &lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_graphics&quot;&gt;vector format&lt;/a&gt;.</source>
          <target state="translated">SVG 또는 기타 &lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_graphics&quot;&gt;벡터 형식&lt;/a&gt; 과 같이 고유 치수는 없지만 너비와 높이 사이 &lt;em&gt;의 고유 종횡비를&lt;/em&gt; 가진 이미지 .</target>
        </trans-unit>
        <trans-unit id="fdc0d8927166935729f6df6dd954ee54f0823464" translate="yes" xml:space="preserve">
          <source>Impact on web developers</source>
          <target state="translated">웹 개발자에게 미치는 영향</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3bd452896133ede07f5d2b54fbbd4b9ddbf60e79" translate="yes" xml:space="preserve">
          <source>Implemented as an alias for for &lt;code&gt;-moz-device-pixel-ratio&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-moz-device-pixel-ratio&lt;/code&gt; 의 별명으로 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="40ce8a5e137482a85a63821cf4d7b571e107a6cf" translate="yes" xml:space="preserve">
          <source>Implemented as an alias for for &lt;code&gt;max--moz-device-pixel-ratio&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max--moz-device-pixel-ratio&lt;/code&gt; 에 대한 별칭으로 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="be2485819e9ed84579ef93185e81188295006724" translate="yes" xml:space="preserve">
          <source>Implemented as an alias for for &lt;code&gt;min--moz-device-pixel-ratio&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min--moz-device-pixel-ratio&lt;/code&gt; 에 대한 별칭으로 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3fbc556882f0619a55468eaf42a495204f22c5ab" translate="yes" xml:space="preserve">
          <source>Implementing image sprites in CSS</source>
          <target state="translated">CSS에서 이미지 스프라이트 구현</target>
        </trans-unit>
        <trans-unit id="f17a523b4dd09629200c63379446725b6055c380" translate="yes" xml:space="preserve">
          <source>Implicit Grid lines from named areas</source>
          <target state="translated">명명 된 영역의 암시 적 그리드 선</target>
        </trans-unit>
        <trans-unit id="9b457abbb70d22bd366275d756b949a40abbaf05" translate="yes" xml:space="preserve">
          <source>Implicit definition.</source>
          <target state="translated">암시 적 정의.</target>
        </trans-unit>
        <trans-unit id="a353686c0928b9da20ee92b711e6c7c094262668" translate="yes" xml:space="preserve">
          <source>Implicit definition; allows 4-digit Unicode escaped characters.</source>
          <target state="translated">암시 적 정의; 4 자리 유니 코드 이스케이프 문자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="020a0c6286d1962f2d8dc812e47646bdd6953b21" translate="yes" xml:space="preserve">
          <source>Implicit grid areas from named lines</source>
          <target state="translated">명명 된 라인의 암시 적 그리드 영역</target>
        </trans-unit>
        <trans-unit id="f0458df90581813377e1da5ffc07d541fc076bda" translate="yes" xml:space="preserve">
          <source>Importance</source>
          <target state="translated">Importance</target>
        </trans-unit>
        <trans-unit id="d6d17215dd64f3f9eb2f23ecdcae867aae8dd6e2" translate="yes" xml:space="preserve">
          <source>Important concepts when working on the main axis</source>
          <target state="translated">주축 작업시 중요한 개념</target>
        </trans-unit>
        <trans-unit id="dd9e30a1df312f79a3ffc42ad747144f0d0d1a46" translate="yes" xml:space="preserve">
          <source>Important methods</source>
          <target state="translated">중요한 방법</target>
        </trans-unit>
        <trans-unit id="4f3f86753c3eda01d7cab7c5988a1122724f0558" translate="yes" xml:space="preserve">
          <source>Importantly, certain characters which would otherwise be invalid can be escaped with a backslash. These include double quotes when used inside a double-quoted string, single quotes when used inside a single-quoted string, and the backslash itself. For example, &lt;code&gt;\\&lt;/code&gt; will create a single backslash.</source>
          <target state="translated">중요하지 않으면 유효하지 않은 특정 문자는 백 슬래시로 이스케이프 할 수 있습니다. 여기에는 큰 따옴표로 묶인 문자열 안에 사용될 때 큰 따옴표, 작은 따옴표로 묶인 문자열 안에 사용될 때 작은 따옴표 및 백 슬래시 자체가 포함됩니다. 예를 들어, &lt;code&gt;\\&lt;/code&gt; 는 단일 백 슬래시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="601ff8a1e99540ac9f69386c607e351d4a820ed6" translate="yes" xml:space="preserve">
          <source>Improving compatibility with older browsers</source>
          <target state="translated">이전 브라우저와의 호환성 향상</target>
        </trans-unit>
        <trans-unit id="eb37490f4b4422ce977d65884e5b68ed897c4149" translate="yes" xml:space="preserve">
          <source>In 3D space, rotations have three degrees of liberty, which together describe a single axis of rotation. The axis of rotation is defined by an [x, y, z] vector and pass by the origin (as defined by the &lt;a href=&quot;../transform-origin&quot;&gt;&lt;code&gt;transform-origin&lt;/code&gt;&lt;/a&gt; property). If, as specified, the vector is not &lt;em&gt;normalized&lt;/em&gt; (i.e., if the sum of the square of its three coordinates is not 1), the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; will normalize it internally. A non-normalizable vector, such as the null vector, [0, 0, 0], will cause the rotation to be ignored, but without invaliding the whole CSS property.</source>
          <target state="translated">3D 공간에서 회전의 자유도는 3도이며, 단일 회전축을 함께 설명합니다. 회전축은 [x, y, z] 벡터로 정의되고 원점을 통과합니다 ( &lt;a href=&quot;../transform-origin&quot;&gt; &lt;code&gt;transform-origin&lt;/code&gt; &lt;/a&gt; 속성 으로 정의 ). 지정된대로 벡터가 &lt;em&gt;정규화&lt;/em&gt; 되지 않은 경우 (즉, 세 좌표의 제곱의 합이 1이 아닌 경우) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 는 벡터를 내부적으로 정규화합니다. null 벡터 인 [0, 0, 0]과 같이 정규화 할 수없는 벡터는 회전을 무시하지만 전체 CSS 속성을 무효화하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="877dffe68dcc6507b642b1fa95f86bb786ef2a0b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML5&quot;&gt;HTML5&lt;/a&gt;, known &lt;a href=&quot;https://html.spec.whatwg.org/#foreign-elements&quot;&gt;foreign elements&lt;/a&gt; will be automatically be assigned namespaces. This means that HTML elements will act as though they are in the XHTML namespace (&lt;code&gt;http://www.w3.org/1999/xhtml&lt;/code&gt;), even if there is no &lt;code&gt;xmlns&lt;/code&gt; attribute anywhere in the document, and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg&quot;&gt;&amp;lt;svg&amp;gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math&quot;&gt;&amp;lt;math&amp;gt;&lt;/a&gt; elements will be assigned their proper namespaces (&lt;code&gt;http://www.w3.org/2000/svg&lt;/code&gt; and &lt;code&gt;http://www.w3.org/1998/Math/MathML&lt;/code&gt;).</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML5&quot;&gt;HTML5&lt;/a&gt; 알려진 &lt;a href=&quot;https://html.spec.whatwg.org/#foreign-elements&quot;&gt;외국 요소는&lt;/a&gt; 자동으로 할당 된 네임 스페이스 될 것입니다. HTML 요소들이 XHTML 네임 스페이스 (에있는 것처럼 역할을 할 것을이 수단 &lt;code&gt;http://www.w3.org/1999/xhtml&lt;/code&gt; ) 더있는 경우에도, &lt;code&gt;xmlns&lt;/code&gt; 하여 문서의 아무 곳이나 속성없고, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg&quot;&gt;&amp;lt;SVG&amp;gt;&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math&quot;&gt;&amp;lt; math&amp;gt;&lt;/a&gt; 요소에는 올바른 네임 스페이스가 할당됩니다 ( &lt;code&gt;http://www.w3.org/2000/svg&lt;/code&gt; 및 &lt;code&gt;http://www.w3.org/1998/Math/MathML&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d354c41279b3de6edd6d07f8b2737b1c342403b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt;, a &lt;strong&gt;replaced element&lt;/strong&gt; is an element whose representation is outside the scope of CSS; they're external objects whose representation is independent of the CSS formatting model.</source>
          <target state="translated">에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 하는 &lt;strong&gt;대체 요소&lt;/strong&gt; 그 CSS 표현의 범위 외부에있는 요소이고; 그것들은 표현이 CSS 형식화 모델과 무관 한 외부 객체입니다.</target>
        </trans-unit>
        <trans-unit id="72e458a1ba637c9e2db7410d5056b350ac1f05fe" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt;, use the &lt;a href=&quot;@media&quot;&gt;&lt;code&gt;@media&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;at-rule&quot;&gt;at-rule&lt;/a&gt; to conditionally apply part of a style sheet based on the result of a media query. Use &lt;a href=&quot;@import&quot;&gt;&lt;code&gt;@import&lt;/code&gt;&lt;/a&gt; to conditionally apply an entire style sheet.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 의 사용 &lt;a href=&quot;@media&quot;&gt; &lt;code&gt;@media&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;at-rule&quot;&gt; 에서 규칙을&lt;/a&gt; 조건부로 미디어 쿼리의 결과에 따라 스타일 시트의 일부를 적용합니다. 전체 스타일 시트를 조건부로 적용 하려면 &lt;a href=&quot;@import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ace2ab649cc86e828e2596313a3f73a6f2bb59b0" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;, media queries can be applied to various elements:</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; , 미디어 쿼리는 다양한 요소에 적용 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d33862ea9ca59e279f7b5c197f1ebab5545aefb3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia&quot;&gt;&lt;code&gt;Window.matchMedia()&lt;/code&gt;&lt;/a&gt; method to test the window against a media query. You can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener&quot;&gt;&lt;code&gt;MediaQueryList.addListener()&lt;/code&gt;&lt;/a&gt; to be notified whenever the state of a query changes. With this functionality, your site or app can respond to changes in the device configuration, orientation, or state.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia&quot;&gt; &lt;code&gt;Window.matchMedia()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 미디어 쿼리에 대해 창을 테스트 할 수 있습니다 . 쿼리 상태가 변경 될 때마다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener&quot;&gt; &lt;code&gt;MediaQueryList.addListener()&lt;/code&gt; &lt;/a&gt; 를 사용하여 알림을받을 수도 있습니다 . 이 기능을 사용하면 사이트 또는 앱이 장치 구성, 방향 또는 상태 변경에 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79dfb5b11044ebd5b2e61a6f525d822d084edb50" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;relative&lt;/em&gt;&lt;em&gt; positioning&lt;/em&gt;, triggered by the value &lt;code&gt;relative&lt;/code&gt; of the &lt;a href=&quot;position&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; property, the boxes are drawn with an offset defined by the &lt;a href=&quot;top&quot;&gt;&lt;code&gt;top&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bottom&quot;&gt;&lt;code&gt;bottom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;right&quot;&gt;&lt;code&gt;right&lt;/code&gt;&lt;/a&gt; CSS properties.</source>
          <target state="translated">에서는 &lt;em&gt;상대 &lt;/em&gt;&lt;em&gt;위치&lt;/em&gt; 값에 의해 트리거, &lt;code&gt;relative&lt;/code&gt; 의 &lt;a href=&quot;position&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 속성 박스는 상기에서 정의 된 오프셋에 그려 &lt;a href=&quot;top&quot;&gt; &lt;code&gt;top&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bottom&quot;&gt; &lt;code&gt;bottom&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;right&quot;&gt; &lt;code&gt;right&lt;/code&gt; &lt;/a&gt; CSS 속성.</target>
        </trans-unit>
        <trans-unit id="a159af38771ca727aacf9a2b03d4e58148d6f332" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;static positioning&lt;/em&gt;, triggered by the value &lt;code&gt;static&lt;/code&gt; of the &lt;a href=&quot;position&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; property, the boxes are drawn at the exact position defined by the normal flow layout.</source>
          <target state="translated">에서는 &lt;em&gt;고정 위치&lt;/em&gt; 값에 의해 트리거, &lt;code&gt;static&lt;/code&gt; 의 &lt;a href=&quot;position&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 속성 상자는 통상 플로우 레이아웃에 의해 정의 된 정확한 위치에서 인출된다.</target>
        </trans-unit>
        <trans-unit id="bed2f9ee98a29addc81c6dd7441b38e2d5ff6251" translate="yes" xml:space="preserve">
          <source>In CSS (and most computer graphics), the origin &lt;code&gt;(0, 0)&lt;/code&gt; represents the&lt;em&gt; top-left&lt;/em&gt; corner of any element. Positive coordinates are down and to the right of the origin, while negative ones are up and to the left. Thus, a point that's 2 units to the right and 5 units down would be &lt;code&gt;(2, 5)&lt;/code&gt;, while a point 3 units to the left and 12 units up would be &lt;code&gt;(-3, -12)&lt;/code&gt;.</source>
          <target state="translated">CSS (및 대부분의 컴퓨터 그래픽)에서 원점 &lt;code&gt;(0, 0)&lt;/code&gt; 은 모든 요소의 &lt;em&gt;왼쪽&lt;/em&gt; 상단을 나타냅니다 . 양의 좌표는 원점의 오른쪽 아래에 있고 음의 좌표는 위쪽과 왼쪽에 있습니다. 따라서 오른쪽에 2 단위, 5 단위 아래에있는 점은 &lt;code&gt;(2, 5)&lt;/code&gt; 이고, 왼쪽에 3 단위, 12 단위 위에있는 점은 &lt;code&gt;(-3, -12)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbfbaf9da20d5a865aa32662977ce2d948cb07e0" translate="yes" xml:space="preserve">
          <source>In CSS Level 1, the &lt;code&gt;url()&lt;/code&gt; functional notation described only true URLs. In CSS Level 2, the definition of &lt;code&gt;url()&lt;/code&gt; was extended to describe any URI, whether a URL or a URN. Confusingly, this meant that &lt;code&gt;url()&lt;/code&gt; could be used to create a &lt;code&gt;&amp;lt;uri&amp;gt;&lt;/code&gt; CSS data type. This change was not only awkward but, debatably, unnecessary, since URNs are almost never used in actual CSS. To alleviate the confusion, CSS Level 3 returned to the narrower, initial definition. Now, &lt;code&gt;url()&lt;/code&gt; denotes only true &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;s.</source>
          <target state="translated">CSS 레벨 1에서 &lt;code&gt;url()&lt;/code&gt; 기능 표기법은 실제 URL 만 설명했습니다. CSS 레벨 2에서 &lt;code&gt;url()&lt;/code&gt; 정의 는 URL이든 URN이든 URI를 설명하기 위해 확장되었습니다. 혼란스럽게도 &lt;code&gt;url()&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;lt;uri&amp;gt;&lt;/code&gt; CSS 데이터 형식 을 만들 수있었습니다 . URN은 실제 CSS에서 거의 사용되지 않기 때문에이 변경은 어색 할뿐만 아니라 논쟁의 여지가 없지만 불필요합니다. 혼란을 완화하기 위해 CSS 레벨 3은 더 좁은 초기 정의로 돌아 왔습니다. 이제 &lt;code&gt;url()&lt;/code&gt; 은 true &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 만 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a607ebd720cd31c70488065832f556e502e0fc3b" translate="yes" xml:space="preserve">
          <source>In CSS, &lt;code&gt;::after&lt;/code&gt; creates a &lt;a href=&quot;pseudo-elements&quot;&gt;pseudo-element&lt;/a&gt; that is the last child of the selected element. It is often used to add cosmetic content to an element with the &lt;a href=&quot;content&quot;&gt;&lt;code&gt;content&lt;/code&gt;&lt;/a&gt; property. It is inline by default.</source>
          <target state="translated">CSS에서 &lt;code&gt;::after&lt;/code&gt; 는 선택한 요소의 마지막 자식 인 &lt;a href=&quot;pseudo-elements&quot;&gt;의사 요소&lt;/a&gt; 를 만듭니다 . &lt;a href=&quot;content&quot;&gt; &lt;code&gt;content&lt;/code&gt; &lt;/a&gt; 속성 을 가진 요소에 장식적인 내용을 추가하는 데 종종 사용됩니다 . 기본적으로 인라인입니다.</target>
        </trans-unit>
        <trans-unit id="6fcfc3b2e2fd2b79a1fa2bab5b9edda0ddeaa0e5" translate="yes" xml:space="preserve">
          <source>In CSS, &lt;code&gt;::before&lt;/code&gt; creates a &lt;a href=&quot;pseudo-elements&quot;&gt;pseudo-element&lt;/a&gt; that is the first child of the selected element. It is often used to add cosmetic content to an element with the &lt;a href=&quot;content&quot;&gt;&lt;code&gt;content&lt;/code&gt;&lt;/a&gt; property. It is inline by default.</source>
          <target state="translated">CSS에서 &lt;code&gt;::before&lt;/code&gt; 는 선택한 요소의 첫 번째 하위 &lt;a href=&quot;pseudo-elements&quot;&gt;요소 인 의사 요소&lt;/a&gt; 를 만듭니다 . &lt;a href=&quot;content&quot;&gt; &lt;code&gt;content&lt;/code&gt; &lt;/a&gt; 속성 을 가진 요소에 장식적인 내용을 추가하는 데 종종 사용됩니다 . 기본적으로 인라인입니다.</target>
        </trans-unit>
        <trans-unit id="ae016ebad623cdbec22bff6c82a3be0856f26d16" translate="yes" xml:space="preserve">
          <source>In CSS, &lt;strong&gt;inheritance&lt;/strong&gt; controls what happens when no value is specified for a property on an element. Refer to &lt;a href=&quot;css_reference&quot;&gt;any CSS property&lt;/a&gt; definition to see whether a specific property inherits by default (&quot;Inherited: yes&quot;) or not (&quot;Inherited: no&quot;).</source>
          <target state="translated">CSS에서 &lt;strong&gt;상속&lt;/strong&gt; 은 요소의 속성에 값이 지정되지 않은 경우 발생하는 상황을 제어합니다. 를 참조하지 &lt;a href=&quot;css_reference&quot;&gt;어떤 CSS 속성&lt;/a&gt; 여부 ( &quot;상속 : 없음&quot;) : 기본적으로 특정 속성 상속은 ( &quot;예 상속&quot;) 여부를 확인하기 위해 정의.</target>
        </trans-unit>
        <trans-unit id="1ed53b26132a6967b2fd714950219706ef064b19" translate="yes" xml:space="preserve">
          <source>In CSS, a few characters can appear on their own, like the slash ('&lt;code&gt;/&lt;/code&gt;') or the comma ('&lt;code&gt;,&lt;/code&gt;'), and are used in a property definition to separate its parts. The comma is often used to separate values in enumerations, or parameters in mathematical-like functions; the slash often separates parts of the value that are semantically different, but have a common syntax. Typically, the slash is used in shorthand properties; to separate component that are of the same type, but belong to different properties.</source>
          <target state="translated">CSS에서 슬래시 ( ' &lt;code&gt;/&lt;/code&gt; ') 또는 쉼표 ( ' &lt;code&gt;,&lt;/code&gt; ') 와 같은 일부 문자는 자체적으로 나타날 수 있으며 속성 정의에서 해당 부분을 구분하는 데 사용됩니다. 쉼표는 종종 열거 형의 값 또는 수학과 같은 함수의 매개 변수를 구분하는 데 사용됩니다. 슬래시는 종종 의미 적으로 다른 값의 일부를 분리하지만 공통 구문을 갖습니다. 일반적으로 슬래시는 속기 속성에 사용됩니다. 동일한 유형이지만 다른 속성에 속하는 구성 요소를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="e2d7c377f282ca0a689ac7cc269be132249dde56" translate="yes" xml:space="preserve">
          <source>In CSS, both italic and oblique are applied to text using the &lt;a href=&quot;../font-style&quot;&gt;&lt;code&gt;font-style&lt;/code&gt;&lt;/a&gt; property. Also note the introduction of &lt;code&gt;font-synthesis: none;&lt;/code&gt;&amp;mdash;which will prevent browsers from accidentally applying the variation axis and a synthesized italic. This can be used to prevent faux-bolding as well.</source>
          <target state="translated">CSS에서 기울임 꼴과 오블 리크는 모두 &lt;a href=&quot;../font-style&quot;&gt; &lt;code&gt;font-style&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 텍스트에 적용됩니다 . &lt;code&gt;font-synthesis: none;&lt;/code&gt; 의 도입에 주목하십시오 : none; 브라우저가 실수로 변형 축과 합성 된 이탤릭체를 적용하는 것을 방지합니다. 이것은 가짜 볼딩도 방지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b641c883f19c4d7adacdb79e5b565585622a0a" translate="yes" xml:space="preserve">
          <source>In CSS, gradients aren't colors but &lt;a href=&quot;css_images&quot;&gt;images&lt;/a&gt;.</source>
          <target state="translated">CSS에서 그라디언트는 색상이 아니라 &lt;a href=&quot;css_images&quot;&gt;이미지&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="056cb3fc41f3fd2367ebd0ff2f83d24d3a80a2ab" translate="yes" xml:space="preserve">
          <source>In Chrome 18 to 19, the &lt;code&gt;saturate()&lt;/code&gt; function only takes integers instead of decimal or percentage values. From Chrome 20, this bug is fixed.</source>
          <target state="translated">Chrome 18 ~ 19에서 &lt;code&gt;saturate()&lt;/code&gt; 함수는 10 진수 또는 백분율 값 대신 정수만 사용합니다. Chrome 20부터이 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b5402a15f1a5cd605fed8afa476d2d53327f32d" translate="yes" xml:space="preserve">
          <source>In Dutch (&lt;code&gt;nl&lt;/code&gt;), the &lt;code&gt;ij&lt;/code&gt; digraph becomes &lt;code&gt;IJ&lt;/code&gt;, even with &lt;code&gt;text-transform: capitalize&lt;/code&gt;, which only puts the first letter of a word in uppercase.</source>
          <target state="translated">네덜란드어 ( &lt;code&gt;nl&lt;/code&gt; )에서 &lt;code&gt;ij&lt;/code&gt; digraph는 &lt;code&gt;text-transform: capitalize&lt;/code&gt; 와 함께 &lt;code&gt;IJ&lt;/code&gt; 가됩니다 . 단어의 첫 글자 만 대문자로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e5724118fc705676ac5d111d32a483bdf983365" translate="yes" xml:space="preserve">
          <source>In Edge, hovering over an element and then scrolling up or down without moving the pointer will leave the element in the &lt;code&gt;:hover&lt;/code&gt; state until the pointer is moved. See &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5381673/&quot;&gt;bug 5381673&lt;/a&gt;.</source>
          <target state="translated">Edge에서 요소 위로 마우스를 가져간 다음 포인터를 이동하지 않고 위 또는 아래로 스크롤 하면 포인터가 움직일 때까지 요소가 &lt;code&gt;:hover&lt;/code&gt; 상태로 유지됩니다. &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5381673/&quot;&gt;버그 5381673을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97ad32ef01e6d6b973fef9bea50d7ff1f5ea59ee" translate="yes" xml:space="preserve">
          <source>In Firefox 59, the property was limited to usage in chrome code only (See &lt;a href=&quot;https://bugzil.la/1417200&quot;&gt;bug 1417200&lt;/a&gt;).</source>
          <target state="translated">Firefox 59 &lt;a href=&quot;https://bugzil.la/1417200&quot;&gt;에서이&lt;/a&gt; 속성은 크롬 코드에서만 사용하도록 제한되었습니다 ( 버그 1417200 참조 ).</target>
        </trans-unit>
        <trans-unit id="a431314804a34d74792b5a64bb43ef6be5426e16" translate="yes" xml:space="preserve">
          <source>In Firefox 60, the property was removed completely (See &lt;a href=&quot;https://bugzil.la/1429723&quot;&gt;bug 1429723&lt;/a&gt;).</source>
          <target state="translated">Firefox 60에서는 속성이 완전히 제거되었습니다 ( &lt;a href=&quot;https://bugzil.la/1429723&quot;&gt;버그 1429723&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a0b43ed2ee148cd07e125a389b0668feac556930" translate="yes" xml:space="preserve">
          <source>In Flow and Out of Flow</source>
          <target state="translated">유입 및 유출</target>
        </trans-unit>
        <trans-unit id="05daa321394d596baa5b1be66f28f172f13612e1" translate="yes" xml:space="preserve">
          <source>In Gecko (Firefox) the limit of the cursor size is 128&amp;times;128px. Larger cursor images are ignored. However, you should limit yourself to the size 32&amp;times;32 for maximum compatibility with operating systems and platforms.</source>
          <target state="translated">Gecko (Firefox)에서 커서 크기의 제한은 128 &amp;times; 128px입니다. 더 큰 커서 이미지는 무시됩니다. 그러나 운영 체제 및 플랫폼과의 최대 호환성을 위해서는 32x32 크기로 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4d953850927a160d788bf46abc404a819576bdc" translate="yes" xml:space="preserve">
          <source>In German (&lt;code&gt;de&lt;/code&gt;), the &lt;code&gt;&amp;szlig;&lt;/code&gt; becomes &lt;code&gt;SS&lt;/code&gt; in uppercase.</source>
          <target state="translated">독일어 ( &lt;code&gt;de&lt;/code&gt; )에서 &lt;code&gt;&amp;szlig;&lt;/code&gt; 는 대문자로 &lt;code&gt;SS&lt;/code&gt; 가됩니다 .</target>
        </trans-unit>
        <trans-unit id="80781c40c3f8967b190b0d89539fd63e02763523" translate="yes" xml:space="preserve">
          <source>In German (de), the &lt;code&gt;&amp;szlig;&lt;/code&gt; becomes &lt;code&gt;SS&lt;/code&gt; in uppercase.</source>
          <target state="translated">독일어 (de)에서 &lt;code&gt;&amp;szlig;&lt;/code&gt; 는 대문자로 &lt;code&gt;SS&lt;/code&gt; 가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e37391e5d15cc3b54765120217c0b5653aa4f07d" translate="yes" xml:space="preserve">
          <source>In Greek (&lt;code&gt;el&lt;/code&gt;), the lowercase sigma character has two forms: &lt;code&gt;&amp;sigma;&lt;/code&gt; and &lt;code&gt;&amp;sigmaf;&lt;/code&gt;. &lt;code&gt;&amp;sigmaf;&lt;/code&gt; is used only when sigma terminates a word. When applying &lt;code&gt;text-transform: lowercase&lt;/code&gt; to an uppercase sigma (&lt;code&gt;&amp;Sigma;&lt;/code&gt;), the browser needs to choose the right lowercase form based on context.</source>
          <target state="translated">그리스어 ( &lt;code&gt;el&lt;/code&gt; )에서 소문자 시그마 문자는 &lt;code&gt;&amp;sigma;&lt;/code&gt; 및 &lt;code&gt;&amp;sigmaf;&lt;/code&gt; 의 두 가지 형태를 갖습니다 . &lt;code&gt;&amp;sigmaf;&lt;/code&gt; 는 시그마가 단어를 종료 할 때만 사용됩니다. &lt;code&gt;text-transform: lowercase&lt;/code&gt; 를 대문자 시그마 ( &lt;code&gt;&amp;Sigma;&lt;/code&gt; )에 적용 할 때 브라우저는 컨텍스트에 따라 올바른 소문자 양식을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="25eeee60a49c8ca059739c2da1de51cfddbe7e6a" translate="yes" xml:space="preserve">
          <source>In Greek (&lt;code&gt;el&lt;/code&gt;), vowels lose their accent when the whole word is in uppercase (&lt;code&gt;ά&lt;/code&gt;/&lt;code&gt;&amp;Alpha;&lt;/code&gt;), except for the disjunctive eta (&lt;code&gt;ή&lt;/code&gt;/&lt;code&gt;Ή&lt;/code&gt;). Also, diphthongs with an accent on the first vowel lose the accent and gain a diaeresis on the second vowel (&lt;code&gt;ά&amp;iota;&lt;/code&gt;/&lt;code&gt;&amp;Alpha;Ϊ&lt;/code&gt;).</source>
          <target state="translated">그리스어 ( &lt;code&gt;el&lt;/code&gt; )에서 모음 은 분리형 eta ( &lt;code&gt;ή&lt;/code&gt; / &lt;code&gt;Ή&lt;/code&gt; )를 제외하고 전체 단어가 대문자 ( &lt;code&gt;ά&lt;/code&gt; / &lt;code&gt;&amp;Alpha;&lt;/code&gt; ) 일 때 악센트를 잃습니다 . 또한 첫 번째 모음에 악센트가있는 디프 통은 두 번째 모음 ( &lt;code&gt;ά&amp;iota;&lt;/code&gt; / &lt;code&gt;&amp;Alpha;Ϊ&lt;/code&gt; ) 에서 억양을 잃습니다 .</target>
        </trans-unit>
        <trans-unit id="1161334729a96a24f422f6ffc8f969d8d7188dcc" translate="yes" xml:space="preserve">
          <source>In Greek (el), vowels lose their accent when the whole word is in uppercase (&lt;code&gt;ά&lt;/code&gt;/&lt;code&gt;&amp;Alpha;&lt;/code&gt;), except for the disjunctive eta (&lt;code&gt;ή&lt;/code&gt;/&lt;code&gt;Ή&lt;/code&gt;). Also, diphthongs with an accent on the first vowel lose the accent and gain a diacritic on the second vowel (&lt;code&gt;ά&amp;iota;&lt;/code&gt;/&lt;code&gt;&amp;Alpha;Ϊ&lt;/code&gt;).</source>
          <target state="translated">그리스어 (el)에서 모음 은 분리형 eta ( &lt;code&gt;ή&lt;/code&gt; / &lt;code&gt;Ή&lt;/code&gt; )를 제외하고 전체 단어가 대문자 ( &lt;code&gt;ά&lt;/code&gt; / &lt;code&gt;&amp;Alpha;&lt;/code&gt; ) 일 때 악센트를 잃습니다 . 또한 첫 번째 모음에 악센트가있는 디프 톤은 악센트를 잃고 두 번째 모음에 분음 부호를 얻습니다 ( &lt;code&gt;ά&amp;iota;&lt;/code&gt; / &lt;code&gt;&amp;Alpha;Ϊ&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b6f95d9cdcb8870525b34d88afcb6e8aba98ae1f" translate="yes" xml:space="preserve">
          <source>In IE 7 and IE 8 of Internet Explorer, this property always behaved like &lt;code&gt;background-clip: padding&lt;/code&gt; when &lt;code&gt;overflow&lt;/code&gt; was &lt;code&gt;hidden&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, or &lt;code&gt;scroll&lt;/code&gt;.</source>
          <target state="translated">IE 7 및 Internet Explorer의 IE 8에서는이 속성은 항상처럼 행동 &lt;code&gt;background-clip: padding&lt;/code&gt; 할 때 &lt;code&gt;overflow&lt;/code&gt; 된 &lt;code&gt;hidden&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; , 또는 &lt;code&gt;scroll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a95a951b6c2f0353cd1e98ce4685df836b48f9" translate="yes" xml:space="preserve">
          <source>In IE 7 and IE 9 of Internet Explorer, it always behaved like &lt;code&gt;background-clip: padding&lt;/code&gt; if &lt;code&gt;overflow: hidden | auto | scroll&lt;/code&gt;</source>
          <target state="translated">Internet Explorer의 IE 7 및 IE 9에서는 항상 &lt;code&gt;background-clip: padding&lt;/code&gt; 과 같이 동작 합니다. &lt;code&gt;overflow: hidden | auto | scroll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67757997fb463ce21b9a08ccfe91630ab4e2b137" translate="yes" xml:space="preserve">
          <source>In IE 7 and IE 9 of Internet Explorer, it always behaved like &lt;code&gt;background-clip: padding&lt;/code&gt; if &lt;code&gt;overflow: hidden | auto | scroll&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer의 IE 7 및 IE 9에서는 항상 &lt;code&gt;background-clip: padding&lt;/code&gt; 과 같이 동작 합니다. &lt;code&gt;overflow: hidden | auto | scroll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e40895f43f8daf804c7969752ab1482748b26b0b" translate="yes" xml:space="preserve">
          <source>In IE 7 and before, Internet explorer was behaving as if &lt;code&gt;background-origin: border-box&lt;/code&gt; was set. In Internet Explorer 8, as if &lt;code&gt;background-origin: padding-box&lt;/code&gt;, the regular default value, was set.</source>
          <target state="translated">IE 7 이하에서는 인터넷 익스플로러가 &lt;code&gt;background-origin: border-box&lt;/code&gt; 가 설정된 것처럼 작동했습니다 . Internet Explorer 8에서는 &lt;code&gt;background-origin: padding-box&lt;/code&gt; 가 일반 기본값 인 것처럼 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2cf37abe85810e9faef65ab4ebb25e5d6540427" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 10 and 11, a &lt;code&gt;min-height&lt;/code&gt; declaration on a column-direction flex container doesn't apply to the container's flex items. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#3-min-height-on-a-column-flex-container-wont-apply-to-its-flex-items&quot;&gt;Flexbug #3&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 10 및 11에서 열 방향 플렉스 컨테이너에 대한 &lt;code&gt;min-height&lt;/code&gt; 선언은 컨테이너의 플렉스 항목에 적용되지 않습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#3-min-height-on-a-column-flex-container-wont-apply-to-its-flex-items&quot;&gt;Flexbug # 3&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f55daac39a2970b2c39578f77b898fef333b3280" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 10 and 11, if column flex items have &lt;code&gt;align-items: center;&lt;/code&gt; set on them and their content is too large, then they will overflow the bounds of their container. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#2-column-flex-items-set-to-align-itemscenter-overflow-their-container&quot;&gt;Flexbug #2&lt;/a&gt;.</source>
          <target state="translated">Internet Explorer 10 및 11에서 열 플렉스 항목에 &lt;code&gt;align-items: center;&lt;/code&gt; 항목이있는 경우 : center; 그것들을 설정하고 내용물이 너무 크면 컨테이너의 경계를 넘칩니다. &lt;a href=&quot;https://github.com/philipwalton/flexbugs#2-column-flex-items-set-to-align-itemscenter-overflow-their-container&quot;&gt;Flexbug # 2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ca2a0643faed0c66b2a02b33c7717c48cd3e1f9" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 11, when &lt;code&gt;cursor&lt;/code&gt; is applied to an element and this element is underneath an open &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/a&gt; menu and the user hovers over a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/a&gt; menu item that's on top of said element, the cursor for said element will be displayed rather than the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/a&gt;'s normal cursor. See &lt;a href=&quot;https://developer.microsoft.com/microsoft-edge/platform/issues/817822/&quot;&gt;bug 817822&lt;/a&gt;.</source>
          <target state="translated">Internet Explorer 11에서 &lt;code&gt;cursor&lt;/code&gt; 가 요소에 적용되고이 요소가 열려있는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;/a&gt; 메뉴 아래에 있고 사용자가 해당 요소 위에있는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;/a&gt; 메뉴 항목을 가리킬 경우 해당 요소의 커서가 오히려 표시됩니다. 는보다 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/select&quot;&gt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 정상 커서를. &lt;a href=&quot;https://developer.microsoft.com/microsoft-edge/platform/issues/817822/&quot;&gt;버그 817822를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2e4fe5e1b8fd396a4c6c71bd62711557d80446d" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8 (IE8) the &lt;code&gt;-ms-accelerator&lt;/code&gt; attribute is an extension to CSS, and can be used as a synonym for &lt;code&gt;accelerator&lt;/code&gt;in IE8 Standards mode.</source>
          <target state="translated">Internet Explorer 8 (IE8)에서 &lt;code&gt;-ms-accelerator&lt;/code&gt; 속성은 CSS의 확장 이며 IE8 표준 모드에서 &lt;code&gt;accelerator&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2df433c8083862097360e82c796919d3d0ced1fe" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8 and 9, there is a bug where a computed &lt;code&gt;background-color&lt;/code&gt; of &lt;code&gt;transparent&lt;/code&gt; causes &lt;code&gt;click&lt;/code&gt; events to not get fired on overlaid elements.</source>
          <target state="translated">Internet Explorer 8 및 9에는 계산 된 &lt;code&gt;background-color&lt;/code&gt; 의 &lt;code&gt;transparent&lt;/code&gt; 인해 &lt;code&gt;click&lt;/code&gt; 이벤트가 겹쳐진 요소에서 시작되지 않는 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a7f51c05a37e9d741c8d5578d57f985bea9d9e9" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8 to Internet Explorer 11, hovering over an element and then scrolling up or down without moving the pointer will leave the element in the &lt;code&gt;:hover&lt;/code&gt; state until the pointer is moved. See &lt;a href=&quot;https://connect.microsoft.com/IE/feedbackdetail/view/926665&quot;&gt;bug 926665&lt;/a&gt;.</source>
          <target state="translated">Internet Explorer 8에서 Internet Explorer 11까지의 요소 위로 마우스를 가져간 다음 포인터를 이동하지 않고 위 또는 아래로 스크롤 하면 포인터가 움직일 때까지 요소가 &lt;code&gt;:hover&lt;/code&gt; 상태로 유지됩니다. &lt;a href=&quot;https://connect.microsoft.com/IE/feedbackdetail/view/926665&quot;&gt;버그 926665를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b213fccd0f4caed60146a9e4a6a51d90eb7ff8f" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8, if an element is inserted dynamically by clicking on a link the first-child style isn't applied until the link loses focus.</source>
          <target state="translated">Internet Explorer 8에서 링크를 클릭하여 요소를 동적으로 삽입하면 링크가 포커스를 잃을 때까지 첫 번째 자식 스타일이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0afbddb0da61299da8ea9fd752c5b7a754eaba44" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8, if an element is inserted dynamically by clicking on a link, then the &lt;code&gt;:first-child&lt;/code&gt; style isn't applied until the link loses focus.</source>
          <target state="translated">Internet Explorer 8에서 링크를 클릭하여 요소를 동적으로 삽입 하면 링크의 포커스가 없어 질 때까지 &lt;code&gt;:first-child&lt;/code&gt; 스타일이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05967c6ec64c704a4b566b8a8f0cb566235add51" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 9 (and possibly earlier), if a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/a&gt; has a parent with a non-&lt;code&gt;auto&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/overflow-x&quot;&gt;&lt;code&gt;overflow-x&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: auto;&lt;/code&gt;, the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/a&gt; has enough content to horizontally overflow its parent, and there are &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/:hover&quot;&gt;&lt;code&gt;:hover&lt;/code&gt;&lt;/a&gt; styles set on elements within the table, then hovering over said elements will cause the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/a&gt;'s height to increase. See &lt;a href=&quot;http://jsbin.com/diwiqe&quot;&gt;a live demo that triggers the bug&lt;/a&gt;. One workaround for the bug is to set &lt;code&gt;min-height: 0%;&lt;/code&gt; (the &lt;code&gt;%&lt;/code&gt; unit must be specified, since unitless and &lt;code&gt;px&lt;/code&gt; don't work) on the &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;'s parent element.</source>
          <target state="translated">인터넷 익스플로러 9 (및 이하)하는 경우 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt; &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; &lt;/a&gt; 비와 상위 갖는 &lt;code&gt;auto&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/overflow-x&quot;&gt; &lt;code&gt;overflow-x&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: auto;&lt;/code&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt; &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; &lt;/a&gt; 부모 수평 오버 플로우에 충분한 내용을 가지고 있으며,이 있습니다 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/:hover&quot;&gt; &lt;code&gt;:hover&lt;/code&gt; &lt;/a&gt; , 테이블 내의 요소에 설정된 스타일은 다음 말했다 위로 가져 가면 요소는 원인이됩니다 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/table&quot;&gt; &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 높이가 증가 할 수 있습니다. &lt;a href=&quot;http://jsbin.com/diwiqe&quot;&gt;버그를 유발하는 라이브 데모를&lt;/a&gt; 참조하십시오 . 버그에 대한 한 가지 해결 방법은 &lt;code&gt;min-height: 0%;&lt;/code&gt; 를 설정하는 것입니다 . 0 %; 합니다 ( &lt;code&gt;%&lt;/code&gt; 의 단위없는 및 이후 단위를 지정해야합니다 &lt;code&gt;px&lt;/code&gt; 온 일을하지 않는) &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 의 부모 요소입니다.</target>
        </trans-unit>
        <trans-unit id="484ff8b237fefbdf48168820dad70d4c17858d54" translate="yes" xml:space="preserve">
          <source>In Internet Explorer versions before 7, when both &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;bottom&lt;/code&gt; are specified, the element position is overconstrained and the &lt;code&gt;top&lt;/code&gt; property has precedence; the computed value of &lt;code&gt;bottom&lt;/code&gt; is set to &lt;code&gt;-top&lt;/code&gt;, while its specified value is ignored.</source>
          <target state="translated">7 이전의 Internet Explorer 버전에서 &lt;code&gt;top&lt;/code&gt; 과 &lt;code&gt;bottom&lt;/code&gt; 이 모두 지정되면 요소 위치가 지나치게 제한되고 &lt;code&gt;top&lt;/code&gt; 속성이 우선합니다. &lt;code&gt;bottom&lt;/code&gt; 의 계산 된 값은 &lt;code&gt;-top&lt;/code&gt; 으로 설정되고 지정된 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5552baeb462251e401fa11da8815de9b5d7c96ce" translate="yes" xml:space="preserve">
          <source>In Internet Explorer, fixed positioning doesn't work if the document is in &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ie/ms531140(v=vs.85).aspx&quot;&gt;quirks mode&lt;/a&gt;.</source>
          <target state="translated">Internet Explorer에서 문서가 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ie/ms531140(v=vs.85).aspx&quot;&gt;쿼크 모드 인&lt;/a&gt; 경우 고정 위치가 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="33b74c02473edf32df500c42443b75f6eb6fffd8" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;@media&lt;/code&gt; can be accessed via the CSS object model interface &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule&quot;&gt;&lt;code&gt;CSSMediaRule&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;@media&lt;/code&gt; 는 CSS 객체 모델 인터페이스 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule&quot;&gt; &lt;code&gt;CSSMediaRule&lt;/code&gt; 을&lt;/a&gt; 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41b502521dacc3e640822ad4a5b89c14755b6204" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;@supports&lt;/code&gt; can be accessed via the CSS object model interface &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSSupportsRule&quot;&gt;&lt;code&gt;CSSSupportsRule&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자바 스크립트에서 &lt;code&gt;@supports&lt;/code&gt; 는 CSS의 객체 모델 인터페이스를 통해 액세스 할 수 있습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSSupportsRule&quot;&gt; &lt;code&gt;CSSSupportsRule&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20706841123976adeaa337e6f0cdd2d66bb686b0" translate="yes" xml:space="preserve">
          <source>In Media Queries Level 4 this can be written as:</source>
          <target state="translated">미디어 쿼리 수준 4에서는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed0905507fbddc8ffca6b6b6c5df98f3ecd58fc" translate="yes" xml:space="preserve">
          <source>In Mozilla applications like Firefox, the &lt;code&gt;-moz-border-bottom-colors&lt;/code&gt; CSS property sets a list of colors for the bottom border.</source>
          <target state="translated">Firefox와 같은 Mozilla 응용 프로그램에서 &lt;code&gt;-moz-border-bottom-colors&lt;/code&gt; CSS 속성은 아래쪽 테두리의 색상 목록을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d646e6c522d83bd260b320e439da9b3cc06cc15a" translate="yes" xml:space="preserve">
          <source>In Mozilla applications like Firefox, the &lt;code&gt;-moz-border-left-colors&lt;/code&gt; CSS property sets a list of colors for the left border.</source>
          <target state="translated">Firefox와 같은 Mozilla 응용 프로그램에서 &lt;code&gt;-moz-border-left-colors&lt;/code&gt; CSS 속성은 왼쪽 테두리의 색상 목록을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6cb61c6d68200a673e9a68a5c66d151ac435518a" translate="yes" xml:space="preserve">
          <source>In Mozilla applications like Firefox, the &lt;code&gt;-moz-border-right-colors&lt;/code&gt; CSS property sets a list of colors for the right border.</source>
          <target state="translated">Firefox와 같은 Mozilla 응용 프로그램에서 &lt;code&gt;-moz-border-right-colors&lt;/code&gt; CSS 속성은 오른쪽 테두리의 색상 목록을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cc3f1daf690a70ea8e9b00ddf364285a9841bfae" translate="yes" xml:space="preserve">
          <source>In Mozilla applications like Firefox, the &lt;code&gt;-moz-border-top-colors&lt;/code&gt; CSS property sets a list of colors for the top border.</source>
          <target state="translated">Firefox와 같은 Mozilla 응용 프로그램에서 &lt;code&gt;-moz-border-top-colors&lt;/code&gt; CSS 속성은 위쪽 테두리의 색상 목록을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e15eb265a585a306161d6a278772e00ff0fedc96" translate="yes" xml:space="preserve">
          <source>In Mozilla applications like Firefox, the &lt;code&gt;-moz-outline-radius&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; property can be used to give an element's &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt; rounded corners.</source>
          <target state="translated">Firefox와 같은 Mozilla 애플리케이션에서 &lt;code&gt;-moz-outline-radius&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 특성을 사용하여 요소의 &lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 모서리 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71425c57b965e2e6fb351245088392c523711399" translate="yes" xml:space="preserve">
          <source>In Mozilla applications, &lt;code&gt;-moz-user-input&lt;/code&gt; determines if an element will accept user input.</source>
          <target state="translated">Mozilla 응용 프로그램에서 &lt;code&gt;-moz-user-input&lt;/code&gt; 은 요소가 사용자 입력을 승인할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8a2560592288d08ecaf1be3f739350eb1a6946d7" translate="yes" xml:space="preserve">
          <source>In Mozilla applications, the &lt;code&gt;-moz-outline-radius-bottomleft&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; property can be used to round the bottom-left corner of an element's &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mozilla 애플리케이션에서 &lt;code&gt;-moz-outline-radius-bottomleft&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 특성을 사용하여 요소 &lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 의 왼쪽 아래 모서리를 둥글게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a63edcd216cb0f3a24e70a7f95e9f920333f2746" translate="yes" xml:space="preserve">
          <source>In Mozilla applications, the &lt;code&gt;-moz-outline-radius-bottomright&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; property can be used to round the bottom-right corner of an element's &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mozilla 애플리케이션에서 &lt;code&gt;-moz-outline-radius-bottomright&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 특성을 사용하여 요소 &lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 의 오른쪽 아래 모서리를 둥글게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="060ba422b3cff44130f96db124630bf50ff56a5f" translate="yes" xml:space="preserve">
          <source>In Mozilla applications, the &lt;code&gt;-moz-outline-radius-topleft&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; property can be used to round the top-left corner of an element's &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mozilla 애플리케이션에서 &lt;code&gt;-moz-outline-radius-topleft&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 특성을 사용하여 요소 &lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 의 왼쪽 상단 모서리를 둥글게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfb4218fd0048be14ea792e8eff51732da40d3f9" translate="yes" xml:space="preserve">
          <source>In Mozilla applications, the &lt;code&gt;-moz-outline-radius-topright&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; property can be used to round the top-right corner of an element's &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mozilla 애플리케이션에서 &lt;code&gt;-moz-outline-radius-topright&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt; 특성을 사용하여 요소 &lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 의 오른쪽 상단 모서리를 둥글게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e60be4b0bbd8eac8ed2a5dd87b95f9fa3d28a1f" translate="yes" xml:space="preserve">
          <source>In Opera prior to version 11.60, replaced elements with &lt;code&gt;border-radius&lt;/code&gt; will not have rounded corners.</source>
          <target state="translated">버전 11.60 이전의 Opera에서 &lt;code&gt;border-radius&lt;/code&gt; 대체 된 요소 에는 둥근 모서리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f18ee7716836d9bd1ff739d118760a6d818ae662" translate="yes" xml:space="preserve">
          <source>In Opera, &lt;code&gt;visibility: collapse&lt;/code&gt; works on table elements, but doesn't hide a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/tfoot&quot;&gt;&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;&lt;/a&gt; if it is adjacent to a visible &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/tbody&quot;&gt;&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Opera에서 &lt;code&gt;visibility: collapse&lt;/code&gt; 는 테이블 요소에서 작동하지만 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/tfoot&quot;&gt; &lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt; &lt;/a&gt; 이 보이는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/tbody&quot;&gt; &lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt; 에&lt;/a&gt; 인접하면 숨겨지지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="378aff0da81e4cfa2370e3961449bec3e145ab6b" translate="yes" xml:space="preserve">
          <source>In SVG, when text is scaled up or down, browsers calculate the final size of the text (which is determined by the specified font size and the applied scale) and request a font of that computed size from the platform's font system. But if you request a font size of, say, 9 with a scale of 140%, the resulting font size of 12.6 doesn't explicitly exist in the font system, so the browser rounds the font size to 12 instead. This results in stair-step scaling of text.</source>
          <target state="translated">SVG에서 텍스트가 확대 또는 축소 될 때 브라우저는 텍스트의 최종 크기 (지정된 글꼴 크기 및 적용된 크기로 결정됨)를 계산하고 플랫폼의 글꼴 시스템에서 계산 된 크기의 글꼴을 요청합니다. 그러나 글꼴 크기가 140 % 인 9의 글꼴 크기를 요청하면 글꼴 시스템에 12.6의 결과 글꼴 크기가 명시 적으로 존재하지 않으므로 브라우저는 대신 글꼴 크기를 12로 반올림합니다. 결과적으로 텍스트의 계단 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="7a5b6c9c3ddb63355c6e6325240ec48bf56f8f9e" translate="yes" xml:space="preserve">
          <source>In Safari, &lt;code&gt;:in-range&lt;/code&gt; matched disabled and read-only inputs (see &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=156530&quot;&gt;bug 156530&lt;/a&gt;). It was later changed to only match enabled read-write inputs.</source>
          <target state="translated">Safari에서 &lt;code&gt;:in-range&lt;/code&gt; 일치 비활성화 및 읽기 전용 입력 ( &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=156530&quot;&gt;버그 156530&lt;/a&gt; 참조 ). 나중에 활성화 된 읽기 / 쓰기 입력 만 일치하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="5306832d0149aed08ed29106b74a9e0cb93186cf" translate="yes" xml:space="preserve">
          <source>In Safari, any shadows that do not explicitly specify a color are transparent.</source>
          <target state="translated">Safari에서 색상을 명시 적으로 지정하지 않은 그림자는 투명합니다.</target>
        </trans-unit>
        <trans-unit id="307666c8efda7abd1115a9021ac303c9eff997a8" translate="yes" xml:space="preserve">
          <source>In Spring of 2017, we saw for the first time a major specification like Grid being shipped into browsers almost simultaneously, and we now have CSS Grid Layout support in the public versions of Firefox, Chrome, Opera, Safari and Edge. However, while evergreen browsers mean that many of us are going to see the majority of users having Grid Layout support very quickly, there are also old or non-supporting browsers to contend with. In this guide we will walk through a variety of strategies for support.</source>
          <target state="translated">2017 년 봄에 Grid와 같은 주요 사양이 브라우저에 거의 동시에 제공되는 것을 처음으로 보았으며 이제 Firefox, Chrome, Opera, Safari 및 Edge의 공개 버전에서 CSS Grid Layout이 지원됩니다. 그러나 항상 녹색 브라우저는 많은 사람들이 그리드 레이아웃을 지원하는 대다수의 사용자를 매우 빠르게 보게 될 것이라고 말하지만, 오래되거나 지원되지 않는 브라우저도 있습니다. 이 안내서에서는 다양한 지원 전략을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="7eb88804a8039d51fa93d6df93f81c16c8f47c43" translate="yes" xml:space="preserve">
          <source>In Turkic languages, like Turkish (&lt;code&gt;tr&lt;/code&gt;), Azerbaijani (&lt;code&gt;az&lt;/code&gt;), Crimean Tatar (&lt;code&gt;crh&lt;/code&gt;), Volga Tatar (&lt;code&gt;tt&lt;/code&gt;), and Bashkir (&lt;code&gt;ba&lt;/code&gt;), there are two kinds of &lt;code&gt;i&lt;/code&gt;, with and without the dot, and two case pairings: &lt;code&gt;i&lt;/code&gt;/&lt;code&gt;İ&lt;/code&gt; and &lt;code&gt;ı&lt;/code&gt;/&lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">터키어 ( &lt;code&gt;tr&lt;/code&gt; ), 아제르바이잔 어 ( &lt;code&gt;az&lt;/code&gt; ), 크림 타타르어 ( &lt;code&gt;crh&lt;/code&gt; ), 볼가 타타르어 ( &lt;code&gt;tt&lt;/code&gt; ) 및 바쉬 키르 어 ( &lt;code&gt;ba&lt;/code&gt; ) 와 같은 투르크어 언어에는 점이 있거나 없는 두 가지 종류의 &lt;code&gt;i&lt;/code&gt; 가 있으며 두 가지 경우가 있습니다. : &lt;code&gt;i&lt;/code&gt; / &lt;code&gt;İ&lt;/code&gt; 및 &lt;code&gt;ı&lt;/code&gt; / &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e07882c5b9ed633ee66c66f648bec121f5908e8" translate="yes" xml:space="preserve">
          <source>In Turkic languages, such as Turkish (tr), Azerbaijani (az), Crimean Tatar (crh), Volga Tatar (tt), and Bashkir (ba), there are two kinds of &lt;code&gt;i&lt;/code&gt; (one with the dot, one without) and two case pairings: &lt;code&gt;i&lt;/code&gt;/&lt;code&gt;İ&lt;/code&gt; and &lt;code&gt;ı&lt;/code&gt;/&lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">터키어 (tr), 아제르바이잔 어 (az), 크림 타타르어 (crh), 볼가 타타르어 (tt) 및 바쉬르 어 (ba)와 같은 투르크어 언어에는 두 가지 종류의 &lt;code&gt;i&lt;/code&gt; (점 하나,없는 것)와 이 경우 페어링 : &lt;code&gt;i&lt;/code&gt; / &lt;code&gt;İ&lt;/code&gt; 및 &lt;code&gt;ı&lt;/code&gt; / &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69958fd1c3b69f1c0f338798b33a3ff69719f5b3" translate="yes" xml:space="preserve">
          <source>In Windows Internet Explorer 8 the &lt;code&gt;-ms-scrollbar-track-color&lt;/code&gt; attribute is an extension to CSS, and can be used as a synonym for &lt;code&gt;scrollbar-track-color&lt;/code&gt; in IE8 Standards Mode.</source>
          <target state="translated">Windows Internet Explorer 8에서 &lt;code&gt;-ms-scrollbar-track-color&lt;/code&gt; 속성은 CSS의 확장 이며 IE8 표준 모드에서 &lt;code&gt;scrollbar-track-color&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f31170eaf9943a358b50719fa5092e663e634ca" translate="yes" xml:space="preserve">
          <source>In Windows Internet Explorer 8, the &lt;code&gt;-ms-filter&lt;/code&gt; attribute is an extension to CSS, and can be used as a synonym for &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; in IE8 Standards mode. When you use &lt;code&gt;-ms-filter&lt;/code&gt;, enclose the progid in single quotes (&lt;code&gt;'&lt;/code&gt;) or double quotes (&lt;code&gt;&quot;&lt;/code&gt;). Use commas (&lt;code&gt;,&lt;/code&gt;) to separate multiple values, as shown in the Examples section.</source>
          <target state="translated">Windows Internet Explorer 8에서 &lt;code&gt;-ms-filter&lt;/code&gt; 속성은 CSS의 확장 이며 IE8 표준 모드에서 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 의 동의어로 사용할 수 있습니다 . &lt;code&gt;-ms-filter&lt;/code&gt; 를 사용 하는 경우 예제를 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ) 또는 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; )로 묶고 예제 섹션에 표시된대로 쉼표 ( &lt;code&gt;,&lt;/code&gt; )를 사용 하여 여러 값을 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="35b7c3f352b6397e4e90d142d673cabe1cf765c5" translate="yes" xml:space="preserve">
          <source>In Windows Internet Explorer 8, the &lt;code&gt;-ms-scrollbar-3dlight-color&lt;/code&gt; attribute is an extension to CSS, and can be used as a synonym for &lt;code&gt;scrollbar-3dlight-color&lt;/code&gt; in IE8 Standards Mode.</source>
          <target state="translated">Windows Internet Explorer 8에서 &lt;code&gt;-ms-scrollbar-3dlight-color&lt;/code&gt; 속성은 CSS의 확장 이며 IE8 표준 모드에서 &lt;code&gt;scrollbar-3dlight-color&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b66eda0c654d57de8d6aaa815a5f5b5a64cf189" translate="yes" xml:space="preserve">
          <source>In Windows Internet Explorer 8, the &lt;code&gt;-ms-scrollbar-arrow-color&lt;/code&gt; property is an extension to CSS, and can be used as a synonym for &lt;code&gt;scrollbar-arrow-color&lt;/code&gt; in IE8 Standards Mode.</source>
          <target state="translated">Windows Internet Explorer 8에서 &lt;code&gt;-ms-scrollbar-arrow-color&lt;/code&gt; 속성은 CSS의 확장 이며 IE8 표준 모드에서 &lt;code&gt;scrollbar-arrow-color&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6386ff2f9ec2596b5a346de5b0aa54743aaea73" translate="yes" xml:space="preserve">
          <source>In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).&amp;rdquo; - 9.4.1</source>
          <target state="translated">블록 서식 컨텍스트에서 각 상자의 왼쪽 바깥 쪽 가장자리는 포함 블록의 왼쪽 가장자리에 닿습니다 (오른쪽에서 왼쪽으로 서식을 지정하려면 오른쪽 가장자리를 터치).&amp;rdquo; -9.4.1</target>
        </trans-unit>
        <trans-unit id="822afc5b8b0beb496d526c9b4e63d71471696efe" translate="yes" xml:space="preserve">
          <source>In a future version of the specification it would be useful to be able to have overflow columns in continuous media display in the block direction, therefore allowing the reader to scroll down to view the next set of columns.</source>
          <target state="translated">향후 버전의 사양에서는 블록 방향으로 연속 미디어 디스플레이에서 오버플로 열을 가질 수 있으므로 독자가 아래로 스크롤하여 다음 열 집합을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4197746f7227d316c0adaa8b80f93492394b7c1b" translate="yes" xml:space="preserve">
          <source>In a horizontal &lt;code&gt;writing-mode&lt;/code&gt; this CSS would apply &lt;code&gt;5px&lt;/code&gt; of padding to the top of the box and 10px of padding to the bottom:</source>
          <target state="translated">가로 &lt;code&gt;writing-mode&lt;/code&gt; 에서이 CSS는 상자 상단에 &lt;code&gt;5px&lt;/code&gt; 의 패딩을 적용 하고 하단에 10px의 패딩을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="656b133dd8458a3650465de6b12b90286674723b" translate="yes" xml:space="preserve">
          <source>In a horizontal writing mode this CSS would apply a 5px margin to the top of the box and a 10px margin to the bottom.</source>
          <target state="translated">가로 쓰기 모드에서이 CSS는 상자 상단에 5px 여백을 적용하고 하단에 10px 여백을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d607845f37f742a85401853979ab9393246a94fa" translate="yes" xml:space="preserve">
          <source>In a later article in this series &amp;mdash; Aligning items in a flex container &amp;mdash; we will take a thorough look at how the Box Alignment properties apply to flex items.</source>
          <target state="translated">이 시리즈의 후반 기사 (Flex 컨테이너에 항목 정렬)에서는 Box Alignment 속성이 Flex 항목에 어떻게 적용되는지 철저히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bbf2e85693e8aec91204957ec72bc7f29ad8896a" translate="yes" xml:space="preserve">
          <source>In a later guide in this series, I&amp;rsquo;ll be taking a proper look at Box Alignment and how it works in Grid Layout. For now, here is a comparison between simple examples of flexbox and grid.</source>
          <target state="translated">이 시리즈의 후반부에서 Box Alignment와 그리드 레이아웃에서 작동 방식을 올바르게 살펴 보겠습니다. 지금은 flexbox와 grid의 간단한 예제를 비교 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="80a7d45c10e0cdfb82016353c40883e972db80c3" translate="yes" xml:space="preserve">
          <source>In a multi-column block, content is automatically flowed from one column into the next as needed. All HTML, CSS and DOM functionality is supported within columns, as are editing and printing.</source>
          <target state="translated">다중 열 블록에서 내용은 필요에 따라 자동으로 한 열에서 다음 열로 흐릅니다. 모든 HTML, CSS 및 DOM 기능은 편집 및 인쇄와 마찬가지로 열 내에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8bef0e09d052fbac433a11734b9709be46aac90f" translate="yes" xml:space="preserve">
          <source>In a perfect world of browser support, the reason you'd choose to use flexbox is because you want to lay a collection of items out in one direction or another. As you lay out your items you want to control the dimensions of the items in that one dimension, or control the spacing between items. These are the uses that flexbox was designed for. You can read more about the difference between flexbox and CSS Grid Layout in &lt;a href=&quot;relationship_of_flexbox_to_other_layout_methods&quot;&gt;Relationship of Flexbox to other layout methods&lt;/a&gt;, where we discuss how flexbox fits into the overall picture of CSS Layout.</source>
          <target state="translated">완벽한 브라우저 지원 환경에서 flexbox를 사용하기로 선택한 이유는 항목 모음을 한 방향 또는 다른 방향으로 배치하기 때문입니다. 항목을 배치 할 때 해당 한 차원의 항목 크기를 제어하거나 항목 간 간격을 제어하려고합니다. 이것이 flexbox를위한 용도입니다. Flexbox와 &lt;a href=&quot;relationship_of_flexbox_to_other_layout_methods&quot;&gt;다른 레이아웃 방법의 관계&lt;/a&gt; 에서 Flexbox와 CSS 그리드 레이아웃의 차이점에 대해 자세히 읽을 수 있습니다 . 여기서 Flexbox가 CSS 레이아웃의 전체 그림에 어떻게 적용되는지에 대해 논의합니다.</target>
        </trans-unit>
        <trans-unit id="fd88678f50419c35ed43f5fa7d02d34b1b9ff59b" translate="yes" xml:space="preserve">
          <source>In a vertical writing mode then would lay out horizontally.</source>
          <target state="translated">세로 쓰기 모드에서는 가로로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e01d0995c06fd484c061943f9d14c2923ea966d8" translate="yes" xml:space="preserve">
          <source>In absolutely-positioned layouts, the keyword behaved like &lt;code&gt;start&lt;/code&gt; on &lt;em&gt;replaced&lt;/em&gt; absolutely-positioned boxes, and as &lt;code&gt;stretch&lt;/code&gt; on &lt;em&gt;all other&lt;/em&gt; absolutely-positioned boxes.</source>
          <target state="translated">절대적으로 배치 된 레이아웃에서 키워드 는 &lt;em&gt;대체 된&lt;/em&gt; 절대 위치 상자에서 &lt;code&gt;start&lt;/code&gt; 하는 것처럼 작동 &lt;em&gt;하고 다른 모든&lt;/em&gt; 절대 위치 상자 에서 &lt;code&gt;stretch&lt;/code&gt; 되는 것처럼 작동 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a853b42f7047cd8efc1d9fd42ac9942a10ab3acb" translate="yes" xml:space="preserve">
          <source>In absolutely-positioned layouts, the keyword behaves like &lt;code&gt;start&lt;/code&gt; on &lt;em&gt;replaced&lt;/em&gt; absolutely-positioned boxes, and as &lt;code&gt;stretch&lt;/code&gt; on &lt;em&gt;all other&lt;/em&gt; absolutely-positioned boxes.</source>
          <target state="translated">절대적으로 배치 된 레이아웃에서 키워드 는 &lt;em&gt;대체 된&lt;/em&gt; 절대 위치 상자에서 &lt;code&gt;start&lt;/code&gt; 하는 것처럼 작동 &lt;em&gt;하고 다른 모든&lt;/em&gt; 절대 위치 상자 에서 &lt;code&gt;stretch&lt;/code&gt; 되는 것처럼 작동 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e2b3b85c2777074ed353d28ccaad585e03552d3" translate="yes" xml:space="preserve">
          <source>In addition to broad feature sets like ligatures or lining figures (numerals that line up evenly as opposed to 'oldstyle', which look more like lower-case letters), there are also very specific ones such as stylistic sets (which might include several specific variants of glyphs meant to be used together), alternates (which might be one or more variants of the letter 'a'), or even language-specific alterations for East Asian languages. In the latter case, these alterations are actually necessary to properly express the language, so they go beyond the more stylistic preference of most other OpenType features.</source>
          <target state="translated">합자 또는 안감 그림과 같은 광범위한 기능 세트 (소문자처럼 보이는 '이전 스타일'과는 반대로 균등하게 정렬되는 숫자) 외에도 스타일 세트와 같은 매우 특정한 기능이 있습니다 (여러 가지를 포함 할 수 있음) 함께 사용되는 글리프의 변형), 대체 문자 ( 'a'의 하나 이상의 변형 일 수 있음) 또는 동아시아 언어의 언어 별 변경까지 가능합니다. 후자의 경우 이러한 언어 변경은 실제로 언어를 제대로 표현하기 위해 필요하므로 대부분의 다른 OpenType 기능보다 더 문체 적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="5c046329ebae0600c208c979e6a52c6d5c1ed816" translate="yes" xml:space="preserve">
          <source>In addition to displaying documents, using the correct writing mode for the language, writing modes can be used creatively within documents that are otherwise &lt;code&gt;ltr&lt;/code&gt;. In this next example I have a grid layout with a set of links down one side. I&amp;rsquo;ve used writing modes to turn these on their side in the column track:</source>
          <target state="translated">언어에 대한 올바른 쓰기 모드를 사용하여 문서를 표시하는 것 외에도 &lt;code&gt;ltr&lt;/code&gt; 인 문서 내에서 쓰기 모드를 창의적으로 사용할 수 있습니다 . 이 다음 예에서는 한쪽에 링크 세트가있는 그리드 레이아웃이 있습니다. 필자는 쓰기 모드를 사용하여 열 트랙에서 측면을 켭니다.</target>
        </trans-unit>
        <trans-unit id="2eb52c7a147952d2ea4ebc5d701ded0862a99155" translate="yes" xml:space="preserve">
          <source>In addition to indicating that the element is not the target of mouse events, the value &lt;code&gt;none&lt;/code&gt; instructs the mouse event to go &quot;through&quot; the element and target whatever is &quot;underneath&quot; that element instead.</source>
          <target state="translated">요소가 마우스 이벤트의 대상이 아님을 나타내는 것 외에도 값 &lt;code&gt;none&lt;/code&gt; 은 마우스 이벤트가 요소를 &quot;통과&quot;하고 해당 요소의 &quot;아래&quot;를 대상으로 지정하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="be630f48e3eded015a335adacc65ce23fb35aa71" translate="yes" xml:space="preserve">
          <source>In addition to reversing the order in which flex items are visually displayed, you can target individual items and change where they appear in the visual order with the &lt;a href=&quot;../order&quot;&gt;&lt;code&gt;order&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">플렉스 항목이 시각적으로 표시되는 순서를 반대로하는 것 외에도 &lt;a href=&quot;../order&quot;&gt; &lt;code&gt;order&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 개별 항목을 대상으로 지정하고 시각적 순서에서 표시되는 위치를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69bed036b9ed9fb8feb32cdffea98e085029dd61" translate="yes" xml:space="preserve">
          <source>In addition to specifying the start and end lines by number, you can specify a start line and then the number of tracks you would like the area to span.</source>
          <target state="translated">시작 및 끝 줄을 번호로 지정하는 것 외에도 시작 줄을 지정한 다음 영역을 확장하려는 트랙 수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e7bad3ceceb6ed4734a03860420f1dc2c38825" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;auto&lt;/code&gt; keyword, you can use the &lt;code&gt;content&lt;/code&gt; keyword as the &lt;code&gt;flex-basis&lt;/code&gt;. This will result in the &lt;code&gt;flex-basis&lt;/code&gt; being taken from the content size even if there is a width set on the item. This is a newer keyword and has less browser support, however you can always get the same effect by using &lt;code&gt;auto&lt;/code&gt; as the flex-basis and ensuring that your item does not have a width set, in order that it will be auto-sized.</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 키워드 외에도 &lt;code&gt;content&lt;/code&gt; 키워드를 &lt;code&gt;flex-basis&lt;/code&gt; 로 사용할 수 있습니다 . 이렇게하면 항목에 너비가 설정되어 있어도 콘텐츠 크기에서 &lt;code&gt;flex-basis&lt;/code&gt; 이 적용됩니다. 이 키워드는 최신 키워드이며 브라우저를 지원하지 않지만, &lt;code&gt;auto&lt;/code&gt; 기준을 기준으로 사용하고 자동 크기 조정을 위해 항목에 너비가 설정되어 있지 않은 경우 항상 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14f790608a5d177bdb1e57350f47d8ef2740d924" translate="yes" xml:space="preserve">
          <source>In addition to the CSS Display Specification Level 3, further specifications define the behavior of various values of display.</source>
          <target state="translated">CSS 디스플레이 사양 레벨 3 외에도, 추가 사양은 다양한 디스플레이 값의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a1678978059f12992cde93376cd6a35525d7a413" translate="yes" xml:space="preserve">
          <source>In addition to the ability to place items accurately onto a created grid, the CSS Grid Layout specification contains rules that control what happens when you create a grid and do not place some or all of the child items. You can see auto-placement in action in the simplest of ways by creating a grid on a set of items. If you give the items no placement information they will position themselves on the grid, one in each grid cell.</source>
          <target state="translated">CSS 그리드 레이아웃 사양에는 항목을 생성 된 그리드에 정확하게 배치하는 기능 외에도 그리드를 만들 때 발생하는 작업을 제어하고 하위 항목 중 일부 또는 전부를 배치하지 않는 규칙이 포함되어 있습니다. 일련의 항목에 그리드를 작성하면 가장 간단한 방법으로 자동 배치가 작동하는 것을 볼 수 있습니다. 항목에 배치 정보를 제공하지 않으면 각 격자 셀에 하나씩 격자에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="3e875f9f2e7b58dd63cd2e253d8894f9aa514d85" translate="yes" xml:space="preserve">
          <source>In addition to the above, browser support for these properties is a little patchy. The compatibility data charts on the individual property pages here on MDN can help you see which browsers support which features. In most cases, the fallback to breaks not being controlled is something you can live with, with suboptimal breaking being untidy rather than a disaster to your layout.</source>
          <target state="translated">위의 것 외에도 이러한 속성에 대한 브라우저 지원은 약간의 패치입니다. 여기 MDN의 개별 속성 페이지에있는 호환성 데이터 차트를 통해 어떤 브라우저가 어떤 기능을 지원하는지 확인할 수 있습니다. 대부분의 경우, 제어되지 않는 중단으로의 폴백은 사용자가 살 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="744f18547c59c3767a5cac8545b868e079b2f366" translate="yes" xml:space="preserve">
          <source>In addition to the one-dimensional versus two-dimensional distinction, there is another way to decide if you should use flexbox or grid for a layout. Flexbox works from the content out. An ideal use case for flexbox is when you have a set of items and want to space them out evenly in a container. You let the size of the content decide how much individual space each item takes up. If the items wrap onto a new line, they will work out their spacing based on their size and the available space &lt;em&gt;on that line&lt;/em&gt;.</source>
          <target state="translated">1 차원 대 2 차원 구별 외에도, 레이아웃에 flexbox 또는 그리드를 사용해야하는지 여부를 결정하는 다른 방법이 있습니다. Flexbox는 컨텐츠에서 작동합니다. flexbox의 이상적인 사용 사례는 아이템 세트가 있고 컨테이너에 균등하게 배치하려는 경우입니다. 내용의 크기에 따라 각 항목이 차지하는 개별 공간의 양이 결정됩니다. 항목이 줄 바꿈으로 바뀌면 크기와 &lt;em&gt;해당 줄&lt;/em&gt; 의 사용 가능한 공간 &lt;em&gt;을&lt;/em&gt; 기준으로 간격 &lt;em&gt;을 계산합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2c80cf93c72b0c70f71a87d2de58cb2d976bd1b4" translate="yes" xml:space="preserve">
          <source>In addition to the root element of our document (the &lt;code&gt;html&lt;/code&gt; element) ,a new</source>
          <target state="translated">우리 문서의 루트 요소 ( &lt;code&gt;html&lt;/code&gt; 요소) 외에도</target>
        </trans-unit>
        <trans-unit id="31cb455cbd34c42c8df68471be1833da1a54f00d" translate="yes" xml:space="preserve">
          <source>In addition to the rules existing in CSS2.1, new levels of CSS further describes the behaviour of block and inline boxes. The &lt;code&gt;display&lt;/code&gt; property defines how a box, and any boxes inside it behaves. In the CSS Display Model Level 3 we can learn more about how the display property changes the behaviour of boxes and the boxes they generate.</source>
          <target state="translated">CSS2.1에 존재하는 규칙 외에도 새로운 수준의 CSS는 블록 및 인라인 박스의 동작을 추가로 설명합니다. &lt;code&gt;display&lt;/code&gt; 상자, 어떤 상자가 작동 내부에서 어떻게 속성을 정의합니다. CSS Display Model Level 3에서 display 속성이 박스의 동작과 박스의 동작을 어떻게 바꾸는 지에 대해 더 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69996fa2865ae5903316b531297a942b8582f2db" translate="yes" xml:space="preserve">
          <source>In addition to these mapped properties there are some additional shorthand properties made possible by being able to address block and inline dimensions. These have no mapping to physical properties.</source>
          <target state="translated">이러한 매핑 된 속성 외에도 블록 및 인라인 차원을 처리 할 수있어 몇 가지 추가 속기 속성이 있습니다. 이들은 물리적 속성에 대한 매핑이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b75653b185f655aab64be6a4a830f23d9efcd458" translate="yes" xml:space="preserve">
          <source>In addition, even for the above styles, you won't be able to change the transparency between unvisited and visited links, as you otherwise would be able to using &lt;code&gt;&lt;a href=&quot;color_value#rgba()&quot;&gt;rgba()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;color_value#hsla()&quot;&gt;hsla()&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;color_value#transparent&quot;&gt;transparent&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">또한 위 스타일의 경우에도 &lt;code&gt;&lt;a href=&quot;color_value#rgba()&quot;&gt;rgba()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;color_value#hsla()&quot;&gt;hsla()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;color_value#transparent&quot;&gt;transparent&lt;/a&gt;&lt;/code&gt; 키워드 를 사용할 수 있으므로 방문하지 않은 링크와 방문한 링크 사이의 투명도를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cda9fab168d9befbbcff3cde33569c1f48305bf5" translate="yes" xml:space="preserve">
          <source>In addition, you can find detailed explanations of the layout models that certain values enable elsewhere on MDN:</source>
          <target state="translated">또한 특정 값이 MDN의 다른 곳에서 사용할 수있는 레이아웃 모델에 대한 자세한 설명을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf572b88ccf9e58e3f1aa49c2ed9cddb9bfb5743" translate="yes" xml:space="preserve">
          <source>In all of these examples I have been working in English, which is a left-to-right language. This means that our start lines are top and left of our grid when thinking in physical directions.</source>
          <target state="translated">이 모든 예에서 저는 왼쪽에서 오른쪽 언어 인 영어로 일하고 있습니다. 이것은 물리적 방향으로 생각할 때 시작 선이 그리드의 상단과 왼쪽에 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd48b6671917bca188cc6c86712a56e6013913ac" translate="yes" xml:space="preserve">
          <source>In all other cases no interpolation occurs.</source>
          <target state="translated">다른 모든 경우에는 보간이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20fb3fe23686db3ecb2d619e0eb6c6b242584382" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;&amp;lt;input type='text'&amp;gt;&lt;/code&gt; element styled with &lt;code&gt;text-align: right&lt;/code&gt;, if the clear button is shown, it will clip off the right edge of the text value of the &lt;code&gt;&amp;lt;input type='text'&amp;gt;&lt;/code&gt; element. A workaround is to hide the clear button using &lt;code&gt;display: none&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;&amp;lt;input type='text'&amp;gt;&lt;/code&gt; 와 스타일 소자 &lt;code&gt;text-align: right&lt;/code&gt; 클리어 버튼이 표시되면, 상기 텍스트 값의 우단 오프 클립 것 &lt;code&gt;&amp;lt;input type='text'&amp;gt;&lt;/code&gt; 요소. 해결 방법은 &lt;code&gt;display: none&lt;/code&gt; 사용하여 지우기 단추를 숨기는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="439edbed9decacfd1bebe3f4494e1b45c015f9b6" translate="yes" xml:space="preserve">
          <source>In an HTML editor, if a double-click or context-click occurred in sub-elements, the highest ancestor with this value will be selected.</source>
          <target state="translated">HTML 편집기에서 하위 요소에서 두 번 클릭 또는 컨텍스트 클릭이 발생하면이 값을 가진 가장 높은 조상이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="19a3bbce77163651d7ee09975ecbfeb0fd61000f" translate="yes" xml:space="preserve">
          <source>In an SVG, the viewport is the visible area of the SVG image. You can set any height and width on an SVG, but the whole image might not be visible. The area that is visible is called the viewport. The size of the viewport can be definited using the width and height attributes of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg&quot;&gt;&lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">SVG에서 뷰포트는 SVG 이미지의 가시 영역입니다. SVG에서 높이와 너비를 설정할 수 있지만 전체 이미지가 보이지 않을 수 있습니다. 보이는 영역을 뷰포트라고합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg&quot;&gt; &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 width 및 height 속성을 사용하여 뷰포트의 크기를 정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c19ca877dcf62e20f81aa718ee7daae51ebbcac9" translate="yes" xml:space="preserve">
          <source>In animations and &lt;a href=&quot;css_images/using_css_gradients&quot;&gt;gradients&lt;/a&gt;, &lt;code&gt;&amp;lt;color&amp;gt;&lt;/code&gt; values are interpolated on each of their red, green, and blue components. Each component is interpolated as a real, floating-point number. Note that interpolation of colors happens in the &lt;a href=&quot;https://www.gimp.org/docs/plug-in/appendix-alpha.html&quot;&gt;alpha-premultiplied sRGBA color space&lt;/a&gt; to prevent unexpected gray colors from appearing. In animations, the interpolation's speed is determined by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function&quot;&gt;timing function&lt;/a&gt;.</source>
          <target state="translated">애니메이션 및 &lt;a href=&quot;css_images/using_css_gradients&quot;&gt;그라디언트&lt;/a&gt; 에서 &lt;code&gt;&amp;lt;color&amp;gt;&lt;/code&gt; 값은 빨강, 녹색 및 파랑 구성 요소 각각에 보간됩니다. 각 구성 요소는 실수 부동 소수점 숫자로 보간됩니다. &lt;a href=&quot;https://www.gimp.org/docs/plug-in/appendix-alpha.html&quot;&gt;알파 미리 곱한 sRGBA 색상 공간&lt;/a&gt; 에서 색상의 보간이 발생하여 예기치 않은 회색 색상이 나타나지 않도록합니다. 애니메이션에서 보간 속도는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/single-transition-timing-function&quot;&gt;타이밍 기능에&lt;/a&gt; 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="701c53c6262571e81753c6dc58e9cba0f2ae07bf" translate="yes" xml:space="preserve">
          <source>In block-level layouts, it aligns an item inside its containing block on the inline axis.</source>
          <target state="translated">블록 레벨 레이아웃에서는 인라인 축의 포함 블록 내부에 항목을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="35819adfbeeaea066010f86aff00ab304fcedad0" translate="yes" xml:space="preserve">
          <source>In block-level layouts, it aligns the items inside their containing block on the inline axis.</source>
          <target state="translated">블록 레벨 레이아웃에서는 인라인 축의 포함 블록 내부에 항목을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="8f16fe2511ee90dafd5a1e407fe24b0a692b9c3b" translate="yes" xml:space="preserve">
          <source>In block-level layouts, the keyword is a synonym of &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">블록 레벨 레이아웃에서 키워드는 &lt;code&gt;start&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="26a299e382b8448c7a752f1a4bf54709bb82360d" translate="yes" xml:space="preserve">
          <source>In both cases the start edge of the cross axis is at the top of the flex container and the end edge at the bottom, as both languages have a horizontal writing mode.</source>
          <target state="translated">두 경우 모두 가로 쓰기 모드를 갖기 때문에 크로스 축의 시작 가장자리는 플렉스 컨테이너의 상단에 있고 끝 가장자리는 하단에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a56fdac7dd1cebd3be24f995c230f163005d10f" translate="yes" xml:space="preserve">
          <source>In case of equality, the &lt;a href=&quot;specificity&quot;&gt;specificity&lt;/a&gt; of a value is considered to choose one or the other.</source>
          <target state="translated">동등의 경우 , 값 의 &lt;a href=&quot;specificity&quot;&gt;특이성&lt;/a&gt; 은 하나 또는 다른 것을 선택하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4ada1826d99f923bb087fefa93d349bfeaaeabad" translate="yes" xml:space="preserve">
          <source>In cases where a fragment identifier points to a portion of the document, readers may become confused about which part of the document they're supposed to be reading. By styling the target of a URI, reader confusion can be reduced or eliminated.</source>
          <target state="translated">조각 식별자가 문서의 일부를 가리키는 경우 독자는 읽고 자하는 문서의 일부에 대해 혼동 될 수 있습니다. URI의 대상을 스타일링함으로써 독자 혼란을 줄이거 나 없앨 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8822ee8e3c2ebb232b8be0a9babe46236ee7a02d" translate="yes" xml:space="preserve">
          <source>In comparison, the grid version always has three column tracks. The tracks themselves will grow and shrink, but there are always three since we asked for three when defining our grid.</source>
          <target state="translated">이에 비해 그리드 버전에는 항상 3 개의 열 트랙이 있습니다. 트랙 자체는 커지거나 줄어들지 만 그리드를 정의 할 때 3 개를 요청한 이후 항상 3 개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8bff5d41de2a92f7170015e9723fc1ecca75443" translate="yes" xml:space="preserve">
          <source>In each case, we show what the source image looks like rendered in a 150x150 box, and provide a link to the SVG source.</source>
          <target state="translated">각각의 경우 소스 이미지가 150x150 상자에 렌더링 된 모습을 보여주고 SVG 소스에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90f819a00a14e6b245d16ec2afdf72e73458d1e7" translate="yes" xml:space="preserve">
          <source>In earlier versions of the &lt;code&gt;font-stretch&lt;/code&gt; specification, the property accepts only the nine keyword values. CSS Fonts Level 4 extends the syntax to accept a &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; value as well. This enables variable fonts to offer something more like a continuum of character widths. For TrueType or OpenType variable fonts, the &quot;wdth&quot; variation is used to implement varying widths.</source>
          <target state="translated">&lt;code&gt;font-stretch&lt;/code&gt; 스펙 의 이전 버전 에서이 특성은 9 개의 키워드 값만 허용합니다. CSS Fonts Level 4는 &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; 값 을 허용하도록 구문을 확장합니다 . 이를 통해 가변 글꼴이 연속적인 문자 너비와 같은 것을 제공 할 수 있습니다. TrueType 또는 OpenType 변수 글꼴의 경우 &quot;wdth&quot;변형은 다양한 너비를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1521de2eb98f5349d7def135482bed50108914" translate="yes" xml:space="preserve">
          <source>In earlier versions of the &lt;code&gt;font-weight&lt;/code&gt; specification, the property accepts only keyword values and the numeric values 100, 200, 300, 400, 500, 600, 700, 800, and 900. CSS Fonts Level 4 extends the syntax to accept any number between 1 and 1000. This enables variable fonts to provide a much finer-grained range of font weights. Note that this is not yet supported by all browsers.</source>
          <target state="translated">&lt;code&gt;font-weight&lt;/code&gt; 사양 의 이전 버전 에서이 속성은 키워드 값과 숫자 값 100, 200, 300, 400, 500, 600, 700, 800 및 900 만 허용합니다. CSS 글꼴 수준 4는 모든 숫자를 허용하도록 구문을 확장합니다. 가변 글꼴을 사용하면보다 세밀한 글꼴 가중치 범위를 제공 할 수 있습니다. 아직 모든 브라우저에서 지원되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f1ea47a51b0dbd995252884124bb680f309b40b1" translate="yes" xml:space="preserve">
          <source>In flexbox layouts, this keyword has no meaning as this property is &lt;em&gt;ignored.&lt;/em&gt;</source>
          <target state="translated">flexbox 레이아웃에서이 키워드는이 속성이 &lt;em&gt;무시&lt;/em&gt; 되므로 의미가 없습니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83ef9a793fa5b50c40d9e8a4b9cbd47e993ade96" translate="yes" xml:space="preserve">
          <source>In flexbox layouts, this property is &lt;em&gt;ignored&lt;/em&gt; (&lt;a href=&quot;css_box_alignment/box_alignment_in_flexbox&quot;&gt;more&lt;/a&gt; about alignment in Flexbox)</source>
          <target state="translated">Flexbox 레이아웃에서이 속성은 &lt;em&gt;무시됩니다&lt;/em&gt; ( Flexbox의 정렬에 대한 &lt;a href=&quot;css_box_alignment/box_alignment_in_flexbox&quot;&gt;자세한&lt;/a&gt; 내용).</target>
        </trans-unit>
        <trans-unit id="7c78c0cb0eddf793f4122fccb9a00ad7cb16a7da" translate="yes" xml:space="preserve">
          <source>In formal syntax, data types are denoted by a keyword placed between the inequality signs &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot;.</source>
          <target state="translated">형식적인 구문에서 데이터 형식은 부등호 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot;사이에있는 키워드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="160e478f14b6d24175aca6998e2eb0bc9a4c24a7" translate="yes" xml:space="preserve">
          <source>In fragmented media, once a fragment (for example a page) is filled with columns, the columns will move to a new page and fill that up with columns. In continuous media, columns will overflow in the inline direction. On the web this means that you will get a horizontal scrollbar.</source>
          <target state="translated">조각난 미디어에서 조각 (예 : 페이지)이 열로 채워지면 열이 새 페이지로 이동하여 열로 채워집니다. 연속 용지에서는 열이 인라인 방향으로 오버플로됩니다. 웹에서는 가로 스크롤 막대가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="87e9056c2b206cd9248d3207f0bfebd454cea773" translate="yes" xml:space="preserve">
          <source>In full screen mode, the viewport is the device screen, the window is the browser window, which can be as big as viewport or smaller, and the document is the website, which can be much taller or wider than the viewport. The viewport is basically the part of the document that is currently visible.</source>
          <target state="translated">전체 화면 모드에서 뷰포트는 장치 화면이고, 윈도우는 브라우저 창으로, 뷰포트보다 크거나 작을 수 있으며, 문서는 웹 사이트이며, 뷰포트보다 더 크거나 넓을 수 있습니다. 뷰포트는 기본적으로 현재 보이는 문서의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="4a96d7b3a7aea1f5aee0bcb31ca5e0422c3c536f" translate="yes" xml:space="preserve">
          <source>In general, for a requested angle of 14 degrees or greater, larger angles are prefered; otherwise, smaller angles are preferred (see the spec's &lt;a href=&quot;https://drafts.csswg.org/css-fonts-4/#font-matching-algorithm&quot;&gt;font matching section&lt;/a&gt; for the precise algorithm).</source>
          <target state="translated">일반적으로 요청 된 각도가 14도 이상인 경우 더 큰 각도가 선호됩니다. 그렇지 않으면 더 작은 각도가 선호됩니다 ( 정확한 알고리즘 은 사양의 &lt;a href=&quot;https://drafts.csswg.org/css-fonts-4/#font-matching-algorithm&quot;&gt;글꼴 일치 섹션&lt;/a&gt; 을 참조하십시오 ).</target>
        </trans-unit>
        <trans-unit id="faf305d8f4b75c9f3277e35e04297e3b66586611" translate="yes" xml:space="preserve">
          <source>In general:</source>
          <target state="translated">일반적으로 :</target>
        </trans-unit>
        <trans-unit id="235862adf1c0905968addd047f638ceaeab13e2b" translate="yes" xml:space="preserve">
          <source>In grid layouts, it aligns an item inside its grid area on the inline axis (&lt;a href=&quot;css_box_alignment/box_alignment_in_grid_layout&quot;&gt;more&lt;/a&gt; about alignment in grid layouts)</source>
          <target state="translated">그리드 레이아웃에서는 인라인 축의 그리드 영역 안에 항목을 정렬합니다 ( 그리드 레이아웃 정렬에 대한 &lt;a href=&quot;css_box_alignment/box_alignment_in_grid_layout&quot;&gt;자세한&lt;/a&gt; 내용).</target>
        </trans-unit>
        <trans-unit id="c1000a9a2d8ad7132a72dee322a658058d0134b7" translate="yes" xml:space="preserve">
          <source>In grid layouts, it aligns the items inside their grid areas on the inline axis (&lt;a href=&quot;css_box_alignment/box_alignment_in_grid_layout&quot;&gt;more&lt;/a&gt; about alignment in grid layouts)</source>
          <target state="translated">그리드 레이아웃에서는 인라인 축의 그리드 영역 안에있는 항목을 정렬합니다 ( 그리드 레이아웃의 정렬에 대한 &lt;a href=&quot;css_box_alignment/box_alignment_in_grid_layout&quot;&gt;자세한&lt;/a&gt; 내용).</target>
        </trans-unit>
        <trans-unit id="5263e9f74458ab1eef81d089ebf289bae34bf06d" translate="yes" xml:space="preserve">
          <source>In grid layouts, this keyword leads to a behavior similar to the one of &lt;code&gt;stretch&lt;/code&gt;, except for boxes with an aspect ratio or an intrinsic sizes where it behaves like &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">그리드 레이아웃에서이 키워드 는 종횡비가있는 상자 또는 &lt;code&gt;start&lt;/code&gt; 과 같이 동작하는 고유 크기를 제외하고 는 &lt;code&gt;stretch&lt;/code&gt; 와 유사한 동작을 유발합니다 .</target>
        </trans-unit>
        <trans-unit id="93e2fafd974277555f26943911ad44c399f62353" translate="yes" xml:space="preserve">
          <source>In grid properties it is relative to the inline size of the grid container in column tracks and to the block size of the grid container for row tracks. Otherwise it is relative to the available inline size or block size of the laid out box depending on the writing mode.</source>
          <target state="translated">그리드 속성에서는 열 트랙에있는 그리드 컨테이너의 인라인 크기와 행 트랙에 대한 그리드 컨테이너의 블록 크기를 기준으로합니다. 그렇지 않으면 쓰기 모드에 따라 배치 된 상자의 사용 가능한 인라인 크기 또는 블록 크기를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="9e3b6993ce2317ef8b30cedd90fab07e2ecfc02d" translate="yes" xml:space="preserve">
          <source>In including an iframe, the visual viewport is the size of the inner width and height of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; of the parent document. You can set any height and width on an iframe, but the whole document may not be visible.</source>
          <target state="translated">iframe을 포함 할 때 시각적 뷰포트는 부모 문서 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 내부 너비와 높이의 크기입니다 . iframe에서 높이와 너비를 설정할 수 있지만 전체 문서가 보이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="821c5084ca337243035578194e03467f6c7e6caa" translate="yes" xml:space="preserve">
          <source>In many browsers, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea&quot;&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;&lt;/a&gt; elements are resizable by default. You may override this behavior with the &lt;code&gt;resize&lt;/code&gt; property.</source>
          <target state="translated">많은 브라우저에서 기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea&quot;&gt; &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 크기를 조정할 수 있습니다. &lt;code&gt;resize&lt;/code&gt; 속성 으로이 동작을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc2d288a9f39ff1b64356465fca53bdc8ba89156" translate="yes" xml:space="preserve">
          <source>In most cases, flow layout works as you would expect it to when changing the writing mode of the document or parts of the document. This can be used to properly typeset vertical languages or for creative reasons. CSS is making this easier by way of introducing logical properties and values so that when working in a vertical writing mode sizing can be based on element's inline and block size. This will be useful when creating components which can work in different writing-modes.</source>
          <target state="translated">대부분의 경우 흐름 레이아웃은 문서 또는 문서 일부의 쓰기 모드를 변경할 때 예상대로 작동합니다. 이것은 수직 언어를 올바르게 조판하거나 ​​독창적 인 이유로 사용할 수 있습니다. CSS는 논리적 속성과 값을 도입하여 이것을 쉽게 만들어 세로 쓰기 모드에서 작업 할 때 크기가 요소의 인라인 및 블록 크기를 기반으로 할 수 있습니다. 다른 쓰기 모드에서 작동 할 수있는 구성 요소를 만들 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3bef99e1a0b0a957ab5e44eda6dc1aff8ecb35c9" translate="yes" xml:space="preserve">
          <source>In moving to CSS we often spoke about CSS for layout enabling a separation of content and markup and presentation. The ultimate aim being that we could create a semantic and well structured document, then apply CSS to create the layout we desired. Sites such as the &lt;a href=&quot;http://www.csszengarden.com/&quot;&gt;CSS Zen Garden&lt;/a&gt; showcased this ability. The &lt;a href=&quot;http://www.csszengarden.com/&quot;&gt;CSS Zen Garden&lt;/a&gt; challenged us to take identical markup and create a unique design using CSS.</source>
          <target state="translated">CSS로 이동할 때 종종 컨텐츠와 마크 업 및 프리젠 테이션을 분리 할 수있는 레이아웃을위한 CSS에 대해 이야기했습니다. 궁극적 인 목표는 의미적이고 체계적인 문서를 만든 다음 CSS를 적용하여 원하는 레이아웃을 만들 수 있다는 것입니다. &lt;a href=&quot;http://www.csszengarden.com/&quot;&gt;CSS Zen Garden&lt;/a&gt; 과 같은 사이트 에서이 기능을 선보였습니다. &lt;a href=&quot;http://www.csszengarden.com/&quot;&gt;CSS 선 정원은&lt;/a&gt; 동일한 마크 업을하고 CSS를 사용하여 독특한 디자인을 만들기 위해 우리를 도전했다.</target>
        </trans-unit>
        <trans-unit id="815a54f3c3d216995b4a7fe9ee3323dfd4b8f1b9" translate="yes" xml:space="preserve">
          <source>In multi-column layout the alignment container is the content box of the multicol container. The alignment subject is the column box. The properties which apply to multi-column layouts are detailed below.</source>
          <target state="translated">다중 열 레이아웃에서 정렬 컨테이너는 멀티 콜 컨테이너의 내용 상자입니다. 정렬 주제는 열 상자입니다. 다중 열 레이아웃에 적용되는 속성은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cba2bdeb13f441f19f7ad76edbbb040c277cb28d" translate="yes" xml:space="preserve">
          <source>In normal flow, &lt;strong&gt;inline&lt;/strong&gt; elements display in the inline direction, that is in the direction words are displayed in a sentence according to the &lt;a href=&quot;css_writing_modes&quot;&gt;Writing Mode&lt;/a&gt; of the document. &lt;strong&gt;Block&lt;/strong&gt; elements display one after the other, as paragraphs do in the Writing Mode of that document. In English therefore, inline elements display one after the other, starting on the left, and block elements start at the top and move down the page.</source>
          <target state="translated">정상적인 흐름에서 &lt;strong&gt;인라인&lt;/strong&gt; 요소는 인라인 방향으로 표시됩니다. 즉, 방향은 워드 의 문서 가 &lt;a href=&quot;css_writing_modes&quot;&gt;쓰기 모드&lt;/a&gt; 에 따라 문장으로 표시됩니다 . 단락은 해당 문서의 쓰기 모드에서와 같이 &lt;strong&gt;블록&lt;/strong&gt; 요소가 차례로 표시됩니다. 따라서 영어에서는 인라인 요소가 왼쪽부터 차례로 표시되고 블록 요소가 맨 위에서 시작하여 페이지 아래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="33b241f9b47c32be3ad86e3dff16fe926bd8bba9" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;overflow&lt;/code&gt; to have an effect, the block-level container must have either a set height (&lt;code&gt;height&lt;/code&gt; or &lt;code&gt;max-height&lt;/code&gt;) or &lt;code&gt;white-space&lt;/code&gt; set to &lt;code&gt;nowrap&lt;/code&gt;.</source>
          <target state="translated">위해서는 &lt;code&gt;overflow&lt;/code&gt; 하는 효과를 갖기 위해, 블록 레벨 컨테이너 세트 높이 (하나 있어야 &lt;code&gt;height&lt;/code&gt; 또는 &lt;code&gt;max-height&lt;/code&gt; ) 또는 &lt;code&gt;white-space&lt;/code&gt; 으로 설정 &lt;code&gt;nowrap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bc67cd685a5647dbccf91218e3f47a5aaacaba1" translate="yes" xml:space="preserve">
          <source>In order to avoid this and get some indentation, there are really only three options available to browser implementors.</source>
          <target state="translated">이것을 피하고 들여 쓰기를하기 위해 브라우저 구현자가 사용할 수있는 옵션은 실제로 세 가지뿐입니다.</target>
        </trans-unit>
        <trans-unit id="e674677bd8087556acbbdc338b8d029b99e4a1a8" translate="yes" xml:space="preserve">
          <source>In order to calculate the em equivalent for any pixel value required, you can use this formula:</source>
          <target state="translated">필요한 픽셀 값에 해당하는 em을 계산하기 위해 다음 공식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e796f07b739733e028929493890852e5ac039f94" translate="yes" xml:space="preserve">
          <source>In order to make the layout neater I can use multiple &lt;code&gt;.&lt;/code&gt; characters. As long as there is no white space between the full stops it will be counted as one cell. For a complex layout there is a benefit to having the rows and columns neatly aligned. It means that you can actually see, right there in the CSS, what this layout looks like.</source>
          <target state="translated">레이아웃을 깔끔하게 만들기 위해 여러 개를 사용할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 문자. 완전 정지 사이에 공백이 없으면 하나의 셀로 계산됩니다. 복잡한 레이아웃의 경우 행과 열을 깔끔하게 정렬하면 이점이 있습니다. 즉, CSS에서 바로이 레이아웃의 모습을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c2ee5e717806c3ca5da0a46bb0fe8b93ab388f" translate="yes" xml:space="preserve">
          <source>In order to understand why this is the case, and more importantly how to avoid the problem altogether, it's necessary to examine the details of list construction.</source>
          <target state="translated">이것이 왜 그런지 이해하고 더 중요하게 문제를 피하는 방법을 이해하려면리스트 구성의 세부 사항을 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="78fc8b3d4273a107ef3febe9f1c1ad43a7ee28ec" translate="yes" xml:space="preserve">
          <source>In order to work out how much space there is available to lay out flex items, the browser needs to know how big the item is to start with. How is this worked out for items that don&amp;rsquo;t have a width or a height applied using an absolute length unit?</source>
          <target state="translated">플렉스 아이템을 배치 할 수있는 공간이 얼마나되는지 알아 내기 위해서는 브라우저가 아이템이 얼마나 큰지 알아야합니다. 너비 또는 높이가 절대 길이 단위를 사용하여 적용되지 않은 항목에 대해서는 어떻게 해결 되었습니까?</target>
        </trans-unit>
        <trans-unit id="546eb5da7f7ca7309b47cfd26096baf5dddfefe9" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;basic_shapes&quot;&gt;Guide to Basic Shapes&lt;/a&gt; we explore each of the possible Basic Shapes and how to create them.</source>
          <target state="translated">우리에서 &lt;a href=&quot;basic_shapes&quot;&gt;기본 도형에 대한 가이드&lt;/a&gt; 우리는 가능한 기본 도형의 각을 탐구하고 방법을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655e44b1236ca04d2821a3d073a5362998897cb7" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;https://mdn.github.io/css-examples/overscroll-behavior/&quot;&gt;overscroll-behavior example&lt;/a&gt; (see the &lt;a href=&quot;https://github.com/mdn/css-examples/tree/master/overscroll-behavior&quot;&gt;source code&lt;/a&gt; also), we present a full-page list of fake contacts, and a dialog box containing a chat window.</source>
          <target state="translated">우리에서 &lt;a href=&quot;https://mdn.github.io/css-examples/overscroll-behavior/&quot;&gt;오버 스크롤 - 행동 예를&lt;/a&gt; 합니다 (참조 &lt;a href=&quot;https://github.com/mdn/css-examples/tree/master/overscroll-behavior&quot;&gt;소스 코드&lt;/a&gt; 도), 우리는 가짜 연락처의 전체 페이지 목록 및 채팅 창을 포함하는 대화 상자를 제시한다.</target>
        </trans-unit>
        <trans-unit id="feb7915d89dc5c0ac4667486f685f66c5fcbdabd" translate="yes" xml:space="preserve">
          <source>In our example each of the areas spans multiple grid cells and we achieve this by repeating the name of that grid area multiple times with white space between. You can add extra white space in order to keep your columns neatly lined up in the value of &lt;code&gt;grid-template-areas&lt;/code&gt;. You can see that I have done this in order that the &lt;code&gt;hd&lt;/code&gt; and &lt;code&gt;ft&lt;/code&gt; line up with &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">이 예에서 각 영역은 여러 그리드 셀에 걸쳐 있으며 그 사이의 공백을 사용하여 그리드 영역의 이름을 여러 번 반복하여이를 달성합니다. &lt;code&gt;grid-template-areas&lt;/code&gt; 값에 열이 깔끔하게 정렬되도록 공백을 추가 할 수 있습니다 . &lt;code&gt;hd&lt;/code&gt; 와 &lt;code&gt;ft&lt;/code&gt; 가 &lt;code&gt;main&lt;/code&gt; 과 정렬되도록이 작업을 수행했음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ecd8d34c8b18fc87a5e2a65029b72e721fb2cac" translate="yes" xml:space="preserve">
          <source>In our initial example with &lt;code&gt;display: flex&lt;/code&gt; on the container, the items display as a row and all line up at the start of the container. This is due to the initial value of &lt;code&gt;justify-content&lt;/code&gt; being &lt;code&gt;flex-start&lt;/code&gt;. Any available space is placed at the end of the items.</source>
          <target state="translated">컨테이너에 &lt;code&gt;display: flex&lt;/code&gt; 를 사용하는 초기 예제 에서 컨테이너 시작시 항목이 행으로 표시되고 모든 줄이 표시됩니다. 이는 &lt;code&gt;justify-content&lt;/code&gt; 의 초기 값 이 &lt;code&gt;flex-start&lt;/code&gt; 이기 때문 입니다. 사용 가능한 공간은 항목의 끝에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="972b1f6fe5ad06ab71ac12e25b912fae3971103b" translate="yes" xml:space="preserve">
          <source>In our simple &lt;a href=&quot;https://mdn.github.io/css-examples/overscroll-behavior/overscroll-behavior-x&quot;&gt;overscroll-behavior-x example&lt;/a&gt; (see &lt;a href=&quot;https://github.com/mdn/css-examples/blob/master/overscroll-behavior/overscroll-behavior-x.html&quot;&gt;source code&lt;/a&gt; also), we have two block-level boxes, one inside the other. The outer box has a large &lt;a href=&quot;width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; set on it so the page will scroll horizontally. The inner box has a small width (and &lt;a href=&quot;height&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/a&gt;) set on it so it sits comforably inside the viewport, but its content is given a large &lt;code&gt;width&lt;/code&gt; so it will scroll horizontally.</source>
          <target state="translated">간단한 &lt;a href=&quot;https://mdn.github.io/css-examples/overscroll-behavior/overscroll-behavior-x&quot;&gt;오버 스크롤 동작 -x 예제&lt;/a&gt; ( &lt;a href=&quot;https://github.com/mdn/css-examples/blob/master/overscroll-behavior/overscroll-behavior-x.html&quot;&gt;소스 코드&lt;/a&gt; 도 참조 )에는 두 개의 블록 수준 상자가 있습니다. 하나는 다른 상자 안에 있습니다. 외부 상자에는 &lt;a href=&quot;width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 가 크게 설정되어 있으므로 페이지가 가로로 스크롤됩니다. 내부 상자에는 너비와 &lt;a href=&quot;height&quot;&gt; &lt;code&gt;height&lt;/code&gt; &lt;/a&gt; 가 작게 설정되어 뷰포트 내부에 편안하게 놓일 수 있지만 내용의 &lt;code&gt;width&lt;/code&gt; 가로로 스크롤됩니다.</target>
        </trans-unit>
        <trans-unit id="17bafec10322c5b78938f961b98dc5cfb21b43d6" translate="yes" xml:space="preserve">
          <source>In particular, &lt;a href=&quot;background-image&quot;&gt;&lt;code&gt;background-image&lt;/code&gt;&lt;/a&gt; is ignored.</source>
          <target state="translated">특히 &lt;a href=&quot;background-image&quot;&gt; &lt;code&gt;background-image&lt;/code&gt; &lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e964a6b4af21bcbe5652865a972979698bec26" translate="yes" xml:space="preserve">
          <source>In practice the shrinking behaviour does tend to give you reasonable results. You don&amp;rsquo;t usually want your content to disappear completely or for boxes to get smaller than their minimum content, so the above rules make sense in terms of sensible behaviour for content that needs to be shrunk in order to fit into a container.</source>
          <target state="translated">실제로 수축 동작은 합리적인 결과를 제공하는 경향이 있습니다. 일반적으로 콘텐츠가 완전히 사라지거나 상자가 최소 콘텐츠보다 작아지는 것을 원하지 않으므로 위 규칙은 컨테이너에 맞추기 위해 축소해야하는 콘텐츠의 합리적인 동작 측면에서 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c11c06f78fe3f759320749e6b4a8043fd547a84" translate="yes" xml:space="preserve">
          <source>In previous guides we&amp;rsquo;ve looked at placing items by the lines created by defining grid tracks and also how to place items using named template areas. In this guide we are going to look at how these two things work together when we use named lines. Line naming is incredibly useful, but some of the more baffling looking grid syntax comes from this combination of names and track sizes. Once you work through some examples it should become clearer and easier to work with.</source>
          <target state="translated">이전 가이드에서는 그리드 트랙을 정의하여 만든 선으로 항목을 배치하고 명명 된 템플릿 영역을 사용하여 항목을 배치하는 방법을 살펴 보았습니다. 이 가이드에서는 명명 된 줄을 사용할 때이 두 가지가 어떻게 작동하는지 살펴 보겠습니다. 라인 이름 지정은 매우 유용하지만, 좀 더 당황스럽게 보이는 격자 구문은 이러한 이름과 트랙 크기 조합에서 비롯됩니다. 몇 가지 예제를 통해 작업하면보다 명확하고 작업하기 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="9d127d2697bfe9ab7be9c786bd85c4f24b4fdcd7" translate="yes" xml:space="preserve">
          <source>In rare scenarios, if you're using nested link elements and the element being matched is different from the link whose presence in history is being tested, the element will be rendered as if the link were unvisited, as well.</source>
          <target state="translated">드물게 중첩 된 링크 요소를 사용하고 있고 일치하는 요소가 히스토리에서 존재 여부를 테스트중인 링크와 다른 경우 링크를 방문하지 않은 것처럼 요소가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="59c94a0ffaf543fef5726cc5849aebaa44a3aaf4" translate="yes" xml:space="preserve">
          <source>In reality we also often use Flexbox for jobs that might be better done by Grid Layout, as a fallback for Grid, and also in order to get alignment capabilities. This is something that may well change once Box Alignment is implemented in Block Layout. In this guide I look at some of the typical things you might use flexbox for today.</source>
          <target state="translated">실제로 그리드 레이아웃에 의해 더 잘 수행 될 수있는 작업, 그리드에 대한 폴백 및 정렬 기능을 얻기 위해 Flexbox를 종종 사용합니다. 이것은 블록 정렬에서 Box Alignment가 구현되면 잘 변경 될 수 있습니다. 이 가이드에서는 오늘날 flexbox를 사용할 수있는 몇 가지 일반적인 사항을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="c79d93d6ab63d3f0da43423583854d534e964565" translate="yes" xml:space="preserve">
          <source>In recent Windows versions (e.g., 10), if accent colors are enabled in window titlebars, this is 1. Otherwise it's 0.</source>
          <target state="translated">최근 Windows 버전 (예 : 10)에서 창 제목 표시 줄에서 강조 색이 활성화 된 경우 1입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="0d0a4822a0f4f0e70ffefecb0d8b3b58f5b2862b" translate="yes" xml:space="preserve">
          <source>In some cases these behaviors are not desirable. you can use &lt;code&gt;overscroll-behavior&lt;/code&gt; to get rid of unwanted scroll chaining and the browser's Facebook/Twitter app-inspired &quot;pull to refresh&quot;-type behavior.</source>
          <target state="translated">어떤 경우에는 이러한 행동이 바람직하지 않습니다. &lt;code&gt;overscroll-behavior&lt;/code&gt; 스크롤 동작 을 사용 하여 원치 않는 스크롤 체인과 브라우저의 Facebook / Twitter 앱에서 영감을 얻은 &quot;새로 고치기&quot;유형 동작을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22ea5096d8162c98ffca057c4340c413e777fa12" translate="yes" xml:space="preserve">
          <source>In some cases you could happily use either layout method, but as you become confident with both you will find each one suiting different layout needs, and you will end up with both methods in your CSS. There is rarely a right or wrong answer.</source>
          <target state="translated">어떤 경우에는 두 가지 레이아웃 방법 중 하나를 행복하게 사용할 수 있지만 두 가지 방법을 모두 사용하면 서로 다른 레이아웃 요구에 맞는 것을 찾고 CSS에서 두 가지 방법을 모두 사용할 수 있습니다. 옳고 그른 대답은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7141f6e5b6db63bb657ba0194ef796c35ebe297" translate="yes" xml:space="preserve">
          <source>In some cases, the visual formatting algorithm needs to add supplementary boxes. Because CSS selectors cannot style or name these boxes, they are called &lt;em&gt;anonymous boxes&lt;/em&gt;.</source>
          <target state="translated">경우에 따라 시각적 형식화 알고리즘은 보충 상자를 추가해야합니다. CSS 선택기는 이러한 상자의 스타일을 지정하거나 이름을 지정할 수 없으므로 &lt;em&gt;익명 상자&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="a5f67b6c533ef6e46bf5be2fd66df1ead1904ee7" translate="yes" xml:space="preserve">
          <source>In some environments, an equivalent bidirectional resize cursor is shown. For example, &lt;code&gt;n-resize&lt;/code&gt; and &lt;code&gt;s-resize&lt;/code&gt; are the same as &lt;code&gt;ns-resize&lt;/code&gt;.</source>
          <target state="translated">일부 환경에서는 동등한 양방향 크기 조정 커서가 표시됩니다. 예를 들어, &lt;code&gt;n-resize&lt;/code&gt; 및 &lt;code&gt;s-resize&lt;/code&gt; 는 &lt;code&gt;ns-resize&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="184bacc96e77ecd25debbec8e986516a912a68e8" translate="yes" xml:space="preserve">
          <source>In static position of absolutely-positioned layouts, the keyword behaves as &lt;code&gt;stretch&lt;/code&gt;.</source>
          <target state="translated">절대적으로 배치 된 레이아웃의 정적 위치에서 키워드는 &lt;code&gt;stretch&lt;/code&gt; 로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fd86dab69095a456e4783b222bc7eb24f8747ca0" translate="yes" xml:space="preserve">
          <source>In such a scenario, in order to use a typeface for typical use on a site for body copy you would need at least four files: regular, italic, bold, and bold italic. If you wanted to add more weights, like a lighter one for captions or a heavier one for extra emphasis, that would mean several more files. This results in more HTTP requests, and more data being downloaded (usually around 20k or more per file).</source>
          <target state="translated">이러한 시나리오에서 본문에 대 한 사이트에서 일반적인 용도로 서체를 사용하려면 일반, 기울임 꼴, 굵게 및 굵은 기울임 꼴의 파일이 4 개 이상 필요합니다. 캡션의 경우 더 가벼워 지거나 강조 할 때의 경우에는 더 많은 가중치를 추가하려는 경우 파일이 몇 개 더 필요합니다. 이로 인해 더 많은 HTTP 요청과 더 많은 데이터가 다운로드됩니다 (일반적으로 파일 당 약 20k 이상).</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="58fe6afac4b0c54dd6862e02fb0bff767ab18a56" translate="yes" xml:space="preserve">
          <source>In table cell layouts, this keyword has no meaning as this property is &lt;em&gt;ignored&lt;/em&gt;.</source>
          <target state="translated">테이블 셀 레이아웃에서이 키워드는이 속성이 &lt;em&gt;무시&lt;/em&gt; 되므로 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eceaf9ffe4699da43dad29f2d4afb1b1137d02ad" translate="yes" xml:space="preserve">
          <source>In table cell layouts, this property is &lt;em&gt;ignored&lt;/em&gt; (&lt;a href=&quot;css_box_alignment/box_alignment_in_block_abspos_tables&quot;&gt;more&lt;/a&gt; about alignment in block, absolute positioned and table layout)</source>
          <target state="translated">테이블 셀 레이아웃에서이 속성은 &lt;em&gt;무시됩니다&lt;/em&gt; ( 블록 정렬, 절대 위치 및 테이블 레이아웃에 대한 &lt;a href=&quot;css_box_alignment/box_alignment_in_block_abspos_tables&quot;&gt;자세한&lt;/a&gt; 내용).</target>
        </trans-unit>
        <trans-unit id="80acf15a586cb8009da2b8e956975625d370671b" translate="yes" xml:space="preserve">
          <source>In table layout, you have access to the &lt;a href=&quot;../vertical-align&quot;&gt;&lt;code&gt;vertical-align&lt;/code&gt;&lt;/a&gt; property to align the contents of a cell inside that cell.</source>
          <target state="translated">테이블 레이아웃에서는 &lt;a href=&quot;../vertical-align&quot;&gt; &lt;code&gt;vertical-align&lt;/code&gt; &lt;/a&gt; 속성에 액세스하여 해당 셀 내부의 셀 내용을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="353e6bdc18ad24d6d8ae1d1fcaa926596ef45662" translate="yes" xml:space="preserve">
          <source>In terms of line-based positioning of items, the gap acts as if the line has gained extra width. Anything starting at that line starts after the gap and you cannot address the gap or place anything into it. If you want gutters that act more like regular tracks you can of course define a track for the purpose instead.</source>
          <target state="translated">품목의 선 기반 위치 지정 측면에서 간격은 선이 추가 너비를 얻은 것처럼 작동합니다. 해당 라인에서 시작하는 것은 공백 이후에 시작되며 공백을 처리하거나 그 안에 아무것도 넣을 수 없습니다. 일반 트랙처럼 작동하는 거터를 원한다면 물론 목적에 맞게 트랙을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25fe61c56dcfe62ee9d8eea3a0e76c9ed83aa852" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic_concepts_of_flexbox&quot;&gt;Basic concepts of flexbox&lt;/a&gt; article, I explained that flexbox is &lt;strong&gt;writing mode aware&lt;/strong&gt;. Writing modes are fully detailed in the CSS &lt;a href=&quot;https://www.w3.org/TR/css-writing-modes-3/&quot;&gt;Writing Modes specification&lt;/a&gt;, which details how CSS supports the various different writing modes that exist internationally. We need to be aware of how this will impact our flex layouts as writing mode changes the direction that blocks are laid out in our document. Understanding &lt;strong&gt;block&lt;/strong&gt; and &lt;strong&gt;inline&lt;/strong&gt; directions is key to new layout methods.</source>
          <target state="translated">&lt;a href=&quot;basic_concepts_of_flexbox&quot;&gt;flexbox&lt;/a&gt; 기사 의 기본 개념에서 flexbox가 &lt;strong&gt;쓰기 모드 인식&lt;/strong&gt; 이라고 설명했습니다 . 쓰기 모드는 CSS &lt;a href=&quot;https://www.w3.org/TR/css-writing-modes-3/&quot;&gt;쓰기 모드 사양&lt;/a&gt; 에 자세히 설명되어 있으며 CSS는 국제적으로 존재하는 다양한 쓰기 모드를 지원하는 방법을 자세히 설명합니다. 쓰기 모드가 문서에서 블록이 배치되는 방향을 변경함에 따라 이것이 플렉스 레이아웃에 어떤 영향을 미치는지 알아야합니다. 새로운 레이아웃 방법의 핵심은 &lt;strong&gt;블록&lt;/strong&gt; 및 &lt;strong&gt;인라인&lt;/strong&gt; 방향을 이해 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07ebc4cbf7b7ec9c8371444b58a60156d63ff2bc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic_concepts_of_grid_layout&quot;&gt;article covering the basic concepts of grid layout&lt;/a&gt;, we started to look at how to position items on a grid using line numbers. In this article we will fully explore how this fundamental feature of the specification works.</source>
          <target state="translated">에서 &lt;a href=&quot;basic_concepts_of_grid_layout&quot;&gt;그리드 레이아웃의 기본 개념을 다루는 기사&lt;/a&gt; , 우리는 줄 번호를 사용하여 그리드에 위치 항목에 방법에 대해 살펴 시작했다. 이 기사에서는 사양의 기본 기능이 어떻게 작동하는지 완전히 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="ead29de3cc6401e8b44858b9149cb3c2a76216c8" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;block_and_inline_layout_in_normal_flow&quot;&gt;previous guide&lt;/a&gt; I explained block and inline layout in normal flow. All elements that are in flow, will be laid out using this method.</source>
          <target state="translated">에서 &lt;a href=&quot;block_and_inline_layout_in_normal_flow&quot;&gt;이전 가이드&lt;/a&gt; I 정상 흐름 인라인 블록 레이아웃을 설명한다. 흐르는 모든 요소는이 방법을 사용하여 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8feb1cbe8814ec4e19f5d2a43e993e883f394163" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; attribute, they define the media to which a linked resource (typically CSS) should be applied.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; 속성들은 링크 자원 (전형적 CSS)이 적용되어야하는 매체를 정의한다.</target>
        </trans-unit>
        <trans-unit id="2df3cd51a6783673dceb2b325c42a34c86a4aff7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt;&lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt;&lt;/a&gt; element's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; attribute, they define the media to which that source should be applied. (This is only valid inside &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture&quot;&gt;&lt;code&gt;&amp;lt;picture&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.)</source>
          <target state="translated">에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt; &lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; 속성들은 그 소스가 적용되어야하는 매체를 정의한다. (이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture&quot;&gt; &lt;code&gt;&amp;lt;picture&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 내에서만 유효 합니다.)</target>
        </trans-unit>
        <trans-unit id="f783bf7d1d6da6cb40f80b7969bef523dfc3acef" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; attribute, they define the media to which the style should be applied.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style#attr-media&quot;&gt;media&lt;/a&gt;&lt;/code&gt; 속성, 그들은 스타일이 적용되어야하는 미디어를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="22059d3e23365089e9c88cbb1517209bc0592f31" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;line-based_placement_with_css_grid&quot;&gt;previous guide&lt;/a&gt; we looked at grid lines, and how to position items against those lines. When you use CSS Grid Layout you always have lines, and this can be a straightforward way to place items on your grid. However, there is an alternate method to use for positioning items on the grid which you can use alone or in combination with line-based placement. This method involves placing our items using named template areas, and we will find out exactly how this method works. You will see very quickly why we sometimes call this the ascii-art method of grid layout!</source>
          <target state="translated">&lt;a href=&quot;line-based_placement_with_css_grid&quot;&gt;이전 가이드&lt;/a&gt; 에서는 그리드 선과 해당 선에 항목을 배치하는 방법을 살펴 보았습니다. CSS 그리드 레이아웃을 사용하면 항상 선이 생겨 그리드에 항목을 배치하는 간단한 방법이 될 수 있습니다. 그러나 그리드에 항목을 배치하는 데 사용할 수있는 대체 방법이 있습니다.이 방법은 단독으로 사용하거나 선 기반 배치와 함께 사용할 수 있습니다. 이 방법에는 명명 된 템플릿 영역을 사용하여 항목을 배치하는 과정이 포함되며이 방법의 작동 방식을 정확히 알게됩니다. 왜 우리가 때때로 이것을 격자 레이아웃의 아스키 아트 방식이라고 부르는지 매우 빨리 알 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="4f7e828fe38de6a16622e681e5e96b9544638c12" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;absolute positioning scheme&lt;/em&gt;, boxes are entirely removed from the flow and don't interact with it at all. They are positioned relative to their &lt;a href=&quot;all_about_the_containing_block&quot;&gt;containing block&lt;/a&gt; using the &lt;a href=&quot;top&quot;&gt;&lt;code&gt;top&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bottom&quot;&gt;&lt;code&gt;bottom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;left&quot;&gt;&lt;code&gt;left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;right&quot;&gt;&lt;code&gt;right&lt;/code&gt;&lt;/a&gt; CSS properties.</source>
          <target state="translated">에서 &lt;em&gt;절대 위치 방식&lt;/em&gt; , 상자는 전체 흐름에서 제거되고 전혀 상호 작용 그것으로하지 않습니다. 그것들은 &lt;a href=&quot;top&quot;&gt; &lt;code&gt;top&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bottom&quot;&gt; &lt;code&gt;bottom&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;left&quot;&gt; &lt;code&gt;left&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;right&quot;&gt; &lt;code&gt;right&lt;/code&gt; &lt;/a&gt; CSS 속성을 사용하여 &lt;a href=&quot;all_about_the_containing_block&quot;&gt;포함 블록에&lt;/a&gt; 상대적으로 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="9f929defd15fe16fa976a6d5265c381b553af0c1" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;float positioning scheme&lt;/em&gt;, specific boxes (called &lt;em&gt;floating boxes&lt;/em&gt; or simply &lt;em&gt;floats)&lt;/em&gt; are positioned at the beginning, or end of the current line. This leads to the property that text (and more generally anything within the normal flow) flows along the edge of the floating boxes, except if told differently by the &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; CSS property.</source>
          <target state="translated">에서 &lt;em&gt;부동의 위치 방식&lt;/em&gt; , 특정 상자 (라는 &lt;em&gt;상자를 떠&lt;/em&gt; 하거나 &lt;em&gt;수레)&lt;/em&gt; 시작 부분에 위치, 또는 현재 줄의 끝에있다. 이것은 &lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; CSS 속성에 의해 다르게 지시되지 않는 한, 텍스트 (및 일반적으로 일반적인 흐름 내의 모든 것)가 부동 상자의 가장자리를 따라 흐르는 속성으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="13d605f829339e72924971b0196722cd52fab2c7" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;normal flow&lt;/em&gt;, boxes are laid out one after the other. In a block formatting context, they are laid out vertically; in an inline formatting context, they are laid out horizontally. The normal flow is triggered when the CSS &lt;a href=&quot;position&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; is set to the value &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;relative&lt;/code&gt;, and if the CSS &lt;a href=&quot;float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is set to the value &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;em&gt;정상 흐름&lt;/em&gt; , 상자 하나씩 배치됩니다. 블록 형식화 컨텍스트에서는 수직으로 배치됩니다. 인라인 형식화 컨텍스트에서는 가로로 배치됩니다. CSS &lt;a href=&quot;position&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;relative&lt;/code&gt; 값 으로 설정되고 CSS &lt;a href=&quot;float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;none&lt;/code&gt; 으로 설정 되면 일반 흐름이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="f47eca4f6e2b138703d034401c4db872c3704594" translate="yes" xml:space="preserve">
          <source>In the CSS, you can see that we are in effect defining a completely separate &lt;a href=&quot;../@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt; that only includes a single character in it, meaning that only this character will be styled with this font. We could also have done this by wrapping the ampersand in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; and applying a different font just to that, but that is an extra element and rule set.</source>
          <target state="translated">CSS에서 단일 문자 만 포함하는 완전히 별개의 &lt;a href=&quot;../@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 를 정의하는 효과가 있음을 알 수 있습니다. 즉 ,이 문자 만이 글꼴로 스타일이 지정됩니다. 앰퍼샌드를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt; 으로 감싸서 다른 글꼴을 적용 하여이 작업을 수행 할 수도 있지만 이는 추가 요소 및 규칙 세트입니다.</target>
        </trans-unit>
        <trans-unit id="3c40b54d1bf7c7ba6921106eb34a4779dee7f885" translate="yes" xml:space="preserve">
          <source>In the Cartesian coordinate system, a two-dimensional point is described using two values: an x coordinate (abscissa) and a y coordinate (ordinate). This is represented by the vector notation &lt;code&gt;(x, y)&lt;/code&gt;.</source>
          <target state="translated">직교 좌표계에서 2 차원 점은 x 좌표 (가로) 및 y 좌표 (좌표)의 두 값을 사용하여 설명됩니다. 이것은 벡터 표기법 &lt;code&gt;(x, y)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b6927a55d0a6eef87b327d1b5e63930cdde5247" translate="yes" xml:space="preserve">
          <source>In the Level 3 Overflow specification we have some properties which can help improve the way content looks in an overflow situation.</source>
          <target state="translated">레벨 3 오버 플로우 스펙에는 오버 플로우 상황에서 컨텐츠가 표시되는 방식을 개선하는 데 도움이되는 몇 가지 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d747087d6fc352923bd1c008d49889e4f51644" translate="yes" xml:space="preserve">
          <source>In the above example I have both used the image as the value of &lt;a href=&quot;../shape-outside&quot;&gt;&lt;code&gt;shape-outside&lt;/code&gt;&lt;/a&gt; and also added it to the page. Many demos do this as it helps to show the shape we are following, however the &lt;code&gt;shape-outside&lt;/code&gt; property is not related to the image that is displayed on the page and so you do not need to display an image to use an image to create a shape.</source>
          <target state="translated">위의 예제에서 이미지를 &lt;a href=&quot;../shape-outside&quot;&gt; &lt;code&gt;shape-outside&lt;/code&gt; &lt;/a&gt; 의 값으로 사용 하고 페이지에 추가했습니다. 많은 데모는 우리가 따르는 모양을 표시하는 데 도움이 되므로이 작업을 수행하지만 &lt;code&gt;shape-outside&lt;/code&gt; 속성은 페이지에 표시되는 이미지와 관련이 없으므로 이미지를 사용하기 위해 이미지를 표시하기 위해 이미지를 표시 할 필요가 없습니다. 모양.</target>
        </trans-unit>
        <trans-unit id="9eee9fe99eb3fc12b3d04b19eff164205da45811" translate="yes" xml:space="preserve">
          <source>In the above example the content is wrapped in paragraph &lt;code&gt;p&lt;/code&gt; tags with default styling. Therefore, there is a margin above each paragraph. You can see how this margin causes the first line of text to be pushed down. This is because a multicol container creates a new Block Formatting Context (BFC) which means margins on child elements do not collapse with any margin on the container.</source>
          <target state="translated">위의 예제에서 내용은 기본 스타일을 사용하여 단락 &lt;code&gt;p&lt;/code&gt; 태그로 래핑됩니다 . 따라서 각 단락 위에 여백이 있습니다. 이 여백으로 인해 첫 번째 텍스트 줄이 아래로 밀리는 방식을 알 수 있습니다. 이는 멀티 콜 컨테이너가 새로운 BFC (Block Formatting Context)를 생성하기 때문에 하위 요소의 여백이 컨테이너의 여백으로 축소되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ab0f488303b77542ba9f89ffeca8c719cf3a75ec" translate="yes" xml:space="preserve">
          <source>In the above example, the width will be at least 80px, but will be wider if the the viewport is more than 800px wide, or an em is more than 20px wide. In other words, the min-width is 80px. Think of the max() value as providing the minimum value a property can have, realizing this, at first, sounds conter-intuitive.</source>
          <target state="translated">위의 예에서 너비는 80px 이상이지만 뷰포트 너비가 800px 이상이거나 em이 20px 이상인 경우 너비가 더 넓습니다. 즉, 최소 너비는 80px입니다. max () 값은 속성이 가질 수있는 최소값을 제공하는 것으로 생각하면, 처음에는이를 결정적으로 들립니다.</target>
        </trans-unit>
        <trans-unit id="8daa85283de2bcfc4946f9b5c6a3798bcb780447" translate="yes" xml:space="preserve">
          <source>In the above example, the width will be at most 80px, at least 10px wide, but 4ems wide if an em is currently between 2.5p and 20px wide.</source>
          <target state="translated">위의 예에서 너비가 최대 80px, 너비가 최소 10px이지만 너비가 현재 2.5p에서 20px 사이 인 경우 너비는 4em입니다.</target>
        </trans-unit>
        <trans-unit id="708d8b2a13f9876dea42c20b436f1e574e6890dc" translate="yes" xml:space="preserve">
          <source>In the above example, the width will be at most 80px, but will be narrower if the the viewport is less than 800px wide, or an em is less than 20px wide. In other words, the max-width is 80px. Think of the min() value as providing the maximum value a property can have.</source>
          <target state="translated">위 예제에서 너비는 최대 80px이지만 뷰포트의 너비가 800px 미만이거나 em의 너비가 20px 미만인 경우 더 좁아집니다. 즉, 최대 너비는 80px입니다. min () 값은 속성이 가질 수있는 최대 값을 제공하는 것으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="ba8660c7a86570dacef1d7ca60d1b58659be5641" translate="yes" xml:space="preserve">
          <source>In the above examples I specified every end row and column line, in order to demonstrate the properties, however in practice if an item only spans one track you can omit the &lt;code&gt;grid-column-end&lt;/code&gt; or &lt;code&gt;grid-row-end&lt;/code&gt; value. Grid defaults to spanning one track. This means that our initial, long-hand, example would look like this:</source>
          <target state="translated">위의 예에서 속성을 보여주기 위해 모든 끝 행과 열 줄을 지정했지만 실제로 항목이 하나의 트랙에만 걸쳐있는 경우 &lt;code&gt;grid-column-end&lt;/code&gt; 또는 &lt;code&gt;grid-row-end&lt;/code&gt; 값을 생략 할 수 있습니다 . 그리드는 기본적으로 하나의 트랙에 걸쳐 있습니다. 즉, 우리의 초기 긴 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="300031c2ac05e904b0ba610f420c1635d71cff7b" translate="yes" xml:space="preserve">
          <source>In the article &lt;a href=&quot;aligning_items_in_a_flex_container&quot;&gt;Aligning Items in a Flex Container&lt;/a&gt; we will explore these properties in more depth, in order to have a better understanding of how they work. These simple examples however will be useful in the majority of use cases.</source>
          <target state="translated">&lt;a href=&quot;aligning_items_in_a_flex_container&quot;&gt;Flex 컨테이너에 항목 정렬&lt;/a&gt; 기사에서는 이러한 속성이 어떻게 작동하는지 더 잘 이해하기 위해 이러한 속성에 대해 자세히 살펴볼 것입니다. 그러나이 간단한 예는 대부분의 사용 사례에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f0af30ecdfe3cc8c62efe61539b01aeeac14e26" translate="yes" xml:space="preserve">
          <source>In the below example I have a grid container of 500 pixels by 500 pixels. I have defined 3 row and column tracks each of 100 pixels with a 10 pixel gutter. This means that there is space inside the grid container both in the block and inline directions.</source>
          <target state="translated">아래 예제에서는 500 x 500 픽셀의 그리드 컨테이너가 있습니다. 10 픽셀 거터로 100 픽셀 각각에 3 개의 행 및 열 트랙을 정의했습니다. 이것은 그리드 컨테이너 내부에 블록과 인라인 방향으로 공간이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1f7044c7ef3778a51b7dc01c78765c3857118ed1" translate="yes" xml:space="preserve">
          <source>In the below example I have a wrapper containing four child items. Item three is absolutely positioned and also placed on the grid using line-based placement. The grid container has &lt;code&gt;position: relative&lt;/code&gt; and so becomes the positioning context of this item.</source>
          <target state="translated">아래 예제에는 4 개의 하위 항목이 포함 된 래퍼가 있습니다. 항목 3은 절대적으로 배치되며 선 기반 배치를 사용하여 그리드에 배치됩니다. 그리드 컨테이너에는 &lt;code&gt;position: relative&lt;/code&gt; 가 있으며이 항목의 위치 지정 컨텍스트가됩니다.</target>
        </trans-unit>
        <trans-unit id="03e03f2702d23ccdb42815e9313f02761bd7d8fa" translate="yes" xml:space="preserve">
          <source>In the below example I have created a circle on an item with a width of 100 pixels, plus a margin of 20 pixels. This gives a total width for the reference box of 140 pixels. I have given a value of 50% for the shape-radius value which means that our radius is 70px. I have then set the position value to 30%.</source>
          <target state="translated">아래 예제에서는 너비가 100 픽셀이고 여백이 20 픽셀 인 항목에 원을 만들었습니다. 140 픽셀의 참조 상자에 대한 총 너비를 제공합니다. shape-radius 값에 50 %의 값을주었습니다. 이는 반경이 70px임을 의미합니다. 그런 다음 위치 값을 30 %로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="54ca724dd91411e70b1027a699d2e8b9cf09caee" translate="yes" xml:space="preserve">
          <source>In the below example I have used the &lt;code&gt;inset-block-start&lt;/code&gt; and &lt;code&gt;inset-inline-end&lt;/code&gt; properties to position the blue box using absolute positioning inside the area with the grey dotted border, which has &lt;code&gt;position: relative&lt;/code&gt;. Change the &lt;code&gt;writing-mode&lt;/code&gt; property to &lt;code&gt;vertical-rl&lt;/code&gt;, or add &lt;code&gt;direction: rtl&lt;/code&gt;, and see how the flow relative box stays with the text direction.</source>
          <target state="translated">아래의 예에서, I는 사용한 &lt;code&gt;inset-block-start&lt;/code&gt; 및 &lt;code&gt;inset-inline-end&lt;/code&gt; 갖는 회색 점선 테두리 영역 내부에 절대 위치를 사용하여 청색 박스의 위치를 등록 &lt;code&gt;position: relative&lt;/code&gt; . 변경 &lt;code&gt;writing-mode&lt;/code&gt; 로 속성을 &lt;code&gt;vertical-rl&lt;/code&gt; , 또는 추가 &lt;code&gt;direction: rtl&lt;/code&gt; 하고, 텍스트 방향과 상대 박스 숙박 흐름 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44ebcf646bd61d807f23cb421d19ccbe9495832d" translate="yes" xml:space="preserve">
          <source>In the below example we use &lt;code&gt;grid-auto-rows&lt;/code&gt; to ensure that tracks created in the implicit grid are 200 pixels tall.</source>
          <target state="translated">아래 예제에서는 &lt;code&gt;grid-auto-rows&lt;/code&gt; 를 사용하여 암시 적 그리드에서 생성 된 트랙의 높이가 200 픽셀인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cbd2059798ba7cd0f388334eab07e47933e0f631" translate="yes" xml:space="preserve">
          <source>In the below example we use the &lt;code&gt;column-count&lt;/code&gt; property to create three columns on the &lt;code&gt;.container&lt;/code&gt; element. The content, including the children of &lt;code&gt;.container&lt;/code&gt; is then split between the three columns.</source>
          <target state="translated">아래 예제에서는 &lt;code&gt;column-count&lt;/code&gt; 속성을 사용하여 &lt;code&gt;.container&lt;/code&gt; 요소 에 3 개의 열을 만듭니다 . 그런 다음 &lt;code&gt;.container&lt;/code&gt; 의 자식을 포함하여 내용 이 세 열로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5f7c3a1417adea9e046222ec98da196fe6392d" translate="yes" xml:space="preserve">
          <source>In the below example we use the &lt;code&gt;column-width&lt;/code&gt; property with a value of 200px. We get as many 200 pixel columns as will fit the container, with the extra space shared equally.</source>
          <target state="translated">아래 예제에서는 200px 의 &lt;code&gt;column-width&lt;/code&gt; 속성을 사용합니다 . 우리는 컨테이너에 맞는 200 픽셀 열을 확보하고 여분의 공간을 똑같이 공유합니다.</target>
        </trans-unit>
        <trans-unit id="da9cab1c335e8fdb1506e88e36409178b9e549db" translate="yes" xml:space="preserve">
          <source>In the below example, a grid layout uses the &lt;code&gt;gap&lt;/code&gt; shorthand to set a &lt;code&gt;10px&lt;/code&gt; gap between row tracks, and a &lt;code&gt;2em&lt;/code&gt; gap between column tracks.</source>
          <target state="translated">아래 예제에서 그리드 레이아웃은 &lt;code&gt;gap&lt;/code&gt; 단축을 사용하여 행 트랙 사이에 &lt;code&gt;10px&lt;/code&gt; 간격 을 설정하고 열 트랙 사이에 &lt;code&gt;2em&lt;/code&gt; 간격을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f0be7ea63031833852c901096aac12d62812bbe0" translate="yes" xml:space="preserve">
          <source>In the below example, we are creating an inline flex container with the legacy keyword inline-flex.</source>
          <target state="translated">아래 예에서는 기존 키워드 inline-flex를 사용하여 인라인 플렉스 컨테이너를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2fa3f8b4895ca4a4eb5c56f45a89d141f0d01dea" translate="yes" xml:space="preserve">
          <source>In the below image I have placed the grid with &lt;code&gt;align-content&lt;/code&gt;, with a value of &lt;code&gt;start&lt;/code&gt; alongside the grid when &lt;code&gt;align-content&lt;/code&gt; has a value of &lt;code&gt;space-between&lt;/code&gt;. You can see how items 1 and 2, which span two row tracks have taken on extra height as they gain the additional space added to the gap between those two tracks:</source>
          <target state="translated">아래 이미지에서 &lt;code&gt;align-content&lt;/code&gt; 가 &lt;code&gt;space-between&lt;/code&gt; 의 값을 가질 때 그리드와 함께 &lt;code&gt;start&lt;/code&gt; 값을 가진 &lt;code&gt;align-content&lt;/code&gt; 가 있는 그리드를 배치했습니다 . 두 행 트랙에 걸쳐있는 항목 1과 2가 어떻게 두 트랙 사이의 간격에 추가 공간을 확보하여 추가 높이를 차지했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06ad82f67263f4901d26cc9f326206253392e3e" translate="yes" xml:space="preserve">
          <source>In the below live example we display the items at their natural size and by using &lt;code&gt;justify-content: space-between&lt;/code&gt; make equal amounts of space between the items. You can change how the space is distributed using the &lt;code&gt;space-around&lt;/code&gt; value, or where supported, &lt;code&gt;space-evenly&lt;/code&gt;. You could also use &lt;code&gt;flex-start&lt;/code&gt; to place the space at the end of the items, &lt;code&gt;flex-end&lt;/code&gt; to place it before them, or &lt;code&gt;center&lt;/code&gt; to centre the navigation items.</source>
          <target state="translated">아래 라이브 예에서 우리는 항목을 원래 크기로 표시하고 &lt;code&gt;justify-content: space-between&lt;/code&gt; 를 사용 하여 항목 간 간격 을 동일하게 만듭니다. &lt;code&gt;space-around&lt;/code&gt; 값을 사용하거나 &lt;code&gt;space-evenly&lt;/code&gt; 지원되는 경우 공간이 분산되는 방식을 변경할 수 있습니다 . &lt;code&gt;flex-start&lt;/code&gt; 를 사용 하여 항목 끝에 공간을 배치하거나 &lt;code&gt;flex-end&lt;/code&gt; 를 사용 하여 항목 앞에 배치하거나 &lt;code&gt;center&lt;/code&gt; 를 탐색 항목 중앙 에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d672770297b3c90c770f6b0612c45bfb9607cc2c" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;-ms-ime-align: after&lt;/code&gt;, an IME might adjust the candidate window and keyboard input behavior to provide a better user experience, such as using a horizontal candidate list and allowing some keys to be sent to the app for suggestion list navigation.</source>
          <target state="translated">의 경우 &lt;code&gt;-ms-ime-align: after&lt;/code&gt; , IME의는 수평 후보 목록을 사용하여 일부 키는 제안을위한 응용 프로그램으로 전송 될 수 있도록로, 더 나은 사용자 경험을 제공하기 위해 후보 창 및 키보드 입력 동작을 조정할 수 있습니다 탐색 목록.</target>
        </trans-unit>
        <trans-unit id="e9788e82a8144e96ac175026c66f94fc43948a3b" translate="yes" xml:space="preserve">
          <source>In the coordinate systems used by web technologies, convention dictates that the horizontal offset is called the &lt;em&gt;x-coordinate&lt;/em&gt;, where a negative value indicates a position to the left of the origin and a positive value is to the right of the origin. The &lt;em&gt;y-coordinate&lt;/em&gt; specifies the vertical offset, with a negative value being above the origin and a positive value being below the origin.</source>
          <target state="translated">웹 기술에서 사용하는 좌표계에서 규칙은 가로 오프셋을 &lt;em&gt;x 좌표&lt;/em&gt; 라고하며 , 음수 값은 원점 왼쪽 위치를 나타내고 양수 값은 원점 오른쪽입니다. &lt;em&gt;Y 좌표&lt;/em&gt; 음의 값이 원점 및 원점 아래 인 포지티브 값으로 지정되는 이상을 오프셋 수직.</target>
        </trans-unit>
        <trans-unit id="64439c0ecd4c6520a6a910c34f4a727915cad4b9" translate="yes" xml:space="preserve">
          <source>In the current level 1 specification there are only two allowable values for &lt;code&gt;column-span&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; is the initial value and means the item does not span, remaining within a column. The value &lt;code&gt;all&lt;/code&gt; means the item spans all of the columns. You cannot cause an item to span two out of three columns for example.</source>
          <target state="translated">현재 레벨 1 스펙에는 &lt;code&gt;column-span&lt;/code&gt; 에 허용되는 값이 두 개뿐입니다 . &lt;code&gt;none&lt;/code&gt; 값 은 초기 값이며 항목이 확장되지 않고 열 내에 남아 있음을 의미합니다. &lt;code&gt;all&lt;/code&gt; 값 은 항목이 모든 열에 걸쳐 있음을 의미합니다. 예를 들어 항목이 3 개 열 중 2 개에 걸쳐있을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc7d7873ee31e6e3c48d2dbbfecf398c5ca76c6c" translate="yes" xml:space="preserve">
          <source>In the current specification, we would edit the above nested grid example to change the track definition of &lt;code&gt;grid-template-columns: repeat(3, 1fr)&lt;/code&gt;, to &lt;code&gt;grid-template-columns: subgrid&lt;/code&gt;. The nested grid will then use the parent grid tracks to layout items.</source>
          <target state="translated">현재 사양에서 위의 중첩 된 그리드 예제를 편집하여 &lt;code&gt;grid-template-columns: repeat(3, 1fr)&lt;/code&gt; 의 트랙 정의 를 &lt;code&gt;grid-template-columns: subgrid&lt;/code&gt; 합니다. 그런 다음 중첩 된 그리드는 부모 그리드 트랙을 사용하여 항목을 레이아웃합니다.</target>
        </trans-unit>
        <trans-unit id="e398e18850820d83310e37ba64490fc07571a6b0" translate="yes" xml:space="preserve">
          <source>In the end, we can see that none of the browsers mentioned in this article is right or wrong about how they lay out lists. They use different default styles, and that's where the problems creep in. By making sure you style both the left padding and left margin of lists, you can find much greater cross-browser consistency in your list indentation.</source>
          <target state="translated">결국, 우리는이 기사에서 언급 한 브라우저 중 어느 것도 목록을 배치하는 방법에 대해 옳고 그른 것이 없다는 것을 알 수 있습니다. 서로 다른 기본 스타일을 사용하므로 문제가 발생합니다. 목록의 왼쪽 여백과 왼쪽 여백을 모두 스타일 지정하면 목록 들여 쓰기에서 브라우저 간 일관성이 훨씬 높아집니다.</target>
        </trans-unit>
        <trans-unit id="46f54639e3f551d90f8aebe2b1c7354da65a7106" translate="yes" xml:space="preserve">
          <source>In the example above, the text &lt;a href=&quot;color&quot;&gt;&lt;code&gt;color&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;#411&lt;/code&gt;, is so dark that it's difficult to read given the &lt;code&gt;black&lt;/code&gt;&lt;a href=&quot;background-color&quot;&gt;&lt;code&gt;background-color&lt;/code&gt;&lt;/a&gt;. Depending on the browser, its configuration, and the device on which the example is being viewed, the browser may opt to remove the black background or change the text color in order to improve contrast and make the text more legible.</source>
          <target state="translated">텍스트, 위의 예에서 &lt;a href=&quot;color&quot;&gt; &lt;code&gt;color&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;#411&lt;/code&gt; , 그것은 주어진 읽기 어려운 있다는 어두운 있도록입니다 &lt;code&gt;black&lt;/code&gt; &lt;a href=&quot;background-color&quot;&gt; &lt;code&gt;background-color&lt;/code&gt; &lt;/a&gt; . 브라우저, 구성 및 예제를보고있는 장치에 따라 브라우저는 대비를 개선하고 텍스트를보다 읽기 쉽게하기 위해 검은 색 배경을 제거하거나 텍스트 색상을 변경하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ccbff938633706387f6ddd6912e37e3e0a608b" translate="yes" xml:space="preserve">
          <source>In the example already shown, you can see how writing mode changes the direction in which items place themselves onto the grid. Items will, by default, place themselves along the Inline axis then move onto a new row. However, that inline axis may not always run from left to right.</source>
          <target state="translated">이미 표시된 예에서 쓰기 모드가 항목이 그리드에 배치되는 방향을 어떻게 변경하는지 확인할 수 있습니다. 기본적으로 항목은 인라인 축을 따라 배치 된 다음 새 행으로 이동합니다. 그러나 인라인 축이 항상 왼쪽에서 오른쪽으로 실행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b1103502619976f299aa04868c6610ab1b397b87" translate="yes" xml:space="preserve">
          <source>In the example below I am using a similar image to the initial example, however in this image the background of the star is not fully transparent, it has a 20% opacity as created in my graphics programme. If I set &lt;code&gt;shape-image-threshold&lt;/code&gt; to &lt;code&gt;0.3&lt;/code&gt; then I see the shape, if I set it to something smaller than &lt;code&gt;0.2&lt;/code&gt; I do not get the shape.</source>
          <target state="translated">아래 예에서 초기 예와 비슷한 이미지를 사용하고 있지만이 이미지에서 별의 배경이 완전히 투명하지는 않습니다. 그래픽 프로그램에서 생성 된 불투명도가 20 %입니다. 내가 설정 한 경우 &lt;code&gt;shape-image-threshold&lt;/code&gt; 에 &lt;code&gt;0.3&lt;/code&gt; 그때보다 작은 무언가로 설정하면 나는 모양을 참조 &lt;code&gt;0.2&lt;/code&gt; 나는 모양을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="593e017b6b7c0eacc18ab5ceee5444a72111725d" translate="yes" xml:space="preserve">
          <source>In the example below I have created a shape for text to follow using the &lt;code&gt;polygon()&lt;/code&gt;, you can change any of the values to see how the shape is changed.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;polygon()&lt;/code&gt; 사용하여 텍스트에 따라 모양을 만들었 습니다. 모양이 어떻게 변경되는지 확인하기 위해 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34312e5f2e98fb8ae9a0e88cb776234d908dd79c" translate="yes" xml:space="preserve">
          <source>In the example below I have created two boxes and added different sized margins to each edge. I have added an extra container with a border in order to make the margin more obvious to see.</source>
          <target state="translated">아래 예에서는 두 개의 상자를 만들고 각 가장자리에 서로 다른 크기의 여백을 추가했습니다. 여백을 더 분명하게 보이기 위해 테두리가있는 컨테이너를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="95654e184176d21fbdcf53511aad98ee4d47356e" translate="yes" xml:space="preserve">
          <source>In the example below I have two boxes &amp;mdash; the first has the box floated with &lt;code&gt;float: left&lt;/code&gt;, the second with &lt;code&gt;float: inline-start&lt;/code&gt;. If you change the &lt;code&gt;writing-mode&lt;/code&gt; to &lt;code&gt;vertical-rl&lt;/code&gt; or the &lt;code&gt;direction&lt;/code&gt; to &lt;code&gt;rtl&lt;/code&gt; you will see that the left-floated box always sticks to the left, whereas the &lt;code&gt;inline-start&lt;/code&gt;-floated item follows the &lt;code&gt;direction&lt;/code&gt; and &lt;code&gt;writing-mode&lt;/code&gt;.</source>
          <target state="translated">아래 예제에는 두 개의 상자가 있습니다. 첫 번째 상자에는 &lt;code&gt;float: left&lt;/code&gt; , 두 번째 상자 에는 &lt;code&gt;float: inline-start&lt;/code&gt; 있습니다. 당신이 변경하는 경우 &lt;code&gt;writing-mode&lt;/code&gt; 에 &lt;code&gt;vertical-rl&lt;/code&gt; 또는 &lt;code&gt;direction&lt;/code&gt; 하는 &lt;code&gt;rtl&lt;/code&gt; 당신이 볼 수, 왼쪽에 왼쪽 부유 박스는 항상 스틱 그 반면 &lt;code&gt;inline-start&lt;/code&gt; -floated 항목은 다음과 &lt;code&gt;direction&lt;/code&gt; 및 &lt;code&gt;writing-mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75219be434d76ec0ca4936f20b880c25dc99dcd1" translate="yes" xml:space="preserve">
          <source>In the example below I have two boxes, one of which is using physical padding properties and the other logical padding properties. With a &lt;code&gt;writing-mode&lt;/code&gt; of &lt;code&gt;horizontal-tb&lt;/code&gt;, both boxes should appear the same.</source>
          <target state="translated">아래 예제에는 두 개의 상자가 있는데 그 중 하나는 물리적 패딩 속성과 다른 논리적 패딩 속성을 사용합니다. A를 &lt;code&gt;writing-mode&lt;/code&gt; 의 &lt;code&gt;horizontal-tb&lt;/code&gt; , 두 상자는 동일하게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ade9fac5d6ccfe3034657e770d8dc1cae4cf94ee" translate="yes" xml:space="preserve">
          <source>In the example below we have added a &lt;code&gt;shape-margin&lt;/code&gt; to a basic shape. Change the margin to push the text further away from the path the shape would take by default.</source>
          <target state="translated">아래 예제 에서 기본 &lt;code&gt;shape-margin&lt;/code&gt; 에 도형 여백 을 추가했습니다 . 여백을 변경하여 도형이 기본적으로 사용하는 경로에서 텍스트를 더 멀리 밀어냅니다.</target>
        </trans-unit>
        <trans-unit id="33026d8bab067e8d2a5636083180b4467ba52589" translate="yes" xml:space="preserve">
          <source>In the example below we have an &lt;code&gt;inset()&lt;/code&gt; shape used to pull content over the floated element. Change the offset values to see how the shape changes.</source>
          <target state="translated">아래 예에서는 플로팅 된 요소 위로 내용을 가져 오는 데 사용되는 &lt;code&gt;inset()&lt;/code&gt; 모양이 있습니다. 모양이 어떻게 변하는 지 보려면 오프셋 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c652e79ee709d3906a520f2a7bda48f0d9c6a75d" translate="yes" xml:space="preserve">
          <source>In the example below we have used a &lt;code&gt;min-height&lt;/code&gt; query to check the height before applying the column properties.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;min-height&lt;/code&gt; 쿼리를 사용 하여 열 속성을 적용하기 전에 높이를 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="a0c532f29b779d48711b45394f66f479a527ed48" translate="yes" xml:space="preserve">
          <source>In the example below you can change the value &lt;code&gt;border-box&lt;/code&gt; to any of the other allowed values to see how the shape moves closer or further away from the box.</source>
          <target state="translated">아래 예제에서 값 &lt;code&gt;border-box&lt;/code&gt; 를 다른 허용 된 값 중 하나로 변경 하여 도형이 상자에서 멀어 지거나 멀어지는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dc42da6b95fa8bff1abfb4e31da1ae484b04273" translate="yes" xml:space="preserve">
          <source>In the example below you can see how the text now follows the line created by the border. Change the border size and the content follows it.</source>
          <target state="translated">아래 예에서 텍스트가 테두리로 작성된 선을 따르는 방식을 볼 수 있습니다. 테두리 크기를 변경하면 내용이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b9369a1201d51d08289155303f00232cb5e10df6" translate="yes" xml:space="preserve">
          <source>In the example below, the h2 element is set to &lt;code&gt;column-span: all&lt;/code&gt; and spans all of the columns.</source>
          <target state="translated">아래 예에서 h2 요소는 &lt;code&gt;column-span: all&lt;/code&gt; 설정되고 모든 열에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7496e48926463801ef244134127e6702eb72ac" translate="yes" xml:space="preserve">
          <source>In the example below, the paragraphs have a top margin of &lt;code&gt;20px&lt;/code&gt; and a bottom margin of &lt;code&gt;40px&lt;/code&gt;. The size of the margin between the paragraphs is &lt;code&gt;40px&lt;/code&gt; as the smaller top margin on the second paragraph has collapsed with the larger bottom margin of the first.</source>
          <target state="translated">아래 예에서 단락의 상단 여백은 &lt;code&gt;20px&lt;/code&gt; 이고 하단 여백은 &lt;code&gt;40px&lt;/code&gt; 입니다. 두 번째 단락의 작은 위쪽 여백이 첫 번째의 아래쪽 여백이 커질수록 단락 사이의 여백 크기는 40 &lt;code&gt;40px&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4e1f578a2c273d75cfd46ae4d4d7c8137627bec" translate="yes" xml:space="preserve">
          <source>In the example below, the value of &lt;code&gt;justify-content&lt;/code&gt; is &lt;code&gt;space-between&lt;/code&gt;. The available space after displaying the items is distributed between the items. The left and right item line up flush with the start and end.</source>
          <target state="translated">아래 예에서 &lt;code&gt;justify-content&lt;/code&gt; 의 값 은 &lt;code&gt;space-between&lt;/code&gt; 입니다. 항목을 표시 한 후 사용 가능한 공간이 항목간에 분배됩니다. 왼쪽 및 오른쪽 항목이 시작 및 끝과 나란히 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="435c5dff50cefc4cef6c1d6bb199e83edf19dc62" translate="yes" xml:space="preserve">
          <source>In the example below, we are using the &lt;code&gt;orphans&lt;/code&gt; property to control the number of lines left at the bottom of a column. You can change that value to see the effect on the breaking of the content.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;orphans&lt;/code&gt; 속성을 사용하여 열의 맨 아래에 남은 줄 수를 제어합니다. 해당 값을 변경하여 컨텐츠 분리에 미치는 영향을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="389fa1e25801f00230a450147bc99ac26c878f12" translate="yes" xml:space="preserve">
          <source>In the example below, we have a circular purple item which is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; with a height, width, and background colour. The &lt;code&gt;border-radius&lt;/code&gt; property has been used to create a circle by setting &lt;code&gt;border-radius: 50%&lt;/code&gt;. As the element has a margin, you can see that the content is flowing around the circular shape and the margin applied to it.</source>
          <target state="translated">아래 예 에는 높이, 너비 및 배경색 이있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 인&lt;/a&gt; 원형 자주색 항목이 있습니다. &lt;code&gt;border-radius&lt;/code&gt; 속성을 설정함으로써 원 작성에 사용 된 &lt;code&gt;border-radius: 50%&lt;/code&gt; . 요소에 여백이 있으므로 내용이 원형 모양을 따라 흐르고 여백이 적용된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f130bac936ac35235b254ca436983752f1b353" translate="yes" xml:space="preserve">
          <source>In the example below, we have a floated element inside a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; with a border applied. The content of that &lt;code&gt;div&lt;/code&gt; has floated alongside the floated element. As the content of the float is taller than the content alongside it, the border of the div now runs through the float. As explained in the &lt;a href=&quot;in_flow_and_out_of_flow&quot;&gt;guide to in-flow and out of flow elements&lt;/a&gt;, the float has been taken out of flo so the background and border of the div only contain the content and not the float.</source>
          <target state="translated">아래 예에서는 테두리가 적용된 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 안에 부동 요소가 있습니다 . 해당 &lt;code&gt;div&lt;/code&gt; 의 내용이 부동 요소와 함께 부동되었습니다. float의 내용이 옆에있는 내용보다 더 크면 div의 테두리가 float을 통과합니다. &lt;a href=&quot;in_flow_and_out_of_flow&quot;&gt;유입 및 유출 요소 가이드에&lt;/a&gt; 설명 된 것처럼 플로트는 플로에서 제거되어 div의 배경과 테두리에는 플로트가 아닌 내용 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c107768ba9702cccab007a82eaafb3f40dbffd21" translate="yes" xml:space="preserve">
          <source>In the example below, we have applied break-inside to the figure element to prevent the caption from becoming separated from the image.</source>
          <target state="translated">아래 예에서는 캡션이 이미지에서 분리되는 것을 방지하기 위해 그림 요소에 break-inside를 적용했습니다.</target>
        </trans-unit>
        <trans-unit id="bdb98a6cc0426954c7368bd442296f7bd84ff6a8" translate="yes" xml:space="preserve">
          <source>In the examples above we have used images or a visible element to define the shape, meaning that you can see the shape on the page. Instead, you might simply want to cause some text to flow along a non-rectangular invisible line. You can do this with Shapes, however you will still need a floated item, which you can then make invisible. That could be a redundant element inserted into the document, an empty &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; perhaps, but our preference is to use generated content. This means we can keep things used for styling inside the CSS.</source>
          <target state="translated">위의 예제에서 이미지 또는 보이는 요소를 사용하여 모양을 정의했습니다. 즉, 페이지에서 모양을 볼 수 있습니다. 대신, 텍스트가 직사각형이 아닌 보이지 않는 선을 따라 흐르도록 할 수도 있습니다. 셰이프를 사용하여이 작업을 수행 할 수 있지만 여전히 플로팅 된 항목이 필요하므로이를 보이지 않게 할 수 있습니다. 문서에 비어있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소가 중복 된 요소 일 수 있지만 생성 된 컨텐츠를 사용하는 것이 좋습니다. 즉, CSS 내부에서 스타일링에 사용되는 것을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3445c5f72a7cf65ef57c9a6b03705d026a2e54" translate="yes" xml:space="preserve">
          <source>In the final guide in this series we will see &lt;a href=&quot;handling_content_breaks_in_multicol&quot;&gt;how Multicol works with the Fragmentation spec &lt;/a&gt;to give us control over how content breaks between columns.</source>
          <target state="translated">이 시리즈의 마지막 안내서에서 &lt;a href=&quot;handling_content_breaks_in_multicol&quot;&gt;Multicol이 Fragmentation 스펙과 함께 작동하여&lt;/a&gt; 열 사이에서 컨텐츠가 어떻게 분리되는지 제어 할 수있는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="f3432b14b360205e5f7a1e98c561dd64dab2c97c" translate="yes" xml:space="preserve">
          <source>In the first example, which uses flexbox, I have a container with three items inside. The wrapper &lt;a href=&quot;../min-height&quot;&gt;&lt;code&gt;min-height&lt;/code&gt;&lt;/a&gt; is set, so it defines the height of the flex container. I have set &lt;a href=&quot;../align-items&quot;&gt;&lt;code&gt;align-items&lt;/code&gt;&lt;/a&gt; on the flex container to &lt;code&gt;flex-end&lt;/code&gt; so the items will line up at the end of the flex container. I have also set the &lt;a href=&quot;../align-self&quot;&gt;&lt;code&gt;align-self&lt;/code&gt;&lt;/a&gt; property on &lt;code&gt;box1&lt;/code&gt; so it will override the default and stretch to the height of the container and on &lt;code&gt;box2&lt;/code&gt; so it aligns to the start of the flex container.</source>
          <target state="translated">flexbox를 사용하는 첫 번째 예에서는 3 개의 항목이있는 컨테이너가 있습니다. 랩퍼 &lt;a href=&quot;../min-height&quot;&gt; &lt;code&gt;min-height&lt;/code&gt; &lt;/a&gt; 가 설정되므로 플렉스 컨테이너의 높이를 정의합니다. 내가 설정 한 &lt;a href=&quot;../align-items&quot;&gt; &lt;code&gt;align-items&lt;/code&gt; &lt;/a&gt; 에 플렉스 컨테이너 &lt;code&gt;flex-end&lt;/code&gt; 항목이 플렉스 용기의 끝 부분에 줄을 있도록. 또한 &lt;code&gt;box1&lt;/code&gt; 에 &lt;a href=&quot;../align-self&quot;&gt; &lt;code&gt;align-self&lt;/code&gt; &lt;/a&gt; 속성을 설정하여 기본값을 재정의하고 컨테이너 높이로 확장하고 &lt;code&gt;box2&lt;/code&gt; 에서 flex 컨테이너의 시작 부분에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="c72b83154889f6d107a6bb5ca2398c3ca75257e1" translate="yes" xml:space="preserve">
          <source>In the following example I am placing the first two items on our three column track grid, using the &lt;a href=&quot;../grid-column-start&quot;&gt;&lt;code&gt;grid-column-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../grid-column-end&quot;&gt;&lt;code&gt;grid-column-end&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../grid-row-start&quot;&gt;&lt;code&gt;grid-row-start&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../grid-row-end&quot;&gt;&lt;code&gt;grid-row-end&lt;/code&gt;&lt;/a&gt; properties. Working from left to right, the first item is placed against column line 1, and spans to column line 4, which in our case is the far-right line on the grid. It begins at row line 1 and ends at row line 3, therefore spanning two row tracks.</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;../grid-column-start&quot;&gt; &lt;code&gt;grid-column-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../grid-column-end&quot;&gt; &lt;code&gt;grid-column-end&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../grid-row-start&quot;&gt; &lt;code&gt;grid-row-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../grid-row-end&quot;&gt; &lt;code&gt;grid-row-end&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 세 개의 열 트랙 그리드에 처음 두 항목을 배치합니다 . 왼쪽에서 오른쪽으로 작업 할 때 첫 번째 항목은 열 1 행에 배치되고 열 4 행에 이르며이 경우에는 그리드에서 가장 오른쪽에 있습니다. 행 1 행에서 시작하여 행 3 행에서 끝나므로 두 행 트랙에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9c1c7215875666c55031180f0e7cccfa45b3e2" translate="yes" xml:space="preserve">
          <source>In the following example I have a heading, paragraph, a list and a final paragraph which contains a &lt;code&gt;strong&lt;/code&gt; element. The heading and paragraphs are block level, the &lt;code&gt;strong&lt;/code&gt; element inline. The list is displayed using flexbox to arrange the items into a row, however it too is participating in block and inline layout - the container has an outside &lt;code&gt;display&lt;/code&gt; type of &lt;code&gt;block&lt;/code&gt;.</source>
          <target state="translated">다음 예에서는 제목, 단락, 목록 및 &lt;code&gt;strong&lt;/code&gt; 요소 를 포함하는 마지막 단락이 있습니다 . 제목과 단락은 블록 수준이며 &lt;code&gt;strong&lt;/code&gt; 요소 인라인입니다. 목록은 flexbox를 사용하여 항목을 행으로 정렬하지만 블록 및 인라인 레이아웃에 참여합니다. 컨테이너에는 외부 &lt;code&gt;display&lt;/code&gt; 유형의 &lt;code&gt;block&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9166e9691dae65338c7eb1b6a7ad2a1a0012db" translate="yes" xml:space="preserve">
          <source>In the following example I have an image floated left. I have then applied the &lt;code&gt;shape-outside&lt;/code&gt; property to it with a value of &lt;code&gt;circle(50%)&lt;/code&gt;. The result is that the content now curves around the circular shape rather than following the rectangle created by the box of the image.</source>
          <target state="translated">다음 예에서는 이미지가 왼쪽으로 떠 있습니다. 그런 다음 &lt;code&gt;circle(50%)&lt;/code&gt; 값으로 &lt;code&gt;shape-outside&lt;/code&gt; 속성을 적용했습니다 . 결과적으로 내용이 이미지 상자로 생성 된 사각형을 따르지 않고 원형 모양을 따라 구부러집니다.</target>
        </trans-unit>
        <trans-unit id="98df973196e4e092d94f62000b05f45ff7fda7f3" translate="yes" xml:space="preserve">
          <source>In the following example a container has been set to &lt;code&gt;display: flex&lt;/code&gt;, which means that the three child items become flex items. The value of &lt;code&gt;justify-content&lt;/code&gt; has been set to &lt;code&gt;space-between&lt;/code&gt; in order to space the items out evenly on the main axis. An equal amount of space is placed between each item with the left and right items being flush with the edges of the flex container. You can also see that the items are stretching on the cross axis, due to the default value of &lt;code&gt;align-items&lt;/code&gt; being &lt;code&gt;stretch&lt;/code&gt;. The items stretch to the height of the flex container, making them each appear as tall as the tallest item.</source>
          <target state="translated">다음 예제에서 컨테이너는 &lt;code&gt;display: flex&lt;/code&gt; 로 표시 되도록 설정되었습니다 . 즉, 세 개의 하위 항목이 플렉스 항목이됩니다. 항목을 주축에 균등하게 배치하기 위해 &lt;code&gt;justify-content&lt;/code&gt; 의 값이 &lt;code&gt;space-between&lt;/code&gt; 에 설정되었습니다 . 왼쪽 및 오른쪽 항목이 플렉스 컨테이너의 가장자리와 같은 높이가되도록 각 항목 사이에 동일한 공간이 배치됩니다. &lt;code&gt;align-items&lt;/code&gt; 의 기본값 이 &lt;code&gt;stretch&lt;/code&gt; 이므로 항목 이 교차 축에서 늘어나고 있음을 알 수 있습니다. 아이템은 플렉스 컨테이너의 높이까지 뻗어 각각의 키가 가장 큰 아이템으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="39f55d3e3d87c5387e101555b1001e0891585e6c" translate="yes" xml:space="preserve">
          <source>In the following example the &lt;a href=&quot;column-count&quot;&gt;&lt;code&gt;column-count&lt;/code&gt;&lt;/a&gt; property has been applied to the element with a class of container. As the value of &lt;code&gt;column-count&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, the content is arranged into 3 columns of equal size.</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;column-count&quot;&gt; &lt;code&gt;column-count&lt;/code&gt; &lt;/a&gt; 속성이 컨테이너 클래스가있는 요소에 적용되었습니다. &lt;code&gt;column-count&lt;/code&gt; 의 값 이 &lt;code&gt;3&lt;/code&gt; 이므로 내용은 동일한 크기의 3 개의 열로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2e8f28a0d905f5f451c02e03d191652af09d47" translate="yes" xml:space="preserve">
          <source>In the following example we have three inline boxes created by a paragraph with a strong element inside it.</source>
          <target state="translated">다음 예에는 단락에 강한 요소가있는 단락으로 만든 세 개의 인라인 상자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97d95466508eec13093a8b4c24493dba0d277d47" translate="yes" xml:space="preserve">
          <source>In the following example, I have four grid areas within my grid. I can use the &lt;a href=&quot;../align-items&quot;&gt;&lt;code&gt;align-items&lt;/code&gt;&lt;/a&gt; property on the grid container, to align the items using one of the following values:</source>
          <target state="translated">다음 예제에서는 그리드 내에 4 개의 그리드 영역이 있습니다. 그리드 컨테이너 에서 &lt;a href=&quot;../align-items&quot;&gt; &lt;code&gt;align-items&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 다음 값 중 하나를 사용하여 항목을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7056de60841151d095062abbcd5bb07fc3f15382" translate="yes" xml:space="preserve">
          <source>In the following example, span elements (normally displayed as inline elements) are set to &lt;code&gt;display: block&lt;/code&gt; and so break onto new lines and expand to fill their container in the inline dimension.</source>
          <target state="translated">다음 예제에서 span 요소 (일반적으로 인라인 요소로 표시됨)는 &lt;code&gt;display: block&lt;/code&gt; 설정 되어 새 줄로 나뉘어 확장하여 컨테이너를 인라인 차원으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ff40524fd9054adc2b3ee64a232968e9b95511d1" translate="yes" xml:space="preserve">
          <source>In the following example, there are five links that point to elements in the same document. Selecting the &quot;First&quot; link, for example, will cause &lt;code&gt;&amp;lt;h1 id=&quot;one&quot;&amp;gt;&lt;/code&gt; to become the target element. Note that the document may jump to a new scroll position, since target elements are placed on the top of the browser window if possible.</source>
          <target state="translated">다음 예에는 동일한 문서의 요소를 가리키는 5 개의 링크가 있습니다. 예를 들어 &quot;First&quot;링크를 선택하면 &lt;code&gt;&amp;lt;h1 id=&quot;one&quot;&amp;gt;&lt;/code&gt; 이 대상 요소가됩니다. 가능한 경우 대상 요소가 브라우저 창의 맨 위에 배치되므로 문서가 새 스크롤 위치로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2255de9ff1b87394edc348b1f6bcfd93394b9cfe" translate="yes" xml:space="preserve">
          <source>In the following examples I am working with &lt;a href=&quot;../flex-direction&quot;&gt;&lt;code&gt;flex-direction&lt;/code&gt;&lt;/a&gt; set to row, therefore the size of items will always come from their width. We will be calculating the positive and negative free space created by comparing the total width of all the items with the container width. You could equally try out each example with &lt;code&gt;flex-direction: column&lt;/code&gt;. The main axis would then be the column, and you would then need to compare the height of the items and that of the container they are in to work out the positive and negative free space.</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;../flex-direction&quot;&gt; &lt;code&gt;flex-direction&lt;/code&gt; &lt;/a&gt; 을 row로 설정하여 작업 하므로 항목의 크기는 항상 너비에서옵니다. 모든 항목의 총 너비와 컨테이너 너비를 비교하여 생성 된 양수 및 음수 여유 공간을 계산합니다. &lt;code&gt;flex-direction: column&lt;/code&gt; 사용하여 각 예제를 동일하게 시도 할 수 있습니다. 그러면 주축은 기둥이되고 양수 및 음수 여유 공간을 계산하기 위해 항목의 높이와 컨테이너의 높이를 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="092d50cb66ecb4c6d736fe2dabbfaa287ac3adcb" translate="yes" xml:space="preserve">
          <source>In the following live example I have a flex container with three child elements. One of these flex items has two elements nested inside it, which would not ordinarily participate in flex layout. Flex layout only applies to the direct children of a flex container.</source>
          <target state="translated">다음 라이브 예제에는 세 개의 자식 요소가있는 플렉스 컨테이너가 있습니다. 이러한 플렉스 항목 중 하나에는 내부에 두 개의 요소가 중첩되어있어 일반적으로 플렉스 레이아웃에 참여하지 않습니다. Flex 레이아웃은 Flex 컨테이너의 직계 자식에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aee3ec61f4f5be2ec4476ec4c7e342f6adaffb3e" translate="yes" xml:space="preserve">
          <source>In the following live example I have a non-wrapped flex container. The third item has more content than the others yet is set to &lt;code&gt;visibility: collapse&lt;/code&gt; and therefore the flex container is retaining a &lt;em&gt;strut&lt;/em&gt; of the height required to display this item. If you remove &lt;code&gt;visibility: collapse&lt;/code&gt; from the CSS or change the value to &lt;code&gt;visible&lt;/code&gt;, you will see the item disappear and the space redistribute between non-collapsed items; the height of the flex container should not change.</source>
          <target state="translated">다음 라이브 예제에서는 랩핑되지 않은 플렉스 컨테이너가 있습니다. 세 번째 항목은 다른 항목보다 내용이 &lt;code&gt;visibility: collapse&lt;/code&gt; 으로 설정되어 있습니다 . 축소 로 인해 Flex 컨테이너는 이 항목을 표시하는 데 필요한 높이 의 &lt;em&gt;스트럿&lt;/em&gt; 을 유지합니다 . &lt;code&gt;visibility: collapse&lt;/code&gt; 을 제거 하면 CSS에서 축소 되거나 값을 &lt;code&gt;visible&lt;/code&gt; 로 변경 하면 항목이 사라지고 축소되지 않은 항목 사이에 공간이 재분배됩니다. 플렉스 용기의 높이는 변하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a25b116fc0289a523680d38e9f59aa7ccd4634b5" translate="yes" xml:space="preserve">
          <source>In the following live example the first item has a &lt;code&gt;flex-shrink&lt;/code&gt; factor of 1, the second &lt;code&gt;0&lt;/code&gt; (so it won&amp;rsquo;t shrink at all), and the third &lt;code&gt;4&lt;/code&gt;. The third item therefore shrinks more rapidly than the first. Play around with the different values &amp;mdash; as for &lt;code&gt;flex-grow&lt;/code&gt; you can use decimals or larger numbers here. Choose whatever makes most sense to you.</source>
          <target state="translated">다음 라이브 예제에서 첫 번째 항목의 &lt;code&gt;flex-shrink&lt;/code&gt; factor는 1, 두 번째 &lt;code&gt;0&lt;/code&gt; (그래서 전혀 줄어들지 않음) 및 세 번째 &lt;code&gt;4&lt;/code&gt; 가 있습니다. 따라서 세 번째 항목은 첫 번째 항목보다 빠르게 축소됩니다. &lt;code&gt;flex-grow&lt;/code&gt; 의 경우 소수점 이하 자릿수 또는 큰 숫자를 사용할 수 있으므로 다른 값으로 재생 하십시오. 가장 적합한 것을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e3fc697cb9eee14b1453006fddbe4686ded4eb29" translate="yes" xml:space="preserve">
          <source>In the following live example, I have floated two blocks and then set &lt;code&gt;display: flex&lt;/code&gt; on the container. The items are now flex items, which means they stretch to equal height. Any float behaviour does not apply.</source>
          <target state="translated">다음 라이브 예제에서는 두 블록을 띄운 다음 컨테이너에 &lt;code&gt;display: flex&lt;/code&gt; 를 표시 합니다. 아이템은 이제 플렉스 아이템입니다. 즉, 동일한 높이로 늘어납니다. 플로트 동작은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6954ad952493aa4e25639ea39362c8f364f453c4" translate="yes" xml:space="preserve">
          <source>In the future we may not need to make a container a flex container just to centre a single item, as the Box Alignment properties will ultimately be implemented in Block layout. For now however, if you need to properly centre one thing inside another, flexbox is the way to do it. As in the above example, make a container into a flex container, and then use either &lt;code&gt;align-items&lt;/code&gt; on the parent element or target the flex item itself with &lt;code&gt;align-self&lt;/code&gt;.</source>
          <target state="translated">박스 정렬 속성은 궁극적으로 블록 레이아웃에서 구현되므로 향후 단일 아이템을 중앙에 배치하기 위해 컨테이너를 플렉스 컨테이너로 만들 필요는 없습니다. 그러나 지금은 하나의 것을 다른 것의 중심에 올바로 배치해야하는 경우 flexbox를 사용하는 방법입니다. 위의 예에서와 같이 컨테이너를 플렉스 컨테이너로 만든 다음 부모 요소에 &lt;code&gt;align-items&lt;/code&gt; 을 사용하거나 &lt;code&gt;align-self&lt;/code&gt; 를 사용하여 flex 항목 자체를 대상으로합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f514b8a9143ecc2063c50c73ee3cbd0f423441" translate="yes" xml:space="preserve">
          <source>In the guide to &lt;a href=&quot;flow_layout_and_writing_modes&quot;&gt;Writing Modes and Flow Layout&lt;/a&gt;, we looked at the newer properties of &lt;code&gt;block-size&lt;/code&gt; and &lt;code&gt;inline-size&lt;/code&gt; which make more sense when working with different writing modes than tying our layout to the physical dimensions of the screen. The Level 3 Overflow Module also includes flow relative properties for overflow - &lt;code&gt;&lt;a href=&quot;../@media/overflow-block&quot;&gt;overflow-block&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../@media/overflow-inline&quot;&gt;overflow-inline&lt;/a&gt;&lt;/code&gt;. These correspond to &lt;code&gt;overflow-x&lt;/code&gt; and &lt;code&gt;overflow-y&lt;/code&gt; but the mapping depends on the writing mode of the document.</source>
          <target state="translated">&lt;a href=&quot;flow_layout_and_writing_modes&quot;&gt;쓰기 모드 및 흐름 레이아웃&lt;/a&gt; 가이드에서는 레이아웃을 화면의 실제 크기에 연결하는 것보다 다른 쓰기 모드로 작업 할 때 더 적합한 &lt;code&gt;block-size&lt;/code&gt; 및 &lt;code&gt;inline-size&lt;/code&gt; 크기 의 새로운 속성을 살펴 보았습니다 . 레벨 3 오버 플로우 모듈에는 &lt;code&gt;&lt;a href=&quot;../@media/overflow-block&quot;&gt;overflow-block&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../@media/overflow-inline&quot;&gt;overflow-inline&lt;/a&gt;&lt;/code&gt; 대한 플로우 상대 특성도 포함됩니다 . 이들은 &lt;code&gt;overflow-x&lt;/code&gt; 및 &lt;code&gt;overflow-y&lt;/code&gt; 에 해당 하지만 매핑은 문서의 쓰기 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d952a98f5dfb68a5fe3bee072f3f02100d1a3505" translate="yes" xml:space="preserve">
          <source>In the image, you can see that two items have wrapped onto a new line. These items are sharing the available space and not lining up underneath the items above. This is because when you wrap flex items, each new row (or column when working by column) becomes a new flex container. Space distribution happens across the row.</source>
          <target state="translated">이미지에서 두 항목이 줄 바꿈 된 것을 볼 수 있습니다. 이 항목은 사용 가능한 공간을 공유하고 위의 항목 아래에 정렬되지 않습니다. 이는 플렉스 항목을 줄 바꿈 할 때 각각의 새 행 (또는 열별로 작업 할 때 열)이 새 플렉스 컨테이너가되기 때문입니다. 공간 분포는 행 전체에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dab5642e4f51019fbb1e55bf540191f4c2e7e142" translate="yes" xml:space="preserve">
          <source>In the live code example below I have items laid out using Flexbox. By changing which item has the class &lt;code&gt;active&lt;/code&gt; assigned to it in the HTML, you can change which item displays first and therefore becomes full width at the top of the layout, with the other items displaying below it.</source>
          <target state="translated">아래의 라이브 코드 예제에는 Flexbox를 사용하여 배치 된 항목이 있습니다. HTML에서 클래스에 할당 된 &lt;code&gt;active&lt;/code&gt; 항목이있는 항목을 변경 하면 먼저 표시 할 항목을 변경하여 레이아웃 상단에서 전체 너비가되고 다른 항목이 그 아래에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c05b9d199e6d3c3626af3c16ef2d036bcab9872f" translate="yes" xml:space="preserve">
          <source>In the live example below I have added a focus style in order that as you tab from link to link you can see which is highlighted. If you change the order using &lt;code&gt;flex-direction&lt;/code&gt; you can see how the tab order continues to follow the order that the items are listed in the source.</source>
          <target state="translated">아래 라이브 예제에서는 링크에서 링크로 탭할 때 강조 표시된 스타일을 볼 수 있도록 포커스 스타일을 추가했습니다. &lt;code&gt;flex-direction&lt;/code&gt; 을 사용하여 순서를 변경하면 탭 순서가 항목이 소스에 나열된 순서를 계속 따르는 방식을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ab10a7f257be62661e031bff67ee293e3eb39a" translate="yes" xml:space="preserve">
          <source>In the live example below I have set the Writing Mode to &lt;code&gt;horizontal-tb&lt;/code&gt;. Change it to &lt;code&gt;vertical-rl&lt;/code&gt; and you will see that the first example &amp;mdash; which uses &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; &amp;mdash; remains the same size in each dimension, despite the text becoming vertical. The second example &amp;mdash; which uses &lt;code&gt;inline-size&lt;/code&gt; and &lt;code&gt;block-size&lt;/code&gt; &amp;mdash; will follow the text direction as if the entire block has rotated.</source>
          <target state="translated">아래 라이브 예제에서 Writing Mode를 &lt;code&gt;horizontal-tb&lt;/code&gt; 로 설정했습니다 . &lt;code&gt;vertical-rl&lt;/code&gt; 로 변경 하면 텍스트가 수직이 되더라도 &lt;code&gt;width&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 를 사용하는 첫 번째 예제 는 각 차원에서 동일한 크기로 유지됩니다. &lt;code&gt;inline-size&lt;/code&gt; 와 &lt;code&gt;block-size&lt;/code&gt; 크기 를 사용하는 두 번째 예 는 전체 블록이 회전 한 것처럼 텍스트 방향을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9255335d6547c17fb53a42e099f9699e6f877b0e" translate="yes" xml:space="preserve">
          <source>In the live example below for instance I have two paragraph elements that contain a string of text. The first paragraph has a width of &lt;code&gt;min-content&lt;/code&gt;. In a browser that supports this keyword you should be able to see that the text has taken all of the soft wrapping opportunities available to it, becoming as small as it can be without overflowing. This then, is the &lt;code&gt;min-content&lt;/code&gt; size of that string. Essentially, the longest word in the string is dictating the size.</source>
          <target state="translated">예를 들어 아래 라이브 예에서는 텍스트 문자열을 포함하는 두 개의 단락 요소가 있습니다. 첫 번째 단락의 너비는 &lt;code&gt;min-content&lt;/code&gt; 입니다. 이 키워드를 지원하는 브라우저에서 텍스트가 사용 가능한 모든 부드러운 줄 바꿈 기회를 가져 와서 넘치지 않고 작을 수 있음을 알 수 있어야합니다. 그러면 해당 문자열 의 &lt;code&gt;min-content&lt;/code&gt; 크기입니다. 기본적으로 문자열에서 가장 긴 단어가 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cbe0578e868834de2803e27df1531ba8bfe603e4" translate="yes" xml:space="preserve">
          <source>In the live example below try changing &lt;code&gt;flex: auto&lt;/code&gt; to &lt;code&gt;flex: 1&lt;/code&gt;. This is the shorthand for &lt;code&gt;flex: 1 1 0&lt;/code&gt; and causes all of the items become the same width, as they are working from a flex-basis of 0 allowing all of the space to be distributed evenly.</source>
          <target state="translated">아래의 라이브 예제에서 &lt;code&gt;flex: auto&lt;/code&gt; to &lt;code&gt;flex: 1&lt;/code&gt; . 이것은 &lt;code&gt;flex: 1 1 0&lt;/code&gt; 의 약자이며 모든 항목이 균등하게 분배 될 수 있도록 0의 플렉스 기준에서 작동하므로 모든 항목이 동일한 너비가됩니다.</target>
        </trans-unit>
        <trans-unit id="93ad6e0c50bd71863f070d61d4bca7421736cb5e" translate="yes" xml:space="preserve">
          <source>In the live example below try changing the first value to one of the allowable values for &lt;code&gt;flex-direction&lt;/code&gt; - &lt;code&gt;row&lt;/code&gt;, &lt;code&gt;row-reverse&lt;/code&gt;, &lt;code&gt;column&lt;/code&gt; or &lt;code&gt;column-reverse&lt;/code&gt;, and also change the second to &lt;code&gt;wrap&lt;/code&gt; and &lt;code&gt;nowrap&lt;/code&gt;.</source>
          <target state="translated">아래의 라이브 예제에서 첫 번째 값을 &lt;code&gt;flex-direction&lt;/code&gt; - &lt;code&gt;row&lt;/code&gt; , &lt;code&gt;row-reverse&lt;/code&gt; , &lt;code&gt;column&lt;/code&gt; 또는 &lt;code&gt;column-reverse&lt;/code&gt; 에 허용되는 값 중 하나로 변경하고 두 번째 값을 줄 &lt;code&gt;wrap&lt;/code&gt; 및 &lt;code&gt;nowrap&lt;/code&gt; 바꿈으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="16dae158bffff224106262746f0d0fcc88c16edf" translate="yes" xml:space="preserve">
          <source>In the live example below you can see our media object. I have used the alignment properties to align the items on the cross axis to &lt;code&gt;flex-start&lt;/code&gt;, and then set the &lt;code&gt;.content&lt;/code&gt; flex item to &lt;code&gt;flex: 1&lt;/code&gt;. As with our column layout card pattern above, using &lt;code&gt;flex: 1&lt;/code&gt; means this part of the card can grow.</source>
          <target state="translated">아래 라이브 예제에서 미디어 객체를 볼 수 있습니다. 정렬 속성을 사용하여 크로스 축의 항목을 &lt;code&gt;flex-start&lt;/code&gt; 에 정렬 한 다음 &lt;code&gt;.content&lt;/code&gt; flex 항목을 &lt;code&gt;flex: 1&lt;/code&gt; . 위의 열 레이아웃 카드 패턴과 마찬가지로 &lt;code&gt;flex: 1&lt;/code&gt; 사용 하면 카드의이 부분이 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c19460d1f4c7e4fdf22b0b177370d1fa36e897" translate="yes" xml:space="preserve">
          <source>In the live example below, the flex container has a height of 400 pixels, which is more than needed to display our items. The value of &lt;code&gt;align-content&lt;/code&gt; is &lt;code&gt;space-between&lt;/code&gt;, which means that the available space is shared out &lt;em&gt;between&lt;/em&gt; the flex lines, which are placed flush with the start and end of the container on the cross axis.</source>
          <target state="translated">아래 라이브 예제에서 플렉스 컨테이너의 높이는 400 픽셀이며 이는 항목을 표시하는 데 필요한 것보다 큽니다. &lt;code&gt;align-content&lt;/code&gt; 의 값 은 &lt;code&gt;space-between&lt;/code&gt; 입니다. 즉, 사용 가능한 공간이 플렉스 라인 &lt;em&gt;간에&lt;/em&gt; 공유되며 , 이는 횡축에서 컨테이너의 시작 및 끝과 같은 높이에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="de72aa481a11341fa849fe0ad912a6a89ed01688" translate="yes" xml:space="preserve">
          <source>In the live example below, the value of &lt;code&gt;align-items&lt;/code&gt; is &lt;code&gt;stretch&lt;/code&gt;. Try the other values and see how all of the items align against each other in the flex container.</source>
          <target state="translated">아래 라이브 예에서 &lt;code&gt;align-items&lt;/code&gt; 의 값 은 &lt;code&gt;stretch&lt;/code&gt; 입니다. 다른 값을 사용 해보고 모든 항목이 Flex 컨테이너에서 서로 어떻게 정렬되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e7dbae096f6a48b717d996edc8b77c8a7dbcfcdd" translate="yes" xml:space="preserve">
          <source>In the live example you can play with increasing or decreasing the size of the circle by changing the size of the radius, moving the circle around with the position value, or setting a reference box as we did for &lt;code&gt;inset()&lt;/code&gt;.</source>
          <target state="translated">라이브 예제에서는 반지름의 크기를 변경하거나 위치 값으로 원을 이동하거나 &lt;code&gt;inset()&lt;/code&gt; 와 같이 참조 상자를 설정하여 원의 크기를 늘리거나 줄이면서 재생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a69f077a50a8b4ba0f18cffd5902642889439327" translate="yes" xml:space="preserve">
          <source>In the most basic cases, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; pages can be considered two-dimensional, because text, images, and other elements are arranged on the page without overlapping. In this case, there is a single rendering flow, and all elements are aware of the space taken by others. The &lt;a href=&quot;../z-index&quot;&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/a&gt; attribute lets you adjust the order of the layering of objects when rendering content.</source>
          <target state="translated">가장 기본적인 경우에는 텍스트, 이미지 및 기타 요소가 겹치지 않고 페이지에 정렬되므로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt; 페이지를 2 차원으로 간주 할 수 있습니다. 이 경우 단일 렌더링 흐름이 있으며 모든 요소는 다른 요소가 차지하는 공간을 인식합니다. &lt;a href=&quot;../z-index&quot;&gt; &lt;code&gt;z-index&lt;/code&gt; &lt;/a&gt; 속성은 콘텐츠를 렌더링 객체의 레이어의 순서를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1553c6b29e44ba9e3cf40fa7f07f3ce15e2e81" translate="yes" xml:space="preserve">
          <source>In the new syntax the inline flex container would be created using two values, inline for the outer display type, and flex for the inner display type.</source>
          <target state="translated">새로운 구문에서 인라인 플렉스 컨테이너는 외부 디스플레이 유형에 대한 인라인과 내부 디스플레이 유형에 대한 플렉스의 두 값을 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad572e0bec9e210a733b8fc55518843969ffc3e" translate="yes" xml:space="preserve">
          <source>In the next guide you will learn &lt;a href=&quot;handling_overflow_in_multicol&quot;&gt;how multicol handles overflow&lt;/a&gt;, both within columns and where there are more columns than will fit the container.</source>
          <target state="translated">다음 가이드에서는 컬럼 내부 및 컨테이너에 맞는 것보다 더 많은 컬럼이있는 위치에서 &lt;a href=&quot;handling_overflow_in_multicol&quot;&gt;multicol이 overflow를 처리하는 방법&lt;/a&gt; 을 학습 합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b040c34fb21d744af8e84794daee27ccbdd29f" translate="yes" xml:space="preserve">
          <source>In the next live example I have three items in a flex container; I&amp;rsquo;ve given each a width of 200 pixels, and the container is 500 pixels wide. With &lt;code&gt;flex-shrink&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; the items are not allowed to shrink and so they overflow the box.</source>
          <target state="translated">다음 라이브 예제에서는 플렉스 컨테이너에 세 개의 항목이 있습니다. 각각 너비가 200 픽셀이고 컨테이너의 너비는 500 픽셀입니다. 로 &lt;code&gt;flex-shrink&lt;/code&gt; 으로 설정 &lt;code&gt;0&lt;/code&gt; 항목은 축소 할 수 없습니다 그래서 그들은 상자를 오버 플로우.</target>
        </trans-unit>
        <trans-unit id="15de18ad2c56f01b034aef435ca8f054cf14763a" translate="yes" xml:space="preserve">
          <source>In the past, a typeface would be produced as a number of individual fonts, and each font would represent one specific width/weight/style combination. So you would have separate files for 'Roboto Regular', 'Roboto Bold', and 'Roboto Bold Italic' &amp;mdash; meaning that you could end up with 20 or 30 different font files to represent a complete typeface (it could be several times that for a large typeface that has different widths as well).</source>
          <target state="translated">과거에는 서체가 여러 개의 개별 글꼴로 만들어졌으며 각 글꼴은 하나의 특정 너비 / 무게 / 스타일 조합을 나타 냈습니다. 따라서 'Roboto Regular', 'Roboto Bold'및 'Roboto Bold Italic'에 대해 별도의 파일을 갖게됩니다. 즉, 완전한 서체를 나타내는 20 ~ 30 개의 서로 다른 글꼴 파일로 끝날 수 있습니다. 너비가 다른 큰 서체).</target>
        </trans-unit>
        <trans-unit id="6c5a70b8682135d7d500c528eb8bc2a783415e68" translate="yes" xml:space="preserve">
          <source>In the previous example, we've already seen the &lt;code&gt;and&lt;/code&gt; operator used to group a media &lt;em&gt;type&lt;/em&gt; with a media &lt;em&gt;feature&lt;/em&gt;. The &lt;code&gt;and&lt;/code&gt; operator can also combine multiple media features into a single media query. The &lt;code&gt;not&lt;/code&gt; operator, meanwhile, negates a media query, basically reversing its normal meaning. The &lt;code&gt;only&lt;/code&gt; operator prevents older browsers from applying the styles.</source>
          <target state="translated">이전 예에서 미디어 &lt;em&gt;유형&lt;/em&gt; 을 미디어 &lt;em&gt;기능&lt;/em&gt; 으로 그룹화하는 데 사용 된 &lt;code&gt;and&lt;/code&gt; 연산자를 이미 보았습니다 . &lt;code&gt;and&lt;/code&gt; 연산자는 하나의 미디어 쿼리에 여러 미디어 기능을 결합 할 수 있습니다. 한편 &lt;code&gt;not&lt;/code&gt; 연산자는 미디어 쿼리를 무시하여 기본 의미를 반대로 바꿉니다. &lt;code&gt;only&lt;/code&gt; 운영자는 스타일을 적용에서 이전 버전의 브라우저를 방지 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f54aaf5c1f5791f450a5eda896d09a4d47e064ea" translate="yes" xml:space="preserve">
          <source>In the previous part of this article, &lt;a href=&quot;../../understanding_z-index/adding_z-index&quot;&gt;Using z-index&lt;/a&gt;, the rendering order of certain elements is influenced by their &lt;code&gt;z-index&lt;/code&gt; value. This occurs because these elements have special properties which cause them to form a &lt;em&gt;stacking context&lt;/em&gt;.</source>
          <target state="translated">이 기사의 앞부분 인 &lt;a href=&quot;../../understanding_z-index/adding_z-index&quot;&gt;z-index 사용&lt;/a&gt; 에서 특정 요소의 렌더링 순서는 &lt;code&gt;z-index&lt;/code&gt; 값의 영향을받습니다 . 이러한 요소에는 특수한 속성이있어 &lt;em&gt;스택 컨텍스트&lt;/em&gt; 를 형성하기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="298c1440011be7fcdc1903def8750068922231c6" translate="yes" xml:space="preserve">
          <source>In the rare cases where width is overconstrained (i.e., when all of &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;margin-left&lt;/code&gt;, &lt;code&gt;border&lt;/code&gt;, &lt;code&gt;padding&lt;/code&gt;, the content area, and &lt;code&gt;margin-right&lt;/code&gt; are defined), &lt;code&gt;margin-left&lt;/code&gt; is ignored, and will have the same calculated value as if the &lt;code&gt;auto&lt;/code&gt; value was specified.</source>
          <target state="translated">너비가 과도하게 제한된 경우 (즉, &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;margin-left&lt;/code&gt; , &lt;code&gt;border&lt;/code&gt; , &lt;code&gt;padding&lt;/code&gt; , 내용 영역 및 &lt;code&gt;margin-right&lt;/code&gt; 가 모두 정의 된 경우)의 경우 &lt;code&gt;margin-left&lt;/code&gt; 는 무시되며 다음과 같은 계산 된 값을 갖습니다. 경우 &lt;code&gt;auto&lt;/code&gt; 값이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="b10380a91b23a0766d57e3e9940d0195da5d1aea" translate="yes" xml:space="preserve">
          <source>In the same way as &lt;code&gt;flex-grow&lt;/code&gt;, you can give flex-items different &lt;code&gt;flex-shrink&lt;/code&gt; factors. This can help change the default behaviour if, for example, you want an item to shrink more or less rapidly than its siblings or not shrink at all.</source>
          <target state="translated">&lt;code&gt;flex-grow&lt;/code&gt; 와 같은 방식으로 flex-item에 다른 &lt;code&gt;flex-shrink&lt;/code&gt; factor를 줄 수 있습니다 . 예를 들어 항목이 형제보다 다소 줄어들거나 전혀 줄어들지 않게하려면 기본 동작을 변경하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac930cc01816801e88080be55a76d1e969c343c" translate="yes" xml:space="preserve">
          <source>In the same way that changing the value of &lt;code&gt;flex-direction&lt;/code&gt; does not change the order in which items are navigated to, changing this value does not change paint order. It is a visual reversal of the items only.</source>
          <target state="translated">&lt;code&gt;flex-direction&lt;/code&gt; 의 값을 변경해도 항목 탐색 순서가 변경되지 않는 것과 마찬가지로이 값을 변경해도 페인트 순서는 변경되지 않습니다. 항목의 시각적 반전입니다.</target>
        </trans-unit>
        <trans-unit id="7fdaf157d4234540dcc73994953caa29f02576a8" translate="yes" xml:space="preserve">
          <source>In the second example, we specify the end row line we want the item to finish at and then set the start line as &lt;code&gt;span 3&lt;/code&gt;. This means the item will need to span upwards from the specified row line. The area will start at line 4 and span 3 lines to line 1.</source>
          <target state="translated">두 번째 예에서는 항목을 끝내려는 행 끝 행을 지정한 다음 시작 행을 &lt;code&gt;span 3&lt;/code&gt; 으로 설정합니다 . 이는 항목이 지정된 행 줄에서 위쪽으로 확장되어야 함을 의미합니다. 이 영역은 4 행에서 시작하여 3 행을 1 행으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="429c132b5a240a1fe584534ef94a564c2b27a8a4" translate="yes" xml:space="preserve">
          <source>In the two-value syntax, the first value represents the horizontal repetition behavior and the second value represents the vertical behavior. Here is an explanation of how each option works for either direction:</source>
          <target state="translated">두 값 구문에서 첫 번째 값은 가로 반복 동작을 나타내고 두 번째 값은 세로 동작을 나타냅니다. 각 옵션이 어느 방향으로 작동하는지에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1c1e39988743448f81127c10aa85b64c828f85c" translate="yes" xml:space="preserve">
          <source>In the working draft of the Level 2 Grid specification there is a feature called &lt;em&gt;subgrid&lt;/em&gt;, which would let us create nested grids that use the track definition of the parent grid.</source>
          <target state="translated">Level 2 Grid 사양의 초안에는 &lt;em&gt;subgrid&lt;/em&gt; 라는 기능이 있는데,이를 통해 부모 그리드의 트랙 정의를 사용하는 중첩 그리드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dbf959c3b8c657ace3d915449997fdc997852eb" translate="yes" xml:space="preserve">
          <source>In these guides, I have already touched on an important feature of grid layout: the support for different writing modes that is built into the specification. For this guide, we will look at this feature of grid and other modern layout methods, learning a little about writing modes and logical vs. physical properties as we do so.</source>
          <target state="translated">이 안내서에서는 그리드 레이아웃의 중요한 기능인 사양에 내장 된 다양한 쓰기 모드 지원에 대해 이미 다루었습니다. 이 가이드에서는 그리드 및 기타 최신 레이아웃 방법의 기능을 살펴보고 모드 작성과 논리적 특성과 물리적 특성에 대해 약간 배웁니다.</target>
        </trans-unit>
        <trans-unit id="7d5e24e0ccb459d232b453d7662e12bfd14a990d" translate="yes" xml:space="preserve">
          <source>In this article we have had a very quick look through the Grid Layout Specification. Have a play with the code examples, and then move onto &lt;a href=&quot;relationship_of_grid_layout&quot;&gt;the next part of this guide where we will really start to dig into the detail of CSS Grid Layout&lt;/a&gt;.</source>
          <target state="translated">이 기사에서는 그리드 레이아웃 사양을 매우 빠르게 살펴 보았습니다. 코드 예제를 살펴본 &lt;a href=&quot;relationship_of_grid_layout&quot;&gt;다음이 가이드의 다음 부분으로&lt;/a&gt; 이동하여 CSS 그리드 레이아웃에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2d1755aa3e53a8c361a46090ad5787f2b79d53" translate="yes" xml:space="preserve">
          <source>In this article we will take a look at how Flexbox fits in with all the other CSS modules. We&amp;rsquo;ll find out which specifications you also need to take notice of if you want to learn flexbox, and find out why flexbox is different to some other modules.</source>
          <target state="translated">이 기사에서는 Flexbox가 다른 모든 CSS 모듈에 어떻게 적용되는지 살펴 보겠습니다. flexbox를 배우려면 어떤 사양을 고려해야하는지 알아 내고 flexbox가 다른 모듈과 다른 이유를 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="806b82362c952195fc17b42b9a51cb9fa51e8eb0" translate="yes" xml:space="preserve">
          <source>In this beginner's learning article we go through all the basic fundamentals of text/font styling in detail, including setting font weight, family and style, font shorthand, text alignment and other effects, and line and letter spacing.</source>
          <target state="translated">이 초급 학습 기사에서는 글꼴 무게, 패밀리 및 스타일, 글꼴 약식, 텍스트 정렬 및 기타 효과, 줄 및 문자 간격 설정을 포함하여 텍스트 / 글꼴 스타일의 모든 기본 기본 사항을 자세히 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="de98041c867702f8e697ecf112eb1cd3d2b3fc58" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;flex-basis&lt;/code&gt; value is &lt;code&gt;auto&lt;/code&gt; and the items don&amp;rsquo;t have a width set, and so are auto-sized. This means that flexbox is looking at the &lt;code&gt;max-content&lt;/code&gt; size of the items. After laying the items out we have some positive free space in the flex container, shown in this image as the hatched area:</source>
          <target state="translated">이 경우 &lt;code&gt;flex-basis&lt;/code&gt; 값은 &lt;code&gt;auto&lt;/code&gt; 이고 항목에 너비가 설정되어 있지 않으므로 자동 크기가 조정됩니다. 이는 flexbox가 항목 의 &lt;code&gt;max-content&lt;/code&gt; 크기를 보고 있음을 의미 합니다. 항목을 배치 한 후이 이미지에서 부화 영역으로 표시된대로 플렉스 컨테이너에 약간의 여유 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="736ae764cd69dc03945633b96e49c9764f9f0747" translate="yes" xml:space="preserve">
          <source>In this case the nested grid has no relationship to the parent. As you can see in the example it has not inherited the &lt;a href=&quot;../grid-gap&quot;&gt;&lt;code&gt;grid-gap&lt;/code&gt;&lt;/a&gt; of the parent and the lines in the nested grid do not align to the lines in the parent grid.</source>
          <target state="translated">이 경우 중첩 그리드는 부모와 관련이 없습니다. 예제에서 볼 수 있듯이 부모 의 &lt;a href=&quot;../grid-gap&quot;&gt; &lt;code&gt;grid-gap&lt;/code&gt; &lt;/a&gt; 을 상속 하지 않았으며 중첩 격자의 선이 부모 격자의 선과 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee3abeeefcb696e519075ddfb065ea8f0e21fa6a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;@stylistic(alternates)&lt;/code&gt; will show all the alternate characters for either font). Applying this to just the word 'My' alters the way the 'M' renders, and applying &lt;code&gt;@styleset(alt-a)&lt;/code&gt; only changes the lower case 'a'.</source>
          <target state="translated">이 경우 &lt;code&gt;@stylistic(alternates)&lt;/code&gt; 는 두 글꼴에 대한 모든 대체 문자를 표시합니다. 이것을 'My'단어에만 적용하면 'M'이 렌더링되는 방식이 &lt;code&gt;@styleset(alt-a)&lt;/code&gt; 적용하면 소문자 'a'만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb3359b2f15de06b821981f5c5a1ef62c9ffe31" translate="yes" xml:space="preserve">
          <source>In this case, declarations inside &lt;code&gt;li&lt;/code&gt; and &lt;code&gt;.specific&lt;/code&gt; rules should apply. No declaration is marked as &lt;code&gt;!important&lt;/code&gt;, so the precedence order is author style sheets before user style sheets or user-agent stylesheet.</source>
          <target state="translated">이 경우 &lt;code&gt;li&lt;/code&gt; 및 &lt;code&gt;.specific&lt;/code&gt; 규칙 내부의 선언 이 적용되어야합니다. 선언이 &lt;code&gt;!important&lt;/code&gt; 로 표시되지 않으므로 우선 순위는 사용자 스타일 시트 또는 사용자 에이전트 스타일 시트 이전의 작성자 스타일 시트입니다.</target>
        </trans-unit>
        <trans-unit id="7e37a1a816cc7f4288f6c617f4216a22cfc3b1d3" translate="yes" xml:space="preserve">
          <source>In this case, the results of &lt;code&gt;var(--test)&lt;/code&gt; are:</source>
          <target state="translated">이 경우 &lt;code&gt;var(--test)&lt;/code&gt; 의 결과 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c77516e387c9dadcedb44d5dbc60bce55d4029d7" translate="yes" xml:space="preserve">
          <source>In this case, the width is specified as auto in the CSS, so the 100px width specified in the SVG is selected, per rule 3. The height is set at 125px in the CSS, so that is selected per rule 1.</source>
          <target state="translated">이 경우 CSS에서 너비가 auto로 지정되므로 규칙 3에 따라 SVG에 지정된 100px 너비가 선택됩니다. CSS에서 높이는 125px로 설정되어 규칙 1마다 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="f5310054937895cf86546219af6d059cabad1f60" translate="yes" xml:space="preserve">
          <source>In this case, we've overridden the height of the image in the CSS to be 150px, so rule 1 is applied. The intrinsic 3:4 aspect ratio then determines the width for the &lt;code&gt;auto&lt;/code&gt; case.</source>
          <target state="translated">이 경우 CSS의 이미지 높이를 150px로 재정의 했으므로 규칙 1이 적용됩니다. 그런 다음 고유 한 3 : 4 종횡비가 &lt;code&gt;auto&lt;/code&gt; 케이스 의 너비를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="8d781426217c2387e7f6e906360a0d586be31724" translate="yes" xml:space="preserve">
          <source>In this case, you could set certain styles in your global CSS file as important, thus overriding inline styles set directly on elements.</source>
          <target state="translated">이 경우 전역 CSS 파일에서 특정 스타일을 중요하게 설정하여 요소에 직접 설정된 인라인 스타일을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45397822e66207fd90cf6afff12f8c4039bd46eb" translate="yes" xml:space="preserve">
          <source>In this demo we use a simple template with three slots:</source>
          <target state="translated">이 데모에서는 3 개의 슬롯이있는 간단한 템플릿을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe1fd37daa0b6455d12ca6ad918e18c56ad8dfb5" translate="yes" xml:space="preserve">
          <source>In this example I am using the &lt;a href=&quot;grid-gap&quot;&gt;&lt;code&gt;grid-gap&lt;/code&gt;&lt;/a&gt; property in addition to &lt;a href=&quot;gap&quot;&gt;&lt;code&gt;gap&lt;/code&gt;&lt;/a&gt;. The gap properties were originally prefixed with &lt;code&gt;grid-&lt;/code&gt; in the Grid Layout specification and some browsers only support these prefixed versions.</source>
          <target state="translated">이 예에서는 내가 사용하고 &lt;a href=&quot;grid-gap&quot;&gt; &lt;code&gt;grid-gap&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 재산 &lt;a href=&quot;gap&quot;&gt; &lt;code&gt;gap&lt;/code&gt; &lt;/a&gt; . 간격 속성은 원래 그리드 레이아웃 사양에서 &lt;code&gt;grid-&lt;/code&gt; 접두사가 붙었 으며 일부 브라우저는 이러한 접두사 버전 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab33cc8f883f39b02630231ec713a1fb9f6b8af1" translate="yes" xml:space="preserve">
          <source>In this example I have a &lt;code&gt;div&lt;/code&gt;, and then two paragraphs. I&amp;rsquo;ve added a background colour to the paragraphs, and then floated the &lt;code&gt;div&lt;/code&gt; left. The &lt;code&gt;div&lt;/code&gt; is now out of flow.</source>
          <target state="translated">이 예에서는 &lt;code&gt;div&lt;/code&gt; 와 두 개의 단락이 있습니다. 단락에 배경색을 추가 한 다음 &lt;code&gt;div&lt;/code&gt; 를 왼쪽으로 플로팅했습니다 . &lt;code&gt;div&lt;/code&gt; 흐름에서 지금이다.</target>
        </trans-unit>
        <trans-unit id="c388f1b57cc0300303f4815e29dcd514c60b82a0" translate="yes" xml:space="preserve">
          <source>In this example I have added an extra div with a class of &lt;code&gt;overlay&lt;/code&gt;. We have named areas created using the &lt;code&gt;grid-area&lt;/code&gt; property, then a layout created in &lt;code&gt;grid-template-areas&lt;/code&gt;. The area names are:</source>
          <target state="translated">이 예에서는 &lt;code&gt;overlay&lt;/code&gt; 클래스가있는 추가 div를 추가했습니다 . &lt;code&gt;grid-area&lt;/code&gt; 속성을 사용하여 만든 영역의 이름을 지정한 다음 &lt;code&gt;grid-template-areas&lt;/code&gt; 에서 만든 레이아웃을 지정했습니다 . 지역 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00d7a6e6cb9021c32a21d567ca50da277e34d653" translate="yes" xml:space="preserve">
          <source>In this example I have created a series of inflexible boxes, with both &lt;code&gt;flex-grow&lt;/code&gt; and &lt;code&gt;flex-shrink&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;. Here we can see how the first item &amp;mdash; which has an explicit width of 150 pixels set as the main size &amp;mdash; takes a &lt;code&gt;flex-basis&lt;/code&gt; of &lt;code&gt;150px&lt;/code&gt;, whereas the other two items have no width and so are sized according to their content width.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;flex-grow&lt;/code&gt; 와 &lt;code&gt;flex-shrink&lt;/code&gt; 가 모두 &lt;code&gt;0&lt;/code&gt; 으로 설정된 일련의 융통성없는 상자를 만들었습니다 . 여기에서 명시 적 너비가 150 픽셀 인 기본 크기로 설정된 첫 번째 항목 이 &lt;code&gt;150px&lt;/code&gt; 의 &lt;code&gt;flex-basis&lt;/code&gt; 를 취하는 반면 다른 두 항목에는 너비가 없으므로 내용 너비에 따라 크기가 조정되는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="412fe06e90ef07f3a8c45d67a7f9f474e02dd569" translate="yes" xml:space="preserve">
          <source>In this example I have used grid to lay out a set of boxes that contain links. I have used the line-based placement properties to position box 1 on the second row of the grid. Visually it now appears as the fourth item in the list. However, if I tab from link to link the tab order still begins with box 1, as it comes first in the source.</source>
          <target state="translated">이 예제에서는 그리드를 사용하여 링크가 포함 된 상자 세트를 배치했습니다. 선 기반 배치 속성을 사용하여 그리드의 두 번째 행에 상자 1을 배치했습니다. 시각적으로 이제 목록에서 네 번째 항목으로 나타납니다. 그러나 링크에서 탭하여 링크를 탭하면 탭 순서가 소스에서 처음 나오는 상자 1로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1902a41f08bb720c50d57bb90ac200a6e48005de" translate="yes" xml:space="preserve">
          <source>In this example every positioned element creates its own stacking context, because of their positioning and z-index values. The hierarchy of stacking contexts is organized as follows:</source>
          <target state="translated">이 예제에서 모든 위치 지정된 요소는 위치 및 z- 색인 값으로 인해 고유 한 스태킹 컨텍스트를 만듭니다. 스태킹 컨텍스트의 계층 구조는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac6b6cac80147f85cb84a6e58baf6c9d7e8b6af4" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;h2&lt;/code&gt; elements inside the sidebar might be different colors. For example, if one of them were the child of a div matched by the rule ...</source>
          <target state="translated">이 예에서 사이드 바 내부 의 &lt;code&gt;h2&lt;/code&gt; 요소는 색상이 다를 수 있습니다. 예를 들어, 그들 중 하나가 규칙과 일치하는 div의 자식 인 경우 ...</target>
        </trans-unit>
        <trans-unit id="063e13fd7e98a47847078727baf87949e460b45a" translate="yes" xml:space="preserve">
          <source>In this example the outer &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; has a 2-pixel red border and a width of 300px. However it also has &lt;code&gt;display: contents&lt;/code&gt; specified therefore this &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will not be rendered, the border and width will no longer apply, and the child element will be displayed as if the parent had never existed.</source>
          <target state="translated">이 예에서 외부 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 2 픽셀의 빨간색 테두리와 300px의 너비를 갖습니다. 그러나 &lt;code&gt;display: contents&lt;/code&gt; 지정되었으므로이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 는 렌더링되지 않고 테두리와 너비가 더 이상 적용되지 않으며 부모 요소가 존재하지 않은 것처럼 자식 요소가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2339f722a93ad17b557f00f1cc9071be7fdc80b" translate="yes" xml:space="preserve">
          <source>In this example the parent box has been given &lt;code&gt;display: flow-root&lt;/code&gt; and so establishes a new BFC and contains the floated item.</source>
          <target state="translated">이 예제에서 부모 상자에 &lt;code&gt;display: flow-root&lt;/code&gt; 되어 새 BFC를 설정하고 부동 항목을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="29b67c1002c50aacac315139c57d95668d10d0e8" translate="yes" xml:space="preserve">
          <source>In this example the style for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;/a&gt; element specifies that the animation should take 3 seconds to execute from start to finish, using the &lt;a href=&quot;../animation-duration&quot;&gt;&lt;code&gt;animation-duration&lt;/code&gt;&lt;/a&gt; property, and that the name of the &lt;a href=&quot;../@keyframes&quot;&gt;&lt;code&gt;@keyframes&lt;/code&gt;&lt;/a&gt; at-rule defining the keyframes for the animation sequence is named &amp;ldquo;slidein&amp;rdquo;.</source>
          <target state="translated">이 예제에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt; &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 스타일 은 &lt;a href=&quot;../animation-duration&quot;&gt; &lt;code&gt;animation-duration&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 애니메이션이 처음부터 끝까지 실행하는 데 3 초가 걸리고 애니메이션 의 키 프레임을 정의하는 &lt;a href=&quot;../@keyframes&quot;&gt; &lt;code&gt;@keyframes&lt;/code&gt; &lt;/a&gt; at-rule 의 이름이 지정되도록 지정 합니다. 서열은 &quot;슬라이드 인&quot;으로 명명된다.</target>
        </trans-unit>
        <trans-unit id="53dd3f7786387eb3a60090e064e9ea13616b56e2" translate="yes" xml:space="preserve">
          <source>In this example using Grid Layout, there is extra space in the grid container after laying out the fixed width tracks on the inline (main) axis. This space is distributed using &lt;a href=&quot;justify-content&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt;. On the block (cross) axis the alignment of the items inside their grid areas is controlled with &lt;a href=&quot;align-items&quot;&gt;&lt;code&gt;align-items&lt;/code&gt;&lt;/a&gt;. The first item overrides the &lt;code&gt;align-items&lt;/code&gt; value set on the group by setting &lt;a href=&quot;align-self&quot;&gt;&lt;code&gt;align-self&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;center&lt;/code&gt;.</source>
          <target state="translated">그리드 레이아웃을 사용하는이 예에서는 인라인 (메인) 축에 고정 폭 트랙을 배치 한 후 그리드 컨테이너에 추가 공간이 있습니다. 이 공간은 &lt;a href=&quot;justify-content&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; 를&lt;/a&gt; 사용하여 분배 됩니다 . 블록 (크로스) 축에서 그리드 영역 내부의 항목 정렬은 &lt;a href=&quot;align-items&quot;&gt; &lt;code&gt;align-items&lt;/code&gt; &lt;/a&gt; 제어 됩니다 . 첫 번째 항목은 &lt;a href=&quot;align-self&quot;&gt; &lt;code&gt;align-self&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;center&lt;/code&gt; 로 설정하여 그룹에 설정된 정렬 &lt;code&gt;align-items&lt;/code&gt; 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1c9c9ab9029359316172493ce4648e51684251bc" translate="yes" xml:space="preserve">
          <source>In this example using grid layout, there is extra space in the grid container after laying out the fixed width tracks on the inline (main) axis. This space is distributed using &lt;code&gt;justify-content&lt;/code&gt;. On the block (cross) axis the alignment of the items inside their grid areas is controlled with &lt;code&gt;align-items&lt;/code&gt;. The first item overrides the &lt;code&gt;align-items&lt;/code&gt; value set on the group by setting &lt;code&gt;align-self&lt;/code&gt; to &lt;code&gt;center&lt;/code&gt;.</source>
          <target state="translated">그리드 레이아웃을 사용하는이 예에서는 인라인 (메인) 축에 고정 폭 트랙을 배치 한 후 그리드 컨테이너에 추가 공간이 있습니다. 이 공간은 &lt;code&gt;justify-content&lt;/code&gt; 를 사용하여 분배 됩니다 . 블록 (크로스) 축에서 그리드 영역 내부의 항목 정렬은 &lt;code&gt;align-items&lt;/code&gt; 제어 됩니다 . 첫 번째 항목은 &lt;code&gt;align-self&lt;/code&gt; 를 &lt;code&gt;center&lt;/code&gt; 로 설정하여 그룹에 설정된 정렬 &lt;code&gt;align-items&lt;/code&gt; 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="eb0ef9572f60f8fad26e4a8d393795da021a1024" translate="yes" xml:space="preserve">
          <source>In this example we have a simple SVG embedded using an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">이 예에서는 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소를 사용하여 포함 된 간단한 SVG가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1ecfba8dac936602cce226f0a525c452bce4e46" translate="yes" xml:space="preserve">
          <source>In this example we have a simple custom element &amp;mdash; &lt;code&gt;&amp;lt;context-span&amp;gt;&lt;/code&gt; &amp;mdash; that you can wrap around text:</source>
          <target state="translated">이 예에서는 텍스트를 감싸는 간단한 사용자 정의 요소 인 &lt;code&gt;&amp;lt;context-span&amp;gt;&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab70300010aee53a1d4aeb5a285bbc1ed68e55d" translate="yes" xml:space="preserve">
          <source>In this example we have chosen to use a thin scrollbar, with a green track and purple thumb.</source>
          <target state="translated">이 예에서는 녹색 트랙과 자주색 엄지가있는 얇은 스크롤 막대를 사용하기로 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="c5e6cea9552a55843d2bcb32da6155d171d79902" translate="yes" xml:space="preserve">
          <source>In this example we will create a simple to-do list using pseudo-elements. This method can often be used to add small touches to the UI and improve user experience.</source>
          <target state="translated">이 예에서는 의사 요소를 사용하여 간단한 할 일 목록을 만듭니다. 이 방법은 종종 UI에 작은 터치를 추가하고 사용자 경험을 향상시키는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="332d826deccc38ea19f8d394c578d1b426fdfca4" translate="yes" xml:space="preserve">
          <source>In this example, I have a containing div with a class of wrapper, inside are five child elements.</source>
          <target state="translated">이 예에서는 래퍼 클래스가 포함 된 div가 있고 내부에는 5 개의 자식 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d5a1d99a9ff05027bff2fcc91f4ce68340e5d6" translate="yes" xml:space="preserve">
          <source>In this example, a box is shown which uses a &lt;a href=&quot;background-image&quot;&gt;&lt;code&gt;background-image&lt;/code&gt;&lt;/a&gt; and a translucent &lt;a href=&quot;linear-gradient()&quot;&gt;&lt;code&gt;linear-gradient()&lt;/code&gt;&lt;/a&gt; function atop a black background color to have a dark blue gradient behind medium red text. For whatever reason, this is the desired appearance in any rendering environment, including on paper, so we also use &lt;code&gt;color-adjust: exact&lt;/code&gt; to tell the browser not to make color or style adjustments to the box when rendering it.</source>
          <target state="translated">이 예에서는 검정색 배경색 위에 &lt;a href=&quot;background-image&quot;&gt; &lt;code&gt;background-image&lt;/code&gt; &lt;/a&gt; 와 반투명 &lt;a href=&quot;linear-gradient()&quot;&gt; &lt;code&gt;linear-gradient()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 중간 빨간색 텍스트 뒤에 진한 파란색 그라디언트 를 사용하는 상자가 표시 됩니다. 어떤 이유로 든 이것은 종이를 포함한 모든 렌더링 환경에서 원하는 모양이므로 &lt;code&gt;color-adjust: exact&lt;/code&gt; 하여 렌더링시 상자에 색상이나 스타일을 조정하지 않도록 브라우저에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="3b0397d42b42957ec7a2420f0d3d40eef5111f16" translate="yes" xml:space="preserve">
          <source>In this example, at the &lt;code&gt;50%&lt;/code&gt; keyframe, the value used is &lt;code&gt;top: 10px&lt;/code&gt; and all other values at this keyframe are ignored.</source>
          <target state="translated">이 예제에서 &lt;code&gt;50%&lt;/code&gt; 키 프레임에서 사용 된 값은 &lt;code&gt;top: 10px&lt;/code&gt; 키 프레임의 다른 모든 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac654a9756e0a155ec887105861fff09614bc62" translate="yes" xml:space="preserve">
          <source>In this example, each list item is matched with a different value of &lt;code&gt;background-repeat&lt;/code&gt;.</source>
          <target state="translated">이 예에서 각 목록 항목은 다른 값의 &lt;code&gt;background-repeat&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d02a88ffb4dc21f397cef8436db853f12a4977a8" translate="yes" xml:space="preserve">
          <source>In this example, the &quot;child&quot; will be either 150 pixels wide or the width of the &quot;parent,&quot; whichever is smaller:</source>
          <target state="translated">이 예에서 &quot;자식&quot;은 너비가 150 픽셀이거나 &quot;부모&quot;의 너비 중 작은 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd83de097f457aca4617d547609c0852083229a0" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;:focus-visible&lt;/code&gt; selector uses the UA's behavior to determine when to match. Compare what happens when you click on the different controls with a mouse, versus when you tab through them using a keyboard. Note the difference in behavior from elements styled with &lt;code&gt;:focus&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;:focus-visible&lt;/code&gt; 선택기는 UA의 동작을 사용하여 일치시기를 결정합니다. 마우스로 다른 컨트롤을 클릭 할 때와 키보드로 컨트롤을 탭할 때 발생하는 상황을 비교하십시오. &lt;code&gt;:focus&lt;/code&gt; 로 스타일이 지정된 요소와 동작의 차이점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b44feeccda260a2ec4520fda513e2f8b9b1ccb11" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;:lang()&lt;/code&gt; pseudo-class is used to match the parents of quote elements (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt;&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;&lt;/a&gt;) using &lt;a href=&quot;child_selectors&quot;&gt;child combinators&lt;/a&gt;. Note that this doesn't illustrate the only way to do this, and that the best method to use depends on the type of document. Also note that &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Unicode&quot;&gt;Unicode&lt;/a&gt; values are used to specify some of the special quote characters.</source>
          <target state="translated">이 예에서 &lt;code&gt;:lang()&lt;/code&gt; 의사 클래스는 &lt;a href=&quot;child_selectors&quot;&gt;하위 결합&lt;/a&gt; 자를 사용하여 인용 요소 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;&gt; &lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; &lt;/a&gt; ) 의 상위 항목을 일치시키는 데 사용됩니다 . 이것이 유일한 방법은 아니며, 사용하는 가장 좋은 방법은 문서 유형에 따라 다릅니다. 또한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Unicode&quot;&gt;유니 코드&lt;/a&gt; 값은 일부 특수 인용 문자를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="67b84670575007b19965bbed12d24ced7044daf6" translate="yes" xml:space="preserve">
          <source>In this example, the backdrop style used when a video is shifted to full-screen mode is configured to be a grey-blue color rather than the black it defaults to in most browsers.</source>
          <target state="translated">이 예에서 비디오가 전체 화면 모드로 전환 될 때 사용되는 배경 스타일은 대부분의 브라우저에서 기본적으로 검은 색이 아닌 회색-파랑 색상으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2197961de2034ce3a0acd9c847a7df7743ee0d" translate="yes" xml:space="preserve">
          <source>In this example, the color of a button is changed depending on whether or not the document is in full-screen mode. This is done without needing to specifically apply style changes using JavaScript.</source>
          <target state="translated">이 예제에서 단추의 색상은 문서가 전체 화면 모드인지 여부에 따라 변경됩니다. JavaScript를 사용하여 스타일 변경을 특별히 적용 할 필요없이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8341c52ecddd124038b8604cfb60f51198b3a52" translate="yes" xml:space="preserve">
          <source>In this example, the form will receive special coloring styles when either text input receives focus.</source>
          <target state="translated">이 예제에서 텍스트 입력에 포커스가 있으면 양식에 특수한 색상 스타일이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="52daa9f0b6c22fa9e5bbfda478480ec5f25ee560" translate="yes" xml:space="preserve">
          <source>In this example, the heading is made to span across all the columns of the article.</source>
          <target state="translated">이 예에서 제목은 기사의 모든 열에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e87d69d07c9c894c3034361bd808a593fb08c03" translate="yes" xml:space="preserve">
          <source>In this example, the logo will be 300px wide unless the viewport narrows below 600px, at which point it will shrink as the viewport shrinks, always being 50% of the width of the viewport.</source>
          <target state="translated">이 예제에서 뷰포트가 600px 아래로 좁히지 않으면 로고 너비는 300px가됩니다.이 시점에서 뷰포트가 줄어들면 축소되어 항상 뷰포트 너비의 50 %가됩니다.</target>
        </trans-unit>
        <trans-unit id="19067ce1f6eacc110bbdb0b34166b958fa154550" translate="yes" xml:space="preserve">
          <source>In this example, the logo will be at least 300px wide, but wider if the viewport grows above 600px, at which point it will grow as the viewport grows, always being 50% of the width of the viewport.</source>
          <target state="translated">이 예제에서 로고는 너비가 300px 이상이지만 뷰포트가 600px 이상으로 커지면 더 커집니다.이 시점에서 뷰포트가 커짐에 따라 로고가 커져 항상 뷰포트 너비의 50 %가됩니다.</target>
        </trans-unit>
        <trans-unit id="0426cb39d665012728355062616ab1b2be607897" translate="yes" xml:space="preserve">
          <source>In this example, the logo will be at least &lt;code&gt;100px&lt;/code&gt; wide on any viewport narrower than &lt;code&gt;400px&lt;/code&gt;, &lt;code&gt;300px&lt;/code&gt; on all viewports wider than &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;200px&lt;/code&gt;, and &lt;code&gt;40%&lt;/code&gt; of the width of the viewport on any viewport in between</source>
          <target state="translated">이 예에서 로고는 &lt;code&gt;400px&lt;/code&gt; 보다 좁은 모든 뷰포트에서 너비가 &lt;code&gt;100px&lt;/code&gt; 이상이고 , 사이의 모든 뷰포트에서 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;200px&lt;/code&gt; 및 모든 뷰포트 너비의 &lt;code&gt;40%&lt;/code&gt; 보다 넓은 모든 뷰포트 에서 &lt;code&gt;300px&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb05e2a3b5e7b79857fbb8ccc5703c7095cabe0e" translate="yes" xml:space="preserve">
          <source>In this example, the paragraph is statically positioned, so its containing block is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section&quot;&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/a&gt; because it's the nearest ancestor that is a block container.</source>
          <target state="translated">이 예에서 단락은 정적으로 배치되므로 포함하는 블록은 블록 컨테이너 인 가장 가까운 조상이므로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section&quot;&gt; &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="358e779fd1295cdbaaaa0e6445f5216451a0da40" translate="yes" xml:space="preserve">
          <source>In this example, the paragraph's &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;absolute&lt;/code&gt;, so its containing block is &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;, which is the nearest ancestor with a &lt;a href=&quot;transform&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; property that isn't &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 단락의 &lt;code&gt;position&lt;/code&gt; 는 &lt;code&gt;absolute&lt;/code&gt; 이므로 포함하는 블록은 &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; 이며 &lt;code&gt;none&lt;/code&gt; 이 아닌 &lt;a href=&quot;transform&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 속성을 가진 가장 가까운 조상입니다 .</target>
        </trans-unit>
        <trans-unit id="fda72dc80a09c48db182ec86df3ba5126b8b0dc2" translate="yes" xml:space="preserve">
          <source>In this example, the paragraph's &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;fixed&lt;/code&gt;, so its containing block is the initial containing block (on screens, the viewport). Thus, the paragraph's dimensions change based on the size of the browser window.</source>
          <target state="translated">이 예제에서는 단락의 &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;fixed&lt;/code&gt; 되어 포함 블록이 초기 포함 블록 (화면에서 뷰포트)입니다. 따라서 단락의 크기는 브라우저 창의 크기에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="f0758459123b42520a114217ed622ed76c466616" translate="yes" xml:space="preserve">
          <source>In this example, the paragraph's containing block is &lt;code&gt;&amp;lt;section&lt;/code&gt;&amp;gt; because the latter's &lt;code&gt;position&lt;/code&gt; is &lt;code&gt;absolute&lt;/code&gt;. The paragraph's percentage values are affected by the padding of its containing block, though if the containing block's &lt;a href=&quot;box-sizing&quot;&gt;&lt;code&gt;box-sizing&lt;/code&gt;&lt;/a&gt; value were &lt;code&gt;border-box&lt;/code&gt; this would not be the case.</source>
          <target state="translated">이 예제에서 단락의 포함 블록은 &lt;code&gt;&amp;lt;section&lt;/code&gt; &amp;gt;이므로 후자의 &lt;code&gt;position&lt;/code&gt; 는 &lt;code&gt;absolute&lt;/code&gt; 입니다. 단락의 백분율 값은 포함 블록의 패딩에 의해 영향을 받지만 포함 블록의 &lt;a href=&quot;box-sizing&quot;&gt; &lt;code&gt;box-sizing&lt;/code&gt; &lt;/a&gt; 값이 &lt;code&gt;border-box&lt;/code&gt; 경우에는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6fee04ab283dff0d4d2d7022c28ed42a91cea7d" translate="yes" xml:space="preserve">
          <source>In this example, the paragraph's containing block is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/a&gt;element, because &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; is not a block container (because of &lt;code&gt;display: inline&lt;/code&gt;) and doesn&amp;rsquo;t establish a formatting context.</source>
          <target state="translated">이 예에서 &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; 은 블록 컨테이너가 아니기 때문에 ( &lt;code&gt;display: inline&lt;/code&gt; ) 단락의 포함 블록은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt; &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 입니다. 서식 컨텍스트를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00395bb5a0aad2ed5d0d93720d17446961477403" translate="yes" xml:space="preserve">
          <source>In this example, the same text (the opening sentences from &lt;a href=&quot;https://en.wikipedia.org/wiki/Herman%20Melville&quot;&gt;Herman Melville's&lt;/a&gt; novel &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moby-Dick&quot;&gt;Moby-Dick&lt;/a&gt;&lt;/em&gt;) is presented in both the &lt;code&gt;horizontal-tb&lt;/code&gt; and &lt;code&gt;vertical-rl&lt;/code&gt; writing modes.</source>
          <target state="translated">이 예에서, 동일한 텍스트 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Herman%20Melville&quot;&gt;Herman Melville의&lt;/a&gt; 소설 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moby-Dick&quot;&gt;Moby-Dick&lt;/a&gt;&lt;/em&gt; 의 시작 문장 )가 &lt;code&gt;horizontal-tb&lt;/code&gt; 및 &lt;code&gt;vertical-rl&lt;/code&gt; 작성 모드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fc257e33a740fd90225680b0dd9f6c9ce4df0661" translate="yes" xml:space="preserve">
          <source>In this example, the user's local copy of &quot;Helvetica Neue Bold&quot; is used; if the user does not have that font installed (two different names are tried), then the downloadable font named &quot;MgOpenModernaBold.ttf&quot; is used instead:</source>
          <target state="translated">이 예에서는 사용자의 &quot;Helvetica Neue Bold&quot;로컬 사본이 사용됩니다. 사용자에게 해당 글꼴이 설치되어 있지 않은 경우 (두 가지 다른 이름으로 시도) &quot;MgOpenModernaBold.ttf&quot;라는 다운로드 가능한 글꼴이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b8ce626cc2282855c9a1b23f66e4e42cd674533" translate="yes" xml:space="preserve">
          <source>In this example, the words &amp;ldquo;outer inner outer&amp;rdquo; are all displayed at 16px (assuming that the browser's font-size has been left at the default value of 16px).</source>
          <target state="translated">이 예에서&amp;ldquo;outer inner outer&amp;rdquo;라는 단어는 모두 16px로 표시됩니다 (브라우저의 글꼴 크기가 기본값 16px 인 경우).</target>
        </trans-unit>
        <trans-unit id="295218d390251d7633be0ef73d699cd7d3e84cde" translate="yes" xml:space="preserve">
          <source>In this example, there are three colored squares. Two are floated left, and one is floated right. Note that the second &quot;left&quot; square is placed to the right of the first. Additional squares would continue to stack to the right, until they filled the containing box, after which they would wrap to the next line.</source>
          <target state="translated">이 예에는 세 개의 정사각형 사각형이 있습니다. 두 개는 왼쪽에 떠 있고, 하나는 오른쪽에 떠 있습니다. 두 번째 &quot;왼쪽&quot;사각형은 첫 번째의 오른쪽에 배치됩니다. 추가 사각형은 포함 상자를 채울 때까지 계속 오른쪽에 쌓여 다음 줄로 줄 바꿈됩니다.</target>
        </trans-unit>
        <trans-unit id="a28d8af3c68a1c92be8dd4fbaee92947feb9a524" translate="yes" xml:space="preserve">
          <source>In this example, three backgrounds are stacked: the Firefox logo, an image of bubbles, and a &lt;a href=&quot;../linear-gradient&quot;&gt;linear gradient&lt;/a&gt;:</source>
          <target state="translated">이 예에서는 Firefox 로고, 거품 이미지 및 &lt;a href=&quot;../linear-gradient&quot;&gt;선형 그라디언트의&lt;/a&gt; 세 가지 배경이 누적됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b612631dd720f9df9f69703fdb146edab4d97d6" translate="yes" xml:space="preserve">
          <source>In this example, three flex items are aligned on the main axis using &lt;a href=&quot;../justify-content&quot;&gt;&lt;code&gt;justify-content&lt;/code&gt;&lt;/a&gt; and on the cross axis using &lt;a href=&quot;../align-items&quot;&gt;&lt;code&gt;align-items&lt;/code&gt;&lt;/a&gt;. The first item overrides the &lt;code&gt;align-items&lt;/code&gt; values set on the group by setting &lt;a href=&quot;../align-self&quot;&gt;&lt;code&gt;align-self&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;center&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 3 개의 플렉스 항목이 &lt;a href=&quot;../justify-content&quot;&gt; &lt;code&gt;justify-content&lt;/code&gt; 를&lt;/a&gt; 사용하여 주축 과 &lt;a href=&quot;../align-items&quot;&gt; &lt;code&gt;align-items&lt;/code&gt; 를&lt;/a&gt; 사용하는 가로축에 정렬됩니다 . 첫 번째 항목은 &lt;a href=&quot;../align-self&quot;&gt; &lt;code&gt;align-self&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;center&lt;/code&gt; 로 설정하여 그룹에 설정된 정렬 &lt;code&gt;align-items&lt;/code&gt; 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="ede25712a221e9f3e81c4741468a909668b1354a" translate="yes" xml:space="preserve">
          <source>In this example, three flex items are aligned on the main axis using &lt;code&gt;justify-content&lt;/code&gt; and on the Cross Axis using &lt;code&gt;align-items&lt;/code&gt;. The first item overrides the &lt;code&gt;align-items&lt;/code&gt; set on the group by setting &lt;code&gt;align-self&lt;/code&gt; to &lt;code&gt;center&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 3 개의 플렉스 항목이 &lt;code&gt;justify-content&lt;/code&gt; 를 사용하여 주축 과 &lt;code&gt;align-items&lt;/code&gt; 를 사용 하는 횡축에 정렬됩니다 . 첫 번째 항목은 &lt;code&gt;align-self&lt;/code&gt; 를 &lt;code&gt;center&lt;/code&gt; 로 설정하여 그룹에 설정된 &lt;code&gt;align-items&lt;/code&gt; 항목보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="73cef6b867595ea0f2428f53018a77520d67621d" translate="yes" xml:space="preserve">
          <source>In this example, two boxes are created. One is positioned normally on the page, without being translated at all. The second is altered by applying perspective to create a 3D space, then moved towards the user.</source>
          <target state="translated">이 예에서는 두 개의 상자가 만들어집니다. 하나는 전혀 번역되지 않고 페이지에 정상적으로 배치됩니다. 두 번째는 원근을 적용하여 3D 공간을 만든 다음 사용자쪽으로 이동하여 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea023ee7b8a6bcc414e564c11ef78be2503a625" translate="yes" xml:space="preserve">
          <source>In this example, we have columns containing an image and some text which are balanced. The image cannot break and so goes into the first column and the other columns fill with equal amounts of text.</source>
          <target state="translated">이 예에서는 이미지가 포함 된 열과 균형이 맞춰진 일부 텍스트가 있습니다. 이미지는 깨질 수 없으므로 첫 번째 열로 들어가고 다른 열은 같은 양의 텍스트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="92b247df6056180dabadfba97684c24ee8e83d0a" translate="yes" xml:space="preserve">
          <source>In this example, we use the &lt;a href=&quot;@keyframes&quot;&gt;@keyframes&lt;/a&gt; at-rule to animate a clip path between two polygons. Note that both polygons have the same number of vertices, which is necessary for this type of animation to work.</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;@keyframes&quot;&gt;@keyframes&lt;/a&gt; at-rule을 사용하여 두 다각형 사이의 클립 경로에 애니메이션을 적용합니다. 두 폴리곤 모두 같은 수의 꼭짓점을 가지므로이 유형의 애니메이션이 작동하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="777f3175810329d16cd033d78fbd41134f7ba6c2" translate="yes" xml:space="preserve">
          <source>In this example, we will apply a diamond pattern to an element's borders. The source for the border image is a &quot;.png&quot; file of 81 by 81 pixels, with three diamonds going vertically and horizontally:</source>
          <target state="translated">이 예에서는 요소의 테두리에 다이아몬드 패턴을 적용합니다. 테두리 이미지의 소스는 81 x 81 픽셀의 &quot;.png&quot;파일이며 세 개의 다이아몬드가 세로 및 가로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7a04deca6ccf92f3977eaec49feb1e4bd24cc607" translate="yes" xml:space="preserve">
          <source>In this example, we will mask an element's border with a diamond pattern. The source for the mask is a &quot;.png&quot; file of 90 by 90 pixels, with three diamonds going vertically and horizontally:</source>
          <target state="translated">이 예에서는 요소의 테두리를 다이아몬드 패턴으로 마스킹합니다. 마스크의 소스는 90 x 90 픽셀의 &quot;.png&quot;파일이며 세 개의 다이아몬드가 세로 및 가로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="19f409b642b700a7741d515aa25cefb2eeb6a7a7" translate="yes" xml:space="preserve">
          <source>In this examples, the viewport has an aspect ratio of 3::4, and is, but default, 400 by 300 units, with a unit generally being a CSS pixel.</source>
          <target state="translated">이 예제에서 뷰포트의 종횡비는 3 :: 4이며 기본적으로 400 x 300 단위이며, 단위는 일반적으로 CSS 픽셀입니다.</target>
        </trans-unit>
        <trans-unit id="b124c77f342aef6fd7cc0b2dda62beaf76c60318" translate="yes" xml:space="preserve">
          <source>In this final example, we mix absolute sized tracks with fraction units. The first track is 500 pixels, so the fixed width is taken away from the available space. The remaining space is divided into three and assigned in proportion to the two flexible tracks.</source>
          <target state="translated">이 마지막 예에서는 절대 크기의 트랙을 분수 단위와 혼합합니다. 첫 번째 트랙은 500 픽셀이므로 고정 너비가 사용 가능한 공간에서 제거됩니다. 남은 공간은 3 개로 분할되고 2 개의 유연한 트랙에 비례하여 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef7c49d17356103c7444c86fc675c00aa420cac" translate="yes" xml:space="preserve">
          <source>In this first example, I am using flexbox to lay out a set of boxes. I have five child items in my container, and I have given the flex properties values so that they can grow and shrink from a flex-basis of 200 pixels.</source>
          <target state="translated">이 첫 번째 예에서는 flexbox를 사용하여 상자 세트를 배치합니다. 컨테이너에 5 개의 자식 항목이 있고 200 픽셀의 flex-basis에서 커지거나 줄어들 수 있도록 flex 속성 값을 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="f49c9edcd7ca34953a32c078aa06a5189be93756" translate="yes" xml:space="preserve">
          <source>In this first example, the paragraph with a class of secret is set to &lt;code&gt;display: none&lt;/code&gt;; the box and any content is now not rendered.</source>
          <target state="translated">이 첫 번째 예에서 비밀 클래스가있는 단락은 다음과 같이 &lt;code&gt;display: none&lt;/code&gt; ; 상자와 내용이 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2e642bc433d4b469dfd9c5fc854ff21ee02c332" translate="yes" xml:space="preserve">
          <source>In this first example, we have three animation names set, but only one duration and iteration count. In this case all three animations are given the same duration and iteration count:</source>
          <target state="translated">이 첫 번째 예에서는 세 개의 애니메이션 이름이 설정되었지만 지속 시간과 반복 횟수는 하나입니다. 이 경우 세 애니메이션 모두에 동일한 지속 시간과 반복 횟수가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b36ed6a0cf82c9b632e114b0b915e676377322" translate="yes" xml:space="preserve">
          <source>In this guide we have covered the ways to take an element out of flow in order to achieve some very specific types of positioning. In the next guide we will look at a related issue, that of creating a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context&quot;&gt;Block Formatting Context&lt;/a&gt;, in &lt;a href=&quot;formatting_contexts_explained&quot;&gt;Formatting Contexts Explained&lt;/a&gt;.</source>
          <target state="translated">이 가이드에서는 매우 구체적인 유형의 포지셔닝을 달성하기 위해 요소를 흐름에서 빠져 나가는 방법을 설명했습니다. 다음 가이드에서는 &lt;a href=&quot;formatting_contexts_explained&quot;&gt;컨텍스트 컨텍스트 설명&lt;/a&gt; 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context&quot;&gt;블록 형식 컨텍스트&lt;/a&gt; 생성과 관련된 문제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7fe79173b650cf6b15eaec92005b75ac0e5f6a6e" translate="yes" xml:space="preserve">
          <source>In this guide we have looked at how elements display in normal flow, as block and inline elements. Due to the default behaviour of these elements, an HTML document with no CSS styling at all, will display in a readable way. By understanding how normal flow works you will find layout easier, as you understand the starting point for making changes to how elements are displayed.</source>
          <target state="translated">이 가이드에서는 블록 및 인라인 요소로 요소가 정상적인 흐름으로 표시되는 방식을 살펴 보았습니다. 이러한 요소의 기본 동작으로 인해 CSS 스타일이 전혀없는 HTML 문서는 읽을 수있는 방식으로 표시됩니다. 일반적인 흐름의 작동 방식을 이해하면 요소가 표시되는 방식을 변경하기위한 시작점을 이해하므로 레이아웃이 더 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="560c7a80ac2b41b30443dc7f5d74375643fdb99d" translate="yes" xml:space="preserve">
          <source>In this guide we look at how multicol deals with overflow, both inside the column boxes and in situations where there is more content than will fit into the container.</source>
          <target state="translated">이 가이드에서는 컬럼 박스 내부와 컨테이너에 들어갈 수있는 것보다 더 많은 컨텐츠가있는 상황에서 멀티 콜이 오버 플로우를 처리하는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="9fa5834c0c36159dc4caa85e9c661a30c7034b10" translate="yes" xml:space="preserve">
          <source>In this guide we look at how to make elements span across columns inside the multicol container and how to control how the columns are filled.</source>
          <target state="translated">이 안내서에서는 요소를 멀티 콜 컨테이너 내부의 열에 걸쳐 배치하는 방법과 열이 채워지는 방법을 제어하는 ​​방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="ec81815788cdee36d0f63eb9f5a3de9611332cbf" translate="yes" xml:space="preserve">
          <source>In this guide we will be exploring the three properties that are applied to flex items, which enable us to control the size and flexibility of the items along the main axis &amp;mdash; &lt;a href=&quot;../flex-grow&quot;&gt;&lt;code&gt;flex-grow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../flex-shrink&quot;&gt;&lt;code&gt;flex-shrink&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../flex-basis&quot;&gt;&lt;code&gt;flex-basis&lt;/code&gt;&lt;/a&gt;. Fully understanding how these properties work with growing and shrinking items is the real key to mastering flexbox.</source>
          <target state="translated">이 가이드에서는 플렉스 아이템에 적용되는 3 가지 속성을 살펴보고, 주축을 따라 아이템의 크기와 유연성 ( &lt;a href=&quot;../flex-grow&quot;&gt; &lt;code&gt;flex-grow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../flex-shrink&quot;&gt; &lt;code&gt;flex-shrink&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../flex-basis&quot;&gt; &lt;code&gt;flex-basis&lt;/code&gt; )을 제어 할 수&lt;/a&gt; 있습니다. flexbox 마스터 링의 핵심은 이러한 속성이 아이템 증가 및 축소에서 어떻게 작동하는지 완전히 이해하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12eb90f1f2c4331abba2086bc3189f09e2b6956d" translate="yes" xml:space="preserve">
          <source>In this guide we will be working in English and therefore a horizontal writing mode. However everything described should work in the same way if your document is in a vertical writing mode.</source>
          <target state="translated">이 안내서에서는 영어로 작업하므로 가로 쓰기 모드를 사용합니다. 그러나 문서가 세로 쓰기 모드 인 경우 설명 된 모든 내용이 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7f190d19ff3b5dcb8edef3ce7639c3510d940c9a" translate="yes" xml:space="preserve">
          <source>In this guide we will explain the flow-relative mappings between physical dimension properties and logical properties used for sizing elements on our pages.</source>
          <target state="translated">이 안내서에서는 페이지의 요소 크기를 조정하는 데 사용되는 물리적 차원 속성과 논리적 속성 간의 흐름 기준 매핑에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8cd5400f2805da7d3a64aaf3cb577389c4279dd5" translate="yes" xml:space="preserve">
          <source>In this guide we will explore the basics of how Block and Inline elements behave when they are part of the normal flow.</source>
          <target state="translated">이 안내서에서는 Block 및 Inline 요소가 정상 흐름의 일부일 때 어떻게 작동하는지에 대한 기본 사항을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="b71d4177d3df1f5adbf75061c043edf60ae73820" translate="yes" xml:space="preserve">
          <source>In this guide we will take a look at how we can create a shape from an image file with an alpha channel or even from a CSS Gradient. This is a very flexible way to create shapes. Rather than drawing a path with a complex polygon in CSS, you can create the shape in a graphics program and then use the path created by the pixels less opaque than a threshold value.</source>
          <target state="translated">이 가이드에서는 알파 채널이있는 이미지 파일 또는 CSS 그라디언트에서 모양을 만드는 방법을 살펴 보겠습니다. 이것은 모양을 만드는 매우 유연한 방법입니다. CSS에서 복잡한 다각형으로 경로를 그리는 대신 그래픽 프로그램에서 모양을 만든 다음 임계 값보다 덜 불투명 한 픽셀로 만든 경로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf7243405852652880321cc5f32d9cd015253a87" translate="yes" xml:space="preserve">
          <source>In this guide we will take a look at some of the common use cases for flexbox &amp;mdash; those places where it makes more sense than another layout method.</source>
          <target state="translated">이 가이드에서는 flexbox의 일반적인 사용 사례 중 일부를 살펴 봅니다. 다른 레이아웃 방법보다 더 적합한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="c369434f0cbb80c77f28d00e5adb6638a40866d4" translate="yes" xml:space="preserve">
          <source>In this guide we've learned the basic use of Multiple-column Layout. In the next guide, we will look at how much we can &lt;a href=&quot;styling_columns&quot;&gt;style the columns themselves&lt;/a&gt;.</source>
          <target state="translated">이 안내서에서는 다중 열 레이아웃의 기본 사용법을 배웠습니다. 다음 가이드에서는 &lt;a href=&quot;styling_columns&quot;&gt;열 자체&lt;/a&gt; 를 얼마나 스타일링 할 수 있는지 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b084a1661072a060b83c6fe748fbe80cb49e4e55" translate="yes" xml:space="preserve">
          <source>In this guide, we have looked in more detail at the Block and Inline formatting contexts and the important subject of creating a Block Formatting Context (</source>
          <target state="translated">이 안내서에서는 블록 및 인라인 형식화 컨텍스트와 블록 형식화 컨텍스트 작성의 중요한 주제 (</target>
        </trans-unit>
        <trans-unit id="894ad065b880efb046399e4c581281e023d2cbfa" translate="yes" xml:space="preserve">
          <source>In this layout I am displaying the &lt;code&gt;nav&lt;/code&gt; in the left column, alongside the &lt;code&gt;content&lt;/code&gt;. In the right column we have the &lt;code&gt;sidebar&lt;/code&gt; and underneath it the advertisements (&lt;code&gt;ad&lt;/code&gt;). The &lt;code&gt;footer&lt;/code&gt; now spans right across the bottom of the layout. I then use a flexbox to display the navigation as a column.</source>
          <target state="translated">이 레이아웃에서는 왼쪽 열에 &lt;code&gt;nav&lt;/code&gt; 을 &lt;code&gt;content&lt;/code&gt; 와 함께 표시 합니다 . 오른쪽 열에는 &lt;code&gt;sidebar&lt;/code&gt; 있고 그 아래에 광고 ( &lt;code&gt;ad&lt;/code&gt; )가 있습니다. &lt;code&gt;footer&lt;/code&gt; 지금 당장 레이아웃의 하단에 걸쳐있다. 그런 다음 flexbox를 사용하여 탐색을 열로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8046361e162f8162328099254c9f3f90b369b465" translate="yes" xml:space="preserve">
          <source>In this live example, I have flex items arranged simply into a row with the basic flex values, and the class &lt;code&gt;push&lt;/code&gt; has &lt;code&gt;margin-left: auto&lt;/code&gt;. You can try removing this, or adding the class to another item to see how it works.</source>
          <target state="translated">이 라이브 예제에서는 기본 플렉스 값을 사용하여 플렉스 항목을 단순히 행으로 배열했으며 클래스 &lt;code&gt;push&lt;/code&gt; 에는 &lt;code&gt;margin-left: auto&lt;/code&gt; 있습니다. 이것을 제거하거나 클래스를 다른 항목에 추가하여 작동 방식을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="addbdbfa597bf4397a880f55afc7ee17461debaa" translate="yes" xml:space="preserve">
          <source>In this next example I am creating a grid with twelve equal width columns. Before defining the 1fr size of the column track I am also defining a line name of &lt;code&gt;[col-start]&lt;/code&gt;. This means that we will end up with a grid that has 12 column lines all named &lt;code&gt;col-start&lt;/code&gt; before a &lt;code&gt;1fr&lt;/code&gt; width column.</source>
          <target state="translated">이 다음 예제에서는 너비가 같은 열이 12 개인 그리드를 만듭니다. 열 트랙의 1fr 크기를 정의하기 전에 &lt;code&gt;[col-start]&lt;/code&gt; 줄 이름을 정의하고 있습니다. 이것은 &lt;code&gt;1fr&lt;/code&gt; 열이 모두 1fr 너비 열 보다 먼저 &lt;code&gt;col-start&lt;/code&gt; 인 그리드를 갖게됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="61ca2180fd3ba56a4f137be4481eff630b8a4004" translate="yes" xml:space="preserve">
          <source>In this next example I am using a radial gradient with an ellipse, once again using a transparent part of the gradient to create the shape.</source>
          <target state="translated">이 다음 예제에서는 타원과 함께 방사형 그래디언트를 사용하고, 다시 한 번 그라데이션의 투명한 부분을 사용하여 모양을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="50c428c107ed972dc1ac3c79b4dd54c29982843f" translate="yes" xml:space="preserve">
          <source>In this next example I have created a 5px dotted rule with a color of rebeccapurple, using the longhand values.</source>
          <target state="translated">이 다음 예에서는 긴 값을 사용하여 rebeccapurple 색상의 5px 점선 규칙을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="84f382cb59109f14176648fc3e38c1b8e7dcd683" translate="yes" xml:space="preserve">
          <source>In this next example I have created a grid with three row tracks of 200 pixels height. I am auto-placing by column and the columns created will be a column width of 300 pixels, then a column width of 100 pixels until there are enough column tracks to hold all of the items.</source>
          <target state="translated">이 다음 예제에서는 높이가 200 픽셀 인 3 개의 행 트랙이있는 그리드를 만들었습니다. 열을 기준으로 자동 배치하고 생성 된 열은 300 픽셀의 열 너비가되고 모든 항목을 담을 수있는 충분한 열 트랙이있을 때까지 100 픽셀의 열 너비가됩니다.</target>
        </trans-unit>
        <trans-unit id="6d58b7d65ac546b399afad6d9a6369a39d2e05b3" translate="yes" xml:space="preserve">
          <source>In this next example I have flipped the layout we were working with by working from the right and bottom of our grid when placing the items.</source>
          <target state="translated">다음 예제에서는 아이템을 배치 할 때 그리드의 오른쪽과 아래쪽에서 작업하여 레이아웃을 뒤집 었습니다.</target>
        </trans-unit>
        <trans-unit id="8c3c940264e268d6c31f9d0d0421f196b27ca1d4" translate="yes" xml:space="preserve">
          <source>In this next example I have items laid out with &lt;code&gt;flex-direction: row-reverse&lt;/code&gt; and &lt;code&gt;justify-content: flex-end&lt;/code&gt;. In a left to right language the items all line up on the left. Try changing &lt;code&gt;flex-direction: row-reverse&lt;/code&gt; to &lt;code&gt;flex-direction: row&lt;/code&gt;. You will see that the items now move to the right hand side.</source>
          <target state="translated">이 다음 예제에서는 &lt;code&gt;flex-direction: row-reverse&lt;/code&gt; 및 &lt;code&gt;justify-content: flex-end&lt;/code&gt; 있습니다. 왼쪽에서 오른쪽 언어로 항목이 모두 왼쪽에 정렬됩니다. &lt;code&gt;flex-direction: row-reverse&lt;/code&gt; 에서 &lt;code&gt;flex-direction: row&lt;/code&gt; 변경해보십시오 . 항목이 이제 오른쪽으로 이동하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7176a19349b289924a8d561434823becf5e83be" translate="yes" xml:space="preserve">
          <source>In this next example I have used generated content and floated this content, giving it a background image of a linear gradient. I am using that same value as the value of &lt;a href=&quot;../shape-outside&quot;&gt;&lt;code&gt;shape-outside&lt;/code&gt;&lt;/a&gt;. The linear gradient goes from purple to transparent, so by changing the value of &lt;a href=&quot;../shape-image-threshold&quot;&gt;&lt;code&gt;shape-image-threshold&lt;/code&gt;&lt;/a&gt; I can decide how transparent the pixels need to be that create my shape. You can play with that value in the example below to see how the diagonal line will move across the shape depending on that value.</source>
          <target state="translated">이 다음 예제에서는 생성 된 내용을 사용하고이 내용을 플로팅하여 선형 그래디언트의 배경 이미지를 제공했습니다. &lt;a href=&quot;../shape-outside&quot;&gt; &lt;code&gt;shape-outside&lt;/code&gt; &lt;/a&gt; 값과 동일한 값을 사용하고 있습니다. 선형 그라디언트는 자주색에서 투명으로 바뀌므로 &lt;a href=&quot;../shape-image-threshold&quot;&gt; &lt;code&gt;shape-image-threshold&lt;/code&gt; &lt;/a&gt; 값을 변경 하여 픽셀이 얼마나 투명해야 내 모양을 만들어야하는지 결정할 수 있습니다. 아래 예제에서 해당 값으로 재생하여 해당 값에 따라 대각선이 모양을 따라 어떻게 이동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef0b60b4ce51d12bccf1dd0dd58eaaeb0bf7a19" translate="yes" xml:space="preserve">
          <source>In this next example we have a very wide rule of 40px and a 10px gap. The rule displays under the content of the columns. In order to make space on both sides of the rule, the gap would need to be increased to be larger than 40px.</source>
          <target state="translated">이 다음 예에서는 40px의 매우 넓은 규칙과 10px 간격이 있습니다. 규칙은 열의 내용 아래에 표시됩니다. 규칙의 양쪽에 공간을 확보하려면 간격을 40px보다 크게 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="38b59d890e7f4e3765ec4193e94861b8a5cff7e3" translate="yes" xml:space="preserve">
          <source>In this next example we use &lt;code&gt;column-width&lt;/code&gt; of 200px and &lt;code&gt;column-count&lt;/code&gt; of 2. Even if there is space for more than two columns, we get two. If there is not enough space for two columns of 200px, however, we get one.</source>
          <target state="translated">이 다음 예에서는 &lt;code&gt;column-width&lt;/code&gt; 200px와 &lt;code&gt;column-count&lt;/code&gt; 2를 사용합니다. 둘 이상의 열을위한 공간이 있어도 두 개를 얻습니다. 그러나 200px의 두 열에 충분한 공간이 없으면 하나를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4f42d4d64c1b28b794e56de37696221800d17844" translate="yes" xml:space="preserve">
          <source>In this next example, I am using alignment to align items inside a grid that is set to &lt;code&gt;writing-mode: vertical-lr&lt;/code&gt;. The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; properties work in exactly the same way that they do in the default writing mode, and remain logical in a way that using left and right, top and bottom to align items would not do. This occurs once we've flipped the grid onto the side, like this:</source>
          <target state="translated">이 다음 예제에서는 alignment를 사용하여 &lt;code&gt;writing-mode: vertical-lr&lt;/code&gt; 설정된 그리드 내부의 항목을 정렬 합니다 . &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 속성은 기본 쓰기 모드에서 수행하는 것이 정확히 같은 방식으로 작동하고, 왼쪽 사용하고 오른쪽 정렬 항목에 상단과 하단이 할 것이라고 방식으로 논리적 남아있다. 다음과 같이 그리드를 측면으로 뒤집었을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6435f01bf3294973dceb380e2ad6fb153badcdd3" translate="yes" xml:space="preserve">
          <source>In this next example, I am using the &lt;code&gt;align-self&lt;/code&gt; property, to demonstrate the different alignment values. The first area, is showing the default behavior of &lt;code&gt;align-self&lt;/code&gt;, which is to stretch. The second item, has an &lt;code&gt;align-self&lt;/code&gt; value of &lt;code&gt;start&lt;/code&gt;, the third &lt;code&gt;end&lt;/code&gt; and the fourth &lt;code&gt;center&lt;/code&gt;.</source>
          <target state="translated">이 다음 예에서는 다른 정렬 값을 보여주기 &lt;code&gt;align-self&lt;/code&gt; 속성을 사용하고 있습니다. 첫 번째 영역은 &lt;code&gt;align-self&lt;/code&gt; 의 기본 동작을 보여줍니다 . 두 번째 항목 은 &lt;code&gt;start&lt;/code&gt; &lt;code&gt;align-self&lt;/code&gt; 값 , 세 번째 &lt;code&gt;end&lt;/code&gt; 및 네 번째 &lt;code&gt;center&lt;/code&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="450ec4b74d7ec30835341870892187b70349cf41" translate="yes" xml:space="preserve">
          <source>In this next example, I create the same layout using Grid. This time we have three &lt;code&gt;1fr&lt;/code&gt; column tracks. We do not need to set anything on the items themselves; they will lay themselves out one into each cell of the created grid. As you can see they stay in a strict grid, lining up in rows and columns. With five items, we get a gap on the end of row two.</source>
          <target state="translated">이 다음 예제에서는 Grid를 사용하여 동일한 레이아웃을 만듭니다. 이번에는 3 개의 &lt;code&gt;1fr&lt;/code&gt; 열 트랙이 있습니다. 항목 자체에 아무것도 설정할 필요가 없습니다. 생성 된 그리드의 각 셀에 하나씩 배치됩니다. 보시다시피 행과 열로 늘어선 엄격한 그리드에 있습니다. 5 개의 품목으로 2 행의 끝에 공백이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="2d86041f429ab39cc1d54ca1412fb533b6c2c23b" translate="yes" xml:space="preserve">
          <source>In this next example, I have a grid which is in the default &lt;code&gt;ltr&lt;/code&gt; direction. I have positioned three items using line-based placement.</source>
          <target state="translated">이 다음 예에서는 기본 &lt;code&gt;ltr&lt;/code&gt; 방향 의 그리드가 있습니다. 라인 기반 게재 위치를 사용하여 3 개의 항목을 배치했습니다.</target>
        </trans-unit>
        <trans-unit id="76fe79de294799d84a377ed9f0bd87108d4e5530" translate="yes" xml:space="preserve">
          <source>In this next example, I have a set of floated cards. I have given the cards a &lt;a href=&quot;../width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt;, in order to &lt;a href=&quot;../float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; them. To create gaps between the cards, I use a &lt;a href=&quot;../margin&quot;&gt;&lt;code&gt;margin&lt;/code&gt;&lt;/a&gt; on the items, and then a negative margin on the container:</source>
          <target state="translated">이 다음 예에서는 플로트 카드 세트가 있습니다. &lt;a href=&quot;../float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 하기 위해 카드에 &lt;a href=&quot;../width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 지정 했습니다. 카드 사이에 틈을 만들려면, 내가 사용하는 &lt;a href=&quot;../margin&quot;&gt; &lt;code&gt;margin&lt;/code&gt; &lt;/a&gt; 컨테이너에 다음 음의 여백을 항목에, 그리고 :</target>
        </trans-unit>
        <trans-unit id="8a41af96fa439594a9c9a2f227cd2e749f6b63f9" translate="yes" xml:space="preserve">
          <source>In this next example, I have given item 1 a left margin of &lt;code&gt;auto&lt;/code&gt;. You can see how the content is now pushed over to the right side of the area, as the auto margin takes up remaining space, after room for the content of that item has been assigned:</source>
          <target state="translated">이 다음 예에서는 항목 1에 왼쪽 여백 &lt;code&gt;auto&lt;/code&gt; 를 지정했습니다 . 해당 항목의 컨텐츠를위한 공간이 지정된 후 자동 여백이 남은 공간을 차지하므로 컨텐츠가 영역의 오른쪽으로 어떻게 푸시되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f30ed07e3cd3c843396e46c62fbe2a02a25efb" translate="yes" xml:space="preserve">
          <source>In this next example, I have used the &lt;code&gt;auto-fill&lt;/code&gt; keyword in place of an integer in the repeat notation and set the track listing to 200 pixels. This means that grid will create as many 200 pixels column tracks as will fit in the container.</source>
          <target state="translated">다음 예제에서는 반복 표기법에서 정수 대신 &lt;code&gt;auto-fill&lt;/code&gt; 키워드를 사용하여 트랙 목록을 200 픽셀로 설정했습니다. 즉, 그리드는 컨테이너에 맞는만큼 200 픽셀의 열 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a2982be72f345f765fed413ddc83804876ee1a78" translate="yes" xml:space="preserve">
          <source>In this next example, we are forcing a column break before an &lt;code&gt;h2&lt;/code&gt; element.</source>
          <target state="translated">이 다음 예에서는 &lt;code&gt;h2&lt;/code&gt; 요소 앞에 열 구분을 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="652ad4cb93ddfd0600d6d3e03a2888739cf6e8c6" translate="yes" xml:space="preserve">
          <source>In this next example, we create a definition with a &lt;code&gt;2fr&lt;/code&gt; track then two &lt;code&gt;1fr&lt;/code&gt; tracks. The available space is split into four. Two parts are given to the first track and one part each to the next two tracks.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;2fr&lt;/code&gt; 트랙 과 두 개의 &lt;code&gt;1fr&lt;/code&gt; 트랙 으로 정의를 만듭니다 . 사용 가능한 공간이 4 개로 분할됩니다. 첫 번째 트랙에는 두 부분이, 다음 두 트랙에는 각각 한 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="024e9bf3836151e6e4ed4624c52d548406522b62" translate="yes" xml:space="preserve">
          <source>In this next example, we have an image with a fully transparent area, and we are using an image as the URL value for &lt;code&gt;shape-outside&lt;/code&gt;. The shape is created around the opaque area &amp;mdash; the image of the balloon.</source>
          <target state="translated">다음 예제에서는 완전히 투명한 영역의 이미지가 있으며 &lt;code&gt;shape-outside&lt;/code&gt; 의 URL 값으로 이미지를 사용합니다 . 모양은 불투명 한 영역 (풍선의 이미지) 주위에 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="a28e814ceebfac81c29dcbeb9d6fa5abc42215c4" translate="yes" xml:space="preserve">
          <source>In this next example, we use generated content to insert an element with height and width of 150px. We can then use Basic Shapes, Box Values or even the Alpha Channel of an image to create a shape for the text to wrap around.</source>
          <target state="translated">다음 예제에서는 생성 된 내용을 사용하여 높이와 너비가 150px 인 요소를 삽입합니다. 그런 다음 기본 도형, 상자 값 또는 이미지의 알파 채널을 사용하여 텍스트를 감싸는 도형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1cc1033f6ec4105d2b88f1d9d6a23e1af2ba4a" translate="yes" xml:space="preserve">
          <source>In this next live example the child elements have been floated, and then their container has had &lt;code&gt;display: flex&lt;/code&gt; added. If you remove &lt;code&gt;display: flex&lt;/code&gt;, you should see that the &lt;code&gt;.box&lt;/code&gt; element collapses as we have no clearing applied. This demonstrates that the float is happening. Re-apply &lt;code&gt;display: flex&lt;/code&gt; and the collapsing does not happen. This is because the items no longer have a float applied, as they have been transformed into flex items.</source>
          <target state="translated">이 다음 라이브 예제에서 자식 요소가 플로팅 된 다음 해당 컨테이너에 &lt;code&gt;display: flex&lt;/code&gt; 추가되었습니다. &lt;code&gt;display: flex&lt;/code&gt; 를 제거 하면 클리어링이 적용되지 않아 &lt;code&gt;.box&lt;/code&gt; 요소가 축소되는 것을 볼 수 있습니다. 이것은 플로트가 발생하고 있음을 보여줍니다. 다시 적용 &lt;code&gt;display: flex&lt;/code&gt; 및 축소가 발생하지 않습니다. 이는 아이템이 플렉스 아이템으로 변형되어 더 이상 부동이 적용되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="df9917d9090b46b26b776cd3f47fb9058e7fbcf2" translate="yes" xml:space="preserve">
          <source>In this next live example, the flex container has &lt;code&gt;align-items: flex-start&lt;/code&gt;, which means the items are all aligned to the start of the cross axis. I have targeted the first item using a &lt;code&gt;first-child&lt;/code&gt; selector and set that item to &lt;code&gt;align-items: stretch&lt;/code&gt;; another item has been selected using its class of &lt;code&gt;selected&lt;/code&gt; and given &lt;code&gt;align-self: center&lt;/code&gt;. You can change the value of &lt;code&gt;align-items&lt;/code&gt; or change the values of &lt;code&gt;align-self&lt;/code&gt; on the individual items to see how this works.</source>
          <target state="translated">다음 라이브 예제에서 플렉스 컨테이너에는 &lt;code&gt;align-items: flex-start&lt;/code&gt; 가 있습니다. 즉, 항목이 모두 교차 축의 시작에 정렬됩니다. &lt;code&gt;first-child&lt;/code&gt; 선택기를 사용하여 첫 번째 항목을 타겟팅하고 해당 항목을 &lt;code&gt;align-items: stretch&lt;/code&gt; 항목으로 설정했습니다 . stretch ; &lt;code&gt;selected&lt;/code&gt; 되고 주어진 &lt;code&gt;align-self: center&lt;/code&gt; 클래스를 사용하여 다른 항목이 선택되었습니다 : center . 당신의 가치 변경할 수 &lt;code&gt;align-items&lt;/code&gt; 또는 값 변경 &lt;code&gt;align-self&lt;/code&gt; 어떻게 작품을 볼 수있는 개별 항목에.</target>
        </trans-unit>
        <trans-unit id="e25e4cff8bc1de15a7b6a4d9f9db4052bf34ad22" translate="yes" xml:space="preserve">
          <source>In this second example, the heading is inside an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/a&gt; element, yet still spans the content as expected.</source>
          <target state="translated">이 두 번째 예에서 제목은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt; &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 안에 있지만 여전히 예상대로 내용에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d95b80d739ad38b15e1a3fdeb90791ffa94270" translate="yes" xml:space="preserve">
          <source>In this second example, we have three values set on all three properties. In this case each animation is run with the corresponding values in the same position on each property, so for example &lt;code&gt;fadeInOut&lt;/code&gt; has a duration of 2.5s and an iteration count of 2, etc.</source>
          <target state="translated">이 두 번째 예에서는 세 가지 속성 모두에 세 개의 값이 설정되어 있습니다. 이 경우 각 애니메이션은 각 속성에서 동일한 위치에 해당 값으로 실행되므로 예를 들어 &lt;code&gt;fadeInOut&lt;/code&gt; 의 지속 시간은 2.5 초 이고 반복 횟수는 2입니다.</target>
        </trans-unit>
        <trans-unit id="6624c485007896db525d492a296809c5e3526552" translate="yes" xml:space="preserve">
          <source>In this section we'll demonstrate the five registered axes defined with examples and the corresponding CSS. Where possible, both the standard and lower-level syntax are included. The lower-level syntax (&lt;a href=&quot;../font-variation-settings&quot;&gt;&lt;code&gt;font-variation-settings&lt;/code&gt;&lt;/a&gt;) was the first mechanism implemented in order to test the early implementations of variable font support, and is necessary to utilize new or custom axes beyond the five registered ones. However, the W3C&amp;rsquo;s intent was for this syntax not to be used when other attributes are available. Therefore wherever possible, the appropriate property should be used, with the lower-level syntax of &lt;code&gt;font-variation-settings&lt;/code&gt; only being used to set values or axes not available otherwise.</source>
          <target state="translated">이 섹션에서는 예제와 해당 CSS로 정의 된 5 개의 등록 된 축을 보여줍니다. 가능하면 표준 구문과 하위 구문이 모두 포함됩니다. 하위 수준 구문 ( &lt;a href=&quot;../font-variation-settings&quot;&gt; &lt;code&gt;font-variation-settings&lt;/code&gt; &lt;/a&gt; )은 가변 글꼴 지원의 초기 구현을 테스트하기 위해 구현 된 첫 번째 메커니즘이며 5 개의 등록 된 축을 넘어 새로운 축 또는 사용자 지정 축을 사용해야합니다. 그러나 W3C의 의도는 다른 속성을 사용할 수있을 때이 구문을 사용하지 않는 것입니다. 따라서 가능한 경우 적절한 속성을 사용해야하며 &lt;code&gt;font-variation-settings&lt;/code&gt; 의 하위 수준 구문은 다른 방법으로는 사용할 수없는 값이나 축을 설정하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7643a56f4d1bf32ce6e36a0cfa039989c44fb487" translate="yes" xml:space="preserve">
          <source>In this simple example, we demonstrate that using the &lt;code&gt;:scope&lt;/code&gt; pseudo-class from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/matches&quot;&gt;&lt;code&gt;Element.matches()&lt;/code&gt;&lt;/a&gt; method matches the element on which it's called.</source>
          <target state="translated">이 간단한 예제에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/matches&quot;&gt; &lt;code&gt;Element.matches()&lt;/code&gt; &lt;/a&gt; 메서드 에서 &lt;code&gt;:scope&lt;/code&gt; pseudo-class를 사용하여 해당 요소가 호출 된 요소와 일치 함을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cb5270cde51b1b7c90a7293f0f1fae6909d66d23" translate="yes" xml:space="preserve">
          <source>In this situation, the content should visibly overflow into the next column, rather than be clipped by the column box. You can see an example of this below, with an image of the expected rendering as, at the time of writing, browsers deal with this differently.</source>
          <target state="translated">이 경우 열 상자에 의해 잘리지 않고 내용이 다음 열로 표시됩니다. 글을 쓰는 시점에 브라우저가 다르게 처리 할 때 예상 렌더링 이미지를 사용하여 아래 예제를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72973ef63e6a9ff00825c45420d00819b46d36c2" translate="yes" xml:space="preserve">
          <source>In this third case, there are three animations specified, but only two durations and interation counts. In such cases where there are not enough values to give a separate value to each animation, the values cycle from start to finish. So for example, fadeInOut gets a duration of 2.5s and moveLeft300px gets a duration of 5s. We&amp;rsquo;ve now got to the end of the available duration values, so we start from the beginning again &amp;mdash; bounce therefore gets a duration of 2.5s. The iteration counts (and any other property values you specify) will be assigned in the same way.</source>
          <target state="translated">이 세 번째 경우에는 세 개의 애니메이션이 지정되지만 두 개의 지속 시간과 간섭 횟수 만 있습니다. 각 애니메이션에 별도의 값을 제공하기에 값이 충분하지 않은 경우 값이 처음부터 끝까지 순환합니다. 예를 들어 fadeInOut의 지속 시간은 2.5 초이고 moveLeft300px의 지속 시간은 5 초입니다. 이제 사용 가능한 지속 시간 값이 끝났으므로 처음부터 다시 시작합니다. 따라서 바운스의 지속 시간은 2.5 초입니다. 반복 횟수 (및 지정한 다른 속성 값)는 동일한 방식으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="2558fd823931a54dbf0a6e55ef3f9f9b05daeb01" translate="yes" xml:space="preserve">
          <source>In typography, a &lt;em&gt;widow&lt;/em&gt; is the last line of a paragraph that appears alone at the top of a page. (The paragraph is continued from a prior page.)</source>
          <target state="translated">타이포그래피에서 &lt;em&gt;미망인&lt;/em&gt; 은 페이지 상단에 혼자 나타나는 단락의 마지막 줄입니다. (이 단락은 이전 페이지에서 계속됩니다.)</target>
        </trans-unit>
        <trans-unit id="57356f30745af0f8d99353ba3973ba7d71d35d87" translate="yes" xml:space="preserve">
          <source>In typography, an &lt;em&gt;orphan&lt;/em&gt; is the first line of a paragraph that appears alone at the bottom of a page. (The paragraph continues on a following page.)</source>
          <target state="translated">활판 인쇄에서 &lt;em&gt;고아&lt;/em&gt; 는 페이지 맨 아래에 단독으로 나타나는 단락의 첫 줄입니다. (이 단락은 다음 페이지에서 계속됩니다.)</target>
        </trans-unit>
        <trans-unit id="a1295125878ef2e3696c6d7a9913982915a23505" translate="yes" xml:space="preserve">
          <source>In use, flex-grow is used alongside the other flex properties &lt;a href=&quot;flex-shrink&quot;&gt;&lt;code&gt;flex-shrink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;flex-basis&quot;&gt;&lt;code&gt;flex-basis&lt;/code&gt;&lt;/a&gt;, and normally defined using the &lt;a href=&quot;flex&quot;&gt;&lt;code&gt;flex&lt;/code&gt;&lt;/a&gt; shorthand to ensure all values are set.</source>
          <target state="translated">사용시, flex-grow는 다른 flex 속성 인 &lt;a href=&quot;flex-shrink&quot;&gt; &lt;code&gt;flex-shrink&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;flex-basis&quot;&gt; &lt;code&gt;flex-basis&lt;/code&gt; &lt;/a&gt; 와 함께 사용 되며 일반적으로 모든 값이 설정되도록 &lt;a href=&quot;flex&quot;&gt; &lt;code&gt;flex&lt;/code&gt; &lt;/a&gt; 속기를 사용하여 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4a629f4456cd1b3f3422b572f5e8f5978be5bf6" translate="yes" xml:space="preserve">
          <source>In user stylesheets, &lt;code&gt;revert&lt;/code&gt; rolls back the cascade and resets the property to the default value established by the user-agent stylesheet.</source>
          <target state="translated">사용자 스타일 시트에서 &lt;code&gt;revert&lt;/code&gt; 는 캐스케이드를 롤백하고 특성을 사용자 에이전트 스타일 시트가 설정 한 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="68377b80ba8bfb68806ed369db4e328abe103006" translate="yes" xml:space="preserve">
          <source>In vertical layout, text lines are rotated 90&amp;deg; clockwise. Images are not rotated, but tables are. Box layout in vertical orientations is exactly analogous to layout in the horizontal orientation: width, height, top, bottom, right, and left do not rotate with the text.</source>
          <target state="translated">세로 레이아웃에서 텍스트 줄은 시계 방향으로 90 &amp;deg; 회전합니다. 이미지는 회전되지 않지만 테이블은 회전합니다. 세로 방향의 상자 레이아웃은 가로 방향의 레이아웃과 정확히 유사합니다. 너비, 높이, 위, 아래, 오른쪽 및 왼쪽은 텍스트와 함께 회전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f12aabf30c3d809090191dde68b2d0d96217924c" translate="yes" xml:space="preserve">
          <source>In vertical writing-modes, this keyword forces the line to be placed on the &lt;em&gt;left&lt;/em&gt; side of the text. In horizontal writing-modes, it is a synonym of &lt;code&gt;under&lt;/code&gt;.</source>
          <target state="translated">세로 쓰기 모드에서이 키워드는 줄을 텍스트 의 &lt;em&gt;왼쪽에&lt;/em&gt; 배치 합니다. 가로 쓰기 모드에서,의 동의어 &lt;code&gt;under&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5df5480fc9a3cd8df5cf523f4865d4069f3e6da6" translate="yes" xml:space="preserve">
          <source>In vertical writing-modes, this keyword forces the line to be placed on the &lt;em&gt;right&lt;/em&gt; side of the text. In horizontal writing-modes, it is a synonym of &lt;code&gt;under&lt;/code&gt;.</source>
          <target state="translated">세로 쓰기 모드에서이 키워드는 줄을 텍스트 의 &lt;em&gt;오른쪽에&lt;/em&gt; 배치 합니다. 가로 쓰기 모드에서,의 동의어 &lt;code&gt;under&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d68d98e7c75afd61a627f9009b0121168ba678d" translate="yes" xml:space="preserve">
          <source>Inactive window border.</source>
          <target state="translated">비활성 창 테두리.</target>
        </trans-unit>
        <trans-unit id="a5813b4444dc1ad919c3de626ebee7feed7784a9" translate="yes" xml:space="preserve">
          <source>Inactive window caption. Should be used with the &lt;code&gt;InactiveCaptionText&lt;/code&gt; foreground color.</source>
          <target state="translated">비활성 창 캡션. &lt;code&gt;InactiveCaptionText&lt;/code&gt; 전경색 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8089934e3733c88ac43f87dabb6ec967b17cd302" translate="yes" xml:space="preserve">
          <source>InactiveBorder</source>
          <target state="translated">InactiveBorder</target>
        </trans-unit>
        <trans-unit id="1cf6c7454a5d75134c833f285e60fd42cb8b53a2" translate="yes" xml:space="preserve">
          <source>InactiveCaption</source>
          <target state="translated">InactiveCaption</target>
        </trans-unit>
        <trans-unit id="818983c6c3bd9ae531425923d7d5fd8b144880d4" translate="yes" xml:space="preserve">
          <source>InactiveCaptionText</source>
          <target state="translated">InactiveCaptionText</target>
        </trans-unit>
        <trans-unit id="c6aac808c0fe6cf21264c2eae13373e7440d5e53" translate="yes" xml:space="preserve">
          <source>Included in the CSS standard are several functions that achieve predefined effects. You can also reference an SVG filter with a URL to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter&quot;&gt;SVG filter element&lt;/a&gt;.</source>
          <target state="translated">CSS 표준에는 사전 정의 된 효과를 달성하는 여러 기능이 포함되어 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter&quot;&gt;SVG 필터 요소에&lt;/a&gt; 대한 URL이 포함 된 SVG 필터 를 참조 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3c3a5240fd9c1b5943662f3e39aaacd6293c66" translate="yes" xml:space="preserve">
          <source>Including a custom property as a fallback, as seen in the second example above, is the correct way to provide more than one fallback. The technique has been seen to cause performance issues as it takes more time to parse through the variables.</source>
          <target state="translated">위의 두 번째 예에서 볼 수 있듯이 사용자 지정 속성을 대체로 포함하는 것은 하나 이상의 대체를 제공하는 올바른 방법입니다. 이 기술은 변수를 구문 분석하는 데 더 많은 시간이 걸리므로 성능 문제를 일으키는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="fd0c217bfb6ea4be2c8fd5ef4aa8bbe7717d5817" translate="yes" xml:space="preserve">
          <source>Increases or decreases the image's contrast.</source>
          <target state="translated">이미지의 대비를 증가 또는 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e888817533e00da62ae38d09764b77ce9f7434" translate="yes" xml:space="preserve">
          <source>Indentation affects the first line of the block container as well as each line after a &lt;em&gt;forced line break&lt;/em&gt;, but does not affect lines after a &lt;em&gt;soft wrap break&lt;/em&gt;.</source>
          <target state="translated">들여 쓰기는 블록 컨테이너의 첫 번째 줄과 &lt;em&gt;강제 줄 바꿈&lt;/em&gt; 후 각 줄에 영향을 주지만, &lt;em&gt;소프트&lt;/em&gt; 줄 &lt;em&gt;바꿈&lt;/em&gt; 후 줄에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="093bf9ec6dd856df64bcfd74b77986603f15a122" translate="yes" xml:space="preserve">
          <source>Indentation is a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; of the containing block's width.</source>
          <target state="translated">들여 쓰기는 포함하는 블록 너비의 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30b44b23c3d597c381e474b494b2972b81af9d59" translate="yes" xml:space="preserve">
          <source>Indentation is specified as an absolute &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt;. Negative values are allowed. See &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; values for possible units.</source>
          <target state="translated">들여 쓰기는 절대 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 지정됩니다 . 음수 값이 허용됩니다. 가능한 단위는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 값을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fd2f19eefd456f70d1414221221bcdeb9e87aca" translate="yes" xml:space="preserve">
          <source>Indenting It Twice</source>
          <target state="translated">들여 쓰기 두 번</target>
        </trans-unit>
        <trans-unit id="91ef53c4f9517bb3c703e7f413fb0ba43d954064" translate="yes" xml:space="preserve">
          <source>Index of standard pseudo-classes</source>
          <target state="translated">표준 의사 클래스의 색인</target>
        </trans-unit>
        <trans-unit id="f6204307052013e66ad5d83ee92b09aad581a70d" translate="yes" xml:space="preserve">
          <source>Index of standard pseudo-elements</source>
          <target state="translated">표준 의사 요소의 색인</target>
        </trans-unit>
        <trans-unit id="84a0c33fd26b877b3c88e9990f4c17f8d1ab926b" translate="yes" xml:space="preserve">
          <source>Indicates automatic sizing, based on the flex item&amp;rsquo;s content.</source>
          <target state="translated">플렉스 항목의 내용에 따라 자동 크기 조정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="06b7e02e457885aff182a02497b250067b0fce96" translate="yes" xml:space="preserve">
          <source>Indicates that all containment rules are applied to the element. This is equivalent to &lt;code&gt;contain: size layout style paint&lt;/code&gt;.</source>
          <target state="translated">모든 포함 규칙이 요소에 적용됨을 나타냅니다. &lt;code&gt;contain: size layout style paint&lt;/code&gt; 를 포함 하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6ad4208a44b4fcf08762676713c51991bdb741f8" translate="yes" xml:space="preserve">
          <source>Indicates that all containment rules except size are applied to the element. This is equivalent to &lt;code&gt;contain: layout style paint&lt;/code&gt;.</source>
          <target state="translated">크기를 제외한 모든 포함 규칙이 요소에 적용됨을 나타냅니다. 이것은 &lt;code&gt;contain: layout style paint&lt;/code&gt; 를 포함 하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="76c967548165c52b6714b82006908a02a0eec5ce" translate="yes" xml:space="preserve">
          <source>Indicates that descendants of the element don't display outside its bounds. If an element is off-screen or otherwise not visible, its descendants are also guaranteed to not be visible.</source>
          <target state="translated">요소의 하위 항목이 경계 외부에 표시되지 않음을 나타냅니다. 요소가 화면 외부에 있거나 표시되지 않으면 해당 하위 요소도 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9992dd4ebf40c2133057f97bed4903e88f20514" translate="yes" xml:space="preserve">
          <source>Indicates that hyphenation is not limited based on the number of consecutive hyphenated lines. In the flow above the consecutive hyphenated lines limit would be an infinitely large positive number.</source>
          <target state="translated">하이픈이 연속 하이픈 줄 수에 따라 제한되지 않음을 나타냅니다. 연속적인 하이픈이있는 라인 위의 흐름에서 무한히 큰 양수입니다.</target>
        </trans-unit>
        <trans-unit id="7af515e5ff5e0048ca2802888ef41138e63bd912" translate="yes" xml:space="preserve">
          <source>Indicates that no perspective transform is to be applied.</source>
          <target state="translated">원근 변환이 적용되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04ef9fb75a3714493eee24701fb447034362686f" translate="yes" xml:space="preserve">
          <source>Indicates that nothing outside the element may affect its internal layout and vice versa.</source>
          <target state="translated">요소 외부의 아무것도 내부 레이아웃에 영향을 줄 수 있으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0d87d74e4af4b0f82017bad2520c93e6278d23bd" translate="yes" xml:space="preserve">
          <source>Indicates that the author expects to animate or change something about the element&amp;rsquo;s contents in the near future.</source>
          <target state="translated">저자가 가까운 미래에 요소의 내용에 대해 애니메이션을 적용하거나 변경할 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d21f995e0e60859e2e4e5d259a4e2d08a471ac6" translate="yes" xml:space="preserve">
          <source>Indicates that the author expects to animate or change the property with the given name on the element in the near future. If the property given is a shorthand, it indicates the expectation for all the longhands the shorthand expands to. It cannot be one of the following values: &lt;code&gt;unset&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt;, &lt;code&gt;inherit&lt;/code&gt;, &lt;code&gt;will-change&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;scroll-position&lt;/code&gt;, or &lt;code&gt;contents&lt;/code&gt;. The spec doesn't define the behavior of particular value, but it is common for &lt;code&gt;transform&lt;/code&gt; to be a compositing layer hint. &lt;a href=&quot;https://github.com/operasoftware/devopera/pull/330&quot;&gt;Chrome currently takes two actions&lt;/a&gt;, given particular CSS property idents: establish a new compositing layer or a new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/stacking_context&quot;&gt;stacking context&lt;/a&gt;.</source>
          <target state="translated">작성자가 가까운 시일 내에 요소에서 지정된 이름으로 속성을 애니메이션하거나 변경하려고 함을 나타냅니다. 주어진 속성이 속기 인 경우, 속기가 확장되는 모든 Longhands에 대한 기대를 나타냅니다. &lt;code&gt;unset&lt;/code&gt; , &lt;code&gt;initial&lt;/code&gt; , &lt;code&gt;inherit&lt;/code&gt; , &lt;code&gt;will-change&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;scroll-position&lt;/code&gt; 또는 &lt;code&gt;contents&lt;/code&gt; 값 중 하나 일 수 없습니다 . 스펙은 특정 값의 동작을 정의하지 않지만 &lt;code&gt;transform&lt;/code&gt; 이 합성 레이어 힌트 인 것이 일반적입니다 . &lt;a href=&quot;https://github.com/operasoftware/devopera/pull/330&quot;&gt;Chrome은 현재&lt;/a&gt; 특정 CSS 속성 ID를 고려하여 두 가지 작업을 수행 합니다. 새 합성 레이어 설정 또는 새 CSS&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/stacking_context&quot;&gt;스태킹 컨텍스트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="376a6b6761a1236cbc5ca78b950ad38728dc3262" translate="yes" xml:space="preserve">
          <source>Indicates that the author expects to animate or change the scroll position of the element in the near future.</source>
          <target state="translated">제작자가 가까운 장래에 요소의 스크롤 위치에 애니메이션을 적용하거나 변경할 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d85757f4706dbef331f1e9ad56eef357581956ff" translate="yes" xml:space="preserve">
          <source>Indicates that the children of the element are lying in the plane of the element itself.</source>
          <target state="translated">요소의 하위 요소가 요소 자체의 평면에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8657d0e7e94e8a29012df19a8b56b51588223ebf" translate="yes" xml:space="preserve">
          <source>Indicates that the children of the element should be positioned in the 3D-space.</source>
          <target state="translated">요소의 자식이 3D 공간에 배치되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="900e692bdd75bdd19e0e08f1766c6b02f6a35ab7" translate="yes" xml:space="preserve">
          <source>Indicates that the element can be sized without the need to examine its descendants for size changes.</source>
          <target state="translated">크기 변경을 위해 하위 요소를 검사 할 필요없이 요소 크기를 조정할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c9afdaadca5f930e0afcb841e7c0b0e523049632" translate="yes" xml:space="preserve">
          <source>Indicates that the motion of the content after the contact is picked up &lt;em&gt;may&lt;/em&gt; be adjusted if the content would normally stop &quot;close enough&quot; to a snap-point. This implies that it is possible for the content zoom factor to end up between snap-points.</source>
          <target state="translated">컨텐츠가 일반적으로 스냅 포인트에 &quot;충분히 가까이&quot;정지하는 경우 접촉이 포착 된 후 컨텐츠의 동작 이 조정될 &lt;em&gt;수&lt;/em&gt; 있음을 나타냅니다 . 이는 컨텐츠 확대 / 축소 비율이 스냅 포인트 사이에있을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b7248b1f2ea440b2a27159e8f685d427450ccbae" translate="yes" xml:space="preserve">
          <source>Indicates that the motion of the content after the contact is picked up is &lt;em&gt;always&lt;/em&gt; adjusted so that it lands on a snap-point. The snap-point that is selected is the one that is closest to where the content zoom factor would normally stop.</source>
          <target state="translated">접점을 선택한 후 컨텐츠의 동작이 &lt;em&gt;항상&lt;/em&gt; 스냅 포인트에 도달하도록 조정 됨을 나타냅니다 . 선택된 스냅 포인트는 컨텐츠 확대 / 축소 비율이 일반적으로 중지되는 위치에 가장 가까운 스냅 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="d94ae74d78a0d8167beb4e4910395de4a20161b6" translate="yes" xml:space="preserve">
          <source>Indicates that the subsequent styling rules will be applied when the system is placed in high contrast mode with a black-on-white color variation.</source>
          <target state="translated">시스템이 흑백 색상 변화로 고 대비 모드에있을 때 후속 스타일링 규칙이 적용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8fa0837a7b17822f6fc62fe841ad4c975a17baef" translate="yes" xml:space="preserve">
          <source>Indicates that the subsequent styling rules will be applied when the system is placed in high contrast mode with a white-on-black color variation.</source>
          <target state="translated">시스템이 흰색에서 검은 색으로 변색 된 고 대비 모드에있을 때 후속 스타일링 규칙이 적용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f33e7aedbb6a523ec537d9ae4879bcfc5f48fcf" translate="yes" xml:space="preserve">
          <source>Indicates that the subsequent styling rules will be applied when the system is placed in high contrast mode with any color variation.</source>
          <target state="translated">시스템이 색상 변화가있는 고 대비 모드에있을 때 후속 스타일링 규칙이 적용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95ff9899c62377575c0a87b3629798d0f3bf743a" translate="yes" xml:space="preserve">
          <source>Indicates that the user has made no preference known to the system.</source>
          <target state="translated">사용자가 시스템에 알려진 기본 설정을 지정하지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e9c9dd712a6bc67161319559b764237e6c1df1f" translate="yes" xml:space="preserve">
          <source>Indicates that user has notified the system that they prefer an interface that minimizes the amount of movement or animation, preferably to the point where all non-essential movement is removed.</source>
          <target state="translated">사용자가 시스템에 움직임이나 애니메이션의 양을 최소화하는 인터페이스를 선호한다는 것을 알았으며, 비 필수적인 모든 움직임이 제거되는 지점으로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="599b3405595517238644e81150c0148e6c603549" translate="yes" xml:space="preserve">
          <source>Indicates that, for properties that can have effects on more than just an element and its descendants, those effects don't escape the containing element.</source>
          <target state="translated">하나 이상의 요소와 그 하위 항목에 영향을 줄 수있는 속성의 경우 해당 효과가 포함 요소를 벗어나지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eac8d93f17aa617efa9f7d24e607782a7a610b3a" translate="yes" xml:space="preserve">
          <source>Indicates the applicable CSS properties &lt;em&gt;will not&lt;/em&gt; be adjusted when the system is in high contrast mode.</source>
          <target state="translated">시스템이 고 대비 모드 인 경우 해당 CSS 속성 &lt;em&gt;이&lt;/em&gt; 조정 &lt;em&gt;되지 않음을&lt;/em&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="184dbe0e24e2a9d65b78e649559a50b605bcc0bf" translate="yes" xml:space="preserve">
          <source>Indicates the applicable CSS properties &lt;em&gt;will&lt;/em&gt; be adjusted as expected when the system is in high contrast mode.</source>
          <target state="translated">시스템이 고 대비 모드 일 때 적용 가능한 CSS 속성 &lt;em&gt;이&lt;/em&gt; 예상대로 조정 됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="14946a92dd72a9ab17ac591a0616c5060511fd0b" translate="yes" xml:space="preserve">
          <source>Indicates the element renders as normal, with no containment applied.</source>
          <target state="translated">억제가 적용되지 않은 상태에서 요소가 정상적으로 렌더링됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c936a53222ff1ddf11f85c45d07e632fcb291642" translate="yes" xml:space="preserve">
          <source>Indicates the maximum number of successive hyphenated lines.</source>
          <target state="translated">연속적인 하이픈 줄의 최대 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7fa6b5b51639cebe6128a3c2add3611ab1953e9c" translate="yes" xml:space="preserve">
          <source>Indicates the optimal column width. The actual column width may differ from the specified value: it may be wider when necessary to fill available space, and narrower when the available space is too small. The value must be strictly positive or the declaration is invalid. Percentage values are also invalid.</source>
          <target state="translated">최적의 열 너비를 나타냅니다. 실제 열 너비는 지정된 값과 다를 수 있습니다. 사용 가능한 공간을 채울 필요가있을 때 더 넓고 사용 가능한 공간이 너무 작을 때 더 좁을 수 있습니다. 값은 반드시 양수 여야합니다. 그렇지 않으면 선언이 유효하지 않습니다. 백분율 값도 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05d5510b9160aed74036ac6bf28168bd54e9b7a6" translate="yes" xml:space="preserve">
          <source>Indicates the position of the abscissa of the &lt;em&gt;vanishing point&lt;/em&gt;. It can have one of the following values:</source>
          <target state="translated">&lt;em&gt;소실점&lt;/em&gt; 의 가로 좌표 위치를 나타냅니다 . 다음 값 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c395f7eef46e27f01c39a344102bab6b2ff826ef" translate="yes" xml:space="preserve">
          <source>Indicates the position of the ordinate of the &lt;em&gt;vanishing point&lt;/em&gt;. It can have one of the following values:</source>
          <target state="translated">&lt;em&gt;소실점&lt;/em&gt; 의 세로 위치를 나타냅니다 . 다음 값 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf58ded585db7cbb7a4bf94cf9e9c01a48849060" translate="yes" xml:space="preserve">
          <source>Indicates the size of the reflection.</source>
          <target state="translated">반사의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1003d6bea2a485076df105e8657082f84cb14697" translate="yes" xml:space="preserve">
          <source>Indicating Overflow</source>
          <target state="translated">오버플로 표시</target>
        </trans-unit>
        <trans-unit id="fd460920298c8557b897209822f333dc6c296947" translate="yes" xml:space="preserve">
          <source>Indicating logical values for the 4-value shorthand syntax</source>
          <target state="translated">4 값 속기 구문의 논리 값 표시</target>
        </trans-unit>
        <trans-unit id="5bec20640c9694f178e5683ed6cd18a081ca056a" translate="yes" xml:space="preserve">
          <source>InfoBackground</source>
          <target state="translated">InfoBackground</target>
        </trans-unit>
        <trans-unit id="b5f27876abf2ea4ddad97e38037e93d99fafefba" translate="yes" xml:space="preserve">
          <source>InfoText</source>
          <target state="translated">InfoText</target>
        </trans-unit>
        <trans-unit id="923b241351b311e9b28837ac45a9093fd4ed8849" translate="yes" xml:space="preserve">
          <source>Informal definition of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;ms&lt;/code&gt; 의 비공식적 인 정의 .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="e0f6d0f76e29d8b06e53fd7c1b8d5dc359ab53ab" translate="yes" xml:space="preserve">
          <source>Inheritance is always from the parent element in the document tree, even when the parent element is not the containing block.</source>
          <target state="translated">상속은 상위 요소가 포함 블록이 아닌 경우에도 항상 문서 트리의 상위 요소에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="25a8f8f6cea5b4f9438b2acefee0a32946cb19bf" translate="yes" xml:space="preserve">
          <source>Inheritance of CSS Variables</source>
          <target state="translated">CSS 변수의 상속</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="7951150c36a5b0078509be63ec158d0a10f3f90a" translate="yes" xml:space="preserve">
          <source>Inherited properties</source>
          <target state="translated">상속 된 속성</target>
        </trans-unit>
        <trans-unit id="77cd3f14829b11dee5420e5b5e5777cc5a714a44" translate="yes" xml:space="preserve">
          <source>Inherited value</source>
          <target state="translated">상속 된 가치</target>
        </trans-unit>
        <trans-unit id="035932ce61bd03f6681a2dfbb742b6af7b651dcc" translate="yes" xml:space="preserve">
          <source>Initial Definition</source>
          <target state="translated">초기 정의</target>
        </trans-unit>
        <trans-unit id="2d26fae0aedb317af83d87ca1df3865ec1154118" translate="yes" xml:space="preserve">
          <source>Initial SVG definition.</source>
          <target state="translated">초기 SVG 정의.</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="translated">초기 정의</target>
        </trans-unit>
        <trans-unit id="25f9a77cf783f16036629e79a731b48c703cdd57" translate="yes" xml:space="preserve">
          <source>Initial definition (applies to SVG elements only).</source>
          <target state="translated">초기 정의 (SVG 요소에만 적용)</target>
        </trans-unit>
        <trans-unit id="40f14a9f5c25314a9bd140e8078d6763887c11a2" translate="yes" xml:space="preserve">
          <source>Initial definition, but without the associated semantics.</source>
          <target state="translated">초기 의미이지만 관련 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="be24ed67a94593fc3cd4c6e53624d888aa659ee2" translate="yes" xml:space="preserve">
          <source>Initial definition, using the one-colon syntax</source>
          <target state="translated">1 콜론 구문을 사용한 초기 정의</target>
        </trans-unit>
        <trans-unit id="74002d7e78de203b29aeda48d3f886aec4698673" translate="yes" xml:space="preserve">
          <source>Initial definition, using the one-colon syntax.</source>
          <target state="translated">1 콜론 구문을 사용한 초기 정의.</target>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="translated">초기 정의.</target>
        </trans-unit>
        <trans-unit id="975bf7141a91d3278ea71022c906bc08dfca1acd" translate="yes" xml:space="preserve">
          <source>Initial definition. Also defines &lt;code&gt;-webkit-user-select&lt;/code&gt; as a deprecated alias of &lt;code&gt;user-select&lt;/code&gt;.</source>
          <target state="translated">초기 정의. 또한 &lt;code&gt;-webkit-user-select&lt;/code&gt; 를 더 이상 사용되지 않는 &lt;code&gt;user-select&lt;/code&gt; 별명으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c881fe0a09349713c32f429bd8895f5e7a934a99" translate="yes" xml:space="preserve">
          <source>Initial definition. Basic values: &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;block&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;list-item&lt;/code&gt;.</source>
          <target state="translated">초기 정의. 기본 값 : &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;block&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; 및 &lt;code&gt;list-item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b00e221ec42d16a3691742b1d94b2f3055dc8fc" translate="yes" xml:space="preserve">
          <source>Initial definition. Basic values: &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;block&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt;, and &lt;code&gt;list-item&lt;/code&gt;.</source>
          <target state="translated">초기 정의. 기본 값 : &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;block&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; 및 &lt;code&gt;list-item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="820f9617dae68b20d995506d46f6cd36ecf7165f" translate="yes" xml:space="preserve">
          <source>Initial definition. Before this, there was no explicitly defined &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; data type. Images could only be defined using the &lt;code&gt;url()&lt;/code&gt; functional notation.</source>
          <target state="translated">초기 정의. 이전에는 명시 적으로 정의 된 &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; 데이터 유형 이 없었습니다 . 이미지는 &lt;code&gt;url()&lt;/code&gt; 기능 표기법을 사용해서 만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e5e02957a963cbf342e1ec02bd394976b39e866" translate="yes" xml:space="preserve">
          <source>Initial definition. Extends the CSS 2.1 &lt;a href=&quot;page-break-after&quot;&gt;&lt;code&gt;page-break-after&lt;/code&gt;&lt;/a&gt; property to handle both page and column breaks.</source>
          <target state="translated">초기 정의. CSS 2.1 &lt;a href=&quot;page-break-after&quot;&gt; &lt;code&gt;page-break-after&lt;/code&gt; &lt;/a&gt; 속성을 확장하여 페이지 및 열 나누기를 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="11bfc68ae6c8c49814fdb235700ad53880c4f8e9" translate="yes" xml:space="preserve">
          <source>Initial definition. Extends the CSS 2.1 &lt;a href=&quot;page-break-before&quot;&gt;&lt;code&gt;page-break-before&lt;/code&gt;&lt;/a&gt; property to handle both page and column breaks.</source>
          <target state="translated">초기 정의. CSS 2.1 &lt;a href=&quot;page-break-before&quot;&gt; &lt;code&gt;page-break-before&lt;/code&gt; &lt;/a&gt; 속성을 확장하여 페이지 및 열 나누기를 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8265e9e013bec7297a2f42d5d894e5dd3e263062" translate="yes" xml:space="preserve">
          <source>Initial definition. Implicit definition of the &lt;code&gt;em&lt;/code&gt;, &lt;code&gt;pt&lt;/code&gt;, &lt;code&gt;pc&lt;/code&gt;, and &lt;code&gt;px&lt;/code&gt; units.</source>
          <target state="translated">초기 정의. &lt;code&gt;em&lt;/code&gt; , &lt;code&gt;pt&lt;/code&gt; , &lt;code&gt;pc&lt;/code&gt; 및 &lt;code&gt;px&lt;/code&gt; 단위 의 암시 적 정의</target>
        </trans-unit>
        <trans-unit id="d41db0dc231852b17d289f05356651e798841a6e" translate="yes" xml:space="preserve">
          <source>Initial definition. Includes 16 basic color keywords.</source>
          <target state="translated">초기 정의. 16 가지 기본 색상 키워드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="53c9c50b1d1b45d614c8c72e019e636f3b7e42dc" translate="yes" xml:space="preserve">
          <source>Initial definition. Makes &lt;code&gt;ime-mode&lt;/code&gt; officially obsolete.</source>
          <target state="translated">초기 정의. &lt;code&gt;ime-mode&lt;/code&gt; 를 공식적으로 쓸모 없게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0114813b18510cc9f46a860ff2206ec5c42488e5" translate="yes" xml:space="preserve">
          <source>Initial definition. The &lt;a href=&quot;text-decoration&quot;&gt;&lt;code&gt;text-decoration&lt;/code&gt;&lt;/a&gt; property is now a shorthand to define multiple related properties.</source>
          <target state="translated">초기 정의. &lt;a href=&quot;text-decoration&quot;&gt; &lt;code&gt;text-decoration&lt;/code&gt; &lt;/a&gt; 속성은 이제 여러 관련 속성을 정의하는 속기입니다.</target>
        </trans-unit>
        <trans-unit id="a5fad50e663339eb69b33c7176d0d59f7ff329be" translate="yes" xml:space="preserve">
          <source>Initial definition. The value must be nonnegative.</source>
          <target state="translated">초기 정의. 이 값은 음이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="e74dc34a4e35801a72521fe3dc94d638863f8374" translate="yes" xml:space="preserve">
          <source>Initial defintion</source>
          <target state="translated">초기 정의</target>
        </trans-unit>
        <trans-unit id="585ca2462f2ae0b7d0d57fb6f5fb89e35c466e8a" translate="yes" xml:space="preserve">
          <source>Initial documentation</source>
          <target state="translated">초기 문서</target>
        </trans-unit>
        <trans-unit id="b05c468492e894bf720cb26fc99830351a2cef87" translate="yes" xml:space="preserve">
          <source>Initial specification</source>
          <target state="translated">초기 사양</target>
        </trans-unit>
        <trans-unit id="b02ab27206424d25f0694d50b2db52af850703cc" translate="yes" xml:space="preserve">
          <source>Initial specification of longhand sub-properties of &lt;a href=&quot;background-position&quot;&gt;&lt;code&gt;background-position&lt;/code&gt;&lt;/a&gt; to match longstanding implementations.</source>
          <target state="translated">오랜 구현과 일치 하는 &lt;a href=&quot;background-position&quot;&gt; &lt;code&gt;background-position&lt;/code&gt; &lt;/a&gt; 장기 하위 속성에 대한 초기 사양입니다 .</target>
        </trans-unit>
        <trans-unit id="8f03130f43d80f7b832367da10284552d03021e1" translate="yes" xml:space="preserve">
          <source>Initial specification.</source>
          <target state="translated">초기 사양.</target>
        </trans-unit>
        <trans-unit id="5d15320e0b2f39af3533c8f07c8726c865ff1a13" translate="yes" xml:space="preserve">
          <source>Initial standardization</source>
          <target state="translated">초기 표준화</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="b179b79771c41d76bb6255c3a2fd0a5b15cbf225" translate="yes" xml:space="preserve">
          <source>Initial value. Automatic page breaks (neither forced nor forbidden).</source>
          <target state="translated">초기 값. 자동 페이지 나누기 (강제 또는 금지)</target>
        </trans-unit>
        <trans-unit id="5b867e672228b2c0f472a9b14bf9670674172756" translate="yes" xml:space="preserve">
          <source>Initial value. Indicates that zooming is unaffected by any defined snap-points. After the contact is picked up, the content will continue to move with inertia.</source>
          <target state="translated">초기 값. 확대 / 축소가 정의 된 스냅 점의 영향을받지 않음을 나타냅니다. 연락처가 수신 된 후에는 내용이 관성으로 계속 이동합니다.</target>
        </trans-unit>
        <trans-unit id="22a3d43a8a94d8aeee1d2bde07e6371306d822f9" translate="yes" xml:space="preserve">
          <source>Initial value. Panning locks to the primary axis of motion.</source>
          <target state="translated">초기 값. 이동은 기본 동작 축으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="3179d2fa68826ec064ce85a0914dcc94f043ba28" translate="yes" xml:space="preserve">
          <source>Initial value. The IME may align the candidate window in any manner.</source>
          <target state="translated">초기 값. IME는 임의의 방식으로 후보 윈도우를 정렬 할 수있다.</target>
        </trans-unit>
        <trans-unit id="c698ce2899083b5c6d74d782ba14dc3a672b594e" translate="yes" xml:space="preserve">
          <source>Initial value. The nearest scrollable parent element begins scrolling when the user hits a scroll limit during any manipulation. No bounce effect is shown.</source>
          <target state="translated">초기 값. 사용자가 조작하는 동안 스크롤 제한에 도달하면 가장 가까운 스크롤 가능한 상위 요소가 스크롤을 시작합니다. 바운스 효과가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7690a0dd7eb88a67c01543c6f75e8b40a394009" translate="yes" xml:space="preserve">
          <source>Initial versions had bugs on Windows and Linux that broke &lt;a href=&quot;http://crbug.com/114719&quot;&gt;font substitition&lt;/a&gt;, &lt;a href=&quot;http://crbug.com/51973&quot;&gt;small-caps&lt;/a&gt;, &lt;a href=&quot;http://crbug.com/55458&quot;&gt;letter-spacing&lt;/a&gt; or caused &lt;a href=&quot;http://crbug.com/149548&quot;&gt;text to overlap&lt;/a&gt;.</source>
          <target state="translated">초기 버전은 Windows 및 Linux에서 &lt;a href=&quot;http://crbug.com/114719&quot;&gt;글꼴 자막&lt;/a&gt; , &lt;a href=&quot;http://crbug.com/51973&quot;&gt;작은 대문자&lt;/a&gt; , &lt;a href=&quot;http://crbug.com/55458&quot;&gt;글자 간격&lt;/a&gt; 또는 &lt;a href=&quot;http://crbug.com/149548&quot;&gt;텍스트가 겹치는&lt;/a&gt; 버그를 가졌습니다 .</target>
        </trans-unit>
        <trans-unit id="57e4f0872386e0adfedf8727302cceaaec297e53" translate="yes" xml:space="preserve">
          <source>Initially a part of &lt;a href=&quot;css_columns&quot;&gt;Multi-column Layout&lt;/a&gt;, the definition of &lt;code&gt;column-gap&lt;/code&gt; has been broadened to include multiple layout methods. Now specified in &lt;a href=&quot;css_box_alignment&quot;&gt;Box Alignment&lt;/a&gt;, it may be used in Multi-column, Flexible Box, and Grid layouts.</source>
          <target state="translated">처음에는 &lt;a href=&quot;css_columns&quot;&gt;다중 열 레이아웃&lt;/a&gt; 의 일부인 &lt;code&gt;column-gap&lt;/code&gt; 정의가 여러 레이아웃 방법을 포함하도록 확장되었습니다. 이제 &lt;a href=&quot;css_box_alignment&quot;&gt;Box Alignment에&lt;/a&gt; 지정되어 다중 열, 유연한 상자 및 격자 레이아웃에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef4d6238de3ab9e8afea7755189c1b37ce62606" translate="yes" xml:space="preserve">
          <source>Initially, Android supported only &lt;code&gt;-webkit-&lt;/code&gt; prefixed values for gradients (such as &lt;code&gt;-webkit-linear-gradient()&lt;/code&gt;). Later, support for unprefixed values was added.</source>
          <target state="translated">처음에 Android 는 그라디언트에 대해 &lt;code&gt;-webkit-&lt;/code&gt; 접두사가 붙은 값만 지원했습니다 (예 : &lt;code&gt;-webkit-linear-gradient()&lt;/code&gt; ). 나중에 접두사가없는 값에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5afb06ad5cff85e7aab9df2741bbe1e500a4c851" translate="yes" xml:space="preserve">
          <source>Initially, Safari supported only &lt;code&gt;-webkit-&lt;/code&gt; prefixed values for gradients (such as &lt;code&gt;-webkit-linear-gradient()&lt;/code&gt;). Later, support for unprefixed values was added.</source>
          <target state="translated">우선, 사파리 만 지원 &lt;code&gt;-webkit-&lt;/code&gt; 그라디언트 접두사 값 (예 &lt;code&gt;-webkit-linear-gradient()&lt;/code&gt; ). 나중에 접두사가없는 값에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f055d0330dcd4f8001e2f0f635457d549e9f013c" translate="yes" xml:space="preserve">
          <source>Inline box fragments</source>
          <target state="translated">인라인 박스 조각</target>
        </trans-unit>
        <trans-unit id="137e1b8d6c6f75683116fe1f1fea9b6f42354c9f" translate="yes" xml:space="preserve">
          <source>Inline dimension</source>
          <target state="translated">인라인 차원</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">인라인 요소</target>
        </trans-unit>
        <trans-unit id="189209b5b5c0f80ace73914d798e8e289f685f21" translate="yes" xml:space="preserve">
          <source>Inline elements display one after the other in the direction that sentences run in that particular writing mode. While we don&amp;rsquo;t tend to think of inline elements as having a box, as with everything in CSS they do. These inline boxes are arranged one after the other. If there is not enough space in the containing block for all of the boxes a box can break onto a new line. The lines created are known as line boxes.</source>
          <target state="translated">인라인 요소는 문장이 특정 쓰기 모드에서 실행되는 방향으로 차례로 표시됩니다. CSS의 모든 것과 마찬가지로 인라인 요소가 상자를 갖는 것으로 생각하지는 않습니다. 이 인라인 박스는 차례로 배열됩니다. 포함하는 블록에 모든 상자를위한 공간이 충분하지 않으면 상자가 새 줄로 나올 수 있습니다. 만들어진 선을 선 상자라고합니다.</target>
        </trans-unit>
        <trans-unit id="20843c01ad0d057ce0fe075fea74d61732633b79" translate="yes" xml:space="preserve">
          <source>Inline flow content can flow on all sides of the exclusion.</source>
          <target state="translated">인라인 흐름 내용은 제외의 모든 측면에서 흐를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69eeba21eb1d72d396cbd8c1b775dc045bc6dc2c" translate="yes" xml:space="preserve">
          <source>Inline flow content can only wrap on top and bottom of the exclusion and must leave empty the areas to the start and end edges of the exclusion box.</source>
          <target state="translated">인라인 흐름 내용은 제외의 맨 위와 맨 아래에서만 감쌀 수 있으며 제외 상자의 시작 및 끝 가장자리에 빈 공간을 남겨 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="2128f1864e27a46db7ace35ab572513a1fb52d82" translate="yes" xml:space="preserve">
          <source>Inline flow content can wrap after the end edge of the exclusion area but must leave empty the area before the start edge of the exclusion area.</source>
          <target state="translated">인라인 흐름 내용은 제외 영역의 끝 가장자리 뒤를 감쌀 수 있지만 제외 영역의 시작 가장자리 앞을 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="66b27e6e016c561d706617b44a135f54dcd6f487" translate="yes" xml:space="preserve">
          <source>Inline flow content can wrap on the side of the exclusion with the largest available space for the given line, and must leave empty the other side of the exclusion.</source>
          <target state="translated">인라인 흐름 내용은 주어진 라인에 대해 사용 가능한 가장 큰 공간으로 제외 측면을 감싸고 제외의 다른 측면을 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="87a509c4e2ce1661312286b0c6871e538f6dbe43" translate="yes" xml:space="preserve">
          <source>Inline flow content can wrap on the start edge of the exclusion area but must leave empty the area after the end edge of the exclusion area.</source>
          <target state="translated">인라인 흐름 내용은 제외 영역의 시작 가장자리를 감쌀 수 있지만 제외 영역의 끝 가장자리 다음에 해당 영역을 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="da86e7e07ef125ab7771aae6787d426ed6424d34" translate="yes" xml:space="preserve">
          <source>Inline formatting contexts exist inside other formatting contexts and can be thought of as the context of a paragraph. The paragraph creates an inline formatting context inside which such things as &lt;code&gt;strong&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, or &lt;code&gt;span&lt;/code&gt; elements are used on text.</source>
          <target state="translated">인라인 서식 컨텍스트는 다른 서식 컨텍스트 안에 존재하며 단락의 컨텍스트로 생각할 수 있습니다. 이 단락은 텍스트에 &lt;code&gt;strong&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;span&lt;/code&gt; 요소가 사용되는 인라인 서식 컨텍스트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f386eab51dee9de6029b4b6151fe84bed24ca95c" translate="yes" xml:space="preserve">
          <source>Inline layout mode</source>
          <target state="translated">인라인 레이아웃 모드</target>
        </trans-unit>
        <trans-unit id="ab5a70452dbadf33e1d51d91e88905850bf3fbbf" translate="yes" xml:space="preserve">
          <source>Inline styles added to an element (e.g., &lt;code&gt;style=&quot;font-weight: bold;&quot;&lt;/code&gt;) always overwrite any styles in external stylesheets, and thus can be thought of as having the highest specificity.</source>
          <target state="translated">요소에 추가 된 인라인 스타일 (예 : &lt;code&gt;style=&quot;font-weight: bold;&quot;&lt;/code&gt; )은 항상 외부 스타일 시트의 모든 스타일을 덮어 쓰므로 가장 높은 특이성을 갖는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd29783f5b6e9b0fddfced518bfe6f412b88e6db" translate="yes" xml:space="preserve">
          <source>Inline-Axis Overflow</source>
          <target state="translated">인라인 축 오버플로</target>
        </trans-unit>
        <trans-unit id="a7dbe78d2335a5d5bd4daf2aa3a1210c1150efce" translate="yes" xml:space="preserve">
          <source>Inline-level elements and inline boxes</source>
          <target state="translated">인라인 레벨 요소 및 인라인 박스</target>
        </trans-unit>
        <trans-unit id="992f014d4ba6df78f03b431f2889ec23bd37a7ef" translate="yes" xml:space="preserve">
          <source>Inline-level elements generate &lt;em&gt;inline-level boxes&lt;/em&gt; that are defined as boxes participating to an &lt;a href=&quot;inline_formatting_context&quot;&gt;inline formatting context&lt;/a&gt;. &lt;em&gt;Inline boxes&lt;/em&gt; are both inline-level boxes and boxes, whose contents participate in their container's inline formatting context. This is the case, for example, for all non-replaced boxes with &lt;code&gt;display:inline&lt;/code&gt;. Inline-level boxes, whose contents do not participate in an inline formatting context, are called &lt;em&gt;atomic inline-level boxes&lt;/em&gt;. These boxes, generated by replaced inline-level elements or by elements with a calculated &lt;a href=&quot;display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;inline-block&lt;/code&gt; or &lt;code&gt;inline-table&lt;/code&gt;, are never split into several boxes, as is possible with inline boxes.</source>
          <target state="translated">인라인 레벨 요소 는 &lt;a href=&quot;inline_formatting_context&quot;&gt;인라인 포맷 컨텍스트에&lt;/a&gt; 참여하는 박스로 정의 된 &lt;em&gt;인라인 레벨 박스&lt;/em&gt; 를 생성 합니다. &lt;em&gt;인라인 박스&lt;/em&gt; 는 컨테이너의 인라인 포맷팅 컨텍스트에 내용이 포함 된 인라인 레벨 박스 및 박스입니다. 예를 들어 &lt;code&gt;display:inline&lt;/code&gt; 이있는 교체되지 않은 모든 상자의 경우입니다 . 내용이 인라인 형식화 컨텍스트에 참여하지 않는 &lt;em&gt;인라인 레벨 상자를 원자 인라인 레벨 상자&lt;/em&gt; 라고 합니다. 인라인 레벨 요소로 대체 되거나 &lt;code&gt;inline-table&lt;/code&gt; &lt;code&gt;inline-block&lt;/code&gt; 또는 인라인 테이블 의 계산 된 &lt;a href=&quot;display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 값이 있는 요소로 생성되는이 상자&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;인라인 상자에서와 같이 여러 상자로 분할되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6c75dc74d1bbc1afebd3b7c8e613f09e5bb437d" translate="yes" xml:space="preserve">
          <source>Inside our grid container I have four child elements. If we do not place these on to the grid in any way they will lay out according to the auto-placement rules, one item in each of the first four cells. If you use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector/How_to/Examine_grid_layouts&quot;&gt;Firefox Grid Highlighter&lt;/a&gt; you can see how the grid has defined columns and rows.</source>
          <target state="translated">그리드 컨테이너 안에는 네 개의 자식 요소가 있습니다. 우리가 어떤 식 으로든 그리드에 배치하지 않으면 자동 배치 규칙에 따라 배치됩니다. 처음 네 개의 셀 각각에 하나씩 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector/How_to/Examine_grid_layouts&quot;&gt;Firefox Grid Highlighter&lt;/a&gt; 를 사용하면 그리드가 열과 행을 어떻게 정의했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf53f917bc6c943f97fe8c8417827d5c5892429" translate="yes" xml:space="preserve">
          <source>Inside the element's constructor, we create &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;span&lt;/code&gt; elements, fill the &lt;code&gt;span&lt;/code&gt; with the content of the custom element, and fill the &lt;code&gt;style&lt;/code&gt; element with some CSS rules:</source>
          <target state="translated">요소의 생성자 내에서 &lt;code&gt;style&lt;/code&gt; 과 &lt;code&gt;span&lt;/code&gt; 요소를 만들고 &lt;code&gt;span&lt;/code&gt; 를 사용자 정의 요소의 내용으로 채우고 &lt;code&gt;style&lt;/code&gt; 요소를 CSS 규칙으로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="ea8c1b4ec60d1501f436e24ae27534df043d761b" translate="yes" xml:space="preserve">
          <source>Instead of ignoring the &lt;code&gt;-webkit-text-size-adjust&lt;/code&gt; property, a bug prevents desktop Chrome users from zooming in or out. The bug was fixed after Chrome 26.</source>
          <target state="translated">&lt;code&gt;-webkit-text-size-adjust&lt;/code&gt; 속성 을 무시하는 대신 버그로 인해 데스크톱 Chrome 사용자가 확대하거나 축소 할 수 없습니다. 이 버그는 Chrome 26 이후에 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="79ba06e50637ef05b0e949f2065fadc5ce7b9530" translate="yes" xml:space="preserve">
          <source>Instead of ignoring the &lt;code&gt;-webkit-text-size-adjust&lt;/code&gt; property, a bug prevents desktop Safari users from zooming in or out. The bug was fixed after Safari 5.</source>
          <target state="translated">버그 는 &lt;code&gt;-webkit-text-size-adjust&lt;/code&gt; 속성 을 무시하는 대신 데스크탑 Safari 사용자가 확대 또는 축소하는 것을 방지합니다. 이 버그는 Safari 5 이후 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ea8523d947c511ee5277a9ec99bfa7d7e03c921" translate="yes" xml:space="preserve">
          <source>Instead we can target item 4 and separate it from the first three items by giving it a &lt;code&gt;margin-left&lt;/code&gt; value of &lt;code&gt;auto&lt;/code&gt;. Auto margins will take up all of the space that they can in their axis &amp;mdash; it is how centering a block with margin auto left and right works. Each side tries to take as much space as it can, and so the block is pushed into the middle.</source>
          <target state="translated">대신 항목 4를 대상으로하고 &lt;code&gt;margin-left&lt;/code&gt; 값 &lt;code&gt;auto&lt;/code&gt; 를 지정하여 처음 세 항목과 구분할 수 있습니다 . 자동 여백은 축에서 가능한 모든 공간을 차지합니다. 여백 자동 왼쪽 및 오른쪽으로 블록을 중앙에 배치하는 방식입니다. 각면은 가능한 한 많은 공간을 차지하려고 시도하므로 블록이 가운데로 밀립니다.</target>
        </trans-unit>
        <trans-unit id="c20b8f147e0e4af5f8712f07daf88693461e01fc" translate="yes" xml:space="preserve">
          <source>Intended for paged material and documents viewed on a screen in print preview mode. (Please see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media&quot;&gt;paged media&lt;/a&gt; for information about formatting issues that are specific to these formats.)</source>
          <target state="translated">인쇄 미리보기 모드에서 화면에서 볼 수있는 페이징 된 자료 및 문서에 사용됩니다. ( 이러한 형식과 관련된 서식 문제에 대한 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media&quot;&gt;페이징 된 미디어&lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="7947754bf7c28941dd485b71c6cbc0b62229193f" translate="yes" xml:space="preserve">
          <source>Intended for speech synthesizers.</source>
          <target state="translated">음성 합성기에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03f6dfea05d7992a6a6b94442d68470a85a5139d" translate="yes" xml:space="preserve">
          <source>Intended mainly for internal use and by themes. Disables scrolling of XML root elements, &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;, and &lt;code&gt; &amp;lt;body&amp;gt;&lt;/code&gt; with the keyboard's arrow keys and the mouse wheel.</source>
          <target state="translated">주로 내부 용 및 테마 용입니다. 키보드의 화살표 키와 마우스 휠을 사용하여 XML 루트 요소 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 및 &lt;code&gt; &amp;lt;body&amp;gt;&lt;/code&gt; 를 스크롤 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09310508c2262ec61d2c7e926f4eee93241e0f8b" translate="yes" xml:space="preserve">
          <source>Intended primarily for screens.</source>
          <target state="translated">주로 스크린 용입니다.</target>
        </trans-unit>
        <trans-unit id="a54cd2e7a39890cc97a46dfdef5f1c663b4f9138" translate="yes" xml:space="preserve">
          <source>Internal &lt;code&gt;table-*&lt;/code&gt; elements don't have margins, use &lt;a href=&quot;border-spacing&quot;&gt;&lt;code&gt;border-spacing&lt;/code&gt;&lt;/a&gt; instead</source>
          <target state="translated">내부 &lt;code&gt;table-*&lt;/code&gt; 요소에는 여백이 없습니다. 대신 &lt;a href=&quot;border-spacing&quot;&gt; &lt;code&gt;border-spacing&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">인터넷 익스플로러</target>
        </trans-unit>
        <trans-unit id="c41136655b3f6611881379e8221c0db44ed5aff6" translate="yes" xml:space="preserve">
          <source>Internet Explorer 10 and 11 consider a unitless value in the &lt;code&gt;flex-basis&lt;/code&gt; part to be syntactically invalid (and will thus be ignored). A workaround is to always include a unit in the &lt;code&gt;flex-basis&lt;/code&gt; part of the &lt;code&gt;flex&lt;/code&gt; shorthand value. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#4-flex-shorthand-declarations-with-unitless-flex-basis-values-are-ignored&quot;&gt;Flexbug #4&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 10 및 11은 &lt;code&gt;flex-basis&lt;/code&gt; 부분 의 단위가없는 값 이 구문 상 유효하지 않은 것으로 간주 하므로 무시됩니다. 해결 방법은 항상 &lt;code&gt;flex&lt;/code&gt; 속기 값 의 플렉스 &lt;code&gt;flex-basis&lt;/code&gt; 부분에 단위를 포함하는 것 입니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#4-flex-shorthand-declarations-with-unitless-flex-basis-values-are-ignored&quot;&gt;Flexbug # 4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="095d998cf217ecc1c467b7e664bf1558a574b8dd" translate="yes" xml:space="preserve">
          <source>Internet Explorer 10 and 11 ignore uses of &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/calc&quot;&gt;&lt;code&gt;calc()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;flex-basis&lt;/code&gt; part of the &lt;code&gt;flex&lt;/code&gt; syntax. This can be worked around by using the longhand properties instead of the shorthand. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#8-flex-basis-doesnt-support-calc&quot;&gt;Flexbug #8&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 10 및 11 은 &lt;code&gt;flex&lt;/code&gt; 구문 의 &lt;code&gt;flex-basis&lt;/code&gt; 부분 에서 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/calc&quot;&gt; &lt;code&gt;calc()&lt;/code&gt; &lt;/a&gt; 사용을 무시 합니다. 이것은 속기 대신 긴 속성을 사용하여 해결할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#8-flex-basis-doesnt-support-calc&quot;&gt;Flexbug # 8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6621016b55329b0778a3d157c3ef97bf7d9a278f" translate="yes" xml:space="preserve">
          <source>Internet Explorer 10 uses &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;1&lt;/code&gt; as the initial value for the &lt;code&gt;flex-shrink&lt;/code&gt; property. A workaround is to always set an explicit value for &lt;code&gt;flex-shrink&lt;/code&gt;. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#6-the-default-flex-value-has-changed&quot;&gt;Flexbug #6&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 10은 &lt;code&gt;flex-shrink&lt;/code&gt; 속성 의 초기 값 으로 &lt;code&gt;1&lt;/code&gt; 대신 &lt;code&gt;0&lt;/code&gt; 을 사용 합니다. 해결 방법은 항상 &lt;code&gt;flex-shrink&lt;/code&gt; 에 대한 명시 적 값을 설정하는 것 입니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#6-the-default-flex-value-has-changed&quot;&gt;Flexbug # 6&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4882dffca9570cc206d6fe5b67e34d8f1c7db5a2" translate="yes" xml:space="preserve">
          <source>Internet Explorer 10, which implemented the &lt;code&gt;display: flexbox&lt;/code&gt; version of the specification with the &lt;code&gt;-ms-&lt;/code&gt; prefix.</source>
          <target state="translated">Internet Explorer 10 &lt;code&gt;display: flexbox&lt;/code&gt; &lt;code&gt;-ms-&lt;/code&gt; 접두사 가있는 사양의 flexbox 버전 디스플레이 를 구현했습니다 .</target>
        </trans-unit>
        <trans-unit id="7816182258d900b70c821a021fa841c35c51e8e7" translate="yes" xml:space="preserve">
          <source>Internet Explorer 11 considers a unitless value in the &lt;code&gt;flex-basis&lt;/code&gt; part to be syntactically invalid (and will thus be ignored). A workaround is to always include a unit in the &lt;code&gt;flex-basis&lt;/code&gt; part of the &lt;code&gt;flex&lt;/code&gt; shorthand value. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#4-flex-shorthand-declarations-with-unitless-flex-basis-values-are-ignored&quot;&gt;Flexbug #4&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 11은 &lt;code&gt;flex-basis&lt;/code&gt; 부분 의 단위가없는 값 이 구문 상 유효하지 않은 것으로 간주 하므로 무시됩니다. 해결 방법은 항상 &lt;code&gt;flex&lt;/code&gt; 속기 값 의 플렉스 &lt;code&gt;flex-basis&lt;/code&gt; 부분에 단위를 포함하는 것 입니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#4-flex-shorthand-declarations-with-unitless-flex-basis-values-are-ignored&quot;&gt;Flexbug # 4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ffdc003c062aa1a1ecca859f0c511a4362a5f9a" translate="yes" xml:space="preserve">
          <source>Internet Explorer 11 ignores uses of &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/calc&quot;&gt;&lt;code&gt;calc()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;flex-basis&lt;/code&gt; part of the &lt;code&gt;flex&lt;/code&gt; syntax. This can be worked around by using the longhand properties instead of the shorthand. See &lt;a href=&quot;https://github.com/philipwalton/flexbugs#8-flex-basis-doesnt-support-calc&quot;&gt;Flexbug #8&lt;/a&gt; for more info.</source>
          <target state="translated">Internet Explorer 11은 &lt;code&gt;flex&lt;/code&gt; 구문 의 &lt;code&gt;flex-basis&lt;/code&gt; 부분 에서 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/calc&quot;&gt; &lt;code&gt;calc()&lt;/code&gt; &lt;/a&gt; 사용을 무시 합니다. 이것은 속기 대신 긴 속성을 사용하여 해결할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/philipwalton/flexbugs#8-flex-basis-doesnt-support-calc&quot;&gt;Flexbug # 8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc1932c946261fb9be93823c86cac93f1fb4ff01" translate="yes" xml:space="preserve">
          <source>Internet Explorer 4 to 9 implemented a non-standard &lt;code&gt;filter&lt;/code&gt; property. The syntax was completely different from this one and is not documented here.</source>
          <target state="translated">Internet Explorer 4 ~ 9는 비표준 &lt;code&gt;filter&lt;/code&gt; 속성을 구현했습니다 . 구문은이 구문과 완전히 다르며 여기에 설명되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e566e6c77293e613e703bec89c33e0667e55df07" translate="yes" xml:space="preserve">
          <source>Internet Explorer 5.5 or later supports a proprietary &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms533014(VS.85,loband).aspx&quot;&gt;Matrix Filter&lt;/a&gt; which can be used to achieve a similar effect.</source>
          <target state="translated">Internet Explorer 5.5 이상 은 유사한 효과를 얻는 데 사용할 수 있는 독점 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms533014(VS.85,loband).aspx&quot;&gt;매트릭스 필터&lt;/a&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="d291604cf86ab705de40a90d2c834d430f2850b1" translate="yes" xml:space="preserve">
          <source>Internet Explorer 5.5 through 9.0 supported gradients via a proprietary filter: &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/-ms-filter#Gradient&quot;&gt;-ms-filter: progid:DXImageTransform.Microsoft.Gradient()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 5.5에서 9.0 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/CSS/-ms-filter#Gradient&quot;&gt;-ms-filter: progid:DXImageTransform.Microsoft.Gradient()&lt;/a&gt;&lt;/code&gt; 독점 필터 ( -ms-filter : progid : DXImageTransform.Microsoft.Gradient ()) 를 통해 그라디언트를 지원했습니다 .</target>
        </trans-unit>
        <trans-unit id="6d00d9dd5f66259287a276d783b6b26b2dd46aa7" translate="yes" xml:space="preserve">
          <source>Internet Explorer 7 doesn't update &lt;code&gt;:first-child&lt;/code&gt; styles when elements are added dynamically.</source>
          <target state="translated">Internet Explorer 7은 요소가 동적으로 추가 될 때 &lt;code&gt;:first-child&lt;/code&gt; 스타일을 업데이트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a387d2282d34c7d1618fc0d7201321a7658de79d" translate="yes" xml:space="preserve">
          <source>Internet Explorer 7 doesn't update the style correctly when an element is dynamically placed before an element that matched the selector.</source>
          <target state="translated">요소가 선택기와 일치하는 요소 앞에 동적으로 배치되면 Internet Explorer 7에서 스타일이 올바르게 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba237dc7b1b4815ec223b26e8609a284f986db07" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 and later support gray color keywords spelled with an &lt;em&gt;e&lt;/em&gt; (&lt;code&gt;grey&lt;/code&gt;, &lt;code&gt;darkgrey&lt;/code&gt;, &lt;code&gt;darkslategrey&lt;/code&gt;, &lt;code&gt;dimgrey&lt;/code&gt;, &lt;code&gt;lightgrey&lt;/code&gt;, and &lt;code&gt;lightslategrey&lt;/code&gt;). Internet Explorer 3 to Internet Explorer 7 only support the keywords spelled with &lt;em&gt;a&lt;/em&gt; (&lt;code&gt;gray&lt;/code&gt;, &lt;code&gt;darkgray&lt;/code&gt;, &lt;code&gt;darkslategray&lt;/code&gt;, &lt;code&gt;dimgray&lt;/code&gt;, &lt;code&gt;lightgray&lt;/code&gt;, and &lt;code&gt;lightslategray&lt;/code&gt;).</source>
          <target state="translated">인터넷 익스플로러 8과 나중에 철자 회색 키워드 지원 &lt;em&gt;전자&lt;/em&gt; ( &lt;code&gt;grey&lt;/code&gt; , &lt;code&gt;darkgrey&lt;/code&gt; , &lt;code&gt;darkslategrey&lt;/code&gt; , &lt;code&gt;dimgrey&lt;/code&gt; , &lt;code&gt;lightgrey&lt;/code&gt; 및 &lt;code&gt;lightslategrey&lt;/code&gt; 을 ). 인터넷 익스플로러 7에 인터넷 익스플로러 3 만 철자 키워드를 지원 ( &lt;code&gt;gray&lt;/code&gt; , &lt;code&gt;darkgray&lt;/code&gt; , &lt;code&gt;darkslategray&lt;/code&gt; , &lt;code&gt;dimgray&lt;/code&gt; , &lt;code&gt;lightgray&lt;/code&gt; 및 &lt;code&gt;lightslategray&lt;/code&gt; 을 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0061cc24b45fc654aa7d6a84aa52c571836d4213" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9 and later support an old draft values: &lt;code&gt;inline&lt;/code&gt; (equivalent of having &lt;code&gt;display: inline&lt;/code&gt; on the ruby), and &lt;code&gt;above&lt;/code&gt; (synonym of the modern &lt;code&gt;over&lt;/code&gt;).</source>
          <target state="translated">Internet Explorer 9 이상은 &lt;code&gt;inline&lt;/code&gt; ( 루비에 &lt;code&gt;display: inline&lt;/code&gt; 루비에 인라인 표시 ) 및 &lt;code&gt;above&lt;/code&gt; (현대 &lt;code&gt;over&lt;/code&gt; 동의어 )와 같은 오래된 초안 값을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="0616c092898dbe7ae78fec0871873ffdbca9ad51" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9 and later supports an earlier draft of CSS Ruby with non-standard values for this property: &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;distribute-letter&lt;/code&gt;, &lt;code&gt;distribute-space&lt;/code&gt;, and &lt;code&gt;line-edge&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 9 이상은 &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;distribute-letter&lt;/code&gt; , &lt;code&gt;distribute-space&lt;/code&gt; 및 &lt;code&gt;line-edge&lt;/code&gt; 와 같은이 속성에 대한 비표준 값으로 CSS Ruby의 초기 초안을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8ab108ae28952ba3bef468b4fe2817252c91b795" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9 supports 2D but not 3D transforms. In version 9, mixing 2D and 3D transform functions invalidates the entire property.</source>
          <target state="translated">Internet Explorer 9는 2D를 지원하지만 3D 변환은 지원하지 않습니다. 버전 9에서는 2D 및 3D 변형 함수를 혼합하면 전체 속성이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="487af5e8b667f554d2afffdd44f6ea38f29eccdc" translate="yes" xml:space="preserve">
          <source>Internet Explorer 9.0 or earlier has no support for 3D transforms. Mixing 3D and 2D transform functions, such as &lt;code&gt;-ms-transform:rotate(10deg) translateZ(0);&lt;/code&gt;, will prevent the entire property from being applied.</source>
          <target state="translated">Internet Explorer 9.0 이하는 3D 변환을 지원하지 않습니다. &lt;code&gt;-ms-transform:rotate(10deg) translateZ(0);&lt;/code&gt; 과 같은 3D 및 2D 변환 함수 혼합 ; 전체 속성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b956a017b2b83a815d64253bb17a30a44ce91ee9" translate="yes" xml:space="preserve">
          <source>Internet Explorer and Microsoft Edge use these pseudo-elements to style other parts of a range input:</source>
          <target state="translated">Internet Explorer와 Microsoft Edge는 이러한 의사 요소를 사용하여 범위 입력의 다른 부분을 스타일링합니다.</target>
        </trans-unit>
        <trans-unit id="e7d8b966e73b7a1cbfc5b7b79c04884aeb2c13d3" translate="yes" xml:space="preserve">
          <source>Internet Explorer does not recognize &lt;code&gt;:disabled&lt;/code&gt; on the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/fieldset&quot;&gt;&lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">Internet Explorer가 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/fieldset&quot;&gt; &lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 &lt;code&gt;:disabled&lt;/code&gt; 를 인식하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="23c96ce22bf9a21055bd4a969d43012686f848a6" translate="yes" xml:space="preserve">
          <source>Internet Explorer does not support the global values &lt;code&gt;initial&lt;/code&gt; and &lt;code&gt;unset&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer는 전역 값 &lt;code&gt;initial&lt;/code&gt; 및 &lt;code&gt;unset&lt;/code&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="91f370ac229045927a7bdb72388a5c51bddbd31a" translate="yes" xml:space="preserve">
          <source>Internet Explorer doesn't support &lt;code&gt;visibility: initial&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer는 &lt;code&gt;visibility: initial&lt;/code&gt; 지원하지 않습니다 : initial .</target>
        </trans-unit>
        <trans-unit id="c5f8c7865e42f1f649bdfe3988d2d87f7ad11101" translate="yes" xml:space="preserve">
          <source>Internet Explorer implements an older version of the specification.</source>
          <target state="translated">Internet Explorer는 이전 버전의 사양을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2d31f010bc67031ad3d938f2ce6fc47d86d8b274" translate="yes" xml:space="preserve">
          <source>Internet Explorer only supports clip paths defined by &lt;code&gt;url()&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer는 &lt;code&gt;url()&lt;/code&gt; 의해 정의 된 클립 경로 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cac2de5d3a7e0d4d1f8cabb71b2fd16e05d16d" translate="yes" xml:space="preserve">
          <source>Internet Explorer supports an earlier draft of CSS Scroll Snap without axis values.</source>
          <target state="translated">Internet Explorer는 축 값없이 CSS 초안의 초안을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0ae1a09f1a487e37bd7d948ff3009a1cd0fd031f" translate="yes" xml:space="preserve">
          <source>Internet Explorer's implementation differs from the specification.</source>
          <target state="translated">Internet Explorer의 구현은 사양과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="26cd1fe9380ea9565de1c2bd864a8690b0d56346" translate="yes" xml:space="preserve">
          <source>Interpolation Hints / Gradient Midpoints</source>
          <target state="translated">보간 힌트 / 그라디언트 중간 점</target>
        </trans-unit>
        <trans-unit id="3313fcf85704e25c9cf47d7f97eb4c1ae29fccfb" translate="yes" xml:space="preserve">
          <source>Interpolation of basic shapes</source>
          <target state="translated">기본 도형의 보간</target>
        </trans-unit>
        <trans-unit id="4a4a8d5d6c8fb0d81c46467beee99205c026b923" translate="yes" xml:space="preserve">
          <source>Interpolation of blend modes</source>
          <target state="translated">블렌드 모드 보간</target>
        </trans-unit>
        <trans-unit id="9b21711488363d652f10dd903450b89ea21cb58f" translate="yes" xml:space="preserve">
          <source>Interprets the counter symbols as digits in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Positional_notation&quot;&gt;place-value numbering system&lt;/a&gt;. The numeric system is similar to the &lt;code&gt;alphabetic&lt;/code&gt; system, described above. The main difference is that in the &lt;code&gt;alphabetic&lt;/code&gt; system, the first counter symbol given in the &lt;code&gt;symbols&lt;/code&gt; descriptor is interpreted as &lt;code&gt;1&lt;/code&gt;, the next as &lt;code&gt;2&lt;/code&gt;, and so on. However, in the numeric system, the first counter symbol is interpreted as 0, the next as &lt;code&gt;1&lt;/code&gt;, then &lt;code&gt;2&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Positional_notation&quot;&gt;장소 값 번호 매기기 시스템&lt;/a&gt; 에서 카운터 기호를 숫자로 해석합니다 . 숫자 시스템은 위에서 설명한 &lt;code&gt;alphabetic&lt;/code&gt; 시스템 과 유사합니다 . 주요 차이점은 &lt;code&gt;alphabetic&lt;/code&gt; 시스템에서 &lt;code&gt;symbols&lt;/code&gt; 설명자에 제공된 첫 번째 카운터 기호 는 &lt;code&gt;1&lt;/code&gt; 로 , 다음은 &lt;code&gt;2&lt;/code&gt; 등 으로 해석 된다는 것입니다. 그러나 숫자 시스템에서 첫 번째 카운터 기호는 0으로, 다음 카운터는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 등 으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="2646800f360d39d6c765db16777b558d99b6c535" translate="yes" xml:space="preserve">
          <source>Interprets the specified symbols as digits, to an alphabetic numbering system. If the characters &lt;code&gt;&quot;a&quot;&lt;/code&gt; to &lt;code&gt;&quot;z&quot;&lt;/code&gt; are specified as symbols in a counter style, with the &lt;code&gt;alphabetic&lt;/code&gt; system, then the first 26 counter representations will be &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;b&quot;&lt;/code&gt; upto &lt;code&gt;&quot;z&quot;&lt;/code&gt;. Until this point, the behavior is the same as that of the &lt;code&gt;symbolic&lt;/code&gt; system, described above. However, after &lt;code&gt;&quot;z&quot;&lt;/code&gt;, it will continue as &lt;code&gt;&quot;aa&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab&quot;&lt;/code&gt;, &lt;code&gt;&quot;ac&quot;&lt;/code&gt;&amp;hellip;</source>
          <target state="translated">지정된 기호를 알파벳 숫자 체계로 숫자로 해석합니다. 문자 경우 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 에 &lt;code&gt;&quot;z&quot;&lt;/code&gt; 와 대향 스타일로 지정된 기호 &lt;code&gt;alphabetic&lt;/code&gt; 에있어서, 다음 제 26 개 이의 표현 될 것이다 &lt;code&gt;&quot;a&quot;&lt;/code&gt; , &lt;code&gt;&quot;b&quot;&lt;/code&gt; 개까지 &lt;code&gt;&quot;z&quot;&lt;/code&gt; . 이 시점까지는 위에서 설명한 &lt;code&gt;symbolic&lt;/code&gt; 시스템 의 동작과 동일 합니다. 그러나 &lt;code&gt;&quot;z&quot;&lt;/code&gt; 뒤에는 &quot; &lt;code&gt;&quot;aa&quot;&lt;/code&gt; , &lt;code&gt;&quot;ab&quot;&lt;/code&gt; , &lt;code&gt;&quot;ac&quot;&lt;/code&gt; 로 계속됩니다 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="221ad5d9cf460323dd5acb798b113cea81f557b7" translate="yes" xml:space="preserve">
          <source>Intrinsic dimensions and proportions</source>
          <target state="translated">고유 치수 및 비율</target>
        </trans-unit>
        <trans-unit id="5fda894242cdc9c8cc6f32bd3d9329030a51f8b0" translate="yes" xml:space="preserve">
          <source>Intrinsic dimensions of contained images.</source>
          <target state="translated">포함 된 이미지의 고유 치수.</target>
        </trans-unit>
        <trans-unit id="5b3737cdc2139c258e86478caed3206a02bbcd9d" translate="yes" xml:space="preserve">
          <source>Intrinsic sizes</source>
          <target state="translated">고유 크기</target>
        </trans-unit>
        <trans-unit id="8808878638b7a85cab416e884165e84f5a9d3ada" translate="yes" xml:space="preserve">
          <source>Introduced in Media Queries Level 4 is a new range syntax that allows for less verbose media queries when testing for any feature accepting a range, as shown in the below examples:</source>
          <target state="translated">미디어 쿼리에 도입 된 수준 4는 아래 예제와 같이 범위를 허용하는 기능을 테스트 할 때보다 자세한 미디어 쿼리를 허용하는 새로운 범위 구문입니다.</target>
        </trans-unit>
        <trans-unit id="e1e07fa10fad1b352d112ceac5798bf70e971804" translate="yes" xml:space="preserve">
          <source>Introduces media queries, their syntax, and the operators and media features which are used to construct media query expressions.</source>
          <target state="translated">미디어 쿼리, 구문 및 미디어 쿼리 식을 구성하는 데 사용되는 연산자 및 미디어 기능을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="68f2446ddae1b7372b7e6dc2ad9b8e439bdcc880" translate="yes" xml:space="preserve">
          <source>Introduces no content, but increments (decrements) the level of nesting for quotes.</source>
          <target state="translated">내용을 소개하지 않지만 따옴표에 대한 중첩 수준을 증가 (감소)시킵니다.</target>
        </trans-unit>
        <trans-unit id="a4230f93f3f3f8dabe3a331312f68b7ad8096169" translate="yes" xml:space="preserve">
          <source>Introduces the two-colon syntax.</source>
          <target state="translated">두 콜론 구문을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f407486c3e584e24e0f52f16f83af2584f16358e" translate="yes" xml:space="preserve">
          <source>Introducing the 'variation axis'</source>
          <target state="translated">'변이 축'소개</target>
        </trans-unit>
        <trans-unit id="2f5ea559188b8b08d3d440077d6463782eaf8450" translate="yes" xml:space="preserve">
          <source>Introducing the CSS Cascade</source>
          <target state="translated">CSS 캐스케이드 소개</target>
        </trans-unit>
        <trans-unit id="c54e0676abaa94b45eca1c4ec2ebbdf6403a5638" translate="yes" xml:space="preserve">
          <source>Introducing the CSS cascade</source>
          <target state="translated">CSS 캐스케이드 소개</target>
        </trans-unit>
        <trans-unit id="92d630fd64c3c5569d32d352d4ee24c220afcce4" translate="yes" xml:space="preserve">
          <source>Introduction of the two-colon syntax.</source>
          <target state="translated">두 콜론 구문 소개.</target>
        </trans-unit>
        <trans-unit id="bdfb59c3fb4ec235a8d1c890364e3b5cf699a52e" translate="yes" xml:space="preserve">
          <source>Introduction of the two-colon syntax. Definition of edge-case behavior, such as in list items or with specific languages (e.g., the Dutch digraph &lt;code&gt;IJ&lt;/code&gt;).</source>
          <target state="translated">두 콜론 구문 소개. 목록 항목 또는 특정 언어 (예 : Dutch digraph &lt;code&gt;IJ&lt;/code&gt; ) 와 같은 엣지 케이스 동작의 정의 .</target>
        </trans-unit>
        <trans-unit id="98cda1e821e0ff23cd78a3fbca95288d5467f19d" translate="yes" xml:space="preserve">
          <source>Introduction to the CSS box model</source>
          <target state="translated">CSS 박스 모델 소개</target>
        </trans-unit>
        <trans-unit id="847c0b04f044aa4be68f460985c3a2ab786fa505" translate="yes" xml:space="preserve">
          <source>Introduction to the Fragmentation specification and how to control where column content breaks.</source>
          <target state="translated">조각화 사양 소개 및 열 내용이 중단되는 위치를 제어하는 ​​방법</target>
        </trans-unit>
        <trans-unit id="37c1de3465e9abe2f8935a87ce3d15cc5b5e2538" translate="yes" xml:space="preserve">
          <source>Invalid frequency values</source>
          <target state="translated">유효하지 않은 주파수 값</target>
        </trans-unit>
        <trans-unit id="a907c978cf02025a436cb2ded88edec7baf34ca7" translate="yes" xml:space="preserve">
          <source>Invalid identifiers</source>
          <target state="translated">잘못된 식별자</target>
        </trans-unit>
        <trans-unit id="9fd4a0c0f6df1a64ed4270d83aab58edf3120409" translate="yes" xml:space="preserve">
          <source>Invalid images</source>
          <target state="translated">잘못된 이미지</target>
        </trans-unit>
        <trans-unit id="e7224dbf7a2e4167347bd7696de923a9e215ea73" translate="yes" xml:space="preserve">
          <source>Invalid integers</source>
          <target state="translated">잘못된 정수</target>
        </trans-unit>
        <trans-unit id="77c1cc16611704a59399549cb81acf508886e300" translate="yes" xml:space="preserve">
          <source>Invalid numbers</source>
          <target state="translated">잘못된 숫자</target>
        </trans-unit>
        <trans-unit id="7d56a40a15debda68b04c4906b9fa1bd9ec0dd14" translate="yes" xml:space="preserve">
          <source>Invalid positions</source>
          <target state="translated">잘못된 위치</target>
        </trans-unit>
        <trans-unit id="0dc485d1120ba3f1dad6f199c2266aaabe1ba7ef" translate="yes" xml:space="preserve">
          <source>Invalid resolutions</source>
          <target state="translated">잘못된 해상도</target>
        </trans-unit>
        <trans-unit id="85f30696d7c8aa573f7cfbe56486376cc3f8fa5f" translate="yes" xml:space="preserve">
          <source>Invalid times</source>
          <target state="translated">잘못된 시간</target>
        </trans-unit>
        <trans-unit id="1ce475219883b98f3f6db1ffcb60e1e6df328af7" translate="yes" xml:space="preserve">
          <source>Inverting a query's meaning</source>
          <target state="translated">쿼리의 의미 반전</target>
        </trans-unit>
        <trans-unit id="20e71f49714a3ca3f4fc6a48777a29bbf8a47b43" translate="yes" xml:space="preserve">
          <source>Inverts the colors of the image.</source>
          <target state="translated">이미지의 색상을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="80035022ac880d2b9619ebceb62f930d2d26a003" translate="yes" xml:space="preserve">
          <source>Inverts the samples in the input image. The value of &lt;code&gt;amount&lt;/code&gt; defines the proportion of the conversion. A value of &lt;code&gt;100%&lt;/code&gt; is completely inverted. A value of &lt;code&gt;0%&lt;/code&gt; leaves the input unchanged. Values between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; are linear multipliers on the effect. The lacuna value for interpolation is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">입력 이미지의 샘플을 반전시킵니다. &lt;code&gt;amount&lt;/code&gt; 값은 전환 비율을 정의합니다. &lt;code&gt;100%&lt;/code&gt; 의 값 이 완전히 반전됩니다. 값이 &lt;code&gt;0%&lt;/code&gt; 이면 입력이 변경되지 않습니다. &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 값 은 효과에 대한 선형 승수입니다. 보간의 lacuna 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f076661ae0a0f3a9cd7cae05efeba4582fa7f592" translate="yes" xml:space="preserve">
          <source>Inverts which lines are indented. All lines &lt;em&gt;except&lt;/em&gt; the first line will be indented.</source>
          <target state="translated">들여 쓰기 된 줄을 반전시킵니다. 첫 번째 줄을 &lt;em&gt;제외한&lt;/em&gt; 모든 줄 이 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8712aeb00ec4ca126d4e47d72f74dae20b861a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;flex-basis&lt;/code&gt; a length unit, but not zero? If so this is the size of the item.</source>
          <target state="translated">인가 &lt;code&gt;flex-basis&lt;/code&gt; 길이 단위가 아닌 제로? 그렇다면이 크기는 항목의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="dcab060a56967efd26a14507b91cc969bd9c6244" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;flex-basis&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;? if so then the item size is not taken into consideration for the space-sharing calculation.</source>
          <target state="translated">가요 &lt;code&gt;flex-basis&lt;/code&gt; 로 설정 &lt;code&gt;0&lt;/code&gt; ? 그렇다면 공간 공유 계산을 위해 항목 크기가 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b642d741ad1e21de6ef544672912461852d2994f" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;flex-basis&lt;/code&gt; set to &lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;content&lt;/code&gt; (in a supporting browser)? If so, the size is based on the item size.</source>
          <target state="translated">가요 &lt;code&gt;flex-basis&lt;/code&gt; 로 설정 &lt;code&gt;auto&lt;/code&gt; 또는 &lt;code&gt;content&lt;/code&gt; (A 지원하는 브라우저에서)? 그렇다면 크기는 항목 크기를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="a2c8f7a2f7c847101c6c5ab5d7a30c782bce0865" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;flex-basis&lt;/code&gt; set to &lt;code&gt;auto&lt;/code&gt;, and does the item have a width set? If so, the size will be based on that width.</source>
          <target state="translated">인가 &lt;code&gt;flex-basis&lt;/code&gt; 세트에 &lt;code&gt;auto&lt;/code&gt; , 그리고 항목은 너비가 설정되어 있습니까? 그렇다면 크기는 해당 너비를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="2cb8e4d245eb8f5457b601b8a11ec4cdc65305d8" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the abscissa of the translating vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 가로 좌표를 나타내는.</target>
        </trans-unit>
        <trans-unit id="21774222895296de4b74f93599f65a6c50eed34f" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the ordinate of the translating vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 좌표를 나타내는.</target>
        </trans-unit>
        <trans-unit id="59eac5f4a03a2c969ca3c2680c906b8d10eb77af" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the abscissa (x-coordinate) of the translating vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 가로축 (x 좌표)를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="2f2dd62b7aef2e03706eae5582c9889226a62400" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the abscissa of the translating vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 횡축을 나타내는이.</target>
        </trans-unit>
        <trans-unit id="b8f428d29a9a7eecbce525027704bab292583f21" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the distance from the user to the z=0 plane. If it is 0 or a negative value, no perspective transform is applied.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 은 z = 0 평면에 대해 사용자로부터의 거리를 나타내는이. 값이 0이거나 음수이면 원근감 변환이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10d52ed0aa02ff48bbc1aed892c169b98e5d83b5" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the ordinate of the translating vector (or y-coordinate). If unspecified, its default value is &lt;code&gt;0&lt;/code&gt;. For example, &lt;code&gt;translate(2)&lt;/code&gt; is equivalent to &lt;code&gt;translate(2, 0)&lt;/code&gt;.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 좌표를 나타내는 (또는 Y 좌표). 지정되지 않은 경우 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;translate(2)&lt;/code&gt; 는 &lt;code&gt;translate(2, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd82818df278e295dbbca9fc8c8b10fd7b79a22a" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the ordinate of the translating vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 좌표를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="0be02a459d2445cfed0b8ee048f629b8391d08ec" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the z component of the translating vector. It can't be a &lt;a href=&quot;../percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; value; in that case the property containing the transform is considered invalid.</source>
          <target state="translated">A는 &lt;a href=&quot;../length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 병진 벡터의 Z 성분을 나타내는이. &lt;a href=&quot;../percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 값 이 될 수 없습니다 . 이 경우 변환을 포함하는 특성이 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="46518f1d49a382369d3f15e598b0a0618b3d7d2a" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; describing the x-coordinate of the vector denoting the axis of rotation which could between 0 and 1.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 묘화 회전축을 나타내는 벡터의 x 좌표 수있는 0과 1 사이.</target>
        </trans-unit>
        <trans-unit id="f18504912f967a02ab14c3a122f1aa48ec1f1c1a" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; describing the y-coordinate of the vector denoting the axis of rotation which could between 0 and 1.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 묘화 회전축을 나타내는 벡터의 Y 좌표되는 0과 1 사이 있었다.</target>
        </trans-unit>
        <trans-unit id="f3ebd9bc90b0aaabae3ec154bd1f98c27f4656b5" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; describing the z-coordinate of the vector denoting the axis of rotation which could between 0 and 1.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 묘화 회전축을 나타내는 벡터의 Z 좌표되는 0과 1 사이 있었다.</target>
        </trans-unit>
        <trans-unit id="54db5aec3a6e38961ff92d78e8977de080b25a2d" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the abscissa of the scaling vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 스케일링 벡터의 가로 좌표를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="de14ba04e260117d61c0196ba2786b8bef443e0d" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the ordinate of the scaling vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 스케일링 벡터의 좌표를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="4fc9f23d210bc09a77ad135d68fec748c094a488" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the scaling factor to apply on the abscissa of each point of the element.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 각 지점의 가로 좌표에 적용 할 배율 인수를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="1078a18a1b404b133d38192af690f4341b37b9ff" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the scaling factor to apply on the ordinate of each point of the element.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 각 지점의 좌표에 적용 할 배율 인수를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="8a143cc2b20a9c8fa4169889c2c02bf31a7ce0e0" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the scaling factor to apply on the z-coordinate of each point of the element.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 온 적용 할 스케일링 인자를 나타내는 요소의 각 점의 Z 좌표.</target>
        </trans-unit>
        <trans-unit id="2051ad1ee05ca01d276270c9971acead9fed6b78" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the z-component of the scaling vector.</source>
          <target state="translated">A는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; &lt;/a&gt; 스케일링 벡터의 z 성분을 나타내는이.</target>
        </trans-unit>
        <trans-unit id="e9e3f834b735c5627e9e489598d5f9484a0e9a6e" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;color_value&quot;&gt;&lt;code&gt;&amp;lt;color&amp;gt;&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">A는 &lt;a href=&quot;color_value&quot;&gt; &lt;code&gt;&amp;lt;color&amp;gt;&lt;/code&gt; &lt;/a&gt; 값.</target>
        </trans-unit>
        <trans-unit id="5a557dc64afa7db353a642704c58b54f918e279a" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; (and never a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; which would make the statement invalid) describing how far from the user eye the z=0 origin is set.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; (그리고 결코 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 문 무효를 만들 것)은 z = 0 원점이 설정되어 얼마나 사용자의 눈의 설명.</target>
        </trans-unit>
        <trans-unit id="7ca95a0f939c5a48f1816aa4353300b944ee122a" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in each corner of the border. It is used only in the one-value syntax.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 국경의 각 모서리에있는 국경에 사용할 반경을 나타내는. 하나의 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21fa2049d363dbe5c3f11b5199abd17f0d69c822" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the bottom-left corner of the element's box. It is used only in the four-value syntax.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 왼쪽 아래 모서리에있는 국경에 사용할 반경을 나타내는. 4 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce5753cadf6ef379883d15a065ed091ca9121d4" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the bottom-right corner of the element's box. It is used only in the three- and four-value syntaxes.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 오른쪽 아래 모서리에있는 국경에 사용할 반경을 나타내는. 3 값 및 4 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae396a5c6f05dd5fa8cab111ceb7f845f66b2fd" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the top-left and bottom-right corners of the element's box. It is used only in the two-value syntax.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 왼쪽 상단과 오른쪽 하단 모서리에있는 국경에 사용할 반경을 나타내는. 2 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4caa4048207f7740db5fedce950b593096add23" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the top-left corner of the element's box. It is used only in the three- and four-value syntaxes.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 왼쪽 상단 모서리에있는 국경에 사용할 반경을 나타내는. 3 값 및 4 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59761a9c1fa2ec26169927e844b70c5a16769d3f" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the top-right and bottom-left corners of the element's box. It is used only in the two- and three-value syntaxes.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 오른쪽 상단과 왼쪽 하단 모서리에 국경에 사용할 반경을 나타내는. 2 값 및 3 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc50f86b993c71c65cd68b2d481bd0c273637041" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting a radius to use for the border in the top-right corner of the element's box. It is used only in the four-value syntax.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 상자의 오른쪽 상단 모서리에있는 국경에 사용할 반경을 나타내는. 4 값 구문에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1133edbcef4a857aa4a139220084022eab03de4" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; describing how far from the left edge of the box the origin of the transform is set.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 설명 얼마나 박스의 좌측 에지가 설정된 변환의 원점부터.</target>
        </trans-unit>
        <trans-unit id="6d512df6ca36a365d56ff03a8fa067095ae86810" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; describing how far from the top edge of the box the origin of the transform is set.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 설명 얼마나 상자의 상단의 가장자리가 설정된 변환의 원점부터.</target>
        </trans-unit>
        <trans-unit id="13e981a7061a156ce02ca031dce78a8bf771a1bd" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or one of the three keywords, &lt;code&gt;thin&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;thick&lt;/code&gt;. See &lt;a href=&quot;border-width&quot;&gt;&lt;code&gt;border-width&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 세 개의 키워드 중 하나 &lt;code&gt;thin&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 또는 &lt;code&gt;thick&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;border-width&quot;&gt; &lt;code&gt;border-width&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ffcdb1799798c25e09be34b57c6ad0a6a4404ee3" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the offset for the bottom of the rectangle relative to the top border of the element's box.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; (가) 요소의 상자의 맨 국경 사각형 상대의 하단 오프셋 대표는.</target>
        </trans-unit>
        <trans-unit id="a7fc4d22b774e51f02966f9cceaf3aa61597b415" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the offset for the left of the rectangle relative to the left border of the element's box.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 하여 요소의 상자의 왼쪽 테두리의 직사각형 상대의 왼쪽 오프셋을 나타내는이.</target>
        </trans-unit>
        <trans-unit id="fe4dc6942f2e06493aced1146f522f32a114184c" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the offset for the right of the rectangle relative to the left border of the element's box.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; (가) 요소의 상자의 왼쪽 테두리의 직사각형 상대의 오른쪽 오프셋을 나타내는이.</target>
        </trans-unit>
        <trans-unit id="22eea78c2bb7efb6df9349c177263609905e5771" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the offset for the top of the rectangle relative to the top border of the element's box.</source>
          <target state="translated">A는 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; (가) 요소의 상자의 맨 국경 사각형 상대의 상단 오프셋 대표는.</target>
        </trans-unit>
        <trans-unit id="3b3bd1a099c391acea57f4d2628fb2fea31fcec8" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;string&quot;&gt;&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting the character encoding to be used. It must be the name of a web-safe character encoding defined in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA-registry&lt;/a&gt;, and must be double-quoted, following exactly one space character (U+0020), and immediately terminated with a semicolon. If several names are associated with an encoding, only the one marked with &lt;em&gt;preferred&lt;/em&gt; must be used.</source>
          <target state="translated">A는 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 사용하는 문자 인코딩을 나타내는이. &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA 레지스트리에&lt;/a&gt; 정의 된 웹 안전 문자 인코딩의 이름 이어야하며 정확히 하나의 공백 문자 (U + 0020) 다음에 큰 따옴표로 묶어야하며 세미콜론으로 즉시 종료해야합니다. 여러 이름이 인코딩과 연관되어 있으면 &lt;em&gt;선호&lt;/em&gt; 로 표시된 이름 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="286495b2290d6e9e8c1644a6b0f8b35db8be50f7" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;string&quot;&gt;&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;url&quot;&gt;&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the location of the resource to import. The URL may be absolute or relative. Note that the URL for a Mozilla package need not actually specify a file; it can just specify the package name and part, and the appropriate file is chosen automatically (e.g. &lt;strong&gt;chrome://communicator/skin/&lt;/strong&gt;). &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Tutorial/The_Chrome_URL&quot;&gt;See here&lt;/a&gt; for more information.</source>
          <target state="translated">A는 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;url&quot;&gt; &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; &lt;/a&gt; 가져올 수있는 자원의 위치를 나타내는. URL은 절대적이거나 상대적 일 수 있습니다. Mozilla 패키지의 URL은 실제로 파일을 지정할 필요는 없습니다. 패키지 이름과 부품 만 지정하면 적절한 파일이 자동으로 선택됩니다 (예 : &lt;strong&gt;chrome : // communicator / skin /&lt;/strong&gt; ). &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Tutorial/The_Chrome_URL&quot;&gt;자세한 내용은 여기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a06546fba781a193a9184b5d09f68ce8cc3be3e7" translate="yes" xml:space="preserve">
          <source>Is a &lt;a href=&quot;time&quot;&gt;&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting the amount of time the transition from the old value of a property to the new value should take. A time of &lt;code&gt;0s&lt;/code&gt; indicates that no transition will happen, that is the switch between the two states will be instantaneous. A negative value for the time renders the declaration invalid.</source>
          <target state="translated">A는 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; &lt;/a&gt; 새 값 속성의 이전 값으로의 전환을해야하는 시간을 나타내는. &lt;code&gt;0s&lt;/code&gt; 의 시간은 전환이 발생하지 않음을 나타냅니다. 즉, 두 상태 간 전환이 즉시 이루어집니다. 시간의 음수 값은 선언을 유효하지 않게합니다.</target>
        </trans-unit>
        <trans-unit id="1d111fe65724885c909f7b0a8f0ae92e5c12e68c" translate="yes" xml:space="preserve">
          <source>Is a comma-separated list of &lt;a href=&quot;media_queries/using_media_queries&quot;&gt;media queries&lt;/a&gt; conditioning the application of the CSS rules defined in the linked URL. If the browser does not support any these queries, it does not load the linked resource.</source>
          <target state="translated">링크 된 URL에 정의 된 CSS 규칙의 적용을 조정 하는 쉼표로 구분 된 &lt;a href=&quot;media_queries/using_media_queries&quot;&gt;미디어 쿼리&lt;/a&gt; 목록입니다 . 브라우저가 이러한 쿼리를 지원하지 않으면 연결된 리소스를로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad57bbcf68cf5ec61e863fee9f67f7f040c5f4e7" translate="yes" xml:space="preserve">
          <source>Is a functional notation that defines a size range greater than or equal to &lt;em&gt;min&lt;/em&gt; and less than or equal to &lt;em&gt;max&lt;/em&gt;. If &lt;em&gt;max&lt;/em&gt; is smaller than &lt;em&gt;min&lt;/em&gt;, then &lt;em&gt;max&lt;/em&gt; is ignored and the function is treated as &lt;em&gt;min&lt;/em&gt;. As a maximum, a &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; value sets the track&amp;rsquo;s flex factor. As a minimum, it is treated as zero (or minimal content, if the grid container is sized under a minimal content constraint).</source>
          <target state="translated">&lt;em&gt;min&lt;/em&gt; 이상 &lt;em&gt;max&lt;/em&gt; 이하 의 크기 범위를 정의하는 기능 표기법입니다 . 경우 &lt;em&gt;맥스&lt;/em&gt; 보다 작은 &lt;em&gt;분&lt;/em&gt; 후 &lt;em&gt;최대&lt;/em&gt; 무시되고 함수로 처리된다 &lt;em&gt;분&lt;/em&gt; . 최대 값 으로 &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; 값은 트랙의 플렉스 팩터를 설정합니다. 최소값으로 0으로 처리됩니다 (또는 그리드 컨테이너의 크기가 최소 컨텐츠 제한 조건 인 경우 최소 컨텐츠).</target>
        </trans-unit>
        <trans-unit id="120fe4eaa575766461b10fa15bed9c507d9e8e09" translate="yes" xml:space="preserve">
          <source>Is a functional notation that defines a size range greater than or equal to &lt;em&gt;min&lt;/em&gt; and less than or equal to &lt;em&gt;max&lt;/em&gt;. If &lt;em&gt;max&lt;/em&gt; is smaller than &lt;em&gt;min&lt;/em&gt;, then &lt;em&gt;max&lt;/em&gt; is ignored and the function is treated as &lt;em&gt;min&lt;/em&gt;. As a maximum, a &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; value sets the track&amp;rsquo;s flex factor. It is invalid as a minimum.</source>
          <target state="translated">&lt;em&gt;min&lt;/em&gt; 이상 &lt;em&gt;max&lt;/em&gt; 이하 의 크기 범위를 정의하는 기능 표기법입니다 . 경우 &lt;em&gt;맥스&lt;/em&gt; 보다 작은 &lt;em&gt;분&lt;/em&gt; 후 &lt;em&gt;최대&lt;/em&gt; 무시되고 함수로 처리된다 &lt;em&gt;분&lt;/em&gt; . 최대 값 으로 &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; 값은 트랙의 플렉스 팩터를 설정합니다. 최소 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e789b4f30f6cb491da7145ca43ecab8095585058" translate="yes" xml:space="preserve">
          <source>Is a functional notation that defines a size range, greater than or equal to &lt;em&gt;min&lt;/em&gt;, and less than or equal to &lt;em&gt;max&lt;/em&gt;. If &lt;em&gt;max&lt;/em&gt; is smaller than &lt;em&gt;min&lt;/em&gt;, then &lt;em&gt;max&lt;/em&gt; is ignored and the function is treated as &lt;em&gt;min&lt;/em&gt;. As a maximum, a &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; value sets the track&amp;rsquo;s flex factor. It is invalid as a minimum.</source>
          <target state="translated">크기 범위를 &lt;em&gt;min&lt;/em&gt; 이상 또는 &lt;em&gt;max&lt;/em&gt; 이하로 정의하는 기능 표기법입니다 . 경우 &lt;em&gt;맥스&lt;/em&gt; 보다 작은 &lt;em&gt;분&lt;/em&gt; 후 &lt;em&gt;최대&lt;/em&gt; 무시되고 함수로 처리된다 &lt;em&gt;분&lt;/em&gt; . 최대 값 으로 &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; 값은 트랙의 플렉스 팩터를 설정합니다. 최소 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20a6526f9695b4d2cd33a95647961ea00fc20a60" translate="yes" xml:space="preserve">
          <source>Is a keyword defined by &lt;a href=&quot;border-style&quot;&gt;&lt;code&gt;border-style&lt;/code&gt;&lt;/a&gt; describing the style of the rule. The styling must be interpreted as in the collapsing border model.</source>
          <target state="translated">규칙 &lt;a href=&quot;border-style&quot;&gt; &lt;code&gt;border-style&lt;/code&gt; &lt;/a&gt; 설명하는 테두리 스타일로 정의 된 키워드 입니다. 스타일링은 접는 테두리 모델에서와 같이 해석되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5e1e202ac4d459c1cf6a41182bc3b4098c1f030" translate="yes" xml:space="preserve">
          <source>Is a keyword defined by &lt;a href=&quot;border-width&quot;&gt;&lt;code&gt;border-width&lt;/code&gt;&lt;/a&gt; describing the width of the rule. It may be either a &lt;a href=&quot;length&quot;&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;&lt;/a&gt; or one of the &lt;code&gt;thin&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;thick&lt;/code&gt; keywords.</source>
          <target state="translated">규칙의 너비를 설명하는 &lt;a href=&quot;border-width&quot;&gt; &lt;code&gt;border-width&lt;/code&gt; 로&lt;/a&gt; 정의 된 키워드 입니다. 그것은 이어도 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 하나의 &lt;code&gt;thin&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 또는 &lt;code&gt;thick&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="e72b3f4cd7ee0738bf1123e15c4efcf90dfc8ac2" translate="yes" xml:space="preserve">
          <source>Is a keyword denoting the absence of images.</source>
          <target state="translated">이미지가 없음을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="d34e88a3a947617a3f900d7976651df64c447855" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating if it the function is &lt;a href=&quot;https://en.wikipedia.org/wiki/Left-continuous#Directional_and_semi-continuity&quot;&gt;left- or right-continuous&lt;/a&gt;:</source>
          <target state="translated">함수가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Left-continuous#Directional_and_semi-continuity&quot;&gt;왼쪽 또는 오른쪽 연속인지&lt;/a&gt; 나타내는 키워드입니다 .</target>
        </trans-unit>
        <trans-unit id="3abf6c9e2e39a5e5fdc908ab6dae1b641b8c4ab3" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the associated mask image is a luminance mask, i.e., that its &lt;a href=&quot;https://en.wikipedia.org/wiki/Luminance_%28relative%29&quot;&gt;relative luminance&lt;/a&gt; values must be used when applying it.</source>
          <target state="translated">연관된 마스크 이미지가 휘도 마스크임을 나타내는 키워드입니다. 즉, 적용 할 때 &lt;a href=&quot;https://en.wikipedia.org/wiki/Luminance_%28relative%29&quot;&gt;상대 휘도&lt;/a&gt; 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="460aaa8b49b03ce6ab6f604df48de1fa7335049d" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the associated mask image is an alpha mask, i.e., that its &lt;a href=&quot;https://en.wikipedia.org/wiki/Alpha_compositing&quot;&gt;alpha channel&lt;/a&gt; values must be used when applying it.</source>
          <target state="translated">연결된 마스크 이미지가 알파 마스크임을 나타내는 키워드입니다. 즉, 적용 할 때 &lt;a href=&quot;https://en.wikipedia.org/wiki/Alpha_compositing&quot;&gt;알파 채널&lt;/a&gt; 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3cc5ff706e3dc2b747ba85f0ceb2346c3c51b6d" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is &lt;em&gt;not&lt;/em&gt; moved down to clear past floating elements.</source>
          <target state="translated">떠 다니는 요소를 지울 때 요소가 아래로 이동 &lt;em&gt;하지 않음을&lt;/em&gt; 나타내는 키워드 입니다.</target>
        </trans-unit>
        <trans-unit id="114951bc0d777052ff4853d68c78ade87b73a02d" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is moved down to clear floats on &lt;em&gt;end side of its containing block&lt;/em&gt;, that is the &lt;em&gt;right&lt;/em&gt; floats on ltr scripts and the &lt;em&gt;left&lt;/em&gt; floats on rtl scripts.</source>
          <target state="translated">요소가에 명확 수레 아래로 이동을 나타내는 키워드가 &lt;em&gt;그 용기 블럭의 끝 쪽&lt;/em&gt; 은 IS, &lt;em&gt;바로&lt;/em&gt; LTR 스크립트와의 수레 &lt;em&gt;왼쪽&lt;/em&gt; RTL 스크립트에 수레.</target>
        </trans-unit>
        <trans-unit id="407cc57f0482f7370e01363868c3fa8564b116b8" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is moved down to clear floats on &lt;em&gt;start side of its containing block&lt;/em&gt;, that is the &lt;em&gt;left&lt;/em&gt; floats on ltr scripts and the &lt;em&gt;right&lt;/em&gt; floats on rtl scripts.</source>
          <target state="translated">요소가 &lt;em&gt;포함 블록의 시작면에서&lt;/em&gt; float를 지우도록 아래로 이동했음을 나타내는 키워드입니다. 즉, ltr 스크립트 에서 &lt;em&gt;왼쪽&lt;/em&gt; floats이고 rtl 스크립트 에서 &lt;em&gt;오른쪽&lt;/em&gt; float입니다.</target>
        </trans-unit>
        <trans-unit id="19a22e5cc7afadf00816d9f79df2c1b4281c1262" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is moved down to clear past &lt;em&gt;both&lt;/em&gt; left and right floats.</source>
          <target state="translated">요소가지나 취소 아래로 이동을 나타내는 키워드가 &lt;em&gt;모두&lt;/em&gt; 왼쪽과 오른쪽 수레.</target>
        </trans-unit>
        <trans-unit id="c30e2e76c487e1c819dbf594c29b86a7310bc219" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is moved down to clear past &lt;em&gt;left&lt;/em&gt; floats.</source>
          <target state="translated">&lt;em&gt;왼쪽&lt;/em&gt; 플로트를 지나서 요소를 아래로 이동했음을 나타내는 키워드 입니다.</target>
        </trans-unit>
        <trans-unit id="c33563b848d7237ce8a6cc397dfd628bac6543c4" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the element is moved down to clear past &lt;em&gt;right&lt;/em&gt; floats.</source>
          <target state="translated">&lt;em&gt;오른쪽&lt;/em&gt; 수레를 지나서 요소를 아래로 이동했음을 나타내는 키워드 입니다.</target>
        </trans-unit>
        <trans-unit id="a07bd44de3e0e8f206276d2eb47056a01a83a93f" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the extra space will be distributed between the elements of the ruby, and around it.</source>
          <target state="translated">추가 공간이 루비의 요소 사이와 그 주위에 분산됨을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="0610afe926af0312a716667dd8c4c8fec1f75b13" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the extra space will be distributed between the elements of the ruby.</source>
          <target state="translated">여분의 공간이 루비의 요소 사이에 분배됨을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="b6595710d37ffd930deb661e441de44d9d73d448" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the property contributes nothing to the grid item&amp;rsquo;s placement, indicating auto-placement or a default span of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">속성이 그리드 항목의 배치에 아무 것도 기여하지 않음을 나타내는 키워드이며, 자동 배치 또는 기본 범위는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc67f67ee78b0a4ab3d5a073848868e7a1ce3db3" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the property contributes nothing to the grid item&amp;rsquo;s placement, indicating auto-placement, an automatic span, or a default span of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">속성이 그리드 항목의 배치에 아무 것도 기여하지 않음을 나타내는 키워드이며, 자동 배치, 자동 범위 또는 기본 범위는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0b8be4d7bd60b8d6c26ac2837b21fb32eb159f4" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the ruby has to be placed between the different characters.</source>
          <target state="translated">루비를 다른 문자 사이에 배치해야 함을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="86d4f3851cc4152c830cde3e5587a8bd7d946e4c" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the ruby has to be placed over the main text for horizontal scripts and right to it for vertical scripts.</source>
          <target state="translated">가로 스크립트의 경우 루비가 기본 텍스트 위에 있고 세로 스크립트의 경우 루비가 있어야 함을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="68c59da3a0f8d1b928a2ee02e9b1485c5af9d6a5" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the ruby has to be placed under the main text for horizontal scripts and left to it for vertical scripts.</source>
          <target state="translated">가로 스크립트의 경우 루비가 기본 텍스트 아래에 있고 세로 스크립트의 경우 루비가 있어야 함을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="bfbb6216fd67bac1b8e6981f8ef95bda410d2627" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the ruby will be aligned at the middle of the base text.</source>
          <target state="translated">루비가 기본 텍스트의 중간에 정렬됨을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="f07f04e24f1e10d98164064d4e83d477607b13dc" translate="yes" xml:space="preserve">
          <source>Is a keyword indicating that the ruby will be aligned with the start of the base text.</source>
          <target state="translated">루비가 기본 텍스트의 시작과 정렬됨을 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="561b4115d3680871d66d7c3d06bf0c929be56693" translate="yes" xml:space="preserve">
          <source>Is a keyword meaning that there is no explicit grid. Any columns will be implicitly generated and their size will be determined by the &lt;a href=&quot;grid-auto-columns&quot;&gt;&lt;code&gt;grid-auto-columns&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">명시 적 그리드가 없음을 의미하는 키워드입니다. 모든 열은 암시 적으로 생성되며 그 크기는 &lt;a href=&quot;grid-auto-columns&quot;&gt; &lt;code&gt;grid-auto-columns&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bab374224af3353a4d8d3907335e894a22fae28c" translate="yes" xml:space="preserve">
          <source>Is a keyword meaning that there is no explicit grid. Any rows will be implicitly generated and their size will be determined by the &lt;a href=&quot;grid-auto-rows&quot;&gt;&lt;code&gt;grid-auto-rows&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">명시 적 그리드가 없음을 의미하는 키워드입니다. 모든 행은 내재적으로 생성되며 그 크기는 &lt;a href=&quot;grid-auto-rows&quot;&gt; &lt;code&gt;grid-auto-rows&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e25ac411bcf3317eb776d1dc3a38bd3315f263db" translate="yes" xml:space="preserve">
          <source>Is a keyword representing either the type of the attribute's value, or its unit, as in HTML some attributes have implicit units. If the use of &lt;code&gt;&amp;lt;type-or-unit&amp;gt;&lt;/code&gt; as a value for the given attribute is invalid, the &lt;code&gt;attr()&lt;/code&gt; expression will be invalid too. If omitted, it defaults to &lt;code&gt;string&lt;/code&gt;. The list of valid values are:</source>
          <target state="translated">HTML에서와 같이 일부 속성에는 암시 적 단위가있는 속성 값의 유형 또는 해당 단위를 나타내는 키워드입니다. 지정된 속성의 값 으로 &lt;code&gt;&amp;lt;type-or-unit&amp;gt;&lt;/code&gt; 을 사용하는 것이 유효하지 않으면 &lt;code&gt;attr()&lt;/code&gt; 표현식도 유효하지 않습니다. 생략하면 기본값은 &lt;code&gt;string&lt;/code&gt; 입니다. 유효한 값 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfa33a418965c088b85166e03324297d0ca1f518" translate="yes" xml:space="preserve">
          <source>Is a keyword representing the largest maximal content contribution of the grid items occupying the grid track.</source>
          <target state="translated">그리드 트랙을 차지하는 그리드 항목의 최대 컨텐츠 기여도를 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="cb26610cb210d230dd0c08b0ff8e3ea4bae4cf5d" translate="yes" xml:space="preserve">
          <source>Is a keyword representing the largest minimal content contribution of the grid items occupying the grid track.</source>
          <target state="translated">그리드 트랙을 차지하는 그리드 항목의 최소 컨텐츠 기여도를 나타내는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="797235e54af49dbd28484e8f696c1af3d43a27a3" translate="yes" xml:space="preserve">
          <source>Is a keyword specifying that the auto-placement algorithm places items, by filling each column in turn, adding new columns as necessary.</source>
          <target state="translated">자동 배치 알고리즘이 각 열을 차례로 채우고 필요에 따라 새 열을 추가하여 항목을 배치하도록 지정하는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="76408cc0571ff85e4248bca88af0688864ea31be" translate="yes" xml:space="preserve">
          <source>Is a keyword specifying that the auto-placement algorithm places items, by filling each row in turn, adding new rows as necessary. If neither &lt;code&gt;row&lt;/code&gt; nor &lt;code&gt;column&lt;/code&gt; is provided, &lt;code&gt;row&lt;/code&gt; is assumed.</source>
          <target state="translated">자동 배치 알고리즘이 각 행을 차례로 채우고 필요에 따라 새 행을 추가하여 항목을 배치하도록 지정하는 키워드입니다. &lt;code&gt;row&lt;/code&gt; 과 &lt;code&gt;column&lt;/code&gt; 이 제공 되지 않으면 &lt;code&gt;row&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe7f56d1933b10fc64a91a2758f59c35acf3f15" translate="yes" xml:space="preserve">
          <source>Is a keyword specifying that the auto-placement algorithm uses a &amp;ldquo;dense&amp;rdquo; packing algorithm, which attempts to fill in holes earlier in the grid, if smaller items come up later. This may cause items to appear out-of-order, when doing so would fill in holes left by larger items.</source>
          <target state="translated">자동 배치 알고리즘이 &quot;밀도가 높은&quot;패킹 알고리즘을 사용하도록 지정하는 키워드입니다.이 알고리즘은 작은 항목이 나중에 나올 경우 그리드의 초기에 구멍을 채우려 고합니다. 이로 인해 품목이 고장난 것처럼 보일 수 있으며, 큰 품목이 남은 구멍을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94726b509a187a96238a5b78ec249cc68fc7005" translate="yes" xml:space="preserve">
          <source>Is a keyword that converts all characters to lowercase.</source>
          <target state="translated">모든 문자를 소문자로 변환하는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="0d5410fdaf8d9277fb2fab6eccc9747d5fe10a00" translate="yes" xml:space="preserve">
          <source>Is a keyword that converts all characters to uppercase.</source>
          <target state="translated">모든 문자를 대문자로 변환하는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="5cb25ba4e0cae1c491d0f55950d62a51f1c3cd8d" translate="yes" xml:space="preserve">
          <source>Is a keyword that converts the first &lt;em&gt;letter&lt;/em&gt; of each word to uppercase. Other characters remain unchanged (they retain their original case as written in the element's text). A letter is defined as a character that is part of Unicode's Letter or Number general categories ; thus, any punctuation marks or symbols at the beginning of a word are ignored.</source>
          <target state="translated">각 단어 의 첫 &lt;em&gt;글자&lt;/em&gt; 를 대문자 로 변환하는 키워드입니다 . 다른 문자는 변경되지 않은 상태로 유지됩니다 (요소의 텍스트에 기록 된대로 원래 대소 문자를 유지함). 문자는 유니 코드의 문자 또는 숫자 일반 범주의 일부인 문자로 정의됩니다. 따라서 단어의 시작 부분에있는 문장 부호 나 기호는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e55746b5a95baeb0d8127ec283391f8e91be4e" translate="yes" xml:space="preserve">
          <source>Is a keyword that forces the writing of a character &amp;mdash; mainly ideograms and Latin scripts &amp;mdash; inside a square, allowing them to be aligned in the usual East Asian scripts (like Chinese or Japanese).</source>
          <target state="translated">정사각형 안에 문자 (주로 표의 문자 및 라틴 문자)를 쓰도록하는 키워드로, 일반적인 동아시아 문자 (중국어 또는 일본어)로 정렬 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c855f87cfb38863b632809738cdf5d0b99f7c0" translate="yes" xml:space="preserve">
          <source>Is a keyword that is identical to maximal content if it's a maximum. As a minimum it represents the largest minimum size (as specified by &lt;a href=&quot;min-width&quot;&gt;&lt;code&gt;min-width&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;min-height&quot;&gt;&lt;code&gt;min-height&lt;/code&gt;&lt;/a&gt;) of the grid items occupying the grid track.</source>
          <target state="translated">최대 콘텐츠 인 경우 최대 콘텐츠와 동일한 키워드입니다. 최소값 은 그리드 트랙을 차지하는 그리드 항목 의 최대 최소 크기 (최소 &lt;a href=&quot;min-width&quot;&gt; &lt;code&gt;min-width&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;min-height&quot;&gt; &lt;code&gt;min-height&lt;/code&gt; &lt;/a&gt; 로 지정됨)를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="56ae719dda10bba3e085a0b20c5cafd50ef75fad" translate="yes" xml:space="preserve">
          <source>Is a keyword that prevents the case of all characters from being changed.</source>
          <target state="translated">모든 문자의 대소 문자가 변경되지 않도록하는 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="ee98174de78d55f7de137a0ad5c49e70ed8fdb6a" translate="yes" xml:space="preserve">
          <source>Is a keyword that sets all three longhand properties to &lt;code&gt;none&lt;/code&gt;, meaning there is no explicit grid. There are no named grid areas. Rows and columns will be implicitly generated; their size will be determined by the &lt;a href=&quot;grid-auto-rows&quot;&gt;&lt;code&gt;grid-auto-rows&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;grid-auto-columns&quot;&gt;&lt;code&gt;grid-auto-columns&lt;/code&gt;&lt;/a&gt; properties.</source>
          <target state="translated">세 개의 longhand 속성을 &lt;code&gt;none&lt;/code&gt; 으로 설정하는 키워드입니다 . 즉, 명시 적 그리드가 없습니다. 명명 된 그리드 영역이 없습니다. 행과 열은 내재적으로 생성됩니다. 크기는 &lt;a href=&quot;grid-auto-rows&quot;&gt; &lt;code&gt;grid-auto-rows&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;grid-auto-columns&quot;&gt; &lt;code&gt;grid-auto-columns&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2dca3ae15cdebc0b3afb691bef8acff76451f2e8" translate="yes" xml:space="preserve">
          <source>Is a non-negative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; value relative to the block size of the grid container. If the block size of the grid container is indefinite, the percentage value is treated like &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">그리드 컨테이너의 블록 크기에 대한 음이 아닌 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 값입니다. 그리드 컨테이너의 블록 크기가 무한하면 백분율 값은 &lt;code&gt;auto&lt;/code&gt; 처럼 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="9028971555f7aa60f91a89128a2827e816a12d02" translate="yes" xml:space="preserve">
          <source>Is a non-negative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; value relative to the inline size of the grid container. If the size of the grid container depends on the size of its tracks, then the percentage must be treated as &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">그리드 컨테이너의 인라인 크기를 기준으로 음이 아닌 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 값입니다. 그리드 컨테이너의 크기가 트랙의 크기에 의존하는 경우 백분율을 &lt;code&gt;auto&lt;/code&gt; 로 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dc2c50fa749cf2f5d76f21abaedfde80a80acbc5" translate="yes" xml:space="preserve">
          <source>Is a non-negative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; value, relative to the block size of the grid container. If the size of the grid container depends on the size of its tracks, then the percentage must be treated as &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">그리드 컨테이너의 블록 크기를 기준으로 음이 아닌 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 값입니다. 그리드 컨테이너의 크기가 트랙의 크기에 의존하는 경우 백분율을 &lt;code&gt;auto&lt;/code&gt; 로 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd11e5207e57e89ba6492db66b6b4aded874f039" translate="yes" xml:space="preserve">
          <source>Is a non-negative dimension with the unit &lt;code&gt;fr&lt;/code&gt; specifying the track&amp;rsquo;s flex factor. Each &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt;-sized track takes a share of the remaining space in proportion to its flex factor.</source>
          <target state="translated">트랙의 플렉스 팩터를 지정하는 단위 &lt;code&gt;fr&lt;/code&gt; 과 함께 음이 아닌 치수입니다 . 각 &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; 크기의 트랙은 플렉스 팩터에 비례하여 나머지 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="8a97abbdd5f8b3e698764bf4db7f2db19198761d" translate="yes" xml:space="preserve">
          <source>Is a non-negative dimension with the unit &lt;code&gt;fr&lt;/code&gt; specifying the track&amp;rsquo;s flex factor. Each &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt;-sized track takes a share of the remaining space in proportion to its flex factor. When appearing outside a &lt;code&gt;minmax()&lt;/code&gt; notation, it implies an automatic minimum (i.e. &lt;code&gt;minmax(auto, &amp;lt;flex&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">트랙의 플렉스 팩터를 지정하는 단위 &lt;code&gt;fr&lt;/code&gt; 과 함께 음이 아닌 치수입니다 . 각 &lt;code&gt;&amp;lt;flex&amp;gt;&lt;/code&gt; 크기의 트랙은 플렉스 팩터에 비례하여 나머지 공간을 차지합니다. &lt;code&gt;minmax()&lt;/code&gt; 표기법 외부에 나타날 때는 자동 최소값을 의미합니다 (예 : &lt;code&gt;minmax(auto, &amp;lt;flex&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eaa03c2c089e69390574009bc29af693a329322f" translate="yes" xml:space="preserve">
          <source>Is a non-negative length.</source>
          <target state="translated">음수가 아닌 길이입니다.</target>
        </trans-unit>
        <trans-unit id="9230471c89460fbc268e8a93abe1379ab71dabed" translate="yes" xml:space="preserve">
          <source>Is a strictly positive &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;&lt;/a&gt; describing the ideal number of columns into which the content of the element will be flowed. If the &lt;a href=&quot;column-width&quot;&gt;&lt;code&gt;column-width&lt;/code&gt;&lt;/a&gt; is also set to a non-&lt;code&gt;auto&lt;/code&gt; value, it merely indicates the maximum allowed number of columns.</source>
          <target state="translated">요소의 내용이 흐르는 이상적인 열 수를 설명 하는 엄격하게 양의 &lt;a href=&quot;integer&quot;&gt; &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;column-width&quot;&gt; &lt;code&gt;column-width&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;auto&lt;/code&gt; 이 아닌 값으로 설정된 경우에는 최대 허용 열 수만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50a624bd11d22f881dcf34f8a22eb687692639ed" translate="yes" xml:space="preserve">
          <source>Is a strictly positive &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;&lt;/a&gt;, representing the amount of equidistant intervals composing the stepping function.</source>
          <target state="translated">스테핑 함수를 구성하는 등거리 간격의 양을 나타내는 엄격하게 양의 &lt;a href=&quot;integer&quot;&gt; &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1dff28b30f47bb1dbe2c5a253787a8faa9ae9b79" translate="yes" xml:space="preserve">
          <source>Is a strictly positive &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;&lt;/a&gt;, representing the amount of equidistant treads composing the stepping function.</source>
          <target state="translated">스테핑 기능을 구성하는 등거리 트레드의 양을 나타내는 엄격하게 양의 &lt;a href=&quot;integer&quot;&gt; &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be8627c55f2448ca1c41fd8ba2d719b6dbfbd9d8" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;khmer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;khmer&lt;/code&gt; 의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="5c2cf2da35dc3e2375b1a32c6c6ca2c5549e6665" translate="yes" xml:space="preserve">
          <source>Is an &lt;a href=&quot;../angle&quot;&gt;&lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the angle of the rotation. A positive angle denotes a clockwise rotation, a negative angle a counter-clockwise one.</source>
          <target state="translated">는 &lt;a href=&quot;../angle&quot;&gt; &lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt; &lt;/a&gt; 회전 각도를 나타내는이. 양의 각도는 시계 방향 회전을, 음의 각도는 시계 반대 방향을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f192728f7df26e7f34dbbebf6b07630139b32dd2" translate="yes" xml:space="preserve">
          <source>Is an &lt;a href=&quot;../angle&quot;&gt;&lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the angle to use to distort the element along the abscissa.</source>
          <target state="translated">는 &lt;a href=&quot;../angle&quot;&gt; &lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt; &lt;/a&gt; 횡축 소자 왜곡에 사용하는 각도를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="a4a53a1d585e2bba3116c84390a7e8d6cf2bd15b" translate="yes" xml:space="preserve">
          <source>Is an &lt;a href=&quot;../angle&quot;&gt;&lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the angle to use to distort the element along the ordinate.</source>
          <target state="translated">는 &lt;a href=&quot;../angle&quot;&gt; &lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt; &lt;/a&gt; 세로축 소자 왜곡에 사용하는 각도를 나타내는이.</target>
        </trans-unit>
        <trans-unit id="d9b7b161a573169f5e888cf6444ea1c67fec8a4d" translate="yes" xml:space="preserve">
          <source>Is an &lt;a href=&quot;../angle&quot;&gt;&lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the angle to use to distort the element along the ordinate. If not defined, its default value is &lt;code&gt;0&lt;/code&gt;, resulting in a purely horizontal skewing.</source>
          <target state="translated">는 &lt;a href=&quot;../angle&quot;&gt; &lt;code&gt;&amp;lt;angle&amp;gt;&lt;/code&gt; &lt;/a&gt; 세로축 소자 왜곡에 사용하는 각도를 나타내는이. 정의되지 않은 경우 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 완전히 수평으로 치우칩니다.</target>
        </trans-unit>
        <trans-unit id="8179d2327d68c1eb00a5f6029249135809fcf242" translate="yes" xml:space="preserve">
          <source>Is an &lt;a href=&quot;image&quot;&gt;&lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt;&lt;/a&gt; denoting the image to display. There can be several of them, separated by commas, as &lt;a href=&quot;multiple_backgrounds&quot;&gt;multiple backgrounds&lt;/a&gt; are supported.</source>
          <target state="translated">이다 &lt;a href=&quot;image&quot;&gt; &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; &lt;/a&gt; 표시 화상을 나타내는이. &lt;a href=&quot;multiple_backgrounds&quot;&gt;여러 배경&lt;/a&gt; 이 지원 되므로 쉼표로 구분하여 여러 개가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6588799b28ebce2484f0d8dfcd9458d120b61396" translate="yes" xml:space="preserve">
          <source>Is any available input mechanism a pointing device, and if so, how accurate is it?</source>
          <target state="translated">사용 가능한 입력 메커니즘이 포인팅 장치입니까? 그렇다면 정확합니까?</target>
        </trans-unit>
        <trans-unit id="969954b7cccc1b71f17f4b5c0bcb8bc32f3c8eac" translate="yes" xml:space="preserve">
          <source>Is it a CORS issue?</source>
          <target state="translated">CORS 문제입니까?</target>
        </trans-unit>
        <trans-unit id="a967a72b1fdaa992f4826524b96c3ea51db32699" translate="yes" xml:space="preserve">
          <source>Is it safe to use CSS grids for my layout?</source>
          <target state="translated">레이아웃에 CSS 그리드를 사용하는 것이 안전합니까?</target>
        </trans-unit>
        <trans-unit id="1ceaa92a802c58fbc9e995c53fe681fc43734b79" translate="yes" xml:space="preserve">
          <source>Is one of the &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, or &lt;code&gt;center&lt;/code&gt; keyword describing the corresponding offset.</source>
          <target state="translated">해당 오프셋을 설명하는 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; 또는 &lt;code&gt;center&lt;/code&gt; 키워드 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="fb2f14fda905660cc1bcf7484ae8ccd4863fcf21" translate="yes" xml:space="preserve">
          <source>Is one of the &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;center&lt;/code&gt; keyword describing how far from the left edge of the box the origin of the transform is set.</source>
          <target state="translated">변환의 원점이 설정된 상자의 왼쪽 가장자리에서 얼마나 멀리 떨어져 있는지 설명하는 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 또는 &lt;code&gt;center&lt;/code&gt; 키워드 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="94469d73ee5983305f97b12c18ea5e57ecca0b58" translate="yes" xml:space="preserve">
          <source>Is one of the &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, or &lt;code&gt;center&lt;/code&gt; keyword describing how far from the top edge of the box the origin of the transform is set.</source>
          <target state="translated">변환의 원점이 설정된 상자의 위쪽 가장자리에서 얼마나 멀리 떨어져 있는지 설명하는 &lt;code&gt;top&lt;/code&gt; , &lt;code&gt;bottom&lt;/code&gt; 또는 &lt;code&gt;center&lt;/code&gt; 키워드 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="fe4bdafd5b1e10460b4d4ab525eab19d0eaf52f0" translate="yes" xml:space="preserve">
          <source>Is the name of an attribute on the HTML element referenced in the CSS.</source>
          <target state="translated">CSS에서 참조하는 HTML 요소의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d0c0ff04de8fe38db9e59acf91b08b5aa8a40fbf" translate="yes" xml:space="preserve">
          <source>Is the primary input mechanism a pointing device, and if so, how accurate is it?</source>
          <target state="translated">기본 입력 메커니즘이 포인팅 장치입니까? 그렇다면 정확합니까?</target>
        </trans-unit>
        <trans-unit id="fef6f203817e58c01d740706770af34f2b0429a0" translate="yes" xml:space="preserve">
          <source>Is the user agent or underlying OS inverting colors?</source>
          <target state="translated">사용자 에이전트 또는 기본 OS가 반전 색상입니까?</target>
        </trans-unit>
        <trans-unit id="6adf2779058bb9c161faf2ec3b7f9bccfe5abeea" translate="yes" xml:space="preserve">
          <source>Is the width of the gutter separating the grid lines, relative to the dimension of the element.</source>
          <target state="translated">요소의 치수를 기준으로 그리드 선을 분리하는 거터의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="3f8f4bf6a50d484d4bc5ac290cb2d992a4460163" translate="yes" xml:space="preserve">
          <source>Is the width of the gutter separating the grid lines.</source>
          <target state="translated">격자 선을 분리하는 거터의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="6cebcee0bcfce45687e5ed59d49f9b1f51373f32" translate="yes" xml:space="preserve">
          <source>Is the width of the gutter separating the rows. &lt;a href=&quot;percentage&quot;&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/a&gt; values are relative to the dimension of the element.</source>
          <target state="translated">행을 분리하는 거터의 너비입니다. &lt;a href=&quot;percentage&quot;&gt; &lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt; &lt;/a&gt; 값은 요소의 차원에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="c1b412c4acc9d41416229834f90a70526e25431b" translate="yes" xml:space="preserve">
          <source>Is used when you need the marker representations to be of a minimum length. For example if you want the counters to start at 01 and go through 02, 03, 04 etc, then the pad descriptor is to be used. For representations larger than the specified pad value, the marker is constructed as normal.</source>
          <target state="translated">마커 표현이 최소 길이 여야 할 때 사용됩니다. 예를 들어 카운터가 01에서 시작하여 02, 03, 04 등을 거치게하려면 패드 설명자가 사용됩니다. 지정된 패드 값보다 큰 표현의 경우 마커가 정상적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="515e555fa0f8d3876c8f1c3dd55a25589700cea7" translate="yes" xml:space="preserve">
          <source>It allows specifying the coordinates of the cursor's hotspot, which will be clamped to the boundaries of the cursor image. If none are specified, the coordinates of the hotspot are read from the file itself (for CUR and XBM files) or are set to the top left corner of the image. An example of the CSS3 syntax is:</source>
          <target state="translated">커서 핫스팟의 좌표를 지정할 수 있으며 커서 이미지의 경계에 고정됩니다. 아무것도 지정하지 않으면 핫스팟의 좌표는 파일 자체에서 읽거나 (CUR 및 XBM 파일의 경우) 이미지의 왼쪽 상단으로 설정됩니다. CSS3 구문의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f67a5d51a5498cd40c9e6bf502b722b402573c" translate="yes" xml:space="preserve">
          <source>It also truncates any margins collapsed with such a margin.</source>
          <target state="translated">또한 이러한 여백으로 축소 된 여백을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="813689606e35d77191acd7d293d36db47eb9b971" translate="yes" xml:space="preserve">
          <source>It can also be used as laid out box size for &lt;a href=&quot;width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;height&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;min-width&quot;&gt;&lt;code&gt;min-width&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;min-height&quot;&gt;&lt;code&gt;min-height&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;max-width&quot;&gt;&lt;code&gt;max-width&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;max-height&quot;&gt;&lt;code&gt;max-height&lt;/code&gt;&lt;/a&gt;, where the maximum size refers to the maximum content size and the minimum size to the minimum content size.</source>
          <target state="translated">&lt;a href=&quot;width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;height&quot;&gt; &lt;code&gt;height&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;min-width&quot;&gt; &lt;code&gt;min-width&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;min-height&quot;&gt; &lt;code&gt;min-height&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;max-width&quot;&gt; &lt;code&gt;max-width&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;max-height&quot;&gt; &lt;code&gt;max-height&lt;/code&gt; 에&lt;/a&gt; 대한 배치 상자 크기로 사용할 수도 있습니다 . 여기서 최대 크기는 최대 콘텐츠 크기를 나타내고 최소 크기는 최소 콘텐츠 크기를 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="d3afb4575d2643064cd8dcd35052b348fc0e334a" translate="yes" xml:space="preserve">
          <source>It corresponds to the &lt;a href=&quot;margin-top&quot;&gt;&lt;code&gt;margin-top&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-right&quot;&gt;&lt;code&gt;margin-right&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-bottom&quot;&gt;&lt;code&gt;margin-bottom&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;margin-left&quot;&gt;&lt;code&gt;margin-left&lt;/code&gt;&lt;/a&gt; property depending on the values defined for &lt;a href=&quot;writing-mode&quot;&gt;&lt;code&gt;writing-mode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;direction&quot;&gt;&lt;code&gt;direction&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;text-orientation&quot;&gt;&lt;code&gt;text-orientation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은에 대응하는 &lt;a href=&quot;margin-top&quot;&gt; &lt;code&gt;margin-top&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-right&quot;&gt; &lt;code&gt;margin-right&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-bottom&quot;&gt; &lt;code&gt;margin-bottom&lt;/code&gt; &lt;/a&gt; 이나 &lt;a href=&quot;margin-left&quot;&gt; &lt;code&gt;margin-left&lt;/code&gt; &lt;/a&gt; 에 정의 된 값에 따라서 속성 &lt;a href=&quot;writing-mode&quot;&gt; &lt;code&gt;writing-mode&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;direction&quot;&gt; &lt;code&gt;direction&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;text-orientation&quot;&gt; &lt;code&gt;text-orientation&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffb03def436d2e0a47de2de8fe869726b2a9acc8" translate="yes" xml:space="preserve">
          <source>It does not apply</source>
          <target state="translated">적용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="c90f6829f2a89da52276ca3facd7cbf434c05d37" translate="yes" xml:space="preserve">
          <source>It first filters all the rules from the different sources to keep only the rules that apply to a given element. That means rules whose selector matches the given element and which are part of an appropriate media at-rule.</source>
          <target state="translated">먼저 다른 요소의 모든 규칙을 필터링하여 지정된 요소에 적용되는 규칙 만 유지합니다. 이는 선택자가 주어진 요소와 일치하고 적절한 미디어 at-rule의 일부인 규칙을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4b9ad82addee7771b6d793da7c0754b0309ece0c" translate="yes" xml:space="preserve">
          <source>It is a &lt;a href=&quot;shorthand_properties&quot;&gt;shorthand property&lt;/a&gt; that sets both the &lt;a href=&quot;column-width&quot;&gt;&lt;code&gt;column-width&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;column-count&quot;&gt;&lt;code&gt;column-count&lt;/code&gt;&lt;/a&gt; properties in a single, convenient declaration. As with all shorthand properties, any omitted sub-values will be set to their &lt;a href=&quot;initial_value&quot;&gt;initial value&lt;/a&gt;.</source>
          <target state="translated">하나의 편리한 선언으로 &lt;a href=&quot;column-count&quot;&gt; &lt;code&gt;column-count&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;column-width&quot;&gt; &lt;code&gt;column-width&lt;/code&gt; &lt;/a&gt; 및 열 수&lt;a href=&quot;shorthand_properties&quot;&gt; 속성&lt;/a&gt; 을 설정 하는 속기 속성 입니다 . 모든 속기 속성과 마찬가지로 생략 된 하위 값은 &lt;a href=&quot;initial_value&quot;&gt;초기 값&lt;/a&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="88420ab8e9964decb11e267dc0af69b7ac4bd84a" translate="yes" xml:space="preserve">
          <source>It is a &lt;a href=&quot;shorthand_properties&quot;&gt;shorthand property&lt;/a&gt; that sets the individual &lt;code&gt;column-rule-*&lt;/code&gt; properties in a single, convenient declaration: &lt;a href=&quot;column-rule-width&quot;&gt;&lt;code&gt;column-rule-width&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;column-rule-style&quot;&gt;&lt;code&gt;column-rule-style&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;column-rule-color&quot;&gt;&lt;code&gt;column-rule-color&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개별 &lt;code&gt;column-rule-*&lt;/code&gt; 속성을 편리한 단일 선언 ( &lt;a href=&quot;column-rule-width&quot;&gt; &lt;code&gt;column-rule-width&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;column-rule-style&quot;&gt; &lt;code&gt;column-rule-style&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;column-rule-color&quot;&gt; &lt;code&gt;column-rule-color&lt;/code&gt; )으로&lt;/a&gt; 설정 하는 &lt;a href=&quot;shorthand_properties&quot;&gt;속기 속성&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="979ee4b431ed11ea7e60ab3a3add3233527e3597" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;inline flex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inline flex&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8c1a9eebf213a43577303ae60bd236b23ec8745a" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;inline flow-root&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inline flow-root&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9603703a2c56cdcca2ca77adbf8a95cba324c520" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;inline grid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inline grid&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cabf88927d0d3f57df7767d8847463cf5c87033d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;inline table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inline table&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5328ae63871ade250fc5fac23b73291d8ef267f9" translate="yes" xml:space="preserve">
          <source>It is even possible to apply several transformations in a row:</source>
          <target state="translated">여러 변환을 한 번에 적용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d394f7e75d591aa7633fe6bbfae1bf7d9bb7d0" translate="yes" xml:space="preserve">
          <source>It is important to ensure that the contrast ratio between the background color and the color of the text placed over it is high enough that people experiencing low vision conditions will be able to read the content of the page.</source>
          <target state="translated">시력이 약한 사람들이 페이지의 내용을 읽을 수있을 정도로 배경색과 그 위에 놓인 텍스트 색의 명암비를 높게 유지하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="86cef34adf890f4bf6f4008f58aedf6383ec8f05" translate="yes" xml:space="preserve">
          <source>It is important to ensure that the contrast ratio between the color of the placeholder text and the background of the input is high enough that people experiencing low vision conditions will be able to read it while also making sure there is enough of a difference between the placeholder text and input text color that users do not mistake the placeholder for inputed data.</source>
          <target state="translated">자리 표시 자 텍스트의 색상과 입력 배경의 명암비가 시력이 약한 사람들이 읽을 수있을 정도로 충분히 높아야하며 자리 표시 자간에 차이가 충분히 있는지 확인하는 것이 중요합니다. 사용자가 입력 한 데이터에 대해 자리 표시자를 착각하지 않는 텍스트 및 입력 텍스트 색상.</target>
        </trans-unit>
        <trans-unit id="650392f280ed4de9eb9c61598437536d4f77b7df" translate="yes" xml:space="preserve">
          <source>It is important to ensure that the contrast ratio between the color of the text and the background the text is placed over is high enough that people experiencing low vision conditions will be able to read the content of the page.</source>
          <target state="translated">시력이 좋지 않은 사람들이 페이지의 내용을 읽을 수있을 정도로 텍스트의 색과 텍스트가 놓인 배경 간의 명암비가 높아야합니다.</target>
        </trans-unit>
        <trans-unit id="7fea00c4be9cdeb4d0ee8cf33274bc501cec5059" translate="yes" xml:space="preserve">
          <source>It is important to note that DIV #4, DIV #5 and DIV #6 are children of DIV #3, so stacking of those elements is completely resolved within DIV#3. Once stacking and rendering within DIV #3 is completed, the whole DIV #3 element is passed for stacking in the root element with respect to its sibling's DIV.</source>
          <target state="translated">DIV # 4, DIV # 5 및 DIV # 6은 DIV # 3의 자식이므로 해당 요소의 스택은 DIV # 3 내에서 완전히 해결됩니다. DIV # 3 내에서 스태킹 및 렌더링이 완료되면 전체 DIV # 3 요소가 형제의 DIV와 관련하여 루트 요소에 스태킹되도록 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a029c6ce4c3def49c393c4a509a795eda1e16ada" translate="yes" xml:space="preserve">
          <source>It is important to note that even if a ruleset characterized by a group of selectors is a kind of shorthand replacing rulesets with a single selector each, this doesn't apply to the validity of the ruleset itself.</source>
          <target state="translated">선택자 그룹을 특징으로하는 규칙 집합이 규칙 집합을 각각 단일 선택 자로 대체하는 일종의 속기 인 경우에도 규칙 집합 자체의 유효성에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4279d20189c4063933508ed5277bf85239ca96f" translate="yes" xml:space="preserve">
          <source>It is important to note that the notions of a block-level box and block container box are disjointed. The first, describes how the box behaves with its parents and sibling. The second, how it interacts with its descendants. Some block-level boxes, like tables, aren't block container boxes. Reciprocally, some block container boxes, like non-replaced inline blocks and non-replaced table cells, aren't block-level boxes.</source>
          <target state="translated">블록 수준 상자와 블록 컨테이너 상자의 개념은 서로 분리되어 있습니다. 첫 번째는 상자가 부모 및 형제와 어떻게 동작하는지 설명합니다. 두 번째는 자손과 상호 작용하는 방법입니다. 테이블과 같은 일부 블록 수준 상자는 컨테이너 상자를 차단하지 않습니다. 반대로, 대체되지 않은 인라인 블록 및 대체되지 않은 테이블 셀과 같은 일부 블록 컨테이너 상자는 블록 수준 상자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f6954b8a497a9f53801b1e408d1ab96b727b368" translate="yes" xml:space="preserve">
          <source>It is often convenient to use the shorthand property &lt;a href=&quot;animation&quot;&gt;&lt;code&gt;animation&lt;/code&gt;&lt;/a&gt; to set all animation properties at once.</source>
          <target state="translated">속기 속성 &lt;a href=&quot;animation&quot;&gt; &lt;code&gt;animation&lt;/code&gt; &lt;/a&gt; 을 사용하여 모든 애니메이션 속성을 한 번에 설정 하는 것이 종종 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="c922f74a60a17b02799597847ce590ee381a62fd" translate="yes" xml:space="preserve">
          <source>It is often convenient to use the shorthand property &lt;a href=&quot;font&quot;&gt;&lt;code&gt;font&lt;/code&gt;&lt;/a&gt; to set &lt;code&gt;font-size&lt;/code&gt; and other font related properties all at once.</source>
          <target state="translated">속기 속성 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;font&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;code&gt;font-size&lt;/code&gt; 및 기타 글꼴 관련 속성을 한 번 에 설정 하는 것이 편리한 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3a4943431b94775af13df3ac83163287edfd4c" translate="yes" xml:space="preserve">
          <source>It is often more convenient to set &lt;code&gt;line-height&lt;/code&gt; by using the &lt;a href=&quot;font&quot;&gt;&lt;code&gt;font&lt;/code&gt;&lt;/a&gt; shorthand as shown above, but this requires the &lt;code&gt;font-family&lt;/code&gt; property to be specified as well.</source>
          <target state="translated">위와 같이 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;font&lt;/code&gt; &lt;/a&gt; 속기를 사용하여 &lt;code&gt;line-height&lt;/code&gt; 를 설정하는 것이 더 편리 하지만 &lt;code&gt;font-family&lt;/code&gt; 속성도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca011518fc1843f80c57ad00cb5fcd9fa9a3e479" translate="yes" xml:space="preserve">
          <source>It is often more convenient to use the shorthand &lt;a href=&quot;list-style&quot;&gt;&lt;code&gt;list-style&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속기 &lt;a href=&quot;list-style&quot;&gt; &lt;code&gt;list-style&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="b2ba376f86926ef6792f5a49c460bf5bd28ceb59" translate="yes" xml:space="preserve">
          <source>It is often more convenient to use the shorthand property &lt;a href=&quot;outline&quot;&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/a&gt; when defining the appearance of an outline.</source>
          <target state="translated">&lt;a href=&quot;outline&quot;&gt; &lt;code&gt;outline&lt;/code&gt; &lt;/a&gt; 의 모양을 정의 할 때 속기 속성 개요 를 사용하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="098889f15dbdc47268f027a89465498ea0c7fb8d" translate="yes" xml:space="preserve">
          <source>It is permitted to nest &lt;code&gt;calc()&lt;/code&gt; functions, in which case the inner ones are treated as simple parentheses.</source>
          <target state="translated">&lt;code&gt;calc()&lt;/code&gt; 함수 를 중첩 할 수 있으며,이 경우 내부 함수는 간단한 괄호로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae2ab2f7ee3778a0fea94029dd3e4c4fd6f5687" translate="yes" xml:space="preserve">
          <source>It is permitted to nest &lt;code&gt;max()&lt;/code&gt; and &lt;code&gt;min()&lt;/code&gt; functions as expression values, in which case the inner ones are treated as simple parentheses. The expressions are full math expressions, so you can use direct addition, subtraction, multiplication and division without using the calc() function itself.</source>
          <target state="translated">&lt;code&gt;max()&lt;/code&gt; 및 &lt;code&gt;min()&lt;/code&gt; 함수를 표현식 값 으로 중첩 할 수 있으며 ,이 경우 내부 함수는 간단한 괄호로 처리됩니다. 표현식은 완전한 수학 표현식이므로 calc () 함수 자체를 사용하지 않고 직접 더하기, 빼기, 곱하기 및 나누기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86a54951cd863959f5ec24e18319b24423b27c7c" translate="yes" xml:space="preserve">
          <source>It is permitted to nest &lt;code&gt;max()&lt;/code&gt; and other &lt;code&gt;min()&lt;/code&gt; functions as expression values. The expressions are full math expressions, so you can use direct addition, subtraction, multiplication and division without using the calc() function itself.</source>
          <target state="translated">&lt;code&gt;max()&lt;/code&gt; 및 기타 &lt;code&gt;min()&lt;/code&gt; 함수를 표현식 값 으로 중첩 할 수 있습니다 . 표현식은 완전한 수학 표현식이므로 calc () 함수 자체를 사용하지 않고 직접 더하기, 빼기, 곱하기 및 나누기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74f958df13442b091f882dc7dcb027474b5aadaf" translate="yes" xml:space="preserve">
          <source>It is permitted to nest &lt;code&gt;min()&lt;/code&gt; and other &lt;code&gt;max()&lt;/code&gt; functions as expression values. The expressions are full math expressions, so you can use direct addition, subtraction, multiplication and division without using the calc() function itself.</source>
          <target state="translated">&lt;code&gt;min()&lt;/code&gt; 및 기타 &lt;code&gt;max()&lt;/code&gt; 함수를 표현식 값 으로 중첩 할 수 있습니다 . 표현식은 완전한 수학 표현식이므로 calc () 함수 자체를 사용하지 않고 직접 더하기, 빼기, 곱하기 및 나누기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9cd5ca29335392f52ea633feacf6bcc4c2af340" translate="yes" xml:space="preserve">
          <source>It is possible to use the &lt;a href=&quot;::-ms-ticks-after&quot;&gt;&lt;code&gt;::-ms-ticks-after&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;::-ms-ticks-before&quot;&gt;&lt;code&gt;::-ms-ticks-before&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;::-ms-track&lt;/code&gt; pseudo-elements together. To do so would create three sets of tick marks, but the best user experience is one set. To remove tick marks altogether, set the &lt;a href=&quot;color&quot;&gt;&lt;code&gt;color&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;transparent&lt;/code&gt;.</source>
          <target state="translated">그것은 사용하는 것이 가능하다 &lt;a href=&quot;::-ms-ticks-after&quot;&gt; &lt;code&gt;::-ms-ticks-after&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;::-ms-ticks-before&quot;&gt; &lt;code&gt;::-ms-ticks-before&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;code&gt;::-ms-track&lt;/code&gt; 함께 의사 요소. 그렇게하려면 세 세트의 눈금이 생성되지만 최상의 사용자 환경은 하나의 세트입니다. 눈금을 모두 제거하려면 &lt;a href=&quot;color&quot;&gt; &lt;code&gt;color&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;transparent&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7983bed093cd371cfa5e05d5a2a11defbd8b758a" translate="yes" xml:space="preserve">
          <source>It is possible to use the &lt;a href=&quot;::-ms-ticks-after&quot;&gt;&lt;code&gt;::-ms-ticks-after&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;::-ms-ticks-before&lt;/code&gt;, and &lt;a href=&quot;::-ms-track&quot;&gt;&lt;code&gt;::-ms-track&lt;/code&gt;&lt;/a&gt; pseudo-elements together. To do so would create three sets of tick marks, but the best user experience is one set. To remove tick marks altogether, set the &lt;a href=&quot;color&quot;&gt;&lt;code&gt;color&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;transparent&lt;/code&gt;.</source>
          <target state="translated">그것은 사용하는 것이 가능하다 &lt;a href=&quot;::-ms-ticks-after&quot;&gt; &lt;code&gt;::-ms-ticks-after&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;::-ms-ticks-before&lt;/code&gt; , 그리고 &lt;a href=&quot;::-ms-track&quot;&gt; &lt;code&gt;::-ms-track&lt;/code&gt; &lt;/a&gt; 함께 의사 요소. 그렇게하려면 세 세트의 눈금이 생성되지만 최상의 사용자 환경은 하나의 세트입니다. 눈금을 모두 제거하려면 &lt;a href=&quot;color&quot;&gt; &lt;code&gt;color&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;transparent&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ef15ebfef8ce9d9be3f3000c372cf600e3f77dd" translate="yes" xml:space="preserve">
          <source>It is possible to use the &lt;code&gt;::-ms-ticks-after&lt;/code&gt;, &lt;a href=&quot;::-ms-ticks-before&quot;&gt;&lt;code&gt;::-ms-ticks-before&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;::-ms-track&quot;&gt;&lt;code&gt;::-ms-track&lt;/code&gt;&lt;/a&gt; pseudo-elements together. To do so would create three sets of tick marks, but the best user experience is one set. To remove tick marks altogether, set the &lt;a href=&quot;color&quot;&gt;&lt;code&gt;color&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;transparent&lt;/code&gt;.</source>
          <target state="translated">그것은 사용하는 것이 가능하다 &lt;code&gt;::-ms-ticks-after&lt;/code&gt; , &lt;a href=&quot;::-ms-ticks-before&quot;&gt; &lt;code&gt;::-ms-ticks-before&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;::-ms-track&quot;&gt; &lt;code&gt;::-ms-track&lt;/code&gt; &lt;/a&gt; 함께 의사 요소. 그렇게하려면 세 세트의 눈금이 생성되지만 최상의 사용자 환경은 하나의 세트입니다. 눈금을 모두 제거하려면 &lt;a href=&quot;color&quot;&gt; &lt;code&gt;color&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;transparent&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="abead7b8c69283ba494a3a3a5a531f196c47a069" translate="yes" xml:space="preserve">
          <source>It is this distribution of positive free space and removal of negative free space that we need to understand in order to understand the flex properties.</source>
          <target state="translated">플렉스 속성을 이해하기 위해 이해해야하는 것은 양의 자유 공간 분포와 음의 자유 공간 제거입니다.</target>
        </trans-unit>
        <trans-unit id="4725ff1feb3be7d4f3a8aba8b6a42293fce09da4" translate="yes" xml:space="preserve">
          <source>It is this requirement that the gap properties, once implemented, will solve for us. Proper gaps only happen on the inside edges of items.</source>
          <target state="translated">갭 속성이 일단 구현되면이 요구 사항이 해결 될 것입니다. 적절한 간격은 항목의 내부 가장자리에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f506744ff44025c710ab225271364589747c4ac" translate="yes" xml:space="preserve">
          <source>It is worth noting that we might want to change the writing mode of our document for reasons other than publishing content in a language that uses a different writing mode. See &lt;a href=&quot;https://24ways.org/2016/css-writing-modes/&quot;&gt;this article&lt;/a&gt; for a full description of writing modes and ways to use them, both for content in other languages and for creative reasons.</source>
          <target state="translated">다른 쓰기 모드를 사용하는 언어로 콘텐츠를 게시하는 것 이외의 이유로 문서의 쓰기 모드를 변경하고 싶을 수도 있습니다. 다른 언어로 된 내용과 독창적 인 이유로 작성 모드와 사용 방법에 대한 자세한 설명은 &lt;a href=&quot;https://24ways.org/2016/css-writing-modes/&quot;&gt;이 기사&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e928076804ef99476aff9c7a4017c66753e3c5d0" translate="yes" xml:space="preserve">
          <source>It is worth noting that you do not have to use grid in an &lt;em&gt;all or nothing&lt;/em&gt; way. You could start by simply enhancing elements in your design with grid, that could otherwise display using an older method. Overwriting of legacy methods with grid layout works surprisingly well, due to the way grid interacts with these other methods.</source>
          <target state="translated">그리드를 &lt;em&gt;전혀 또는 전혀&lt;/em&gt; 사용하지 않아도됩니다 . 그리드를 사용하여 디자인의 요소를 간단히 향상시키는 것부터 시작할 수 있습니다. 그렇지 않으면 구식 방법으로 표시 할 수 있습니다. 그리드가 다른 방법과 상호 작용하는 방식으로 인해 그리드 레이아웃으로 레거시 메서드를 덮어 쓰는 것은 놀랍도록 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e3168d9914dd51d6f02471534c957a66be4d359a" translate="yes" xml:space="preserve">
          <source>It is worth noting, that using these space distribution values may cause items on your grid to become larger. If an item spans more than one grid track, as further space is added between the tracks, that item needs to become large to absorb the space. We&amp;rsquo;re always working in a strict grid. Therefore, if you decide to use these values, ensure that the content of your tracks can cope with the extra space, or that you have used alignment properties on the items, to cause them to move to the start rather than stretch.</source>
          <target state="translated">이러한 공간 분포 값을 사용하면 그리드의 항목이 커질 수 있습니다. 항목이 둘 이상의 그리드 트랙에 걸쳐있는 경우 트랙 사이에 추가 공간이 추가되므로 해당 항목이 커져 공간을 흡수해야합니다. 우리는 항상 엄격한 그리드에서 일하고 있습니다. 따라서이 값을 사용하기로 결정한 경우 트랙의 내용이 추가 공간에 대처할 수 있는지 또는 항목의 정렬 속성을 사용하여 스트레치가 아닌 시작으로 이동하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="a666ce9ede14dedf34747b996e12352a3da6923c" translate="yes" xml:space="preserve">
          <source>It may be that you come up with your own use cases for auto-placement or any other part of grid layout. If you do, raise them as issues or add to an existing issue that could solve your use case. This will help to make future versions of the specification better.</source>
          <target state="translated">자동 배치 또는 그리드 레이아웃의 다른 부분에 대한 자체 사용 사례를 생각해 냈을 수 있습니다. 그렇다면 문제를 문제로 제기하거나 사용 사례를 해결할 수있는 기존 문제에 추가하십시오. 이는 향후 버전의 사양을 개선하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="10ad06e5105e168e6d369b6647a7622bb674ab14" translate="yes" xml:space="preserve">
          <source>It may however be appropriate to include &lt;code&gt;will-change&lt;/code&gt; in your style sheet for an application that does page flips on key presses like an album or a slide deck presentation where the pages are large and complex. This will let browser prepare the transition ahead of time and allow for snappy transitions between the pages as soon as the key is pressed.</source>
          <target state="translated">그러나 앨범이나 페이지가 크고 복잡한 슬라이드 데크 프레젠테이션과 같이 키를 누를 때 페이지를 넘기는 응용 프로그램의 경우 스타일 시트에 &lt;code&gt;will-change&lt;/code&gt; 을 포함시키는 것이 적절할 수 있습니다 . 이렇게하면 브라우저에서 미리 전환을 준비 할 수 있으며 키를 누르 자마자 페이지간에 빠르게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51dc1fd54878d559ca2d0953b13ec41297fe32d" translate="yes" xml:space="preserve">
          <source>It modifies the abscissa of each element point by a constant factor, except when the scale factor is 1, in which case the function is the identity transform. The scaling is not isotropic, and the angles of the element are not conserved. &lt;code&gt;scaleX(-1)&lt;/code&gt; defines an &lt;a href=&quot;http://en.wikipedia.org/wiki/Axial_symmetry&quot;&gt;axial symmetry&lt;/a&gt;, with a vertical axis passing through the origin (as specified by the &lt;a href=&quot;../transform-origin&quot;&gt;&lt;code&gt;transform-origin&lt;/code&gt;&lt;/a&gt; property).</source>
          <target state="translated">축척 계수가 1 인 경우를 제외하고는 각 요소 점의 가로 좌표를 상수 인수로 수정합니다.이 경우 함수는 항등 변환입니다. 스케일링이 등방성이 아니며 요소의 각도가 보존되지 않습니다. &lt;code&gt;scaleX(-1)&lt;/code&gt; 은 세로 축이 원점을 통과 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Axial_symmetry&quot;&gt;축 대칭을&lt;/a&gt; 정의합니다 ( &lt;a href=&quot;../transform-origin&quot;&gt; &lt;code&gt;transform-origin&lt;/code&gt; &lt;/a&gt; 속성 으로 지정 ).</target>
        </trans-unit>
        <trans-unit id="fe8279e45e6b4f02f7bd5d06a7bc3dae62ff5bd1" translate="yes" xml:space="preserve">
          <source>It modifies the ordinate of each element point by a constant factor, except when the scale factor is 1, in which case the function is the identity transform. The scaling is not isotropic, and the angles of the element are not conserved. &lt;code&gt;scaleY(-1)&lt;/code&gt; defines an &lt;a href=&quot;http://en.wikipedia.org/wiki/Axial_symmetry&quot;&gt;axial symmetry&lt;/a&gt;, with a horizontal axis passing through the origin (as specified by the &lt;a href=&quot;../transform-origin&quot;&gt;&lt;code&gt;transform-origin&lt;/code&gt;&lt;/a&gt; property).</source>
          <target state="translated">스케일 팩터가 1 인 경우를 제외하고 함수가 항등 변환 인 경우를 제외하고 각 요소 점의 좌표를 상수 팩터로 수정합니다. 스케일링이 등방성이 아니며 요소의 각도가 보존되지 않습니다. &lt;code&gt;scaleY(-1)&lt;/code&gt; 은 가로축이 원점을 통과 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Axial_symmetry&quot;&gt;축 대칭을&lt;/a&gt; 정의합니다 ( &lt;a href=&quot;../transform-origin&quot;&gt; &lt;code&gt;transform-origin&lt;/code&gt; &lt;/a&gt; 속성 으로 지정 ).</target>
        </trans-unit>
        <trans-unit id="d7ec26f20e3240e9d26a8b992ae6432bcebc20f1" translate="yes" xml:space="preserve">
          <source>It must not contain a &lt;code&gt;symbols&lt;/code&gt; or &lt;code&gt;additive-symbols&lt;/code&gt; descriptor, or else the counter style rule is invalid. If one more more counter styles defenitions form a cycle with their extends values, the browser will treat all the participating counter styles as extending from the decimal style.</source>
          <target state="translated">&lt;code&gt;symbols&lt;/code&gt; 또는 &lt;code&gt;additive-symbols&lt;/code&gt; 설명자를 포함하지 않아야합니다. 그렇지 않으면 카운터 스타일 규칙이 유효하지 않습니다. 하나 이상의 카운터 스타일 방어가 확장 값으로주기를 형성하면 브라우저는 참여하는 모든 카운터 스타일을 10 진수 스타일에서 확장 한 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="c03476b0802d34f25440078ad06f1b3c9a498df1" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-after&quot;&gt;&lt;code&gt;-webkit-border-after&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-start&quot;&gt;&lt;code&gt;-webkit-border-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-end&quot;&gt;&lt;code&gt;-webkit-border-end&lt;/code&gt;&lt;/a&gt;, which define the other borders of the element.</source>
          <target state="translated">그것은 관한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-after&quot;&gt; &lt;code&gt;-webkit-border-after&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-start&quot;&gt; &lt;code&gt;-webkit-border-start&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-border-end&quot;&gt; &lt;code&gt;-webkit-border-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 경계를 정의한다.</target>
        </trans-unit>
        <trans-unit id="3f5ff530afff2759b1e915810c10c96b2ebf35b8" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;inset-block-end&quot;&gt;&lt;code&gt;inset-block-end&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inset-inline-start&quot;&gt;&lt;code&gt;inset-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;inset-inline-end&quot;&gt;&lt;code&gt;inset-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other offsets of the element.</source>
          <target state="translated">그것은에 관한 &lt;a href=&quot;inset-block-end&quot;&gt; &lt;code&gt;inset-block-end&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inset-inline-start&quot;&gt; &lt;code&gt;inset-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;inset-inline-end&quot;&gt; &lt;code&gt;inset-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 오프셋을 정의한다.</target>
        </trans-unit>
        <trans-unit id="c9dfcf8749cf08633f6a559e50d8a169eebdbc09" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;inset-block-start&quot;&gt;&lt;code&gt;inset-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inset-block-end&quot;&gt;&lt;code&gt;inset-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;inset-inline-end&quot;&gt;&lt;code&gt;inset-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other insets of the element.</source>
          <target state="translated">그것은에 관한 &lt;a href=&quot;inset-block-start&quot;&gt; &lt;code&gt;inset-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inset-block-end&quot;&gt; &lt;code&gt;inset-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;inset-inline-end&quot;&gt; &lt;code&gt;inset-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 세트를 정의한다.</target>
        </trans-unit>
        <trans-unit id="164b198c69d948b5527cfb9ff517fec35e85522f" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;inset-block-start&quot;&gt;&lt;code&gt;inset-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inset-block-end&quot;&gt;&lt;code&gt;inset-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;inset-inline-start&quot;&gt;&lt;code&gt;inset-inline-start&lt;/code&gt;&lt;/a&gt;, which define the other offsets of the element.</source>
          <target state="translated">그것은에 관한 &lt;a href=&quot;inset-block-start&quot;&gt; &lt;code&gt;inset-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inset-block-end&quot;&gt; &lt;code&gt;inset-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;inset-inline-start&quot;&gt; &lt;code&gt;inset-inline-start&lt;/code&gt; &lt;/a&gt; 요소의 다른 오프셋을 정의한다.</target>
        </trans-unit>
        <trans-unit id="4e38d06cdb423745d6a84a4eae31e9328f12e2f0" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;inset-block-start&quot;&gt;&lt;code&gt;inset-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inset-inline-start&quot;&gt;&lt;code&gt;inset-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;inset-inline-end&quot;&gt;&lt;code&gt;inset-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other offsets of the element.</source>
          <target state="translated">그것은에 관한 &lt;a href=&quot;inset-block-start&quot;&gt; &lt;code&gt;inset-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inset-inline-start&quot;&gt; &lt;code&gt;inset-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;inset-inline-end&quot;&gt; &lt;code&gt;inset-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 오프셋을 정의한다.</target>
        </trans-unit>
        <trans-unit id="1be44e6f6fdd6d6b5bc11f36ca85e039287b30c6" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;margin-block-end&quot;&gt;&lt;code&gt;margin-block-end&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-inline-start&quot;&gt;&lt;code&gt;margin-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;margin-inline-end&quot;&gt;&lt;code&gt;margin-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other margins of the element.</source>
          <target state="translated">이는 요소의 다른 여백을 정의하는 &lt;a href=&quot;margin-block-end&quot;&gt; &lt;code&gt;margin-block-end&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-inline-start&quot;&gt; &lt;code&gt;margin-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;margin-inline-end&quot;&gt; &lt;code&gt;margin-inline-end&lt;/code&gt; &lt;/a&gt; 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d12f3496fdff02548f56e39c9a152bb71d6d2c9" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;margin-block-start&quot;&gt;&lt;code&gt;margin-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-block-end&quot;&gt;&lt;code&gt;margin-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;margin-inline-end&quot;&gt;&lt;code&gt;margin-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other margins of the element.</source>
          <target state="translated">이는 요소의 다른 여백을 정의하는 &lt;a href=&quot;margin-block-start&quot;&gt; &lt;code&gt;margin-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-block-end&quot;&gt; &lt;code&gt;margin-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;margin-inline-end&quot;&gt; &lt;code&gt;margin-inline-end&lt;/code&gt; &lt;/a&gt; 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4547aadda72c3caf31b49ea7cd318c742cf36f5" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;margin-block-start&quot;&gt;&lt;code&gt;margin-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-block-end&quot;&gt;&lt;code&gt;margin-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;margin-inline-start&quot;&gt;&lt;code&gt;margin-inline-start&lt;/code&gt;&lt;/a&gt;, which define the other margins of the element.</source>
          <target state="translated">이는 요소의 다른 여백을 정의하는 &lt;a href=&quot;margin-block-start&quot;&gt; &lt;code&gt;margin-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-block-end&quot;&gt; &lt;code&gt;margin-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;margin-inline-start&quot;&gt; &lt;code&gt;margin-inline-start&lt;/code&gt; &lt;/a&gt; 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c80ecbfeebfc1fbe307467990c2907c4857d61" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;margin-block-start&quot;&gt;&lt;code&gt;margin-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;margin-inline-start&quot;&gt;&lt;code&gt;margin-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;margin-inline-end&quot;&gt;&lt;code&gt;margin-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other margins of the element.</source>
          <target state="translated">이는 요소의 다른 여백을 정의하는 &lt;a href=&quot;margin-block-start&quot;&gt; &lt;code&gt;margin-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;margin-inline-start&quot;&gt; &lt;code&gt;margin-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;margin-inline-end&quot;&gt; &lt;code&gt;margin-inline-end&lt;/code&gt; &lt;/a&gt; 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9532d7526f31cd1ddf21abd9e36cd397b05f3f4" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;padding-block-end&quot;&gt;&lt;code&gt;padding-block-end&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;padding-inline-start&quot;&gt;&lt;code&gt;padding-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;padding-inline-end&quot;&gt;&lt;code&gt;padding-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other paddings of the element.</source>
          <target state="translated">그것은 관련된 &lt;a href=&quot;padding-block-end&quot;&gt; &lt;code&gt;padding-block-end&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;padding-inline-start&quot;&gt; &lt;code&gt;padding-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;padding-inline-end&quot;&gt; &lt;code&gt;padding-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 가스켓을 정의.</target>
        </trans-unit>
        <trans-unit id="7f9e11f61b66854c37cb037683874ad659614532" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;padding-block-start&quot;&gt;&lt;code&gt;padding-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;padding-block-end&quot;&gt;&lt;code&gt;padding-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;padding-inline-end&quot;&gt;&lt;code&gt;padding-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other paddings of the element.</source>
          <target state="translated">그것은 관련된 &lt;a href=&quot;padding-block-start&quot;&gt; &lt;code&gt;padding-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;padding-block-end&quot;&gt; &lt;code&gt;padding-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;padding-inline-end&quot;&gt; &lt;code&gt;padding-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 가스켓을 정의.</target>
        </trans-unit>
        <trans-unit id="f1e1a3456c5526118424a14cf8e98eedd5a7f3cf" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;padding-block-start&quot;&gt;&lt;code&gt;padding-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;padding-block-end&quot;&gt;&lt;code&gt;padding-block-end&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;padding-inline-start&quot;&gt;&lt;code&gt;padding-inline-start&lt;/code&gt;&lt;/a&gt;, which define the other paddings of the element.</source>
          <target state="translated">그것은 관련된 &lt;a href=&quot;padding-block-start&quot;&gt; &lt;code&gt;padding-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;padding-block-end&quot;&gt; &lt;code&gt;padding-block-end&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;padding-inline-start&quot;&gt; &lt;code&gt;padding-inline-start&lt;/code&gt; &lt;/a&gt; 요소의 다른 가스켓을 정의.</target>
        </trans-unit>
        <trans-unit id="e2c7100141d46ba2b98e182efe6b2e5f6c830118" translate="yes" xml:space="preserve">
          <source>It relates to &lt;a href=&quot;padding-block-start&quot;&gt;&lt;code&gt;padding-block-start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;padding-inline-start&quot;&gt;&lt;code&gt;padding-inline-start&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;padding-inline-end&quot;&gt;&lt;code&gt;padding-inline-end&lt;/code&gt;&lt;/a&gt;, which define the other paddings of the element.</source>
          <target state="translated">그것은 관련된 &lt;a href=&quot;padding-block-start&quot;&gt; &lt;code&gt;padding-block-start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;padding-inline-start&quot;&gt; &lt;code&gt;padding-inline-start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;padding-inline-end&quot;&gt; &lt;code&gt;padding-inline-end&lt;/code&gt; &lt;/a&gt; 요소의 다른 가스켓을 정의.</target>
        </trans-unit>
        <trans-unit id="5a582436c2add46403634ec6c64ced1ea8aae869" translate="yes" xml:space="preserve">
          <source>It should be noted that at this point there is no way in the &lt;code&gt;@font-face&lt;/code&gt; declaration to 'map' a specific point on the variation axis of a variable font to the keyword &lt;code&gt;bold&lt;/code&gt; (or any other keyword). This can generally be resolved fairly easily, but does require an extra step in writing your CSS:</source>
          <target state="translated">이 시점에서 &lt;code&gt;@font-face&lt;/code&gt; 선언에서 변수 글꼴의 변형 축에있는 특정 지점을 키워드 &lt;code&gt;bold&lt;/code&gt; (또는 다른 키워드) 로 '매핑' 할 수있는 방법이 없습니다 . 이것은 일반적으로 상당히 쉽게 해결할 수 있지만 CSS 작성에 추가 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="deb03b8fd1fd04f3e6579ec3ae8b1f0413c0653c" translate="yes" xml:space="preserve">
          <source>It should be noted that when we define a grid we define the grid tracks, not the lines. Grid then gives us numbered lines to use when positioning items. In our three column, two row grid we have four column lines.</source>
          <target state="translated">그리드를 정의 할 때 선이 아닌 그리드 트랙을 정의합니다. 그런 다음 그리드는 항목을 배치 할 때 사용할 번호가 매겨진 줄을 제공합니다. 세 개의 열, 두 개의 행 그리드에는 네 개의 열 선이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9db0053a121b40302b61d189d087aae57a59a0a" translate="yes" xml:space="preserve">
          <source>It should be remembered that the original implementation of CSS Grid Layout happened in Internet Explorer 10. This early specification did not contain all of the properties and values that the up-to-date specification has. There are also substantial differences between what shipped in IE10 and the current specification, even where the properties and values appear the same. This early implementation is also the version of Grid Layout implemented in Edge up to version 15.</source>
          <target state="translated">CSS Grid Layout의 원래 구현은 Internet Explorer 10에서 발생했음을 기억해야합니다.이 초기 사양에는 최신 사양에 포함 된 모든 속성과 값이 포함되어 있지 않습니다. 속성과 값이 동일하게 나타나는 경우에도 IE10에 제공된 것과 현재 사양 간에는 실질적인 차이가 있습니다. 이 초기 구현은 Edge에서 버전 15까지 구현 된 그리드 레이아웃 버전이기도합니다.</target>
        </trans-unit>
        <trans-unit id="74811481532fd6a13eba8c3e342bedb0e4a67f8a" translate="yes" xml:space="preserve">
          <source>It's actually possible to change the definitions and orientations of these coordinate systems using CSS properties such as &lt;a href=&quot;../transform&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt;. However, we'll only talk about the standard coordinate system for now.</source>
          <target state="translated">실제로 &lt;a href=&quot;../transform&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; 과 같은 CSS 속성을 사용하여 이러한 좌표계의 정의와 방향을 변경할 수 있습니다 . 그러나 지금은 표준 좌표계에 대해서만 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d488b5000639fd7316a3a176955e54c5ce0f62bf" translate="yes" xml:space="preserve">
          <source>It's also possible to create styles that are specific to a particular fragment of the document. This is done using the same identifying value that is found in the URI. Thus, to add a border to the &lt;code&gt;#example&lt;/code&gt; fragment, we would write:</source>
          <target state="translated">문서의 특정 조각에 고유 한 스타일을 만들 수도 있습니다. 이는 URI에서 발견되는 것과 동일한 식별 값을 사용하여 수행됩니다. 따라서 &lt;code&gt;#example&lt;/code&gt; 조각에 테두리를 추가하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="778ced7e100024e59bbff71b9951492c5d8a1a00" translate="yes" xml:space="preserve">
          <source>It's common to use both &lt;code&gt;url()&lt;/code&gt; and &lt;code&gt;local()&lt;/code&gt; together, so that the user's installed copy of the font is used if available, falling back to downloading a copy of the font if it's not found on the user's device.</source>
          <target state="translated">그것의 일반적인 둘 다 사용하는 &lt;code&gt;url()&lt;/code&gt; 및 &lt;code&gt;local()&lt;/code&gt; 글꼴에 대한 사용자의 설치된 사본을 사용하는 그래서 서로를 사용할 수있는 경우,이 사용자의 장치에서 발견되어 있지 않은 경우 글꼴의 사본을 다운로드에 다시 떨어지는.</target>
        </trans-unit>
        <trans-unit id="4a5d13a17ba0bd17ee454c31c5eb0e356b0ffe00" translate="yes" xml:space="preserve">
          <source>It's worth noting that the sizing algorithm only cares about the image's dimensions and proportions, or lack thereof. An SVG image with fixed dimensions will be treated just like a raster image of the same size.</source>
          <target state="translated">크기 조정 알고리즘은 이미지의 크기와 비율 또는 그 부족에 대해서만 관심이 있다는 점은 주목할 가치가 있습니다. 크기가 고정 된 SVG 이미지는 동일한 크기의 래스터 이미지처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="1616e2e5405e69c4e3914c67c644a9bd3ac00956" translate="yes" xml:space="preserve">
          <source>Italic</source>
          <target state="translated">Italic</target>
        </trans-unit>
        <trans-unit id="6193919fada173889258c366ee9f05b45a02b56f" translate="yes" xml:space="preserve">
          <source>Item 1 starts at column line 1, spanning one track.</source>
          <target state="translated">항목 1은 열 1 열에서 시작하여 하나의 트랙에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="69c1379e29c5cf81e8d8dbebd55e973616ce9076" translate="yes" xml:space="preserve">
          <source>Item 2 starts at column line -1, spanning to -3.</source>
          <target state="translated">항목 2는 열 행 -1에서 시작하여 -3에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d64c95efec2b97500f63caf51793d107ed9c5d" translate="yes" xml:space="preserve">
          <source>Item 3 starts at column line 1, spanning to column line 3.</source>
          <target state="translated">항목 3은 열 1 행에서 시작하여 열 3 행에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0baf7bf76071340662fc3a8ddf55cbb96ba432c" translate="yes" xml:space="preserve">
          <source>Item placement</source>
          <target state="translated">아이템 배치</target>
        </trans-unit>
        <trans-unit id="1afe57172a69a9c9f58bf1ce5efb03968d44b339" translate="yes" xml:space="preserve">
          <source>Item(s) selected in a control. Should be used with the &lt;code&gt;HighlightText&lt;/code&gt; foreground color.</source>
          <target state="translated">컨트롤에서 선택된 항목. &lt;code&gt;HighlightText&lt;/code&gt; 전경색 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95f3463db439be16bcf35fbeb57cd5199a421a56" translate="yes" xml:space="preserve">
          <source>Items can span one or more cells both by row or by column, and this creates a &lt;em&gt;grid area&lt;/em&gt;. Grid areas must be rectangular &amp;ndash; it isn&amp;rsquo;t possible to create an L-shaped area for example. The highlighted grid area spans two row and two column tracks.</source>
          <target state="translated">항목은 행 또는 열별로 하나 이상의 셀에 걸쳐있을 수 있으며 &lt;em&gt;그리드 영역을&lt;/em&gt; 만듭니다 . 격자 영역은 직사각형이어야합니다. 예를 들어 L 자형 영역을 만들 수 없습니다. 강조 표시된 격자 영역은 두 개의 행과 두 개의 열 트랙에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94875c0c64e45033ad39f0e808bd4d5288c4e10" translate="yes" xml:space="preserve">
          <source>Items can&amp;rsquo;t grow with no positive free space, and they won&amp;rsquo;t shrink unless there is negative free space.</source>
          <target state="translated">양의 여유 공간이 없으면 항목을 확장 할 수 없으며 음의 여유 공간이 없으면 줄어들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4ba382b1b84432fa758356c7ec189086b67f379" translate="yes" xml:space="preserve">
          <source>Items display in a row (the &lt;code&gt;flex-direction&lt;/code&gt; property's default is &lt;code&gt;row&lt;/code&gt;).</source>
          <target state="translated">항목은 행으로 표시됩니다 ( &lt;code&gt;flex-direction&lt;/code&gt; 속성의 기본값은 &lt;code&gt;row&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="ad22e02a9ad915e33b7990867696e958fab3ae75" translate="yes" xml:space="preserve">
          <source>Items will then wrap in the container. In the next example I have ten items all with a &lt;code&gt;flex-basis&lt;/code&gt; of &lt;code&gt;160px&lt;/code&gt; and the ability to grow and shrink. Once the first row gets to a point where there is not enough space to place another 160 pixel item, a new flex line is created for the items and so on until all of the items are placed. As the items can grow, they will expand larger than 160 px in order to fill each row completely. If there is only one item on the final line it will stretch to fill the entire line.</source>
          <target state="translated">그런 다음 품목이 용기에 포장됩니다. 다음 예제에서 나는 모두와 열 항목이 &lt;code&gt;flex-basis&lt;/code&gt; 의 &lt;code&gt;160px&lt;/code&gt; 성장 및 축소 할 수있는 기능. 첫 번째 행이 다른 160 픽셀 항목을 배치하기에 충분한 공간이없는 지점에 도달하면 모든 항목이 배치 될 때까지 항목에 대한 새로운 플렉스 라인이 작성됩니다. 항목이 커질 수 있으므로 각 행을 완전히 채우기 위해 160px보다 크게 확장됩니다. 마지막 줄에 항목이 하나만 있으면 전체 줄을 채우도록 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="83cfbb3cc55fce7b610e022a8a189ee61487125c" translate="yes" xml:space="preserve">
          <source>Items with an intrinsic aspect ratio</source>
          <target state="translated">고유 종횡비를 가진 항목</target>
        </trans-unit>
        <trans-unit id="cf158c7c5120290558384c0232fedb46a29504f9" translate="yes" xml:space="preserve">
          <source>Items with placement properties</source>
          <target state="translated">게재 위치 속성이있는 항목</target>
        </trans-unit>
        <trans-unit id="d543537dea8ff3af10fea7f19650559597728f82" translate="yes" xml:space="preserve">
          <source>Its extension to HTML elements, though present in early drafts of CSS Basic User Interface Module Level 3, has been pushed to its &lt;a href=&quot;http://wiki.csswg.org/spec/css4-ui#pointer-events&quot;&gt;level 4&lt;/a&gt;.</source>
          <target state="translated">CSS 기본 사용자 인터페이스 모듈 레벨 3의 초안에 있지만 HTML 요소의 확장은 &lt;a href=&quot;http://wiki.csswg.org/spec/css4-ui#pointer-events&quot;&gt;레벨 4&lt;/a&gt; 로 푸시되었습니다 .</target>
        </trans-unit>
        <trans-unit id="99a7b47ce384431ae1eb227b6ba4f9591177fbbb" translate="yes" xml:space="preserve">
          <source>Its value is a prioritized, comma-separated list of external references or locally-installed font face names. When a font is needed the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; iterates over the set of references listed using the first one it can successfully activate. Fonts containing invalid data or local font faces that are not found are ignored and the user agent loads the next font in the list.</source>
          <target state="translated">이 값은 쉼표로 구분 된 우선 순위가 지정된 외부 참조 목록 또는 로컬로 설치된 글꼴 이름입니다. 글꼴이 필요한 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 는 성공적으로 활성화 할 수있는 첫 번째 글꼴을 사용하여 나열된 참조 세트를 반복합니다. 유효하지 않은 데이터 또는 찾을 수없는 로컬 글꼴이 포함 된 글꼴은 무시되고 사용자 에이전트는 목록에서 다음 글꼴을로드합니다.</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="c1c8382a5664e15c09760b19e31b37639ac40495" translate="yes" xml:space="preserve">
          <source>JIS X 0208:1978</source>
          <target state="translated">JIS X 0208 : 1978</target>
        </trans-unit>
        <trans-unit id="9d6b48d7b1f75208832a33a757f4ffcc9bfc959b" translate="yes" xml:space="preserve">
          <source>JIS X 0208:1983</source>
          <target state="translated">JIS X 0208 : 1983</target>
        </trans-unit>
        <trans-unit id="1bb1ea7e6913d3475331965d5020085a59262c58" translate="yes" xml:space="preserve">
          <source>JIS X 0208:1990</source>
          <target state="translated">JIS X 0208 : 1990</target>
        </trans-unit>
        <trans-unit id="349541f40c3238d7cfaba2197fe7584ab8cb21ca" translate="yes" xml:space="preserve">
          <source>JIS X 0213:2004</source>
          <target state="translated">JIS X 0213 : 2004</target>
        </trans-unit>
        <trans-unit id="bf67b2dfa7452eeeba2d99ea18fbc82a08a6af72" translate="yes" xml:space="preserve">
          <source>JIS-B4</source>
          <target state="translated">JIS-B4</target>
        </trans-unit>
        <trans-unit id="4d5b1d7fd1ebf7056b5fe370c6d90fad94177661" translate="yes" xml:space="preserve">
          <source>JIS-B5</source>
          <target state="translated">JIS-B5</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="cabd6fe8d763c51a9fbf7324f044e6ffa1963889" translate="yes" xml:space="preserve">
          <source>Japanese formal numbering to be used in legal or financial document.</source>
          <target state="translated">법률 또는 재무 문서에 사용되는 일본 공식 번호입니다.</target>
        </trans-unit>
        <trans-unit id="703c69600e070ab1081de5959051c3beb1b0c2f4" translate="yes" xml:space="preserve">
          <source>Japanese informal numbering</source>
          <target state="translated">일본어 비공식 번호 매기기</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="33fc64beda12d84ba20564feed9804f42d9249da" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;&lt;code&gt;AnimationEvent&lt;/code&gt;&lt;/a&gt; API</source>
          <target state="translated">JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt; &lt;code&gt;AnimationEvent&lt;/code&gt; &lt;/a&gt; API</target>
        </trans-unit>
        <trans-unit id="ebe94f498f1cdb99b4e5ebe4411c03d1682c1c24" translate="yes" xml:space="preserve">
          <source>JavaScript Content</source>
          <target state="translated">자바 스크립트 내용</target>
        </trans-unit>
        <trans-unit id="c15ca41ff2b0ccf6512cfe528d1cc181cf599b14" translate="yes" xml:space="preserve">
          <source>JavaScript can access the &lt;code&gt;@keyframes&lt;/code&gt; at-rule with the CSS object model interface &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSKeyframesRule&quot;&gt;&lt;code&gt;CSSKeyframesRule&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JavaScript는 CSS 객체 모델 인터페이스 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSKeyframesRule&quot;&gt; &lt;code&gt;CSSKeyframesRule&lt;/code&gt; 을&lt;/a&gt; 사용하여 &lt;code&gt;@keyframes&lt;/code&gt; at-rule에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a62b40b41ce0d42df8ba4b0874263a7aa928401" translate="yes" xml:space="preserve">
          <source>JavaScript content</source>
          <target state="translated">자바 스크립트 내용</target>
        </trans-unit>
        <trans-unit id="bcf021b49cd8e796288272017b01657d2e5cc8dc" translate="yes" xml:space="preserve">
          <source>JavaScript examples</source>
          <target state="translated">자바 스크립트 예제</target>
        </trans-unit>
        <trans-unit id="e4815d242f65f22a5033f376d11aa19ade048914" translate="yes" xml:space="preserve">
          <source>Just for the sake of completeness, here&amp;rsquo;s the HTML that displays the page content, including the list into which the script inserts information about the received events:</source>
          <target state="translated">완성을 위해 스크립트가 수신 된 이벤트에 대한 정보를 삽입하는 목록을 포함하여 페이지 컨텐츠를 표시하는 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7c4942f73b35f684c1bc282f462d7decb78ec94" translate="yes" xml:space="preserve">
          <source>Just like linear gradients, you can also stack radial gradients. The first specified is on top, the last on the bottom.</source>
          <target state="translated">선형 그라디언트와 마찬가지로 방사형 그라디언트도 쌓을 수 있습니다. 첫 번째는 맨 위에, 마지막은 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="536d2746f7f2f88df35515a9cd5e44cb1582b9ca" translate="yes" xml:space="preserve">
          <source>Justify</source>
          <target state="translated">Justify</target>
        </trans-unit>
        <trans-unit id="323bd53c811584ccea8cf8e9d3bcdc1ce9505648" translate="yes" xml:space="preserve">
          <source>Justifying Items on the Inline Axis</source>
          <target state="translated">인라인 축의 항목 정렬</target>
        </trans-unit>
        <trans-unit id="9f9a1b50bc7b997f6d378c4e08fe8258618f306b" translate="yes" xml:space="preserve">
          <source>Justifying the grid tracks on the row axis</source>
          <target state="translated">행 축의 그리드 트랙 정렬</target>
        </trans-unit>
        <trans-unit id="3130a1430df90f7ad2b8cef85a5471d0e92f3969" translate="yes" xml:space="preserve">
          <source>Juxtaposition</source>
          <target state="translated">Juxtaposition</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="6a7628f58199c7079042a94c19241b733dd76ee0" translate="yes" xml:space="preserve">
          <source>Keep in mind that once you set &lt;code&gt;align-self:&amp;nbsp;start&lt;/code&gt;, the height of each child &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will be determined by the contents of the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is in contrast to omitting &lt;code&gt;&lt;a href=&quot;../align-self&quot;&gt;align-self&lt;/a&gt;&lt;/code&gt; completely, in which case the height of each &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; stretches to fill its grid area.</source>
          <target state="translated">사용자가 설정 한 번 있다는 사실을 숙지 &lt;code&gt;align-self:&amp;nbsp;start&lt;/code&gt; , 각 자녀의 높이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 의 내용에 따라 결정됩니다 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; . 이것은 &lt;code&gt;&lt;a href=&quot;../align-self&quot;&gt;align-self&lt;/a&gt;&lt;/code&gt; 완전히 생략하는 것과 대조적 입니다.이 경우 각 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 의 높이가 그리드 영역을 채우기 위해 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="9b8bea35eefc1e714b1a6555fcb100dafbc9b8ea" translate="yes" xml:space="preserve">
          <source>Keep in mind that these are custom properties, not actual variables like you might find in other programming languages. The value is computed where it is needed, not stored for use in other rules. For instance, you cannot set a property for an element and expect to retrieve it in a sibling's descendant's rule. The property is only set for the matching selector and its descendants, like any normal CSS.</source>
          <target state="translated">이들은 다른 프로그래밍 언어에서 볼 수있는 실제 변수가 아닌 사용자 지정 속성이라는 점에 유의하십시오. 값은 필요한 경우 계산되며 다른 규칙에 사용하기 위해 저장되지 않습니다. 예를 들어 요소의 속성을 설정할 수 없으며 형제의 자손 규칙에서 검색 할 것으로 예상됩니다. 이 속성은 일반 CSS와 마찬가지로 일치하는 선택기 및 해당 하위 항목에 대해서만 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e094be9c115702e9e6bd6183639f6738aaf8f5dc" translate="yes" xml:space="preserve">
          <source>Kerning (&lt;a href=&quot;../font-kerning&quot;&gt;&lt;code&gt;font-kerning&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">커닝 ( &lt;a href=&quot;../font-kerning&quot;&gt; &lt;code&gt;font-kerning&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="610e7d4afcb0ce4e34e1229014d83237eab3a05b" translate="yes" xml:space="preserve">
          <source>Key Concepts and Terminology</source>
          <target state="translated">주요 개념 및 용어</target>
        </trans-unit>
        <trans-unit id="d99a5fad781343a4ebc41c9fd0646ca593604548" translate="yes" xml:space="preserve">
          <source>Key concepts and terminology</source>
          <target state="translated">주요 개념 및 용어</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="a8619cd742f973918239ca10ea6bb7210df3762b" translate="yes" xml:space="preserve">
          <source>Keyword color values</source>
          <target state="translated">키워드 색상 값</target>
        </trans-unit>
        <trans-unit id="f1225da0d096f8f15aea31032eb0e8694e4f7e4b" translate="yes" xml:space="preserve">
          <source>Keyword index</source>
          <target state="translated">키워드 색인</target>
        </trans-unit>
        <trans-unit id="eea1ad53d84b27e3538ec5125ef87cc6151130f5" translate="yes" xml:space="preserve">
          <source>Keyword to numeric mapping</source>
          <target state="translated">키워드 대 숫자 매핑</target>
        </trans-unit>
        <trans-unit id="dd5c9ddeef7cae40b880e0855843e7fd270cd7f9" translate="yes" xml:space="preserve">
          <source>Keyword values</source>
          <target state="translated">키워드 값</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="2eed9bd33567933d6441d0fb9f6700e5e0a88a0a" translate="yes" xml:space="preserve">
          <source>Keywords and percentages refer to the canvas instead of the object itself. See &lt;a href=&quot;https://bugzil.la/1209061&quot;&gt;bug 1209061&lt;/a&gt;.</source>
          <target state="translated">키워드와 백분율은 객체 자체 대신 캔버스를 나타냅니다. &lt;a href=&quot;https://bugzil.la/1209061&quot;&gt;버그 1209061을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc706a2ed131aeaa5a4e84d56a8c915c48b5dfac" translate="yes" xml:space="preserve">
          <source>Keywords are a good way to set the size of fonts on the web. By setting a keyword font size on the body element, you can set relative font-sizing everywhere else on the page, giving you the ability to easily scale the font up or down on the entire page accordingly.</source>
          <target state="translated">키워드는 웹에서 글꼴 크기를 설정하는 좋은 방법입니다. body 요소에 키워드 글꼴 크기를 설정하면 페이지의 다른 곳에서 상대적 글꼴 크기를 설정하여 전체 페이지에서 글꼴을 쉽게 확대 또는 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c0541d8c590206617df62e4998fbf5d32ef32b" translate="yes" xml:space="preserve">
          <source>Keywords for common timing functions</source>
          <target state="translated">일반적인 타이밍 기능을위한 키워드</target>
        </trans-unit>
        <trans-unit id="927be3b222733d8a218abcdcfa4d821e9c926ce7" translate="yes" xml:space="preserve">
          <source>Kind of object</source>
          <target state="translated">물체의 종류</target>
        </trans-unit>
        <trans-unit id="1a3b174ac92802ce629b23582265c3b78c98395e" translate="yes" xml:space="preserve">
          <source>Korean hangul numbering.</source>
          <target state="translated">한글 번호 매기기</target>
        </trans-unit>
        <trans-unit id="2c5f89537d03f6774bc3b0f5a13cdb0e81a3bdf6" translate="yes" xml:space="preserve">
          <source>Korean hanja numbering.</source>
          <target state="translated">한자 번호 매기기.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="c2dee6a0be52e08e5abd1adc0e82a190d36a98f0" translate="yes" xml:space="preserve">
          <source>Language-related pseudo-classes: &lt;a href=&quot;:lang&quot;&gt;&lt;code&gt;:lang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:dir&quot;&gt;&lt;code&gt;:dir&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">언어 관련 의사 클래스 : &lt;a href=&quot;:lang&quot;&gt; &lt;code&gt;:lang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:dir&quot;&gt; &lt;code&gt;:dir&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf4a531c2a377cf48a5c1f4d4293cc20ac462d32" translate="yes" xml:space="preserve">
          <source>Language-specific rules</source>
          <target state="translated">언어 별 규칙</target>
        </trans-unit>
        <trans-unit id="db07be184479f34078cd4fc76d248dc0975720e9" translate="yes" xml:space="preserve">
          <source>Languages</source>
          <target state="translated">Languages</target>
        </trans-unit>
        <trans-unit id="ca35216490bbff4772ec6412d7de9fc1fa6f8e5b" translate="yes" xml:space="preserve">
          <source>Large grids with many tracks can use the &lt;code&gt;repeat()&lt;/code&gt; notation, to repeat all or a section of the track listing. For example the grid definition:</source>
          <target state="translated">트랙이 많은 큰 격자는 &lt;code&gt;repeat()&lt;/code&gt; 표기법을 사용하여 트랙 목록의 전체 또는 일부를 반복 할 수 있습니다 . 예를 들어 그리드 정의 :</target>
        </trans-unit>
        <trans-unit id="cb2c3057ceb222ec3ef89eae7c0393769f3aa45d" translate="yes" xml:space="preserve">
          <source>Large sections of text set with a &lt;code&gt;font-style&lt;/code&gt; value of &lt;code&gt;italic&lt;/code&gt; may be difficult for people with cognitive concerns such as Dyslexia to read.</source>
          <target state="translated">&lt;code&gt;italic&lt;/code&gt; 의 &lt;code&gt;font-style&lt;/code&gt; 값으로 설정된 텍스트의 큰 부분은 실독증과 같은인지 문제가있는 사람들이 읽기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9689e23a844cc36d16318857b05ae7e39532c6f" translate="yes" xml:space="preserve">
          <source>Large sections of text set with a &lt;code&gt;font-variant&lt;/code&gt; value of &lt;code&gt;all-small-caps&lt;/code&gt; or &lt;code&gt;all-petite-caps&lt;/code&gt; may be difficult for people with cognitive concerns such as Dyslexia to read.</source>
          <target state="translated">난독증과 같은인지 문제가있는 사람들은 읽기 어려운 &lt;code&gt;font-variant&lt;/code&gt; 값이 &lt;code&gt;all-small-caps&lt;/code&gt; 또는 &lt;code&gt;all-petite-caps&lt;/code&gt; 대문자로 설정된 텍스트의 큰 부분 을 읽기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c20422b04b2892ba0b0da6b6a07e09d328079f" translate="yes" xml:space="preserve">
          <source>Large sections of text set with a &lt;code&gt;text-transform&lt;/code&gt; value of &lt;code&gt;uppercase&lt;/code&gt; may be difficult for people with cognitive concerns such as Dyslexia to read.</source>
          <target state="translated">A를 텍스트 세트의 큰 부분 &lt;code&gt;text-transform&lt;/code&gt; 의 값 &lt;code&gt;uppercase&lt;/code&gt; 난독증과 같은인지 적 문제를 가진 사람들이 읽기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d0b86a2d69031a786d1bc9f0e43c76dfef8600f" translate="yes" xml:space="preserve">
          <source>Last Updated Date: July 9, 2005</source>
          <target state="translated">최종 업데이트 날짜 : 2005 년 7 월 9 일</target>
        </trans-unit>
        <trans-unit id="40d9667692519ddb9eea1c21a5666bfc23b72552" translate="yes" xml:space="preserve">
          <source>Last Updated Date: Published 30 Aug 2002</source>
          <target state="translated">최종 업데이트 날짜 : 2002 년 8 월 30 일 게시</target>
        </trans-unit>
        <trans-unit id="0c96659e7ae68683ad6a454a38fe3a83b67a4d25" translate="yes" xml:space="preserve">
          <source>Layering items with &lt;code&gt;z-index&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;z-index&lt;/code&gt; 항목 계층화</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="6244ff239cc780ac7072110d33e417834249055b" translate="yes" xml:space="preserve">
          <source>Layout and the containing block</source>
          <target state="translated">레이아웃 및 포함 블록</target>
        </trans-unit>
        <trans-unit id="f3bd184de8e98d40dad596370c6c22a00cfe87b6" translate="yes" xml:space="preserve">
          <source>Layout mode</source>
          <target state="translated">레이아웃 모드</target>
        </trans-unit>
        <trans-unit id="3343e1bad41376eb659e4bd5d48296c954d51fe9" translate="yes" xml:space="preserve">
          <source>Layout using line-based placement</source>
          <target state="translated">라인 기반 배치를 사용한 레이아웃</target>
        </trans-unit>
        <trans-unit id="ab65764160b69ecec126aafbfe3e82ed26cf224a" translate="yes" xml:space="preserve">
          <source>Layout using named grid lines</source>
          <target state="translated">명명 된 그리드 선을 사용한 레이아웃</target>
        </trans-unit>
        <trans-unit id="d1d7913e695042635fdbe1ddb0ac8e63660e6f43" translate="yes" xml:space="preserve">
          <source>Lays out the characters of horizontal scripts naturally (upright), as well as the glyphs for vertical scripts. Note that this keyword causes all characters to be considered as left-to-right: the used value of &lt;a href=&quot;direction&quot;&gt;&lt;code&gt;direction&lt;/code&gt;&lt;/a&gt; is forced to be &lt;code&gt;ltr&lt;/code&gt;.</source>
          <target state="translated">가로 스크립트의 문자를 자연스럽게 (똑바로), 세로 스크립트의 글리프를 배치합니다. 이 키워드를 사용하면 모든 문자가 왼쪽에서 오른쪽으로 간주됩니다. &lt;a href=&quot;direction&quot;&gt; &lt;code&gt;direction&lt;/code&gt; &lt;/a&gt; 의 사용 된 값은 &lt;code&gt;ltr&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="203d6e25e30be7570c3e4d86d921cc83c47ceb48" translate="yes" xml:space="preserve">
          <source>Lea Verou's article on reflection using &lt;a href=&quot;http://lea.verou.me/2011/06/css-reflections-for-firefox-with-moz-element-and-svg-masks/&quot;&gt;CSS features on the standard track&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://lea.verou.me/2011/06/css-reflections-for-firefox-with-moz-element-and-svg-masks/&quot;&gt;표준 트랙에서 CSS 기능을&lt;/a&gt; 사용한 리플에 관한 Lea Verou의 기사 .</target>
        </trans-unit>
        <trans-unit id="8ef6bff52166f1183442b7370fead5ece360d999" translate="yes" xml:space="preserve">
          <source>Leading and trailing spaces are stripped.</source>
          <target state="translated">선행 및 후행 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c4a243c03536bb77923e3b07697a1a2df0af6c" translate="yes" xml:space="preserve">
          <source>Leading to:</source>
          <target state="translated">이어지는 :</target>
        </trans-unit>
        <trans-unit id="abfc20d57a179c12d6ecc7eab2a34c44025c6334" translate="yes" xml:space="preserve">
          <source>League Mono Variable</source>
          <target state="translated">리그 모노 변수</target>
        </trans-unit>
        <trans-unit id="14cec16eb011461dd1698acb2dd092fd8698985d" translate="yes" xml:space="preserve">
          <source>Learn Layout: &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning&quot;&gt;Positioning&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">레이아웃 배우기 : &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning&quot;&gt;포지셔닝&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8103ebaa8c491a30e8ccfa2432589461ca67187" translate="yes" xml:space="preserve">
          <source>Learn how Media Queries can help users understand your website better.</source>
          <target state="translated">미디어 쿼리를 통해 사용자가 웹 사이트를 더 잘 이해하는 데 도움이되는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="1723c78fbc1f5c847a594e5a5ac19e560f0eefdc" translate="yes" xml:space="preserve">
          <source>Leaving a grid cell empty</source>
          <target state="translated">그리드 셀을 비워 두십시오</target>
        </trans-unit>
        <trans-unit id="8ac113a1cc0892afdbbec48759bf7aebd06d51f2" translate="yes" xml:space="preserve">
          <source>Left alignment</source>
          <target state="translated">왼쪽 정렬</target>
        </trans-unit>
        <trans-unit id="2429df49956781ba18744100a513895509a5016d" translate="yes" xml:space="preserve">
          <source>Left-to-right block flow. Layout is vertical.</source>
          <target state="translated">왼쪽에서 오른쪽으로 블록 흐름. 레이아웃이 수직입니다.</target>
        </trans-unit>
        <trans-unit id="36832053790940c9f124b15d4ee799d8068a526d" translate="yes" xml:space="preserve">
          <source>Legacy alignment: the &lt;code&gt;legacy&lt;/code&gt; keyword, followed by one of &lt;code&gt;left&lt;/code&gt; or &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">기존 정렬 : &lt;code&gt;legacy&lt;/code&gt; 키워드 다음에 &lt;code&gt;left&lt;/code&gt; 또는 &lt;code&gt;right&lt;/code&gt; 중 하나가옵니다 .</target>
        </trans-unit>
        <trans-unit id="5846955db6bef539707c3590c701613c5f0cf50f" translate="yes" xml:space="preserve">
          <source>Legend</source>
          <target state="translated">Legend</target>
        </trans-unit>
        <trans-unit id="786c62f9cf8856203d110036992d80f805b8ff51" translate="yes" xml:space="preserve">
          <source>Legible &lt;code&gt;word-spacing&lt;/code&gt; must be determined on a case-by-case basis, as different font families have different character widths. There is no one value that can ensure all font families automatically maintain their legibility.</source>
          <target state="translated">가독성이있는 &lt;code&gt;word-spacing&lt;/code&gt; 은 각 글꼴 모음마다 문자 너비가 다르기 때문에 사례별로 결정해야합니다. 모든 글꼴 모음이 자동으로 가독성을 유지할 수있는 값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9558e9b50cc81b5b3b73e1dc18205c1775dc849" translate="yes" xml:space="preserve">
          <source>Legible letter-spacing must be determined on a case-by-case basis, as different font families have different character widths. There is no one value that can ensure all font families automatically maintain their legibility.</source>
          <target state="translated">가독성이 좋은 글자 간격은 각 글꼴 패밀리마다 문자 너비가 다르기 때문에 사례별로 결정해야합니다. 모든 글꼴 모음이 자동으로 가독성을 유지할 수있는 값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="48de85df924a2665a794e88cdc4b82f06ab2ec26" translate="yes" xml:space="preserve">
          <source>Lengths specified as percentages are calculated relative to the &lt;strong&gt;initial viewport&lt;/strong&gt;, which is the viewport before any user agent or authored styles have had an opportunity to adjust the viewport. This is typically based on the size of the window on desktop browsers that aren't in full screen mode.</source>
          <target state="translated">백분율로 지정된 길이는 &lt;strong&gt;초기 뷰포트를&lt;/strong&gt; 기준으로 계산되며 , 이는 사용자 에이전트 또는 작성된 스타일이 뷰포트를 조정할 기회를 갖기 전에 뷰포트입니다. 일반적으로 전체 화면 모드가 아닌 데스크톱 브라우저의 창 크기를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="50a873db19d92f05f7a15af0f9d1316fcd0bcb08" translate="yes" xml:space="preserve">
          <source>Less common data types, called &lt;em&gt;non-terminal data types&lt;/em&gt;, are also surrounded by '&lt;code&gt;&amp;lt;&lt;/code&gt;' and '&lt;code&gt;&amp;gt;&lt;/code&gt;'.</source>
          <target state="translated">&lt;em&gt;비 터미널 데이터 형식&lt;/em&gt; 이라고하는 덜 일반적인 데이터 형식 도 ' &lt;code&gt;&amp;lt;&lt;/code&gt; '및 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="ad1be8a03dd5f9ed18d1988bf51e079e5f54b2d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add another keyframe to the previous example&amp;rsquo;s animation. Let&amp;rsquo;s say we want the header&amp;rsquo;s font size to increase as it moves from right to left for a while, then to decrease back to its original size. That&amp;rsquo;s as simple as adding this keyframe:</source>
          <target state="translated">이전 예제의 애니메이션에 다른 키 프레임을 추가하겠습니다. 헤더의 글꼴 크기가 오른쪽에서 왼쪽으로 잠시 이동할 때 증가한 다음 원래 크기로 다시 돌아 가기를 원한다고 가정 해 봅시다. 이 키 프레임을 추가하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="6d13ad12eb812e5fff9eac2cc6d9c23794960115" translate="yes" xml:space="preserve">
          <source>Let's Talk About Speech CSS | CSS Tricks</source>
          <target state="translated">Speech CSS에 대해 이야기합시다 | CSS 트릭</target>
        </trans-unit>
        <trans-unit id="7f3aac4b0c4250709985ac989f5459fe4ea139ab" translate="yes" xml:space="preserve">
          <source>Let's apply the following rectangle as a mask:</source>
          <target state="translated">다음 사각형을 마스크로 적용 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5e3ad9561890132e7bda7f7e66875705044fe9f3" translate="yes" xml:space="preserve">
          <source>Let's assume an em in the above case is 16px wide:</source>
          <target state="translated">위의 경우 em이 16px 너비라고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="56ba24f3154af18ff7307f7695be99e4145f1a89" translate="yes" xml:space="preserve">
          <source>Let's consider a large image, a 2982x2808 Firefox logo image. We want (for some reason likely involving horrifyingly bad site design) to tile four copies of this image into a 300x300-pixel element. To do this, we can use a fixed &lt;code&gt;background-size&lt;/code&gt; value of 150 pixels.</source>
          <target state="translated">큰 이미지 인 2982x2808 Firefox 로고 이미지를 생각해 봅시다. 우리는 (어떤 이유로 끔찍한 사이트 디자인과 관련이있을 수 있음)이 이미지 사본을 300x300 픽셀 요소로 바둑판 식으로 배열하기를 원합니다. 이를 위해 고정 &lt;code&gt;background-size&lt;/code&gt; 값인 150 픽셀을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e6b55f99374c37367a23080f73b478969e7d493" translate="yes" xml:space="preserve">
          <source>Let's create two classes: one for boring paragraphs and one for exciting ones. We can use these classes to add pseudo-elements to the end of paragraphs.</source>
          <target state="translated">지루한 단락과 흥미 진진한 클래스를위한 두 개의 클래스를 만들어 보겠습니다 이 클래스를 사용하여 단락 끝에 의사 요소를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="927db4b57c8e1149f775246e337f8bcdb40210e2" translate="yes" xml:space="preserve">
          <source>Let's explain what's going on here:</source>
          <target state="translated">여기서 무슨 일이 일어나고 있는지 설명해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b81bd10cd3060ad43fce4348798a8dd5b3513fb5" translate="yes" xml:space="preserve">
          <source>Let's have a look at a couple of these in order to see the effect creating a new</source>
          <target state="translated">새로운 것을 만드는 효과를보기 위해이 두 가지를 살펴 보자</target>
        </trans-unit>
        <trans-unit id="82387c48c52fdc199b9df7983724491b054bed17" translate="yes" xml:space="preserve">
          <source>Let's look at an example involving multiple sources of CSS across the various origins; here we have a user agent style sheet, two author style sheets, a user stylesheet, and inline styles within the HTML:</source>
          <target state="translated">다양한 출처에 걸쳐 여러 CSS 소스가 포함 된 예를 살펴 보겠습니다. 여기에는 HTML 내에 사용자 에이전트 스타일 시트, 두 개의 작성자 스타일 시트, 사용자 스타일 시트 및 인라인 스타일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6a572628d177e902fc6dc6b0adfbfdeb2ef90d" translate="yes" xml:space="preserve">
          <source>Let's look at some CSS:</source>
          <target state="translated">CSS를 보자 :</target>
        </trans-unit>
        <trans-unit id="b0a3aa7eef73ba9c6a090d63cafc787dd4438afd" translate="yes" xml:space="preserve">
          <source>Let's look at the script in two sections. First, the code that logs the coordinates to the screen. This code will be called by the event handler for the various mouse events we watch.</source>
          <target state="translated">두 섹션에서 스크립트를 살펴 보겠습니다. 먼저 좌표를 화면에 기록하는 코드입니다. 이 코드는 우리가 보는 다양한 마우스 이벤트에 대한 이벤트 핸들러에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8f42abefed842c5c5033cc187ed2bba0fc846120" translate="yes" xml:space="preserve">
          <source>Let's look at the two approaches for a moment. In Internet Explorer and Opera, the lists are indented by setting a left margin of 40 pixels on the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element. If we apply a background color to the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element and leave the list item and &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; borders in place, we get the result shown in Figure 5.</source>
          <target state="translated">두 가지 접근 방식을 잠시 살펴 보겠습니다. Internet Explorer 및 Opera에서 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 요소 에 왼쪽 여백을 40 픽셀로 설정하여 목록을 들여 씁니다 . &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 요소에 배경색을 적용 하고 목록 항목과 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 테두리를 그대로두면 결과가 그림 5에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfae6521e79457fcf78e8b78e0c3ec71723c718" translate="yes" xml:space="preserve">
          <source>Let's start with this simple CSS that applies the same color to elements of different classes:</source>
          <target state="translated">다른 클래스의 요소에 동일한 색상을 적용하는이 간단한 CSS부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="20538de7ec954c30653752fe40c3be7d10e62c2f" translate="yes" xml:space="preserve">
          <source>Let's take a look at an example. First some HTML:</source>
          <target state="translated">예를 살펴 보겠습니다. 먼저 일부 HTML :</target>
        </trans-unit>
        <trans-unit id="b6753781dd7a9b30329381721210c464a43403a9" translate="yes" xml:space="preserve">
          <source>Let's take a look at an example. This simple example creates a set of nested boxes. Whenever the mouse enters, moves around inside, or exits the inner box, the corresponding event is handled by updating a set of informational messages within the box, listing out the current mouse coordinates in each of the four available &lt;a href=&quot;coordinate_systems&quot;&gt;coordinate systems&lt;/a&gt;.</source>
          <target state="translated">예를 살펴 보겠습니다. 이 간단한 예제는 중첩 상자 세트를 작성합니다. 마우스가 들어 오거나 내부를 돌아 다니거나 내부 상자를 나갈 때마다 해당 이벤트는 상자 내의 정보 메시지 세트를 업데이트하여 사용 가능한 네 가지 &lt;a href=&quot;coordinate_systems&quot;&gt;좌표계&lt;/a&gt; 각각에서 현재 마우스 좌표를 나열하여 처리 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a2a03c2328213e4e10e56a10aba3515aafc8c48" translate="yes" xml:space="preserve">
          <source>Lets the author specify symbols to be appended or prepended to the counter representation if the value is negative.</source>
          <target state="translated">값이 음수이면 작성자가 카운터 표시에 추가하거나 추가 할 기호를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091ba853f3cef2696cbb685f2ad95d37ece92e16" translate="yes" xml:space="preserve">
          <source>Lets you pause and resume the animation sequence.</source>
          <target state="translated">애니메이션 시퀀스를 일시 중지했다가 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47984d503510d210c1bab7366b10c29c677941dc" translate="yes" xml:space="preserve">
          <source>Letting the browser control the animation sequence lets the browser optimize performance and efficiency by, for example, reducing the update frequency of animations running in tabs that aren't currently visible.</source>
          <target state="translated">브라우저가 애니메이션 시퀀스를 제어하게하면 브라우저는 예를 들어 현재 보이지 않는 탭에서 실행되는 애니메이션의 업데이트 빈도를 줄임으로써 성능과 효율성을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d8e88746aed29c5732084d86f85c42f51868b5" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike License v2.5 이상에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="6de0fb71572b9e4e053f85172ed7d869dfeda40a" translate="yes" xml:space="preserve">
          <source>Lift the restriction to only apply it for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에만 적용되도록 제한을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="f90ce7c49cf079e2f1de87660ef0c0125118f9b7" translate="yes" xml:space="preserve">
          <source>Lifts the restriction to only apply &lt;code&gt;:visited&lt;/code&gt; to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Lets browsers restrict its behavior for privacy reasons.</source>
          <target state="translated">에만 적용에 제한을 리프트 &lt;code&gt;:visited&lt;/code&gt; 받는 사람 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소입니다. 개인 정보 보호를 위해 브라우저가 동작을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e691c3190b85011ff81becb46ea220ff4242c631" translate="yes" xml:space="preserve">
          <source>Ligatures (&lt;a href=&quot;../font-variant-ligatures&quot;&gt;&lt;code&gt;font-variant-ligatures&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">합자 ( &lt;a href=&quot;../font-variant-ligatures&quot;&gt; &lt;code&gt;font-variant-ligatures&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="db1e381d0f5aeea15bde13bcd657c121c3cd5375" translate="yes" xml:space="preserve">
          <source>Ligatures are glyphs that replace two or more separate glyphs in order to represent them more smoothly (from a spacing or aesthetic perspective). Some of the most common are letters like 'fi', 'fl', or 'ffl' &amp;mdash; but there are many other possibilities. There are the most frequent ones (referred to as common ligatures), and there are also more specialized categories like 'discretionary ligatures', 'historical ligatures', and 'contextual alternates'. While these last ones are not technically ligatures, they are generally similar in that they replace specific combinations of letters when they appear together.</source>
          <target state="translated">합자는 두 개 이상의 개별 글리프를 대체하여 간격이나 미적 관점에서보다 매끄럽게 표현하기 위해 글리프입니다. 가장 일반적인 것 중 일부는 'fi', 'fl'또는 'ffl'와 같은 문자이지만 다른 가능성도 많이 있습니다. 가장 흔한 것들 (공통 합자라고 함)이 있으며 '임의 합자', '역사 합자'및 '문맥 대안'과 같은 더 전문화 된 범주도 있습니다. 이 마지막 문자는 기술적으로 합자가 아니지만 일반적으로 문자가 함께 나타날 때 특정 문자 조합을 대체한다는 점에서 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="a36ef8aba22905e2d2efbf1ac1d6230d5761859d" translate="yes" xml:space="preserve">
          <source>Light</source>
          <target state="translated">Light</target>
        </trans-unit>
        <trans-unit id="e9b1015d6b9e4cb0e81a1f8cd1c9ca43a768c2b7" translate="yes" xml:space="preserve">
          <source>Light level of the environment</source>
          <target state="translated">환경의 빛 수준</target>
        </trans-unit>
        <trans-unit id="45812c58f9490640017f335cfaa69bcccb6270d1" translate="yes" xml:space="preserve">
          <source>Lighter and darker greens</source>
          <target state="translated">더 밝고 어두운 녹색</target>
        </trans-unit>
        <trans-unit id="6423f80097f72e0296a64ca9c34d2ad2993213bf" translate="yes" xml:space="preserve">
          <source>Like in CSS1, but removes its effect on inline elements.</source>
          <target state="translated">CSS1에서와 같지만 인라인 요소에 대한 영향을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5363f85347ec603724151c609dfc48bd210b26ac" translate="yes" xml:space="preserve">
          <source>Like regular classes, you can chain together as many pseudo-classes as you want in a selector.</source>
          <target state="translated">일반 클래스와 마찬가지로 선택기에서 원하는 수의 유사 클래스를 함께 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74df946b28c7e1f19a91fdcea890f3ea839e491e" translate="yes" xml:space="preserve">
          <source>Like tables, grid layout enables an author to align elements into columns and rows. However, many more layouts are either possible or easier with CSS grid than they were with tables. For example, a grid container's child elements could position themselves so they actually overlap and layer, similar to CSS positioned elements.</source>
          <target state="translated">표와 마찬가지로 격자 레이아웃을 사용하면 작성자가 요소를 열과 행에 정렬 할 수 있습니다. 그러나 CSS 그리드에서는 테이블보다 레이아웃이 훨씬 많거나 쉽습니다. 예를 들어 그리드 컨테이너의 자식 요소는 CSS 위치 요소와 유사하게 실제로 겹치거나 겹쳐 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99a3031af0b0e247a4d225d7ab916c945777f9d7" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;hidden&lt;/code&gt; keyword, displays no border. Unless a &lt;a href=&quot;background-image&quot;&gt;&lt;code&gt;background-image&lt;/code&gt;&lt;/a&gt; is set, the calculated value of &lt;a href=&quot;border-top-width&quot;&gt;&lt;code&gt;border-top-width&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;0&lt;/code&gt;, even if the specified value is something else. In the case of table cell and border collapsing, the &lt;code&gt;none&lt;/code&gt; value has the &lt;em&gt;lowest&lt;/em&gt; priority: if any other conflicting border is set, it will be displayed.</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 키워드 와 마찬가지로 테두리가 표시되지 않습니다. 않는 &lt;a href=&quot;background-image&quot;&gt; &lt;code&gt;background-image&lt;/code&gt; &lt;/a&gt; 설정의 계산 된 값 &lt;a href=&quot;border-top-width&quot;&gt; &lt;code&gt;border-top-width&lt;/code&gt; &lt;/a&gt; 될 것이다 &lt;code&gt;0&lt;/code&gt; 지정된 값이 다른 어떤 경우에도. 테이블 셀 및 테두리 축소의 경우 &lt;code&gt;none&lt;/code&gt; 값이 우선 순위 가 &lt;em&gt;가장 낮습니다&lt;/em&gt; . 충돌하는 다른 테두리가 설정되어 있으면 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bb7daff9804a2d8ba2ba0db202e49f0ceabe2642" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;none&lt;/code&gt; keyword, displays no border. Unless a &lt;a href=&quot;background-image&quot;&gt;&lt;code&gt;background-image&lt;/code&gt;&lt;/a&gt; is set, the calculated value of &lt;a href=&quot;border-top-width&quot;&gt;&lt;code&gt;border-top-width&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;0&lt;/code&gt;, even if the specified value is something else. In the case of table cell and border collapsing, the &lt;code&gt;hidden&lt;/code&gt; value has the &lt;em&gt;highest&lt;/em&gt; priority: if any other conflicting border is set, it won't be displayed.</source>
          <target state="translated">&lt;code&gt;none&lt;/code&gt; 키워드 와 마찬가지로 테두리를 표시하지 않습니다. 않는 &lt;a href=&quot;background-image&quot;&gt; &lt;code&gt;background-image&lt;/code&gt; &lt;/a&gt; 설정의 계산 된 값 &lt;a href=&quot;border-top-width&quot;&gt; &lt;code&gt;border-top-width&lt;/code&gt; &lt;/a&gt; 될 것이다 &lt;code&gt;0&lt;/code&gt; 지정된 값이 다른 어떤 경우에도. 표 셀 및 테두리 축소의 경우 &lt;code&gt;hidden&lt;/code&gt; 값의 우선 순위 가 &lt;em&gt;가장&lt;/em&gt; 높습니다. 충돌하는 다른 테두리가 설정되어 있으면 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="0440ed5025e05c7e67481c59993553757eff3afa" translate="yes" xml:space="preserve">
          <source>Limitations of column-span</source>
          <target state="translated">열 스팬의 한계</target>
        </trans-unit>
        <trans-unit id="545bf2883d9d02dff1fdc6075a7008c537c88915" translate="yes" xml:space="preserve">
          <source>Limited to the &lt;a href=&quot;content&quot;&gt;&lt;code&gt;content&lt;/code&gt;&lt;/a&gt; property; always return a &lt;a href=&quot;string&quot;&gt;&lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;content&quot;&gt; &lt;code&gt;content&lt;/code&gt; &lt;/a&gt; 속성으로 제한됩니다 . 항상 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; 을&lt;/a&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf167073e4afed85da6f724d5e6724ec36f44c5" translate="yes" xml:space="preserve">
          <source>Limits to visited link styles</source>
          <target state="translated">방문한 링크 스타일로 제한</target>
        </trans-unit>
        <trans-unit id="13100646858027b627ad1d730f8c260e21aaf34f" translate="yes" xml:space="preserve">
          <source>Line boxes</source>
          <target state="translated">라인 박스</target>
        </trans-unit>
        <trans-unit id="a5f883800b565de1367f89fbe405b8303a24e555" translate="yes" xml:space="preserve">
          <source>Line breaks inside &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre&quot;&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre&quot;&gt; &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 안의 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="83e537c8dfff1137a16b64fbe498d7651054b606" translate="yes" xml:space="preserve">
          <source>Line-based placement</source>
          <target state="translated">라인 기반 배치</target>
        </trans-unit>
        <trans-unit id="fedfbe82b85c92071925a605908cc3b232b426b2" translate="yes" xml:space="preserve">
          <source>Line-based placement and Writing Modes</source>
          <target state="translated">라인 기반 배치 및 쓰기 모드</target>
        </trans-unit>
        <trans-unit id="43064943b3bbdb1a1c43c298c230b70562ba8d21" translate="yes" xml:space="preserve">
          <source>Line-relative values</source>
          <target state="translated">라인 기준 값</target>
        </trans-unit>
        <trans-unit id="6182eedbd35403b1b3c82436654bbdd226cb830d" translate="yes" xml:space="preserve">
          <source>Linear gradient</source>
          <target state="translated">선형 그라디언트</target>
        </trans-unit>
        <trans-unit id="08c3a655a7baad2e33ef704871f598912f8d3d13" translate="yes" xml:space="preserve">
          <source>Lines are numbered according to the writing mode of the document. In a left-to-right language, line 1 is on the left-hand side of the grid. In a right-to-left language, it is on the right-hand side of the grid. Lines can also be named, and we will look at how to do this in a later guide in this series.</source>
          <target state="translated">줄은 문서의 쓰기 모드에 따라 번호가 매겨집니다. 왼쪽에서 오른쪽 언어로 1 행은 그리드의 왼쪽에 있습니다. 오른쪽에서 왼쪽으로 쓰는 언어는 그리드의 오른쪽에 있습니다. 라인 이름도 지정할 수 있으며이 시리즈의 후반부에서이 작업을 수행하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="37c4b224e12548e8b95fe6334386ede9c680977f" translate="yes" xml:space="preserve">
          <source>Lines may only break at normal word break points (such as a space between two words).</source>
          <target state="translated">줄은 일반적인 단어 구분 점 (예 : 두 단어 사이의 공백)에서만 끊길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d111138b33a0fcc709b7fa372e86328b07a66cb3" translate="yes" xml:space="preserve">
          <source>Lining and Oldstyle figures</source>
          <target state="translated">안감과 구식 인물</target>
        </trans-unit>
        <trans-unit id="6d10bb0a2f928802138462cae8607e05fbb171c8" translate="yes" xml:space="preserve">
          <source>Link to Selectors Level 3.</source>
          <target state="translated">선택기 수준 3에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="97b6e314e5a14a1ed7a8ec0352aefdd2c8da6f74" translate="yes" xml:space="preserve">
          <source>Link-related pseudo-classes: &lt;a href=&quot;:link&quot;&gt;&lt;code&gt;:link&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:active&quot;&gt;&lt;code&gt;:active&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:hover&quot;&gt;&lt;code&gt;:hover&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">링크 관련 의사 클래스 : &lt;a href=&quot;:link&quot;&gt; &lt;code&gt;:link&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:active&quot;&gt; &lt;code&gt;:active&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:hover&quot;&gt; &lt;code&gt;:hover&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15b4d5fd98f8522e4de8a880a3848965296a3c67" translate="yes" xml:space="preserve">
          <source>Link-related pseudo-classes: &lt;a href=&quot;:link&quot;&gt;&lt;code&gt;:link&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:visited&quot;&gt;&lt;code&gt;:visited&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;:hover&quot;&gt;&lt;code&gt;:hover&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">링크 관련 의사 클래스 : &lt;a href=&quot;:link&quot;&gt; &lt;code&gt;:link&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:visited&quot;&gt; &lt;code&gt;:visited&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;:hover&quot;&gt; &lt;code&gt;:hover&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4fee080c608e3e96b9b2a08161eda11a64d324cc" translate="yes" xml:space="preserve">
          <source>Link-related pseudo-classes: &lt;a href=&quot;:visited&quot;&gt;&lt;code&gt;:visited&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:hover&quot;&gt;&lt;code&gt;:hover&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;:active&quot;&gt;&lt;code&gt;:active&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">링크 관련 의사 클래스 : &lt;a href=&quot;:visited&quot;&gt; &lt;code&gt;:visited&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:hover&quot;&gt; &lt;code&gt;:hover&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;:active&quot;&gt; &lt;code&gt;:active&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="e696599cd6356a62048c319b4436a31496f41148" translate="yes" xml:space="preserve">
          <source>Links &amp;amp; status</source>
          <target state="translated">링크 및 상태</target>
        </trans-unit>
        <trans-unit id="013341e76133765858c8bb47f3e77fd6e5ed188f" translate="yes" xml:space="preserve">
          <source>Links to Selectors Level 3.</source>
          <target state="translated">선택기 수준 3에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="8e3c49aaf1ce8f9f232ffc7b44391811f5a6afae" translate="yes" xml:space="preserve">
          <source>Lists &lt;code&gt;height&lt;/code&gt; as animatable.</source>
          <target state="translated">리스트의 &lt;code&gt;height&lt;/code&gt; 애니메이션으로.</target>
        </trans-unit>
        <trans-unit id="a14237b21a917ef158b94eee242c0fd98631bdf9" translate="yes" xml:space="preserve">
          <source>Lists &lt;code&gt;text-indent&lt;/code&gt; as animatable.</source>
          <target state="translated">&lt;code&gt;text-indent&lt;/code&gt; 를 애니메이션 가능으로 나열 합니다 .</target>
        </trans-unit>
        <trans-unit id="13463e89d2eee726c9c8bfc150bc2c2bca624820" translate="yes" xml:space="preserve">
          <source>Lists &lt;code&gt;width&lt;/code&gt; as animatable.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 를 애니메이션 가능으로 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="275e94ce13d431156c5042236e4f0adcc45a86a7" translate="yes" xml:space="preserve">
          <source>Little white lies</source>
          <target state="translated">작은 선의의 거짓말</target>
        </trans-unit>
        <trans-unit id="65c821a596ceec1c13b619a965d32175734a0c5f" translate="yes" xml:space="preserve">
          <source>Live</source>
          <target state="translated">Live</target>
        </trans-unit>
        <trans-unit id="48a9797337c3ee31a3145f2060d0f20813adecfa" translate="yes" xml:space="preserve">
          <source>Live Result</source>
          <target state="translated">라이브 결과</target>
        </trans-unit>
        <trans-unit id="07193fe45c4dfe70880268287df9801670810bc0" translate="yes" xml:space="preserve">
          <source>Live Samples</source>
          <target state="translated">라이브 샘플</target>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">라이브 예</target>
        </trans-unit>
        <trans-unit id="d66c6803c67f60624e428beacade6cb10972157a" translate="yes" xml:space="preserve">
          <source>Live examples</source>
          <target state="translated">라이브 예</target>
        </trans-unit>
        <trans-unit id="a8f778670bbf82fa7e6d46dc6c3e86457cc1eb34" translate="yes" xml:space="preserve">
          <source>Live keyword</source>
          <target state="translated">라이브 키워드</target>
        </trans-unit>
        <trans-unit id="1f641e8e90d42931bf33f6a7a99170e709e885f8" translate="yes" xml:space="preserve">
          <source>Live result</source>
          <target state="translated">라이브 결과</target>
        </trans-unit>
        <trans-unit id="ce2b0a1084a3ea629fbf0148f08da2a6c9f8133e" translate="yes" xml:space="preserve">
          <source>Live sample</source>
          <target state="translated">라이브 샘플</target>
        </trans-unit>
        <trans-unit id="fdc9cd8af766453e3f002c92aa7dcb59890ec48c" translate="yes" xml:space="preserve">
          <source>Live sample link</source>
          <target state="translated">라이브 샘플 링크</target>
        </trans-unit>
        <trans-unit id="d81b072a609cb829f45333cb83e086a659ba9738" translate="yes" xml:space="preserve">
          <source>Living Standard</source>
          <target state="translated">생활 수준</target>
        </trans-unit>
        <trans-unit id="48c768671f98a0e08288b7e5f49264e4e1782290" translate="yes" xml:space="preserve">
          <source>Locating DOM elements using selectors</source>
          <target state="translated">선택기를 사용하여 DOM 요소 찾기</target>
        </trans-unit>
        <trans-unit id="282e33be2cdf13bfecdf0bf8c2c5d1ced70868cf" translate="yes" xml:space="preserve">
          <source>Location of image to use as the marker.</source>
          <target state="translated">마커로 사용할 이미지의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="a0de5b30de0a03480f7e65890de9508e7be98485" translate="yes" xml:space="preserve">
          <source>Logical Properties &amp;amp; Values</source>
          <target state="translated">논리적 특성 및 값</target>
        </trans-unit>
        <trans-unit id="2861d321a2c702d123bd9134bf01a21cab7b4017" translate="yes" xml:space="preserve">
          <source>Logical Properties and Values</source>
          <target state="translated">논리적 특성 및 값</target>
        </trans-unit>
        <trans-unit id="36a331b183e20c8d991c6d8829f034fa8bf4130c" translate="yes" xml:space="preserve">
          <source>Logical Properties and Values can be thought of as a couple of groups in terms of current browser support. Some of the properties are essentially mappings from the physical versions, for example &lt;a href=&quot;../inline-size&quot;&gt;&lt;code&gt;inline-size&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../margin-inline-start&quot;&gt;&lt;code&gt;margin-inline-start&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;../margin-left&quot;&gt;&lt;code&gt;margin-left&lt;/code&gt;&lt;/a&gt;. These mapped properties are starting to see good browser support, and if you look at the individual pages for the properties in the &lt;a href=&quot;../css_logical_properties#Reference&quot;&gt;reference here on MDN&lt;/a&gt; you will see that Edge is the only modern browser currently missing these.</source>
          <target state="translated">논리적 속성 및 값은 현재 브라우저 지원 측면에서 두 그룹으로 생각할 수 있습니다. 일부 속성은 기본적으로 예제에 대한 물리적 버전의 매핑입니다 &lt;a href=&quot;../inline-size&quot;&gt; &lt;code&gt;inline-size&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;a href=&quot;../width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../margin-inline-start&quot;&gt; &lt;code&gt;margin-inline-start&lt;/code&gt; &lt;/a&gt; 보다는 &lt;a href=&quot;../margin-left&quot;&gt; &lt;code&gt;margin-left&lt;/code&gt; &lt;/a&gt; . 이러한 매핑 된 속성은 훌륭한 브라우저 지원을 제공하기 시작했으며 &lt;a href=&quot;../css_logical_properties#Reference&quot;&gt;여기 MDN&lt;/a&gt; 의 참조에서 속성에 대한 개별 페이지를 보면 Edge에 현재 누락 된 유일한 최신 브라우저라는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd223cd9c4b162f991b5ecf54a041f80cc6cd9e8" translate="yes" xml:space="preserve">
          <source>Logical Properties for floating and positioning</source>
          <target state="translated">플로팅 및 위치 결정을위한 논리적 특성</target>
        </trans-unit>
        <trans-unit id="929439cd985fd3c37876b48f2d6e581d8ed4600b" translate="yes" xml:space="preserve">
          <source>Logical Properties for margins, borders and padding</source>
          <target state="translated">여백, 테두리 및 패딩에 대한 논리적 속성</target>
        </trans-unit>
        <trans-unit id="aa63ff7da64da7aa04da3c434871441132eef59b" translate="yes" xml:space="preserve">
          <source>Logical Properties for sizing</source>
          <target state="translated">크기 조정을위한 논리적 속성</target>
        </trans-unit>
        <trans-unit id="ad27a6e257d9647cb4ce5662506ed3725c7b2c0d" translate="yes" xml:space="preserve">
          <source>Logical Property</source>
          <target state="translated">논리적 속성</target>
        </trans-unit>
        <trans-unit id="83d2ff9bfef585c82e2e110fa904adda3f674b95" translate="yes" xml:space="preserve">
          <source>Logical and physical properties and values</source>
          <target state="translated">논리적 및 물리적 특성 및 값</target>
        </trans-unit>
        <trans-unit id="72c96732e66ab9ff9a9ddd0c64bca474ed3c1060" translate="yes" xml:space="preserve">
          <source>Logical keywords for resize</source>
          <target state="translated">크기 조정을위한 논리 키워드</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="5ce1981f02ba57f7187c58943189ef4e396ed3b7" translate="yes" xml:space="preserve">
          <source>Logical properties and values</source>
          <target state="translated">논리적 특성 및 값</target>
        </trans-unit>
        <trans-unit id="0f8a95788a9d607f68a3eff0e8eb2f3dd0aeceb8" translate="yes" xml:space="preserve">
          <source>Logical properties and values do not make an assumption about text direction. Which is why in Grid Layout we use the keyword &lt;code&gt;start&lt;/code&gt; when aligning something to the start of the container. For me, working in English, &lt;code&gt;start&lt;/code&gt; may well be on the left, however it doesn&amp;rsquo;t have to be, and the word &lt;code&gt;start&lt;/code&gt; infers no physical location.</source>
          <target state="translated">논리적 속성과 값은 텍스트 방향에 대한 가정을하지 않습니다. 그리드 레이아웃 에서 컨테이너 시작 부분에 무언가를 정렬 할 때 키워드 &lt;code&gt;start&lt;/code&gt; 를 사용하는 이유가 여기에 있습니다. 저에게 영어로 일할 &lt;code&gt;start&lt;/code&gt; 은 왼쪽에 있을지 모르지만 &lt;code&gt;start&lt;/code&gt; 는 없으며 시작 이라는 단어 는 실제 위치를 유추하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33e6776f0ee6c1bf2e02ac6f497fd690642b4de8" translate="yes" xml:space="preserve">
          <source>Logical properties and values use the abstract terms &lt;em&gt;block&lt;/em&gt; and &lt;em&gt;inline&lt;/em&gt; to describe the direction in which they flow. The physical meaning of these terms depends on the &lt;a href=&quot;css_writing_modes&quot;&gt;writing mode&lt;/a&gt;.</source>
          <target state="translated">논리 특성과 값은 추상 용어 &lt;em&gt;블록&lt;/em&gt; 과 &lt;em&gt;인라인&lt;/em&gt; 을 사용하여 흐름 방향을 설명합니다. 이 용어의 물리적 의미는 &lt;a href=&quot;css_writing_modes&quot;&gt;쓰기 모드&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="48e3ac7ccc9ccd54688dac9bc68301bc7e2da4a3" translate="yes" xml:space="preserve">
          <source>Logical properties for everything!</source>
          <target state="translated">모든 것에 대한 논리적 특성!</target>
        </trans-unit>
        <trans-unit id="b12c315df4a8b311da4af5d04a370124b430f6ac" translate="yes" xml:space="preserve">
          <source>Logical property</source>
          <target state="translated">논리적 특성</target>
        </trans-unit>
        <trans-unit id="f2e7d80d88d6afbab6c16703eb84ac018c6525f3" translate="yes" xml:space="preserve">
          <source>Logical property or value</source>
          <target state="translated">논리적 특성 또는 값</target>
        </trans-unit>
        <trans-unit id="db211070f601ef6f1c4f27a9a8c0fedf5dc7ad97" translate="yes" xml:space="preserve">
          <source>Logical values for alignment</source>
          <target state="translated">정렬을위한 논리 값</target>
        </trans-unit>
        <trans-unit id="6c51bae7964ca81c43b1269ff8892cdd5d699c53" translate="yes" xml:space="preserve">
          <source>Look for available weights between the target and &lt;code&gt;500&lt;/code&gt;, in ascending order.</source>
          <target state="translated">대상과 &lt;code&gt;500&lt;/code&gt; 사이에서 사용 가능한 가중치 를 오름차순으로 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="e59c6077f6666cab68bcb11ef3cc1b57e3e87cc5" translate="yes" xml:space="preserve">
          <source>Lots of new values, not all clearly defined yet. Any differences in behavior, unrelated to new features, are expected to be unintentional; please report.</source>
          <target state="translated">아직 명확하게 정의되지 않은 많은 새로운 가치. 새로운 기능과 관련이없는 동작의 차이는 의도하지 않은 것으로 예상됩니다. 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="83810d85fe9fbec34579063af430b44a5f6a656e" translate="yes" xml:space="preserve">
          <source>Lowercase ASCII letters</source>
          <target state="translated">소문자 ASCII 문자</target>
        </trans-unit>
        <trans-unit id="bc818967d4728d88e19768227d5f47c32f6f86bf" translate="yes" xml:space="preserve">
          <source>Lowercase classical Greek</source>
          <target state="translated">소문자 클래식 그리스어</target>
        </trans-unit>
        <trans-unit id="3a7965038d9279a1ba3d11f19c8811cfcd5ca070" translate="yes" xml:space="preserve">
          <source>Lowercase roman numerals</source>
          <target state="translated">로마 숫자 소문자</target>
        </trans-unit>
        <trans-unit id="cb802d67d1e72080709b758976ac96e5ab6cd6f5" translate="yes" xml:space="preserve">
          <source>Lowest Version</source>
          <target state="translated">최저 버전</target>
        </trans-unit>
        <trans-unit id="27cc99609f64b6908532495c619d67aa17c968e2" translate="yes" xml:space="preserve">
          <source>Lowest version</source>
          <target state="translated">최저 버전</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="27b659266b55e413c0c9be6997f1af70a3e76ee1" translate="yes" xml:space="preserve">
          <source>MDN Basic form hints</source>
          <target state="translated">MDN 기본 양식 힌트</target>
        </trans-unit>
        <trans-unit id="0385b2a4a867b7b37365707bd3de1b582a79ccbc" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 1.1 explanations</source>
          <target state="translated">MDN WCAG 이해, 지침 1.1 설명</target>
        </trans-unit>
        <trans-unit id="3e81fe994b3e49859a739e0dfd8755f48e2a4a72" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 1.3 explanations</source>
          <target state="translated">MDN WCAG 이해, 가이드 라인 1.3 설명</target>
        </trans-unit>
        <trans-unit id="4ef7cfe99646b2e0c06e34ca8761bb38f8ac9432" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 1.4 explanations</source>
          <target state="translated">MDN WCAG 이해, 가이드 라인 1.4 설명</target>
        </trans-unit>
        <trans-unit id="a29d717494d33e490ea688e8f7ae0a2d06fa41b8" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 2.2 explanations</source>
          <target state="translated">MDN WCAG 이해, 지침 2.2 설명</target>
        </trans-unit>
        <trans-unit id="c02fdc7d8bc1d942fae90460eadb61e955448ecf" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 2.4 explanations</source>
          <target state="translated">MDN WCAG 이해, 가이드 라인 2.4 설명</target>
        </trans-unit>
        <trans-unit id="d5e009a75c2540a694e0b15d62b8a55f74a7f530" translate="yes" xml:space="preserve">
          <source>MDN Understanding WCAG, Guideline 3.3 explanations</source>
          <target state="translated">MDN WCAG 이해, 가이드 라인 3.3 설명</target>
        </trans-unit>
        <trans-unit id="8c6307bfb3b795f533739b8404318fa008b26432" translate="yes" xml:space="preserve">
          <source>MIME type</source>
          <target state="translated">MIME 유형</target>
        </trans-unit>
        <trans-unit id="e744d6d0de6223ead8562a18b04f1f4843b4d947" translate="yes" xml:space="preserve">
          <source>Made it a shorthand of the new &lt;code&gt;font-variant-*&lt;/code&gt; properties.</source>
          <target state="translated">새로운 &lt;code&gt;font-variant-*&lt;/code&gt; 속성을 줄였습니다.</target>
        </trans-unit>
        <trans-unit id="4a48ef0a4ef1b048b472e64888af078b79d31842" translate="yes" xml:space="preserve">
          <source>Main Axis</source>
          <target state="translated">주축</target>
        </trans-unit>
        <trans-unit id="800738c68f440aaf5b361b4fc9bb59a2b9eef02e" translate="yes" xml:space="preserve">
          <source>Main Axis Alignment</source>
          <target state="translated">주축 정렬</target>
        </trans-unit>
        <trans-unit id="815743bbeaef79967d784a9d4118878465e98fa7" translate="yes" xml:space="preserve">
          <source>Main axis</source>
          <target state="translated">주축</target>
        </trans-unit>
        <trans-unit id="ae8fa11fdeabc885ffa8691a22e9601eb966f66e" translate="yes" xml:space="preserve">
          <source>Major object types</source>
          <target state="translated">주요 객체 유형</target>
        </trans-unit>
        <trans-unit id="ffbd8fe777f7ebbef8b84ad33eb8ea1d9d5a2dd4" translate="yes" xml:space="preserve">
          <source>Make sure the visual focus indicator can be seen by people with low vision. This will also benefit anyone use a screen in a brightly lit space (like outside in the sun). &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/non-text-contrast.html&quot;&gt;WCAG 2.1 SC 1.4.11 Non-Text Contrast&lt;/a&gt; requires that the visual focus indicator be at least 3 to 1.</source>
          <target state="translated">시력이 약한 사람이 시각적 초점 표시기를 볼 수 있는지 확인하십시오. 또한 밝은 곳 (햇빛 외부)처럼 화면을 사용하는 사람에게도 도움이됩니다. &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/non-text-contrast.html&quot;&gt;WCAG 2.1 SC 1.4.11 비 텍스트 대비를&lt;/a&gt; 위해서는 시각적 초점 표시기가 3 대 1 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1d325576f69f679e9aeb46118eacbb076a627f8" translate="yes" xml:space="preserve">
          <source>Make the first letter of every paragraph red and big.</source>
          <target state="translated">모든 단락의 첫 글자를 빨간색과 큰 글씨로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="2d0ea75e90a15e1b3d7a648fc171ff630d4ed1f2" translate="yes" xml:space="preserve">
          <source>Make your animation as self-contained as possible. This means you should not rely on &lt;code&gt;animation-direction: alternate&lt;/code&gt;. Instead you should explicitly write a keyframe animation that goes through the full animation in one forward repetition.</source>
          <target state="translated">애니메이션을 가능한 한 독립적으로 만드십시오. 이것은 &lt;code&gt;animation-direction: alternate&lt;/code&gt; 에 의존해서는 안된다는 것을 의미합니다 : alternate . 대신 전체 애니메이션을 한 번의 반복으로 진행하는 키 프레임 애니메이션을 명시 적으로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe25a246d8620a35f965b25655df4a890c3cba95" translate="yes" xml:space="preserve">
          <source>Makes the image brighter or darker.</source>
          <target state="translated">이미지를 밝거나 어둡게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ee7f22619625263aa3f1201fc95cf63d2515d405" translate="yes" xml:space="preserve">
          <source>Makes the image transparent.</source>
          <target state="translated">이미지를 투명하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="877a74a28bceaabc9f4b2c9405ff2870227e8fe7" translate="yes" xml:space="preserve">
          <source>Makes the syntax more flexible by adding, among other things, the &lt;code&gt;or&lt;/code&gt; keyword.</source>
          <target state="translated">무엇보다 &lt;code&gt;or&lt;/code&gt; 키워드 를 추가하여 구문을보다 유연하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6f5b32cf9fd8cf61a93107e633ff4e3cf6dbaa24" translate="yes" xml:space="preserve">
          <source>Makes the value inherited by the box descendants. Note that if a descendant has a &lt;code&gt;justify-self: auto&lt;/code&gt; value, the &lt;code&gt;legacy&lt;/code&gt; keyword is not considered by the descend, only the &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;center&lt;/code&gt; value associated to it.</source>
          <target state="translated">상자의 자손이 상속 한 값을 만듭니다. 하위 항목에 &lt;code&gt;justify-self: auto&lt;/code&gt; 값 이 있으면 &lt;code&gt;legacy&lt;/code&gt; 키워드는 내림차순으로 간주되지 않으며 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 또는 &lt;code&gt;center&lt;/code&gt; 값만 고려됩니다 .</target>
        </trans-unit>
        <trans-unit id="78035a36a71bf6dacff9acc410b7a7de817cbebd" translate="yes" xml:space="preserve">
          <source>Making a List</source>
          <target state="translated">리스트 만들기</target>
        </trans-unit>
        <trans-unit id="8dbf363affb4c68ba3052ba365a26ffcc1856648" translate="yes" xml:space="preserve">
          <source>Making better use of CSS cascading properties</source>
          <target state="translated">CSS 계단식 속성을보다 잘 활용</target>
        </trans-unit>
        <trans-unit id="a8004b5807f1c34932e12f7e68a6f04550a7d7f1" translate="yes" xml:space="preserve">
          <source>Making content editable</source>
          <target state="translated">컨텐츠를 편집 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="900f1c3328bbe77c0027cc064b9277643ff0a4ed" translate="yes" xml:space="preserve">
          <source>Making images at least a minimum size</source>
          <target state="translated">이미지를 최소 크기로 만들기</target>
        </trans-unit>
        <trans-unit id="55929c6fc89b1f8d2d96a9725256bb2dd00ff8c3" translate="yes" xml:space="preserve">
          <source>Making it move back and forth</source>
          <target state="translated">앞뒤로 움직이기</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
