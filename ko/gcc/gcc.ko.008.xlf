<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">예를 들어, 아래의 1 차 함수 템플리트를 선언하면 &lt;code&gt;malloc&lt;/code&gt; 및 &lt;code&gt;alloc_size&lt;/code&gt; 속성을 모두 사용 하므로 템플리트 중 하나가 누락 되었기 때문에 템플리트의 명시 적 특수화 선언이 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 아래의 &lt;code&gt;struct A&lt;/code&gt; 가 정렬 요구 사항 &lt;code&gt;N&lt;/code&gt; 을 가지며 속성의 &lt;code&gt;packed&lt;/code&gt; 로 인해 유형의 변수가 정렬되지 않을 때마다 경고를 강제 하기 위해 일부 타사 라이브러리 헤더에 정의 되었다고 가정 하십시오 . 지정] &lt;code&gt;copy&lt;/code&gt; 관련없는의 정의에 속성을 &lt;code&gt;struct B&lt;/code&gt; 포인터의 발현에 의해 참조 유형의 모든 관련 속성 복사의 효과가 &lt;code&gt;struct B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">예를 들어, SunOS 4.1.3 의 &lt;code&gt;sprintf&lt;/code&gt; 함수는 &lt;code&gt;char *&lt;/code&gt; 를 반환 하지만 C 표준에서는 &lt;code&gt;sprintf&lt;/code&gt; 가 &lt;code&gt;int&lt;/code&gt; 를 반환 한다고 말합니다 . &lt;code&gt;fixincludes&lt;/code&gt; 프로그램은이 함수의 프로토 타입이 표준과 일치 할 수 있지만 기능은 여전히 반환하기 때문에 즉, 잘못된 것 &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">예를 들어, 아래 의 &lt;var&gt;StrongAlias&lt;/var&gt; 매크로는 &lt;code&gt;alias&lt;/code&gt; 및 &lt;code&gt;copy&lt;/code&gt; 속성을 사용하여 &lt;var&gt;alloc_size&lt;/var&gt; , &lt;var&gt;malloc&lt;/var&gt; 및 &lt;var&gt;nothrow&lt;/var&gt; 속성으로 선언 &lt;var&gt;allocate&lt;/var&gt; 함수 할당에 &lt;var&gt;alloc&lt;/var&gt; 이라는 별명을 정의합니다 . &lt;code&gt;__typeof__&lt;/code&gt; 연산자 덕분에 별칭은 대상 함수와 유형이 같습니다. &lt;code&gt;copy&lt;/code&gt; 속성의 결과로 별명도 대상과 동일한 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">예를 들어, 아래 &lt;code&gt;memset&lt;/code&gt; 호출 은 함수가 &lt;code&gt;size_t&lt;/code&gt; 유형의 값을 인수로 예상 하지만 유형 &lt;code&gt;32&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 이므로 경고로 진단됩니다 . 와</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">예를 들어, 컴파일러는 pragma를 사용하여 다음 루프를 무조건 벡터화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">예를 들어, 다음 함수 는 스택에 각각 &lt;code&gt;n&lt;/code&gt; 바이트 의 8 개 객체를 할당 하여 배열 &lt;code&gt;a&lt;/code&gt; 의 연속 요소 각각에 대한 포인터를 저장 합니다 . 그런 다음 각 배열 요소가 가리키는 스토리지를 안전하게 사용할 수있는 함수 &lt;code&gt;g&lt;/code&gt; 로 배열을 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">예를 들어, 다음 매크로를 사용하면 컴파일 타임에 두 개의 상수 정수를 추가하면 오버플로되는지 여부를 이식 가능하게 검사하고 안전하다고 알려진 경우에만 추가를 수행하고</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 함수 &lt;code&gt;foo&lt;/code&gt; 의 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">예를 들어, 내장 함수 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 및 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 를 사용하여 CPU 유형을 확인하는 &lt;code&gt;ifunc&lt;/code&gt; 리졸버 또는 생성자 우선 순위를 지원하지 않는 대상의 생성자 에서이 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">예를 들어, 컴파일러에서 &lt;code&gt;[object init]&lt;/code&gt; 와 같은 메소드 호출이 발생하면이 를 &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; 에 대한 호출로 컴파일 한 후 리턴 된 값을 적절한 함수 포인터 유형으로 캐스트하고 그런 다음 호출합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">구조체 속성에 대한 전체 설명서는 &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 변수 속성&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">함수 및 계산 된 goto에 대한 간접 호출의 경우 링커는 &lt;em&gt;스텁을&lt;/em&gt; 생성 합니다. 스텁은 때때로 &lt;em&gt;트램펄린&lt;/em&gt; 이라고도하는 점프 패드 입니다. 따라서 간접 호출 / 점프는 이러한 스텁으로 이동합니다. 스텁에는 원하는 주소로 직접 점프하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">O64 ABI에 대한 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">모든 언어의 입력 파일에 대해 file에서 해당 Go 선언을 생성 &lt;var&gt;file&lt;/var&gt; . 이렇게하면 Go &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;func&lt;/code&gt; 선언 이 생성 되어 다른 언어로 작성된 코드에 Go 인터페이스를 작성하는 데 유용한 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">For instance,</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">예를 들어, 스택이 절대 주소 '에서 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">예를 들어 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; 가 있고</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">예를 들어, x86에서 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; 로 함수를 컴파일 할 수 있습니다. GCC는 두 개의 함수 클론을 생성합니다. 하나는</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">예를 들어, x86에서는 &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 속성을 가진 함수 하나 와 &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 함수를 하나 선언 할 수 있습니다. 이것은 첫 번째 함수를 사용하여 컴파일하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">예를 들어 SB-1에서 FP 예외가 비활성화되고 64 비트 코드를 내보내는 경우 두 FP 파이프를 모두 사용할 수 있습니다. 그렇지 않으면 하나의 FP 파이프 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">예를 들어, 다음 선언</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">내부 이름의 경우 모든 문자가 중요합니다. 외부 이름의 경우 유효 문자 수는 링커에 의해 정의됩니다. 거의 모든 대상에 대해 모든 문자가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">라이브러리 코드의 경우 라이브러리가 필요한 모든 템플릿 인스턴스를 제공하려면 모든 객체 파일을 함께 연결하십시오. 링크는 실패하지만 인스턴스화가 부작용으로 생성됩니다. 그러나 여러 라이브러리가 동일한 인스턴스를 제공하려고하면 충돌이 발생할 수 있습니다. 더 효과적으로 제어하려면 다음 옵션에 설명 된대로 명시 적 인스턴스화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">함수 호출 후 인수를 팝해야하는 머신의 경우, 각 함수가 리턴되는 즉시 인수를 팝하십시오. 레벨에서</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">온라인으로 제공되는 Objective-C의 역사에 대한 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">GCC의 트랜잭션 메모리 지원에 대한 자세한 내용 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;은 GNU 트랜잭션 메모리 라이브러리의 GNU 트랜잭션 메모리 라이브러리&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">프로파일 지향 최적화의 경우 동일한 최적화 및 코드 생성 옵션과 함께 소스 파일을 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Technical Corrigenda, Rationale 문서 및 온라인으로 제공되는 C의 역사에 관한 정보는 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">런타임 식별을 위해, 해당 영역의 시작 주소 (각 기능 항목에서 &lt;var&gt;M&lt;/var&gt; 을 뺀 값 )는 결과 바이너리 의 &lt;code&gt;__patchable_function_entries&lt;/code&gt; 섹션에 추가로 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">단 정밀도 부동 소수점 비교의 경우 &lt;code&gt;fsub&lt;/code&gt; 명령어를 생성하고 플래그를 테스트하십시오. 이는 소프트웨어 비교보다 빠르지 만 NaN이 있거나 두 개의 서로 다른 작은 숫자를 비교하여 차이가 0으로 계산 될 때 잘못된 결과를 얻을 수 있습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">일부 대상 시스템의 경우 GCC는 형식 속성에 대한 추가 옵션을 지원합니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성 선언&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">일부 대상의 경우 접미사가로 지정된 루트 디렉토리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">알 수없는 크기의 문자열 연산의 경우 작은 블록의 경우 인라인 코드와 큰 블록의 라이브러리 호출로 런타임 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">GNU C 라이브러리를 사용하는 시스템의 경우 기본값이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">COMDAT 또는 약한 기호를 지원하지 않는 대상의 경우 모호한 링크가있는 대부분의 엔티티는 로컬 기호로 생성되어 링커에서 중복 정의 오류가 발생하지 않습니다. 그러나 인라인의 로컬 정적에는 여러 사본이 있으면 거의 확실하게 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">중첩 함수에 일반적으로 트램폴린이 필요한 대상의 경우 설명자를 사용하지 않고 항상 생성하십시오. 그렇지 않으면 HP-PA 또는 IA-64와 같이 필요없는 대상의 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">모든 사용자 모드 Xtensa 코드가 위치 독립적 코드 (PIC) 여야하는 GNU / Linux와 같은 대상의 경우이 옵션은 커널 코드 컴파일을 위해 PIC를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">테스트 범위 분석을 위해 &lt;code&gt;gcov&lt;/code&gt; 를 사용 하여</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">ABI 버전 2의 NeXT 런타임의 경우 실제 메소드 호출을 수행하기 전에 메소드 호출에서 nil 수신자를 확인하십시오. 이것이 기본값이며 다음을 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">명명 된 함수의 경우 컴파일러는 해당 함수가 지속되는 동안 인터럽트를 비활성화하는 코드를 추가합니다. 소스에 이름이 지정된 기능이 없으면 pragma가 사용되지 않는다는 경고가 표시됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">명명 된 함수의 경우 컴파일러는 명명 된 함수를 호출 할 때 항상 레지스터 간접 호출 모델을 사용합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">분기 예측 최적화를 위해 &lt;code&gt;__builtin_expect&lt;/code&gt; 표현식이 &lt;code&gt;true&lt;/code&gt; 확률 은 GCC의 &lt;code&gt;builtin-expect-probability&lt;/code&gt; 매개 변수에 의해 제어되며 기본값은 90 %입니다. &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; 를 사용 하여 확률 값을 개별 표현식에 명시 적으로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">include 지시문의 인용 양식의 경우 다음으로 지정된 디렉토리</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">include 지시문의 인용 양식의 경우 현재 파일의 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">x86-32 컴파일러의 경우 다음을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">기존 코드에 가시성 지원을 추가하려는 경우 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; 사용을 찾을 수 있습니다. 이것은 가시성을 설정하려는 선언을 &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; 및 &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; . 심볼 가시성은 &lt;strong&gt;API 인터페이스 계약의 일부로&lt;/strong&gt; 보아야 하므로 모든 새 코드는 기본값이 아닌 경우 항상 가시성을 지정해야합니다. 즉, 로컬 DSO 내에서만 사용되는 선언은 PLT 간접 간접비를 피하기 위해 &lt;strong&gt;항상&lt;/strong&gt; 명시 적으로 숨겨진 것으로 표시 해야합니다. 이를 명확하게하면 코드의 가독성 및 자체 문서화에 도움이됩니다. ISO C ++ 사양 요구 사항으로 인해 &lt;code&gt;operator new&lt;/code&gt; 및 &lt;code&gt;operator delete&lt;/code&gt; 는 항상 기본 가시성이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">생성 된 코드가 각 함수마다 하나의 종료점을 갖도록 강제하십시오 (강제하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">사소한 블록 이동 에 &lt;code&gt;memcpy&lt;/code&gt; 를 사용하도록 강요하지 마십시오 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">포스 &lt;code&gt;long&lt;/code&gt; 종류가 다양한 64 비트 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">강제 &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , 포인터 타입은 폭 32 비트 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">다음과 같은 경우 GCC가 내부적으로보기 번호를 지정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">DWARF2 + 라인 번호 테이블을 생성하려는 경우 GCC가 내부적으로 DWARF2 + 라인 번호 테이블을 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">함수에 대한 모든 호출을 간접적으로 수행하십시오. 이는 함수 호출에 대한보다 정확한 타이밍 정보를 생성하는 인텔 프로세서 추적을 사용할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">모든 기능을 4 바이트 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">명령의 I / O 변형을 사용하여 모든로드 및 저장 명령이 항상 캐시를 무시하도록합니다. 기본값은 캐시를 무시하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">어셈블리 출력이 항상 16 진 상수를 사용하도록합니다. 일반적으로 이러한 상수는 부호있는 10 진수이지만이 옵션은 테스트 슈트 및 / 또는 미적 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">ARM (A32) ISA에서 강제 코드 생성</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">아키텍처 수준에 따라 Thumb (T16 / T32) ISA에서 코드를 강제로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">간접 호출을 강제하고 레지스터를 통해 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">조건부 분기에 지연 슬롯을 사용하도록 하여 적절한 명령을 찾을 수없는 경우 지연 슬롯을 &lt;code&gt;nop&lt;/code&gt; 로 채 웁니다 . 기본적으로이 옵션은 비활성화되어 있습니다. 원래 SH7055에있는 하드웨어 버그를 해결하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">jli_s 명령어를 사용하여 함수를 강제로 호출합니다. 이 옵션은 ARCv2 아키텍처에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; 명령어를 사용하여 특정 함수를 강제로 호출 합니다. &lt;code&gt;jli&lt;/code&gt; 명령은 차종에 저장된 테이블의 사용 &lt;code&gt;.jlitab&lt;/code&gt; 이 명령을 사용하여 어드레스 된 기능의 위치를 보유 섹션.</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">속성의 형식적 구문.</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">특정 대상에 특정한 형식 검사.</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">이전에는 &lt;code&gt;hi&lt;/code&gt; 레지스터입니다. 이 제약은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">사전 처리해야하는 자유 형식의 포트란 소스 코드 (전통적인 전 처리기 사용).</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 자유 형식의 포트란 소스 코드.</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">함수 속성은 함수 선언에서 &lt;code&gt;__attribute__&lt;/code&gt; 키워드에 의해 소개되고 그 뒤에 이중 괄호로 묶인 속성 스펙이옵니다. 이중 괄호 안에 쉼표로 구분하거나 한 속성 스펙을 다른 속성 스펙 바로 뒤에 따라 선언에 여러 속성을 지정할 수 있습니다. 참조 &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성 구문을&lt;/a&gt; 특성 구문 및 배치에 대한 정확한 규칙. 동일한 함수의 고유 한 선언에서 호환되는 속성 사양이 병합됩니다. 동일한 함수의 선언에 이미 적용된 속성과 호환되지 않는 속성 사양은 경고와 함께 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">기능 정밀도. 트랩 핸들러는 부동 소수점 예외를 발생시킨 함수를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">함수 프로토 타입</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">프로파일 인스 트루먼 테이션을 기반으로하는 함수 재정렬은 함수의 첫 실행 시간을 수집하고이 함수를 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">함수는 16 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">크기를 최적화하지 않는 한 함수는 32 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 속성으로 선언 된 함수 에는 기본 &lt;code&gt;asm&lt;/code&gt; 이 필요합니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">발신자 모드에서 다른 모드의 기능을 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">프롤로그 / 에필로그 기능은 적절한 서브 루틴에 대한 호출로 확장됩니다. 코드 크기가 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">일반적으로 내장되어 있지만 ISO C에 의해 정의 된 의미가없는 함수 (예 : &lt;code&gt;alloca&lt;/code&gt; 및 &lt;code&gt;ffs&lt;/code&gt; )는 내장 함수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">자금 조달 자유 소프트웨어</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">또한 &lt;em&gt;초기 클로버&lt;/em&gt; 피연산자가 읽기 / 쓰기 피연산자 인 경우 해당 피연산자는 사용한 후에 만 ​​기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">이후 버전의 GCC는 제로 확장 또는 대상 정의 &lt;code&gt;ptr_extend&lt;/code&gt; 패턴을 사용할 수 있습니다. 부호 확장에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++은 가상 함수가 '</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G ++을 사용하면 익명 구조체와 공용체에 정적이 아닌 공개 데이터 멤버가 아닌 멤버 (예 : 필드)를 가질 수 있습니다. 이 확장은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++를 사용하면 속성이 괄호로 묶인 직접 초기화 프로그램을 따를 수 있습니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++를 사용하면 부동 소수점 리터럴이 정수 상수 표현식에 나타날 수 있습니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G ++를 사용하면 const 부동 소수점 형식의 정적 데이터 멤버를 클래스 정의에서 초기화 자로 선언 할 수 있습니다. 표준은 const 정수형과 const 열거 형의 정적 멤버에 대한 이니셜 라이저 만 허용하므로이 확장은 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++는 복사 할당을위한 &quot;직관적 인&quot;알고리즘을 구현합니다. 모든 직접베이스를 할당 한 다음 모든 멤버를 할당합니다. 이 알고리즘에서 가상 기본 하위 오브젝트가 두 번 이상 발생할 수 있습니다. 이 예에서 복사는 다음 순서로 진행됩니다. '</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G ++는 ELF 대상 (GNU / Linux 등), Mac OS X 및 Microsoft Windows를 포함하여 링커에서 지원하는 대상에서 Borland 모델을 구현합니다. 그렇지 않으면 G ++는 자동 모델을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++는 휘발성 객체에 할당 할 때 GCC와 동일한 동작을 구현합니다. 할당 된 객체를 다시 읽지 않고 할당 된 rvalue가 재사용됩니다. C ++ 대입 표현식에서 lvalue는 lvalue로 사용되며 lvalue로 사용될 경우 휘발성 객체가 참조됩니다. 예를 들어, 다음 예제에서 &lt;var&gt;vref&lt;/var&gt; 는 예상대로 &lt;var&gt;vobj&lt;/var&gt; 를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC는 적합한 독립 실행 형 구현 또는 적합한 호스팅 구현을위한 컴파일러로 사용하는 것을 목표로합니다. 기본적으로 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 를 &lt;code&gt;1&lt;/code&gt; 로 정의 하고 ISO C 함수의 이름을 사용할 때 표준에 정의 된 의미가 있다고 가정 하여 호스팅 된 구현의 컴파일러 역할을합니다 . 독립형 환경에 적합한 독립형 구현으로 작동하게하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 C 레이블에 속성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 열거 자에 속성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 null 문에 특성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 기 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC는 유연한 배열 구성원의 정적 초기화를 허용합니다. 이는 원래 구조를 포함하는 새 구조를 정의한 다음 데이터를 포함하기에 충분한 크기의 배열을 정의하는 것과 같습니다. 예를 들어, 다음에서 &lt;code&gt;f1&lt;/code&gt; 은 마치 &lt;code&gt;f2&lt;/code&gt; 처럼 선언 된 것처럼 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC를 통해 사용자는 특정 유형의 진단을 선택적으로 활성화 또는 비활성화하고 진단 종류를 변경할 수 있습니다. 예를 들어, 프로젝트 정책에 따라 모든 소스가</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC에서는 &lt;code&gt;typedef&lt;/code&gt; 이름을 벡터 유형의 유형 지정자로 사용할 수 있지만 다음 상황에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC에서는 &lt;code&gt;typedef&lt;/code&gt; 이름을 벡터 유형의 유형 지정자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC를 사용하면 중첩 된 블록 범위에서 &lt;em&gt;로컬 레이블&lt;/em&gt; 을 선언 할 수 있습니다 . 로컬 레이블은 일반 레이블과 비슷하지만 선언 된 블록 내 에서만 레이블을 참조 할 수 있습니다 ( &lt;code&gt;goto&lt;/code&gt; 문을 사용하거나 주소를 사용하여).</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC를 사용하면</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC에는 이미 광범위한 접미사 목록이 있습니다. 이 지시문은 접미사 목록 끝에 항목을 추가하지만 목록을 끝에서 뒤로 검색하므로이 기술을 사용하여 이전 항목을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">또한 GCC는 ColdFire 마이크로 아키텍처 &lt;var&gt;uarch&lt;/var&gt; 를 조정할 때 매크로 &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 여기서 &lt;var&gt;uarch&lt;/var&gt; 는 위에 제공된 인수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC는 또한 인수가 다음에서 시작한다는 것을 암시 적으로 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC는 컴파일 중에 메시지를 인쇄하기위한 간단한 메커니즘도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC는 또한 대상 특정 매크로 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 를 제공하는데 , 이는 컴파일중인 대상 시스템의 모든 데이터 유형에 사용 된 최대 정렬입니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC는 또한 네트워크 레지스터에 직접 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC는 변수 선언 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조 )에 대한 속성도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC는 &lt;code&gt;format&lt;/code&gt; 속성의 후보가 될 수있는 함수 정의에 대해서도 경고 합니다. 다시, 이들은 가능한 후보자입니다. GCC는 추측 &lt;code&gt;format&lt;/code&gt; 속성이 같은 함수 호출하는 기능에 적합 할 수 있습니다 &lt;code&gt;vprintf&lt;/code&gt; 또는 &lt;code&gt;vscanf&lt;/code&gt; 을 하지만, 항상 그렇지,하고있는 일부 기능하지 않을 수 있습니다 &lt;code&gt;format&lt;/code&gt; 속성이 검색되지 않을 수 있습니다 적절한이다.</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC는 항상 C99 및 C11 요구 사항을 따르므로 나눗셈 결과가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC는 가능한 경우 항상 프로그램 컴파일을 시도합니다. (예를 들어) 표준을 준수하지 않기 때문에 그 의미가 분명한 프로그램을 절대 거부하지 않습니다. 그러나 어떤 경우에는 C 및 C ++ 표준에 따라 특정 확장이 금지 되어 있으며 적합한 컴파일러 에서 진단 &lt;em&gt;을&lt;/em&gt; 발행 &lt;em&gt;해야합니다&lt;/em&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC는 기본적으로 GCC의 일부이며 Apple 시스템에서 사용되는 Apple / NeXT Objective-C 런타임 라이브러리와 동일하지 않은 GNU Objective-C 런타임 라이브러리를 사용합니다. 이 설명서에는 여러 가지 차이점이 있습니다. 옵션</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC 자체는 적합한 독립 실행 형 구현을 시도합니다. 이것이 의미하는 바에 대한 자세한 내용은 &lt;a href=&quot;standards#Standards&quot;&gt;GCC가 지원하는 언어 표준을&lt;/a&gt; 참조하십시오 . 이러한 구현에 필요한 라이브러리 기능 외에도 나머지 C 라이브러리는 운영 체제 공급 업체에서 제공합니다. 해당 C 라이브러리가 C 표준을 준수하지 않으면 프로그램에 경고 메시지가 표시 될 수 있습니다 (특히</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC는 복잡한 자동 변수를 비 연속 방식으로 할당 할 수 있습니다. 허수 부분이 스택에있는 동안 (또는 그 반대) 실제 부분이 레지스터에있을 수도 있습니다. DWARF 디버그 정보 형식 만이를 나타낼 수 있으므로 DWARF를 사용하는 것이 좋습니다. stabs 디버그 정보 형식을 사용하는 경우 GCC는 비 연속 복합 변수를 비 복합 유형의 두 개의 개별 변수 인 것처럼 설명합니다. 변수의 실제 이름이 &lt;code&gt;foo&lt;/code&gt; 인 경우 두 가상의 변수 이름은 &lt;code&gt;foo$real&lt;/code&gt; 및 &lt;code&gt;foo$imag&lt;/code&gt; 입니다. 디버거를 사용하여이 두 가상 변수를 검사하고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC는 HSA 프로그래머 참조 설명서 버전 1.0.1에 설명 된대로 HSAIL 텍스트 형식의 이진 표현 (BRIG)을 컴파일 할 수 있습니다. 이 기능은 일반적으로 gcc 지원 프로세서에 대한 HSA 런타임 API의 HSAIL 최종 확장을 구현하는 데 사용됩니다. HSA 표준은 &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt; 에서 자유롭게 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC는 VxWorks 커널과 실시간 프로세스 (RTP) 모두에 대한 코드를 생성 할 수 있습니다. 이 옵션은 전자에서 후자로 전환됩니다. 또한 전 처리기 매크로 &lt;code&gt;__RTP__&lt;/code&gt; 도 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC는 asm에서 하나의 교환 쌍만 처리 할 수 ​​있습니다. 더 많이 사용하면 컴파일러가 실패 할 수 있습니다. 두 대안이 완전히 동일한 경우 수정자를 사용할 필요가 없습니다. 이것은 재 장전 패스에서 시간을 낭비 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC는 시스템 헤더 파일에서 알려진 특정 문제를 해결하기위한 쉘 스크립트와 함께 제공됩니다. GCC만이 일반적으로 찾을 수있는 특수 디렉토리에 다양한 헤더 파일의 수정 사본을 설치합니다. 스크립트는 우리가 알고있는 문제 사례에 대한 모든 시스템 헤더 파일을 검색하여 다양한 시스템에 적응합니다.</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC 컴파일 코드는 때때로 다음 형식의 HP-UX 어셈블러에서 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC는 '와 같은 프로그램 조각에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC는 전처리 조건부 내에서 종료되지 않은 문자 상수에 대해 불평합니다. 일부 프로그램에는 조건부로 영어 설명이 포함되어있어 실패 할 수 있습니다. 이러한 주석에 아포스트로피가 포함 된 경우 GCC에서 오류를보고 할 수 있습니다. 예를 들어이 코드는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">에서 찾을 수있다 오픈 파워 64 비트 ELF V2 ABI 사양과 GCC의 준수 &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt; . 이 문서의 부록 A에는 호환되는 컴파일러가 제공해야하는 벡터 API 인터페이스가 나와 있습니다. 프로그래머는 여기에 설명 된 인터페이스를 우선적으로 사용해야합니다. 그러나 역사적으로 GCC는 벡터 명령에 액세스하기위한 추가 인터페이스를 제공했습니다. 이것들은 아래에 간략하게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC는 현재 호출 방출 &lt;code&gt;vmldExp2&lt;/code&gt; , &lt;code&gt;vmldLn2&lt;/code&gt; , &lt;code&gt;vmldLog102&lt;/code&gt; , &lt;code&gt;vmldPow2&lt;/code&gt; , &lt;code&gt;vmldTanh2&lt;/code&gt; , &lt;code&gt;vmldTan2&lt;/code&gt; , &lt;code&gt;vmldAtan2&lt;/code&gt; , &lt;code&gt;vmldAtanh2&lt;/code&gt; , &lt;code&gt;vmldCbrt2&lt;/code&gt; , &lt;code&gt;vmldSinh2&lt;/code&gt; , &lt;code&gt;vmldSin2&lt;/code&gt; , &lt;code&gt;vmldAsinh2&lt;/code&gt; , &lt;code&gt;vmldAsin2&lt;/code&gt; , &lt;code&gt;vmldCosh2&lt;/code&gt; , &lt;code&gt;vmldCos2&lt;/code&gt; , &lt;code&gt;vmldAcosh2&lt;/code&gt; , &lt;code&gt;vmldAcos2&lt;/code&gt; , &lt;code&gt;vmlsExp4&lt;/code&gt; , &lt;code&gt;vmlsLn4&lt;/code&gt; , &lt;code&gt;vmlsLog104&lt;/code&gt; , &lt;code&gt;vmlsPow4&lt;/code&gt; , &lt;code&gt;vmlsTanh4&lt;/code&gt; 을 , &lt;code&gt;vmlsTan4&lt;/code&gt; , &lt;code&gt;vmlsAtan4&lt;/code&gt; , &lt;code&gt;vmlsAtanh4&lt;/code&gt; , &lt;code&gt;vmlsCbrt4&lt;/code&gt; , &lt;code&gt;vmlsSinh4&lt;/code&gt; , &lt;code&gt;vmlsSin4&lt;/code&gt; , &lt;code&gt;vmlsAsinh4&lt;/code&gt; , &lt;code&gt;vmlsAsin4&lt;/code&gt; , &lt;code&gt;vmlsCosh4&lt;/code&gt; , &lt;code&gt;vmlsCos4&lt;/code&gt; , &lt;code&gt;vmlsAcosh4&lt;/code&gt; 및 &lt;code&gt;vmlsAcos4&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCC는 ColdFire 대상에 대한 코드를 생성 할 때마다 매크로 &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 이 매크로 의 &lt;var&gt;arch&lt;/var&gt; 는</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC는 지정된 &lt;var&gt;cpu&lt;/var&gt; 에 대한 전 처리기 매크로를 정의합니다 . '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC는 몇 가지 기본 제공 매크로를 정의하여 사용자 코드가 기능의 존재 여부를 테스트 할 수 있습니다. 다음의 내장 매크로 중 거의 모든 것이 장치 기능에서 추론되므로</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">GCC는 ColdFire 대상 &lt;var&gt;cpu&lt;/var&gt; 가 선택된 경우 매크로 &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; 를 정의합니다 . 또한 정의 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; 의 값, &lt;var&gt;family&lt;/var&gt; 위 표에 의해 주어진다된다.</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">GCC는 이 옵션이 활성화되면 매크로 &lt;code&gt;__mcfhwdiv__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC는 680x0 아키텍처 &lt;var&gt;arch&lt;/var&gt; 조정할 때 매크로 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 또한 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; &lt;var&gt;arch&lt;/var&gt; 를 정의 하지 않는 한</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC는 이 기본 제공을 지원하도록 업데이트 된 대상에 대한 전 처리기 매크로 &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC는이 옵션의 값에 따라 두 개의 매크로를 정의합니다. 첫 번째는 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 이며 대상 아키텍처의 이름을 문자열로 제공합니다. 두 번째는 &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; 형식입니다 . 여기서 &lt;var&gt;foo&lt;/var&gt; 는 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 의 대문자 값입니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCC가 SSEx 명령어를 누르면</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">'을 지정하지 않으면 GCC는 최적화하지 않을 때 함수를 인라인하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC는 기본 &lt;code&gt;asm&lt;/code&gt; 의 &lt;var&gt;AssemblerInstructions&lt;/var&gt; 를 구문 분석하지 않으므로 컴파일러 내부에서 발생하는 작업을 컴파일러와 통신 할 방법이 없습니다. GCC는 &lt;code&gt;asm&lt;/code&gt; 에서 심볼을 볼 수 없으며 참조되지 않은 것으로 버릴 수 있습니다. 또한 메모리 또는 레지스터 수정과 같은 어셈블러 코드의 부작용에 대해서도 알지 못합니다. 일부 컴파일러와 달리 GCC는 범용 레지스터가 변경되지 않는다고 가정합니다. 이 가정은 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC는 다음과 관련된 C 라이브러리 기능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC는 호스팅 된 구현에만 필요한 라이브러리 기능을 제공하지 않으며 C99에서 모든 플랫폼에서 독립 실행 형 구현에 필요한 모든 기능을 제공하지는 않습니다. 호스팅 환경의 기능을 사용하려면 다른 곳 (예 : GNU C 라이브러리)에서 해당 기능을 찾아야합니다. &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;표준 라이브러리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCC는 문자열 상수 안에 나타날 때 매크로 인수를 대체하지 않습니다. 예를 들어 GCC의 다음 매크로</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC는 확장 정수 유형을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC는 정적이 아닌 로컬 변수와 함께이 기능을 지원하지 않습니다. 이러한 변수에는 어셈블러 이름이 없기 때문입니다. 변수를 특정 레지스터에 넣으려는 경우 &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC는 이러한 값을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC는 기본적으로이 속성을 기반으로 경고를 보냅니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC는 기본적으로이 옵션을 활성화합니다. 최적화가 설정되어 있는지 여부에 관계없이 컴파일러가 변수가 참조되는지 확인하도록하려면</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCC는 현재 취약하지 않은 인스턴스 변수를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC는 오랫동안 가변성 매크로를 지원했으며 다른 인수와 마찬가지로 변수 인수에 이름을 지정할 수있는 다른 구문을 사용했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCC에는 다음과 같은 사양 문자열이 내장되어 있습니다. 스펙 파일은 이러한 문자열을 대체하거나 자체 문자열을 작성할 수 있습니다. 개별 대상도이 목록에 고유 한 사양 문자열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC는 제한된 버퍼 오버 플로우 방지 메커니즘을 구현하여 데이터를 쓰려는 객체의 크기를 결정하고 크기가 충분하지 않은 경우 쓰기를 방지함으로써 일부 버퍼 오버 플로우 공격을 방지 할 수 있습니다. 아래에 설명 된 내장 함수는 함께 사용하거나 최적화가 활성화 된 경우 최상의 결과를 제공합니다. 예를 들어, 기능 경계에서 객체 크기를 감지하거나 사소하지 않은 제어 흐름을 통해 포인터 할당을 따르려면</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC는 &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt; 에있는 ARM C 언어 확장 (ACLE) 사양에 설명 된대로 C 확장을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC는 C 및 C ++ 모두에 &lt;code&gt;offsetof&lt;/code&gt; 매크로 를 구현하기위한 구문 확장을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC는 &lt;em&gt;trampolines&lt;/em&gt; 라는 기술을 사용하여 중첩 함수의 주소를 가져옵니다 . 이 기술은 C ++의 Lexical Closures (1988 년 10 월 17-21 일 USENIX C ++ Conference Proceedings의 Thomas M. Breuel)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC는 &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc&lt;/a&gt; 에있는 ARMv8-M 보안 확장 : 개발 도구 엔지니어링 사양 요구 사항에 설명 된대로 ARMv8-M 보안 확장을 구현합니다 . ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf .</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC는 함수를 인라인으로 선언하는 세 가지 시맨틱을 구현합니다. 하나는</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC에는 표준 C 라이브러리에 여러 함수의 내장 버전이 포함되어 있습니다. 이 함수는 이름이 &lt;code&gt;__builtin_&lt;/code&gt; 접두사로 시작 하고 다른 하나는없는 두 가지 형식으로 제공됩니다 . 두 형식 모두 동일한 유형 (시제품 포함), 동일한 주소 (주소를 가져올 때) 및 C 라이브러리 함수와 동일한 의미를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC는 기존 C와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC는 사용 가능한 메모리에 의해서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC는 일부 시스템 헤더 파일의 수정 된 버전을 설치해야합니다. 대부분의 대상 시스템에는 변경하지 않는 한 GCC에서 작동하지 않는 일부 헤더 파일이 있기 때문입니다. 일부는 버그가 있고 일부는 ISO C와 호환되지 않으며 일부는 다른 컴파일러의 특수 기능에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC는 더 이상 DWARF 버전 1을 지원하지 않으며 이는 버전 2 이상과 실질적으로 다릅니다. 역사적 이유로 다음과 같은 다른 DWARF 관련 옵션</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC는 일반적으로 &lt;code&gt;__STDC__&lt;/code&gt; 를 1로 정의하고 추가로 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC는 일반적으로 특정 내장 함수를보다 효율적으로 처리하기 위해 특수 코드를 생성합니다. 예를 들어, &lt;code&gt;alloca&lt;/code&gt; 호출 은 스택을 직접 조정하는 단일 명령이 될 수 있으며 &lt;code&gt;memcpy&lt;/code&gt; 호출 은 인라인 복사 루프가 될 수 있습니다. 결과 코드는 종종 더 작고 빠르지 만 함수 호출이 더 이상 나타나지 않으므로 해당 호출에 중단 점을 설정할 수 없으며 다른 라이브러리와 연결하여 함수의 동작을 변경할 수도 없습니다. 또한 함수가 내장 함수로 인식되면 GCC는 해당 함수에 대한 정보를 사용하여 해당 함수에 대한 호출 문제를 경고하거나 결과 코드에 여전히 해당 함수에 대한 호출이 포함되어 있어도보다 효율적인 코드를 생성 할 수 있습니다 . 예를 들어, 경고는</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCC는 일반적으로 문자열 상수를 읽기 전용으로 만듭니다. 동일한 모양의 문자열 상수가 여러 개 사용되는 경우 GCC는 문자열의 복사본 하나만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCC는 일반적으로 단일 명령을 사용하여 GOT에서 값을로드합니다. 이것은 비교적 효율적이지만 GOT가 약 64k보다 작은 경우에만 작동합니다. 더 큰 것은 링커가 다음과 같은 오류를보고하게합니다.</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">GCC 옵션.</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC는 C 구조체가 멤버를 갖지 않도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC는 C에서 인터럽트 핸들러 작성을 지원하는 몇 가지 특수 내장 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC는 위에서 언급 한 것 이외의 많은 내장 기능을 제공합니다. 이들 중 일부는 예외 또는 가변 길이 인수 목록 처리에 내부적으로 사용되며 수시로 변경 될 수 있으므로 여기에 문서화되어 있지 않습니다. 이러한 기능은 일반적으로 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC는 PowerPC 프로세서 제품군이 Motorola의 AltiVec 프로그래밍 인터페이스 매뉴얼에 설명 된 AltiVec 작업에 액세스 할 수있는 인터페이스를 제공합니다. &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 를 포함 하고 사용하여 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC는 picoChip 명령어 세트에서 선택된 기계 명령어에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC는 정렬되지 않은 피연산자에 대한 예외를 피하기 위해 ISO C99 부동 소수점 비교 매크로의 기본 제공 버전을 제공합니다. 그들은 표준 매크로 (같은 이름이 &lt;code&gt;isgreater&lt;/code&gt; , &lt;code&gt;isgreaterequal&lt;/code&gt; , &lt;code&gt;isless&lt;/code&gt; , &lt;code&gt;islessequal&lt;/code&gt; , &lt;code&gt;islessgreater&lt;/code&gt; 및 &lt;code&gt;isunordered&lt;/code&gt; 를 함께) &lt;code&gt;__builtin_&lt;/code&gt; 앞에 둔. 우리는 라이브러리 구현자가 각각의 표준 매크로를 내장 된 동등한 것으로 &lt;code&gt;#define&lt;/code&gt; 할 수있게하려고합니다 . 같은 방식으로 GCC는 &lt;code&gt;fpclassify&lt;/code&gt; , &lt;code&gt;isfinite&lt;/code&gt; , &lt;code&gt;isinf_sign&lt;/code&gt; , &lt;code&gt;isnormal&lt;/code&gt; 및 &lt;code&gt;signbit&lt;/code&gt; 를 제공합니다 &lt;code&gt;__builtin_&lt;/code&gt; 접두사가 붙은 내장 기능 . &lt;code&gt;isinf&lt;/code&gt; 및 &lt;code&gt;isnan&lt;/code&gt; 내장 된 기능으로하고,하지 않고 모두 표시 &lt;code&gt;__builtin_&lt;/code&gt; 접두사.</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC는 Sony / Toshiba / IBM SPU 언어 확장 사양에 설명 된대로 SPU 프로세서에 대한 확장을 제공합니다. GCC의 구현은 몇 가지면에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC는 TI C6X 프로세서의 특정 명령에 액세스 할 수있는 내장 기능을 제공합니다. 아래에 나열된 이러한 내장 함수는 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; 헤더 파일을 포함시킨 후에 사용할 수 있습니다 . C6X 명령어에 직접 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC는 TILE-Gx 프로세서의 모든 명령에 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC는 TILEPro 프로세서의 모든 명령에 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC는 MSA MIPS SIMD 아키텍처에서 제공하는 SIMD 명령어에 액세스하기위한 내장 함수를 제공합니다. &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; 를 포함 하고 사용하여 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC는 ST Microelectronics Loongson-2E 및 -2F 프로세서에서 제공하는 SIMD 명령어에 액세스하기위한 내장 함수를 제공합니다. &lt;code&gt;loongson.h&lt;/code&gt; 헤더 파일 을 포함시킨 후 사용 가능한 이러한 내장 함수 는 다음 64 비트 벡터 유형에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC는 많은 FR-V 고유의 내장 기능을 제공합니다. 일반적으로 이러한 기능은 FR-V 제품군, Softune C / C ++ 컴파일러 설명서 (V6), Fujitsu Semiconductor에서 설명하는 기능과 호환되도록 설계되었습니다. 두 가지 예외는 &lt;code&gt;__MDUNPACKH&lt;/code&gt; 및 &lt;code&gt;__MBTOHE&lt;/code&gt; 이며 GCC 형식은 값이 아닌 포인터로 128 비트 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC는 다른 MIPS 고유의 내장 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC는 내장 함수 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 및 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 를 제공하지만 C 라이브러리 함수 &lt;code&gt;setjmp&lt;/code&gt; 및 &lt;code&gt;longjmp&lt;/code&gt; 와 유사하지만 상호 교환 할 수는 없습니다 . 내장 버전은 GCC 라이브러리에서 내부적으로 사용되어 일부 대상에서 예외 처리를 구현합니다. 내장 코드 대신 사용자 코드 에서 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 에 선언 된 표준 C 라이브러리 함수를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC는 현재 함수의 이름을 문자열로 보유하는 세 가지 마법 상수를 제공합니다. C ++ 11 및 이후 모드에서는 세 가지 모두 상수 표현식으로 취급되며 &lt;code&gt;constexpr&lt;/code&gt; constexts 에서 사용할 수 있습니다 . 이 상수 중 첫 번째는 &lt;code&gt;__func__&lt;/code&gt; 이며 C99 표준의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC는 일부 PowerPC 프로세서 제품군 (예 : POWER8)에서 사용 가능한 HTM (Hardware Transactional Memory) 명령어에 액세스하기위한 두 가지 인터페이스를 제공합니다. 두 인터페이스는 PowerPC 고유의 내장 기능과 PowerPC와 S / 390간에 공통적 인 인라인 기능으로 구성된 상위 인터페이스로 구성된 저수준 인터페이스로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC는 &quot;GNU Compiler Collection&quot;의 약자입니다. GCC는 여러 주요 프로그래밍 언어를위한 통합 컴파일러 배포판입니다. 이러한 언어에는 현재 C, C ++, Objective-C, Objective-C ++, Fortran, Ada, D, Go 및 BRIG (HSAIL)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">기술 보고서 ​​초안에 지정된 10 진수 부동 소수점에 대한 GCC 지원이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">기술 보고서 ​​초안에 지정된 고정 소수점 유형에 대한 GCC 지원이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC는 &quot;전통적인&quot;Objective-C ( &quot;Objective-C 1.0&quot;이라고도 함)를 지원하며 Objective-C 예외 및 동기화 구문을 지원합니다. 또한 속성, 빠른 열거 (Objective-C에만 해당), 메서드 속성 및 프로토콜의 @optional 및 @required 키워드를 포함하여 여러 &quot;Objective-C 2.0&quot;언어 확장을 지원합니다. GCC는 Objective-C ++를 지원하며 Objective-C에서 사용 가능한 기능은 Objective-C ++에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC는 모두 일반 벡터 확장을 사용하여 MIPS DSP 작업을 지원합니다 ( &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; ) 및 내장 함수 MIPS 고유의 컬렉션입니다. 두 종류의 지원은</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC는 (참조 모두 일반 벡터 확장을 사용하여 SPARC에 SIMD 연산을 지원하는 &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; )뿐만 아니라 내장 함수는 SPARC 비쥬얼 명령에 대한 세트 (VIS) 등을. 사용할 때</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC는 주어진 선언에 대해 어셈블리에 사용되는 이름을 변경 하는 &lt;code&gt;#pragma&lt;/code&gt; 지시문을 지원합니다 . 이 pragma는 모든 플랫폼에서 지원되지만 주로 Solaris 시스템 헤더와의 호환성을 제공하기위한 것입니다. 이 효과는 asm labels 확장을 사용하여 얻을 수도 있습니다 ( &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC는 일반적으로 생성되는 코드에 런타임 계측 추가를 제어하는 ​​여러 명령 줄 옵션을 지원합니다. 예를 들어, 계측의 한 가지 목적은 프로그램 핫스팟, 코드 범위 분석 또는 프로파일 가이드 최적화를 찾는 데 사용하기위한 프로파일 링 통계를 수집하는 것입니다. 또 다른 클래스의 프로그램 계측은 런타임 검사를 추가하여 유효하지 않은 포인터 역 참조 또는 범위를 벗어난 어레이 액세스와 같은 프로그래밍 오류와 스택 스매싱 또는 C ++ vtable 하이재킹과 같은 의도적으로 적대적인 공격을 탐지합니다. 디버그 또는 프로그램 분석 목적으로 다른 형태의 추적 또는 함수 레벨 계측을 구현하는 데 사용할 수있는 일반 후크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC는 부동 소수점 레지스터의 너비가 32 비트가 아닌 64 인 o32 ABI의 변형을 지원합니다. 이 조합을 선택할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC는 2의 보수 정수 유형 만 지원하며 모든 비트 패턴은 일반 값입니다.</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC 지원은 쌍 단일 일반 벡터 확장 (참조 모두 사용하여 작업 &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; ) 및 내장 함수 MIPS 고유의 컬렉션을. 두 종류의 지원은</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC는 주로 다른 컴파일러 용으로 작성된 코드를 컴파일하기 위해 여러 유형의 pragma를 지원합니다. 일반적으로 pragma를 사용하지 않는 것이 좋습니다. 자세한 설명 은 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC는 내장 함수를 사용하여 C 프로그래밍 언어로 표현할 수없는 일부 RX 명령어를 지원합니다. 다음과 같은 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC는 D 2.0 프로그래밍 언어를 지원합니다. D 언어 자체는 현재 &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html에&lt;/a&gt; 설명 된 참조 구현 및 지원 언어 사양으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC는 다음과 같은 AVR 장치 및 ISA를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC는 1998 년에 발표 된 원본 ISO C ++ 표준과 2011 및 2014 개정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCC는 C-SKY V2 프로세서를 컴파일 할 때 이러한 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC는 두 가지 형태의 SVE 코드 생성을 지원합니다. 모든 크기의 벡터 레지스터와 함께 작동하는 &quot;벡터 길이에 구애받지 않는&quot;출력과 GCC가 최적화 이유로 유용 할 때 벡터 길이에 대해 가정 할 수있는 &quot;벡터 길이에 따른&quot;출력. '의 가능한 값</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC는 식별자의 모든 문자를 중요하게 취급합니다. K &amp;amp; R-1 (2.2)에 따르면,&amp;ldquo;처음 8자를 초과하면 더 많을 수 있지만 중요하지 않습니다.&amp;rdquo;. 또한 K &amp;amp; R-1 (2.2)에 따르면&amp;ldquo;식별자는 문자와 숫자의 순서입니다. 첫 번째 문자는 문자 여야합니다. 밑줄 _은 문자로 계산됩니다.&amp;rdquo;그러나 GCC는 식별자에 달러 기호도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC는 &lt;var&gt;name&lt;/var&gt; 을 사용 하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다 (</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC는 &lt;var&gt;name&lt;/var&gt; 을 사용 하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다. 만약</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC는 가비지 수집기를 사용하여 자체 메모리 할당을 관리합니다. 이 매개 변수는 가비지 콜렉터의 힙이 콜렉션간에 확장 될 수있는 최소 백분율을 지정합니다. 이를 조정하면 컴파일 속도가 향상 될 수 있습니다. 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC는 수정 된 버전의 시스템 헤더 파일을 사용합니다. 이것은 필요하지만 항상 원활하게 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC는 휴리스틱을 사용하여 프로파일 링 피드백으로 제공되지 않는 분기 확률을 추측합니다 (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC는 ISO C 표준을 준수하지 않을 수있는 시스템 C 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC는</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCC의 기본 동작은 &lt;code&gt;dllexport&lt;/code&gt; 속성을 사용하여 모든 인라인 함수를 내보내는 것 입니다. 이로 인해 파일 크기가 부풀려 질 수 있으므로</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">C 및 C ++ 코드에서 사용 가능한 고급 언어 인터페이스의 GCC 구현은 몇 가지면에서 Motorola의 설명서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCC의 옵티마이 저는이 코드를 이전 예제의 비 휘발성 코드처럼 취급하지 않습니다. 이전 호출의 결과가 여전히 유효하다는 가정하에 루프 밖으로 이동하거나 생략하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">GCC의 옵티마이 저는 출력 변수가 필요하지 않다고 판단하면 &lt;code&gt;asm&lt;/code&gt; 문을 무시 합니다. 또한 옵티마이 저는 코드가 항상 동일한 결과를 리턴한다고 생각하는 경우 (즉, 호출간에 입력 값이 변경되지 않음) 코드를 루프 밖으로 이동할 수 있습니다. 은 Using &lt;code&gt;volatile&lt;/code&gt; 규정하는 것은 이러한 최적화를 사용하지 않습니다. &lt;code&gt;asm&lt;/code&gt; &lt;code&gt;asm goto&lt;/code&gt; 문을 포함하여 출력 피연산자가없는 asm 문 은 암시 적으로 일시적입니다.</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX에는 객체 파일의 절대 경로에 추가 할 접두사가 포함되어 있습니다. 접두사는 절대적이거나 상대적 일 수 있습니다. 기본값은 접두사가 없습니다.</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP는 고정 배선 된 절대 경로를 제거 할 초기 디렉토리 이름 수를 나타냅니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNI 지침.</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C를 사용하면 특정 하드웨어 레지스터를 C 변수와 연결할 수 있습니다. 거의 모든 경우에 컴파일러가 레지스터를 할당하도록 허용하면 최상의 코드가 생성됩니다. 그러나 특별한 상황에서는 가변 스토리지에 대한보다 정확한 제어가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C는 ISO C를 확장하여 함수 프로토 타입이 나중의 구식 비 프로토 타입 정의를 재정의 할 수 있도록합니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C는 ISO 표준 C에는없는 몇 가지 언어 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C ++는 구식 함수 정의를 지원하지 않으므로이 확장은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP에는 두 가지 가변 가변 매크로 확장이 있으며 위의 매크로 정의 형식 중 하나와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP에서는 이런 식으로 변수 인수를 완전히 생략 할 수 있습니다. 위의 예에서 매크로의 확장은 여전히 ​​형식 문자열 뒤에 추가 쉼표가 있기 때문에 컴파일러가 불평합니다.</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU 일반 공중 사용 허가서</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU General Public License는 GCC를 복사하고 공유하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C는 컴파일러가 직접 생성 한 상수 문자열 객체를 제공합니다. C 상수 문자열 앞에 ''문자를 붙여 상수 문자열 객체를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C는 다음 예제와 같이 언어에 내장 된 예외 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C는 동기화 된 블록을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C는 빠른 열거 구문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-C 런타임 기능.</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C는 C / Objective-C 형식에서 형식 인코딩을 만들 수 있는 &lt;code&gt;@encode&lt;/code&gt; 구문을 지원합니다 . 예를 들어, &lt;code&gt;@encode(int)&lt;/code&gt; 는 컴파일러에서 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 로 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">GNU 방언</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11의 GNU 방언. 이름 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17의 GNU 방언. 이것이 C 코드의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90의 GNU 방언 (일부 C99 기능 포함).</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99의 GNU 방언 이름 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">C 언어 제품군에 대한 GNU 확장.</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">C ++ 언어에 대한 GNU 확장.</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64 비트 명령어가 활성화 된 경우 범용 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">일반 레지스터 1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;addl&lt;/code&gt; 명령어를 위한 일반 레지스터 &lt;code&gt;r0&lt;/code&gt; ~ &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r29&lt;/code&gt; , &lt;code&gt;r30&lt;/code&gt; 및 &lt;code&gt;r31&lt;/code&gt; 이 아닌 일반 레지스터</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">범용 32 비트 레지스터</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">일반적으로 메모리 트랜잭션이 성공한다고 보장 할 수 없으며 항상 적절한 대체 코드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">일반적으로 최적화가 지정되지 않으면 함수가 인라인되지 않습니다. 인라인으로 선언 된 함수의 경우이 속성은 인라인에 적용되는 제한과 상관없이 함수를 인라인합니다. 이러한 기능을 인라인하지 않으면 오류로 진단됩니다. 이러한 함수가 간접적으로 호출되면 컴파일러는 최적화 수준에 따라 함수를 인라인하거나 인라인하지 않을 수 있으며 간접 호출을 인라인하지 못하면 진단되거나 진단되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">일반적으로 함수에 인라인하는 것은 제한됩니다. 이 속성으로 표시된 함수의 경우 가능하면이 함수 내부의 모든 호출이 인라인됩니다. &lt;code&gt;noinline&lt;/code&gt; 속성 과 비슷한 속성으로 선언 된 함수는 인라인되지 않습니다. 함수 자체가 인라인에 고려되는지 여부는 크기와 현재 인라인 매개 변수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">일반적으로 링크 타임에 지정된 옵션은 컴파일 타임에 지정된 옵션보다 우선하지만 GCC에서는 입력 파일을 컴파일하는 데 사용 된 설정에서 링크 타임 옵션을 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">ColdFire 하드웨어 나누기 및 나머지 명령어를 생성 (생성하지 않음)합니다. 만약</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">GP 기준 액세스를 생성 (생성하지 않음)합니다. 다음과 같은 &lt;var&gt;option&lt;/var&gt; 이름이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">MIPS16 코드를 생성 (생성하지 않음)하십시오. GCC가 MIPS32 또는 MIPS64 아키텍처를 대상으로하는 경우 MIPS16e ASE를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">위치에 독립적이며 공유 라이브러리에 링크 될 수있는 코드를 생성 (생성하지 않음)하십시오. 이 옵션은 다음에 만 영향을줍니다</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">SVR4 스타일 동적 객체에 적합한 코드를 생성 (생성하지 않음)합니다.</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">&lt;em&gt;기본 주소&lt;/em&gt; 를 사용하는 코드를 생성 (생성하지 않음)하십시오 . 기본 주소를 사용하면 전역 레지스터에 상수를 설정하기위한 요청 (어셈블러 및 링커에서 처리)이 자동으로 생성됩니다. 레지스터는 레지스터에 보유 된 값에서 0에서 255 사이의 하나 이상의 기본 주소 요청에 사용됩니다. 일반적으로 코드가 짧고 빠르지 만 처리 할 수있는 다양한 데이터 항목의 수가 제한됩니다. 이것은 많은 정적 데이터를 사용하는 프로그램이 필요할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">함수 포인터가 함수 주소, TOC 값을 제공하는 3 워드 디스크립터를 가리키는 AIX 및 64 비트 Linux 시스템에서 포인터를 통해 호출 할 때 정적 체인 레지스터 ( &lt;code&gt;r11&lt;/code&gt; ) 를로드하는 코드를 생성 (생성하지 않음) 하십시오. 레지스터 &lt;code&gt;r2&lt;/code&gt; 에로드되고 레지스터 &lt;code&gt;r11&lt;/code&gt; 에 로드 될 정적 체인 값 . 그만큼</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">구 버전의 GCC와의 호환성을 위해 최대 64 비트 정렬로 구조 매개 변수를 전달하는 코드를 생성 (생성하지 않음)하십시오.</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">함수가 AIX 및 64 비트 Linux 시스템에서 포인터를 통해 호출하는 경우 함수 프롤로그의 예약 된 스택 위치에 TOC 값을 저장하는 코드를 생성 (생성하지 않음)하십시오. TOC 값이 프롤로그에 저장되지 않은 경우 포인터를 통해 호출 직전에 저장됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">microMIPS 코드를 생성 (생성하지 않음)하십시오.</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">때 &lt;code&gt;friz&lt;/code&gt; 명령을 생성 (생성하지 마십시오)</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">서브 루틴 호출을 수행하기 위해 &lt;code&gt;bras&lt;/code&gt; 명령어를 사용하여 코드를 생성하거나 생성하지 마십시오 . 총 실행 파일 크기가 64k를 초과하지 않는 경우에만 안정적으로 작동합니다. 기본적으로 &lt;code&gt;basr&lt;/code&gt; 명령어 를 사용하는 것이지만 이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">&lt;code&gt;mvcle&lt;/code&gt; 명령어를 사용하여 코드를 생성 (또는 생성하지 않음)하여 블록 이동을 수행합니다. 언제</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">생성 (또는하지 않음) '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">휘발성 asm 문 바로 앞과 뒤에 정지 비트를 생성하거나 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">GNU 어셈블러 용 코드를 생성하거나 생성하지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">GNU 링커에 대한 코드를 생성하거나 생성하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">16 비트 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">HP-UX 10 링커에 필요할 때마다 3 명령로드 및 저장 시퀀스를 생성합니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">32x16 비트 곱하기 및 곱하기 누산 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">&lt;code&gt;.debug_pubnames&lt;/code&gt; 및 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 섹션을 GDB 색인으로 변환하기에 적합한 형식으로 생성하십시오 . 이 옵션은 GDB 인덱스 버전 7을 생성 할 수있는 링커에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">&lt;code&gt;mul64&lt;/code&gt; 및 &lt;code&gt;mulu64&lt;/code&gt; 명령어를 생성하십시오 . 에 대해서만 유효</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 지침을 생성하십시오 . 이것이 기본값 인 경우</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">&lt;var&gt;M&lt;/var&gt; 번째 NOP 앞에 함수 진입 점이있는 각 함수의 시작 부분에서 바로 &lt;var&gt;N&lt;/var&gt; NOP를 생성하십시오 . 경우 &lt;var&gt;M&lt;/var&gt; 은 , 그것은 디폴트 생략 &lt;code&gt;0&lt;/code&gt; 단지 제 NOP의 주소 함수 엔트리 포인트 있도록. NOP 명령어는 코드 세그먼트가 쓰기 가능한 경우 런타임에 원하는 계측에서 패치하는 데 사용할 수있는 추가 공간을 예약합니다. 공간의 양은 NOP의 수를 통해 간접적으로 제어 할 수 있습니다. 사용 된 NOP 명령어는 내부 GCC 백엔드 인터페이스 &lt;code&gt;gen_nop&lt;/code&gt; 에서 생성 한 명령어에 해당합니다 . 이 동작은 대상에 따라 다르며 아키텍처 변형 및 / 또는 다른 컴파일 옵션에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">값으로 전달되는 가장 큰 구조를 설명하는 C 헤더를 생성하십시오 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; 및 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 섹션을 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">원자 내장 함수에 대한 GNU / Linux 호환 gUSA 소프트웨어 원자 시퀀스를 생성합니다. 생성 된 원자 시퀀스는 시스템의 인터럽트 / 예외 처리 코드에서 추가 지원이 필요하며 SH3 * 및 SH4 * 단일 코어 시스템에만 적합합니다. 이 옵션은 대상이 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 및 SH3 * 또는 SH4 * 인 경우 기본적으로 사용됩니다 . 대상이 SH4A 인 경우이 옵션은 하드웨어 원자 명령어 &lt;code&gt;movli.l&lt;/code&gt; 및 &lt;code&gt;movco.l&lt;/code&gt; 을 부분적으로 사용하여 '</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">프로그램의 모든 데이터 개체에 대한 GP 상대 액세스를 생성하십시오. 이 옵션을 사용하는 경우 프로그램의 전체 데이터 및 BSS 세그먼트는 64K 메모리에 적합해야하며 적절한 링커 스크립트를 사용하여 전역 포인터의 주소 지정 가능 범위 내에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fc88c33c3fc53124fa0f92092082efc85a7cdc0" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for small data objects that are not external, weak, or uninitialized common symbols. Also use GP-relative addressing for objects that have been explicitly placed in a small data section via a &lt;code&gt;section&lt;/code&gt; attribute.</source>
          <target state="translated">외부, 약하거나 초기화되지 않은 공통 기호가 아닌 작은 데이터 개체에 대한 GP 기준 액세스를 생성합니다. 또한 &lt;code&gt;section&lt;/code&gt; 속성을 통해 작은 데이터 섹션에 명시 적으로 배치 된 객체에 대해 GP 기준 주소 지정을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="548a87f5ac4837154b7b55bf3a0684dbbd7b3056" translate="yes" xml:space="preserve">
          <source>Generate GP-relative addresses for function pointers as well as data pointers. If you use this option, the entire text, data, and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">함수 포인터 및 데이터 포인터에 대한 GP 상대 주소를 생성합니다. 이 옵션을 사용하면 프로그램의 전체 텍스트, 데이터 및 BSS 세그먼트가 64K 메모리에 맞아야하며 적절한 링커 스크립트를 사용하여 전역 포인터의 주소 지정 가능 범위 내에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f3a196b430f925ff0ff89b9ccb1a7bf625049d2" translate="yes" xml:space="preserve">
          <source>Generate MIPS16 code on alternating functions. This option is provided for regression testing of mixed MIPS16/non-MIPS16 code generation, and is not intended for ordinary use in compiling user code.</source>
          <target state="translated">대체 기능에 MIPS16 코드를 생성합니다. 이 옵션은 혼합 MIPS16 / 비 MIPS16 코드 생성의 회귀 테스트를 위해 제공되며 사용자 코드를 컴파일 할 때 일반적으로 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b7aa3b59b611b18a6a4ec60f9d9a319cc049bd6b" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the large model: The TOC may be up to 4G in size. Other data and code is only limited by the 64-bit address space.</source>
          <target state="translated">큰 모델을위한 PowerPC64 코드 생성 : TOC의 크기는 최대 4G입니다. 다른 데이터 및 코드는 64 비트 주소 공간에 의해서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a74518f21d3c00aafcfd3b084cf7c00aee1848" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the medium model: The TOC and other static data may be up to a total of 4G in size. This is the default for 64-bit Linux.</source>
          <target state="translated">중형 모델 용 PowerPC64 코드 생성 : TOC 및 기타 정적 데이터의 크기는 최대 4G입니다. 64 비트 Linux의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8cfde8c4df8b2eb989bc818febefc0e7c28874e7" translate="yes" xml:space="preserve">
          <source>Generate PowerPC64 code for the small model: The TOC is limited to 64k.</source>
          <target state="translated">소형 모델 용 PowerPC64 코드 생성 : TOC는 64k로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c7ea62356cd3157102c66b58a868e34df2a5c060" translate="yes" xml:space="preserve">
          <source>Generate VRSAVE instructions when generating AltiVec code.</source>
          <target state="translated">AltiVec 코드를 생성 할 때 VRSAVE 명령어를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="0bd45272345d657871ab9cf111cdd01907672885" translate="yes" xml:space="preserve">
          <source>Generate a __return_loc section pointing to all return instrumentation code.</source>
          <target state="translated">모든 리턴 계측 코드를 가리키는 __return_loc 섹션을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="2cf42b0393916fe85d4396c2a4ea44c0c0b17c4a" translate="yes" xml:space="preserve">
          <source>Generate a call to the function &lt;code&gt;abort&lt;/code&gt; at the end of a &lt;code&gt;noreturn&lt;/code&gt; function. It is executed if the function tries to return.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 함수 의 끝에서 함수 &lt;code&gt;abort&lt;/code&gt; 에 대한 호출을 생성하십시오 . 함수가 리턴을 시도하면 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfebab0f7716c6c7d48b3db2e26f828205f2eb0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the ARM Procedure Call Standard for all functions, even if this is not strictly necessary for correct execution of the code. Specifying</source>
          <target state="translated">코드를 올바르게 실행하는 데 꼭 필요한 것은 아니지만 모든 함수에 대해 ARM 프로 시저 호출 표준을 준수하는 스택 프레임을 생성하십시오. 지정</target>
        </trans-unit>
        <trans-unit id="09e70235b2ae102fe1ff7ae3b745820674b997a0" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">모든 리프 함수에 대해 Thumb 프로 시저 호출 표준을 준수하는 스택 프레임을 생성하십시오. 리프 함수는 다른 함수를 호출하지 않는 함수입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="4e955728a6de82a9bddec4fed62b648dcfc40e9a" translate="yes" xml:space="preserve">
          <source>Generate a stack frame that is compliant with the Thumb Procedure Call Standard for all non-leaf functions. (A leaf function is one that does not call any other functions.) The default is</source>
          <target state="translated">모든 리프가 아닌 함수에 대해 Thumb 프로 시저 호출 표준을 준수하는 스택 프레임을 생성하십시오. 리프 함수는 다른 함수를 호출하지 않는 함수입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="4839b3bf0bbd769aa7c0e4fcd67cdaaed9746bd5" translate="yes" xml:space="preserve">
          <source>Generate an executable in the ELF format, rather than the default &amp;lsquo;</source>
          <target state="translated">기본 '이 아닌 ELF 형식으로 실행 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="6c98697c08dfd7f201b6b9c98efc4af59466b6c7" translate="yes" xml:space="preserve">
          <source>Generate an inline expansion using loop code for all block compares that are less than or equal to &lt;var&gt;num&lt;/var&gt; bytes, but greater than the limit for non-loop inline block compare expansion. If the block length is not constant, at most &lt;var&gt;num&lt;/var&gt; bytes will be compared before &lt;code&gt;memcmp&lt;/code&gt; is called to compare the remainder of the block. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; 바이트 이하 이지만 비 루프 인라인 블록 비교 확장의 한계보다 큰 모든 블록 비교에 루프 코드를 사용하여 인라인 확장을 생성하십시오 . 블록 길이가 일정하지 않은 경우 &lt;code&gt;memcmp&lt;/code&gt; 가 호출되어 블록의 나머지를 비교 하기 전에 최대 &lt;var&gt;num&lt;/var&gt; 바이트가 비교됩니다 . 기본값은 대상에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ee53ff6577ff7bdeec45265bba557ddc96dc42d1" translate="yes" xml:space="preserve">
          <source>Generate big-endian code.</source>
          <target state="translated">빅 엔디안 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="faa1ec28121e6f94c7459039f3f456a29482ffe4" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">빅 엔디안 코드를 생성합니다. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="497dec8a0e83106900bb3f13f33208ac13cc564e" translate="yes" xml:space="preserve">
          <source>Generate big-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">빅 엔디안 코드를 생성합니다. GCC가 '</target>
        </trans-unit>
        <trans-unit id="9f5c216ca40ddba6d0b7e0356dfb54eddd239c13" translate="yes" xml:space="preserve">
          <source>Generate calls as register indirect calls, thus providing access to the full 32-bit address range.</source>
          <target state="translated">등록 간접 호출로 호출을 생성하여 전체 32 비트 주소 범위에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf711e932fbd2a210fbf658c2ed048fe589f322" translate="yes" xml:space="preserve">
          <source>Generate checks for control speculation in selective scheduling. This flag is disabled by default.</source>
          <target state="translated">선택적 스케줄링에서 제어 추론 검사를 생성합니다. 이 플래그는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="340f82c2c0a45e961b4cd414df01b6dcda27429e" translate="yes" xml:space="preserve">
          <source>Generate code containing floating-point instructions. This is the default.</source>
          <target state="translated">부동 소수점 명령어가 포함 된 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d1eb9be83c7705dec7853ee52d8e983f54f63d2c" translate="yes" xml:space="preserve">
          <source>Generate code containing library calls for floating-point.</source>
          <target state="translated">부동 소수점에 대한 라이브러리 호출을 포함하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ffda305054ff95e7394bd4003326530b52f9583d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit ABI.</source>
          <target state="translated">32 비트 또는 64 비트 ABI 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b67c6b7cf041ab09d12159e623bf4650fd97244d" translate="yes" xml:space="preserve">
          <source>Generate code for 32-bit or 64-bit environments of Darwin and SVR4 targets (including GNU/Linux). The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any PowerPC variant. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits, and generates code for PowerPC64, as for</source>
          <target state="translated">Darwin 및 SVR4 대상 (GNU / Linux 포함)의 32 비트 또는 64 비트 환경에 대한 코드를 생성하십시오. 32 비트 환경은 int, long 및 32 비트를 가리키는 포인터를 설정하고 모든 PowerPC 변형에서 실행되는 코드를 생성합니다. 64 비트 환경은 int를 32 비트 및 long으로 설정하고 포인터를 64 비트로 설정하고 PowerPC64 용 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4491a667cb7d0b6c838f6faaee6a864eadc20bd" translate="yes" xml:space="preserve">
          <source>Generate code for CR16C or CR16C+ architecture. CR16C+ architecture is default.</source>
          <target state="translated">CR16C 또는 CR16C + 아키텍처를위한 코드를 생성하십시오. CR16C + 아키텍처가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="67648931cfe6b959b11bf696abb5438c66a26217" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 단 정밀도 모드에 있다고 가정하고 SH4-100에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="de1af2a9972c47a564f5e7fcce23d995d6ae1b8b" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">배정 밀도 부동 소수점 연산이 사용되지 않도록 SH4-100에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="107ca25d9739e824d4175850436b6598a742f5a1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100 in such a way that the floating-point unit is not used.</source>
          <target state="translated">부동 소수점 단위가 사용되지 않는 방식으로 SH4-100에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f4838bc707d842b8a2b2e768456d1b164bf348d3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-100.</source>
          <target state="translated">SH4-100 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb7eb15dc4aa3c46b2283b182c63acf0a395433d" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 단 정밀도 모드라고 가정하고 SH4-200에 대한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c7c33168087299c03364283296e9feb1a533b788" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">배정 밀도 부동 소수점 연산이 사용되지 않도록 SH4-200 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b14c102c6af7d5f6fb411b3d326830a45f2aceb0" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">부동 소수점 단위를 사용하지 않는 방식으로 SH4-200 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5283c23e1460ff21798ade4588312627145b49aa" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-200.</source>
          <target state="translated">SH4-200 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="2fb0dbc9dfbf231f5e57962b75a086351c1f46b3" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">배정 밀도 부동 소수점 연산이 사용되지 않도록 SH4-300 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ff44e3f28e2fd7daaa679641ff86e04eab85fb68" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300 without in such a way that the floating-point unit is not used.</source>
          <target state="translated">부동 소수점 단위를 사용하지 않는 방식으로 SH4-300 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5dd69911ae792e28eb1d16efd78aa149dec9b0b1" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-300.</source>
          <target state="translated">SH4-300 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3190f28d97b238beea538765e992a0880400111e" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-340 (no MMU, no FPU).</source>
          <target state="translated">SH4-340 용 코드를 생성합니다 (MMU 없음, FPU 없음).</target>
        </trans-unit>
        <trans-unit id="964d89eec4f49e488b7e663bfb784df7de2d9807" translate="yes" xml:space="preserve">
          <source>Generate code for SH4-500 (no FPU). Passes</source>
          <target state="translated">SH4-500 용 코드를 생성합니다 (FPU 없음). 패스</target>
        </trans-unit>
        <trans-unit id="bd07f25b5dfd9dc83556617396ced4ced292840d" translate="yes" xml:space="preserve">
          <source>Generate code for Smart Mode, using only registers numbered 0-7 to allow use of 16-bit instructions. This option is ignored for CK801 where this is the required behavior, and it defaults to on for CK802. For other targets, the default is off.</source>
          <target state="translated">16 비트 명령어를 사용할 수 있도록 0-7까지의 레지스터 만 사용하여 스마트 모드 용 코드를 생성하십시오. 이 옵션은 필수 동작 인 CK801의 경우 무시되며 기본값은 CK802입니다. 다른 대상의 경우 기본값은 해제입니다.</target>
        </trans-unit>
        <trans-unit id="d1ef13a03c7e2ed855aab73fe845bb318c6bf94c" translate="yes" xml:space="preserve">
          <source>Generate code for a 16-bit, 32-bit or 64-bit environment. The</source>
          <target state="translated">16 비트, 32 비트 또는 64 비트 환경을위한 코드를 생성하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="6f846bc35b4ddbb63662daaf0b8a0b9a36eafb1b" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit environment, which sets int, long, and pointer to 32 bits. This is the only supported behavior so the flag is essentially ignored.</source>
          <target state="translated">int, long 및 32 비트에 대한 포인터를 설정하는 32 비트 환경에 대한 코드를 생성하십시오. 이것은 유일하게 지원되는 동작이므로 플래그는 본질적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c70fb6bc63f54c3dd3b6636fb15aabdae1032dda" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32 비트 또는 64 비트 환경을위한 코드를 생성하십시오. 32 비트 환경은 int, long 및 32 비트를 가리키는 포인터를 설정합니다. 64 비트 환경은 int를 32 비트 및 long으로 설정하고 64 비트를 포인터로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="25466413f97413255c5d54e631be1e6a23f5330d" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits. These are HP-UX specific flags.</source>
          <target state="translated">32 비트 또는 64 비트 환경을위한 코드를 생성하십시오. 32 비트 환경은 int, long 및 32 비트를 가리키는 포인터를 설정합니다. 64 비트 환경은 int를 32 비트 및 long으로 설정하고 64 비트를 포인터로 설정합니다. 이들은 HP-UX 특정 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="89222a0849ae48c73c6bd1624ef4d88ea3c84874" translate="yes" xml:space="preserve">
          <source>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long, and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.</source>
          <target state="translated">32 비트 또는 64 비트 환경을위한 코드를 생성하십시오. 32 비트 환경은 int, long 및 32 비트에 대한 포인터를 설정합니다. 64 비트 환경은 int를 32 비트 및 long으로 설정하고 64 비트를 포인터로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7a6899675bc409f91ebf1c2951874d09f2171d0a" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/10. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11 / 10 용 코드를 생성하십시오. -msoft-float -mno-split을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bee1deaf455b6a6b4cdb2bb13d6ee23ad81f5012" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/40. Implies -msoft-float -mno-split.</source>
          <target state="translated">PDP-11 / 40 용 코드를 생성하십시오. -msoft-float -mno-split을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d9780d13a5a51c47480c939a428413699ac3ed17" translate="yes" xml:space="preserve">
          <source>Generate code for a PDP-11/45. This is the default.</source>
          <target state="translated">PDP-11 / 45 용 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="92b920e8ba8535d90a16588551ee999d568f0291" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target.</source>
          <target state="translated">빅 엔디안 대상에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d68254cfeddff60f3b9cadfb72e8acbde8b8a455" translate="yes" xml:space="preserve">
          <source>Generate code for a big-endian target. This is the default for HP-UX.</source>
          <target state="translated">빅 엔디안 대상에 대한 코드를 생성하십시오. 이것이 HP-UX의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5fbe216af63a08f8f99c457d81f72aa33271a249" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target.</source>
          <target state="translated">리틀 엔디안 대상에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7fec6c67ff3977f6cbf34379a4b039899b9238d9" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default for AIX5 and GNU/Linux.</source>
          <target state="translated">리틀 엔디안 대상에 대한 코드를 생성하십시오. 이것이 AIX5 및 GNU / Linux의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="12a32136f06def3f80692a9e99c0d8f9b7d0b140" translate="yes" xml:space="preserve">
          <source>Generate code for a little-endian target. This is the default.</source>
          <target state="translated">리틀 엔디안 대상에 대한 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="86cf4bd8b15db1a7bae18b7503fdfe578d14ff3d" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in big-endian mode; the default is to compile code for a little-endian processor.</source>
          <target state="translated">빅 엔디안 모드에서 실행되는 프로세서의 코드를 생성합니다. 리틀 엔디안 프로세서의 코드를 컴파일하는 것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b9c63b6f7dde24a56bfd3b0c8c39dff387d09612" translate="yes" xml:space="preserve">
          <source>Generate code for a processor running in little-endian mode. This is the default for all standard configurations.</source>
          <target state="translated">리틀 엔디안 모드에서 실행되는 프로세서의 코드를 생성하십시오. 이것이 모든 표준 구성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7c9d614db21563decf26e4450a12e8ff0db080a3" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire instruction set architecture. Permissible values of &lt;var&gt;arch&lt;/var&gt; for M680x0 architectures are: &amp;lsquo;</source>
          <target state="translated">특정 M680x0 또는 ColdFire 명령어 세트 아키텍처에 대한 코드를 생성하십시오. M680x0 아키텍처에 허용되는 &lt;var&gt;arch&lt;/var&gt; 값은 '</target>
        </trans-unit>
        <trans-unit id="4756b1c10e780d22755d4efd055be671187986d0" translate="yes" xml:space="preserve">
          <source>Generate code for a specific M680x0 or ColdFire processor. The M680x0 &lt;var&gt;cpu&lt;/var&gt;s are: &amp;lsquo;</source>
          <target state="translated">특정 M680x0 또는 ColdFire 프로세서에 대한 코드를 생성하십시오. M680x0 &lt;var&gt;cpu&lt;/var&gt; 는 다음과 같습니다. '</target>
        </trans-unit>
        <trans-unit id="cf0efda24e55f61b98734329e006dab8159c05d8" translate="yes" xml:space="preserve">
          <source>Generate code for given RISC-V ISA (e.g. &amp;lsquo;</source>
          <target state="translated">지정된 RISC-V ISA에 대한 코드 생성 (예 : '</target>
        </trans-unit>
        <trans-unit id="1cc9f255978b92385d0966d847bc3f1f4feff36e" translate="yes" xml:space="preserve">
          <source>Generate code for given the specified PTX ISA (e.g. &amp;lsquo;</source>
          <target state="translated">지정된 PTX ISA에 대한 코드 생성 (예 : '</target>
        </trans-unit>
        <trans-unit id="4b8a962abd2bc5357f263a724ad7ce6201860ac4" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires divide instruction emulation.</source>
          <target state="translated">분할 명령어 에뮬레이션이 필요한 하드웨어 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff05f7bfb6de148dd31e5b918468ff58be8cc2b" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which requires multiply instruction emulation.</source>
          <target state="translated">명령어 에뮬레이션을 곱해야하는 하드웨어 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9d141b4aab656e3ada981384fd6736554ccf4fe3" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports divide instructions. This is the default.</source>
          <target state="translated">나누기 명령어를 지원하는 하드웨어 용 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="63b8cd12a9a7b77524e7516bc8342264efc809e2" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports multiply instructions. This is the default.</source>
          <target state="translated">곱하기 명령어를 지원하는 하드웨어 용 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f67b905d0c7d601714b6d40130d650c8841556d5" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports rotate right instructions.</source>
          <target state="translated">올바른 회전 명령을 지원하는 하드웨어 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d8901265c038359c4cabcecef69c62a4ad403284" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports set flag immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions.</source>
          <target state="translated">플래그 즉시 설정 ( &lt;code&gt;l.sf*i&lt;/code&gt; ) 명령 을 지원하는 하드웨어 용 코드를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb0dc185d9cce6eac6a0da7c5fde4468c232eb00" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports shift immediate related instructions (i.e. &lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;, &lt;code&gt;1.rori&lt;/code&gt;). Note, to enable generation of the &lt;code&gt;l.rori&lt;/code&gt; instruction the</source>
          <target state="translated">시프트 관련 명령을 즉시 지원하는 하드웨어 용 코드를 생성하십시오 (예 : &lt;code&gt;l.srai&lt;/code&gt; , &lt;code&gt;l.srli&lt;/code&gt; , &lt;code&gt;l.slli&lt;/code&gt; , &lt;code&gt;1.rori&lt;/code&gt; ). &lt;code&gt;l.rori&lt;/code&gt; 명령어를 생성 하려면</target>
        </trans-unit>
        <trans-unit id="56c0dd74c2b5f08d1195605802098a996d48ddaa" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports sign-extension instructions.</source>
          <target state="translated">부호 확장 명령어를 지원하는 하드웨어 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c6c9d0431f616f47453feb5bcfe61cef592a68b7" translate="yes" xml:space="preserve">
          <source>Generate code for hardware which supports the conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instruction.</source>
          <target state="translated">조건부 이동 ( &lt;code&gt;l.cmov&lt;/code&gt; ) 명령어 를 지원하는 하드웨어 용 코드를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf79d7ac3430cd100137adc751a91365b039edd3" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the maximum throughput algorithm.</source>
          <target state="translated">최대 처리량 알고리즘을 사용하여 부동 소수점 값의 인라인 분할 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3cedd11fcbf120218332b498654e7e4160f8c76d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of floating-point values using the minimum latency algorithm.</source>
          <target state="translated">최소 대기 시간 알고리즘을 사용하여 부동 소수점 값의 인라인 분할 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc7790f16d0c4d4d91471e6f5d653df0c747e44" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the maximum throughput algorithm.</source>
          <target state="translated">최대 처리량 알고리즘을 사용하여 정수 값의 인라인 분할 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="faf94b4d20f983cdf533f47ec33942d0ce63586d" translate="yes" xml:space="preserve">
          <source>Generate code for inline divides of integer values using the minimum latency algorithm.</source>
          <target state="translated">최소 대기 시간 알고리즘을 사용하여 정수 값의 인라인 분할 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5418fa0a1b1b281d2485d7060d2309afdebd6ff4" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the maximum throughput algorithm.</source>
          <target state="translated">최대 처리량 알고리즘을 사용하여 인라인 제곱근에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="83ef176a0741f8d1f5fe6e111f7583e6807956ad" translate="yes" xml:space="preserve">
          <source>Generate code for inline square roots using the minimum latency algorithm.</source>
          <target state="translated">최소 대기 시간 알고리즘을 사용하여 인라인 제곱근에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="00979759a61ef121145bed1163bfbd0399a7b98b" translate="yes" xml:space="preserve">
          <source>Generate code for long address mode. This is only supported for 64-bit and x32 environments. It is the default address mode for 64-bit environments.</source>
          <target state="translated">긴 주소 모드에 대한 코드를 생성하십시오. 64 비트 및 x32 환경에서만 지원됩니다. 64 비트 환경의 기본 주소 모드입니다.</target>
        </trans-unit>
        <trans-unit id="8adaf3135394010293585c029db12629ab7fdcf7" translate="yes" xml:space="preserve">
          <source>Generate code for short address mode. This is only supported for 32-bit and x32 environments. It is the default address mode for 32-bit and x32 environments.</source>
          <target state="translated">짧은 주소 모드를위한 코드를 생성하십시오. 이것은 32 비트 및 x32 환경에서만 지원됩니다. 32 비트 및 x32 환경의 기본 주소 모드입니다.</target>
        </trans-unit>
        <trans-unit id="694f6014654115d073cccf62f6b995dc2510f9c1" translate="yes" xml:space="preserve">
          <source>Generate code for the 210 processor.</source>
          <target state="translated">210 프로세서에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="85e35fc91e0af86a193c565f8d6f2a96d089e373" translate="yes" xml:space="preserve">
          <source>Generate code for the C-SKY compiler runtime instead of libgcc. This option defaults to off.</source>
          <target state="translated">libgcc 대신 C-SKY 컴파일러 런타임에 대한 코드를 생성하십시오. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27e854c2e0908c3f4c936f01364c648aa32b367c" translate="yes" xml:space="preserve">
          <source>Generate code for the H8/300H.</source>
          <target state="translated">H8 / 300H에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="bb83090e60c2fc757a89c80487c241185ee5d95a" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S and H8/300H in the normal mode. This switch must be used either with</source>
          <target state="translated">일반 모드에서 H8S 및 H8 / 300H에 대한 코드를 생성하십시오. 이 스위치는</target>
        </trans-unit>
        <trans-unit id="d052e6239d8f301fe0a2b7da20c249087f96d45d" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S.</source>
          <target state="translated">H8S 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="6d5ff3e2bd91c0a262161bf6efa2cdef6971233e" translate="yes" xml:space="preserve">
          <source>Generate code for the H8S/2600. This switch must be used with</source>
          <target state="translated">H8S / 2600에 대한 코드를 생성하십시오. 이 스위치는</target>
        </trans-unit>
        <trans-unit id="d28ff0fda5a5612fbf86e8ebd7c80cabd4110b85" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R. This is the default.</source>
          <target state="translated">M32R에 대한 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="20e08fc2eddd3584a33dc2a59b26172bf1281828" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/2.</source>
          <target state="translated">M32R / 2 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1939be789de09c47e008a34d88743773021de724" translate="yes" xml:space="preserve">
          <source>Generate code for the M32R/X.</source>
          <target state="translated">M32R / X 용 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="df8817f533054f34d7acf449e4e33f38657d304e" translate="yes" xml:space="preserve">
          <source>Generate code for the SH1.</source>
          <target state="translated">SH1에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="050479be73754de25483a6e1712e26489d053e34" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2.</source>
          <target state="translated">SH2에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3723c95f415c4a4c6a69d66a7f758a27732147a1" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a without FPU, or for a SH2a-FPU in such a way that the floating-point unit is not used.</source>
          <target state="translated">FPU가없는 SH2a 또는 부동 소수점 단위가 사용되지 않는 방식으로 SH2a-FPU에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc412156cf20c916e946ffa4cbe84584eb6567a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in double-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 배정도 모드라고 가정하고 SH2a-FPU에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="34abdbdae2fa95db6713e96853be2eca7e9c05eb" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 단 정밀도 모드라고 가정하고 SH2a-FPU에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1f2673d8ddd54030d4d4878de69f24422a5fdba0" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2a-FPU, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">배정 밀도 부동 소수점 연산이 사용되지 않도록 SH2a-FPU에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="483cb3ca44e923a4b1df433858f80751ca9f93aa" translate="yes" xml:space="preserve">
          <source>Generate code for the SH2e.</source>
          <target state="translated">SH2e에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1a936c359ffaab90c574043388b2920044ce94c5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3.</source>
          <target state="translated">SH3에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="52624bfb24aef64a24903a711fc58d43129edfce" translate="yes" xml:space="preserve">
          <source>Generate code for the SH3e.</source>
          <target state="translated">SH3e에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3974fd9acf25ff513cb6f41c5bd4a7bda9784a55" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 단 정밀도 모드라고 가정하고 SH4에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="75d92b5b6d76cda99c6a173e1dd53216d0ca8f31" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.</source>
          <target state="translated">단 정밀도 산술 만 지원하는 부동 소수점 단위로 SH4에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="162b02716f568279c8d0d5122c58fd1e1d0d9f75" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4 without a floating-point unit.</source>
          <target state="translated">부동 소수점 단위없이 SH4에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="63daf68bdeb08d26dfc7feca667cc330215f1c9b" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4.</source>
          <target state="translated">SH4에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="e752d163eaf5a23bc2b7e20cedab4af27f30919d" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.</source>
          <target state="translated">부동 소수점 단위가 기본적으로 단 정밀도 모드라고 가정하고 SH4a에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9bfcba29114940deb31d10a6d0e6239fe06706a5" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a, in such a way that no double-precision floating-point operations are used.</source>
          <target state="translated">배정 밀도 부동 소수점 연산이 사용되지 않도록 SH4a에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c9b792a4628ba5fbcf5191ba54ebda633615fe85" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4a.</source>
          <target state="translated">SH4a에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="e7ae153f4f4ad9faa39e7795dea14788da791715" translate="yes" xml:space="preserve">
          <source>Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.</source>
          <target state="translated">부동 소수점 단위가 사용되지 않도록 SH4al-dsp 또는 SH4a에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b868662932b00739d50db318aa2ddd01fc4bd249" translate="yes" xml:space="preserve">
          <source>Generate code for the given ABI.</source>
          <target state="translated">지정된 ABI에 대한 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="54f462554c550dbd112a2f944735d38c4f45d0bc" translate="yes" xml:space="preserve">
          <source>Generate code for the kernel code model. The kernel runs in the negative 2 GB of the address space. This model has to be used for Linux kernel code.</source>
          <target state="translated">커널 코드 모델의 코드를 생성하십시오. 커널은 2GB의 주소 공간에서 실행됩니다. 이 모델은 Linux 커널 코드에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f7119380ad6e8c2c7924710a3b532b63b7c448f" translate="yes" xml:space="preserve">
          <source>Generate code for the large code model. This makes no assumptions about addresses and sizes of sections. Programs can be statically linked only.</source>
          <target state="translated">큰 코드 모델을위한 코드를 생성하십시오. 이것은 섹션의 주소와 크기에 대한 가정을하지 않습니다. 프로그램은 정적으로 만 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3f449db1f29f06f736e88f3d496de39caace854" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. There is no limitation on call distance, pc-relative addresses, or absolute addresses.</source>
          <target state="translated">큰 모델의 코드를 생성하십시오. 통화 거리, PC 상대 주소 또는 절대 주소에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e0fcd5ba89af087e24036d07076369bc21de870" translate="yes" xml:space="preserve">
          <source>Generate code for the large model. This model makes no assumptions about addresses and sizes of sections.</source>
          <target state="translated">큰 모델의 코드를 생성하십시오. 이 모델은 섹션의 주소와 크기에 대한 가정을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0971940cc08a4932dadb19e61d4f634d86124a27" translate="yes" xml:space="preserve">
          <source>Generate code for the medium model: the program is linked in the lower 2 GB of the address space. Small symbols are also placed there. Symbols with sizes larger than</source>
          <target state="translated">중형 모델에 대한 코드 생성 : 프로그램이 주소 공간의 하위 2GB에 연결되어 있습니다. 작은 기호도 배치됩니다. 보다 큰 크기의 기호</target>
        </trans-unit>
        <trans-unit id="59ca259d5568c2d002dd2ccbe8f095a11b92f1df" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.</source>
          <target state="translated">보통 코드 모델을위한 코드를 생성하십시오. 프로그램 및 정적으로 정의 된 기호는 단일 2GiB 주소 범위 내에 있어야합니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504796a714036a0c76db86fa41cc45a9fb08427c" translate="yes" xml:space="preserve">
          <source>Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">중저 코드 모델에 대한 코드를 생성하십시오. 프로그램과 정적으로 정의 된 기호는 단일 2GiB 주소 범위 내에 있어야하며 절대 주소 -2GiB와 + 2GiB 사이에 있어야합니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다. 이것이 기본 코드 모델입니다.</target>
        </trans-unit>
        <trans-unit id="071c751072fdeed9625e903fca26e27c829fa3e5" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model. The program and its statically defined symbols must be within 4GB of each other. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">작은 코드 모델을위한 코드를 생성하십시오. 프로그램과 정적으로 정의 된 기호는 서로 4GB 이내 여야합니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다. 이것이 기본 코드 모델입니다.</target>
        </trans-unit>
        <trans-unit id="051a1860ec3526f5a9b8c1256cff7e9959d2ec61" translate="yes" xml:space="preserve">
          <source>Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.</source>
          <target state="translated">작은 코드 모델에 대한 코드를 생성하십시오. 프로그램 및 해당 심볼은 주소 공간의 하위 2GB에 연결되어야합니다. 포인터는 64 비트입니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다. 이것이 기본 코드 모델입니다.</target>
        </trans-unit>
        <trans-unit id="fccb732c10311c882aff8903c1dae6926a19b9e0" translate="yes" xml:space="preserve">
          <source>Generate code for the small model. The distance for direct calls is limited to 500M in either direction. PC-relative addresses are 32 bits. Absolute addresses support the full address range.</source>
          <target state="translated">작은 모델의 코드를 생성하십시오. 직통 전화 거리는 양방향으로 500M으로 제한됩니다. PC 기준 주소는 32 비트입니다. 절대 주소는 전체 주소 범위를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="245e4a42ebe1fc23a573492e82ac616ceb7b3a60" translate="yes" xml:space="preserve">
          <source>Generate code for the specified ABI. Permissible values are: &amp;lsquo;</source>
          <target state="translated">지정된 ABI에 대한 코드를 생성하십시오. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="62cd08507f5129c0313b216b3b312e1f38339400" translate="yes" xml:space="preserve">
          <source>Generate code for the specified architecture. The choices for &lt;var&gt;architecture-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">지정된 아키텍처에 대한 코드를 생성하십시오. &lt;var&gt;architecture-type&lt;/var&gt; 대한 선택 은 '</target>
        </trans-unit>
        <trans-unit id="fa0e2168d621855d66b05e248a41636b81294293" translate="yes" xml:space="preserve">
          <source>Generate code for the specified calling convention. Permissible values are &amp;lsquo;</source>
          <target state="translated">지정된 호출 규칙에 대한 코드를 생성하십시오. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="d43b1f64836a5b0a5d775d2376c530695500c9a6" translate="yes" xml:space="preserve">
          <source>Generate code for the specified data model. Permissible values are &amp;lsquo;</source>
          <target state="translated">지정된 데이터 모델에 대한 코드를 생성하십시오. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="e12f5237878118905a68ef1df9fd8353d31db89f" translate="yes" xml:space="preserve">
          <source>Generate code for the supervisor mode, where there are no restrictions on the access to general registers. This is the default.</source>
          <target state="translated">일반 레지스터 액세스에 대한 제한이없는 수퍼바이저 모드에 대한 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e6c40e69179c553d840354dee8e09afd6afb670e" translate="yes" xml:space="preserve">
          <source>Generate code for the tiny code model. The program and its statically defined symbols must be within 1MB of each other. Programs can be statically or dynamically linked.</source>
          <target state="translated">작은 코드 모델을위한 코드를 생성하십시오. 프로그램과 정적으로 정의 된 기호는 서로 1MB 이내에 있어야합니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e11e5ef71d66be04277bc1f01b5f5278d9a40a3" translate="yes" xml:space="preserve">
          <source>Generate code for the user mode, where the access to some general registers is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this mode; on the GR6, only registers r29 to r31 are affected.</source>
          <target state="translated">일부 일반 레지스터에 대한 액세스가 금지 된 사용자 모드에 대한 코드를 생성하십시오. GR5에서이 모드에서는 레지스터 r24 ~ r31에 액세스 할 수 없습니다. GR6에서는 레지스터 r29 ~ r31 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="bd8c4bf394db1eaf7b115e9a97579b1aa69d5063" translate="yes" xml:space="preserve">
          <source>Generate code for use in OpenMP offloading: enables</source>
          <target state="translated">OpenMP 오프 로딩에 사용할 코드 생성 : 활성화</target>
        </trans-unit>
        <trans-unit id="16c4c1a05d2b765d07aab8ca18577dc3fd7c3686" translate="yes" xml:space="preserve">
          <source>Generate code in big-endian mode.</source>
          <target state="translated">빅 엔디안 모드에서 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="617c48669c81ce32d047fdd88ab6cc36cefe714c" translate="yes" xml:space="preserve">
          <source>Generate code in big/little endian mode, respectively.</source>
          <target state="translated">빅 / 리틀 엔디안 모드에서 각각 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f467368c82a003e89d9528f03fca80cb77bf1e51" translate="yes" xml:space="preserve">
          <source>Generate code in little-endian mode.</source>
          <target state="translated">리틀 엔디안 모드에서 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d2870658bf99f10270c562aaa0ce69afd3724aea" translate="yes" xml:space="preserve">
          <source>Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.</source>
          <target state="translated">큰 스위치 테이블에 적합한 코드를 생성하십시오. 이 옵션은 어셈블러 / 링커가 스위치 테이블 내 범위를 벗어난 분기에 대해 불평하는 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31742c20f6d08e41957b4759da6c2e20cfa33560" translate="yes" xml:space="preserve">
          <source>Generate code suitable for fast turnaround development, such as to allow GDB to dynamically load</source>
          <target state="translated">GDB가 동적으로로드 할 수 있도록하는 등 빠른 처리 개발에 적합한 코드 생성</target>
        </trans-unit>
        <trans-unit id="f9c5e3444f60e6e1d269aebfea1614af0e0ffa27" translate="yes" xml:space="preserve">
          <source>Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS.</source>
          <target state="translated">운영 체제의 루틴을 추적하기 위해 TPF OS 특정 분기에 추가하거나 추가하지 않는 코드를 생성하십시오. 이 옵션은 TPF OS를 위해 컴파일 할 때도 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf132e8fd4ca1bac8a3c035b0896be35d4f95248" translate="yes" xml:space="preserve">
          <source>Generate code that allows (does not allow) a static executable to be relocated to a different address at run time. A simple embedded PowerPC system loader should relocate the entire contents of &lt;code&gt;.got2&lt;/code&gt; and 4-byte locations listed in the &lt;code&gt;.fixup&lt;/code&gt; section, a table of 32-bit addresses generated by this option. For this to work, all objects linked together must be compiled with</source>
          <target state="translated">정적 실행 파일을 런타임에 다른 주소로 재배치 할 수있는 코드를 생성하십시오. 간단한 내장 PowerPC 시스템 로더는 이 옵션으로 생성 된 32 비트 주소 &lt;code&gt;.fixup&lt;/code&gt; 섹션에 나열된 &lt;code&gt;.got2&lt;/code&gt; 및 4 바이트 위치 의 전체 내용을 재배치해야합니다 . 이것이 작동하려면 함께 연결된 모든 객체를</target>
        </trans-unit>
        <trans-unit id="86d1c7c8ebb812df3d75ca440f1dd938fb6de6fb" translate="yes" xml:space="preserve">
          <source>Generate code that allows &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;ld.so&lt;/code&gt; to build executables and shared libraries with non-executable &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld&lt;/code&gt; 및 &lt;code&gt;ld.so&lt;/code&gt; 가 실행 파일이 아닌 &lt;code&gt;.plt&lt;/code&gt; 및 &lt;code&gt;.got&lt;/code&gt; 섹션 으로 실행 파일 및 공유 라이브러리를 빌드 할 수 있도록하는 코드를 생성하십시오 . PowerPC 32 비트 SYSV ABI 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="2493e6ad3aa4a2943864620cf6ffd109b6ddb3da" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute in place in an environment without virtual memory management by eliminating relocations against the text section.</source>
          <target state="translated">데이터 세그먼트가 텍스트 세그먼트와 다른 메모리 영역에 위치 할 수 있도록하는 코드를 생성하십시오. 이를 통해 텍스트 섹션에 대한 재배치를 제거함으로써 가상 메모리 관리없이 환경에서 적절한 위치에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6f87eee15c30331198259c5e0fa884666e3b45" translate="yes" xml:space="preserve">
          <source>Generate code that allows the data segment to be located in a different area of memory from the text segment. This allows for execute-in-place in an environment without virtual memory management. This option implies</source>
          <target state="translated">데이터 세그먼트가 텍스트 세그먼트와 다른 메모리 영역에 위치 할 수 있도록하는 코드를 생성하십시오. 이를 통해 가상 메모리 관리가없는 환경에서 바로 실행할 수 있습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="338b24d92797baf1f472014c3eb7e81cad28ab15" translate="yes" xml:space="preserve">
          <source>Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows &lt;em&gt;trapping&lt;/em&gt; instructions to throw exceptions, i.e. memory references or floating-point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">트 랩핑 명령어가 예외를 발생시킬 수있는 코드를 생성하십시오. 여기에는 어디에도 존재하지 않는 플랫폼 별 런타임 지원이 필요합니다. 또한 &lt;em&gt;트래핑&lt;/em&gt; 명령어 만 예외 (예 : 메모리 참조 또는 부동 소수점 명령어)를 발생시킬 수 있습니다. &lt;code&gt;SIGALRM&lt;/code&gt; 과 같은 임의의 신호 처리기에서 예외를 발생시킬 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fbd1ec35fb62e61a3c0c9ad20b949b97f631374a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required.</source>
          <target state="translated">더 긴 통화 순서가 필요하도록 모든 통화가 멀리 있다고 가정 (추정하지 않음)하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f709a2890cb93e8763f592a97bd90453baa9bc3" translate="yes" xml:space="preserve">
          <source>Generate code that assumes calls never cross space boundaries. This allows GCC to emit code that performs faster indirect calls.</source>
          <target state="translated">호출이 공간 경계를 넘지 않는다고 가정하는 코드를 생성하십시오. 이를 통해 GCC는 더 빠른 간접 호출을 수행하는 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b9beb60bdc4afff878eec93b064cf17ba08cf6" translate="yes" xml:space="preserve">
          <source>Generate code that assumes that the data segment follows the text segment. This is the default.</source>
          <target state="translated">데이터 세그먼트가 텍스트 세그먼트를 따르는 것으로 가정하는 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="336489e1da74ce723400b7df9bbae17f47d7009a" translate="yes" xml:space="preserve">
          <source>Generate code that assumes the target has no space registers. This allows GCC to generate faster indirect calls and use unscaled index address modes.</source>
          <target state="translated">대상에 공간 레지스터가 없다고 가정하는 코드를 생성하십시오. 이를 통해 GCC는 더 빠른 간접 호출을 생성하고 스케일되지 않은 인덱스 주소 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918ffaae0c58edeaaf21af8db9990d1e80c480af" translate="yes" xml:space="preserve">
          <source>Generate code that does not use (uses) the floating-point register set. Software floating-point emulation is provided if you use the</source>
          <target state="translated">부동 소수점 레지스터 세트를 사용하지 않는 코드를 생성합니다. 소프트웨어 부동 소수점 에뮬레이션은</target>
        </trans-unit>
        <trans-unit id="c1d77eef17962d23aa2b64213060026efae223d1" translate="yes" xml:space="preserve">
          <source>Generate code that does not use &lt;code&gt;.local&lt;/code&gt; memory directly for stack storage. Instead, a per-warp stack pointer is maintained explicitly. This enables variable-length stack allocation (with variable-length arrays or &lt;code&gt;alloca&lt;/code&gt;), and when global memory is used for underlying storage, makes it possible to access automatic variables from other threads, or with atomic instructions. This code generation variant is used for OpenMP offloading, but the option is exposed on its own for the purpose of testing the compiler; to generate code suitable for linking into programs using OpenMP offloading, use option</source>
          <target state="translated">스택 스토리지에 &lt;code&gt;.local&lt;/code&gt; 메모리를 직접 사용하지 않는 코드를 생성하십시오 . 대신 워프 별 스택 포인터가 명시 적으로 유지됩니다. 이를 통해 가변 길이 스택 할당 (가변 길이 배열 또는 &lt;code&gt;alloca&lt;/code&gt; 사용 )이 가능하며 기본 메모리에 글로벌 메모리가 사용되는 경우 다른 스레드 또는 원자 명령어로 자동 변수에 액세스 할 수 있습니다. 이 코드 생성 변형은 OpenMP 오프 로딩에 사용되지만이 옵션은 컴파일러 테스트를 위해 자체적으로 노출됩니다. OpenMP 오프 로딩을 사용하여 프로그램에 연결하기에 적합한 코드를 생성하려면 옵션 사용</target>
        </trans-unit>
        <trans-unit id="44ab5ca5f8364ad55909ace91a8c6e880674fbc6" translate="yes" xml:space="preserve">
          <source>Generate code that does not use a global pointer register. The result is not position independent code, and violates the IA-64 ABI.</source>
          <target state="translated">전역 포인터 레지스터를 사용하지 않는 코드를 생성하십시오. 결과는 위치 독립적 인 코드가 아니며 IA-64 ABI를 위반합니다.</target>
        </trans-unit>
        <trans-unit id="60de4e859809d0c4dc8e855c46af0110311ff144" translate="yes" xml:space="preserve">
          <source>Generate code that doesn&amp;rsquo;t assume ID-based shared libraries are being used. This is the default.</source>
          <target state="translated">ID 기반 공유 라이브러리가 사용되지 않는다고 가정하는 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="354fbc6c3e514e9f7e68643c90303161a363d508" translate="yes" xml:space="preserve">
          <source>Generate code that is self-relocatable. This implies</source>
          <target state="translated">자체 연관성이있는 코드를 생성하십시오. 이것은 암시</target>
        </trans-unit>
        <trans-unit id="13b5daaeeae847dab7bba6f104ed44e1ab6ee054" translate="yes" xml:space="preserve">
          <source>Generate code that keeps (does not keeps) some integer operations adjacent so that the instructions can be fused together on power8 and later processors.</source>
          <target state="translated">power8 이상의 프로세서에서 명령어를 함께 융합 할 수 있도록 일부 정수 연산을 인접하게 유지하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ebb2d4ebaa412c3ca6bb8549fd5605ffef2b8a3c" translate="yes" xml:space="preserve">
          <source>Generate code that passes function parameters and return values that (in the called function) are seen as registers &lt;code&gt;$0&lt;/code&gt; and up, as opposed to the GNU ABI which uses global registers &lt;code&gt;$231&lt;/code&gt; and up.</source>
          <target state="translated">글로벌 레지스터 &lt;code&gt;$231&lt;/code&gt; 을 사용하는 GNU ABI와 달리 함수 매개 변수 및 호출 된 함수에서) 값을 레지스터 &lt;code&gt;$0&lt;/code&gt; 으로 전달하는 코드를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="572a137e555b3b3423721fc0e3626b6e8b160c46" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;arch&lt;/var&gt;, which can be the name of a generic MIPS ISA, or the name of a particular processor. The ISA names are: &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; 에서 실행되는 코드를 생성하십시오 . 일반 MIPS ISA 이름 또는 특정 프로세서 이름 일 수 있습니다. ISA 이름은 '</target>
        </trans-unit>
        <trans-unit id="e20973741c69f13efd8aaaa56fd8109762470570" translate="yes" xml:space="preserve">
          <source>Generate code that runs on &lt;var&gt;cpu-type&lt;/var&gt;, which is the name of a system representing a certain processor type. Possible values for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; 에서 실행되는 코드를 생성하십시오 . 이는 특정 프로세서 유형을 나타내는 시스템의 이름입니다. &lt;var&gt;cpu-type&lt;/var&gt; 가능한 값 은 '</target>
        </trans-unit>
        <trans-unit id="2afe5cce361ce178d21f1f9e300c77965e025f71" translate="yes" xml:space="preserve">
          <source>Generate code that supports calling between the ARM and Thumb instruction sets. Without this option, on pre-v5 architectures, the two instruction sets cannot be reliably used inside one program. The default is</source>
          <target state="translated">ARM 명령어와 Thumb 명령어 세트 간의 호출을 지원하는 코드를 생성하십시오. 이 옵션이 없으면 v5 이전 아키텍처에서는 두 프로그램 세트를 하나의 프로그램에서 안정적으로 사용할 수 없습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="1e1b0c53abd34ffe18acaa9b5781550d29a84379" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method, but assumes that this library or executable won&amp;rsquo;t link against any other ID shared libraries. That allows the compiler to use faster code for jumps and calls.</source>
          <target state="translated">라이브러리 ID 방법을 통해 공유 라이브러리를 지원하는 코드를 생성하지만이 라이브러리 또는 실행 파일은 다른 ID 공유 라이브러리와 링크되지 않는다고 가정합니다. 이를 통해 컴파일러는 점프 및 호출에 더 빠른 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19a4d4ef1ca305d055c2c43578e68d17e9af2a97" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute in place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">라이브러리 ID 방법을 통해 공유 라이브러리를 지원하는 코드를 생성하십시오. 이를 통해 가상 메모리 관리가없는 환경에서 적절한 위치에서 공유 라이브러리를 실행할 수 있습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="d499e8859196b03e31f4b5d6d30e4cb073e79ae2" translate="yes" xml:space="preserve">
          <source>Generate code that supports shared libraries via the library ID method. This allows for execute-in-place and shared libraries in an environment without virtual memory management. This option implies</source>
          <target state="translated">라이브러리 ID 방법을 통해 공유 라이브러리를 지원하는 코드를 생성하십시오. 이를 통해 가상 메모리 관리가없는 환경에서 바로 실행 및 공유 라이브러리를 사용할 수 있습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="3080019b4a448b8d2f42e11601716bd17c75e272" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions.</source>
          <target state="translated">인덱싱 된로드 또는 저장 명령어의 사용을 피하려고 시도하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7d0f8dbe32444b165a61440094a0d21d656220" translate="yes" xml:space="preserve">
          <source>Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targeting Power6 and disabled otherwise.</source>
          <target state="translated">인덱싱 된로드 또는 저장 명령어의 사용을 피하려고 시도하는 코드를 생성하십시오. 이러한 명령어는 16M 경계를 넘는 대형 어레이를 단계별로 실행할 때와 같은 특정 상황에서 Power6 프로세서의 성능 저하를 초래할 수 있습니다. 이 옵션은 Power6을 대상으로 할 때 기본적으로 활성화되고 그렇지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="bf98fe716d964a094592ad1d59afe4951cb9d36f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions, and also enable the use of built-in functions that allow more direct access to the AltiVec instruction set. You may also need to set</source>
          <target state="translated">AltiVec 명령어를 사용 (사용하지 않음)하는 코드를 생성하고 AltiVec 명령어 세트에보다 직접 액세스 할 수있는 내장 함수를 사용할 수 있습니다. 설정해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="2f5b28537613ef22817b9ba8bf63c4e1f2104514" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable AltiVec instructions unless</source>
          <target state="translated">AltiVec 명령어를 사용하는 (사용하지 않는) 코드를 생성하십시오. 32 비트 코드에서는 AltiVec 명령어를 활성화 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="8c04238a31ea4511a013025b49118e3c3e42e84e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) ISEL instruction.</source>
          <target state="translated">ISEL 명령어를 사용하는 (사용하지 않는) 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="92155be900bc9933add2300c7a5d23503087ce0e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) VAX F and G floating-point arithmetic instead of IEEE single and double precision.</source>
          <target state="translated">IEEE 단정도 및 배정도 대신 VAX F 및 G 부동 소수점 산술을 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b95c7c98a27a75ea4aed9a1312a1f6d81d84fc5d" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture.</source>
          <target state="translated">확장 된 PowerPC V2.05 아키텍처를 지원하는 POWER6X 프로세서 및 기타 프로세서에서 구현 된 범용 레지스터 명령어로 FP 이동을 사용하거나 사용하지 않는 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a2c4f9d3a1eb191b5662b1d07619055360c468c4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture.</source>
          <target state="translated">POWER5 + 프로세서 및 PowerPC V2.03 아키텍처를 지원하는 다른 프로세서에서 구현 된 정수 명령어로 FP 반올림을 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="46d6eec21f4fa802b85560d860276b9199fed94b" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the atomic quad word memory instructions. The</source>
          <target state="translated">원자 쿼드 워드 메모리 명령어를 사용하는 (사용하지 않는) 코드를 생성합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="262e0fd3e027fbfbead855b3f29a870f608f4f72" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture.</source>
          <target state="translated">POWER6 프로세서 및 PowerPC V2.05 아키텍처를 지원하는 다른 프로세서에서 구현 된 바이트 비교 명령을 사용 (사용하지 않음)하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="08b86aae00b13e22b96514a69b5b064be8919eb4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the decimal floating-point instructions implemented on some POWER processors.</source>
          <target state="translated">일부 POWER 프로세서에서 구현 된 10 진 부동 소수점 명령어를 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3131d9ab648d637f7f2b9519e03b551e9a374743" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.</source>
          <target state="translated">부동 소수점 곱셈을 사용하는 (사용하지 않는) 코드를 생성하고 명령어를 누적합니다. 이 명령어는 하드웨어 부동 소수점이 사용되는 경우 기본적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c04a8a825b0f94e2eb07f4e8f21cb84241b2efaf" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used. The machine-dependent</source>
          <target state="translated">부동 소수점 곱셈을 사용하는 (사용하지 않는) 코드를 생성하고 명령어를 누적합니다. 이 명령어는 하드웨어 부동 소수점이 사용되는 경우 기본적으로 생성됩니다. 기계 의존</target>
        </trans-unit>
        <trans-unit id="61eadf2cc65c85da3c9ba20e0d77a3b18047c546" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the floating-point register set.</source>
          <target state="translated">부동 소수점 레지스터 세트를 사용하는 (사용하지 않는) 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="32b3b39a373f02faec1c8e47cea1029610f3648e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the generation of PAIRED simd instructions.</source>
          <target state="translated">PAIRED simd 명령어 생성을 사용하는 (사용하지 않는) 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="a16384b2cc48decd8d149f4edeab3b4637c6c2dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors.</source>
          <target state="translated">IBM 405, 440, 464 및 476 프로세서에서 하프 워드 곱셈 및 곱셈 명령어를 사용하는 (사용하지 않는) 코드를 생성하십시오. 이러한 명령어는 해당 프로세서를 대상으로 할 때 기본적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae0cd2b0200a8b41b70cb257df1cc0c71cf4ea9" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions.</source>
          <target state="translated">여러 단어로드 명령어와 여러 단어 명령어 저장을 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="2c52b95b537c53566c2534b67e93882f9aca68b1" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. These instructions are generated by default on POWER systems, and not generated on PowerPC systems. Do not use</source>
          <target state="translated">여러 단어로드 명령어와 여러 단어 명령어 저장을 사용하는 코드를 생성하십시오. 이 명령어는 기본적으로 POWER 시스템에서 생성되며 PowerPC 시스템에서는 생성되지 않습니다. 사용하지 마세요</target>
        </trans-unit>
        <trans-unit id="fd774e2be13b8cb13d5052ff903f2b6dbbaa0be4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location.</source>
          <target state="translated">기본 레지스터를 계산 된 메모리 위치의 주소로 업데이트하는로드 또는 저장 명령어를 사용하거나 사용하지 않는 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a22e11f108e540ae0805ccbff5751fce923b96a4" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. These instructions are generated by default. If you use</source>
          <target state="translated">기본 레지스터를 계산 된 메모리 위치의 주소로 업데이트하는로드 또는 저장 명령어를 사용하거나 사용하지 않는 코드를 생성합니다. 이러한 명령어는 기본적으로 생성됩니다. 당신이 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="0770f3e5c30f3b0aaaeba94f431ff5516808b06c" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves.</source>
          <target state="translated">로드 문자열 명령어와 저장 문자열 단어 명령어를 사용 (사용하지 않음)하여 여러 레지스터를 저장하고 작은 블록 이동을 수행하는 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="386b3e18aecf301e2272c3303cef5b3408b3d72f" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture.</source>
          <target state="translated">POWER4 프로세서 및 PowerPC V2.01 아키텍처를 지원하는 기타 프로세서에서 구현 된 조건 레지스터에서 이동 필드 명령을 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="87adae88954ee8917f3f31be376d9936d82cd4bc" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the non-atomic quad word memory instructions. The</source>
          <target state="translated">비 원자 쿼드 워드 메모리 명령어를 사용하는 (사용하지 않는) 코드를 생성합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="fc8745a466eb796ef7f9c5a441c7003ed311977e" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root.</source>
          <target state="translated">부동 소수점 제곱근을 포함하여 범용 그룹에서 선택적 PowerPC 아키텍처 명령어를 사용하거나 사용하지 않는 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="27810752cbb1f58324d02017084ca261477ff314" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">부동 소수점 선택을 포함하여 그래픽 그룹에서 선택적 PowerPC 아키텍처 명령어를 사용하거나 사용하지 않는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="98f0227605ad4df08722181505cb7a14d55e9799" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount and double-precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture.</source>
          <target state="translated">POWER5 프로세서 및 PowerPC V2.02 아키텍처를 지원하는 기타 프로세서에서 구현 된 popcount 및 배정도 FP 상호 추정 명령을 사용하는 (사용하지 않는) 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c07537f1993a55be984ad5f397058498e67120dd" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture.</source>
          <target state="translated">POWER7 프로세서 및 PowerPC V2.06 아키텍처를 지원하는 기타 프로세서에서 구현 된 popcount 명령을 사용하는 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4b15de7f2b7f03ed6e1790dbf982c588fb5b3528" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the string-search &amp;lsquo;</source>
          <target state="translated">문자열 검색을 사용하는 (사용하지 않는) 코드 생성</target>
        </trans-unit>
        <trans-unit id="ab7a2922566d7313797a3ac188f3c0be7688df71" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) the vector and scalar instructions that were added in version 2.07 of the PowerPC ISA. Also enable the use of built-in functions that allow more direct access to the vector instructions.</source>
          <target state="translated">PowerPC ISA 버전 2.07에 추가 된 벡터 및 스칼라 명령어를 사용 (사용하지 않음)하는 코드를 생성하십시오. 벡터 명령어에보다 직접 액세스 할 수있는 내장 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7dd4f67d21a30765965ab7e7de435cac230ac64" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set.</source>
          <target state="translated">벡터 / 스칼라 (VSX) 명령어를 사용 (사용하지 않음)하는 코드를 생성하고 VSX 명령어 세트에보다 직접 액세스 할 수있는 내장 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ca89c3814bc0cbed05cab7398d230442544564" translate="yes" xml:space="preserve">
          <source>Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or AltiVec instructions unless</source>
          <target state="translated">벡터 / 스칼라 (VSX) 명령어를 사용 (사용하지 않음)하는 코드를 생성하고 VSX 명령어 세트에보다 직접 액세스 할 수있는 내장 함수를 사용할 수 있습니다. 32 비트 코드에서는 VSX 또는 AltiVec 명령어를 활성화 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="67b86bb995294b5ded4deb3fb6384281013e8cde" translate="yes" xml:space="preserve">
          <source>Generate code that uses a BSS &lt;code&gt;.plt&lt;/code&gt; section that &lt;code&gt;ld.so&lt;/code&gt; fills in, and requires &lt;code&gt;.plt&lt;/code&gt; and &lt;code&gt;.got&lt;/code&gt; sections that are both writable and executable. This is a PowerPC 32-bit SYSV ABI option.</source>
          <target state="translated">&lt;code&gt;ld.so&lt;/code&gt; 가 채우고 쓰기 가능하고 실행 가능한 &lt;code&gt;.plt&lt;/code&gt; 및 &lt;code&gt;.got&lt;/code&gt; 섹션이 필요한 BSS &lt;code&gt;.plt&lt;/code&gt; 섹션 을 사용하는 코드를 생성하십시오 . PowerPC 32 비트 SYSV ABI 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="6beeb427ddc734bea4c58516baa43a91d09099d2" translate="yes" xml:space="preserve">
          <source>Generate code that uses a single constant global pointer value. This is useful when compiling kernel code.</source>
          <target state="translated">단일 상수 전역 포인터 값을 사용하는 코드를 생성하십시오. 커널 코드를 컴파일 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6f2e6ea4728870634a5f76e2497b052f725aed62" translate="yes" xml:space="preserve">
          <source>Generate code that uses long call sequences. This ensures that a call is always able to reach linker generated stubs. The default is to generate long calls only when the distance from the call site to the beginning of the function or translation unit, as the case may be, exceeds a predefined limit set by the branch type being used. The limits for normal calls are 7,600,000 and 240,000 bytes, respectively for the PA 2.0 and PA 1.X architectures. Sibcalls are always limited at 240,000 bytes.</source>
          <target state="translated">긴 통화 시퀀스를 사용하는 코드를 생성하십시오. 이렇게하면 통화가 항상 링커에서 생성 된 스텁에 도달 할 수 있습니다. 기본값은 호출 사이트에서 기능 또는 변환 단위의 시작까지의 거리가 사용중인 분기 유형에 의해 설정된 사전 정의 된 한계를 초과하는 경우에만 긴 호출을 생성하는 것입니다. PA 2.0 및 PA 1.X 아키텍처의 경우 일반 통화의 한도는 각각 7,600,000 및 240,000 바이트입니다. Sibcall은 항상 240,000 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="0ddfa4b3d16d23a89e5776522951b15e62426fdc" translate="yes" xml:space="preserve">
          <source>Generate code that uses only the general-purpose registers. This prevents the compiler from using floating-point, vector, mask and bound registers.</source>
          <target state="translated">범용 레지스터 만 사용하는 코드를 생성하십시오. 이는 컴파일러가 부동 소수점, 벡터, 마스크 및 바운드 레지스터를 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="baac973b3b5994adc6aef021db0133816bd28382" translate="yes" xml:space="preserve">
          <source>Generate code to access thread-local storage using the &amp;lsquo;</source>
          <target state="translated">'를 사용하여 스레드 로컬 스토리지에 액세스하기위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="c88cdcf77b77d16255b95669179f017ca5ceda39" translate="yes" xml:space="preserve">
          <source>Generate code to automatically split the stack before it overflows. The resulting program has a discontiguous stack which can only overflow if the program is unable to allocate any more memory. This is most useful when running threaded programs, as it is no longer necessary to calculate a good stack size to use for each thread. This is currently only implemented for the x86 targets running GNU/Linux.</source>
          <target state="translated">스택이 오버플로되기 전에 자동으로 분할하는 코드를 생성하십시오. 결과 프로그램에는 불연속 스택이있어 프로그램에서 더 이상 메모리를 할당 할 수없는 경우에만 오버플로 할 수 있습니다. 더 이상 각 스레드에 사용할 적절한 스택 크기를 계산할 필요가 없으므로 스레드 프로그램을 실행할 때 가장 유용합니다. 이것은 현재 GNU / Linux를 실행하는 x86 대상에 대해서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="915ccec10fdc8928f52708c97467282540464b8a" translate="yes" xml:space="preserve">
          <source>Generate code to avoid bugs in the multiply instructions for the MN10300 processors. This is the default.</source>
          <target state="translated">MN10300 프로세서에 대한 곱하기 명령어에서 버그를 피하기 위해 코드를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0df3e04d22344e23f6649b40a52c7d6f0c186350" translate="yes" xml:space="preserve">
          <source>Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If a larger stack is required, a signal is raised at run time. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.</source>
          <target state="translated">스택이 레지스터 값 또는 심볼 주소와 같은 특정 값 이상으로 커지지 않도록 코드를 생성하십시오. 더 큰 스택이 필요한 경우 런타임에 신호가 발생합니다. 대부분의 대상의 경우 스택이 경계를 초과하기 전에 신호가 발생하므로 특별한주의없이 신호를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b66c9f22b9ae2f51f7b68dcb90be43a732528ba" translate="yes" xml:space="preserve">
          <source>Generate code to prevent stack clash style attacks. When this option is enabled, the compiler will only allocate one page of stack space at a time and each page is accessed immediately after allocation. Thus, it prevents allocations from jumping over any stack guard page provided by the operating system.</source>
          <target state="translated">스택 충돌 스타일 공격을 방지하는 코드를 생성하십시오. 이 옵션이 활성화되면 컴파일러는 한 번에 한 페이지의 스택 공간 만 할당하며 각 페이지는 할당 직후에 액세스됩니다. 따라서 운영 체제에서 제공하는 스택 가드 페이지 위로 할당이 점프하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="dd0c489c581360afbf7f7a5091b3992e53e109af" translate="yes" xml:space="preserve">
          <source>Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but you only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.</source>
          <target state="translated">스택 경계를 넘어 가지 않는지 확인하는 코드를 생성하십시오. 다중 스레드가있는 환경에서 실행중인 경우이 플래그를 지정해야하지만 스택이 하나만 있으면 거의 모든 시스템에서 스택 오버 플로우가 자동으로 감지되므로 단일 스레드 환경에서만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f09658f66e71e4832575a43871e37604d20cbdbd" translate="yes" xml:space="preserve">
          <source>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.</source>
          <target state="translated">주어진 레지스터 범위를 고정 레지스터로 취급하는 코드를 생성하십시오. 고정 레지스터는 레지스터 할당자가 사용할 수없는 것입니다. 커널 코드를 컴파일 할 때 유용합니다. 레지스터 범위는 대시로 구분 된 두 개의 레지스터로 지정됩니다. 여러 레지스터 범위는 쉼표로 구분하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69365c978ad182890bcb4e65e053170c8830231a" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; instructions. This option defaults to on.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 및 &lt;code&gt;pop&lt;/code&gt; 명령어를 사용하여 코드를 생성하십시오 . 이 옵션의 기본값은 on입니다.</target>
        </trans-unit>
        <trans-unit id="7f296d4ed278effc8fa87bfb0e530628874d3432" translate="yes" xml:space="preserve">
          <source>Generate code using &lt;code&gt;stm&lt;/code&gt; and &lt;code&gt;ldm&lt;/code&gt; instructions. This option isn&amp;rsquo;t supported on CK801 but is enabled by default on other processors.</source>
          <target state="translated">&lt;code&gt;stm&lt;/code&gt; 및 &lt;code&gt;ldm&lt;/code&gt; 명령어를 사용하여 코드를 생성하십시오 . 이 옵션은 CK801에서 지원되지 않지만 다른 프로세서에서는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba4d33b91d9e6ab2d69e87dce44c7244b439ed9e" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33 processor.</source>
          <target state="translated">AM33 프로세서 고유의 기능을 사용하여 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f3f1a0016506b7432a6808d95156263172db1a" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM33/2.0 processor.</source>
          <target state="translated">AM33 / 2.0 프로세서 전용 기능을 사용하여 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4d51b4beaa1d3a18f186ce7d15002cb82d47e204" translate="yes" xml:space="preserve">
          <source>Generate code using features specific to the AM34 processor.</source>
          <target state="translated">AM34 프로세서 고유의 기능을 사용하여 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c282f618bb7db95f0feff29b3266b2478e4e252b" translate="yes" xml:space="preserve">
          <source>Generate code using global anchor symbol addresses.</source>
          <target state="translated">글로벌 앵커 심볼 주소를 사용하여 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="cb509e9252b480e0a1aeb49faf8b1ef18fa7edf6" translate="yes" xml:space="preserve">
          <source>Generate code using the FDPIC ABI.</source>
          <target state="translated">FDPIC ABI를 사용하여 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="404e8a65099de95616c40afb1bc863ffa2523650" translate="yes" xml:space="preserve">
          <source>Generate code using the high registers numbered 16-31. This option is not supported on CK801, CK802, or CK803, and is enabled by default for other processors.</source>
          <target state="translated">번호가 16-31 인 높은 레지스터를 사용하여 코드를 생성하십시오. 이 옵션은 CK801, CK802 또는 CK803에서 지원되지 않으며 다른 프로세서에 대해서는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb05ce3f6ef091d20d86e01a77fc7f4a59d0bcc" translate="yes" xml:space="preserve">
          <source>Generate code which uses only the general-purpose registers. This will prevent the compiler from using floating-point and Advanced SIMD registers but will not impose any restrictions on the assembler.</source>
          <target state="translated">범용 레지스터 만 사용하는 코드를 생성하십시오. 이렇게하면 컴파일러에서 부동 소수점 및 고급 SIMD 레지스터를 사용할 수 없지만 어셈블러에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9cce76ef82a38c3b96967249a0f61e0fb26b9334" translate="yes" xml:space="preserve">
          <source>Generate compiler predefines and select a startfile for the specified UNIX standard. The choices for &lt;var&gt;unix-std&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">컴파일러 사전 정의를 생성하고 지정된 UNIX 표준에 대한 시작 파일을 선택하십시오. &lt;var&gt;unix-std&lt;/var&gt; 대한 선택 은 '</target>
        </trans-unit>
        <trans-unit id="a678e34a31471d170303da9eda1b930e2324a992" translate="yes" xml:space="preserve">
          <source>Generate conditional move instructions.</source>
          <target state="translated">조건부 이동 명령을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d72e8c8e0f9b51ca898631ea4a5646d5c76664c2" translate="yes" xml:space="preserve">
          <source>Generate divide instructions. Default is off.</source>
          <target state="translated">나누기 명령어를 생성합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="16d77d1fe0a8bda494d3925636feea2c269c0e3f" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">컴팩트 한 구현을 위해 조정 된 배정도 FPX 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c229df63f7c476d6f9fecd75b4ac0f6491159589" translate="yes" xml:space="preserve">
          <source>Generate double-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">빠른 구현을 위해 조정 된 배정도 FPX 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="efd3351263c1d9caa26ca401350421bfc7b35243" translate="yes" xml:space="preserve">
          <source>Generate extended arithmetic instructions. Currently only &lt;code&gt;divaw&lt;/code&gt;, &lt;code&gt;adds&lt;/code&gt;, &lt;code&gt;subs&lt;/code&gt;, and &lt;code&gt;sat16&lt;/code&gt; are supported. This is always enabled for</source>
          <target state="translated">확장 된 산술 명령어를 생성합니다. 현재 &lt;code&gt;divaw&lt;/code&gt; , &lt;code&gt;adds&lt;/code&gt; , &lt;code&gt;subs&lt;/code&gt; 및 &lt;code&gt;sat16&lt;/code&gt; 만 지원됩니다. 이것은 항상 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="6856e99222352076039e94fbdf5c31806c05feaa" translate="yes" xml:space="preserve">
          <source>Generate extended debug information for inlined functions. Location view tracking markers are inserted at inlined entry points, so that address and view numbers can be computed and output in debug information. This can be enabled independently of location views, in which case the view numbers won&amp;rsquo;t be output, but it can only be enabled along with statement frontiers, and it is only enabled by default if location views are enabled.</source>
          <target state="translated">인라인 함수에 대한 확장 디버그 정보를 생성하십시오. 위치 뷰 추적 마커는 인라인 된 진입 점에 삽입되므로 주소 및 뷰 번호를 계산하여 디버그 정보로 출력 할 수 있습니다. 위치보기와 독립적으로 활성화 할 수 있으며,이 경우보기 번호가 출력되지 않지만 명령문 프론티어와 함께 만 활성화 될 수 있으며 위치보기가 활성화 된 경우에만 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0b2408362730cc5b4ed897b120cdb4b4cc4031" translate="yes" xml:space="preserve">
          <source>Generate extra code to write profile information suitable for the analysis program &lt;code&gt;prof&lt;/code&gt; (for</source>
          <target state="translated">분석 프로그램에 적합한 쓰기 프로필 정보에 추가 코드 생성 &lt;code&gt;prof&lt;/code&gt; (위한</target>
        </trans-unit>
        <trans-unit id="c6eeb91a33862dbf10594e59a0033583feb5fde5" translate="yes" xml:space="preserve">
          <source>Generate floating-point arithmetic for selected unit &lt;var&gt;unit&lt;/var&gt;. The choices for &lt;var&gt;unit&lt;/var&gt; are:</source>
          <target state="translated">선택한 단위 &lt;var&gt;unit&lt;/var&gt; 대한 부동 소수점 산술을 생성합니다 . &lt;var&gt;unit&lt;/var&gt; 선택 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79ec4a91ff56b1468e2e0960559756f702528e59" translate="yes" xml:space="preserve">
          <source>Generate floating-point comparison instructions that compare with respect to the &lt;code&gt;rE&lt;/code&gt; epsilon register.</source>
          <target state="translated">&lt;code&gt;rE&lt;/code&gt; epsilon 레지스터 와 비교하는 부동 소수점 비교 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="5184b7fbfd727379c1835aa4d91abffedcc6f989" translate="yes" xml:space="preserve">
          <source>Generate floating-point instructions. This is the default for 68020 and above, and for ColdFire devices that have an FPU. It defines the macro &lt;code&gt;__HAVE_68881__&lt;/code&gt; on M680x0 targets and &lt;code&gt;__mcffpu__&lt;/code&gt; on ColdFire targets.</source>
          <target state="translated">부동 소수점 명령어를 생성합니다. 이것은 68020 이상 및 FPU가있는 ColdFire 장치의 기본값입니다. 그것은 매크로 정의 &lt;code&gt;__HAVE_68881__&lt;/code&gt; M680x0 목표에와 &lt;code&gt;__mcffpu__&lt;/code&gt; 콜드 파이어 (ColdFire) 목표에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff3989b144109cfd18ff049af7f71f4c3c9f86e" translate="yes" xml:space="preserve">
          <source>Generate hardware atomic sequences using the &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; instructions only. This is only available on SH4A and is suitable for multi-core systems. Since the hardware instructions support only 32 bit atomic variables access to 8 or 16 bit variables is emulated with 32 bit accesses. Code compiled with this option is also compatible with other software atomic model interrupt/exception handling systems if executed on an SH4A system. Additional support from the interrupt/exception handling code of the system is not required for this model.</source>
          <target state="translated">&lt;code&gt;movli.l&lt;/code&gt; 및 &lt;code&gt;movco.l&lt;/code&gt; 명령 만 사용하여 하드웨어 원자 시퀀스를 생성하십시오 . SH4A에서만 사용할 수 있으며 멀티 코어 시스템에 적합합니다. 하드웨어 명령어는 32 비트 원자 변수 만 지원하므로 8 비트 또는 16 비트 변수에 대한 액세스는 32 비트 액세스로 에뮬레이트됩니다. 이 옵션으로 컴파일 된 코드는 SH4A 시스템에서 실행될 경우 다른 소프트웨어 원자 모델 인터럽트 / 예외 처리 시스템과도 호환됩니다. 이 모델에는 시스템의 인터럽트 / 예외 처리 코드에 대한 추가 지원이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8debf693e895754ae8dfa412a7398684e52957b" translate="yes" xml:space="preserve">
          <source>Generate instructions for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. In contrast to</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu-type&lt;/var&gt; 에 대한 지시 사항을 생성하십시오 . 대조적으로</target>
        </trans-unit>
        <trans-unit id="4d9806e63398f5c7206d46ddf2dd393879704321" translate="yes" xml:space="preserve">
          <source>Generate instructions supported by barrel shifter. This is the default unless</source>
          <target state="translated">배럴 시프터가 지원하는 명령어를 생성합니다. 이것이 아니면 기본값입니다</target>
        </trans-unit>
        <trans-unit id="a86b264be3b7927eef8b4d4ec32bd6e0abb23e9a" translate="yes" xml:space="preserve">
          <source>Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions are called with the address of the current function and its call site. (On some platforms, &lt;code&gt;__builtin_return_address&lt;/code&gt; does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)</source>
          <target state="translated">기능 진입 및 종료를위한 계측 호출을 생성합니다. 함수 입력 직후 및 함수 종료 직전에 다음 프로파일 링 함수가 현재 함수의 주소와 해당 호출 사이트로 호출됩니다. (일부 플랫폼에서 &lt;code&gt;__builtin_return_address&lt;/code&gt; 는 현재 기능 이상으로 작동하지 않으므로 콜링 정보가 프로파일 링 기능에 사용 가능하지 않을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a558056c364dd801f66dea4bd9ff5d7025049fb1" translate="yes" xml:space="preserve">
          <source>Generate little-endian (default) or big-endian (experimental) code, respectively.</source>
          <target state="translated">리틀 엔디안 (기본값) 또는 빅 엔디안 (실험) 코드를 각각 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8c624983438064d33fb3b88653aa23aaa51afa20" translate="yes" xml:space="preserve">
          <source>Generate little-endian code.</source>
          <target state="translated">리틀 엔디안 코드를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d362bc65e7c53091f19c9e25dc0b1f5baf698d4a" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default for &amp;lsquo;</source>
          <target state="translated">리틀 엔디안 코드를 생성하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="66047ec2f64b4bd1b8fdd5fa2877f3f85b442eac" translate="yes" xml:space="preserve">
          <source>Generate little-endian code. This is the default when GCC is configured for an &amp;lsquo;</source>
          <target state="translated">리틀 엔디안 코드를 생성하십시오. GCC가 '</target>
        </trans-unit>
        <trans-unit id="e76d98abdce9e7fa1b4a7b7f0a6241f584dc592c" translate="yes" xml:space="preserve">
          <source>Generate mul.x and umul.x instructions. This is the default for &amp;lsquo;</source>
          <target state="translated">mul.x 및 umul.x 명령어를 생성하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="11b3830c8f1fe1ef2c6dc043ba7fa4b0665f2d6d" translate="yes" xml:space="preserve">
          <source>Generate non-looping inline code for all block compares (such as calls to &lt;code&gt;memcmp&lt;/code&gt; or structure compares) less than or equal to &lt;var&gt;num&lt;/var&gt; bytes. If &lt;var&gt;num&lt;/var&gt; is 0, all inline expansion (non-loop and loop) of block compare is disabled. The default value is target-specific.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; 바이트 이하의 모든 블록 비교 (예 : &lt;code&gt;memcmp&lt;/code&gt; 호출 또는 구조 비교)에 대해 비 루프 인라인 코드를 생성하십시오 . 경우 &lt;var&gt;num&lt;/var&gt; 0, 비교 블록의 모든 인라인 확장 (비 루프 및 루프)를 비활성화한다. 기본값은 대상에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="726e8e558f2a846b8999b9aeb3c7faa8d320b08e" translate="yes" xml:space="preserve">
          <source>Generate object code compatible with the standard GNU Objective-C runtime. This is the default for most types of systems.</source>
          <target state="translated">표준 GNU Objective-C 런타임과 호환되는 객체 코드를 생성합니다. 대부분의 시스템 유형에 대한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5f828fdb836a3167f3a117e320f8c23966c29566" translate="yes" xml:space="preserve">
          <source>Generate output compatible with the NeXT runtime. This is the default for NeXT-based systems, including Darwin and Mac OS X. The macro &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; is predefined if (and only if) this option is used.</source>
          <target state="translated">NeXT 런타임과 호환되는 출력을 생성하십시오. 이는 Darwin 및 Mac OS X를 포함한 NeXT 기반 시스템의 기본값입니다 .이 옵션을 사용하는 경우 매크로 &lt;code&gt;__NEXT_RUNTIME__&lt;/code&gt; 이 사전 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3b10b8584ef5629375b0697c006157af2562811c" translate="yes" xml:space="preserve">
          <source>Generate output containing 80387 instructions for floating point.</source>
          <target state="translated">부동 소수점에 대한 80387 명령어를 포함하는 출력을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac64fa385d79df6893e650d3c87094e5fab8e8d" translate="yes" xml:space="preserve">
          <source>Generate output containing floating-point instructions. This is the default.</source>
          <target state="translated">부동 소수점 명령어가 포함 된 출력을 생성합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a54c9d559afdf54011312401dae184f34851998d" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point.</source>
          <target state="translated">부동 소수점에 대한 라이브러리 호출을 포함하는 출력을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b68715959fa47ba0ff79de672b756a42be41a84c" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all HPPA targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">부동 소수점에 대한 라이브러리 호출을 포함하는 출력을 생성하십시오. &lt;strong&gt;경고 :&lt;/strong&gt; 필수 라이브러리를 모든 HPPA 대상에 사용할 수있는 것은 아닙니다. 일반적으로 시스템의 일반적인 C 컴파일러 기능이 사용되지만이 작업은 크로스 컴파일에서 직접 수행 할 수 없습니다. 크로스 컴파일에 적합한 라이브러리 기능을 제공하기 위해 사용자가 직접 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="123686fdd6543b04616633629545ce470b234181" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for floating point. &lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &amp;lsquo;</source>
          <target state="translated">부동 소수점에 대한 라이브러리 호출을 포함하는 출력을 생성하십시오. &lt;strong&gt;경고 :&lt;/strong&gt; 필수 라이브러리를 모든 SPARC 대상에 사용할 수있는 것은 아닙니다. 일반적으로 시스템의 일반적인 C 컴파일러 기능이 사용되지만이 작업은 크로스 컴파일에서 직접 수행 할 수 없습니다. 크로스 컴파일에 적합한 라이브러리 기능을 제공하기 위해 사용자가 직접 준비해야합니다. 임베디드 타겟 '</target>
        </trans-unit>
        <trans-unit id="374b214aae9f131ecd8bd8fbf3ba7e20116baf86" translate="yes" xml:space="preserve">
          <source>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.</source>
          <target state="translated">쿼드 워드 (long double) 부동 소수점 명령어에 대한 라이브러리 호출을 포함하는 출력을 생성합니다. 호출 된 기능은 SPARC ABI에 지정된 기능입니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e778386ad4f7c29303d76d557065f8b2cddd1a1e" translate="yes" xml:space="preserve">
          <source>Generate output containing quad-word (long double) floating-point instructions.</source>
          <target state="translated">쿼드 워드 (긴 더블) 부동 소수점 명령어를 포함하는 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="72b8d6815f1c63fef196e30ed85ba66e28021cd2" translate="yes" xml:space="preserve">
          <source>Generate output for a 5206e ColdFire CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">5206e ColdFire CPU에 대한 출력을 생성하십시오. 해당 옵션을 위해 옵션이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64050f292f81abd70f3bb1391b078794170aa43c" translate="yes" xml:space="preserve">
          <source>Generate output for a 520X ColdFire CPU. This is the default when the compiler is configured for 520X-based systems. It is equivalent to</source>
          <target state="translated">520X ColdFire CPU에 대한 출력을 생성하십시오. 컴파일러가 520X 기반 시스템에 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="4e6125bf5e16c60081ffba73c18391756b953da9" translate="yes" xml:space="preserve">
          <source>Generate output for a 68000. This is the default when the compiler is configured for 68000-based systems. It is equivalent to</source>
          <target state="translated">68000에 대한 출력을 생성하십시오. 컴파일러가 68000 기반 시스템에 대해 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="293fc36513894f8af34456d5d4568e3a8a660df3" translate="yes" xml:space="preserve">
          <source>Generate output for a 68010. This is the default when the compiler is configured for 68010-based systems. It is equivalent to</source>
          <target state="translated">68010에 대한 출력을 생성하십시오. 컴파일러가 68010 기반 시스템에 대해 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="3de0124e7fb5a143b3bdb1e5bf42ea00b8dc1041" translate="yes" xml:space="preserve">
          <source>Generate output for a 68020. This is the default when the compiler is configured for 68020-based systems. It is equivalent to</source>
          <target state="translated">68020에 대한 출력을 생성하십시오. 컴파일러가 68020 기반 시스템에 대해 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="a2125889bc447fbbe5141c63e65b9cc93af2774c" translate="yes" xml:space="preserve">
          <source>Generate output for a 68030. This is the default when the compiler is configured for 68030-based systems. It is equivalent to</source>
          <target state="translated">68030에 대한 출력을 생성하십시오. 이는 컴파일러가 68030 기반 시스템에 대해 구성된 경우의 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="dcd8a9aedf0282928a86db993cf8d4ff8070b038" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68040.</source>
          <target state="translated">새로운 명령어를 사용하지 않고 68040에 대한 출력을 생성하십시오. 이로 인해 68020/68881 또는 68030 또는 68040에서 상대적으로 효율적으로 실행될 수있는 코드가 생성됩니다. 생성 된 코드는 68040에서 에뮬레이트 된 68881 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dd4119d908a2b18c651ef46f26b46cd2bc8b0de2" translate="yes" xml:space="preserve">
          <source>Generate output for a 68040. This is the default when the compiler is configured for 68040-based systems. It is equivalent to</source>
          <target state="translated">68040에 대한 출력을 생성하십시오. 이는 컴파일러가 68040 기반 시스템에 대해 구성된 경우의 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="c0e33f0f063c998bb9f2f1ad28f52830efcc367f" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060, without using any of the new instructions. This results in code that can run relatively efficiently on either a 68020/68881 or a 68030 or a 68040. The generated code does use the 68881 instructions that are emulated on the 68060.</source>
          <target state="translated">새로운 명령어를 사용하지 않고 68060에 대한 출력을 생성하십시오. 이로 인해 68020/68881 또는 68030 또는 68040에서 상대적으로 효율적으로 실행될 수있는 코드가 생성됩니다. 생성 된 코드는 68060에서 에뮬레이트 된 68881 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e0aa817ee3651021250220786d7a8ddadf8d908" translate="yes" xml:space="preserve">
          <source>Generate output for a 68060. This is the default when the compiler is configured for 68060-based systems. It is equivalent to</source>
          <target state="translated">68060에 대한 출력을 생성하십시오. 컴파일러가 68060 기반 시스템에 대해 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="ea5be8485d83583c41e5d8584b5916331ad44880" translate="yes" xml:space="preserve">
          <source>Generate output for a CPU32. This is the default when the compiler is configured for CPU32-based systems. It is equivalent to</source>
          <target state="translated">CPU32에 대한 출력을 생성하십시오. 컴파일러가 CPU32 기반 시스템에 구성된 경우 기본값입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="e1d15ac03ce80d2a7972245b867ea55ebdb92c9b" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5307 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5307 CPU에 대한 출력을 생성하십시오. 해당 옵션을 위해 옵션이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e01c68482064d3161a9a189e69a1cae2c323dfb" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire 5407 CPU. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 5407 CPU에 대한 출력을 생성하십시오. 해당 옵션을 위해 옵션이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0aa9f4c3f64933730b3c4adacac26f4b2456673a" translate="yes" xml:space="preserve">
          <source>Generate output for a ColdFire V4e family CPU (e.g. 547x/548x). This includes use of hardware floating-point instructions. The option is equivalent to</source>
          <target state="translated">ColdFire V4e 제품군 CPU에 대한 출력을 생성하십시오 (예 : 547x / 548x). 여기에는 하드웨어 부동 소수점 명령어 사용이 포함됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="e7347e49e1182821745b1b659d00df4d824a3e04" translate="yes" xml:space="preserve">
          <source>Generate output for a member of the ColdFire 528X family. The option is now deprecated in favor of the equivalent</source>
          <target state="translated">ColdFire 528X 제품군의 구성원에 대한 출력을 생성하십시오. 해당 옵션을 위해 옵션이 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18dcb26797382565521c621a512430444b4e53d3" translate="yes" xml:space="preserve">
          <source>Generate performance extension 2 instructions.</source>
          <target state="translated">성능 확장 2 명령어를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="bd6544f4b4eb02ec7c1103af517606738fd2ba09" translate="yes" xml:space="preserve">
          <source>Generate performance extension instructions.</source>
          <target state="translated">성능 확장 지침을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d399ee7f07dc0a2fb4ab33398b031c9b688f806f" translate="yes" xml:space="preserve">
          <source>Generate position-independent EABI code.</source>
          <target state="translated">위치 독립적 EABI 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1d1142004c8111e7c50b740035c14c26ae3a4d40" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that</source>
          <target state="translated">대상 시스템에 대해 지원되는 경우 공유 라이브러리에서 사용하기에 적합한 위치 독립적 코드 (PIC)를 생성하십시오. 이러한 코드는 전역 오프셋 테이블 (GOT)을 통해 모든 상수 주소에 액세스합니다. 동적 로더는 프로그램이 시작될 때 GOT 항목을 분석합니다 (동적 로더는 GCC의 일부가 아니며 운영 체제의 일부 임). 연결된 실행 파일의 GOT 크기가 시스템 별 최대 크기를 초과하면 링커에서 다음과 같은 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="48b952028eaadcc5cf5b2652a4f09475aac1135d" translate="yes" xml:space="preserve">
          <source>Generate secure code as per the &quot;ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification&quot;, which can be found on &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0에&lt;/a&gt; 있는 &quot;ARMv8-M 보안 확장 : 개발 도구 엔지니어링 사양 요구 사항&quot;에 따라 보안 코드를 생성하십시오 . pdf .</target>
        </trans-unit>
        <trans-unit id="61825c7f7fe0283dfaa12a0bf7f79986a97151b2" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the compact implementation.</source>
          <target state="translated">컴팩트 한 구현을 위해 조정 된 단정도 FPX 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="57fc66010a803fb795da295b4fbe9fac5a8dbfd1" translate="yes" xml:space="preserve">
          <source>Generate single-precision FPX instructions, tuned for the fast implementation.</source>
          <target state="translated">빠른 구현을 위해 조정 된 단정도 FPX 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="03e730324ac713e9445bac5587ed90df17b4e2e3" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that temporarily disable interrupts by setting &lt;code&gt;SR.IMASK = 1111&lt;/code&gt;. This model works only when the program runs in privileged mode and is only suitable for single-core systems. Additional support from the interrupt/exception handling code of the system is not required. This model is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH1* or SH2*.</source>
          <target state="translated">&lt;code&gt;SR.IMASK = 1111&lt;/code&gt; 을 설정하여 인터럽트를 일시적으로 비활성화하는 소프트웨어 원자 시퀀스를 생성하십시오 . 이 모델은 프로그램이 권한 모드에서 실행될 때만 작동하며 단일 코어 시스템에만 적합합니다. 시스템의 인터럽트 / 예외 처리 코드에 대한 추가 지원은 필요하지 않습니다. 이 모델은 대상이 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 및 SH1 * 또는 SH2 * 인 경우 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="adcbfbeac80cfe6a3e4b55a0bdfaf3f19f30fbea" translate="yes" xml:space="preserve">
          <source>Generate software atomic sequences that use a variable in the thread control block. This is a variation of the gUSA sequences which can also be used on SH1* and SH2* targets. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for single-core systems. When using this model, the &amp;lsquo;</source>
          <target state="translated">스레드 제어 블록에서 변수를 사용하는 소프트웨어 원자 시퀀스를 생성하십시오. 이것은 SH1 * 및 SH2 * 대상에서도 사용할 수있는 gUSA 서열의 변형입니다. 생성 된 원자 시퀀스는 시스템의 인터럽트 / 예외 처리 코드의 추가 지원이 필요하며 단일 코어 시스템에만 적합합니다. 이 모델을 사용할 때 '</target>
        </trans-unit>
        <trans-unit id="7e273affad800c8c4cf1d009bbdccfc4d50d0a21" translate="yes" xml:space="preserve">
          <source>Generate stack protection code using canary at &lt;var&gt;guard&lt;/var&gt;. Supported locations are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;guard&lt;/var&gt; 에서 카나리아를 사용하여 스택 보호 코드를 생성합니다 . 지원되는 위치는 '</target>
        </trans-unit>
        <trans-unit id="b8a639f56facade8c98595f71ed5d4db9ac64830" translate="yes" xml:space="preserve">
          <source>Generate string extension instructions.</source>
          <target state="translated">문자열 확장 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8a1f94259681f1ae170bbb57344c845c25fbbd90" translate="yes" xml:space="preserve">
          <source>Generate the &lt;code&gt;tas.b&lt;/code&gt; opcode for &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. Notice that depending on the particular hardware and software configuration this can degrade overall performance due to the operand cache line flushes that are implied by the &lt;code&gt;tas.b&lt;/code&gt; instruction. On multi-core SH4A processors the &lt;code&gt;tas.b&lt;/code&gt; instruction must be used with caution since it can result in data corruption for certain cache configurations.</source>
          <target state="translated">생성] &lt;code&gt;tas.b&lt;/code&gt; 에 대한 오피 코드 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; 을 . 특정 하드웨어 및 소프트웨어 구성에 따라 &lt;code&gt;tas.b&lt;/code&gt; 명령에 의해 암시되는 피연산자 캐시 라인 플러시로 인해 전체 성능이 저하 될 수 있습니다 . 멀티 코어 SH4A 프로세서에서 &lt;code&gt;tas.b&lt;/code&gt; 명령어는 특정 캐시 구성에 대해 데이터가 손상 될 수 있으므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="33b6af1538444b86d0ad7d0fedaceadc538e6781" translate="yes" xml:space="preserve">
          <source>Generate the predefine, &lt;code&gt;_SIO&lt;/code&gt;, for server IO. The default is</source>
          <target state="translated">서버 IO에 대한 사전 정의 &lt;code&gt;_SIO&lt;/code&gt; 를 생성하십시오 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="556e10b173cc8258302ad6ae7353988cc9258bb9" translate="yes" xml:space="preserve">
          <source>Generate unwind table in DWARF format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).</source>
          <target state="translated">대상 시스템에서 지원하는 경우 DWARF 형식으로 테이블 풀기를 생성하십시오. 테이블은 각 명령어 경계에서 정확하므로 비동기 이벤트 (예 : 디버거 또는 가비지 수집기)에서 스택 해제에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57527d83fd3616a340b11bb579911dbfd64f477e" translate="yes" xml:space="preserve">
          <source>Generate v3 push25/pop25 instructions.</source>
          <target state="translated">v3 push25 / pop25 명령어를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="fb9942d737ee06d15159ff521f994cc01ae69210" translate="yes" xml:space="preserve">
          <source>Generated code is not compatible with hardware interrupts. Code size is smaller.</source>
          <target state="translated">생성 된 코드는 하드웨어 인터럽트와 호환되지 않습니다. 코드 크기가 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="847361d2a7401aea217f81327402896d9c474e00" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;sbit&lt;/code&gt;/&lt;code&gt;cbit&lt;/code&gt; instructions for bit manipulations.</source>
          <target state="translated">비트 조작을위한 &lt;code&gt;sbit&lt;/code&gt; / &lt;code&gt;cbit&lt;/code&gt; 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8c23e71aebd89fa525027dc7a4570046a7a64ce0" translate="yes" xml:space="preserve">
          <source>Generates an error message. This pragma &lt;em&gt;is&lt;/em&gt; considered to indicate an error in the compilation, and it will be treated as such.</source>
          <target state="translated">오류 메시지를 생성합니다. 이 pragma &lt;em&gt;는&lt;/em&gt; 컴파일 오류를 나타내는 것으로 간주되며 그대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b4a08a286760cba742dec264941903cd2180c988" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;brk&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;brk&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="de0ffdd1afe0ff10e18f301f3481e988ec1af918" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;clrpsw&lt;/code&gt; machine instruction to clear the specified bit in the processor status word.</source>
          <target state="translated">프로세서 상태 워드에서 지정된 비트를 지우는 &lt;code&gt;clrpsw&lt;/code&gt; 시스템 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e384966166fe10a7e3cda9622b8d991e42dbafb8" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32b&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32b&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="097e8495f2e00512011587a86cec2af02faf3293" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32l&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32l&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="257268a989f9b93ff19c2d7c87cb2336d607cc4f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32q&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32q&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b6ee9ffc23cac162df8a9b520916fe8eb4063947" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;crc32w&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;crc32w&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="9c0298bd9ac40c51cad36ed168d5ebaa6178f1de" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;etnd&lt;/code&gt; machine instruction. The current nesting depth is returned as integer value. For a nesting depth of 0 the code is not executed as part of an transaction.</source>
          <target state="translated">&lt;code&gt;etnd&lt;/code&gt; 기계 명령어를 생성합니다 . 현재 중첩 깊이는 정수 값으로 반환됩니다. 중첩 깊이가 0 인 경우 코드는 트랜잭션의 일부로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba9daaa604a3528f1838ae3869b5e548870970eb" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;extractps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;extractps&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="89f2857c101ed877edbedb096cf0c5b70642f1a6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;insertps&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;insertps&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="bddf0335c49f41b446b0994e140cc0b296730b66" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;int&lt;/code&gt; machine instruction to generate an interrupt with the specified value.</source>
          <target state="translated">생성 &lt;code&gt;int&lt;/code&gt; 지정된 값 인터럽트를 생성하는 시스템을 지시.</target>
        </trans-unit>
        <trans-unit id="cc578c8838d75de69df84505da3623cd37d917cc" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;machi&lt;/code&gt; machine instruction to add the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">두 인수의 상위 16 비트를 누산기에 곱한 결과를 추가 하는 &lt;code&gt;machi&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="99eacdb7a1185745b3f8d3546aa5c195c4ffc120" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;maclo&lt;/code&gt; machine instruction to add the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">두 인수의 하위 16 비트를 누산기에 곱한 결과를 추가하기 위해 &lt;code&gt;maclo&lt;/code&gt; machine 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7a0ca51423d0e24c5de865392e13bff92dec8a47" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; 시스템 명령어를 메모리의로드로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="a6336fc5b41c1f5923ae66b48c6856394b9f7d5d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movhps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movhps&lt;/code&gt; 시스템 명령어를 메모리에 대한 저장소로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="81a1c47a7ece45e98596dc9420085617e89d6661" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a load from memory</source>
          <target state="translated">메모리에서로드로 &lt;code&gt;movlps&lt;/code&gt; 기계 명령어를 생성합니다</target>
        </trans-unit>
        <trans-unit id="1e491626b2ecf306727f7b2f326dde340a6befb6" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movlps&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movlps&lt;/code&gt; 기계 명령어를 메모리에 대한 저장소로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="ac79e7ffaaf077d95a6d1ffa3d8fb253edbeb451" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movss&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movss&lt;/code&gt; 기계 명령어를 메모리에서로드로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc4d75da1c01f01ac98af15d63b74a7af18475d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a load from memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; 기계 명령어를 메모리에서로드로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="363646d48f8bc2356c5c4e7f637ebc00c96d25d3" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;movups&lt;/code&gt; machine instruction as a store to memory.</source>
          <target state="translated">&lt;code&gt;movups&lt;/code&gt; 기계 명령어를 메모리에 대한 저장소로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="bc35453eece3fefcd1bc15a0d478b36419def393" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mulhi&lt;/code&gt; machine instruction to place the result of multiplying the top 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">&lt;code&gt;mulhi&lt;/code&gt; machine 명령어를 생성하여 두 인수의 상위 16 비트를 누산기에 곱한 결과를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="52d614340e6bcb9b13e27d9daf3f3ec4c3e7003e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mullo&lt;/code&gt; machine instruction to place the result of multiplying the bottom 16 bits of the two arguments into the accumulator.</source>
          <target state="translated">두 인수의 하위 16 비트를 &lt;code&gt;mullo&lt;/code&gt; 에 곱한 결과를 배치하기 위해 뮬로 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="37702a0f744e0973c9767b2a0ae0b071d0ab6011" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfachi&lt;/code&gt; machine instruction to read the top 32 bits of the accumulator.</source>
          <target state="translated">&lt;code&gt;mvfachi&lt;/code&gt; 기계 명령어를 생성하여 누산기 의 상위 32 비트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e5e940957ba8e9f4e4a5a9b38f5ec9bacccdcd1d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfacmi&lt;/code&gt; machine instruction to read the middle 32 bits of the accumulator.</source>
          <target state="translated">&lt;code&gt;mvfacmi&lt;/code&gt; machine 명령어를 생성하여 누산기 의 중간 32 비트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="84ea7bb4390bbd29b42442b2c0df648769428770" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvfc&lt;/code&gt; machine instruction which reads the control register specified in its argument and returns its value.</source>
          <target state="translated">인수에 지정된 제어 레지스터를 읽고 해당 값을 리턴 하는 &lt;code&gt;mvfc&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="9a7f85fadc166c23e3a73720a98d17ae8d98c867" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtachi&lt;/code&gt; machine instruction to set the top 32 bits of the accumulator.</source>
          <target state="translated">누적 기의 상위 32 비트를 설정하기 위해 &lt;code&gt;mvtachi&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c2fa5a8c449853ed0e286fabb00686c6c4684432" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtaclo&lt;/code&gt; machine instruction to set the bottom 32 bits of the accumulator.</source>
          <target state="translated">&lt;code&gt;mvtaclo&lt;/code&gt; machine 명령을 생성하여 누산기 의 하위 32 비트를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0c726977269ab1aef450eb4579a182f674e2891b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtc&lt;/code&gt; machine instruction which sets control register number &lt;code&gt;reg&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">제어 레지스터 번호 &lt;code&gt;reg&lt;/code&gt; 를 &lt;code&gt;val&lt;/code&gt; 로 설정 하는 &lt;code&gt;mvtc&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e73288099a5726fcb09aeebaa5734e10714eb5f2" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;mvtipl&lt;/code&gt; machine instruction set the interrupt priority level.</source>
          <target state="translated">인터럽트 우선 순위 레벨을 설정 한 &lt;code&gt;mvtipl&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c95405f984d5d6abab06b81618d6b2d88c6bce16" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ntstg&lt;/code&gt; machine instruction. The second argument is written to the first arguments location. The store operation will not be rolled-back in case of an transaction abort.</source>
          <target state="translated">&lt;code&gt;ntstg&lt;/code&gt; 시스템 명령어를 생성합니다 . 두 번째 인수는 첫 번째 인수 위치에 기록됩니다. 트랜잭션 중단의 경우 저장 조작이 롤백되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="221810e17f3f5b7b6eee2c597dcc35e9560d5c1a" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pause&lt;/code&gt; machine instruction with a compiler memory barrier.</source>
          <target state="translated">컴파일러 메모리 배리어를 사용 하여 &lt;code&gt;pause&lt;/code&gt; 기계 명령을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="fabcc577b37bbc75f15d4acfc478723f40e312bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pclmulqdq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pclmulqdq&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="138581c28238370fdca095f892b8bcc2f037ebde" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrb&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="cc89464fd0e0ffc62121a43ea4c78a22a765f79b" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pextrd&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6995305b1713c32c1cb9c1c29aa123fa501311ad" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pextrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">64 비트 모드에서 &lt;code&gt;pextrq&lt;/code&gt; 기계 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7afd0d12563bc8ecde0ac65ab4ecf09a6388cc0c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrb&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrb&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="587eac9a0053b04618284992d46512728f7465b0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrd&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;pinsrd&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e89f9467a7fdb5f2511c4d93da028b6494b1db2e" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;pinsrq&lt;/code&gt; machine instruction in 64bit mode.</source>
          <target state="translated">64 비트 모드에서 &lt;code&gt;pinsrq&lt;/code&gt; 기계 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="167d17fe5058f3ef0cb33d59903eebaaf6162e68" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntl&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6cb126029514e2d5bfcb6bca148eb150b8aba8a4" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntl&lt;/code&gt; or &lt;code&gt;popcntq&lt;/code&gt; machine instruction, depending on the size of &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsigned long&lt;/code&gt; 의 크기에 따라 &lt;code&gt;popcntl&lt;/code&gt; 또는 &lt;code&gt;popcntq&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c32c9ad948f2048e1fcb6de749499d83eb38bfdd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;popcntq&lt;/code&gt; machine instruction.</source>
          <target state="translated">&lt;code&gt;popcntq&lt;/code&gt; 기계 명령을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c6a384a17f6c55681ebb99e208e7e76367ba0a5f" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;ppa rX,rY,1&lt;/code&gt; machine instruction. Where the integer parameter is loaded into rX and a value of zero is loaded into rY. The integer parameter specifies the number of times the transaction repeatedly aborted.</source>
          <target state="translated">&lt;code&gt;ppa rX,rY,1&lt;/code&gt; 기계 명령어를 생성합니다 . 정수 매개 변수는 rX에로드되고 값 0은 rY에로드됩니다. integer 매개 변수는 트랜잭션이 반복적으로 중단 된 횟수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ad4e7198804a310937a6c8bd6ea66807f131d33" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;racw&lt;/code&gt; machine instruction to round the accumulator according to the specified mode.</source>
          <target state="translated">지정된 모드에 따라 누산기를 반올림 하는 &lt;code&gt;racw&lt;/code&gt; 기계 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="94afa89c73a482e7f60ea3534ec6652b684e5611" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;revw&lt;/code&gt; machine instruction which swaps the bytes in the argument so that bits 0&amp;ndash;7 now occupy bits 8&amp;ndash;15 and vice versa, and also bits 16&amp;ndash;23 occupy bits 24&amp;ndash;31 and vice versa.</source>
          <target state="translated">비트 0&amp;ndash;7이 비트 8&amp;ndash;15를 차지하고 그 반대의 경우도 비트 16-23이 비트 24-31을 점유하고 그 반대도 가능하도록 인수의 바이트를 &lt;code&gt;revw&lt;/code&gt; 하는 revw machine 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6d19e7f0e193910eff939ea1df5fd508cf81e1dd" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;rmpa&lt;/code&gt; machine instruction which initiates a repeated multiply and accumulate sequence.</source>
          <target state="translated">반복 된 곱셈 및 누적 시퀀스를 시작하는 &lt;code&gt;rmpa&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="3a3c845817720a1abf8f57c24608a050c45caf15" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;round&lt;/code&gt; machine instruction which returns the floating-point argument rounded according to the current rounding mode set in the floating-point status word register.</source>
          <target state="translated">부동 소수점 상태 워드 레지스터에 설정된 현재 반올림 모드에 따라 반올림 된 부동 소수점 인수를 반환 하는 &lt;code&gt;round&lt;/code&gt; 기계 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="693bacff2407833725bfd8a8b85cfbf1bb7e034c" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;sat&lt;/code&gt; machine instruction which returns the saturated value of the argument.</source>
          <target state="translated">포화 된 인수 값을 반환 하는 &lt;code&gt;sat&lt;/code&gt; machine 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="0bd4f2535ab0460fd7e26bbf4e95465d1caef5d0" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;setpsw&lt;/code&gt; machine instruction to set the specified bit in the processor status word.</source>
          <target state="translated">프로세서 상태 워드에서 지정된 비트를 설정하기 위해 &lt;code&gt;setpsw&lt;/code&gt; machine 명령어를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="86af23191f84ff6e1646de29e1379a9fa322b441" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tabort&lt;/code&gt; machine instruction with the specified abort code. Abort codes from 0 through 255 are reserved and will result in an error message.</source>
          <target state="translated">지정된 중단 코드를 사용 하여 &lt;code&gt;tabort&lt;/code&gt; machine 명령어를 생성합니다 . 0에서 255 사이의 중단 코드는 예약되어 있으며 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="41fafa8bbaf148ec213bd90ff158b6b99b4cd68d" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbegin&lt;/code&gt; machine instruction starting a non-constrained hardware transaction. If the parameter is non-NULL the memory area is used to store the transaction diagnostic buffer and will be passed as first operand to &lt;code&gt;tbegin&lt;/code&gt;. This buffer can be defined using the &lt;code&gt;struct __htm_tdb&lt;/code&gt; C struct defined in &lt;code&gt;htmintrin.h&lt;/code&gt; and must reside on a double-word boundary. The second tbegin operand is set to &lt;code&gt;0xff0c&lt;/code&gt;. This enables save/restore of all GPRs and disables aborts for FPR and AR manipulations inside the transaction body. The condition code set by the tbegin instruction is returned as integer value. The tbegin instruction by definition overwrites the content of all FPRs. The compiler will generate code which saves and restores the FPRs. For soft-float code it is recommended to used the &lt;code&gt;*_nofloat&lt;/code&gt; variant. In order to prevent a TDB from being written it is required to pass a constant zero value as parameter. Passing a zero value through a variable is not sufficient. Although modifications of access registers inside the transaction will not trigger an transaction abort it is not supported to actually modify them. Access registers do not get saved when entering a transaction. They will have undefined state when reaching the abort code.</source>
          <target state="translated">제한되지 않은 하드웨어 트랜잭션을 시작하는 &lt;code&gt;tbegin&lt;/code&gt; 기계 명령어를 생성합니다 . 매개 변수가 NULL이 아닌 경우 메모리 영역은 트랜잭션 진단 버퍼를 저장하는 데 사용되며 &lt;code&gt;tbegin&lt;/code&gt; 에 첫 번째 피연산자로 전달됩니다 . 이 버퍼의 사용을 정의 할 수 &lt;code&gt;struct __htm_tdb&lt;/code&gt; 정의 C 구조체 &lt;code&gt;htmintrin.h&lt;/code&gt; 를 더블 워드 경계에 존재한다. 두 번째 tbegin 피연산자는 0xff0c로 설정됩니다 &lt;code&gt;0xff0c&lt;/code&gt; . 이를 통해 모든 GPR을 저장 / 복원하고 트랜잭션 본문 내에서 FPR 및 AR 조작을 중단 할 수 없습니다. tbegin 명령어로 설정된 조건 코드는 정수 값으로 반환됩니다. 정의에 의한 tbegin 명령은 모든 FPR의 내용을 덮어 씁니다. 컴파일러는 FPR을 저장하고 복원하는 코드를 생성합니다. 소프트 플로트 코드의 경우 &lt;code&gt;*_nofloat&lt;/code&gt; 를 사용하는 것이 좋습니다.다른. TDB가 작성되는 것을 방지하려면 상수 0 값을 매개 변수로 전달해야합니다. 변수를 통해 0 값을 전달하는 것만으로는 충분하지 않습니다. 트랜잭션 내부의 액세스 레지스터를 수정해도 트랜잭션 중단이 트리거되지는 않지만 실제로는이를 수정할 수는 없습니다. 트랜잭션을 입력 할 때 액세스 레지스터가 저장되지 않습니다. 중단 코드에 도달하면 정의되지 않은 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e6827eb1aea4f7107218c612803fe4d6ada64dff" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tbeginc&lt;/code&gt; machine instruction starting a constrained hardware transaction. The second operand is set to &lt;code&gt;0xff08&lt;/code&gt;.</source>
          <target state="translated">제한된 하드웨어 트랜잭션을 시작하는 &lt;code&gt;tbeginc&lt;/code&gt; 머신 명령어를 생성합니다 . 두 번째 피연산자는 &lt;code&gt;0xff08&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1623696be46dd23fac7b3be91a9dabc88baaf7ab" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;tend&lt;/code&gt; machine instruction finishing a transaction and making the changes visible to other threads. The condition code generated by tend is returned as integer value.</source>
          <target state="translated">(가) 생성 &lt;code&gt;tend&lt;/code&gt; 기계 명령어가 트랜잭션을 종료하고 다른 스레드를 볼 수 변경. tend에 의해 생성 된 조건 코드는 정수 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="98be0f38fb4c5ac278186b26e4d1c15696ff51bf" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;wait&lt;/code&gt; machine instruction.</source>
          <target state="translated">기계 &lt;code&gt;wait&lt;/code&gt; 명령을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="ea3f79632679059de141d66e9dca3bc06851d467" translate="yes" xml:space="preserve">
          <source>Generic VIA Nano CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3 및 SSSE3 명령어 세트를 지원하는 일반 VIA Nano CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="9aea01d94f58ef40baf7a92523ddcc334efa83d3" translate="yes" xml:space="preserve">
          <source>Get and set the contents of the floating-point control and status register (FPU control register 31). These functions are only available in hard-float code but can be called in both MIPS16 and non-MIPS16 contexts.</source>
          <target state="translated">부동 소수점 제어 및 상태 레지스터 (FPU 제어 레지스터 31)의 내용을 가져오고 설정하십시오. 이 함수는 하드 부동 코드에서만 사용할 수 있지만 MIPS16 및 비 MIPS16 컨텍스트에서 모두 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93019384bd85aa8984f35ea4b05d12346052144c" translate="yes" xml:space="preserve">
          <source>Get the current value of shadow stack pointer if shadow stack support from Intel CET is enabled in the hardware or &lt;code&gt;0&lt;/code&gt; otherwise. The &lt;code&gt;ret_type&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; for 64-bit targets and &lt;code&gt;unsigned int&lt;/code&gt; for 32-bit targets.</source>
          <target state="translated">하드웨어에서 Intel CET의 섀도 스택 지원이 활성화되어 있으면 섀도 스택 포인터의 현재 값을 가져 오거나 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 가져옵니다 . &lt;code&gt;ret_type&lt;/code&gt; 이 되는 &lt;code&gt;unsigned long long&lt;/code&gt; 64 비트 및 타겟에 대한 &lt;code&gt;unsigned int&lt;/code&gt; 32 비트의 타겟.</target>
        </trans-unit>
        <trans-unit id="242390092876b4a7227130b506459512d744c5bd" translate="yes" xml:space="preserve">
          <source>Getting pointers to labels, and computed gotos.</source>
          <target state="translated">레이블 및 계산 된 고토에 대한 포인터 가져 오기</target>
        </trans-unit>
        <trans-unit id="fbec048bbd1449a0bc11388da4d5291473184989" translate="yes" xml:space="preserve">
          <source>Getting the return or frame address of a function.</source>
          <target state="translated">함수의 리턴 또는 프레임 주소 얻기</target>
        </trans-unit>
        <trans-unit id="5bde8fdcb7065ba19c1a32d2b6a67073b7fb1601" translate="yes" xml:space="preserve">
          <source>Give a warning when a value of type &lt;code&gt;float&lt;/code&gt; is implicitly promoted to &lt;code&gt;double&lt;/code&gt;. CPUs with a 32-bit &amp;ldquo;single-precision&amp;rdquo; floating-point unit implement &lt;code&gt;float&lt;/code&gt; in hardware, but emulate &lt;code&gt;double&lt;/code&gt; in software. On such a machine, doing computations using &lt;code&gt;double&lt;/code&gt; values is much more expensive because of the overhead required for software emulation.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 값 이 암시 적으로 &lt;code&gt;double&lt;/code&gt; 로 승격 될 때 경고를 표시하십시오 . 32 비트 &quot;단 정밀도&quot;부동 소수점 단위를 사용하는 CPU 는 하드웨어에서 &lt;code&gt;float&lt;/code&gt; 을 구현 하지만 소프트웨어에서는 &lt;code&gt;double&lt;/code&gt; 을 에뮬레이션 합니다. 이러한 시스템에서는 소프트웨어 에뮬레이션에 필요한 오버 헤드로 인해 &lt;code&gt;double&lt;/code&gt; 값을 사용하여 계산하는 것이 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="133654b9660498348bca9e7a9d9666b1d3206bc1" translate="yes" xml:space="preserve">
          <source>Give a warning whenever a function is used before being declared. In C99 mode (</source>
          <target state="translated">함수가 선언되기 전에 사용될 때마다 경고를 표시하십시오. C99 모드에서 (</target>
        </trans-unit>
        <trans-unit id="ce9ec4f1d36927037e489058adc0d7c699b3e5d0" translate="yes" xml:space="preserve">
          <source>Give an error whenever the &lt;em&gt;base standard&lt;/em&gt; (see</source>
          <target state="translated">&lt;em&gt;기본 표준에&lt;/em&gt; 따라 오류가 발생 &lt;em&gt;합니다&lt;/em&gt; (참조</target>
        </trans-unit>
        <trans-unit id="10288103238e1aab071f91b995853a568ee8af72" translate="yes" xml:space="preserve">
          <source>Given a set of input registers that die in an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know which are implicitly popped by the &lt;code&gt;asm&lt;/code&gt;, and which must be explicitly popped by GCC.</source>
          <target state="translated">죽을 입력 레지스터 세트 감안할 때 &lt;code&gt;asm&lt;/code&gt; , 암시 적으로 튀어되는 알 필요가있다 &lt;code&gt;asm&lt;/code&gt; , 어느 명시 적으로 GCC가 튀어해야합니다.</target>
        </trans-unit>
        <trans-unit id="d87967442824754978f26c181e17cc9e46db44dd" translate="yes" xml:space="preserve">
          <source>Gives all externally visible functions in the file being compiled an ARM instruction set header which switches to Thumb mode before executing the rest of the function. This allows these functions to be called from non-interworking code. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">파일에서 외부에서 볼 수있는 모든 함수를 ARM 명령어 세트 헤더로 컴파일하여 나머지 함수를 실행하기 전에 Thumb 모드로 전환합니다. 이를 통해 이러한 기능을 비 인터 워킹 코드에서 호출 할 수 있습니다. 인터 워킹은 기본적으로 활성화되어 있으므로 AAPCS 구성에서는이 옵션이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28fd2d80d56f82ae132cdb0c4269c770aa941c82" translate="yes" xml:space="preserve">
          <source>Global register variables cannot have initial values, because an executable file has no means to supply initial contents for a register.</source>
          <target state="translated">실행 파일에는 레지스터의 초기 내용을 제공 할 수단이 없으므로 글로벌 레지스터 변수는 초기 값을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1edbfbe92e2bd9d3f1182eb37f4bcfb20acdde5" translate="yes" xml:space="preserve">
          <source>Go source code.</source>
          <target state="translated">소스 코드를 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0104e918e01eb5413cf5e7e2b781b5b40dca1b8d" translate="yes" xml:space="preserve">
          <source>Guide linker to relax instructions.</source>
          <target state="translated">지시기를 이완시키기위한 가이드 링커.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="c2d31434fb0f344cb4feeec0b0e57232ab31c7ad" translate="yes" xml:space="preserve">
          <source>HI and LO registers.</source>
          <target state="translated">HI 및 LO 레지스터.</target>
        </trans-unit>
        <trans-unit id="ae1313e0d197443a538cfdaa0498460e61bc9b40" translate="yes" xml:space="preserve">
          <source>HI register.</source>
          <target state="translated">HI 등록.</target>
        </trans-unit>
        <trans-unit id="9ffcbdd38d89bcb3eaa62489fe7281d06ece8295" translate="yes" xml:space="preserve">
          <source>HIGH register class $r12 to $r14, $r20 to $r31.</source>
          <target state="translated">HIGH 레지스터 클래스 $ r12 ~ $ r14, $ r20 ~ $ r31.</target>
        </trans-unit>
        <trans-unit id="3cb15a163b8ebe83004d3a7496bed1214d5c34ea" translate="yes" xml:space="preserve">
          <source>HK</source>
          <target state="translated">HK</target>
        </trans-unit>
        <trans-unit id="f187928fdb223e7f3b7b0396e72e2d59a5f12b29" translate="yes" xml:space="preserve">
          <source>HR</source>
          <target state="translated">HR</target>
        </trans-unit>
        <trans-unit id="85df07a121977d0d0044781e9eeed44012e5da35" translate="yes" xml:space="preserve">
          <source>Half-Precision Floating Point.</source>
          <target state="translated">반 정밀도 부동 소수점.</target>
        </trans-unit>
        <trans-unit id="98b9b2da1252ae05155633eda47b6a7d5cf72927" translate="yes" xml:space="preserve">
          <source>Halt. The processor stops execution. This built-in is useful for implementing assertions.</source>
          <target state="translated">정지. 프로세서가 실행을 중지합니다. 이 내장은 어설 션을 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="04a52ed9fb0a2eefbc17a28c7b4e166c12cd47d4" translate="yes" xml:space="preserve">
          <source>Hardware autoprefetcher scheduler model control flag. Number of lookahead cycles the model looks into; at &amp;rsquo; &amp;rsquo; only enable instruction sorting heuristic.</source>
          <target state="translated">하드웨어 자동 프리 페처 스케줄러 모델 제어 플래그. 모델이 조사하는 예측주기 수입니다. ''에서만 명령 정렬 휴리스틱을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="073339b2e7c4ff717e46d7be967106262132c9d4" translate="yes" xml:space="preserve">
          <source>Hardware multiplies are normally performed by calling a library routine. This saves space in the generated code. When compiling at</source>
          <target state="translated">하드웨어 곱셈은 일반적으로 라이브러리 루틴을 호출하여 수행됩니다. 이렇게하면 생성 된 코드의 공간이 절약됩니다. 에서 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="f483db45c59b64e904de79b67a44935e8bf546fe" translate="yes" xml:space="preserve">
          <source>Have &lt;code&gt;operator=&lt;/code&gt; return a reference to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">유무 &lt;code&gt;operator=&lt;/code&gt; 대한 참조를 반환 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="42b05fc1afa3da7a89484cda5a6cb36dbe6e8a78" translate="yes" xml:space="preserve">
          <source>Hence, it is assumed as a convention that &lt;code&gt;r*&lt;/code&gt; means &lt;code&gt;const
char *&lt;/code&gt; (since it is what is most often meant), and there is no way to encode &lt;code&gt;char *const&lt;/code&gt;. &lt;code&gt;char *const&lt;/code&gt; would simply be encoded as &lt;code&gt;*&lt;/code&gt;, and the &lt;code&gt;const&lt;/code&gt; is lost.</source>
          <target state="translated">따라서 &lt;code&gt;r*&lt;/code&gt; 는 &lt;code&gt;const char *&lt;/code&gt; *를 의미 하는 규칙으로 간주되며 (가장 자주 사용되는 의미이므로) &lt;code&gt;char *const&lt;/code&gt; 를 인코딩 할 방법이 없습니다 . &lt;code&gt;char *const&lt;/code&gt; 단순히로 인코딩 될 것이다 &lt;code&gt;*&lt;/code&gt; 하고, &lt;code&gt;const&lt;/code&gt; 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ff03b9e0183ccfd153d29e4ebb71b3afc43687" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;</source>
          <target state="translated">여기 '</target>
        </trans-unit>
        <trans-unit id="63fa474126b5fb0e84bc0e1276f71b4f5949c4a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; may or may not be restored to its first value when the &lt;code&gt;longjmp&lt;/code&gt; occurs. If &lt;code&gt;a&lt;/code&gt; is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</source>
          <target state="translated">이곳까지 &lt;code&gt;a&lt;/code&gt; 되거나 때 처음 값으로 복원되지 않을 수도 &lt;code&gt;longjmp&lt;/code&gt; 를가 발생한다. &lt;code&gt;a&lt;/code&gt; 가 레지스터에 할당 되면 첫 번째 값이 복원됩니다. 그렇지 않으면 마지막으로 저장된 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6c22abcd7bcbe4b705f9506a92dff2b4514bc0a5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining global register variables, but for a local variable the declaration appears within a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">여기서 &lt;code&gt;r12&lt;/code&gt; 는 사용해야하는 레지스터의 이름입니다. 이것은 전역 레지스터 변수를 정의하는 데 사용되는 구문과 동일하지만 로컬 변수의 경우 선언이 함수 내에 나타납니다. &lt;code&gt;register&lt;/code&gt; 키워드가 필요하고, 함께 사용할 수 없습니다 &lt;code&gt;static&lt;/code&gt; . 레지스터 이름은 대상 플랫폼에 유효한 레지스터 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e629674ac2ffa8c8e6f920770dda44cae02f866e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;r12&lt;/code&gt; is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The &lt;code&gt;register&lt;/code&gt; keyword is required, and cannot be combined with &lt;code&gt;static&lt;/code&gt;. The register name must be a valid register name for the target platform.</source>
          <target state="translated">여기서 &lt;code&gt;r12&lt;/code&gt; 는 사용해야하는 레지스터의 이름입니다. 이것은 로컬 레지스터 변수를 정의하는 데 사용되는 구문과 동일하지만 전역 변수의 경우 선언은 함수 외부에 나타납니다. &lt;code&gt;register&lt;/code&gt; 키워드가 필요하고, 함께 사용할 수 없습니다 &lt;code&gt;static&lt;/code&gt; . 레지스터 이름은 대상 플랫폼에 유효한 레지스터 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1bd41698f09a234c8d3f5259448a5e29c338b76f" translate="yes" xml:space="preserve">
          <source>Here are constraint modifier characters.</source>
          <target state="translated">제약 수정 자 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13c7c696c96d9253d198dc3e9c528b8ff4863b3b" translate="yes" xml:space="preserve">
          <source>Here are some examples showing uses of these options.</source>
          <target state="translated">다음은 이러한 옵션의 사용법을 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a2f0dcf3cf944a4192020c4b10f40e42e5e117ae" translate="yes" xml:space="preserve">
          <source>Here are some more examples of output operands.</source>
          <target state="translated">다음은 출력 피연산자의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="25efdeb982b817cc2032012465d473ceaf58d073" translate="yes" xml:space="preserve">
          <source>Here are some types and their encodings, as they are generated by the compiler on an i386 machine:</source>
          <target state="translated">다음은 i386 시스템에서 컴파일러에 의해 생성되는 일부 유형 및 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="807544d18135eba132f45e4832519a518a98b736" translate="yes" xml:space="preserve">
          <source>Here are specific details on what constraint letters you can use with &lt;code&gt;asm&lt;/code&gt; operands. Constraints can say whether an operand may be in a register, and which kinds of register; whether the operand can be a memory reference, and which kinds of address; whether the operand may be an immediate constant, and which possible values it may have. Constraints can also require two operands to match. Side-effects aren&amp;rsquo;t allowed in operands of inline &lt;code&gt;asm&lt;/code&gt;, unless &amp;lsquo;</source>
          <target state="translated">다음은 &lt;code&gt;asm&lt;/code&gt; 피연산자 와 함께 사용할 수있는 제약 조건 문자에 대한 세부 정보입니다 . 제약 조건은 피연산자가 레지스터에 있는지 여부와 레지스터의 종류를 말할 수 있습니다. 피연산자가 메모리 참조가 될 수 있는지 여부와 어떤 종류의 주소; 피연산자가 즉각적인 상수인지 여부와 가능한 값을 나타냅니다. 구속 조건은 두 개의 피연산자가 일치해야 할 수도 있습니다. 부작용은 인라인의 피연산자에서 허용되지 않습니다 &lt;code&gt;asm&lt;/code&gt; '하지 않는 한,</target>
        </trans-unit>
        <trans-unit id="8169e79c24e48ad827616f09316f377a5693db58" translate="yes" xml:space="preserve">
          <source>Here is a fictitious &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; instruction. Notice that the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; pointer registers must be specified as input/output because the &lt;code&gt;asm&lt;/code&gt; modifies them.</source>
          <target state="translated">가상의 &lt;code&gt;*z++ = *x++ * *y++&lt;/code&gt; 명령이 있습니다. 주목하라 것으로 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 포인터 레지스터의 입력 / 출력으로 지정해야하기 때문에 &lt;code&gt;asm&lt;/code&gt; 수정 그들.</target>
        </trans-unit>
        <trans-unit id="b840ee95bd53e4b94e99eb87178d11fd9afdba38" translate="yes" xml:space="preserve">
          <source>Here is a fictitious sum of squares instruction, that takes two pointers to floating point values in memory and produces a floating point register output. Notice that &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; both appear twice in the &lt;code&gt;asm&lt;/code&gt; parameters, once to specify memory accessed, and once to specify a base register used by the &lt;code&gt;asm&lt;/code&gt;. You won&amp;rsquo;t normally be wasting a register by doing this as GCC can use the same register for both purposes. However, it would be foolish to use both &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%3&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in this &lt;code&gt;asm&lt;/code&gt; and expect them to be the same. In fact, &lt;code&gt;%3&lt;/code&gt; may well not be a register. It might be a symbolic memory reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">다음은 가상의 제곱합 명령어입니다. 메모리에서 부동 소수점 값에 대한 두 개의 포인터를 가져와 부동 소수점 레지스터 출력을 생성합니다. 알 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 두번 나타나는 양쪽 &lt;code&gt;asm&lt;/code&gt; 번 염기에 의해 사용되는 레지스터 지정 일단 메모리 액세스를 지정하고, 파라미터 &lt;code&gt;asm&lt;/code&gt; . GCC가 두 가지 용도로 동일한 레지스터를 사용할 수 있으므로 일반적으로이 작업을 수행하여 레지스터를 낭비하지 않습니다. 그러나이 &lt;code&gt;asm&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;%1&lt;/code&gt; 과 &lt;code&gt;%3&lt;/code&gt; 을 모두 사용 하고 동일한 것으로 기대하는 것은 어리석은 일 입니다 . 실제로 &lt;code&gt;%3&lt;/code&gt; 레지스터가 아닐 수도 있습니다. &lt;code&gt;x&lt;/code&gt; 가 가리키는 객체에 대한 기호 메모리 참조 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="989c5915dce017df7249cda1058c0a0b75ec727b" translate="yes" xml:space="preserve">
          <source>Here is a fully worked-out example using a Foundation library (which provides the implementation of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSString&lt;/code&gt; and &lt;code&gt;NSLog&lt;/code&gt;):</source>
          <target state="translated">다음은 Foundation 라이브러리 ( &lt;code&gt;NSArray&lt;/code&gt; , &lt;code&gt;NSString&lt;/code&gt; 및 &lt;code&gt;NSLog&lt;/code&gt; 의 구현을 제공함)를 사용하여 완전히 해결 된 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="0837d871cde10d5f686c43af16d467ea239dcffc" translate="yes" xml:space="preserve">
          <source>Here is a list of each supported architecture and their supported implementations.</source>
          <target state="translated">다음은 지원되는 각 아키텍처 및 지원되는 구현 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6bbe295750387ad466f92bad763fdcf85832b55b" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling C++ programs:</source>
          <target state="translated">다음은 C ++ 프로그램 컴파일 &lt;em&gt;전용&lt;/em&gt; 옵션 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="9c6de7709b9bd71702ea864b6b84c7a93a1c5dfe" translate="yes" xml:space="preserve">
          <source>Here is a list of options that are &lt;em&gt;only&lt;/em&gt; for compiling Objective-C and Objective-C++ programs:</source>
          <target state="translated">다음은 옵션 목록입니다 &lt;em&gt;만&lt;/em&gt; 목표 - C와 목표 - C ++ 프로그램을 컴파일은 :</target>
        </trans-unit>
        <trans-unit id="3d287577ba4a1613932b539025d50b64c148479a" translate="yes" xml:space="preserve">
          <source>Here is a more technical description with the gory details. Consider the code</source>
          <target state="translated">자세한 내용은 기술적 인 설명입니다. 코드를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="1f5c95b6edb6a49dd54cd8ace0a3af7f6b8efa6e" translate="yes" xml:space="preserve">
          <source>Here is a realistic example for the VAX showing the use of clobbered registers:</source>
          <target state="translated">다음은 클로버 레지스터 사용을 보여주는 VAX의 현실적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="fab100c4848d525a51e3c94ffe939c5c90d217c1" translate="yes" xml:space="preserve">
          <source>Here is a small example of a spec file:</source>
          <target state="translated">다음은 스펙 파일의 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="fd38f38bfeb097a932215690af5b2bcebdd18296" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">다음은 모든 옵션을 유형별로 그룹화 한 요약입니다. 다음 섹션에 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="776e1d0b1f7cf817731495ac8a0bb9e5528c2c48" translate="yes" xml:space="preserve">
          <source>Here is a table of all defined &amp;lsquo;</source>
          <target state="translated">다음은 모든 정의 된 표입니다.</target>
        </trans-unit>
        <trans-unit id="72ec126b11c4f7e2b3f6db181072684dbe3a798e" translate="yes" xml:space="preserve">
          <source>Here is a truncated example from the ARM port of &lt;code&gt;gcc&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;gcc&lt;/code&gt; 의 ARM 포트에서 잘린 예입니다 .</target>
        </trans-unit>
        <trans-unit id="816eebea82d67ac72ae8e305241f89073b0b966e" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;asm goto&lt;/code&gt; for i386:</source>
          <target state="translated">다음은 i386 용 &lt;code&gt;asm goto&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="ddf77123eb0a199270833915774797e456c51dd3" translate="yes" xml:space="preserve">
          <source>Here is an example of a PowerPC vector scale implemented in assembly, complete with vector and condition code clobbers, and some initialized offset registers that are unchanged by the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">다음은 어셈블리에서 구현되고 벡터 및 조건 코드 클로버와 &lt;code&gt;asm&lt;/code&gt; 에 의해 변경되지 않은 초기화 된 오프셋 레지스터로 완성 된 PowerPC 벡터 스케일의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="874ef7a4fb34e57091c1bf1216dfbb76680c0a4d" translate="yes" xml:space="preserve">
          <source>Here is an example of basic &lt;code&gt;asm&lt;/code&gt; for i386:</source>
          <target state="translated">다음은 i386에 대한 기본 &lt;code&gt;asm&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="578c29000b6f8a220ff3bd98b1f6dac59cfc8f4c" translate="yes" xml:space="preserve">
          <source>Here is an example of constructing a &lt;code&gt;struct foo&lt;/code&gt; with a compound literal:</source>
          <target state="translated">복합 리터럴 로 &lt;code&gt;struct foo&lt;/code&gt; 를 구성하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b487a854c417efabdfc0cd516c584d94dc1d4a11" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this feature. Suppose you want to implement a class whose instances hold a weak pointer reference; the following class does this:</source>
          <target state="translated">이 기능을 사용하는 방법의 예는 다음과 같습니다. 인스턴스가 약한 포인터 참조를 보유하는 클래스를 구현한다고 가정하십시오. 다음 클래스가이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ab5b5e88b81c892525543bbf2b441bfb5667f5c0" translate="yes" xml:space="preserve">
          <source>Here is an example showing handling for &lt;code&gt;_XABORT_RETRY&lt;/code&gt; and a fallback path for other failures:</source>
          <target state="translated">다음은 &lt;code&gt;_XABORT_RETRY&lt;/code&gt; 처리 및 기타 실패에 대한 폴백 경로를 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="156d8468259daa1a9f530dd9ec7054117c896faf" translate="yes" xml:space="preserve">
          <source>Here is an example using symbolic names.</source>
          <target state="translated">다음은 기호 이름을 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="aa58661567f951b6e91b047e11c73d9fb7a1db05" translate="yes" xml:space="preserve">
          <source>Here is an example with a typename as the argument:</source>
          <target state="translated">다음은 typename을 인수로 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26a60c8be4c01c6ccc45bd8984830035c8dc1a26" translate="yes" xml:space="preserve">
          <source>Here the two output filenames</source>
          <target state="translated">여기에 두 개의 출력 파일 이름</target>
        </trans-unit>
        <trans-unit id="00b4a6c83965e727380186cb35a7faefe39e2601" translate="yes" xml:space="preserve">
          <source>Here the type described is that of pointers to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">여기에 설명 된 유형은 &lt;code&gt;int&lt;/code&gt; 에 대한 포인터 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="df28516bc4139f3f069071685fe09b0059baa73c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;d&lt;/code&gt; may either be in a register or in memory. Since the compiler might already have the current value of the &lt;code&gt;uint32_t&lt;/code&gt; location pointed to by &lt;code&gt;e&lt;/code&gt; in a register, you can enable it to choose the best location for &lt;code&gt;d&lt;/code&gt; by specifying both constraints.</source>
          <target state="translated">여기서 &lt;code&gt;d&lt;/code&gt; 는 레지스터 또는 메모리에있을 수 있습니다. 컴파일러가 레지스터에서 &lt;code&gt;e&lt;/code&gt; 가 가리키는 &lt;code&gt;uint32_t&lt;/code&gt; 위치 의 현재 값을 이미 가질 수 있으므로 두 제약 조건을 모두 지정하여 &lt;code&gt;d&lt;/code&gt; 에 가장 적합한 위치를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d245b0ad9046b148b54dc212babce2d8a4b44886" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t4&lt;/code&gt; takes up 4 bytes.</source>
          <target state="translated">여기서 &lt;code&gt;t4&lt;/code&gt; 는 4 바이트를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="46a3f0b1a7f9b9f0c9d86a3230e304304bee1bda" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;t5&lt;/code&gt; takes up 2 bytes.</source>
          <target state="translated">여기서 &lt;code&gt;t5&lt;/code&gt; 는 2 바이트를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="f9dddf42b68435ab0aa7d4d6b86db289bd3db824" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;std::move&lt;/code&gt; call is redundant. Because G++ implements Core Issue 1579, another example is:</source>
          <target state="translated">여기서 &lt;code&gt;std::move&lt;/code&gt; 호출은 중복됩니다. G ++는 Core Issue 1579를 구현하기 때문에 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94a1520d218a1c0edb195732392c054a4dc1a61d" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;intermediate&lt;/code&gt; receives the address of &lt;code&gt;store&lt;/code&gt; as an argument. If &lt;code&gt;intermediate&lt;/code&gt; calls &lt;code&gt;store&lt;/code&gt;, the arguments given to &lt;code&gt;store&lt;/code&gt; are used to store into &lt;code&gt;array&lt;/code&gt;. But this technique works only so long as the containing function (&lt;code&gt;hack&lt;/code&gt;, in this example) does not exit.</source>
          <target state="translated">여기서 함수 &lt;code&gt;intermediate&lt;/code&gt; 는 &lt;code&gt;store&lt;/code&gt; 주소를 인수로 받습니다 . &lt;code&gt;intermediate&lt;/code&gt; 호출이 &lt;code&gt;store&lt;/code&gt; 인 경우 , store 에 제공된 인수 는 &lt;code&gt;array&lt;/code&gt; 에 &lt;code&gt;store&lt;/code&gt; 하는 데 사용됩니다 . 그러나이 기술은 포함 함수 ( 이 예에서는 &lt;code&gt;hack&lt;/code&gt; )가 종료되지 않는 한 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e86d7a0668faeeae59dff730b5c0908c7e965fa" translate="yes" xml:space="preserve">
          <source>Here, the names &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; appear in a context that does not depend on the type of &lt;code&gt;T&lt;/code&gt;. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use &lt;code&gt;::foo(double)&lt;/code&gt; and &lt;code&gt;A::N&lt;/code&gt;, respectively. In particular, it will convert the integer value to a &lt;code&gt;double&lt;/code&gt; when passing it to &lt;code&gt;::foo(double)&lt;/code&gt;.</source>
          <target state="translated">여기서 이름 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 유형에 의존하지 않는 컨텍스트에 나타납니다 . 따라서 컴파일러는 인스턴스화 시점 이전뿐만 아니라 템플릿에서 사용 컨텍스트로 정의해야하며 여기 에서 각각 &lt;code&gt;::foo(double)&lt;/code&gt; 및 &lt;code&gt;A::N&lt;/code&gt; 합니다. 특히, &lt;code&gt;::foo(double)&lt;/code&gt; 전달할 때 정수 값을 &lt;code&gt;double&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8a9da0e5c138e6d84a3e4a12f0c523bc1f369e0f" translate="yes" xml:space="preserve">
          <source>Hewlett-Packard PA-RISC&amp;mdash;</source>
          <target state="translated">휴렛팩커드 PA-RISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9e735341d337ae137df7758e8465bb4d998cc55a" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point constants.</source>
          <target state="translated">16 진 부동 소수점 상수.</target>
        </trans-unit>
        <trans-unit id="26e165ccce457fee42636ec531aa349640cf4392" translate="yes" xml:space="preserve">
          <source>Hidden visibility indicates that the entity declared has a new form of linkage, which we call &amp;ldquo;hidden linkage&amp;rdquo;. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object.</source>
          <target state="translated">숨겨진 가시성은 선언 된 엔터티에 새로운 형태의 연계가 있음을 나타내며이를 &quot;숨겨진 연계&quot;라고합니다. 숨겨진 링크가있는 객체의 두 선언은 동일한 공유 객체에있는 경우 동일한 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29464505836db623029950c0312fcb03cbd85481" translate="yes" xml:space="preserve">
          <source>Historically, GCC has not deleted &amp;ldquo;empty&amp;rdquo; loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</source>
          <target state="translated">역사적으로 GCC는 프로그램에 넣을 가능성이 가장 높은 이유는 지연이 있기 때문에&amp;ldquo;빈&amp;rdquo;루프를 삭제하지 않았으므로 삭제하면 실제 프로그램이 더 빨리 실행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="25855108b662a0e8c1ed703787f979b815d2d1a6" translate="yes" xml:space="preserve">
          <source>Historically, compilers for many languages, including C++ and Fortran, have been implemented as &amp;ldquo;preprocessors&amp;rdquo; which emit another high level language such as C. None of the compilers included in GCC are implemented this way; they all generate machine code directly. This sort of preprocessor should not be confused with the &lt;em&gt;C preprocessor&lt;/em&gt;, which is an integral feature of the C, C++, Objective-C and Objective-C++ languages.</source>
          <target state="translated">역사적으로 C ++ 및 Fortran을 포함한 여러 언어의 컴파일러는 C와 같은 다른 고급 언어를 방출하는 &quot;전 처리기&quot;로 구현되었습니다. GCC에 포함 된 컴파일러는 이러한 방식으로 구현되지 않습니다. 그들은 모두 기계 코드를 직접 생성합니다. 이러한 종류의 전처리 기는 C, C ++, Objective-C 및 Objective-C ++ 언어의 필수 기능인 &lt;em&gt;C 전처리 기와&lt;/em&gt; 혼동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="1df0e52c96207e60432f242eee2da9b8ff549d2b" translate="yes" xml:space="preserve">
          <source>How GCC calculates the size of an &lt;code&gt;asm&lt;/code&gt; block.</source>
          <target state="translated">GCC가 &lt;code&gt;asm&lt;/code&gt; 블록 의 크기를 계산하는 방법</target>
        </trans-unit>
        <trans-unit id="3f9040ed129a83c15932559ac6449ffd679075c3" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C specification.</source>
          <target state="translated">GCC가 ISO C 사양을 구현하는 방법</target>
        </trans-unit>
        <trans-unit id="f79f60bc97ae69f938083d6bd71809804c4831c5" translate="yes" xml:space="preserve">
          <source>How GCC implements the ISO C++ specification.</source>
          <target state="translated">GCC가 ISO C ++ 사양을 구현하는 방법</target>
        </trans-unit>
        <trans-unit id="62fab6a3b6832fb352405ce63e5b735618b3cef7" translate="yes" xml:space="preserve">
          <source>How To Get Help with GCC</source>
          <target state="translated">GCC에 대한 도움을받는 방법</target>
        </trans-unit>
        <trans-unit id="3e63c682de797883ae23802bc327411231cc31a8" translate="yes" xml:space="preserve">
          <source>How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90, C99 and C11 5.1.1.3).</source>
          <target state="translated">진단 식별 방법 (C90 3.7, C99 및 C11 3.10, C90, C99 및 C11 5.1.1.3).</target>
        </trans-unit>
        <trans-unit id="a123b2bec235da6dad3dc58f234c2574673ff822" translate="yes" xml:space="preserve">
          <source>How much optimization?</source>
          <target state="translated">얼마나 많은 최적화?</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">컴파일러는 얼마나 까다 롭습니까?</target>
        </trans-unit>
        <trans-unit id="1e2b472e6c532fe8af4932714956f74293f46083" translate="yes" xml:space="preserve">
          <source>How sequences in both forms of header names are mapped to headers or external source file names (C90 6.1.7, C99 and C11 6.4.7).</source>
          <target state="translated">두 가지 헤더 이름 형식의 시퀀스가 ​​헤더 또는 외부 소스 파일 이름에 매핑되는 방식 (C90 6.1.7, C99 및 C11 6.4.7).</target>
        </trans-unit>
        <trans-unit id="848f6ad2348dcee59d13596577066e141ef4d0ad" translate="yes" xml:space="preserve">
          <source>How the named source file is searched for in an included &amp;lsquo;</source>
          <target state="translated">포함 된 소스 파일에서 이름이 지정된 소스 파일을 검색하는 방법</target>
        </trans-unit>
        <trans-unit id="130378b21f742b32140465d74f388cb06f5001cf" translate="yes" xml:space="preserve">
          <source>How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants (C90 6.1.3.1, C99 and C11 6.4.4.2).</source>
          <target state="translated">특정 부동 상수 (C90 6.1.3.1, C99 및 C11 6.4.4.2)에 대해 가장 가까운 표현 가능한 값 또는 가장 가까운 표현 가능한 값에 바로 인접한 더 크거나 작은 표현 가능한 값이 선택되는 방식.</target>
        </trans-unit>
        <trans-unit id="606b9fa050c9f5a8165f3052560ba0c7d8b85fa0" translate="yes" xml:space="preserve">
          <source>How to contribute to testing and developing GCC.</source>
          <target state="translated">GCC 테스트 및 개발에 기여하는 방법.</target>
        </trans-unit>
        <trans-unit id="25170558e581aabef161dcb92e9a6de67ff5f448" translate="yes" xml:space="preserve">
          <source>How to help assure funding for free software.</source>
          <target state="translated">무료 소프트웨어에 대한 자금을 확보하는 방법.</target>
        </trans-unit>
        <trans-unit id="488dee81569b2dc10244c6b537b50c3cc87269e1" translate="yes" xml:space="preserve">
          <source>How to pass switches to sub-processes.</source>
          <target state="translated">하위 프로세스로 스위치를 전달하는 방법</target>
        </trans-unit>
        <trans-unit id="8c1e8efdd3392d7ad8138bb7223322e34b90c240" translate="yes" xml:space="preserve">
          <source>How to use gcov-dump.</source>
          <target state="translated">gcov-dump 사용 방법</target>
        </trans-unit>
        <trans-unit id="f7d8be53e9f165a3a11bb6dadca7af891ced365f" translate="yes" xml:space="preserve">
          <source>How to use gcov-tool.</source>
          <target state="translated">gcov-tool 사용 방법</target>
        </trans-unit>
        <trans-unit id="dde16118c9faa27675fdfe5cf0405564b55597c4" translate="yes" xml:space="preserve">
          <source>How to use gcov.</source>
          <target state="translated">gcov 사용 방법</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">이 매뉴얼을 복사하고 공유하는 방법.</target>
        </trans-unit>
        <trans-unit id="9e8e4dbcb1b211f7b5ab31c6c59b3a79ec59dd4f" translate="yes" xml:space="preserve">
          <source>How, why and where to report bugs.</source>
          <target state="translated">버그보고 방법, 이유 및 위치.</target>
        </trans-unit>
        <trans-unit id="0e3275b465f023e98f74ae720920ad438e50264c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; is not a valid cast because the union has no member of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;(union foo) FLT_MAX;&lt;/code&gt; 공용체에 &lt;code&gt;float&lt;/code&gt; 유형의 멤버가 없으므로 유효한 캐스트가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="9ea71fd7ca0b24f50560578a479dbd93975ddc25" translate="yes" xml:space="preserve">
          <source>However, if a library or main executable is supposed to throw or catch exceptions, you must link it using the G++ driver, or using the option</source>
          <target state="translated">그러나 라이브러리 또는 기본 실행 파일에서 예외를 발생 시키거나 잡아야하는 경우 G ++ 드라이버 또는 옵션을 사용하여 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="68ad5ea0590b2a354fce31707da021a7a4908783" translate="yes" xml:space="preserve">
          <source>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</source>
          <target state="translated">그러나 휘발성 저장소를 수정하지 않고 휘발성 저장소의 값을 사용하지 않으면 상황이 덜 분명합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3955f23a3aaffbcd48d8f54a3969fb80a9687bcd" translate="yes" xml:space="preserve">
          <source>However, the rationale here is that optimization of a nonempty loop cannot produce an empty one. This held for carefully written C compiled with less powerful optimizers but is not always the case for carefully written C++ or with more powerful optimizers. Thus GCC will remove operations from loops whenever it can determine those operations are not externally visible (apart from the time taken to execute them, of course). In case the loop can be proved to be finite, GCC will also remove the loop itself.</source>
          <target state="translated">그러나 여기서의 근거는 비어 있지 않은 루프를 최적화하면 빈 루프를 생성 할 수 없다는 것입니다. 이것은 덜 강력한 옵티 마이저로 컴파일 된 신중하게 작성된 C를위한 것이었지만, 신중하게 작성된 C ++ 또는보다 강력한 옵티 마이저를 사용하는 경우가 항상 아닙니다. 따라서 GCC는 외부에서 볼 수없는 작업을 확인할 수있을 때마다 루프에서 작업을 제거합니다 (물론 실행하는 데 걸리는 시간 제외). 루프가 유한 한 것으로 판명 될 경우 GCC는 루프 자체도 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9091ae1dd68a17c85dd2a3885c0a623d65f81f37" translate="yes" xml:space="preserve">
          <source>However, the use of &lt;code&gt;gcc&lt;/code&gt; does not add the C++ library. &lt;code&gt;g++&lt;/code&gt; is a program that calls GCC and automatically specifies linking against the C++ library. It treats &amp;lsquo;</source>
          <target state="translated">그러나 &lt;code&gt;gcc&lt;/code&gt; 를 사용해도 C ++ 라이브러리는 추가되지 않습니다. &lt;code&gt;g++&lt;/code&gt; 는 GCC를 호출하고 C ++ 라이브러리에 대한 링크를 자동으로 지정하는 프로그램입니다. 그것은 '</target>
        </trans-unit>
        <trans-unit id="25970c1ebc6bb12a4ef702c744afb1bf31667e71" translate="yes" xml:space="preserve">
          <source>However, these built-in functions may interact badly with some sophisticated features or other extensions of the language. It is, therefore, not recommended to use them outside very simple functions acting as mere forwarders for their arguments.</source>
          <target state="translated">그러나 이러한 내장 함수는 일부 정교한 기능 또는 언어의 다른 확장과 심하게 상호 작용할 수 있습니다. 따라서 인수를 전달하는 단순한 전달자 역할을하는 매우 간단한 함수 외부에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="5035ba1d98ecd402c64867de896608b2100e61c1" translate="yes" xml:space="preserve">
          <source>I register</source>
          <target state="translated">등록합니다</target>
        </trans-unit>
        <trans-unit id="0d25569c1c1c38b68b7adac7a2691f92a581fc48" translate="yes" xml:space="preserve">
          <source>IBM 970 Server CPU (ie, Apple G5).</source>
          <target state="translated">IBM 970 서버 CPU (즉, Apple G5).</target>
        </trans-unit>
        <trans-unit id="7ff989fdaf3c65fbe049204ca8d2d3b298dcd55a" translate="yes" xml:space="preserve">
          <source>IBM A2 64-bit Embedded CPU</source>
          <target state="translated">IBM A2 64 비트 임베디드 CPU</target>
        </trans-unit>
        <trans-unit id="7ebf129d97228e5e38b88ee3a2bf7cb0f28dd1fe" translate="yes" xml:space="preserve">
          <source>IBM POWER4 Server CPU.</source>
          <target state="translated">IBM POWER4 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="60fedee6d379816b90140e69a6cb94f8d8a8d0f3" translate="yes" xml:space="preserve">
          <source>IBM POWER5 Server CPU.</source>
          <target state="translated">IBM POWER5 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="d3878c6f9c9f4047fa51bbea5fff4ce5c35e5af1" translate="yes" xml:space="preserve">
          <source>IBM POWER5+ Server CPU.</source>
          <target state="translated">IBM POWER5 + 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="738e9fd792342dee79476051b27ac20d78ee9cda" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (Architected mode).</source>
          <target state="translated">IBM POWER6 서버 CPU (아키텍트 모드).</target>
        </trans-unit>
        <trans-unit id="a1d93b9cb2926fb05ec1f665abf51961f777a207" translate="yes" xml:space="preserve">
          <source>IBM POWER6 Server CPU (RAW mode).</source>
          <target state="translated">IBM POWER6 서버 CPU (RAW 모드).</target>
        </trans-unit>
        <trans-unit id="dbb9a20762f1a0c1106412992e6cc65c84bffc0f" translate="yes" xml:space="preserve">
          <source>IBM POWER7 Server CPU.</source>
          <target state="translated">IBM POWER7 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="a9a9c9a90077a9f8cbd67dc15b93836e1c987d49" translate="yes" xml:space="preserve">
          <source>IBM POWER8 Server CPU.</source>
          <target state="translated">IBM POWER8 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="c65507ef531be00847ba2a33296dc99803a18664" translate="yes" xml:space="preserve">
          <source>IBM POWER9 Server CPU.</source>
          <target state="translated">IBM POWER9 서버 CPU.</target>
        </trans-unit>
        <trans-unit id="5ad8015703e3cb16c9df6da3a8d9e97de8f9cd44" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 464 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 464 32 비트 임베디드 CPU.</target>
        </trans-unit>
        <trans-unit id="a548cb73c6f0d35ac7d906f9a02a9350c2eb6114" translate="yes" xml:space="preserve">
          <source>IBM PowerPC 476FP 32-bit Embedded CPU.</source>
          <target state="translated">IBM PowerPC 476FP 32 비트 임베디드 CPU.</target>
        </trans-unit>
        <trans-unit id="f3afdcbb4bda95413d989775a1a1f73e05c37f36" translate="yes" xml:space="preserve">
          <source>IBM PowerPC Cell Broadband Engine Architecture CPU.</source>
          <target state="translated">IBM PowerPC 셀 광대역 엔진 아키텍처 CPU.</target>
        </trans-unit>
        <trans-unit id="981e760991adb048080be646b9e1438966c192d0" translate="yes" xml:space="preserve">
          <source>IDT WinChip 2 CPU, dealt in same way as i486 with additional MMX and 3DNow! instruction set support.</source>
          <target state="translated">IDT WinChip 2 CPU는 i486과 동일한 방식으로 추가 MMX 및 3DNow를 처리합니다! 명령 세트 지원.</target>
        </trans-unit>
        <trans-unit id="e642e2d5acc8e35a06fd449f3d95c2b4f1486f5e" translate="yes" xml:space="preserve">
          <source>IDT WinChip C6 CPU, dealt in same way as i486 with additional MMX instruction set support.</source>
          <target state="translated">IDT WinChip C6 CPU는 i486과 동일한 방식으로 추가 MMX 명령어 세트 지원을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ec8566180afc9d36e3493dbd47d7e2d1e9ae9485" translate="yes" xml:space="preserve">
          <source>IPA-CP attempts to track all possible values and types passed to a function&amp;rsquo;s parameter in order to propagate them and perform devirtualization.</source>
          <target state="translated">IPA-CP는이를 전파하고 실용화하기 위해 함수의 매개 변수에 전달 된 가능한 모든 값과 유형을 추적하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f55eb535889fe2d3f53ef9f4b4a57453862d05ea" translate="yes" xml:space="preserve">
          <source>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed</source>
          <target state="translated">IPA-CP는 자체 복제 수익성 휴리스틱 스 점수를 계산하고 해당 복제 기회를 초과하는 점수로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="18432c18c0adba44c26c2a586731fb98a9d6d897" translate="yes" xml:space="preserve">
          <source>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.</source>
          <target state="translated">IPA-CP는 또한 집계에 전달 된 여러 스칼라 값을 전파 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6522b0ebe1c355ebd160511e9d28107d63eb735d" translate="yes" xml:space="preserve">
          <source>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to</source>
          <target state="translated">IPA-SRA는 누적 크기가 작거나 같은 경우에만 집계에 대한 포인터를 하나 이상의 새 매개 변수로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b5db770cbd54ca7a4734eeb3ccbfba61d7f93149" translate="yes" xml:space="preserve">
          <source>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see</source>
          <target state="translated">루프 불변량을 이동시키기위한 결정을 위해 루프에서보다 정확한 레지스터 압력을 평가하는 데 IRA를 사용할 수 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="3c1b099cab9d31b532499457a148771feb1ef850" translate="yes" xml:space="preserve">
          <source>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation.</source>
          <target state="translated">IRA는 기본적으로 지역 레지스터 할당을 사용합니다. 함수가이 매개 변수가 제공 한 수보다 많은 수의 루프를 포함하는 경우, 가장 자주 실행되는 최대 수의 루프 만이 지역 레지스터 할당을위한 영역을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="e1a35fb9a6e6329c3bd0cf9dd057013f4b706fa3" translate="yes" xml:space="preserve">
          <source>ISA 3.0 of the PowerPC added new atomic memory operation (amo) instructions. GCC provides support for these instructions in 64-bit environments. All of the functions are declared in the include file &lt;code&gt;amo.h&lt;/code&gt;.</source>
          <target state="translated">PowerPC의 ISA 3.0에는 새로운 원자 메모리 작업 (amo) 명령이 추가되었습니다. GCC는 64 비트 환경에서 이러한 명령어를 지원합니다. 모든 함수는 포함 파일 &lt;code&gt;amo.h&lt;/code&gt; 에 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cc00c6a2a5486718b4fd3642b097add2ed40af8" translate="yes" xml:space="preserve">
          <source>ISO C does not permit such a construct.</source>
          <target state="translated">ISO C는 그러한 구성을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fff460d30b4f47f8adc19f1a9e29c9166acd036b" translate="yes" xml:space="preserve">
          <source>ISO C requires a &amp;ldquo;diagnostic&amp;rdquo; message for certain kinds of invalid programs, but a warning is defined by GCC to count as a diagnostic. If GCC produces a warning but not an error, that is correct ISO C support. If testsuites call this &amp;ldquo;failure&amp;rdquo;, they should be run with the GCC option</source>
          <target state="translated">ISO C에는 특정 종류의 잘못된 프로그램에 대해 &quot;진단&quot;메시지가 필요하지만 GCC는 진단으로 간주하기 위해 경고를 정의합니다. GCC가 경고를 생성하지만 오류는 발생하지 않는 경우, 올바른 ISO C 지원입니다. 테스트 슈트가이를 &quot;실패&quot;라고 부르면 GCC 옵션으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="50648f88649c1f5dd7bf2cb4554ff39825b6b2bb" translate="yes" xml:space="preserve">
          <source>ISO C11, the 2011 revision of the ISO C standard. This standard is substantially completely supported, modulo bugs, floating-point issues (mainly but not entirely relating to optional C11 features from Annexes F and G) and the optional Annexes K (Bounds-checking interfaces) and L (Analyzability). The name &amp;lsquo;</source>
          <target state="translated">ISO C11, ISO C 표준의 2011 년 개정. 이 표준은 모듈로 버그, 부동 소수점 문제 (주로 별첨 F 및 G의 선택적 C11 기능과 관련되지는 않음) 및 별첨 K (경계 확인 인터페이스) 및 L (분석 가능성)과 실질적으로 완전히 지원됩니다. 이름 '</target>
        </trans-unit>
        <trans-unit id="a94be837facd76378c47084c4afa22ac2ddb78d6" translate="yes" xml:space="preserve">
          <source>ISO C17, the 2017 revision of the ISO C standard (published in 2018). This standard is same as C11 except for corrections of defects (all of which are also applied with</source>
          <target state="translated">ISO C 표준의 2017 개정판 ISO C17 (2018 년에 게시). 이 표준은 결함의 수정을 제외하고 C11과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="835b0fe47c2b2521e64ab3b466f790da05e1cf2c" translate="yes" xml:space="preserve">
          <source>ISO C90 as modified in amendment 1.</source>
          <target state="translated">개정 1에서 수정 된 ISO C90</target>
        </trans-unit>
        <trans-unit id="dd3ae16769f5e30cd0e25b181c241be07701badf" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++ allow declarations and code to be freely mixed within compound statements. As an extension, GNU C also allows this in C90 mode. For example, you could do:</source>
          <target state="translated">ISO C99 및 ISO C ++을 사용하면 복합 명령문 내에서 선언과 코드를 자유롭게 혼합 할 수 있습니다. 확장으로 GNU C는 C90 모드에서도이를 허용합니다. 예를 들어 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd9df382c7a9e275bf54293954eb3cea3a9394da" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++11 support data types for integers that are at least 64 bits wide, and as an extension GCC supports them in C90 and C++98 modes. Simply write &lt;code&gt;long long int&lt;/code&gt; for a signed integer, or &lt;code&gt;unsigned long long int&lt;/code&gt; for an unsigned integer. To make an integer constant of type &lt;code&gt;long long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">ISO C99 및 ISO C ++ 11은 최소 64 비트 너비의 정수에 대한 데이터 유형을 지원하며 확장으로 GCC는 C90 및 C ++ 98 모드에서 지원합니다. 간단하게 쓰기 &lt;code&gt;long long int&lt;/code&gt; 부호있는 정수, 또는에 대한 &lt;code&gt;unsigned long long int&lt;/code&gt; 부호없는 정수. &lt;code&gt;long long int&lt;/code&gt; 유형의 정수 상수를 만들려면 접미사 '</target>
        </trans-unit>
        <trans-unit id="8b83453de486a892e712e76d4673bb12ab84c153" translate="yes" xml:space="preserve">
          <source>ISO C99 and ISO C++17 support floating-point numbers written not only in the usual decimal notation, such as &lt;code&gt;1.55e1&lt;/code&gt;, but also numbers such as &lt;code&gt;0x1.fp3&lt;/code&gt; written in hexadecimal format. As a GNU extension, GCC supports this in C90 mode (except in some cases when strictly conforming) and in C++98, C++11 and C++14 modes. In that format the &amp;lsquo;</source>
          <target state="translated">ISO C99 및 ISO C ++ 17은 &lt;code&gt;1.55e1&lt;/code&gt; 과 같은 일반적인 10 진수 표기법 뿐만 아니라 16 진수 형식으로 작성된 &lt;code&gt;0x1.fp3&lt;/code&gt; 과 같은 숫자도 지원 합니다. GNU 확장으로서 GCC는 C90 모드 (엄격하게 준수하는 경우 제외)와 C ++ 98, C ++ 11 및 C ++ 14 모드에서이를 지원합니다. 그 형식으로 '</target>
        </trans-unit>
        <trans-unit id="f45bb32dfebc99db4671808e81b5e06e1a3ae3f3" translate="yes" xml:space="preserve">
          <source>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword &lt;code&gt;_Complex&lt;/code&gt;. As an extension, the older GNU keyword &lt;code&gt;__complex__&lt;/code&gt; is also supported.</source>
          <target state="translated">ISO C99는 복잡한 부동 데이터 유형을 지원하며 확장으로서 GCC는 C90 모드 및 C ++에서이를 지원합니다. GCC는 ISO C99의 일부가 아닌 복합 정수 데이터 유형도 지원합니다. 키워드 &lt;code&gt;_Complex&lt;/code&gt; 를 사용하여 복합 유형을 선언 할 수 있습니다 . 확장으로 이전 GNU 키워드 &lt;code&gt;__complex__&lt;/code&gt; 도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="84c793c819960394587c5cc12a67f14b20b38119" translate="yes" xml:space="preserve">
          <source>ISO C99. This standard is substantially completely supported, modulo bugs and floating-point issues (mainly but not entirely relating to optional C99 features from Annexes F and G). See &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for more information. The names &amp;lsquo;</source>
          <target state="translated">ISO C99. 이 표준은 실질적으로 완전히 지원되는 모듈로 버그 및 부동 소수점 문제 (주로 부록 A와 G의 선택적 C99 기능과는 관련이 없음)입니다. 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; 을 참조하십시오. 이름 '</target>
        </trans-unit>
        <trans-unit id="b19dfb0d72b128922f94144b3b4ef7616d4f13d5" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3 defines new permissible values for &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; that indicate that operations and constants with a semantic type that is an interchange or extended format should be evaluated to the precision and range of that type. These new values are a superset of those permitted under C99/C11, which does not specify the meaning of other positive values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;. As such, code conforming to C11 may not have been written expecting the possibility of the new values.</source>
          <target state="translated">용 ISO / IEC 18661-3 TS 정의 새로운 허용치 &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 인터체인지 또는 확장 형식 시맨틱 타입 및 그 동작을 나타내는 상수 유형의 정밀도 범위로 평가되어야한다. 이 새로운 값은 C99 / C11에서 허용되는 값의 상위 집합으로, &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 의 다른 양수 값의 의미를 지정하지 않습니다 . 따라서 C11을 따르는 코드는 새로운 값의 가능성을 예상하여 작성되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0704127df0a170eee2b3d8c1f35e3e35e1e33e3c" translate="yes" xml:space="preserve">
          <source>ISO/IEC TS 18661-3:2015 defines C support for additional floating types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, and GCC supports these type names; the set of types supported depends on the target architecture. These types are not supported when compiling C++. Constants with these types use suffixes &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; or &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;. These type names can be used together with &lt;code&gt;_Complex&lt;/code&gt; to declare complex types.</source>
          <target state="translated">ISO / IEC TS 18661-3 : 2015는 추가 부동 유형 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 대한 C 지원을 정의 하며 GCC는 이러한 유형 이름을 지원합니다. 지원되는 유형 세트는 대상 아키텍처에 따라 다릅니다. C ++를 컴파일 할 때는 이러한 유형이 지원되지 않습니다. 이러한 유형의 상수는 접미사 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;f&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 또는 &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 합니다. 이 형식 이름을 &lt;code&gt;_Complex&lt;/code&gt; 와 함께 사용하여 복잡한 형식을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beeb64c7eeaed20d36a340ce018bf60cf4a13bf4" translate="yes" xml:space="preserve">
          <source>Ideally, a portable program should always use &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; when it depends on the signedness of an object. But many programs have been written to use plain &lt;code&gt;char&lt;/code&gt; and expect it to be signed, or expect it to be unsigned, depending on the machines they were written for. This option, and its inverse, let you make such a program work with the opposite default.</source>
          <target state="translated">이상적으로, 휴대용 프로그램은 오브젝트의 서명에 의존 할 때 항상 &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 사용해야 합니다. 그러나 많은 프로그램은 일반 &lt;code&gt;char&lt;/code&gt; 를 사용하도록 작성되었으며 서명 된 시스템에 따라 서명되거나 서명되지 않을 것으로 예상됩니다. 이 옵션과 그 반대의 경우 이러한 프로그램이 반대 기본값으로 작동하게합니다.</target>
        </trans-unit>
        <trans-unit id="ab2f71fc75bf24fc42ea67b7b9de3bc2377f68da" translate="yes" xml:space="preserve">
          <source>Identical like the above one, but the location of the function in the &lt;code&gt;jli&lt;/code&gt; table is known and given as an attribute parameter.</source>
          <target state="translated">위와 동일하지만 &lt;code&gt;jli&lt;/code&gt; 테이블 에서 함수의 위치 는 속성 매개 변수로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="06758e7fffb077a661e9d5cfb54c15702892df80" translate="yes" xml:space="preserve">
          <source>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels.</source>
          <target state="translated">식별자가 레이블과 충돌합니다. 기존 C에는 레이블에 대한 별도의 네임 스페이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a6386123e656c29d067b76006564d3382accf62" translate="yes" xml:space="preserve">
          <source>Identify the versions of each tool used by the compiler, in a &lt;code&gt;.ident&lt;/code&gt; assembler directive in the output.</source>
          <target state="translated">출력 의 &lt;code&gt;.ident&lt;/code&gt; 어셈블러 지시문에서 컴파일러가 사용하는 각 도구의 버전을 식별하십시오 .</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="b94b85388613ff812132cfe4fbfdcb534fff787e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfab80fece1ea34402901dd4726bddf817b9cff" translate="yes" xml:space="preserve">
          <source>If 3DNow! extensions are enabled, &lt;code&gt;V2SF&lt;/code&gt; is used as a mode for a vector of two 32-bit floating-point values.</source>
          <target state="translated">3DNow! 확장이 활성화되면 &lt;code&gt;V2SF&lt;/code&gt; 는 두 개의 32 비트 부동 소수점 값으로 구성된 벡터의 모드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23030af34d65c4d0b445c2e6bf477bf6b1f5c071" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%*&lt;/code&gt; appears as the last part of a spec sequence then a space is added after the end of the last substitution. If there is more text in the sequence, however, then a space is not generated. This allows the &lt;code&gt;%*&lt;/code&gt; substitution to be used as part of a larger string. For example, a spec string like this:</source>
          <target state="translated">경우 &lt;code&gt;%*&lt;/code&gt; 스펙 시퀀스의 마지막 부분으로 나타난다는 공간 마지막 교체 종료 후에 첨가된다. 그러나 시퀀스에 더 많은 텍스트가 있으면 공백이 생성되지 않습니다. 이를 통해 &lt;code&gt;%*&lt;/code&gt; 대체를 더 큰 문자열의 일부로 사용할 수 있습니다. 예를 들어 다음과 같은 사양 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="539ea1d3aa99e1f5670827ce3f6d748af1cde993" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) is not implemented or returns &lt;code&gt;NO&lt;/code&gt;, the runtime then tries the forwarding hook.</source>
          <target state="translated">경우 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (또는 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ) 구현하지 않거나 반환 &lt;code&gt;NO&lt;/code&gt; , 런타임은 전달 훅을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3f8dd7c3c9fed3437a52aa9c603d614b32cf2d92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; were passed, the above would trigger a warning, but this time because of the lack of bounds checking.</source>
          <target state="translated">경우 &lt;code&gt;-Walloca-larger-than=500&lt;/code&gt; 전달 된, 위의 경고하지만, 때문에 확인 경계의 부족이 시간을 발생하게됩니다.</target>
        </trans-unit>
        <trans-unit id="ca79581e5d9acfa9f2b20401cffd3a6d08f404f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;attribute-specifier-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;D1&lt;/code&gt; 은 형태 갖는다 &lt;code&gt;( &lt;var&gt;attribute-specifier-list&lt;/var&gt; D )&lt;/code&gt; , 상기 선언 &lt;code&gt;T D&lt;/code&gt; 지정은 유형 &quot; &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; 은&quot; &lt;var&gt;ident&lt;/var&gt; , 후 &lt;code&gt;T D1&lt;/code&gt; 은 타입 &quot;지정 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;attribute-specifier-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; 에 대한 &quot; &lt;var&gt;ident&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="bce12bf3e38781beccd90d07d87af63b34ed169d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D1&lt;/code&gt; has the form &lt;code&gt;*
&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt;, and the declaration &lt;code&gt;T D&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;, then &lt;code&gt;T D1&lt;/code&gt; specifies the type &amp;ldquo;&lt;var&gt;derived-declarator-type-list&lt;/var&gt;&lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; pointer to &lt;var&gt;Type&lt;/var&gt;&amp;rdquo; for &lt;var&gt;ident&lt;/var&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;D1&lt;/code&gt; 은 형태 갖는다 &lt;code&gt;* &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; D&lt;/code&gt; 및 선언 &lt;code&gt;T D&lt;/code&gt; 지정 유형 ' &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;Type&lt;/var&gt; 은 &quot; &lt;var&gt;ident&lt;/var&gt; , 후 &lt;code&gt;T D1&lt;/code&gt; 이 &quot;유형을 지정 &lt;var&gt;derived-declarator-type-list&lt;/var&gt; &lt;var&gt;type-qualifier-and-attribute-specifier-list&lt;/var&gt; &lt;var&gt;ident&lt;/var&gt; 에 대한 &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="fdf6957ed3c287429ab808fa75095697e4d021d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; has been set for a given decl, use that in the dump instead of &lt;code&gt;DECL_NAME&lt;/code&gt;. Its primary use is ease of use working backward from mangled names in the assembly file.</source>
          <target state="translated">주어진 decl에 대해 &lt;code&gt;DECL_ASSEMBLER_NAME&lt;/code&gt; 이 설정된 경우 DECL_NAME 대신 덤프에서이를 사용 &lt;code&gt;DECL_NAME&lt;/code&gt; . 주요 용도는 어셈블리 파일의 맹 글링 된 이름에서 거꾸로 사용하기 쉽다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="647ff2c6b0ee66be47ceb0fe277c3fe135fc84e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is not set, GCC attempts to figure out an appropriate prefix to use based on the pathname it is invoked with.</source>
          <target state="translated">&lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 가 설정되지 않은 경우 GCC는 호출 된 경로 이름을 기반으로 사용할 적절한 접두사를 파악하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7fc3d06e6177481bf26c022c74076e71f4e1f421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.</source>
          <target state="translated">경우 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 이 설정되어, 상기 컴파일러에 의해 실행되는 서브 프로그램의 이름에 사용하는 프리픽스를 지정한다. 이 접두사가 서브 프로그램의 이름과 결합 될 때 슬래시가 추가되지 않지만 원하는 경우 슬래시로 끝나는 접 두부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec8a7933acf37b1c0fdc778b779b3f382d54a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LANG&lt;/code&gt; is not defined, or if it has some other value, then the compiler uses &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbtowc&lt;/code&gt; as defined by the default locale to recognize and translate multibyte characters.</source>
          <target state="translated">경우 &lt;code&gt;LANG&lt;/code&gt; 은 정의하거나 다른 값이있는 경우, 컴파일러의 사용은되지 &lt;code&gt;mblen&lt;/code&gt; 을 하고 &lt;code&gt;mbtowc&lt;/code&gt; 는 인식하고 멀티 바이트 문자를 번역 기본 로케일에 의해 정의 된 바와 같다.</target>
        </trans-unit>
        <trans-unit id="e1943099aece965452d744a5c53ffc07f2bc9f16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;X&lt;/code&gt;; else if &lt;code&gt;T&lt;/code&gt; is given to GCC, substitutes &lt;code&gt;Y&lt;/code&gt;; else substitutes &lt;code&gt;D&lt;/code&gt;. There can be as many clauses as you need. This may be combined with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; as needed.</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 는 GCC에 주어, 대체 &lt;code&gt;X&lt;/code&gt; 를 ; 그렇지 않으면 &lt;code&gt;T&lt;/code&gt; 가 GCC에 주어지면 &lt;code&gt;Y&lt;/code&gt; 를 대체하고 ; 그렇지 않으면 &lt;code&gt;D&lt;/code&gt; 를 대체 합니다. 필요한만큼 절이있을 수 있습니다. 이와 결합 될 수 있습니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;,&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 필요에 따라.</target>
        </trans-unit>
        <trans-unit id="404ec67951a627fb06995708ad6a0e24dc041fa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TMPDIR&lt;/code&gt; is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.</source>
          <target state="translated">경우 &lt;code&gt;TMPDIR&lt;/code&gt; 이 설정되어, 그것은 임시 파일에 사용할 디렉토리를 지정합니다. GCC는 임시 파일을 사용하여 다음 단계에 대한 입력으로 사용되는 한 컴파일 단계의 출력 (예 : 컴파일러에 대한 입력 인 전 처리기의 출력)을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="1953caa75083ee28850ca171a34b26fd4eb8373f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a default constructor that is known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__has_trivial_constructor (type)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 그 특성은 &lt;code&gt;true&lt;/code&gt; 경우, 다른 &lt;code&gt;type&lt;/code&gt; 예외를 throw하지 알려진 기본 생성자와 이력서 클래스 또는 조합 유형 (또는 그 배열) 다음 특성이있다 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="763c1f95adec0e6f2c3d89c3c9b77ea1bcae352d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy constructors that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__has_trivial_copy (type)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 그 특성은 &lt;code&gt;true&lt;/code&gt; 다른 경우, &lt;code&gt;type&lt;/code&gt; 다음 특성이 예외가 발생하지 않도록 알려져있다 복사 생성자와 이력서 자격 클래스 또는 조합 유형입니다 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="348b274e4746ccb17d0ad8ccc31192a6601178b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_class (type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is considered empty if and only if: &lt;code&gt;type&lt;/code&gt; has no non-static data members, or all non-static data members, if any, are bit-fields of length 0, and &lt;code&gt;type&lt;/code&gt; has no virtual members, and &lt;code&gt;type&lt;/code&gt; has no virtual base classes, and &lt;code&gt;type&lt;/code&gt; has no base classes &lt;code&gt;base_type&lt;/code&gt; for which &lt;code&gt;__is_empty (base_type)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__is_class (type)&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 그 특성은 &lt;code&gt;false&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 경우에만, 빈 간주됩니다 &lt;code&gt;type&lt;/code&gt; 더 비 정적 데이터 멤버, 또는 모든 비 정적 데이터 멤버 (있는 경우)이다 길이 0의 비트 필드가 없으며, &lt;code&gt;type&lt;/code&gt; 어떤 가상 구성원이 없으며, &lt;code&gt;type&lt;/code&gt; 어떤 가상이 없습니다 베이스 클래스 및 &lt;code&gt;type&lt;/code&gt; 에는베이스 클래스가없는 &lt;code&gt;base_type&lt;/code&gt; 하는 &lt;code&gt;__is_empty (base_type)&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fb256b452a67db2fcf29b7d6c9eb3c3b57425ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type (or array thereof) with a trivial destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__is_pod (type)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 기준 형 다음 특성이있다 &lt;code&gt;true&lt;/code&gt; 경우, 다른 &lt;code&gt;type&lt;/code&gt; 사소한 소멸자와 CV 클래스 또는 유니온 타입 (또는 이들의 배열)이다 ([class.dtor]) 다음 특성이 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1bf9587539b51be90adc4a1e785e99e947f0059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt; is a reference type then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv class or union type with a trivial copy constructor ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__is_pod (type)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 참조 유형이 다음 특성이있다 &lt;code&gt;true&lt;/code&gt; 경우, 다른 &lt;code&gt;type&lt;/code&gt; 사소한 복사 생성자와 CV 클래스 또는 조합 형태이다 ([class.copy])은 다음의 특성은 &lt;code&gt;true&lt;/code&gt; 이이고, 다른 &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f38bb6a2ade7b8693787a1194261c7451943ac5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type (or array thereof) with a trivial default constructor ([class.ctor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;__is_pod (type)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 그 특성은 &lt;code&gt;true&lt;/code&gt; 경우, 다른 &lt;code&gt;type&lt;/code&gt; CV 수식 사소한 기본 생성자 클래스 또는 유니온 타입 (또는 이들의 배열) ([class.ctor]) A는 다음 특성이있다 &lt;code&gt;true&lt;/code&gt; 는 다른, 이다 &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d19955ce7ffa6060ce61b406573fd7fa063dda62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base_type&lt;/code&gt; is a base class of &lt;code&gt;derived_type&lt;/code&gt; ([class.derived]) then the trait is &lt;code&gt;true&lt;/code&gt;, otherwise it is &lt;code&gt;false&lt;/code&gt;. Top-level cv-qualifications of &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are ignored. For the purposes of this trait, a class type is considered is own base. Requires: if &lt;code&gt;__is_class (base_type)&lt;/code&gt; and &lt;code&gt;__is_class (derived_type)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;base_type&lt;/code&gt; and &lt;code&gt;derived_type&lt;/code&gt; are not the same type (disregarding cv-qualifiers), &lt;code&gt;derived_type&lt;/code&gt; shall be a complete type. A diagnostic is produced if this requirement is not met.</source>
          <target state="translated">경우 &lt;code&gt;base_type&lt;/code&gt; 의베이스 클래스 &lt;code&gt;derived_type&lt;/code&gt; 는 다음 특성이다 ([이 class.derived]) &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면이고, &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;base_type&lt;/code&gt; 및 &lt;code&gt;derived_type&lt;/code&gt; 의 최상위 cv 규정 은 무시됩니다. 이 특성의 목적을 위해 클래스 유형은 자체 기반으로 간주됩니다. 요구 사항 : 경우 &lt;code&gt;__is_class (base_type)&lt;/code&gt; 와 &lt;code&gt;__is_class (derived_type)&lt;/code&gt; 가 있는 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;base_type&lt;/code&gt; 및 &lt;code&gt;derived_type&lt;/code&gt; 은 (CV-규정을 무시) 동일한 유형하지 않습니다, &lt;code&gt;derived_type&lt;/code&gt; 은 완전한 유형이어야한다. 이 요구 사항이 충족되지 않으면 진단이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad52c7e701f6b6ac16fc011e5c3a814b836cace" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;objc_msg_lookup()&lt;/code&gt; does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method.</source>
          <target state="translated">경우 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 적합한 메소드 구현을 찾을 수없는 수신기가 필요한 메소드를 구현하지 않기 때문에, 그것은 클래스가 동적으로 메소드를 등록 할 수 있는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="de0324724a4ecec17009f5551872ea4de764d9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;packed&lt;/code&gt; is used on a structure, or if bit-fields are used, it may be that the Microsoft ABI lays out the structure differently than the way GCC normally does. Particularly when moving packed data between functions compiled with GCC and the native Microsoft compiler (either via function call or as data in a file), it may be necessary to access either format.</source>
          <target state="translated">경우 &lt;code&gt;packed&lt;/code&gt; 구조에 사용되는 비트 필드를 사용하는 경우, 또는, 그것은 마이크로 소프트 ABI는 GCC가 일반적으로 수행하는 방식과 다르게 구조를 낳는 것을 할 수있다. 특히 GCC로 컴파일 된 함수와 네이티브 Microsoft 컴파일러간에 (함수 호출을 통해 또는 파일의 데이터로) 묶음 데이터를 이동할 때 두 형식 중 하나에 액세스해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7ba7dbf5e57d92bfe72102ff6203af39a12a8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; is omitted, the signedness of the vector type is the default signedness of the base type. The default varies depending on the operating system, so a portable program should always specify the signedness.</source>
          <target state="translated">경우 &lt;code&gt;signed&lt;/code&gt; 또는 &lt;code&gt;unsigned&lt;/code&gt; 생략, 벡터 형의 부호의는 기본 유형의 기본 부호의입니다. 기본값은 운영 체제에 따라 다르므로 휴대용 프로그램은 항상 서명을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffd246c0a3fbb949c1fa9d8cc2260944e77a3bfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;- qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__is_pod (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with a trivial copy assignment ([class.copy]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 입니다 &lt;code&gt;const&lt;/code&gt; 를 - 자격 또는 참조 형 다음 특성은 &lt;code&gt;false&lt;/code&gt; . 그렇지 않은 경우 &lt;code&gt;__is_pod (type)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 특성은 &lt;code&gt;true&lt;/code&gt; 이고, &lt;code&gt;type&lt;/code&gt; 이 사소한 사본 할당 ([class.copy])이있는 cv-qualified 클래스 또는 공용체 유형 인 경우 특성이 &lt;code&gt;true&lt;/code&gt; 이고 그렇지 않은 경우 &lt;code&gt;false&lt;/code&gt; 입니다. 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="283cf2672e55770fc0551d9647cca120a4bb630b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;-qualified or is a reference type then the trait is &lt;code&gt;false&lt;/code&gt;. Otherwise if &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the trait is &lt;code&gt;true&lt;/code&gt;, else if &lt;code&gt;type&lt;/code&gt; is a cv-qualified class or union type with copy assignment operators that are known not to throw an exception then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 있다 &lt;code&gt;const&lt;/code&gt; 를 다음 참조 형식을 restrict로 또는 인 특성은 &lt;code&gt;false&lt;/code&gt; . 그렇지 않은 경우 &lt;code&gt;__has_trivial_assign (type)&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 특성이 &lt;code&gt;true&lt;/code&gt; 이고, &lt;code&gt;type&lt;/code&gt; 이 예외를 발생시키지 않는 것으로 알려진 복사 할당 연산자가있는 cv-qualified 클래스 또는 공용체 유형 인 경우 특성이 &lt;code&gt;true&lt;/code&gt; 이면 그렇지 않은 경우 &lt;code&gt;false&lt;/code&gt; 입니다. 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="63c11c8bb0212d553ee20398c564d16b6ec7e69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a class type with a virtual destructor ([class.dtor]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 가상 소멸자 ([class.dtor])와 클래스 타입 다음 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c2e0cd65d0655c5ce8c12d2d2d4a097d810e389" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv POD type ([basic.types]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 이력서 POD 타입 ([basic.types가])은 다음의 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지이고, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="723863e0b5a8fce8c661ff18582b201e84983629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv enumeration type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 이력서 열거 타입 ([basic.compound가])이 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지이고, &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7975a53cee041123902e4671962591f8c2cbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 이력서 조합 유형 ([basic.compound가])이 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89ab4b13f03f8e9b77ccbec6378e569d290932f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a cv-qualified class type, and not a union type ([basic.compound]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 이력서 수식 클래스 유형 및 아닌 노동 조합 유형 ([basic.compound]) 형질은 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c08c113aac15208c2698077a3dc6d2ee08e364" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a literal type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 리터럴 유형 ([basic.types]가) 인 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지이고, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="44c42d9c3a648a4586d6d80ed2afeb43acc1f98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a polymorphic class ([class.virtual]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 다형성 클래스 ([class.virtual]) 다음 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지이고, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="902c4582059f6f78c8c47e8d4db16bfd414011e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a standard-layout type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 표준 레이아웃 유형 ([basic.types가]) 인 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c53c71f1f92604372ad3a40e885b3e290ad04715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is a trivial type ([basic.types]) the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 사소한 유형 ([basic.types]가) 인 특성은 &lt;code&gt;true&lt;/code&gt; 그렇지이고, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ffe6e21bc41957ab0a00219c12663528f239f642" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an abstract class ([class.abstract]) then the trait is &lt;code&gt;true&lt;/code&gt;, else it is &lt;code&gt;false&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 추상 클래스입니다 ([class.abstract]) 다음 특징은 &lt;code&gt;true&lt;/code&gt; 그렇지는, &lt;code&gt;false&lt;/code&gt; . 요구 사항 : &lt;code&gt;type&lt;/code&gt; 은 완전한 유형 이거나, cv-qualified 일 수있는 &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 범위의 배열 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="911911ebb73f24baa4568a362dcf6545a5e8bd9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;0xf&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th bit of &lt;var&gt;val&lt;/var&gt; is returned unaltered.</source>
          <target state="translated">&lt;var&gt;X&lt;/var&gt; 가 &lt;code&gt;0xf&lt;/code&gt; 인 경우 &lt;var&gt;val&lt;/var&gt; 의 &lt;var&gt;n&lt;/var&gt; 번째 비트는 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="529d14d76239ac927a58af9240682db818e156fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;desired&lt;/var&gt; is written into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt; is returned and memory is affected according to the memory order specified by &lt;var&gt;success_memorder&lt;/var&gt;. There are no restrictions on what memory order can be used here.</source>
          <target state="translated">경우 &lt;var&gt;desired&lt;/var&gt; 에 기입 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 다음 &lt;code&gt;true&lt;/code&gt; 반송되고 메모리에 의해 지정된 메모리 순서에 따라 영향 &lt;var&gt;success_memorder&lt;/var&gt; . 여기서 사용할 수있는 메모리 순서에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="90eefc597dfd05335fdc76d585991dd479f5699e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device&lt;/var&gt; is not a device but only a core architecture like &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;device&lt;/var&gt; 장치이지만 '와 같은 단지 코어 아키텍처 아니다</target>
        </trans-unit>
        <trans-unit id="37aede7b841b819868fc3f607fc7588d32233439" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exp1&lt;/var&gt; is returned, the return type is the same as &lt;var&gt;exp1&lt;/var&gt;&amp;rsquo;s type. Similarly, if &lt;var&gt;exp2&lt;/var&gt; is returned, its return type is the same as &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;exp1&lt;/var&gt; 반환, 반환 형식은 동일 &lt;var&gt;exp1&lt;/var&gt; 의 유형입니다. 마찬가지로 &lt;var&gt;exp2&lt;/var&gt; 가 리턴되면 리턴 유형은 &lt;var&gt;exp2&lt;/var&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="43726f9389a16cd86ccc87693856924d076a1cd7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is</source>
          <target state="translated">경우 &lt;var&gt;file&lt;/var&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="5b94a494d8a93062d1fb2f08cf22419880d46ae7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;m&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;m&lt;/var&gt; 가 에 지정되지 않은 경우 기본값 &lt;var&gt;n&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="96e30c03c390fa37f95beff815a87bdc5f2296a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default which is very likely to be &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;n&lt;/var&gt; 을 지정 제로되어 있지 않으며, 가능성 '이 될 것입니다 기계에 의존하는 기본값을 사용</target>
        </trans-unit>
        <trans-unit id="4f4c9abfe6823ac3226b1f95cfb68ae207a767d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default.</source>
          <target state="translated">경우 &lt;var&gt;n&lt;/var&gt; 을 지정 제로되어 있지 않으며, 기계에 의존하는 디폴트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="edea744d98224ea825d53a93f917e0198d6b4e4e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is not specified or is zero, use a machine-dependent default. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">경우 &lt;var&gt;n&lt;/var&gt; 을 지정 제로되어 있지 않으며, 기계에 의존하는 디폴트를 사용합니다. 허용되는 최대 &lt;var&gt;n&lt;/var&gt; 옵션 값은 65536입니다.</target>
        </trans-unit>
        <trans-unit id="759dfcc7101124f098c766f1c7cd00bcc6b949db" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;options&lt;/var&gt; is omitted, it defaults to &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;options&lt;/var&gt; 생략에 디폴트 '</target>
        </trans-unit>
        <trans-unit id="4a58d0d422304ea0f155ce08523224eb514fe6b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;path&lt;/var&gt; is specified, GCC looks at the &lt;var&gt;path&lt;/var&gt; to find the profile feedback data files. See</source>
          <target state="translated">경우 &lt;var&gt;path&lt;/var&gt; 지정되어, 상기 GCC의 외모 &lt;var&gt;path&lt;/var&gt; 프로파일 피드백 데이터 파일을 찾을 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="424b9b0e5144f1c216be7ac998c97fd4f7a0b3fa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;type&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">만약 &lt;var&gt;type&lt;/var&gt; '입니다</target>
        </trans-unit>
        <trans-unit id="a48f8bd6ddf94d7b46204690dc61b7e1c17bca21" translate="yes" xml:space="preserve">
          <source>If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.</source>
          <target state="translated">GCC가 지정된 접두사를 사용하여 서브 프로그램을 찾을 수 없으면 서브 프로그램의 일반적인 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="49e516aa2892d9e488e19e4de501aef3c975c28a" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_is&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCC가 2.23 이전에 GLIBC를 사용하도록 구성된 경우 내장 함수 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 는 항상 0을 리턴하고 컴파일러는 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="009bc2728024c27e5f3a38c77a771a92e70da809" translate="yes" xml:space="preserve">
          <source>If GCC was configured to use a GLIBC before 2.23, the built-in function &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; always returns a 0 and the compiler issues a warning.</source>
          <target state="translated">GCC가 2.23 이전에 GLIBC를 사용하도록 구성된 경우 내장 함수 &lt;code&gt;__builtin_cpu_suports&lt;/code&gt; 는 항상 0을 리턴하고 컴파일러는 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="3d3dbe293db43d1939fa63d41a62ea0fb70dc054" translate="yes" xml:space="preserve">
          <source>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</source>
          <target state="translated">LTO가 서로 다른 변환 단위로 호환되지 않는 유형으로 선언 된 C 연결이있는 객체를 발견하면 (ISO C99 6.2.7에 따라 정의되지 않은 동작) 치명적이지 않은 진단이 발행 될 수 있습니다. 동작은 여전히 ​​런타임에 정의되지 않습니다. 다른 언어에서도 비슷한 진단이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8064195381cae5ba1afd9e1080f901756518ee59" translate="yes" xml:space="preserve">
          <source>If SSE extensions are enabled, &lt;code&gt;V4SF&lt;/code&gt; is used for a vector of four 32-bit floating-point values. Some instructions use a vector of four 32-bit integers, these use &lt;code&gt;V4SI&lt;/code&gt;. Finally, some instructions operate on an entire vector register, interpreting it as a 128-bit integer, these use mode &lt;code&gt;TI&lt;/code&gt;.</source>
          <target state="translated">SSE 확장이 사용 가능한 경우 &lt;code&gt;V4SF&lt;/code&gt; 는 4 개의 32 비트 부동 소수점 값으로 구성된 벡터에 사용됩니다. 일부 명령어는 4 개의 32 비트 정수로 구성된 벡터를 사용 &lt;code&gt;V4SI&lt;/code&gt; 사용 합니다 . 마지막으로, 일부 명령어는 전체 벡터 레지스터에서 작동하며이를 128 비트 정수 (이들 모드 &lt;code&gt;TI&lt;/code&gt; ) 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="c8aa3d549316941fe06d6dfd92787397e613a82c" translate="yes" xml:space="preserve">
          <source>If X is in the range 0&amp;hellip;7, then the &lt;var&gt;n&lt;/var&gt;-th result bit is set to the &lt;var&gt;X&lt;/var&gt;-th bit of &lt;var&gt;bits&lt;/var&gt;</source>
          <target state="translated">X가 0&amp;hellip; 7 범위에 있으면, &lt;var&gt;n&lt;/var&gt; 번째 결과 비트는 &lt;var&gt;X&lt;/var&gt; 번째 비트 &lt;var&gt;bits&lt;/var&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4795ba768ec1950f8dcd780b40f59791bb2c3400" translate="yes" xml:space="preserve">
          <source>If X is in the range 8&amp;hellip;&lt;code&gt;0xe&lt;/code&gt;, then the &lt;var&gt;n&lt;/var&gt;-th result bit is undefined.</source>
          <target state="translated">X의 범위는 8 ... 인 경우 &lt;code&gt;0xe&lt;/code&gt; 후, &lt;var&gt;n&lt;/var&gt; 번째의 결과 비트들은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="77a0a28430753763f9053f0aed3455f25006e137" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;named address space&lt;/a&gt; other than generic or &lt;code&gt;__flash&lt;/code&gt; is used, then &lt;code&gt;RAMPZ&lt;/code&gt; is set as needed before the operation.</source>
          <target state="translated">generic 또는 &lt;code&gt;__flash&lt;/code&gt; 이외 의 &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;명명 된 주소 공간을&lt;/a&gt; 사용 하는 경우 작업 전에 &lt;code&gt;RAMPZ&lt;/code&gt; 가 필요에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e78a838d8422ed3d9e1991db7c391d81f3fd283d" translate="yes" xml:space="preserve">
          <source>If a class is declared to implement a protocol, a warning is issued for every method in the protocol that is not implemented by the class. The default behavior is to issue a warning for every method not explicitly implemented in the class, even if a method implementation is inherited from the superclass. If you use the</source>
          <target state="translated">클래스가 프로토콜을 구현하도록 선언 된 경우 클래스에 의해 구현되지 않은 프로토콜의 모든 메소드에 대해 경고가 발행됩니다. 기본 동작은 메소드 구현이 수퍼 클래스에서 상속 된 경우에도 클래스에서 명시 적으로 구현되지 않은 모든 메소드에 대해 경고를 발행하는 것입니다. 당신이 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="29f23802437b44fdcdb64561f47637459cfd3577" translate="yes" xml:space="preserve">
          <source>If a diagnostic contains fix-it hints, it has a &lt;code&gt;fixits&lt;/code&gt; array, consisting of half-open intervals, similar to the output of</source>
          <target state="translated">진단에 fix-it 힌트가 포함 된 경우 , 결과의 출력과 유사하게 반 열린 간격으로 구성된 &lt;code&gt;fixits&lt;/code&gt; 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e94ab481666483b349181850cc8e39b26f438c5d" translate="yes" xml:space="preserve">
          <source>If a function returns a temporary &lt;code&gt;initializer_list&lt;/code&gt;, or a local &lt;code&gt;initializer_list&lt;/code&gt; variable, the array&amp;rsquo;s lifetime ends at the end of the return statement, so the value returned has a dangling pointer.</source>
          <target state="translated">함수가 임시 &lt;code&gt;initializer_list&lt;/code&gt; 또는 로컬 &lt;code&gt;initializer_list&lt;/code&gt; 변수를 리턴하면 , 배열의 수명은 return 문의 끝에서 종료되므로 리턴 된 값에 매달려있는 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51be4d38853f3a30d7f15e3610ea69ae54265c4e" translate="yes" xml:space="preserve">
          <source>If a loop iterates over an array with a variable stride, create another version of the loop that assumes the stride is always one. For example:</source>
          <target state="translated">루프가 가변 보폭으로 배열을 반복하는 경우 보폭이 항상 1이라고 가정하는 다른 버전의 루프를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e603935699eb5e105e69e65a9021ca2022ac4213" translate="yes" xml:space="preserve">
          <source>If a new-expression creates an &lt;code&gt;initializer_list&lt;/code&gt;, the array only lives until the end of the enclosing full-expression, so the &lt;code&gt;initializer_list&lt;/code&gt; in the heap has a dangling pointer.</source>
          <target state="translated">새 표현식이 &lt;code&gt;initializer_list&lt;/code&gt; 를 작성하는 경우 배열은 묶는 전체 표현식이 끝날 때까지만 유지되므로 힙 의 &lt;code&gt;initializer_list&lt;/code&gt; 에 매달려있는 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc181452125b891816dee9715c4c073b739c819" translate="yes" xml:space="preserve">
          <source>If a program must use a different C++ library and it&amp;rsquo;s not possible to do the final link using a C++ driver that uses that library by default, it is necessary to tell &lt;code&gt;g++&lt;/code&gt; the location and name of that library. It might also be necessary to specify different startup files and other runtime support libraries, and to suppress the use of GCC&amp;rsquo;s support libraries with one or more of the options</source>
          <target state="translated">프로그램이 다른 C ++ 라이브러리를 사용해야하고 기본적으로 해당 라이브러리를 사용하는 C ++ 드라이버를 사용하여 최종 링크를 수행 할 수없는 경우 &lt;code&gt;g++&lt;/code&gt; 에 해당 라이브러리의 위치와 이름을 알려 주어야합니다. 다른 시작 파일 및 기타 런타임 지원 라이브러리를 지정하고 하나 이상의 옵션으로 GCC 지원 라이브러리를 사용하지 않아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84c4785b4be9bc72195941ed1f8c2b45255457e" translate="yes" xml:space="preserve">
          <source>If a standard system include directory, or a directory specified with</source>
          <target state="translated">표준 시스템에 디렉토리 또는 다음으로 지정된 디렉토리가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="5c3be2ab717ecd782733ce9b93456fcb31fc4af7" translate="yes" xml:space="preserve">
          <source>If a variable has the &lt;code&gt;below100&lt;/code&gt; attribute (&lt;code&gt;BELOW100&lt;/code&gt; is allowed also), GCC places the variable in the first 0x100 bytes of memory and use special opcodes to access it. Such variables are placed in either the &lt;code&gt;.bss_below100&lt;/code&gt; section or the &lt;code&gt;.data_below100&lt;/code&gt; section.</source>
          <target state="translated">변수에 &lt;code&gt;below100&lt;/code&gt; 속성 이있는 경우 ( &lt;code&gt;BELOW100&lt;/code&gt; 도 허용됨) GCC는 변수를 처음 0x100 바이트의 메모리에 배치하고 특수 opcode를 사용하여 액세스합니다. 이러한 변수는 &lt;code&gt;.bss_below100&lt;/code&gt; 섹션 또는 &lt;code&gt;.data_below100&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c3454c59e77e91336081ab769819e7fd53ba65" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field follows a normal bit-field, the type of the zero-length bit-field may affect the alignment of the structure as whole. For example, &lt;code&gt;t2&lt;/code&gt; has a size of 4 bytes, since the zero-length bit-field follows a normal bit-field, and is of type short.</source>
          <target state="translated">길이가 0 인 비트 필드가 정상 비트 필드를 뒤 따르면 길이가 0 인 비트 필드의 유형이 전체 구조의 정렬에 영향을 줄 수 있습니다. 예를 들어, 길이가 0 인 비트 필드는 일반 비트 필드를 따르고 짧기 때문에 &lt;code&gt;t2&lt;/code&gt; 의 크기는 4 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="3930dc0fc00c26bd7cfbb87588dd5cf1e2064acf" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted after a bit-field, &lt;code&gt;foo&lt;/code&gt;, and the alignment of the zero-length bit-field is greater than the member that follows it, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is aligned as the type of the zero-length bit-field.</source>
          <target state="translated">길이가 0 인 비트 필드가 비트 필드 &lt;code&gt;foo&lt;/code&gt; 뒤에 삽입되고 길이가 0 인 비트 필드 의 정렬이 뒤에 오는 멤버보다 큰 경우 &lt;code&gt;bar&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 는 0의 유형으로 정렬됩니다. 길이 비트 필드.</target>
        </trans-unit>
        <trans-unit id="487b9fa86178ee0fe71d79bf284c4ff7466101a0" translate="yes" xml:space="preserve">
          <source>If a zero-length bit-field is inserted between two bit-fields that are normally coalesced, the bit-fields are not coalesced.</source>
          <target state="translated">일반적으로 병합 된 두 비트 필드 사이에 길이가 0 인 비트 필드가 삽입되면 비트 필드는 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fce50e2e3a2f90483694041f1d50957c036fd376" translate="yes" xml:space="preserve">
          <source>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as</source>
          <target state="translated">추측 실행이 잘못되었을 때 메모리 위치에 액세스하는 것이 안전하지 않으면 코드를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19dee42123d1606545b47bdc1aee4dced42d70ef" translate="yes" xml:space="preserve">
          <source>If all calls to a given function are integrated, and the function is declared &lt;code&gt;static&lt;/code&gt;, then the function is normally not output as assembler code in its own right.</source>
          <target state="translated">주어진 함수에 대한 모든 호출이 통합되고 함수가 &lt;code&gt;static&lt;/code&gt; 으로 선언 되면 함수는 일반적으로 자체적으로 어셈블러 코드로 출력되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6747ee18a18040e35fcb4f80dbfe422de83e0b1d" translate="yes" xml:space="preserve">
          <source>If an explicit version number is provided and</source>
          <target state="translated">명시적인 버전 번호가 제공된 경우</target>
        </trans-unit>
        <trans-unit id="2a42f93a55377bd2fb4570f085c309d8859bae77" translate="yes" xml:space="preserve">
          <source>If an instruction only takes Altivec registers, you do not want to use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">명령어가 Altivec 레지스터 만 사용하는 경우 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 을 사용하고 싶지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="364981cd1f151ee605ed86bfcc1747b52ebe7a19" translate="yes" xml:space="preserve">
          <source>If any of</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="d4335275a2f1edfde414bbe1e986ac43ea3a56a9" translate="yes" xml:space="preserve">
          <source>If any of the enabled test conditions is true, the corresponding entry in the result vector is -1. Otherwise (all of the enabled test conditions are false), the corresponding entry of the result vector is 0.</source>
          <target state="translated">사용 가능한 테스트 조건 중 하나라도 해당되는 경우 결과 벡터의 해당 항목은 -1입니다. 그렇지 않으면 (사용 가능한 모든 테스트 조건이 false 인 경우) 결과 벡터의 해당 항목은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b0cb0b3f3853386544ffbd0fa1ea4935f0522535" translate="yes" xml:space="preserve">
          <source>If any of these options is used, then the linker is not run, and object file names should not be used as arguments. See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Overall Options&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션 중 하나를 사용하면 링커가 실행되지 않으며 객체 파일 이름을 인수로 사용해서는 안됩니다. &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;전체 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66bff0fe442c04caa45d8e4b29fa05e61e69952b" translate="yes" xml:space="preserve">
          <source>If application code relies on copy-assignment, a user-defined copy-assignment operator removes any uncertainties. With such an operator, the application can define whether and how the virtual base subobject is assigned.</source>
          <target state="translated">응용 프로그램 코드가 복사 할당에 의존하는 경우 사용자 정의 복사 할당 연산자는 불확실성을 제거합니다. 이러한 연산자를 사용하면 응용 프로그램에서 가상 기본 하위 개체의 할당 여부와 방법을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e6fe2d65d6ae8e8dddd4d9d96db3ba491946874" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">두 경우에 &lt;code&gt;signal&lt;/code&gt; 및 &lt;code&gt;interrupt&lt;/code&gt; 와 같은 기능을 위해 지정되는, &lt;code&gt;signal&lt;/code&gt; 조용히 무시된다.</target>
        </trans-unit>
        <trans-unit id="9edaf55b500443b684dd1328cbcf6a8752769f40" translate="yes" xml:space="preserve">
          <source>If both arguments are zero, hotpatching is disabled.</source>
          <target state="translated">두 인수가 모두 0이면 핫 패칭이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="32b3bc364441ca8a7ce5db371cd86527cc2b0b55" translate="yes" xml:space="preserve">
          <source>If both the template and enclosing class have explicit visibility, the visibility from the template is used.</source>
          <target state="translated">템플릿과 엔 클로징 클래스 모두에 가시성이있는 경우 템플릿의 가시성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02529d20c3d2e23aefd28ee9dcdbc7281d16eb72" translate="yes" xml:space="preserve">
          <source>If combined with</source>
          <target state="translated">와 결합하면</target>
        </trans-unit>
        <trans-unit id="af3104b1407804a82ad43f4fa2a84131be37f920" translate="yes" xml:space="preserve">
          <source>If control flow reaches the point of the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code.</source>
          <target state="translated">제어 플로우가 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 의 지점에 도달 하면 프로그램이 정의되지 않습니다. 컴파일러가 코드의 도달 가능성을 추론 할 수없는 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="36b8c90f4b777d0cb2020f4d21e6ac15532c3ad9" translate="yes" xml:space="preserve">
          <source>If debugging information is output when using the precompiled header, using</source>
          <target state="translated">사전 컴파일 된 헤더를 사용할 때 디버깅 정보가 출력되는 경우</target>
        </trans-unit>
        <trans-unit id="402b191a6d5b620de512d8843ce1f34d7777a814" translate="yes" xml:space="preserve">
          <source>If either of the ways of changing the assembly name of a declaration are applied to a declaration whose assembly name has already been determined (either by a previous use of one of these features, or because the compiler needed the assembly name in order to generate code), and the new name is different, a warning issues and the name does not change.</source>
          <target state="translated">선언의 어셈블리 이름을 변경하는 방법 중 하나가 어셈블리 이름이 이미 결정된 선언에 적용되는 경우 (이러한 기능 중 하나를 이전에 사용했거나 코드를 생성하기 위해 컴파일러에서 어셈블리 이름이 필요했기 때문에) ), 새 이름이 다르면 경고 문제가 발생하고 이름이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e6cf380114ced6b961e13544b6be03dfc3354e5" translate="yes" xml:space="preserve">
          <source>If enabled, control-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the control speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">활성화 된 경우 현재 다른 선택 사항이없는 경우에만 일정에 대해 제어 추론 명령이 선택됩니다. 이것은 제어 추론의 사용을 훨씬 더 보수적으로 만듭니다. 기본 설정은 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="c9aeee8753743f519ff715357d9285071a0d9d86" translate="yes" xml:space="preserve">
          <source>If enabled, data-speculative instructions are chosen for schedule only if there are no other choices at the moment. This makes the use of the data speculation much more conservative. The default setting is disabled.</source>
          <target state="translated">활성화 된 경우 현재 다른 선택이없는 경우에만 일정에 대해 데이터 추론 명령이 선택됩니다. 이것은 데이터 추론의 사용을 훨씬 더 보수적으로 만듭니다. 기본 설정은 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="12c5281bb30137f5a28029f336bddc2453ae8835" translate="yes" xml:space="preserve">
          <source>If enabled, speculative dependencies are considered during computation of the instructions priorities. This makes the use of the speculation a bit more conservative. The default setting is disabled.</source>
          <target state="translated">활성화 된 경우 명령 우선 순위를 계산하는 동안 추론 적 종속성이 고려됩니다. 이것은 투기의 사용을 조금 더 보수적으로 만듭니다. 기본 설정은 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="9d63d7ff73f8a910b7cb613706af4cc8bb2d95b9" translate="yes" xml:space="preserve">
          <source>If enabled, the maximum amount of space required for outgoing arguments is computed in the function prologue. This is faster on most modern CPUs because of reduced dependencies, improved scheduling and reduced stack usage when the preferred stack boundary is not equal to 2. The drawback is a notable increase in code size. This switch implies</source>
          <target state="translated">사용 가능한 경우, 나가는 인수에 필요한 최대 공간은 프롤로그 함수에서 계산됩니다. 기본 스택 경계가 2가 아닌 경우 종속성 감소, 스케줄링 개선 및 스택 사용 감소로 인해 대부분의 최신 CPU에서 더 빠릅니다. 단점은 코드 크기가 눈에 띄게 증가한다는 것입니다. 이 스위치는</target>
        </trans-unit>
        <trans-unit id="40d23331ec805b8693bd0e7ed41af8f41bbbeef4" translate="yes" xml:space="preserve">
          <source>If functions are defined in one file and are called in another file, then be sure to write this declaration in both files.</source>
          <target state="translated">함수가 한 파일에 정의되어 있고 다른 파일에 호출 된 경우이 선언을 두 파일 모두에 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a84ad9332942b0583d76324d55388fa827b1dc5" translate="yes" xml:space="preserve">
          <source>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side effects.</source>
          <target state="translated">스칼라 유형이거나 대부분의 경우 멤버 오브젝트 만 스칼라 유형 인 집계 유형 또는 멤버 오브젝트가 스칼라 유형 인 공용체 유형 인 경우 GCC에서는 표현식을 휘발성 오브젝트의 읽기로 해석합니다. 다른 경우에는 표현식이 부작용에 대해서만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="79c1054be8ddf1396d899393bbaa81764a2eed88" translate="yes" xml:space="preserve">
          <source>If multiple</source>
          <target state="translated">여러 경우</target>
        </trans-unit>
        <trans-unit id="e94921c7bd35daddf444608f5259a29f5f4c8cc8" translate="yes" xml:space="preserve">
          <source>If neither</source>
          <target state="translated">그렇지 않다면</target>
        </trans-unit>
        <trans-unit id="afb8c1ba0a7e5bf800f44e5494e9d700db801b00" translate="yes" xml:space="preserve">
          <source>If new system header files are installed, nothing automatically arranges to update the corrected header files. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">새 시스템 헤더 파일이 설치된 경우 수정 된 헤더 파일을 업데이트하도록 자동으로 정렬하지 않습니다. 그것들은 설치된 &lt;code&gt;mkheaders&lt;/code&gt; 스크립트를 사용하여 업데이트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b7def704de696eb922c5e5ba1f5217476d727ef7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is defined in your code, the compiler will automatically replace &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; with &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt;, where that type is silently defined by the compiler in an identical way. This can be confusing and we recommend that you define &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (as shown above) instead.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 가 코드에 정의되어 있지 않으면 컴파일러는 &lt;code&gt;NSFastEnumerationState *&lt;/code&gt; 를 &lt;code&gt;struct __objcFastEnumerationState *&lt;/code&gt; 로 자동 대체합니다 . 여기서 해당 유형은 컴파일러에 의해 동일한 방식으로 자동 정의됩니다. 혼동 될 수 있으므로 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; (위 그림 참조)를 대신 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="089bb39031737c14c4b1a0b430296a1926daaea0" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;arg-index&lt;/var&gt; is given to the &lt;code&gt;nonnull&lt;/code&gt; attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example:</source>
          <target state="translated">&lt;code&gt;nonnull&lt;/code&gt; 이 아닌 속성에 &lt;var&gt;arg-index&lt;/var&gt; 를 지정 하지 않으면 모든 포인터 인수가 널이 아닌 것으로 표시됩니다. 설명을 위해 다음 선언은 이전 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="73b44337d5bc4559e8e1c4b6db36d411b8aef133" translate="yes" xml:space="preserve">
          <source>If no error occurs during compilation, run the compiler a second time, adding &lt;var&gt;opts&lt;/var&gt; and</source>
          <target state="translated">컴파일 도중 오류가 발생하지 않으면 &lt;var&gt;opts&lt;/var&gt; 및</target>
        </trans-unit>
        <trans-unit id="0e662391588b3d6a0fd25b9abb8a35c922931e60" translate="yes" xml:space="preserve">
          <source>If no fixup is needed, this function simply passes through &lt;var&gt;addr&lt;/var&gt;.</source>
          <target state="translated">수정이 필요하지 않은 경우이 함수는 단순히 &lt;var&gt;addr&lt;/var&gt; 을 통과 합니다 .</target>
        </trans-unit>
        <trans-unit id="2c0304f8188faa2beb1f6913883824900b9fd415" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.</source>
          <target state="translated">속성으로 다르게 지정되지 않은 경우 모든 호출이 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 명령어 의 오프셋 범위를 벗어날 수 있다고 가정 하고 (그렇지 않으면 직접) 호출을 수행하기 전에 함수 주소를 레지스터에로드하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4019c8219c3b5cd2dda4dbb0cb3bf4c2a485adff" translate="yes" xml:space="preserve">
          <source>If not otherwise specified by an attribute, assume all direct calls are in the range of the &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; instructions, so use these instructions for direct calls. The default is</source>
          <target state="translated">속성에 의해 달리 지정되지 않은 경우 모든 직통 전화가 &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;bl&lt;/code&gt; 명령어 범위에 있다고 가정 하면이 명령어를 직통 통화에 사용하십시오. 디폴트는</target>
        </trans-unit>
        <trans-unit id="12a28d9821da145a465f7298f6e4c4d208680d82" translate="yes" xml:space="preserve">
          <source>If number of memory accesses in function being instrumented is greater or equal to this number, use callbacks instead of inline checks. E.g. to disable inline code use</source>
          <target state="translated">계측중인 함수의 메모리 액세스 수가이 수보다 크거나 같은 경우 인라인 검사 대신 콜백을 사용하십시오. 예를 들어 인라인 코드 사용을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="5104c1df665f6fc4dddeb5595f01af321de5cad6" translate="yes" xml:space="preserve">
          <source>If object files containing GIMPLE bytecode are stored in a library archive, say</source>
          <target state="translated">GIMPLE 바이트 코드를 포함하는 객체 파일이 라이브러리 아카이브에 저장된 경우</target>
        </trans-unit>
        <trans-unit id="1debeabea3e55864c791086673e07af5641e2395" translate="yes" xml:space="preserve">
          <source>If patchable function entries are enabled globally using the command-line option</source>
          <target state="translated">명령 행 옵션을 사용하여 패치 가능한 기능 항목이 전체적으로 사용 가능한 경우</target>
        </trans-unit>
        <trans-unit id="7ae6684dfcfa35ba16cecacd5ec92f0fb9e0c04e" translate="yes" xml:space="preserve">
          <source>If profiling is active (</source>
          <target state="translated">프로파일 링이 활성화 된 경우 (</target>
        </trans-unit>
        <trans-unit id="88f3c4dd1f2c3c978031ca46886480a0ad40a791" translate="yes" xml:space="preserve">
          <source>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.</source>
          <target state="translated">대상 시스템에서 지원하는 경우 메모리를 프리 페치하여 명령어를 생성하여 큰 어레이에 액세스하는 루프의 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8bfe7e580871525d66e6234642f97096fcdef387" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.</source>
          <target state="translated">대상 시스템에 대해 지원되는 경우 필요한 데이터를 사용할 수 없기 때문에 실행 중단을 제거하기 위해 명령어를 다시 정렬하십시오. 이는로드 또는 부동 소수점 명령의 결과가 필요할 때까지 다른 명령을 실행할 수 있도록하여 부동 소수점 또는 메모리로드 명령이 느린 시스템에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3428a2e4a1d11936eea0f07c36277bc2aa02d581" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.</source>
          <target state="translated">대상 시스템에 대해 지원되는 경우 지연된 분기 명령어 이후에 사용 가능한 명령어 슬롯을 이용하도록 명령어를 다시 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="324f5e0a0812879119b6243a7b551f6c87385665" translate="yes" xml:space="preserve">
          <source>If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on AArch64, m68k, PowerPC and SPARC.</source>
          <target state="translated">대상 시스템에 대해 지원되는 경우 동적 연결에 적합하고 전역 오프셋 테이블의 크기에 대한 제한을 피하기 위해 위치 독립적 인 코드를 생성하십시오. 이 옵션은 AArch64, m68k, PowerPC 및 SPARC에서 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848af5bfa5ce573c8e5c9af3ee618628d308338c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LC_ALL&lt;/code&gt; environment variable is set, it overrides the value of &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt;; otherwise, &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; default to the value of the &lt;code&gt;LANG&lt;/code&gt; environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.</source>
          <target state="translated">경우] &lt;code&gt;LC_ALL&lt;/code&gt; 의 환경 변수를 설정하고, 그 값에 우선 &lt;code&gt;LC_CTYPE&lt;/code&gt; 및 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 을 ; 그렇지 않으면 &lt;code&gt;LC_CTYPE&lt;/code&gt; 및 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 의 기본값은 &lt;code&gt;LANG&lt;/code&gt; 환경 변수 의 값입니다 . 이러한 변수가 설정되지 않은 경우 GCC는 기본적으로 전통적인 C 영어 동작으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="927b034e0a10d14fe57f4acd375117bf77534e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt; attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error or warning (respectively) that includes &lt;var&gt;message&lt;/var&gt; is diagnosed. This is useful for compile-time checking, especially together with &lt;code&gt;__builtin_constant_p&lt;/code&gt; and inline functions where checking the inline function arguments is not possible through &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; tricks.</source>
          <target state="translated">경우] &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;warning&lt;/code&gt; 특성 함수 선언과 같은 함수의 호출에 사용된다 포함 죽은 코드 제거 또는 다른 최적화, 오류 또는 (각각) 경고를 통해 제거되지 않은 &lt;var&gt;message&lt;/var&gt; 진단된다. 이것은 컴파일 타임 검사, 특히 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 및 인라인 함수와 함께 인라인 함수 인수를 검사 할 수없는 &lt;code&gt;extern char [(condition) ? 1 : -1];&lt;/code&gt; 트릭.</target>
        </trans-unit>
        <trans-unit id="20d0c6878745134aa8d904b0690e4fcbddc7d599" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;filename&lt;/var&gt; is provided, then the dumps from all the applicable optimizations are concatenated into the &lt;var&gt;filename&lt;/var&gt;. Otherwise the dump is output onto</source>
          <target state="translated">경우 &lt;var&gt;filename&lt;/var&gt; 제공되며, 모든 적용 가능한 최적화에서 덤프는에 연결됩니다 &lt;var&gt;filename&lt;/var&gt; . 그렇지 않으면 덤프가</target>
        </trans-unit>
        <trans-unit id="9215ad70f2e3e9c6cab1765215d93885159eaa97" translate="yes" xml:space="preserve">
          <source>If the C code that follows the &lt;code&gt;asm&lt;/code&gt; makes no use of any of the output operands, use &lt;code&gt;volatile&lt;/code&gt; for the &lt;code&gt;asm&lt;/code&gt; statement to prevent the optimizers from discarding the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 뒤에 오는 C 코드가 출력 피연산자를 사용하지 않는 경우 &lt;code&gt;asm&lt;/code&gt; 문에 &lt;code&gt;volatile&lt;/code&gt; 을 사용 하여 최적화 프로그램이 &lt;code&gt;asm&lt;/code&gt; 문을 불필요한 것으로 버리지 않도록합니다 ( &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2aa76d6986dfd258dee402c2c95ca11459599c59" translate="yes" xml:space="preserve">
          <source>If the CPU is executing speculatively then either:</source>
          <target state="translated">CPU가 추론 적으로 실행되고 있다면 :</target>
        </trans-unit>
        <trans-unit id="8fe995e077eb81e27ea124938efd43a017d00001" translate="yes" xml:space="preserve">
          <source>If the CPU is not speculatively executing the code, then &lt;var&gt;val&lt;/var&gt; is returned.</source>
          <target state="translated">CPU가 추론 적으로 코드를 실행하지 않으면 &lt;var&gt;val&lt;/var&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c68ba352d7c54da4de70d37cd280b24a3feb4442" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for 64-bit targets. New vector types (&lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt;) are available to hold the &lt;var&gt;__int128&lt;/var&gt; and &lt;var&gt;__uint128&lt;/var&gt; types to use these builtins.</source>
          <target state="translated">벡터 / 스칼라 (power8-vector) 명령어 세트에 ISA 2.07 추가 기능을 사용할 수있는 경우 64 비트 대상에 대해 다음과 같은 추가 기능을 사용할 수 있습니다. 이러한 내장을 사용하기 위해 &lt;var&gt;__int128&lt;/var&gt; 및 &lt;var&gt;__uint128&lt;/var&gt; 유형을 보유하기 위해 새로운 벡터 유형 ( &lt;var&gt;vector __int128&lt;/var&gt; 및 &lt;var&gt;vector __uint128&lt;/var&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ad5ced5d695028f0b739572f683d981d7b325cd" translate="yes" xml:space="preserve">
          <source>If the ISA 2.07 additions to the vector/scalar (power8-vector) instruction set are available, the following additional functions are available for both 32-bit and 64-bit targets. For 64-bit targets, you can use &lt;var&gt;vector long&lt;/var&gt; instead of &lt;var&gt;vector long long&lt;/var&gt;, &lt;var&gt;vector bool long&lt;/var&gt; instead of &lt;var&gt;vector bool long long&lt;/var&gt;, and &lt;var&gt;vector unsigned long&lt;/var&gt; instead of &lt;var&gt;vector unsigned long long&lt;/var&gt;.</source>
          <target state="translated">벡터 / 스칼라 (power8-vector) 명령어 세트에 ISA 2.07 추가 기능을 사용할 수있는 경우 32 비트 및 64 비트 대상 모두에 대해 다음과 같은 추가 기능을 사용할 수 있습니다. 64 비트 대상의 경우 &lt;var&gt;vector long&lt;/var&gt; long 대신 &lt;var&gt;vector long long&lt;/var&gt; , &lt;var&gt;vector bool long&lt;/var&gt; long 대신 &lt;var&gt;vector bool long long&lt;/var&gt; 및 &lt;var&gt;vector unsigned long&lt;/var&gt; long 대신 &lt;var&gt;vector unsigned long long&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c22a3317bedd3145de7eb3a31ecc603e64eb80be" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions (</source>
          <target state="translated">ISA 3.0 명령어 세트 추가 (</target>
        </trans-unit>
        <trans-unit id="424b99254d8407b86c2beca1ac6e71a6fca8ab99" translate="yes" xml:space="preserve">
          <source>If the ISA 3.0 instruction set additions are enabled (</source>
          <target state="translated">ISA 3.0 명령어 세트 추가가 활성화 된 경우 (</target>
        </trans-unit>
        <trans-unit id="b3ba2117601e3a207db62aaa0d548209b490cb82" translate="yes" xml:space="preserve">
          <source>If the argument to the macro has variably modified type, it is evaluated only once when using &lt;code&gt;__auto_type&lt;/code&gt;, but twice if &lt;code&gt;typeof&lt;/code&gt; is used.</source>
          <target state="translated">매크로에 대한 인수에 가변적으로 수정 된 유형이있는 경우 &lt;code&gt;__auto_type&lt;/code&gt; 사용시 한 번만 평가되고 &lt;code&gt;typeof&lt;/code&gt; 가 사용되는 경우 두 번 평가 됩니다.</target>
        </trans-unit>
        <trans-unit id="e5db05160eb702af65a65d649789a2509aade574" translate="yes" xml:space="preserve">
          <source>If the attribute is specified and &lt;code&gt;#pragma omp declare simd&lt;/code&gt; is present on a declaration and the</source>
          <target state="translated">속성이 지정되고 &lt;code&gt;#pragma omp declare simd&lt;/code&gt; 가 선언에 있고</target>
        </trans-unit>
        <trans-unit id="d120c6bfa80fbe55cec1d9862d7e2421db795ea2" translate="yes" xml:space="preserve">
          <source>If the compiler was built to use the system&amp;rsquo;s headers by default, then the default for this option is the system version on which the compiler is running, otherwise the default is to make choices that are compatible with as many systems and code bases as possible.</source>
          <target state="translated">컴파일러가 기본적으로 시스템 헤더를 사용하도록 빌드 된 경우이 옵션의 기본값은 컴파일러가 실행중인 시스템 버전입니다. 그렇지 않으면 기본값은 가능한 한 많은 시스템 및 코드베이스와 호환되는 항목을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d67b52944ba9df1fde368725db64f0de08228c75" translate="yes" xml:space="preserve">
          <source>If the compiler&amp;rsquo;s optimization uses a function&amp;rsquo;s body or information extracted from its body to optimize/change another function, the latter is called an impacted function of the former. If a function is patched, its impacted functions should be patched too.</source>
          <target state="translated">컴파일러 최적화에서 함수 본문 또는 본문에서 추출 된 정보를 사용하여 다른 함수를 최적화 / 변경하는 경우 후자를 전자의 영향을받는 함수라고합니다. 기능이 패치되면 영향을받는 기능도 패치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b237760180d1507d3e5ec309754cc736d88da667" translate="yes" xml:space="preserve">
          <source>If the cryptographic instructions are enabled (</source>
          <target state="translated">암호화 지침이 활성화 된 경우 (</target>
        </trans-unit>
        <trans-unit id="4fb7464a62433bc1b1813aee95893c7c7b12fed7" translate="yes" xml:space="preserve">
          <source>If the device comes with a specific &lt;code&gt;RAMP&lt;/code&gt; register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it.</source>
          <target state="translated">장치에 특정 &lt;code&gt;RAMP&lt;/code&gt; 레지스터가있는 경우 ISR 프롤로그 / 에필로그는 해당 SFR을 저장 / 복원하고 ISR 코드가 (암시 적으로) 사용할 수있는 경우이를 0으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f359291701f84a5c952e96591467d10e46106142" translate="yes" xml:space="preserve">
          <source>If the device supports RAM larger than 64 KiB and the compiler needs to change &lt;code&gt;RAMPZ&lt;/code&gt; to accomplish an operation, &lt;code&gt;RAMPZ&lt;/code&gt; is reset to zero after the operation.</source>
          <target state="translated">장치가 64 KiB보다 큰 RAM을 지원 하고 작업을 수행 하기 위해 컴파일러가 &lt;code&gt;RAMPZ&lt;/code&gt; 를 변경 해야하는 경우 작업 후 &lt;code&gt;RAMPZ&lt;/code&gt; 가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b99e2eb0f30f6704cb82d8729d610b9c040ff67" translate="yes" xml:space="preserve">
          <source>If the equal sign is omitted, the default</source>
          <target state="translated">등호를 생략하면 기본값</target>
        </trans-unit>
        <trans-unit id="d2b152efe933ab511c3240207de045545a59413b" translate="yes" xml:space="preserve">
          <source>If the forwarding hook does not exist or returns &lt;code&gt;NULL&lt;/code&gt;, the runtime currently attempts forwarding using an older, deprecated API, and if that fails, it aborts the program. In future versions of the GNU Objective-C runtime, the runtime will immediately abort.</source>
          <target state="translated">전달 후크가 존재하지 않거나 &lt;code&gt;NULL&lt;/code&gt; 을 반환 하면 런타임은 현재 더 이상 사용되지 않는 이전 API를 사용하여 전달을 시도하고 실패하면 프로그램을 중단합니다. GNU Objective-C 런타임의 이후 버전에서는 런타임이 즉시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3ee17ffd6e7e71752206840400cc69026ba54d" translate="yes" xml:space="preserve">
          <source>If the function is called repeatedly with &lt;code&gt;untrusted_index&lt;/code&gt; less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in &lt;code&gt;array&lt;/code&gt; will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to:</source>
          <target state="translated">500의 한계보다 작은 &lt;code&gt;untrusted_index&lt;/code&gt; 를 사용 하여 함수를 반복해서 호출 하면 분기 예측자는 &lt;code&gt;array&lt;/code&gt; 저장된 값을 반환하는 코드 블록이 실행됨을 알게 됩니다. 이후에 범위를 벗어난 값으로 함수를 호출하면 CPU가 예측이 잘못되었다고 판단 할 때까지 해당 코드 블록을 먼저 실행하려고 시도합니다 (CPU는 해당 시점에서 잘못된 작업을 해제합니다). 그러나 함수 결과의 사용 방법에 따라 범위를 벗어난 위치에 저장된 내용을 표시 할 수있는 추적을 캐시에 남겨 둘 수 있습니다. 내장 함수를 사용하면 코드를 다음과 같이 변경하여 데이터 유출을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4966bfe90659d4fba00a57263dad419daa50166b" translate="yes" xml:space="preserve">
          <source>If the function is declared &lt;code&gt;extern&lt;/code&gt;, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without &lt;code&gt;extern&lt;/code&gt;, in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly.</source>
          <target state="translated">함수가 &lt;code&gt;extern&lt;/code&gt; 으로 선언되면이 함수 정의는 인라인에만 사용됩니다. 주소를 명시 적으로 사용하더라도 함수가 독립형 함수로 컴파일되는 경우는 없습니다. 이러한 주소는 함수를 선언하고 정의하지 않은 것처럼 외부 참조가됩니다. 이것은 거의 매크로의 영향을 미칩니다. 이것을 사용하는 방법은이 속성을 가진 헤더 파일에 함수 정의를 넣고 &lt;code&gt;extern&lt;/code&gt; 없이 함수의 다른 사본을 넣는 것입니다.라이브러리 파일에 있습니다. 헤더 파일의 정의는 함수에 대한 대부분의 호출이 인라인되도록합니다. 함수 사용이 남아 있으면 라이브러리의 단일 사본을 참조합니다. 함수의 두 정의가 동일 할 필요는 없지만, 동일한 효과를 갖지 않으면 프로그램이 이상하게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b771c97ff2c33b584d16ad8091b88c7d383e2d71" translate="yes" xml:space="preserve">
          <source>If the function is inlined in several places, the block structure in each location might not be the same. For instance, a condition might now be calculable at compile time in some instances. Because the coverage of all the uses of the inline function will be shown for the same source lines, the line counts themselves might seem inconsistent.</source>
          <target state="translated">함수가 여러 곳에 인라인 된 경우 각 위치의 블록 구조가 동일하지 않을 수 있습니다. 예를 들어, 일부 경우에 컴파일 시점에 조건을 계산할 수 있습니다. 인라인 함수의 모든 사용 범위가 동일한 소스 라인에 대해 표시되므로 라인 수 자체가 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54a0365a2045222faa9a6a632a364c211ec115e" translate="yes" xml:space="preserve">
          <source>If the function is not inlined, the compiler must emit an out of line copy of the function, in any object file that needs it. If</source>
          <target state="translated">함수가 인라인되지 않은 경우 컴파일러는 함수가 필요한 오브젝트 파일에서 함수의 라인 외부 사본을 내 보내야합니다. 만약</target>
        </trans-unit>
        <trans-unit id="1d41e4e5598657e0dd5a304d5f9d42468e2c3eb3" translate="yes" xml:space="preserve">
          <source>If the hotpatch option is enabled, a &amp;ldquo;hot-patching&amp;rdquo; function prologue is generated for all functions in the compilation unit. The funtion label is prepended with the given number of two-byte NOP instructions (&lt;var&gt;pre-halfwords&lt;/var&gt;, maximum 1000000). After the label, 2 * &lt;var&gt;post-halfwords&lt;/var&gt; bytes are appended, using the largest NOP like instructions the architecture allows (maximum 1000000).</source>
          <target state="translated">핫 패치 옵션이 활성화되면 컴파일 장치의 모든 기능에 대해 &quot;핫 패칭&quot;기능 프롤로그가 생성됩니다. funtion 레이블은 지정된 2 바이트 NOP 명령어 수 ( &lt;var&gt;pre-halfwords&lt;/var&gt; , 최대 1000000) 가 앞에 붙습니다 . 레이블 다음에는 아키텍처가 허용하는 최대 NOP와 같은 명령어를 사용하여 2 * &lt;var&gt;post-halfwords&lt;/var&gt; 바이트가 추가됩니다 (최대 1000000).</target>
        </trans-unit>
        <trans-unit id="1afbfd9c64402361ab2fa39f9fdbd1e3be8c266e" translate="yes" xml:space="preserve">
          <source>If the input program contains a function declaration such as:</source>
          <target state="translated">입력 프로그램에 다음과 같은 함수 선언이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="d87ca5a862edf69ec778f2863678b3c80b02aa1b" translate="yes" xml:space="preserve">
          <source>If the linker complains that an application is using too much small data, you might want to try rebuilding the less performance-critical parts with</source>
          <target state="translated">링커에서 응용 프로그램이 너무 작은 데이터를 사용하고 있다고 불평하는 경우 성능이 덜 중요한 부분을 다시 작성하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf1dd3a359ed16413542f38135a6d9bd4288cff" translate="yes" xml:space="preserve">
          <source>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.</source>
          <target state="translated">세트의 후보 수가이 값보다 작은 경우 새 후보를 추가 할 때 항상 세트에서 불필요한 IV를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e7428a6a85aa26ccfc1d34f1f1cde51cd5cd4798" translate="yes" xml:space="preserve">
          <source>If the operand of &lt;code&gt;__alignof__&lt;/code&gt; is an lvalue rather than a type, its value is the required alignment for its type, taking into account any minimum alignment specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;). For example, after this declaration:</source>
          <target state="translated">&lt;code&gt;__alignof__&lt;/code&gt; 의 피연산자가 유형 이 아닌 lvalue 인 경우 속성 &lt;code&gt;aligned&lt;/code&gt; 지정된 최소 정렬을 고려하여 값이 해당 유형에 필요한 정렬입니다 ( &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성&lt;/a&gt; 참조 ). 예를 들어,이 선언 후 :</target>
        </trans-unit>
        <trans-unit id="a5fda9cca36b52c744155ff2696d3cbfb80c2db1" translate="yes" xml:space="preserve">
          <source>If the operand of the &lt;code&gt;__alignof__&lt;/code&gt; expression is a function, the expression evaluates to the alignment of the function which may be specified by attribute &lt;code&gt;aligned&lt;/code&gt; (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__alignof__&lt;/code&gt; 표현식 의 피연산자가 함수 인 경우 표현식은 속성 &lt;code&gt;aligned&lt;/code&gt; 로 지정 될 수있는 함수의 정렬로 평가됩니다 ( &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 함수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="716641ab8a53f52206a358470c323b2f23eaf7fa" translate="yes" xml:space="preserve">
          <source>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream.</source>
          <target state="translated">삭제에 대한 표현식 삽입 비율이 표현식에 대해이 값보다 큰 경우 RTL PRE는 표현식을 삽입하거나 제거하므로 명령 스트림에 부분적으로 중복 계산이 남습니다.</target>
        </trans-unit>
        <trans-unit id="05912318b76a1009d770bd192ecd133075c5fc90" translate="yes" xml:space="preserve">
          <source>If the register is a call-saved register, call ABI is affected: the register will not be restored in function epilogue sequences after the variable has been assigned. Therefore, functions cannot safely return to callers that assume standard ABI.</source>
          <target state="translated">레지스터가 호출 저장 레지스터 인 경우 호출 ABI가 영향을받습니다. 변수가 할당 된 후 함수 에필로그 순서로 레지스터가 복원되지 않습니다. 따라서 표준 ABI를 가정하는 호출자에게는 함수가 안전하게 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d80c0f0c0e0e7931ed927bbb4a8416d7ae0d80f" translate="yes" xml:space="preserve">
          <source>If the same field is initialized multiple times, or overlapping fields of a union are initialized, the value from the last initialization is used. When a field of a union is itself a structure, the entire structure from the last field initialized is used. If any previous initializer has side effect, it is unspecified whether the side effect happens or not. Currently, GCC discards the side-effecting initializer expressions and issues a warning.</source>
          <target state="translated">동일한 필드가 여러 번 초기화되거나 합집합의 겹치는 필드가 초기화되면 마지막 초기화의 값이 사용됩니다. 공용체 필드 자체가 구조 인 경우, 초기화 된 마지막 필드의 전체 구조가 사용됩니다. 이전 이니셜 라이저에 부작용이있는 경우 부작용이 발생하는지 여부는 지정되지 않습니다. 현재 GCC는 부작용이있는 이니셜 라이저 표현식을 버리고 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="60d643b079de10a712e4f0092195d4a678550bd1" translate="yes" xml:space="preserve">
          <source>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</source>
          <target state="translated">시프트 연산의 두 번째 인수가 범위 내에 있으면 시프트 연산의 결과가 정의되지 않았는지 확인하십시오. 정확히 정의되지 않은 것으로 간주되는 것은 C와 C ++ 및 ISO C90과 C99 등에서 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a31cdc2866161da54d441996165823d561084f93" translate="yes" xml:space="preserve">
          <source>If the selected floating-point hardware includes the NEON extension (e.g.</source>
          <target state="translated">선택한 부동 소수점 하드웨어에 NEON 확장이 포함 된 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="ba7e4ec3c7ed6c8b730bc79d728df15242bb6315" translate="yes" xml:space="preserve">
          <source>If the size of a local variable in bytes is smaller or equal to this number, directly poison (or unpoison) shadow memory instead of using run-time callbacks.</source>
          <target state="translated">바이트 단위의 로컬 변수 크기가이 수보다 작거나 같은 경우 런타임 콜백을 사용하는 대신 섀도 메모리를 직접 독 (또는 독거)합니다.</target>
        </trans-unit>
        <trans-unit id="417bd3fd4051d252d11a2c9158594ed0d6e39230" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic and not bounded, it&amp;rsquo;s:</source>
          <target state="translated">스택 사용량이 (일부) 동적이며 제한되지 않은 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6665e1bf11576c0ed34f60f152094f72a6d33b1" translate="yes" xml:space="preserve">
          <source>If the stack usage is (partly) dynamic but bounded, it&amp;rsquo;s:</source>
          <target state="translated">스택 사용량이 (일부) 동적이지만 한계가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="6185bf1adb7da0baa58ee0f68d56a9ef418a48d1" translate="yes" xml:space="preserve">
          <source>If the stack usage is fully static but exceeds the specified amount, it&amp;rsquo;s:</source>
          <target state="translated">스택 사용량이 완전히 정체되어 있지만 지정된 양을 초과하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d70267f0ff1a52892efb70d9a08fcf6abe326706" translate="yes" xml:space="preserve">
          <source>If the target does not require instruction cache flushes, &lt;code&gt;__builtin___clear_cache&lt;/code&gt; has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the &lt;code&gt;__clear_cache&lt;/code&gt; function in libgcc is made.</source>
          <target state="translated">대상에 명령 캐시 플러시가 필요하지 않은 경우 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 는 영향을 미치지 않습니다. 그렇지 않으면 명령 캐시를 지우기 위해 명령이 인라인으로 방출되거나 libgcc 에서 &lt;code&gt;__clear_cache&lt;/code&gt; 함수 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="095e473e81d277e85bb1ebdb8df1dacc96479003" translate="yes" xml:space="preserve">
          <source>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</source>
          <target state="translated">대상이 데이터 프리 페치를 지원하지 않으면, 부작용이 포함되지만 다른 코드가 생성되지 않고 GCC가 경고를 발행하지 않으면 주소 표현식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="063fcca71547a7fd5efc66500b8f981bd9c39ed3" translate="yes" xml:space="preserve">
          <source>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.</source>
          <target state="translated">대상이 BSS 섹션을 지원하는 경우 GCC는 기본적으로 0으로 초기화 된 변수를 BSS에 넣습니다. 결과 코드에서 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3918a65b7ea046bcd3f9722a5e8050706b67b421" translate="yes" xml:space="preserve">
          <source>If the transaction aborts, all side effects are undone and an abort code encoded as a bit mask is returned. The following macros are defined:</source>
          <target state="translated">트랜잭션이 중단되면 모든 부작용이 취소되고 비트 마스크로 인코딩 된 중단 코드가 반환됩니다. 다음 매크로가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="52878fb9a18ac14d0e8c56cabf2833c060108631" translate="yes" xml:space="preserve">
          <source>If the value in it has side effects, the side effects happen only once, not for each initialized field by the range initializer.</source>
          <target state="translated">그 값에 부작용이있는 경우, 범위 이니셜 라이저에 의해 초기화 된 각 필드가 아니라 부작용이 한 번만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eea091306a656215179432ee609d12ba3a9d954d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;y&lt;/code&gt; is always 1, 2 or 3, then &lt;code&gt;x&lt;/code&gt; is always initialized, but GCC doesn&amp;rsquo;t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 값 이 항상 1, 2 또는 3이면 &lt;code&gt;x&lt;/code&gt; 는 항상 초기화되지만 GCC는이를 알지 못합니다. 경고를 표시하지 않으려면 assert (0) 또는 이와 유사한 코드를 사용하여 기본 사례를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a0552d924c971b406818fb3dc8c14b487a51639" translate="yes" xml:space="preserve">
          <source>If the variable is referenced in inline assembly, the type of access must be provided to the compiler via constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;). Accesses from basic asms are not supported.</source>
          <target state="translated">변수가 인라인 어셈블리에서 참조하는 경우, 액세스 유형 제약 (참조를 통해 컴파일러에 제공해야합니다 &lt;a href=&quot;constraints#Constraints&quot;&gt;제약&lt;/a&gt; ). 기본 asms에서의 액세스는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="710a7177647056e46d73c6a14fa58cb0a4d39cb4" translate="yes" xml:space="preserve">
          <source>If there are no output operands but there are input operands, place two consecutive colons where the output operands would go:</source>
          <target state="translated">출력 피연산자가 없지만 입력 피연산자가있는 경우 출력 피연산자가 이동할 두 개의 연속 콜론을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="ba1e7edd0bd3070d7470d6998361492b87d52104" translate="yes" xml:space="preserve">
          <source>If there is no pattern or mechanism to provide a lock-free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</source>
          <target state="translated">잠금없는 명령 시퀀스를 제공하는 패턴이나 메커니즘이없는 경우 런타임시 해결 될 동일한 매개 변수를 사용하여 외부 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="76caf5beb996fc90102a47daa7e154a5cb406f3a" translate="yes" xml:space="preserve">
          <source>If these options are provided the S/390 back end emits additional instructions in the function prologue that trigger a trap if the stack size is &lt;var&gt;stack-guard&lt;/var&gt; bytes above the &lt;var&gt;stack-size&lt;/var&gt; (remember that the stack on S/390 grows downward). If the &lt;var&gt;stack-guard&lt;/var&gt; option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production-like systems without greater performance degradation. The given values have to be exact powers of 2 and &lt;var&gt;stack-size&lt;/var&gt; has to be greater than &lt;var&gt;stack-guard&lt;/var&gt; without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by &lt;var&gt;stack-size&lt;/var&gt;. The &lt;var&gt;stack-guard&lt;/var&gt; option can only be used in conjunction with &lt;var&gt;stack-size&lt;/var&gt;.</source>
          <target state="translated">이러한 옵션이 제공되면 S / 390 백엔드는 스택 크기가 &lt;var&gt;stack-guard&lt;/var&gt; 크기보다 스택 보호 바이트 인 경우 트랩을 트리거하는 함수 프롤로그에서 추가 명령어를 방출 &lt;var&gt;stack-size&lt;/var&gt; (S / 390의 스택이 아래로 커짐을 기억하십시오). 는 IF &lt;var&gt;stack-guard&lt;/var&gt; 옵션 컴파일 함수의 프레임 크기 2보다 큰 최소의 전력을 생략 선택된다. 이 옵션은 스택 오버플로 문제를 디버깅하는 데 사용됩니다. 추가로 생성 된 코드는 오버 헤드가 거의 발생하지 않으므로 성능 저하없이 프로덕션 시스템에서 사용할 수 있습니다. 주어진 값은 반드시 2의 거듭 제곱이어야하고 &lt;var&gt;stack-size&lt;/var&gt; 는 &lt;var&gt;stack-guard&lt;/var&gt; 보다 커야합니다.64k를 초과하지 않고. 효율성을 높이기 위해 추가 코드는 스택이 &lt;var&gt;stack-size&lt;/var&gt; 에 의해 주어진 값에 정렬 된 주소에서 시작한다고 가정합니다 . &lt;var&gt;stack-guard&lt;/var&gt; 옵션은 함께 사용할 수 있습니다 &lt;var&gt;stack-size&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a905ee4ba472cb30116f3f77a848f112c04b6376" translate="yes" xml:space="preserve">
          <source>If this happens, you should recompile your code with</source>
          <target state="translated">이 경우 코드를 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1cc1d69b5f6b24d749c4393c1e5384e6327ba002" translate="yes" xml:space="preserve">
          <source>If this option appears multiple times in the command line with different values specified, &amp;lsquo;</source>
          <target state="translated">이 옵션이 다른 값으로 지정된 명령 줄에 여러 번 나타나면 '</target>
        </trans-unit>
        <trans-unit id="7d789a669772c260255b8f486a50720c5dbf98e3" translate="yes" xml:space="preserve">
          <source>If this option is disabled, the compiler uses the most efficient instruction. In the previous example, that might be a 32-bit load instruction, even though that accesses bytes that do not contain any portion of the bit-field, or memory-mapped registers unrelated to the one being updated.</source>
          <target state="translated">이 옵션을 비활성화하면 컴파일러가 가장 효율적인 명령어를 사용합니다. 이전 예에서는 비트 필드의 일부를 포함하지 않는 바이트 또는 업데이트되는 것과 관련이없는 메모리 매핑 된 레지스터에 액세스하더라도 32 비트로드 명령어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaaa3704bd89671f3908d72dc5973515cc911101" translate="yes" xml:space="preserve">
          <source>If this option is enabled, the compiler tries to avoid unnecessarily overaligning functions. It attempts to instruct the assembler to align by the amount specified by</source>
          <target state="translated">이 옵션이 활성화되면 컴파일러는 불필요하게 함수를 과도하게 정렬하지 않습니다. 다음에 의해 지정된 양만큼 정렬하도록 어셈블러에 지시하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7074bcc3f488dbf4492fda0d639c0f8273ca6d14" translate="yes" xml:space="preserve">
          <source>If this option is not provided but</source>
          <target state="translated">이 옵션이 제공되지 않지만</target>
        </trans-unit>
        <trans-unit id="b89db9dde06a530a5dff7a4661614320224ef048" translate="yes" xml:space="preserve">
          <source>If this option is not used, the single-core application programming model is used.</source>
          <target state="translated">이 옵션을 사용하지 않으면 단일 코어 응용 프로그램 프로그래밍 모델이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="58f2a7b1d53a81872af6e83acac9efe5419c83d5" translate="yes" xml:space="preserve">
          <source>If this option is set it also selects the type of hardware multiply support to use, unless this is overridden by an explicit</source>
          <target state="translated">이 옵션을 설정하면 명시 적으로 재정의하지 않는 한 사용할 하드웨어 곱셈 지원 유형도 선택합니다.</target>
        </trans-unit>
        <trans-unit id="13cec7c0becaf2d393aabd05cb427709a6c05830" translate="yes" xml:space="preserve">
          <source>If this option is used, the compiler will warn for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed &lt;var&gt;byte-size&lt;/var&gt; bytes. This is similar to how</source>
          <target state="translated">이 옵션을 사용하면 컴파일러는 크기가 제한이 없거나 배열 크기가 &lt;var&gt;byte-size&lt;/var&gt; 바이트 를 초과 할 수있는 인수로 제한되는 가변 길이 배열의 선언에 대해 경고 합니다. 이것은 방법과 비슷합니다</target>
        </trans-unit>
        <trans-unit id="c3115ee12356444486b8dfe277e34da87b4c9653" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies a UNIX timestamp to be used in replacement of the current date and time in the &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; macros, so that the embedded timestamps become reproducible.</source>
          <target state="translated">이 변수를 설정 하면 포함 된 타임 스탬프를 재현 할 수 있도록 &lt;code&gt;__DATE__&lt;/code&gt; 및 &lt;code&gt;__TIME__&lt;/code&gt; 매크로 에서 현재 날짜 및 시간을 대체 할 UNIX 타임 스탬프를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9e2fd261f951c508769059b9f0362dce31b86177" translate="yes" xml:space="preserve">
          <source>If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.</source>
          <target state="translated">이 변수가 설정되면 해당 값은 컴파일러에서 처리 한 비 시스템 헤더 파일을 기반으로 Make의 종속성을 출력하는 방법을 지정합니다. 시스템 헤더 파일은 종속성 출력에서 ​​무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a402efdff3876f11c94bdea172224e741634fd39" translate="yes" xml:space="preserve">
          <source>If used for a function, print the PLT suffix and generate PIC code. For example, emit &lt;code&gt;foo@PLT&lt;/code&gt; instead of &amp;rsquo;foo&amp;rsquo; for the function foo(). If used for a constant, drop all syntax-specific prefixes and issue the bare constant. See &lt;code&gt;p&lt;/code&gt; above.</source>
          <target state="translated">기능에 사용되는 경우 PLT 접미 부를 인쇄하고 PIC 코드를 생성하십시오. 예를 들어, foo () 함수에 대해 'foo'대신 &lt;code&gt;foo@PLT&lt;/code&gt; 를 생성하십시오. 상수에 사용되는 경우 모든 구문 특정 접 두부를 삭제하고 베어 상수를 발행하십시오. 위의 &lt;code&gt;p&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aee4afea693faf480212e1e7dfd95c798d52751" translate="yes" xml:space="preserve">
          <source>If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell&amp;rsquo;s quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.</source>
          <target state="translated">쉘 또는 쉘 유사 프로그램에서 프리 프로세서를 호출하는 경우 쉘 구문에서 의미가있는 공백과 같은 문자를 보호하려면 쉘의 인용 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12dd6be4f44a03f04923a3d7c38a665528824bfc" translate="yes" xml:space="preserve">
          <source>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside</source>
          <target state="translated">플러그인을 지원하는 링커를 사용하지 않거나 링커 플러그인을 활성화하지 않으면 내부의 객체</target>
        </trans-unit>
        <trans-unit id="dadbd9ac438963390bc7bff3cc4c1fa602dc81f8" translate="yes" xml:space="preserve">
          <source>If you are not using some other optimization option, consider using</source>
          <target state="translated">다른 최적화 옵션을 사용하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="c0c121f354142152248081fdee3df09a5e0cff31" translate="yes" xml:space="preserve">
          <source>If you are using Cfront-model code, you can probably get away with not using</source>
          <target state="translated">Cfront-model 코드를 사용하는 경우 사용하지 않고 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670c5a80eac2c68f98a0b7952c25d85ec989c07c" translate="yes" xml:space="preserve">
          <source>If you are using a &amp;ldquo;Foundation&amp;rdquo; library such as GNUstep-Base, this library will provide you with a rich set of functionality to do most of the inspection tasks, and you probably will only need direct access to the GNU Objective-C runtime API to define new classes or methods.</source>
          <target state="translated">GNUstep-Base와 같은 &quot;Foundation&quot;라이브러리를 사용하는 경우이 라이브러리는 대부분의 검사 작업을 수행 할 수있는 다양한 기능을 제공하며 GNU Objective-C 런타임 API에 직접 액세스하기 만하면됩니다. 새로운 클래스 또는 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f60cfeeeec61609632220d7b04102d2cfb0874a6" translate="yes" xml:space="preserve">
          <source>If you are writing a header file that must work when included in ISO C programs, write &lt;code&gt;__typeof__&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO C 프로그램에 포함될 때 작동해야하는 헤더 파일을 작성하는 경우 &lt;code&gt;typeof&lt;/code&gt; 대신 &lt;code&gt;__typeof__&lt;/code&gt; 를 작성 하십시오 . &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;대체 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047e86cc1cc9d18346ee9ad5f63aecd5602b5f99" translate="yes" xml:space="preserve">
          <source>If you are writing a header file to be included in ISO C90 programs, write &lt;code&gt;__inline__&lt;/code&gt; instead of &lt;code&gt;inline&lt;/code&gt;. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">ISO C90 프로그램에 포함 할 헤더 파일을 작성하는 경우 &lt;code&gt;inline&lt;/code&gt; 대신 &lt;code&gt;__inline__&lt;/code&gt; 을 작성하십시오 . &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;대체 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbd2d15a4f5e85df131685d7eb92f6861e37e279" translate="yes" xml:space="preserve">
          <source>If you care about controlling the amount of memory that is accessed, use volatile but do not use bit-fields.</source>
          <target state="translated">액세스되는 메모리 양 제어에 관심이있는 경우 휘발성을 사용하지만 비트 필드는 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0103e1abfe788f8d50e7fc73d958416e72e0b9c1" translate="yes" xml:space="preserve">
          <source>If you compile a module &lt;var&gt;Mod&lt;/var&gt; with</source>
          <target state="translated">당신은 모듈 컴파일하면 &lt;var&gt;Mod&lt;/var&gt; 과를</target>
        </trans-unit>
        <trans-unit id="47d85eced409c6f6fef0defc52869795ed0b0f14" translate="yes" xml:space="preserve">
          <source>If you define a class in a header file marked with &amp;lsquo;</source>
          <target state="translated">'로 표시된 헤더 파일에서 클래스를 정의하는 경우</target>
        </trans-unit>
        <trans-unit id="8af3483bb66c1cf78841141fb90f1ef9efc295a7" translate="yes" xml:space="preserve">
          <source>If you do not specify an optimization level option</source>
          <target state="translated">최적화 수준 옵션을 지정하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="0524dbf059780b836548e3795cd65f22c493bbb4" translate="yes" xml:space="preserve">
          <source>If you do use differing options when generating and using the precompiled header, the actual behavior is a mixture of the behavior for the options. For instance, if you use</source>
          <target state="translated">미리 컴파일 된 헤더를 생성하고 사용할 때 다른 옵션을 사용하는 경우 실제 동작은 옵션 동작의 혼합입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6615402a003808b60f77e922f8fff7dc102cea3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know the type of the operand, you can still do this, but you must use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;__auto_type&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;).</source>
          <target state="translated">피연산자의 유형을 모르는 경우에도이를 수행 할 수 있지만 &lt;code&gt;typeof&lt;/code&gt; 또는 &lt;code&gt;__auto_type&lt;/code&gt; 을 사용해야합니다 ( &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c085ab8b04d2de8c46788dc7f554d15750ff8940" translate="yes" xml:space="preserve">
          <source>If you have trouble using GCC.</source>
          <target state="translated">GCC 사용에 문제가있는 경우</target>
        </trans-unit>
        <trans-unit id="4152886dce97a4266954e0590ef45338d28d4f3b" translate="yes" xml:space="preserve">
          <source>If you invoke &lt;code&gt;gcov&lt;/code&gt; with multiple input files, the contributions from each input file are summed. Typically you would invoke it with the same list of files as the final link of your executable.</source>
          <target state="translated">여러 입력 파일로 &lt;code&gt;gcov&lt;/code&gt; 를 호출하면 각 입력 파일의 컨트 리뷰 션이 합산됩니다. 일반적으로 실행 파일의 최종 링크와 동일한 파일 목록으로 파일을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f78ebb50b8c8401143c21ca977cd992331a9d441" translate="yes" xml:space="preserve">
          <source>If you invoke GCC in parallel, compiling several different source files that share a common base name in different subdirectories or the same source file compiled for multiple output destinations, it is likely that the different parallel compilers will interfere with each other, and overwrite the temporary files. For instance:</source>
          <target state="translated">GCC를 병렬로 호출하여 서로 다른 서브 디렉토리에서 공통 기본 이름을 공유하는 여러 소스 파일을 컴파일하거나 여러 출력 대상에 대해 컴파일 된 동일한 소스 파일을 컴파일하면 서로 다른 병렬 컴파일러가 서로 간섭하여 임시 파일을 겹쳐 쓰게됩니다. 파일. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="339873ba9c437ffb773ea97b43d76bef2cd414b1" translate="yes" xml:space="preserve">
          <source>If you know the above will only be reading a ten byte array then you could instead use a memory input like: &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt;.</source>
          <target state="translated">위의 내용이 10 바이트 배열 만 읽는다는 것을 알고 있다면 대신 &lt;code&gt;&quot;m&quot; (*(const char (*)[10]) p)&lt;/code&gt; 와 같은 메모리 입력을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="888965c4f3b549f1f0054a0f4c6ff67115a7146e" translate="yes" xml:space="preserve">
          <source>If you need a Standard compliant library, then you need to find one, as GCC does not provide one. The GNU C library (called &lt;code&gt;glibc&lt;/code&gt;) provides ISO C, POSIX, BSD, SystemV and X/Open compatibility for GNU/Linux and HURD-based GNU systems; no recent version of it supports other systems, though some very old versions did. Version 2.2 of the GNU C library includes nearly complete C99 support. You could also ask your operating system vendor if newer libraries are available.</source>
          <target state="translated">표준 호환 라이브러리가 필요한 경우 GCC에서 제공하지 않으므로 라이브러리를 찾아야합니다. &lt;code&gt;glibc&lt;/code&gt; 라고하는 GNU C 라이브러리 는 GNU / Linux 및 HURD 기반 GNU 시스템에 대한 ISO C, POSIX, BSD, SystemV 및 X / Open 호환성을 제공합니다. 최신 버전은 다른 시스템을 지원하지 않지만 일부 매우 오래된 버전은 지원합니다. GNU C 라이브러리 버전 2.2에는 거의 완벽한 C99 지원이 포함되어 있습니다. 최신 라이브러리를 사용할 수 있는지 운영 체제 공급 업체에 문의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2295b8a8afca796af761f37955429fb2dfb303ab" translate="yes" xml:space="preserve">
          <source>If you need to precompile the same header file for different languages, targets, or compiler options, you can instead make a &lt;em&gt;directory&lt;/em&gt; named like</source>
          <target state="translated">다른 언어, 대상 또는 컴파일러 옵션에 대해 동일한 헤더 파일을 사전 컴파일해야하는 경우 대신 다음 과 같은 이름 의 &lt;em&gt;디렉토리&lt;/em&gt; 를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66af9e4f8d685ec9e9b50745c5edb5982da51a9b" translate="yes" xml:space="preserve">
          <source>If you need to read the volatile object after an assignment has occurred, you must use a separate expression with an intervening sequence point.</source>
          <target state="translated">할당이 발생한 후 소멸성 개체를 읽어야하는 경우 중간 시퀀스 지점에 별도의 식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4adf572d889db0dbe74d88ef8bb1d09b3f0a1cca" translate="yes" xml:space="preserve">
          <source>If you only want some of the stages of compilation, you can use</source>
          <target state="translated">컴파일 단계 중 일부만 원한다면</target>
        </trans-unit>
        <trans-unit id="0a3a127b379e27c78040de67c2f4f38df68d44ac" translate="yes" xml:space="preserve">
          <source>If you plan to use &lt;code&gt;gcov&lt;/code&gt; to help optimize your code, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 를 사용 하여 코드를 최적화하려면 먼저 특수 GCC 옵션 '을 사용하여 프로그램을 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="89a00b1663443b615a5e906a67310faf3ab9d3e4" translate="yes" xml:space="preserve">
          <source>If you receive a linker error message that saying you have overflowed the available TOC space, you can reduce the amount of TOC space used with the</source>
          <target state="translated">사용 가능한 TOC 공간이 오버플로되었다는 링커 오류 메시지가 표시되면 사용 된 TOC 공간의 양을 줄일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="be0941cee2405a3cef991d81a7e61b7d98631fbb" translate="yes" xml:space="preserve">
          <source>If you replaced &lt;code&gt;short_a&lt;/code&gt; with &lt;code&gt;short&lt;/code&gt; in the variable declaration, the above program would abort when compiled with</source>
          <target state="translated">변수 선언에서 &lt;code&gt;short_a&lt;/code&gt; 를 &lt;code&gt;short&lt;/code&gt; 로 바꾸면 위의 프로그램은 다음과 같이 컴파일 될 때 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="35d1d8ed39d0b8c7b146243c81d4152cdc148fcf" translate="yes" xml:space="preserve">
          <source>If you specify &amp;lsquo;</source>
          <target state="translated">'를 지정하면</target>
        </trans-unit>
        <trans-unit id="4ecc2b870bc1bb7d3b980a000c9f6dcec5995fb9" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</source>
          <target state="translated">함수 정의에 &lt;code&gt;inline&lt;/code&gt; 과 &lt;code&gt;extern&lt;/code&gt; 을 모두 지정하면 인라인 에만 정의가 사용됩니다. 주소를 명시 적으로 참조하더라도 함수가 자체적으로 컴파일되는 것은 아닙니다. 이러한 주소는 함수를 선언하고 정의하지 않은 것처럼 외부 참조가됩니다.</target>
        </trans-unit>
        <trans-unit id="5d47cb731371550330a13465931e86c5d293dfdf" translate="yes" xml:space="preserve">
          <source>If you specify command-line switches such as</source>
          <target state="translated">다음과 같은 명령 줄 스위치를 지정하면</target>
        </trans-unit>
        <trans-unit id="6dac1f1fb59b9ffca6f761fa60561e481b2e6270" translate="yes" xml:space="preserve">
          <source>If you specify neither</source>
          <target state="translated">둘 다 지정하지 않으면</target>
        </trans-unit>
        <trans-unit id="c921e7f4f95a0df5eb637ba56c7aabab978aaee6" translate="yes" xml:space="preserve">
          <source>If you specify the optional &lt;var&gt;n&lt;/var&gt;, the optimization and code generation done at link time is executed in parallel using &lt;var&gt;n&lt;/var&gt; parallel jobs by utilizing an installed &lt;code&gt;make&lt;/code&gt; program. The environment variable &lt;code&gt;MAKE&lt;/code&gt; may be used to override the program used. The default value for &lt;var&gt;n&lt;/var&gt; is 1.</source>
          <target state="translated">선택적 &lt;var&gt;n&lt;/var&gt; 을 지정하면 설치된 &lt;code&gt;make&lt;/code&gt; 프로그램을 사용하여 &lt;var&gt;n&lt;/var&gt; 병렬 작업을 사용하여 링크 시간에 수행 된 최적화 및 코드 생성이 병렬로 실행됩니다 . 환경 변수 &lt;code&gt;MAKE&lt;/code&gt; 를 사용하여 사용 된 프로그램을 재정의 할 수 있습니다. &lt;var&gt;n&lt;/var&gt; 의 기본값 은 1입니다.</target>
        </trans-unit>
        <trans-unit id="925aa9cac99e94c7e1b3007e94e2857fd742f461" translate="yes" xml:space="preserve">
          <source>If you still run out of space in the TOC even when you specify both of these options, specify</source>
          <target state="translated">이 두 옵션을 모두 지정할 때도 여전히 TOC에 공간이 부족한 경우 다음을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e9f3b7bcc19fa8799f793151f5d918c0eb44cc5c" translate="yes" xml:space="preserve">
          <source>If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it&amp;rsquo;s not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.</source>
          <target state="translated">포함 함수가 종료 된 후 주소를 통해 중첩 함수를 호출하려고하면 모든 지옥이 느슨해집니다. 포함하는 범위 수준 종료 후 호출하려고 시도하고 더 이상 범위에없는 일부 변수를 참조하면 운이 좋지만 위험을 감수하는 것은 현명하지 않습니다. 그러나 중첩 함수가 범위를 벗어난 것을 참조하지 않으면 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="f927a3385a1b1e51d949287257534f3a4443c5fc" translate="yes" xml:space="preserve">
          <source>If you update the system&amp;rsquo;s header files, such as by installing a new system version, the fixed header files of GCC are not automatically updated. They can be updated using the &lt;code&gt;mkheaders&lt;/code&gt; script installed in</source>
          <target state="translated">새 시스템 버전 설치와 같은 시스템 헤더 파일을 업데이트하면 GCC의 고정 헤더 파일이 자동으로 업데이트되지 않습니다. 그것들은 설치된 &lt;code&gt;mkheaders&lt;/code&gt; 스크립트를 사용하여 업데이트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="41fb10bf832524090b9ab05176d0ed5567a508f5" translate="yes" xml:space="preserve">
          <source>If you use</source>
          <target state="translated">당신이 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="6a51a2c7443f8a2b859ded2344689b9dd5a96d35" translate="yes" xml:space="preserve">
          <source>If you use &amp;lsquo;</source>
          <target state="translated">'를 사용하면</target>
        </trans-unit>
        <trans-unit id="1eb60252a45f0973d8c5683aecd8b85683d307d3" translate="yes" xml:space="preserve">
          <source>If you use both this option and the</source>
          <target state="translated">이 옵션과</target>
        </trans-unit>
        <trans-unit id="daf14f5a30ee5ca1525b7be167b116e92944e7ce" translate="yes" xml:space="preserve">
          <source>If you use multiple</source>
          <target state="translated">여러 개를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="9b9352d7bdc60d6db5e3f97a4150de5fffc4de3b" translate="yes" xml:space="preserve">
          <source>If you use one big file to do the instantiations, you may want to compile it without</source>
          <target state="translated">하나의 큰 파일을 사용하여 인스턴스화를 수행하는 경우 큰 파일을 사용하지 않고 컴파일 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d5658f3cda5684fd922808fa10e4319b5a492e30" translate="yes" xml:space="preserve">
          <source>If you use one of the &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces you must arrange your linker script to locate the &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; sections according to your needs.</source>
          <target state="translated">&lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 주소 공간 중 하나를 사용하는 경우 필요에 따라 &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; 섹션 을 찾도록 링커 스크립트를 정렬해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d09fff5b63f8a00b0aa50a2fbc9e05727d5eaa55" translate="yes" xml:space="preserve">
          <source>If you use the</source>
          <target state="translated">당신이 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="0c2eabb891cc235e2e02c3ade4b4c6be5a7c7761" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;inline&lt;/code&gt; qualifier, then for inlining purposes the size of the &lt;code&gt;asm&lt;/code&gt; statement is taken as the smallest size possible (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 한정자 를 사용하면 인라인 목적으로 &lt;code&gt;asm&lt;/code&gt; 문의 크기가 가능한 가장 작은 크기로 간주됩니다 ( &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm 크기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1d0a1d145962ca52d117f00e82a8a34efa685f04" translate="yes" xml:space="preserve">
          <source>If you use the ISA 3.0 instruction set (</source>
          <target state="translated">ISA 3.0 명령어 세트를 사용하는 경우 (</target>
        </trans-unit>
        <trans-unit id="3b409b718d6983a24e16eccb9909125cc43f2697" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes a separate argument, you must use</source>
          <target state="translated">별도의 인수를 취하는 옵션을 전달하려면 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01e57dac3d1293541430d1619103f3be6de91e09" translate="yes" xml:space="preserve">
          <source>If you want to pass an option that takes an argument, you must use</source>
          <target state="translated">인수를 취하는 옵션을 전달하려면 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="57c0d52053735b1deca65f8fe95302a40e91aba4" translate="yes" xml:space="preserve">
          <source>If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&amp;mdash;another GNU extension.</source>
          <target state="translated">배열을 먼저 전달한 후 길이를 전달하려는 경우 매개 변수 목록에 또 다른 GNU 확장 인 forward 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714721fbe0a57745166a774e2ee80658db42639e" translate="yes" xml:space="preserve">
          <source>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option</source>
          <target state="translated">실제로 전역 레지스터 변수를 사용하지 않고 다른 목적으로 지정된 레지스터를 사용하지 않는 소스 파일을 재 컴파일하려는 경우 실제로 소스 코드에 글로벌 레지스터 선언을 추가 할 필요는 없습니다. 컴파일러 옵션을 지정하면 충분합니다</target>
        </trans-unit>
        <trans-unit id="63035fe8f0fef33a809f5df21a239bff0f434564" translate="yes" xml:space="preserve">
          <source>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the</source>
          <target state="translated">자체 초기화 프로그램에서 변수의 초기화되지 않은 값을 사용하는 코드에 대해 경고하려면</target>
        </trans-unit>
        <trans-unit id="1f9d39a0d621d29f6b4df2f19650e527eb6087e6" translate="yes" xml:space="preserve">
          <source>If you want your own collection object to be usable with fast enumeration, you need to have it implement the method</source>
          <target state="translated">빠른 열거와 함께 자신의 컬렉션 객체를 사용하려면 메소드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="66ce7bf0d3f3a0ea10a8e8123399a75d9055c922" translate="yes" xml:space="preserve">
          <source>If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you should quote the option. With &lt;code&gt;sh&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt;,</source>
          <target state="translated">명령 행에서 함수와 유사한 매크로를 정의하려면 등호 (있는 경우) 앞에 주변 괄호로 인수 목록을 작성하십시오. 괄호는 대부분의 쉘에 의미가 있으므로 옵션을 인용해야합니다. 와 &lt;code&gt;sh&lt;/code&gt; 와 &lt;code&gt;csh&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="344eca13d4f5455ce9ed14a9174152844b040aa2" translate="yes" xml:space="preserve">
          <source>If your code needs to support multiple assembler dialects (for example, if you are writing public headers that need to support a variety of compilation options), use constructs of this form:</source>
          <target state="translated">코드에서 여러 어셈블러 언어를 지원해야하는 경우 (예 : 다양한 컴파일 옵션을 지원해야하는 공용 헤더를 작성하는 경우) 다음 형식의 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="489624b43d62801c5096e0cef6c84a4128aa3f2e" translate="yes" xml:space="preserve">
          <source>If, for some reason, you want to include letter &amp;lsquo;</source>
          <target state="translated">어떤 이유로 든 문자 '를 포함하려는 경우</target>
        </trans-unit>
        <trans-unit id="8ae25dcd1480cd59f0776f409a8f3b4cc8c76dee" translate="yes" xml:space="preserve">
          <source>If, instead, you use the GCC driver to create shared libraries, you may find that they are not always linked with the shared</source>
          <target state="translated">대신 GCC 드라이버를 사용하여 공유 라이브러리를 만드는 경우 해당 라이브러리가 항상 공유 라이브러리와 연결되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d34e1e1ae89800680b004320ebb086b09cf39f6" translate="yes" xml:space="preserve">
          <source>Ignore the &lt;code&gt;#ident&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;#ident&lt;/code&gt; 지시문을 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e82df27ea7fceb83aac6e28c3926e8f714c2de0" translate="yes" xml:space="preserve">
          <source>Immediate 15-bit unsigned integer</source>
          <target state="translated">즉시 15 비트 부호없는 정수</target>
        </trans-unit>
        <trans-unit id="25ebf6700b63624d3804d20faa7de74e2dccc87c" translate="yes" xml:space="preserve">
          <source>Immediate 16-bit signed integer</source>
          <target state="translated">즉시 16 비트 부호있는 정수</target>
        </trans-unit>
        <trans-unit id="c2ce26e27211c1d69d3a406bee1c55a3cfc3b488" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit integer in range -16..4294967295 (i.e. 32-bit unsigned integer or &amp;lsquo;</source>
          <target state="translated">-16..4294967295 범위의 즉각적인 32 비트 정수 (예 : 32 비트 부호없는 정수 또는 '</target>
        </trans-unit>
        <trans-unit id="7ce04d3df5932775f166ab61ebe67634f6cff4f5" translate="yes" xml:space="preserve">
          <source>Immediate 32-bit signed integer that can be attached to an instruction encoding</source>
          <target state="translated">명령어 인코딩에 첨부 할 수있는 즉시 32 비트 부호있는 정수</target>
        </trans-unit>
        <trans-unit id="95af07c0237447c6b15292985f8e2b14ec413d35" translate="yes" xml:space="preserve">
          <source>Immediate 64-bit constant that can be split into two &amp;lsquo;</source>
          <target state="translated">두 개의 '로 나눌 수있는 즉시 64 비트 상수</target>
        </trans-unit>
        <trans-unit id="aea4f97beb4642aabcdf84f409c00fa5cd5c2c91" translate="yes" xml:space="preserve">
          <source>Immediate constant -1</source>
          <target state="translated">즉시 상수 -1</target>
        </trans-unit>
        <trans-unit id="293172a51e9ef5dbf0bb7e7f454796275cc1f905" translate="yes" xml:space="preserve">
          <source>Immediate constant that can be inlined in an instruction encoding: integer -16..64, or float 0.0, +/-0.5, +/-1.0, +/-2.0, +/-4.0, 1.0/(2.0*PI)</source>
          <target state="translated">명령어 인코딩으로 인라인 될 수있는 즉시 상수 : 정수 -16..64 또는 float 0.0, +/- 0.5, +/- 1.0, +/- 2.0, +/- 4.0, 1.0 / (2.0 * PI)</target>
        </trans-unit>
        <trans-unit id="a56a5101429aaf4e851ed409b055e85e8d91d6b8" translate="yes" xml:space="preserve">
          <source>Immediate integer in the range -16 to 64</source>
          <target state="translated">-16에서 64 사이의 즉시 정수</target>
        </trans-unit>
        <trans-unit id="bf320f9d296e81a49f73cab866d640531aefcfad" translate="yes" xml:space="preserve">
          <source>Implement (do not implement) -fno-plt and long calls using an inline PLT call sequence that supports lazy linking and long calls to functions in dlopen&amp;rsquo;d shared libraries. Inline PLT calls are only supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers, and are enabled by default if the support is detected when configuring GCC, and, in the case of 32-bit PowerPC, if GCC is configured with</source>
          <target state="translated">dlopen의 공유 라이브러리에서 지연 링크 및 함수에 대한 긴 호출을 지원하는 인라인 PLT 호출 시퀀스를 사용하여 -fno-plt 및 긴 호출을 구현합니다 (구현하지 않음). 인라인 PLT 호출은 최신 GNU 링커가있는 PowerPC64 ELFv2 및 32 비트 PowerPC 시스템에서만 지원되며 GCC를 구성 할 때 지원이 감지되고 32 비트 PowerPC의 경우 GCC가 다음과 같이 구성된 경우 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="f6c8b1a3b3ce20b0f24d10325bb5a9fda3cc0723" translate="yes" xml:space="preserve">
          <source>Implies no inter-thread ordering constraints.</source>
          <target state="translated">스레드 간 순서 제약 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe96af122b5bf84f1ddc818f1e5f57ac3e7dac8c" translate="yes" xml:space="preserve">
          <source>Improved AMD Athlon CPU with MMX, 3DNow!, enhanced 3DNow! and full SSE instruction set support.</source>
          <target state="translated">MMX, 3DNow! 및 향상된 3DNow!를 갖춘 AMD Athlon CPU 개선 그리고 완전한 SSE 명령 세트 지원.</target>
        </trans-unit>
        <trans-unit id="6774c0ca18d629c919e07781b4bc4345f81613ce" translate="yes" xml:space="preserve">
          <source>Improved support for generic programming.</source>
          <target state="translated">일반 프로그래밍에 대한 지원이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb701b014b08c67fb59b6b752448015c50d54c43" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with 64-bit extensions, MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">64 비트 확장, MMX, SSE, SSE2 및 SSE3 명령어 세트를 지원하는 향상된 Intel Pentium 4 CPU 버전.</target>
        </trans-unit>
        <trans-unit id="ed782143dc7e1163d3eb2323e646f10006e40097" translate="yes" xml:space="preserve">
          <source>Improved version of Intel Pentium 4 CPU with MMX, SSE, SSE2 and SSE3 instruction set support.</source>
          <target state="translated">MMX, SSE, SSE2 및 SSE3 명령어 세트를 지원하는 향상된 Intel Pentium 4 CPU 버전.</target>
        </trans-unit>
        <trans-unit id="8a73deb51d5b08d19d0486183c731c2e4df58a6c" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K6 CPU with MMX and 3DNow! instruction set support.</source>
          <target state="translated">MMX 및 3DNow가 포함 된 AMD K6 CPU의 향상된 버전! 명령 세트 지원.</target>
        </trans-unit>
        <trans-unit id="0640019f239b6c731b94ce729c56eafeb42fbdce" translate="yes" xml:space="preserve">
          <source>Improved versions of AMD K8 cores with SSE3 instruction set support.</source>
          <target state="translated">SSE3 명령어 세트를 지원하는 개선 된 AMD K8 코어 버전.</target>
        </trans-unit>
        <trans-unit id="faa77d9eb98f8c3bb3a99e6c2fd6a673c7a1ef4f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; expands to &lt;code&gt;((void *)0)&lt;/code&gt;. GCC does not provide the other headers which define &lt;code&gt;NULL&lt;/code&gt; and some library implementations may use other definitions in those headers.</source>
          <target state="translated">에서는 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; , &lt;code&gt;NULL&lt;/code&gt; 에 확장되어 &lt;code&gt;((void *)0)&lt;/code&gt; . GCC는 &lt;code&gt;NULL&lt;/code&gt; 을 정의하는 다른 헤더를 제공하지 않으며 일부 라이브러리 구현은 해당 헤더에서 다른 정의를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f792f5735cf258c95fd93f04f6f7c58a83d70b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;get_i()&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of &lt;code&gt;Base&lt;/code&gt; even after declaring &lt;code&gt;Derived&lt;/code&gt;, so the compiler cannot really know what &lt;code&gt;i&lt;/code&gt; would refer to. If there is no global variable &lt;code&gt;i&lt;/code&gt;, then you will get an error message.</source>
          <target state="translated">에서 &lt;code&gt;get_i()&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 컴파일러 (여기에 글로벌 스코프입니다) 바깥 쪽 네임 스페이스 범위에서 선언 된 이름을 찾습니다 있도록, 종속 맥락에서 사용되지 않습니다. 의존적 이므로 &lt;code&gt;Derived&lt;/code&gt; 선언 한 후에도 &lt;code&gt;Base&lt;/code&gt; 의 전문화를 선언 할 수 있으므로 기본 클래스를 조사하지 않으므로 컴파일러는 &lt;code&gt;i&lt;/code&gt; 무엇 을 참조 하는지 알 수 없습니다 . 전역 변수 &lt;code&gt;i&lt;/code&gt; 가 없으면 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1efd435b2fd7ff4eeb1d3caefe51e97ec2eabff1" translate="yes" xml:space="preserve">
          <source>In C code, this option controls the placement of global variables defined without an initializer, known as &lt;em&gt;tentative definitions&lt;/em&gt; in the C standard. Tentative definitions are distinct from declarations of a variable with the &lt;code&gt;extern&lt;/code&gt; keyword, which do not allocate storage.</source>
          <target state="translated">C 코드에서이 옵션 은 C 표준에서 &lt;em&gt;임시 정의&lt;/em&gt; 라고하는 이니셜 라이저없이 정의 된 전역 변수의 배치를 제어합니다 . 임시 정의는 스토리지를 할당하지 않는 &lt;code&gt;extern&lt;/code&gt; 키워드 를 사용한 변수 선언과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="986d71cafa07e6d2f235ac194e79a8e70cb9cccf" translate="yes" xml:space="preserve">
          <source>In C mode, this is equivalent to</source>
          <target state="translated">C 모드에서 이것은</target>
        </trans-unit>
        <trans-unit id="6e29cf5656ff22cce837fe364a063ee35412d5b9" translate="yes" xml:space="preserve">
          <source>In C this option does not warn about the universal zero initializer &amp;lsquo;</source>
          <target state="translated">C 에서이 옵션은 범용 제로 이니셜 라이저에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f3a5ba446573452e29640c8fc16cb4e894d48dc" translate="yes" xml:space="preserve">
          <source>In C++ code, this allows member names in structures to be similar to previous types declarations.</source>
          <target state="translated">C ++ 코드에서 이는 구조의 멤버 이름이 이전 유형 선언과 유사 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c8175f71005ecf03750f6f6a8eb8dfe31c736137" translate="yes" xml:space="preserve">
          <source>In C++ the value of an object is only affected by changes within its lifetime: when the constructor begins, the object has an indeterminate value, and any changes during the lifetime of the object are dead when the object is destroyed. Normally dead store elimination will take advantage of this; if your code relies on the value of the object storage persisting beyond the lifetime of the object, you can use this flag to disable this optimization. To preserve stores before the constructor starts (e.g. because your operator new clears the object storage) but still treat the object as dead after the destructor you, can use</source>
          <target state="translated">C ++에서 객체의 값은 수명 내 변경에 의해서만 영향을받습니다. 생성자가 시작될 때, 객체는 불확실한 값을 가지며, 객체 수명이 다할 때 변경 사항은 사라집니다. 일반적으로 죽은 상점 제거는이를 활용합니다. 코드가 객체 수명보다 오래 지속되는 객체 스토리지의 값에 의존하는 경우이 플래그를 사용하여이 최적화를 비활성화 할 수 있습니다. 생성자가 시작하기 전에 상점을 보존하려면 (예 : 연산자 new가 객체 스토리지를 지우므로) 소멸자 이후에도 객체를 죽은 것으로 취급하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="168fb41a49baf3aa442f73f3ecb6a40cd4d6ca59" translate="yes" xml:space="preserve">
          <source>In C++, &amp;lsquo;</source>
          <target state="translated">C ++에서 '</target>
        </trans-unit>
        <trans-unit id="1bcce97889f7dbf32fa6b64e8c64b08099b3f7a1" translate="yes" xml:space="preserve">
          <source>In C++, attribute visibility (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.</source>
          <target state="translated">C ++에서는 속성 가시성 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 )을 클래스, 구조체, 공용체 및 열거 형 유형에 적용 할 수도 있습니다. 다른 유형 속성과 달리 속성은 초기 키워드와 유형 이름 사이에 나타나야합니다. 유형의 본문 다음에는 나타날 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41407820aea4af6aceb3725e14d20bcfa5717ed8" translate="yes" xml:space="preserve">
          <source>In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template.</source>
          <target state="translated">C ++에서 템플리트 인수의 가시성이 제한되면이 제한 사항이 내재적으로 템플리트 인스턴스화로 전파됩니다. 그렇지 않으면 템플릿 인스턴스화 및 전문화가 기본적으로 템플릿의 가시성으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="453e27477f405b0f81788514a49ffd79d08ff550" translate="yes" xml:space="preserve">
          <source>In C++, if an initializer is present for a thread-local variable, it must be a &lt;var&gt;constant-expression&lt;/var&gt;, as defined in 5.19.2 of the ANSI/ISO C++ standard.</source>
          <target state="translated">C ++에서 스레드 로컬 변수에 이니셜 라이저가있는 경우 ANSI / ISO C ++ 표준의 5.19.2에 정의 된대로 &lt;var&gt;constant-expression&lt;/var&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e8da9f4a402f87aeb0e1e0768c85b6e521a3ae7" translate="yes" xml:space="preserve">
          <source>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the &amp;lsquo;</source>
          <target state="translated">C ++에서 PMF (Pointer to Member Function)는 가능한 모든 호출 메커니즘을 처리하기 위해 다양한 종류의 포인터를 사용하여 구현됩니다. PMF는 '</target>
        </trans-unit>
        <trans-unit id="34a26947af0331ebcf8b3ff5e4127f49a113bd19" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;ifunc&lt;/code&gt; attribute takes a string that is the mangled name of the resolver function. A C++ resolver for a non-static member function of class &lt;code&gt;C&lt;/code&gt; should be declared to return a pointer to a non-member function taking pointer to &lt;code&gt;C&lt;/code&gt; as the first argument, followed by the same arguments as of the implementation function. G++ checks the signatures of the two functions and issues a</source>
          <target state="translated">C ++에서 &lt;code&gt;ifunc&lt;/code&gt; 속성은 리졸버 함수의 맹 글링 된 문자열을 사용합니다. 는 C ++ 클래스의 비 정적 멤버 함수 리졸버 &lt;code&gt;C&lt;/code&gt; 는 포인터를 취하는 비 멤버 함수에 대한 포인터를 리턴하도록 선언되어야 &lt;code&gt;C&lt;/code&gt; 구현의 기능과 동일한 인수 뒤에 첫 번째 인수로서. G ++은 두 함수의 서명을 확인하고</target>
        </trans-unit>
        <trans-unit id="dae3c25a08855a03a679edfb667679b322123fbc" translate="yes" xml:space="preserve">
          <source>In C++, the logic operators &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; are available for vectors. &lt;code&gt;!v&lt;/code&gt; is equivalent to &lt;code&gt;v == 0&lt;/code&gt;, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; and &lt;code&gt;a || b&lt;/code&gt; is equivalent to &lt;code&gt;a!=0 | b!=0&lt;/code&gt;. For mixed operations between a scalar &lt;code&gt;s&lt;/code&gt; and a vector &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; is equivalent to &lt;code&gt;s?v!=0:0&lt;/code&gt; (the evaluation is short-circuit) and &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; is equivalent to &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt;.</source>
          <target state="translated">C ++에서 논리 연산자 &lt;code&gt;!, &amp;amp;&amp;amp;, ||&lt;/code&gt; 벡터에 사용할 수 있습니다. &lt;code&gt;!v&lt;/code&gt; 동등 &lt;code&gt;v == 0&lt;/code&gt; , &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 동등 &lt;code&gt;a!=0 &amp;amp; b!=0&lt;/code&gt; 및 &lt;code&gt;a || b&lt;/code&gt; 는 &lt;code&gt;a!=0 | b!=0&lt;/code&gt; . 스칼라 &lt;code&gt;s&lt;/code&gt; 와 벡터 &lt;code&gt;v&lt;/code&gt; 사이의 혼합 연산의 경우 &lt;code&gt;s &amp;amp;&amp;amp; v&lt;/code&gt; 는 &lt;code&gt;s?v!=0:0&lt;/code&gt; (평가는 단락)이며 &lt;code&gt;v &amp;amp;&amp;amp; s&lt;/code&gt; 는 &lt;code&gt;v!=0 &amp;amp; (s?-1:0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260b901dabc2f639a1fcfb92f83b3a8bfc6792cb" translate="yes" xml:space="preserve">
          <source>In C++, the ternary operator &lt;code&gt;?:&lt;/code&gt; is available. &lt;code&gt;a?b:c&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are vectors of the same type and &lt;code&gt;a&lt;/code&gt; is an integer vector with the same number of elements of the same size as &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, computes all three arguments and creates a vector &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt;. Note that unlike in OpenCL, &lt;code&gt;a&lt;/code&gt; is thus interpreted as &lt;code&gt;a != 0&lt;/code&gt; and not &lt;code&gt;a &amp;lt; 0&lt;/code&gt;. As in the case of binary operations, this syntax is also accepted when one of &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; is a scalar that is then transformed into a vector. If both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are scalars and the type of &lt;code&gt;true?b:c&lt;/code&gt; has the same size as the element type of &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are converted to a vector type whose elements have this type and with the same number of elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">C ++에서는 삼항 연산자 &lt;code&gt;?:&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;a?b:c&lt;/code&gt; (여기서 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 는 동일한 유형의 벡터이고 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 와 같은 크기의 동일한 수의 요소를 가진 정수 벡터 임), 세 개의 인수를 모두 계산하고 벡터 &lt;code&gt;{a[0]?b[0]:c[0], a[1]?b[1]:c[1], &amp;hellip;}&lt;/code&gt; . OpenCL과 달리 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;a &amp;lt; 0&lt;/code&gt; 아닌 &lt;code&gt;a != 0&lt;/code&gt; 으로 해석됩니다 . 이항 연산의 경우와 마찬가지로이 구문은 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 중 하나 가 스칼라 일 때 허용 되며 벡터로 변환됩니다. 둘 다 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 스칼라와의 유형 &lt;code&gt;true?b:c&lt;/code&gt; 의 요소의 형태와 같은 크기의 보유 &lt;code&gt;a&lt;/code&gt; 그리고, &lt;code&gt;b&lt;/code&gt; 그리고 &lt;code&gt;c&lt;/code&gt; 요소가 본 형태와 같은 수의 요소에있는 벡터 형태로 변환 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8e3384895cb64dc59dfb4ef3c2eae30e005995" translate="yes" xml:space="preserve">
          <source>In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type.</source>
          <target state="translated">C ++에서는 공개 속성이 함수와 객체뿐만 아니라 유형에도 적용됩니다. C ++ 유형에는 링크가 있기 때문입니다. 클래스는 정적이 아닌 데이터 멤버 유형 및 기본보다 가시성이 높아서는 안되며 클래스 멤버는 기본적으로 클래스의 가시성을 기본으로 설정합니다. 또한 명시적인 가시성이없는 선언은 해당 유형의 가시성으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9870b14c476e69190f3f39c0be8be66122cac26a" translate="yes" xml:space="preserve">
          <source>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;assume_aligned&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;format_arg&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;nonnull&lt;/code&gt; is declared without it. Attributes &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;warning&lt;/code&gt; suppress the warning. (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C ++에서 &lt;code&gt;alloc_align&lt;/code&gt; , &lt;code&gt;alloc_size&lt;/code&gt; , &lt;code&gt;assume_aligned&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;format_arg&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; 또는 &lt;code&gt;nonnull&lt;/code&gt; 속성으로 선언 된 기본 템플리트의 명시 적 특수화 가 선언되지 않은 경우 경고가 발행됩니다 . &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;warning&lt;/code&gt; 속성 은 경고를 표시 하지 않습니다 . ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9914fa32f31272fbd1b3c9fd5655fe7c161328ef" translate="yes" xml:space="preserve">
          <source>In C++, this attribute does not depend on &lt;code&gt;extern&lt;/code&gt; in any way, but it still requires the &lt;code&gt;inline&lt;/code&gt; keyword to enable its special behavior.</source>
          <target state="translated">C ++에서이 속성은 어떤 식 으로든 &lt;code&gt;extern&lt;/code&gt; 에 의존하지 않지만 특수 동작을 사용 하려면 여전히 &lt;code&gt;inline&lt;/code&gt; 키워드가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1330ec9305a2cf36952504f041eeaa71d08a1559" translate="yes" xml:space="preserve">
          <source>In C++, this pragma silently applies only to declarations with &amp;ldquo;C&amp;rdquo; linkage. Again, &lt;code&gt;asm&lt;/code&gt; labels do not have this restriction.</source>
          <target state="translated">C ++에서이 pragma는 &quot;C&quot;연결이있는 선언에만 자동 적용됩니다. 또한 &lt;code&gt;asm&lt;/code&gt; 레이블에는이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f1560146bfb02b0050b7346bcee56f1168f8456" translate="yes" xml:space="preserve">
          <source>In C++, this switch only affects the &lt;code&gt;typeof&lt;/code&gt; keyword, since &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; are standard keywords. You may want to use the</source>
          <target state="translated">C ++에서이 스위치에만 영향을 미치는 &lt;code&gt;typeof&lt;/code&gt; 키워드, 이후 &lt;code&gt;asm&lt;/code&gt; 하고 &lt;code&gt;inline&lt;/code&gt; 표준 키워드입니다. 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83513182660c016337c6a43ced48177d4ad0ef0c" translate="yes" xml:space="preserve">
          <source>In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden.</source>
          <target state="translated">C ++에서는 가시성 속성을 사용하여 클래스의 멤버 함수 및 정적 멤버 변수를 표시 할 수 있습니다. 이것은 특정 메소드 나 정적 멤버 변수를 하나의 공유 객체에서만 사용해야한다는 것을 알고있는 경우에 유용합니다. 클래스의 나머지 부분에 기본 가시성이있는 동안 숨겨진 것으로 표시 할 수 있습니다. 하나의 정의 규칙을 위반하지 않도록주의해야합니다. 예를 들어, 전체 클래스를 숨김으로 표시하지 않고 인라인 메소드를 숨김으로 표시하는 것은 일반적으로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1263d4b3bd19eaa09ddd9de78312a5a79d915aa7" translate="yes" xml:space="preserve">
          <source>In C++14, &lt;code&gt;f&lt;/code&gt; calls &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt;, but in C++17 it calls &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">C ++ 14에서 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;f&amp;lt;void(*)()&amp;gt;&lt;/code&gt; 호출하지만 C ++ 17에서는 &lt;code&gt;f&amp;lt;void(*)()noexcept&amp;gt;&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a3eaf8f9d1fd2934be9e06d429d221c630b5bf0a" translate="yes" xml:space="preserve">
          <source>In C++17, the compiler is required to omit these temporaries, but this option still affects trivial member functions.</source>
          <target state="translated">C ++ 17에서 컴파일러는 이러한 임시를 생략해야하지만이 옵션은 여전히 ​​사소한 멤버 함수에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2fd9362a64ee90151b4f33ed9f7535e5f0047820" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is yet another name for &lt;code&gt;__func__&lt;/code&gt;, except that at file (or, in C++, namespace scope), it evaluates to the string &lt;code&gt;&quot;top level&quot;&lt;/code&gt;. In addition, in C++, &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; contains the signature of the function as well as its bare name. For example, this program:</source>
          <target state="translated">C에서 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; 은 &lt;code&gt;__func__&lt;/code&gt; 의 또 다른 이름으로 , 파일 (또는 C ++에서는 네임 스페이스 범위)에서 문자열 &lt;code&gt;&quot;top level&quot;&lt;/code&gt; 로 평가됩니다 . 또한 C ++에서 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; 에는 함수의 서명과 베어 이름이 포함되어 있습니다. 예를 들어이 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89c3cbeabc9fb0c94d32392b571a5dbe1ffa12b0" translate="yes" xml:space="preserve">
          <source>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of &lt;code&gt;foo&lt;/code&gt; in C++ would have undefined behavior because the lifetime of the array ends after the declaration of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">C에서 복합 리터럴은 정적 또는 자동 저장 기간을 사용하여 명명되지 않은 객체를 지정합니다. C ++에서 복합 리터럴은 전체 표현식이 끝날 때까지만 존재하는 임시 객체를 지정합니다. 결과적으로 복합 리터럴의 하위 오브젝트 주소를 사용하는 잘 정의 된 C 코드는 C ++에서 정의되지 않을 수 있으므로 G ++는 임시 배열을 포인터로 변환하는 것을 거부합니다. 함수 내부에서 나타난 배열 화합물 리터럴 예 상술 경우 예를 들어, 임의의 후속 사용 &lt;code&gt;foo&lt;/code&gt; 는 C ++에서 때문에 어레이의 수명 종료 선언 후 정의되지 않은 동작을 가질 것이다 &lt;code&gt;foo&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="b955553d29e649b19193fbacbc412a24a27d538d" translate="yes" xml:space="preserve">
          <source>In C, emit &lt;code&gt;static&lt;/code&gt; functions that are declared &lt;code&gt;inline&lt;/code&gt; into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the &lt;code&gt;extern inline&lt;/code&gt; extension in GNU C90. In C++, emit any and all inline functions into the object file.</source>
          <target state="translated">C에서는 함수가 모든 호출자에게 인라인 된 경우에도 객체 파일에 &lt;code&gt;inline&lt;/code&gt; 으로 선언 된 &lt;code&gt;static&lt;/code&gt; 함수를 생성합니다. 이 스위치는 GNU C90에서 &lt;code&gt;extern inline&lt;/code&gt; 확장을 사용하는 기능에는 영향을 미치지 않습니다 . C ++에서 모든 인라인 함수를 객체 파일로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3058a9d60ea1ade68bb14049e675f5bf83c7026b" translate="yes" xml:space="preserve">
          <source>In C, if the function is neither &lt;code&gt;extern&lt;/code&gt; nor &lt;code&gt;static&lt;/code&gt;, then the function is compiled as a standalone function, as well as being inlined where possible.</source>
          <target state="translated">C에서 함수가 &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 이 아닌 경우 함수는 독립형 함수로 컴파일되고 가능한 경우 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="e352da7bd9ce1ec016de9e2458664a9340519a89" translate="yes" xml:space="preserve">
          <source>In C/C++, every &lt;code&gt;else&lt;/code&gt; branch belongs to the innermost possible &lt;code&gt;if&lt;/code&gt; statement, which in this example is &lt;code&gt;if (b)&lt;/code&gt;. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost &lt;code&gt;if&lt;/code&gt; statement so there is no way the &lt;code&gt;else&lt;/code&gt; can belong to the enclosing &lt;code&gt;if&lt;/code&gt;. The resulting code looks like this:</source>
          <target state="translated">C / C ++에서 &lt;code&gt;else&lt;/code&gt; 모든 분기는 가능한 가장 안쪽의 &lt;code&gt;if&lt;/code&gt; 문에 속하며 ,이 예에서는 &lt;code&gt;if (b)&lt;/code&gt; 입니다. 프로그래머가 선택한 들여 쓰기로 위의 예에서 설명했듯이 프로그래머가 예상 한 것이 아닙니다. 이 혼동 가능성이 있으면 GCC는이 플래그가 지정 될 때 경고를 발행합니다. 경고를 제거하려면 맨 안쪽 &lt;code&gt;if&lt;/code&gt; 문 에 명시 적 괄호를 추가 하여 &lt;code&gt;else&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; 가 둘러싸는 if에 속할 수있는 방법이 없습니다 . 결과 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69cc3b441acbdbe11472c325735b27c046d27c5c" translate="yes" xml:space="preserve">
          <source>In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if &lt;code&gt;A&lt;/code&gt; is a class, then</source>
          <target state="translated">G ++에서 명령문 표현식의 결과 값은 배열 및 함수 포인터 붕괴를 겪고 값으로 묶는 표현식으로 리턴됩니다. 예를 들어 &lt;code&gt;A&lt;/code&gt; 가 클래스 인 경우</target>
        </trans-unit>
        <trans-unit id="2b79b7c58963843a8ca543d9e2a4ed22f6af9388" translate="yes" xml:space="preserve">
          <source>In GNU C and C++, you can use function attributes to specify certain function properties that may help the compiler optimize calls or check code more carefully for correctness. For example, you can use attributes to specify that a function never returns (&lt;code&gt;noreturn&lt;/code&gt;), returns a value depending only on the values of its arguments (&lt;code&gt;const&lt;/code&gt;), or has &lt;code&gt;printf&lt;/code&gt;-style arguments (&lt;code&gt;format&lt;/code&gt;).</source>
          <target state="translated">GNU C 및 C ++에서는 함수 속성을 사용하여 컴파일러가 호출을 최적화하거나 코드의 정확성을보다 신중하게 검사하는 데 도움이되는 특정 함수 속성을 지정할 수 있습니다. 예를 들어, 속성을 사용하여 함수가 절대로 반환하지 않거나 ( &lt;code&gt;noreturn&lt;/code&gt; ), 인수의 값 ( &lt;code&gt;const&lt;/code&gt; ) 에만 의존하는 값을 반환 하거나 &lt;code&gt;printf&lt;/code&gt; 스타일 인수 ( &lt;code&gt;format&lt;/code&gt; )를 갖도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="099e4a52fb6ed11fab7818dcdc84803658fe6ac9" translate="yes" xml:space="preserve">
          <source>In GNU C, addition and subtraction operations are supported on pointers to &lt;code&gt;void&lt;/code&gt; and on pointers to functions. This is done by treating the size of a &lt;code&gt;void&lt;/code&gt; or of a function as 1.</source>
          <target state="translated">GNU C에서 덧셈과 뺄셈 연산은 &lt;code&gt;void&lt;/code&gt; 에 대한 포인터와 함수에 대한 포인터에서 지원됩니다. 이것은 &lt;code&gt;void&lt;/code&gt; 또는 함수 의 크기를 1로 처리하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="cca3c66936552d4dc4ee0493549030694bbe3a79" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear after the colon following a label, other than a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</source>
          <target state="translated">GNU C에서 속성 지정자 목록은 &lt;code&gt;case&lt;/code&gt; 나 &lt;code&gt;default&lt;/code&gt; 레이블 이외의 레이블 다음에 콜론 뒤에 나타날 수 있습니다 . 속성 지정자가 바로 뒤에 세미콜론 (즉, 레이블이 빈 명령문에 적용됨)이있는 경우 GNU C ++는 레이블의 속성 만 허용합니다. 세미콜론이 없으면 C ++ 레이블 속성은 애트리뷰트 목록으로 시작할 수있는 선언이 C ++로 레이블링 될 수 있으므로 모호합니다. C90 또는 C99에서는 선언에 레이블을 지정할 수 없으므로 모호성이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00f091378926e345c0e4332aa146832525cddb05" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of a null statement. The attribute goes before the semicolon.</source>
          <target state="translated">GNU C에서, 속성 지정자 목록은 널 명령문의 일부로 나타날 수 있습니다. 속성은 세미콜론 앞에갑니다.</target>
        </trans-unit>
        <trans-unit id="1b43625a41fcbb3b41411d6343924dd766870911" translate="yes" xml:space="preserve">
          <source>In GNU C, an attribute specifier list may appear as part of an enumerator. The attribute goes after the enumeration constant, before &lt;code&gt;=&lt;/code&gt;, if present. The optional attribute in the enumerator appertains to the enumeration constant. It is not possible to place the attribute after the constant expression, if present.</source>
          <target state="translated">GNU C에서, 속성 지정자 목록은 열거 자의 일부로 나타날 수 있습니다. 존재하는 경우, 속성은 열거 상수 뒤 &lt;code&gt;=&lt;/code&gt; 앞에옵니다 . 열거 자의 선택적 속성은 열거 상수에 적용됩니다. 상수 표현식 (있는 경우) 뒤에 속성을 배치 할 수 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
