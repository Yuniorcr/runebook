<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 위한 부호있는 16 비트 .</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">부호있는 16 비트 상수 (산술 명령어 용).</target>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">하위 16 비트가 0 인 부호있는 32 비트 상수. 이러한 상수는 &lt;code&gt;lui&lt;/code&gt; 를 사용하여로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">단일 레지스터. &lt;var&gt;n&lt;/var&gt; 이 0 내지 7의 범위에 있으면 , 대응하는 D 레지스터. 이 경우 , 다음 레지스터 P0. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">스펙은 [ '</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">상태 레지스터 ( &lt;code&gt;rmsr&lt;/code&gt; , &lt;code&gt;$fcc1&lt;/code&gt; ~ &lt;code&gt;$fcc7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">피연산자의 배치에 대한 제한 조건을 지정하는 문자열 상수. 자세한 내용은 &lt;a href=&quot;constraints#Constraints&quot;&gt;제약 조건&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">가요 성 어레이 부재를 포함하는 구조체, 또는 이러한 구조를 포함하는 결합 (재귀 적으로)은 구조체의 멤버 또는 어레이의 요소가 아닐 수 있습니다. 그러나 이러한 사용은 GCC에서 확장으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">현재 파일의 텍스트 세그먼트에있는 기호</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">기호 참조.</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">기호 피연산자 또는 got, tls 또는 pc 기준 참조의 16 비트 조각입니다.</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">참조 유형이 아닌 유형이 아닌 템플릿 매개 변수가있는 템플릿이 잘못 엉망이되었습니다.</target>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">스윙 모듈로 스케줄러가 고려한 평균 루프 수에 대한 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">트램폴린은 중첩 함수의 주소를 가져올 때 스택에서 런타임에 만들어지고 중첩 함수를 간접적으로 호출하는 데 사용되는 작은 코드 조각입니다. 따라서 프로그램이 제대로 작동하려면 스택을 실행 가능하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">상점마다로드에 대한 진정한 의존성은 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">이 옵션의 일반적인 사용은 부동 소수점 레지스터를 사용하지 않으므로 커널을 빌드하여 저장 및 복원 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">이 컨텍스트에서 유효한 &lt;code&gt;NULL&lt;/code&gt; 은 객체 포인터 유형에서 0으로 정의됩니다. 시스템 이 정수 유형으로 &lt;code&gt;NULL&lt;/code&gt; 매크로를 정의하는 경우 명시 적 캐스트를 추가해야합니다. 설치하는 동안 GCC는 시스템 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 헤더를 NULL을 적절히 재정의하는 사본으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">이 옵션의 값을 제공해야합니다. 가능한 값은</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">값이 -1이면 임계 값이 없으므로 모든 보폭에 대해 프리 페치 힌트를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">벡터 상수</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">벡터 상수는 중괄호 안에있는 상수 식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">벡터 상수가 초기화하는 변수와 유형이 같으면 벡터 초기화 프로그램에 캐스트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">약한 참조는 자체적으로 대상 기호에 대한 정의가 필요하지 않은 별명입니다. 대상 기호가 약한 참조를 통해서만 참조되는 경우 &lt;code&gt;weak&lt;/code&gt; 정의되지 않은 기호가됩니다. 그러나 직접 참조하는 경우, 그러한 강력한 참조가 우선하며, 반드시 동일한 번역 단위에 해당되는 것이 아니라 기호에 대한 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">AArch64 제품군 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">ABI 적합성</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">부록 : 문서에이 라이센스를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">AES 지침.</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">AIX TOC 항목</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">RS / 6000의 AIX는 미국 이외의 환경에 대한 지원 (NLS)을 제공합니다. 컴파일러와 어셈블러는 NLS를 사용하여 부동 소수점 숫자를 포함하여 다양한 객체의 로케일 별 표현을 지원합니다 ( '</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">MMX, 3dNOW !, 향상된 3DNow!를 갖춘 AMD Athlon CPU! 및 SSE 프리 페치 명령어 지원.</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMD CPU.</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMD Family 10h 바르셀로나 CPU.</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMD 제품군 10h CPU.</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMD Family 10h 이스탄불 CPU.</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMD 패밀리 10h 상하이 CPU.</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">AMD 제품군 14 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 1.</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 2.</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 3.</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 4.</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMD 제품군 15 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이는 BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4를 슈퍼 셋으로 설정합니다. .2, ABM 및 64 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64 비트를 슈퍼 셋으로 설정합니다. 명령어 세트 확장.)</target>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64를 수퍼 셋합니다. 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">AMD 제품군 16 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">AMD 제품군 17 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMD 제품군 17h Zen 버전 1.</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMD 제품군 17h Zen 버전 2.</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 17h 코어 기반 CPU. (이것은 BMI, BMI2,, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT 및 64 비트 명령어 세트 확장.)</target>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 17h 코어 기반 CPU. (이는 BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4를 슈퍼 셋으로 설정합니다. , SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT 및 64 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">MMX 및 3DNow! 명령 세트 지원.</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">MMX 명령어 세트를 지원하는 AMD K6 CPU.</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">아크 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX (dpfp) 64 비트 레지스터. &lt;code&gt;D0&lt;/code&gt; , &lt;code&gt;D1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">ARC HS SIMD 지원.</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">ARM 제품군</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">ARM 대상은 반 정밀도 부동 소수점 값에 대해 호환되지 않는 두 가지 표현을 지원합니다. 표현 중 하나를 선택하여 프로그램에서 일관되게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">AVR 제품군 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVX 지침.</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">AVX2 지침.</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS 지침.</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW 지침.</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG 지침.</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW 지침.</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">AVX512CD 지침.</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ 지침.</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">AVX512ER 지침.</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">AVX512F 지침.</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA 지침.</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">AVX512PF 지침.</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI 지침.</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 지침.</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">AVX512VL 지침.</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI 지침.</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ 명령.</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">현재 거래를 중단하십시오. 활성화 된 트랜잭션이없는 경우 이는 작동하지 않습니다. &lt;var&gt;status&lt;/var&gt; 8 비트의 정수이고; 그 값은 &lt;code&gt;_xbegin&lt;/code&gt; 의 반환 값으로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; )의 절대 비교 .</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 스칼라 값 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; )의 절대 비교 .</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">절대 값 ( &lt;code&gt;abs.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">동의하기 '</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">허수, 고정 소수점 또는 기계 정의 리터럴 번호 접미사를 GNU 확장으로 받아들입니다. 이 옵션을 끄면 이러한 접미사는 C ++ 11 사용자 정의 리터럴 숫자 접미사로 처리됩니다. 이것은 모든 C ++ 11 이전 방언과 모든 GNU 방언에 기본적으로 켜져 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">Microsoft 헤더 파일에 사용 된 일부 비표준 구성을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">Plan 9 코드에 사용 된 일부 비표준 구성을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">식별자에 범용 문자 이름을 사용하십시오. 이 옵션은 C99 (및 이후 C 표준 버전) 및 C ++에 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">명명 된 매개 변수없이 가변 함수를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">이 속성을 가진 유형에 대한 포인터를 통한 액세스는 유형 기반 별명 분석의 대상이 아니라 다른 유형의 객체에 별명을 지정할 수 있다고 가정합니다. C99 표준의 섹션 6.5 단락 7의 맥락에서, 그러한 포인터를 참조하는 lvalue 표현식은 문자 유형을 갖는 것으로 취급됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">휘발성 객체에서도 비트 필드에 대한 액세스는 바이트 또는 단어와 같은 더 큰 객체에 액세스하여 작동합니다. 비트 필드를 읽거나 쓰기 위해 어떤 크기의 오브젝트에 액세스 할 수 있는지에 대해서는 의존 할 수 없습니다. 정확한 사용법에 따라 주어진 비트 필드마다 다를 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">비 휘발성 개체에 대한 액세스는 휘발성 액세스와 관련하여 정렬되지 않습니다. 비 휘발성 메모리에 쓰기 순서를 지정하기 위해 휘발성 객체를 메모리 장벽으로 사용할 수 없습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">변수에 대한 액세스는 평소와 같이 최적화 될 수 있으며 변수의 관찰 가능한 값이 영향을받지 않는 한 레지스터는 할당 및 계산에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">입력 / 출력 피연산자를 사용하지 않고 (예 : 어셈블러 템플릿에서 직접 전역 기호 사용) C 프로그램에서 데이터에 액세스하면 예상대로 작동하지 않을 수 있습니다. 마찬가지로 어셈블러 템플릿에서 직접 함수를 호출하려면 대상 어셈블러 및 ABI에 대한 자세한 이해가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">C 표준에 따르면 이러한 표현식은 유형이 원래 유형의 규정되지 않은 버전 인 rvalue입니다 (예 : &lt;code&gt;int&lt;/code&gt; ) . GCC가이를 지적하는 휘발성 개체의 읽기로 해석하는지 또는 부작용에 대한 표현식을 평가하기위한 요청으로 해석할지 여부는이 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">'에 대한 옵션을 누적</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">발신 함수 인수를 누적하고 함수 프롤로그 / 에필로그에서 발신 함수 인수에 필요한 스택 공간을 한 번 확보 / 해제합니다. 이 옵션이 없으면, 나가는 인수는 함수를 호출하기 전에 푸시되고 이후에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">누산기 레지스터.</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">라이브러리 단위 본문 (하위 프로그램 또는 패키지 본문)을 포함하는 Ada 소스 코드 파일. 이러한 파일은 &lt;em&gt;body&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">라이브러리 단위 선언 (패키지, 서브 프로그램 또는 일반 또는 일반 인스턴스화 선언) 또는 라이브러리 단위 이름 바꾸기 선언 (패키지, 일반 또는 서브 프로그램 이름 바꾸기 선언)을 포함하는 Ada 소스 코드 파일. 이러한 파일을 &lt;em&gt;specs&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">단락 1의 목록에 &quot;스레드 저장 기간&quot;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">오프셋 가능한 메모리 참조에 8 바이트를 추가하십시오. 높은 8 바이트의 SSE 값에 액세스 할 때 유용합니다. (% rax)의 memref의 경우</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">단락 1의 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">단락 3의 지정자 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">단락 1의 스토리지 클래스 지정자 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">단락 3 이후에 추가</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">단락 4 이후에 추가</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">단락 5 이후에 추가</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">단락 6 이후에 추가</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">프로그램 흐름 &lt;em&gt;아크&lt;/em&gt; 가 계측 되도록 코드를 추가하십시오 . 실행하는 동안 프로그램은 각 분기 및 호출이 몇 번 실행되었는지와 몇 번이나 가져 오거나 리턴했는지 기록합니다. 우선 순위가 지원되는 생성자를 지원하는 대상에서 프로파일 링은 전역 변수의 유형으로 사용되는 클래스의 생성자, 소멸자 및 C ++ 생성자 (및 소멸자)를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">인공 변수, 외부 참조 및 호출 사이트 매개 변수 DIE와 같이 이름 속성이없는 일부 DWARF DIE에 설명 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">디렉토리 추가 &lt;var&gt;dir&lt;/var&gt; 검색 할 디렉토리 목록에</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">단락 1 뒤에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">6 항 뒤에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">단락 3 이전에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">HP-UX 에서 &lt;em&gt;dce 스레드&lt;/em&gt; 라이브러리를 사용하여 멀티 스레딩 지원을 추가하십시오 . 이 옵션은 전처리 기와 링커 모두에 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">디렉토리 추가 &lt;var&gt;dir&lt;/var&gt; 디렉토리의 목록은 전처리시 헤더 파일을 검색합니다. &lt;var&gt;dir&lt;/var&gt; 이 '로 시작 하면</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">헤더 파일을 검색 할 디렉토리 목록의 헤드에 프레임 워크 디렉토리 &lt;var&gt;dir&lt;/var&gt; 를 추가하십시오 . 이 디렉토리는 다음에 의해 지정된 디렉토리와 인터리브됩니다</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">추가 부동 유형.</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">명령 행 옵션으로 요청하면 추가 블록 정보가 각 행에 성공할 수 있습니다. &lt;var&gt;execution_count&lt;/var&gt; 은 '입니다</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">128 비트 부동 소수점 ( &lt;code&gt;__float128&lt;/code&gt; ) 값 을 효율적으로 사용하기 위해 64 비트 PowerPC 프로세서 제품군에 추가 내장 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">추가 부동 소수점 예외, 반올림 모드, 환경 및 분류 및 매크로 이름 (C99 및 C11 7.6, C99 및 C11 7.12).</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">반환 된 값에 대한 추가 사후 처리가 필요할 수 있습니다 ( &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">추가 레지스터는 일반적으로 프롤로그 및 에필로그에만 사용됩니다 : RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT 및 USP.</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">대상의 스칼라 저장 순서와 관련하여 리버스 스칼라 저장 순서가있는 유형에 대해서는 추가 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">추가로 컴파일 된 함수 인라인</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">또한 기본 AArch64 GNU / Linux 시스템에서 '</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">또한 '</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">또한 &lt;code&gt;CFStringRefs&lt;/code&gt; ( &lt;code&gt;CoreFoundation&lt;/code&gt; 헤더로 정의 )를 형식 인수로 사용할 수도 있습니다. 관련 헤더는 Darwin (OSX) 설치에서만 사용할 수 있습니다. 이러한 설치에서 XCode 및 시스템 문서는 &lt;code&gt;CFString&lt;/code&gt; , &lt;code&gt;CFStringRefs&lt;/code&gt; 및 관련 함수에 대한 설명을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">또한 일부 메시지는 최적화 단계의 구현 세부 정보를 반영하여 다른 메시지 내에 논리적으로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">또한 아키텍처 확장 문자열은 자체적으로 지정할 수 있습니다. 특정 아키텍처 버전 또는 코어를 지정하지 않고도 특정 아키텍처 확장을 켜거나 끄는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">또한 Thumb 실행 상태에 대한 지원이없는 다음 아키텍처는 인식되지만 지원은 사용되지 않습니다. '</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">또한 옵션</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">또한이 옵션은 GCC가 big.LITTLE 시스템의 코드 성능을 조정하도록 지정할 수 있습니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">또한 사용자 정의 리터럴 연산자가 밑줄로 시작하지 않는 리터럴 접미사 식별자로 선언되면 경고합니다. 밑줄로 시작하지 않는 리터럴 접미어 식별자는 향후 표준화를 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">주소베이스 레지스터</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64 비트 명령어가 활성화되어 있거나 NO_REGS 인 경우 주소베이스 레지스터.</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">레지스터에서 색인화되거나 간접적 인 주소 피연산자 ( '</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">세그먼트 레지스터가없는 주소 피연산자</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">주소 레지스터</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">주소 레지스터 (r0을 제외한 일반 목적 레지스터)</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">주소 레지스터 간접 어드레싱 모드</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">주소 레지스터</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">16 비트 폭의 주소 레지스터.</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">24 비트 폭의 주소 레지스터.</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">주소 공간 식별자는 다른 C 유형 한정자 (예 : &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;volatile&lt;/code&gt; ) 와 똑같이 사용될 수 있습니다 . 자세한 내용은 N1275 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">정수 유형의 크기가 동일하고 다음 비트 필드가 공통에 의해 부과 된 경계를 넘지 않고 현재 할당 단위에 맞는 경우 인접한 비트 필드는 동일한 1, 2 또는 4 바이트 할당 단위로 압축됩니다. 비트 필드의 정렬 요구 사항.</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">현재 컴파일 단위에 대해 글로벌 레지스터 변수를 정의한 후 :</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">레지스터 할당 및 사후 레지스터 할당 명령어 분할 후, 해당 연산에 기초한 비교 연산과 유사한 프로세서 플래그를 계산하는 연산 명령어를 식별합니다. 가능하면 명시 적 비교 작업을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">레지스터 할당 및 포스트 레지스터 할당 명령 분할 후 카피 전파 패스를 수행하여 스케줄링 종속성을 줄이고 때로는 카피를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">로 컴파일 된 프로그램을 실행 한 후</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">접두사 후, 하나 개 이상의 추가 제약 (참조가 있어야 &lt;a href=&quot;constraints#Constraints&quot;&gt;제약을&lt;/a&gt; 경우 값이 상주을 설명). 공통 제약 조건에는 '</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">다시 &lt;code&gt;f()&lt;/code&gt; 대한 호출 은 템플릿 인수에 의존하지 않습니다 ( &lt;code&gt;T&lt;/code&gt; 형에 의존하는 인수가 없으며 호출이 종속 컨텍스트에 있어야한다고 지정되지 않음). 따라서 기본 클래스의 선언은 인스턴스화 시간까지 보이지 않기 때문에 이러한 함수의 전역 선언을 사용할 수 있어야합니다. 결과적으로 컴파일러는 다음과 같은 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">이 속성을 가진 집계는 해당 스칼라와 크기가 같더라도 유효하지 않습니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">의 별칭</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">모든 분기 대상을 2의 제곱 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">모든 루프를 32 바이트 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">점프만으로 목표에 도달 할 수있는 분기 목표에 대해 분기 목표를 2의 제곱 경계에 맞 춥니 다. 이 경우 더미 작업을 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">64 비트 경계에서 배가 정렬 이것은 호출 규칙을 변경하므로 표준 C 라이브러리의 일부 함수는 먼저 다시 컴파일하지 않으면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">루프를 2의 제곱 경계에 맞 춥니 다. 루프가 여러 번 실행되면 더미 패딩 명령어를 실행할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">최대 &lt;var&gt;m&lt;/var&gt; -1 바이트 를 건너 뛰면서 &lt;var&gt;n&lt;/var&gt; 보다 큰 다음 2의 제곱에 함수의 시작을 정렬하십시오 . 이는 &lt;var&gt;n&lt;/var&gt; 바이트 정렬 경계를 넘지 않고 CPU에서 함수 의 첫 번째 &lt;var&gt;m&lt;/var&gt; 바이트 이상을 페치 할 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">변수를 정렬합니다 ( &lt;code&gt;alnv.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">모든 조건 레지스터 : SCC, VCCZ, EXECZ</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">모든 의존은 비싸다.</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">에 의해 지정된 모든 파일</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">내재적으로 팝된 모든 입력 레지스터는 내재적으로 팝되지 않은 입력보다 reg-stack의 상단에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">모든 메모리 주문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">모든 모듈은 동일하게 컴파일되어야합니다</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">스레드 스토리지 기간, 동적 스토리지 기간이 없거나 로컬 [&amp;hellip;]이 아닌 모든 오브젝트.</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">모든 루틴은&amp;ldquo;메모리 장벽에 의해 보호되는 변수의 선택적 목록&amp;rdquo;을 취하기 위해 인텔 설명서에 설명되어 있습니다. 그 의미가 무엇인지는 확실하지 않습니다. 그것은 수도 있다는 뜻 &lt;em&gt;에만&lt;/em&gt; 나열된 변수가 보호되고, 또는 추가적인 변수의 목록은 보호되어야 의미 할 수 있었다. 이 목록은 GCC에 의해 무시되며이를 빈 것으로 취급합니다. GCC는 빈 목록을 전역 적으로 액세스 가능한 모든 변수를 보호해야한다는 의미로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">다른 모든 속성</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">모든것 위에</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">모든 기본 정수 유형은 부호있는 유형과 부호없는 유형 인 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; 으로 기본 유형으로 사용할 수 있습니다 . 또한 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 을 사용하여 부동 소수점 벡터 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">모든 데이터 및 읽기 전용 데이터 세그먼트는 512KB 주소 공간 내에 있어야합니다. 텍스트 세그먼트는 16MB 주소 공간 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">모든 텍스트 및 데이터 세그먼트는 4GB 주소 공간 내에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">모든 가시성은 모든 ELF 대상에서 지원되지만 모든 ELF 대상에서 지원되지는 않습니다 (어셈블러에서 '</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">선언 된 가능한 값의 범위에 필요한만큼의 바이트 만 &lt;code&gt;enum&lt;/code&gt; 형에 할당하십시오 . 특히 &lt;code&gt;enum&lt;/code&gt; 형은 충분한 공간이있는 가장 작은 정수 유형과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">가능하면 먼저 읽기 전용 데이터 섹션에 변수를 할당 한 다음 가능하면 작은 데이터 섹션에서 다음에, 그렇지 않으면 데이터에서 변수를 할당하십시오. 이것은 기본값보다 약간 느린 코드를 제공하지만 실행시 필요한 RAM의 양을 줄이므로 일부 임베디드 시스템에서 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">비트 연산에서 임의 크기의 즉각적인 허용.</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">두 번째 및 세 번째 인수에서 유형이 일치하지 않는 조건식을 허용하십시오. 그러한 표현의 가치는 무효입니다. 이 옵션은 C ++에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">메시지 디스패처로 빠르게 점프 할 수 있습니다. 다윈에서 이것은 통신 페이지를 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">다른 수의 요소 및 / 또는 호환되지 않는 요소 유형을 가진 벡터 간의 암시 적 변환을 허용합니다. 이 옵션은 새 코드에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">(a) 인수와 결과가 유효하다고 가정하고 (b) IEEE 또는 ANSI 표준을 위반할 수있는 부동 소수점 산술에 대한 최적화를 허용합니다. 링크 타임에 사용될 때 기본 FPU 제어 단어 또는 기타 유사한 최적화를 변경하는 라이브러리 또는 시작 파일이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">인수와 결과가 NaN 또는 + -Infs가 아니라고 가정하는 부동 소수점 산술에 대한 최적화를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">부호없는 0을 무시하는 부동 소수점 산술에 대한 최적화를 허용합니다. IEEE 산술은 고유 한 +0.0 및 -0.0 값의 동작을 지정하여 x + 0.0 또는 0.0 * x와 같은 식의 단순화를 금지합니다.</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">옵티마이 저가 상점에서 새로운 데이터 레이스를 도입 할 수 있습니다. 허용하려면 1로 설정하고 그렇지 않으면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">컴파일러가 사인 및 코사인 근사값에 대해 &lt;code&gt;fsca&lt;/code&gt; 명령어를 생성하도록 허용하거나 허용하지 않습니다 . 옵션</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">컴파일러가 역 제곱근 근사에 대한 &lt;code&gt;fsrra&lt;/code&gt; 명령어를 생성하도록 허용하거나 허용하지 않습니다 . 옵션</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">일련의 부동 소수점 연산에서 피연산자를 다시 연결할 수 있습니다. 이는 계산 결과를 변경하여 ISO C 및 C ++ 언어 표준을 위반합니다. 참고 : 재정렬은 0의 부호를 변경하고 NaN을 무시하고 언더 플로 또는 오버플로를 금지하거나 만들 수 있으므로 &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; 와 같은 반올림 동작에 의존하는 코드에는 사용할 수 없습니다. 부동 소수점 비교를 재정렬 할 수도 있으므로 순서 비교가 필요할 때는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">더 많은로드 명령의 추론 적 움직임을 허용합니다. 이는 레지스터 할당 전에 스케줄링 할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">일부로드 명령의 추측 동작을 허용합니다. 이는 레지스터 할당 전에 스케줄링 할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">정지 비트를 트리거 한 명령 바로 앞에 정지 비트를 배치 할 수 있습니다. 이렇게하면 명령 예약이 향상 될 수 있지만 항상 그렇게하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">컴파일러가 컴파일되는 언어에 적용 할 수있는 가장 엄격한 앨리어싱 규칙을 가정하도록 허용하십시오. C (및 C ++)의 경우 표현식 유형에 따라 최적화가 활성화됩니다. 특히, 유형이 거의 동일하지 않으면 한 유형의 객체가 다른 유형의 객체와 동일한 주소에 존재하지 않는 것으로 가정합니다. 예를 들어, &lt;code&gt;unsigned int&lt;/code&gt; 별칭 수 &lt;code&gt;int&lt;/code&gt; , 아니지만 &lt;code&gt;void*&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; . 문자 유형은 다른 유형의 별명을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">대상이 '인 경우 컴파일러가 &lt;em&gt;Long Instruction Word&lt;/em&gt; 명령어 를 생성하도록 허용</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">대상이 '인 경우 컴파일러가 &lt;em&gt;SETLB&lt;/em&gt; 및 &lt;em&gt;Lcc&lt;/em&gt; 명령어 를 생성하도록 허용</target>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">열거 유형의 값이 열거의 값 중 하나 일 수 있다는 가정을 사용하여 컴파일러가 최적화하도록 허용합니다 (C ++ 표준에 정의 된대로 기본적으로 모두를 나타내는 데 필요한 최소 비트 수로 표현할 수있는 값). 열거 자). 프로그램이 캐스트를 사용하여 임의의 정수 값을 열거 유형으로 변환하는 경우이 가정이 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">컴파일러가 사용 가능한 모든 레지스터를 사용하도록 허용하십시오. 기본적으로 레지스터 &lt;code&gt;r24..r31&lt;/code&gt; 은 인터럽트 핸들러에서 사용하도록 예약되어 있습니다. 이 옵션을 활성화하면 이러한 레지스터를 일반 기능에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">최적화를 가능하게하는 경우 값을 나누는 대신 값의 역수가 사용되도록합니다. 예를 들어 &lt;code&gt;x / y&lt;/code&gt; 는 &lt;code&gt;x * (1/y)&lt;/code&gt; 로 대체 될 수 있습니다 . 이는 &lt;code&gt;(1/y)&lt;/code&gt; 에 공통 하위 표현식 제거가 적용되는 경우에 유용합니다 . 이로 인해 정밀도가 떨어지고 값에서 작동하는 플롭 수가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">합법적 인 경우, 상점 병합 단계에서 정렬되지 않은 상점을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">분수 고정 소수점 유형의 경우 0으로 반올림하는 대신 잘림을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">로 선택한 DWARF 표준 버전 이후의 확장자 사용 허용</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">&lt;code&gt;__ea&lt;/code&gt; 주소 공간을 일반 주소 공간의 상위 집합으로 취급하도록 허용 / 금지 합니다. 이를 통해 &lt;code&gt;__ea&lt;/code&gt; 와 일반 포인터 간의 명시 적 유형 캐스트 뿐만 아니라 일반 포인터를 &lt;code&gt;__ea&lt;/code&gt; 포인터 로 암시 적으로 변환 할 수 있습니다. 기본적으로 주소 공간 포인터 변환이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; , &lt;code&gt;signed int&lt;/code&gt; 및 &lt;code&gt;unsigned int&lt;/code&gt; 이외의 허용 가능한 비트 필드 유형 (C99 및 C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">대상 코드가 인터 워킹을 위해 컴파일되었는지 여부에 관계없이 함수 포인터 (가상 함수 포함)를 통한 호출이 올바르게 실행되도록합니다. 이 옵션이 활성화 된 경우 함수 포인터를 실행하는 비용에는 약간의 오버 헤드가 있습니다. 인터 워킹은 기본적으로 활성화되어 있으므로 AAPCS 구성에서는이 옵션이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">또한 GCC 벡터화 단일 유동 부문 추가 뉴턴 - 랩슨 벡터화 공정과 함께 상기 열 방출 유의 &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; 과 이미</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">또한 &lt;code&gt;asm goto&lt;/code&gt; 문은 항상 암시 적으로 휘발성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">또한 컴파일러가 비교와 관련된 상수의 크기를 줄이는 경우에 대해서도 경고합니다. 예를 들어, &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; 는 &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; 단순화됩니다 . 이 단순화는 많은 비교에 적용되므로이 경고 수준은 가장 높은 경고 수준에서만보고되므로이 경고 수준은 매우 많은 오 탐지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">또한 비교가 상수로 단순화되는 다른 경우에 대해서도 경고합니다. 예를 들어 : &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; 입니다. &lt;code&gt;abs (INT_MIN)&lt;/code&gt; 가 0보다 작은 &lt;code&gt;INT_MIN&lt;/code&gt; 으로 오버 플로우 되므로 부호있는 정수 오버 플로우가 정의되지 않은 경우에만 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">또한 비교가 단순화 된 다른 경우에 대해서도 경고합니다. 예를 들어, &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; 은 &lt;code&gt;x &amp;gt; 0&lt;/code&gt; 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">위의 경우에서 다루지 않은 다른 단순화에 대해서도 경고하십시오. 예를 들어 : &lt;code&gt;(x * 10) / 5&lt;/code&gt; 는 &lt;code&gt;x * 2&lt;/code&gt; 단순화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">또한에 GNU 확장의 위험 용도에 경고 &lt;code&gt;?:&lt;/code&gt; 생략 중간 피연산자. 언제 상태가 &lt;code&gt;?&lt;/code&gt; : operator는 부울 표현식이며, 생략 된 값은 항상 1입니다. 프로그래머는 종종 조건 표현식 내에서 계산 된 값이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">&lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; 와 같은 비교 가 나타나는 경우에도 경고합니다 . 이것은 &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; 와 동일하며 이는 일반적인 수학 표기법과는 다른 해석입니다.</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">형식 한정자를 안전하지 않은 방식으로 소개하는 캐스트를 만들 때도 경고합니다. 예를 들어, 다음 예제와 같이 &lt;code&gt;char **&lt;/code&gt; 를 &lt;code&gt;const char **&lt;/code&gt; char ** 로 캐스팅하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">또한 일부 내장 함수는 해당 DSP 명령어가 즉시 숫자와 레지스터 피연산자를 모두 허용하거나 즉시 숫자 만 허용하므로 매개 변수로 즉시 숫자를 선호하거나 요구합니다. 즉각적인 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">또한 ABI는 템플릿 인수 팩, &lt;code&gt;const_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , 접두사 증가 / 감소 및 템플릿 인수로 사용되는 클래스 범위 함수의 조작을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">또한 두 가지 특별한 clobber 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">또한 다양한 수의 인수 ( &lt;code&gt;printf&lt;/code&gt; 포함 ) 를 취하는 모든 함수에 대해 함수 프로토 타입을 제공해야합니다 . 그렇지 않으면 해당 함수를 호출 할 때 잘못된 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">OpenMP simd 지시문으로 표시된 루프의 벡터화에 사용되는 비용 모델을 변경하십시오. &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">벡터화에 사용되는 비용 모델을 변경하십시오. &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">사용할 스레드 로컬 스토리지 모델을 변경하십시오 ( &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; 참조 ). &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">프로파일 피드백 기반 최적화를 위해 계측 된 응용 프로그램의 업데이트 방법을 변경하십시오. &lt;var&gt;method&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">또는 괄호로 묶은 실제 C 레이블 이름을 사용하여 레이블을 참조 할 수 있습니다. 예를 들어 &lt;code&gt;carry&lt;/code&gt; 라는 라벨을 참조 하려면 '</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">또는 어떤 바이너리 최적화가 활성화되어 있는지 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">또는 함수 속성 &lt;code&gt;noplt&lt;/code&gt; 를 사용하여 특정 외부 함수에 대한 PLT를 통한 호출을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">또는 사전 컴파일 된 헤더 파일을 디렉토리에 넣고 사용하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">IRA는 충돌 알고리즘 테이블을 압축하기 위해 정교한 알고리즘을 사용하지만, 테이블이 여전히 큰 기능을 수행하려면 과도한 양의 메모리가 필요할 수 있습니다. 함수의 충돌 테이블이이 매개 변수가 제공 한 크기 (MB)보다 클 수있는 경우 레지스터 할당자는 대신 의사 레지스터 충돌 테이블을 작성할 필요가없는 더 빠르고 단순하며 품질이 낮은 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">이러한 모든 경우에 대해 경고하기 위해 노력했지만 G ++이 호환되지 않는 코드를 생성하더라도 경고되지 않은 경우가 있습니다. 생성 된 코드가 호환 되더라도 경고가 발생하는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">이러한 함수를 정의 할 수는 있지만 인수를 읽을 수 없으므로 유용하지 않습니다. 이 구조는 C ++에서 허용되므로 C에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">동작은 Gold Linker의 ICF 최적화와 유사하지만 GCC ICF는 다른 수준에서 작동하므로 최적화는 동일하지 않습니다. GCC에서만 발견되는 동등성과 Gold에서만 발견되는 동등성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">이 속성의 기본 사용법은 POD 유형에 대한 것이지만 생성자에 의해 초기화 된 전역 C ++ 객체에도 속성을 적용 할 수 있습니다. 이 경우 객체를 정의하는 각 변환에서 객체의 정적 초기화 및 소멸 코드가 생성되지만 생성자와 소멸자에 대한 호출은 link-once guard 변수로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">길이가 0 인 배열의 크기는 0이지만 이러한 종류의 배열 구성원은 테일 패딩의 결과로 둘러싸는 유형의 크기를 늘릴 수 있습니다. 엔 클로징 구조의 시작 부분에서 길이가 0 인 배열 멤버의 오프셋은 동일한 유형의 하나 이상의 요소가있는 배열의 오프셋과 동일합니다. 길이가 0 인 배열의 정렬은 요소의 정렬과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">Altivec 레지스터</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">이중로드 / 저장 또는 NO_REGS에 사용할 Altivec 레지스터.</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">float / 32 비트 int로드 / 저장소 또는 NO_REGS에 사용할 Altivec 레지스터.</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">Altivec 벡터 레지스터</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">비트 필드는 항상 &lt;code&gt;int&lt;/code&gt; 크기 로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">항상 도서관 전화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">이러한 변경의 결과 중에는 이름은 동일하지만 다른 공유 객체에 정의 된 동일한 유형의 정적 데이터 멤버가 다르므로 하나를 변경해도 다른 하나는 변경되지 않습니다. 다른 공유 객체에 정의 된 함수 멤버에 대한 포인터는 동일하지 않을 수 있습니다. 이 플래그가 지정되면 이름이 다른 유형을 다르게 정의하는 것은 ODR을 위반하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">정확히 1 비트가 설정된 8 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">요소가 같은 8 요소 벡터 상수입니다.</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; 문을 출력 할 수 없습니다. 이것은 컴파일러의 내부 제한 때문입니다. 제어 전송 명령어는 출력을 가질 수 없습니다. 어셈블러 코드가 아무것도 수정하지 않으면 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 클로버를 사용하여 옵티마이 저가 모든 레지스터 값을 메모리로 플러시하고 필요한 경우 &lt;code&gt;asm&lt;/code&gt; 문 다음에 다시로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 문은 어셈블러 코드에 의해 수정 C 변수의 이름을 나타내는 0 개 이상의 출력 피연산자를 갖는다.</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 유형은 서로 호환으로 간주되지 않습니다 &lt;code&gt;enum&lt;/code&gt; 모두 동일한 정수 유형과 호환 경우에도 유형; 이것이 C 표준이 지정한 것입니다. 예를 들어 &lt;code&gt;enum {foo, bar}&lt;/code&gt; 는 &lt;code&gt;enum {hot, dog}&lt;/code&gt; 와 유사하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">&lt;em&gt;특성 지정자 목록이&lt;/em&gt; 하나 개 이상의 속성 지정자들의 시퀀스이며, 기타 다른 토큰으로 분리된다.</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">&lt;em&gt;특성 지정자&lt;/em&gt; 양식이다 &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; . &lt;em&gt;속성 목록&lt;/em&gt; 의 비어 쉼표로 구분 시퀀스 인 &lt;em&gt;속성&lt;/em&gt; 각 속성은 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">I 형 12 비트 서명 즉시.</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">절대 주소</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">절대 기호 주소 또는 레이블 참조</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">A에 대한 적절한 어드레스 &lt;code&gt;prefetch&lt;/code&gt; 지시 또는 동일한 어드레싱 모드와 임의의 다른 명령의 &lt;code&gt;prefetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">비 매크로로드 또는 저장소에서 사용할 수있는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">범용 레지스터에 보유 된 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">등록 간접 주소 지정 또는 사전 / 사후 증분 / 감소 주소 지정을 포함하지 않는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">위 예제를 작성하는 다른 방법은</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">GCC 2.5 이후로 사용되지 않았지만 GCC에서 여전히 수용하는 대체 구문은 '</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">대상 버퍼의 크기를 늘리는 대안은 서식이 지정된 값의 범위를 제한하는 것입니다. format 지시문에서 정밀도를 지정하여 문자열 인수의 최대 길이를 제한 할 수 있습니다. 형식 지시문의 숫자 인수가 해당 유형의 정밀도보다 작은 것으로 제한 될 수있는 경우 형식 지정자에 적절한 길이 수정자를 선택하면 필요한 버퍼 크기가 줄어 듭니다. 예를 들어, 위의 예에서 &lt;var&gt;a&lt;/var&gt; 와 &lt;var&gt;b&lt;/var&gt; 가 &lt;code&gt;short int&lt;/code&gt; 유형 의 정밀도 내에 있다고 가정 할 수있는 경우 &lt;code&gt;%hi&lt;/code&gt; 형식 지시문 을 사용하거나 인수를 &lt;code&gt;short&lt;/code&gt; 로 캐스팅 하면 버퍼의 최대 필수 크기가 24 바이트로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">1990 년 표준에 대한 개정안은 1995 년에 출판되었습니다.이 개정안 은 언어 에 digraphs와 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 을 추가 했지만 라이브러리와 관련이있었습니다. 이 개정안은 일반적으로 &lt;em&gt;AMD1&lt;/em&gt; 로 알려져 있습니다 . 수정 된 표준은 때때로 &lt;em&gt;C94&lt;/em&gt; 또는 &lt;em&gt;C95&lt;/em&gt; 로 알려져 있습니다. GCC에서이 표준을 선택하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">응용 프로그램은</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">차이점이 가장 분명한 영역은 이름 맹 글링입니다. 다른 이름 맹 글링을 사용하는 것은 의도적으로 더 미묘한 문제로부터 보호하기위한 것입니다. 컴파일러는 클래스 인스턴스 배치 방법, 다중 상속 구현 방법 및 가상 함수 호출 처리 방법 등 C ++ 구현에 대한 많은 내부 세부 사항이 다릅니다. 이름 인코딩이 동일하게 설정되면 프로그램은 다른 컴파일러에서 제공 한 라이브러리와 연결되지만 실행시 프로그램이 중단됩니다. 호환되지 않는 라이브러리는 런타임이 아닌 링크 타임에 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">어셈블러 템플릿은 어셈블러 명령어가 포함 된 리터럴 문자열입니다. 컴파일러는 입력, 출력 및 이동 레이블을 참조하는 템플릿의 토큰을 대체 한 다음 결과 문자열을 어셈블러에 출력합니다. 문자열은 지시문을 포함하여 어셈블러가 인식하는 모든 명령을 포함 할 수 있습니다. GCC는 어셈블러 명령어 자체를 구문 분석하지 않으며, 의미가 무엇인지, 또는 이들이 어셈블러 입력이 유효한지 여부를 모릅니다. 그러나 명령문을 계산합니다 ( &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm의 크기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">원자 연산은 코드 모션을 제한하고 스레드 (예 : 펜스) 간의 동기화를 위해 하드웨어 명령어에 매핑 될 수 있습니다. 이것이 발생하는 정도는 메모리 오더에 의해 제어되며,이 오더는 대략 오름차순으로 나열됩니다. 각 메모리 순서에 대한 설명은 효과를 대략적으로 설명하기위한 것이며 사양이 아닙니다. 정확한 의미론은 C ++ 11 메모리 모델을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">속성 이름 ( &lt;code&gt;unused&lt;/code&gt; 것과 같은 식별자 또는 &lt;code&gt;const&lt;/code&gt; 와 같은 예약어 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">속성 이름 다음에 속성의 괄호로 묶은 매개 변수 목록이 표시됩니다. 이 매개 변수는 다음 형식 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">속성 지정자 목록은 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 지정자의 일부로 나타날 수 있습니다 . &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 키워드 바로 뒤에 또는 닫는 중괄호 뒤에 올 수 있습니다. 전자의 구문이 선호됩니다. 속성 지정자가 닫는 중괄호를 따르는 경우, 형식 지정자가 나타나는 엔 클로징 선언이 아니라 정의 된 구조, 공용체 또는 열거 된 형식과 관련된 것으로 간주되며 정의 된 형식은 속성 지정자 이후까지 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">중첩 된 선언자의 시작 부분에 속성 지정자 목록이 나타날 수 있습니다. 현재이 사용법에는 몇 가지 제한 사항이 있습니다. 속성은 선언자에 올바르게 적용되지만 대부분의 개별 속성에 대해서는 의미가 구현되지 않습니다. 속성 지정 자가 포인터 선언자 의 &lt;code&gt;*&lt;/code&gt; 뒤에 오면 존재하는 모든 형식 한정자와 혼합 될 수 있습니다. 다음은이 구문의 형식적 의미를 설명합니다. ISO C 표준의 선언자 공식 사양에 익숙하다면 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">속성 지정자 목록은 단일 지정자 및 규정 자 목록을 사용하여 둘 이상의 식별자를 선언 할 때 쉼표로 구분 된 선언자 목록에서 선언자 바로 앞에 (첫 번째가 아닌) 나타날 수 있습니다. 이러한 속성 지정자는 선언자가 표시되기 전에 식별자에만 적용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">속성 지정자 목록은 함수 정의 이외의 식별자 선언을 쉼표, &lt;code&gt;=&lt;/code&gt; 또는 세미콜론 바로 앞에 나타날 수 있습니다 . 이러한 속성 지정자는 선언 된 객체 또는 함수에 적용됩니다. 객체 또는 함수의 어셈블러 이름이 지정된 경우 ( &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm 레이블&lt;/a&gt; 참조 ) 속성은 &lt;code&gt;asm&lt;/code&gt; 사양을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">나중에 속성 지정자 목록은 함수 정의에서 선언자 다음에 표시 될 수 있습니다 (이전 스타일 매개 변수 선언 또는 함수 본문 이전).</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">비어있는 대체 문자열은 주어진 범위가 제거됨을 나타냅니다. 빈 범위 (예 : &quot;45 : 3-45 : 3&quot;)는 문자열이 주어진 위치에 삽입 될 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">식별자 뒤에 쉼표와 쉼표로 구분되지 않은 표현식 목록이옵니다. 예를 들어, &lt;code&gt;format&lt;/code&gt; 속성은이 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">식별자. 예를 들어, &lt;code&gt;mode&lt;/code&gt; 속성은이 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">즉시 부동 피연산자 (표현 코드 &lt;code&gt;const_double&lt;/code&gt; 또는 &lt;code&gt;const_vector&lt;/code&gt; )가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">즉시 부동 피연산자 (식 코드 &lt;code&gt;const_double&lt;/code&gt; )는 허용되지만 대상 부동 소수점 형식이 호스트 컴퓨터 (컴파일러가 실행중인)의 형식과 동일한 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">대부분의 산술 명령어를 즉시 제공합니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">시프트 및 회전 명령을 즉시 수행 할 수 있습니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">즉시 정수 피연산자 (상수 값이있는 피연산자)가 허용됩니다. 여기에는 조립시 또는 이후에 값을 알 수있는 기호 상수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">값이 명시 적 정수가 아닌 즉시 정수 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">알려진 숫자 값을 가진 즉시 정수 피연산자가 허용됩니다. 많은 시스템은 단어 너비보다 작은 피연산자에 대해 어셈블리 시간 상수를 지원할 수 없습니다. 이 피연산자에 대한 제약 조건은 '</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">R2 andchi / andci 명령어에 대한 즉각적인 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fsmbi&lt;/code&gt; 로로드 할 수있는 즉시 .</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">중요한주의 사항은 GCC가 컴파일 할 특정 아키텍처 변형에 알려진 레지스터 만 저장하고 복원한다는 것입니다. 이 경우 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 및 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 가 라이브러리에 비해 효율적일 수 있지만 전체 레지스터 세트를 사용하는 코드와 혼합 할 때 부정확하고 신비한 동작이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">출력 피연산자와 일치하도록 제한되지 않는 한 &lt;code&gt;asm&lt;/code&gt; 에 의해 암시 적으로 팝되는 입력 레지스터는 명시 적으로 클로버되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">-255&amp;hellip; 0 범위의 정수 상수</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">0&amp;hellip; 255 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">1&amp;hellip; 15 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">1&amp;hellip; 7 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">코드 제약 조건을 충족하지 않는 정수 상수</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">16 비트에 맞는 정수 상수입니다.</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">하위 16 비트가 0 인 정수 상수입니다.</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">정확히 1을 제외한 모든 비트가 설정된 정수 상수.</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">정확히 단일 비트 세트를 갖는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">누산기 A1에만 사용하기에 적합한 MACFLAG_XXX 상수 중 하나와 동일한 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">하나의 누산기와 함께 사용하기에 적합한 MACFLAG_XXX 상수 중 하나와 동일한 정수.</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">인터럽트 핸들러는 필수 포인터 인수로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">Bext 또는 Bin에 적합한 반전 비트 필드 마스크</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">상수 풀의 항목</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">링크에 직접 공급할 오브젝트 파일. 인식되는 접미사가없는 파일 이름은이 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">스토리지 클래스 지정자 &lt;code&gt;__thread&lt;/code&gt; 로 식별자가 선언 된 오브젝트 에는 &lt;em&gt;스레드 스토리지 기간이&lt;/em&gt; 있습니다. 수명은 전체 스레드 실행이며 저장된 값은 스레드 시작 전에 한 번만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">오프셋 주소</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">오프셋 주소.</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">유효한 메모리 주소 인 피연산자가 허용됩니다. 이것은 &quot;로드 주소&quot;및 &quot;푸시 주소&quot;지침입니다.</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">지정된 피연산자 번호와 일치하는 피연산자가 허용됩니다. 같은 대안 내에서 숫자를 문자와 함께 사용하면 숫자가 마지막에옵니다.</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">관련된 변수의 값이 실제로 오버플로가 발생하지 않는 값인 경우 부호있는 오버플로가 발생하지 않는다고 가정하는 최적화는 완벽하게 안전합니다. 따라서이 경고는 실제로 문제가 아닌 코드에 대한 경고 인 오 탐지를 쉽게 제공 할 수 있습니다. 중요한 문제에 집중할 수 있도록 몇 가지 경고 수준이 정의되어 있습니다. 루프에 필요한 반복 횟수를 예측할 때, 특히 루프의 실행 여부를 결정할 때 정의되지 않은 부호있는 오버플로 사용에 대한 경고는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">이러한 기술에 대한 개요, 장점 및 사용 방법은 &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">부호없는 16 비트 상수 (논리 명령어 용).</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 및 &lt;code&gt;fsmbi&lt;/code&gt; 에 대한 부호없는 16 비트 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">부호없는 16 비트 상수</target>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">16 바이트 회전 및 시프트를위한 ​​부호없는 3 비트 상수</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">부호없는 5 비트 상수</target>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">변환 / 노프 / 채널 명령어를위한 부호없는 7 비트 상수.</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">3 개의 최하위 비트가 0 인 부호없는 7 비트 상수.</target>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">문자열 메모리 인수의 길이를 알 수없는 x86 예제</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">함수 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">추정 된 주소로 어셈블러 명령어에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">컴파일 초기에 사용자 변수에 할당에 주석을 달고 최적화하는 동안 디버그 정보를 개선하기 위해 컴파일 전체에서 주석을 끝까지 전달합니다. 사용</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">어떤 패턴과 대안이 사용되는지를 나타내는 주석으로 어셈블러 출력에 주석을 답니다. 각 명령의 길이와 비용도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">기타 디버깅 정보로 어셈블러 출력에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">링크 타임 최적화를 가능하게하는 또 다른 (간단한) 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">또 다른 결과는 &lt;code&gt;sscanf&lt;/code&gt; 가 형식 제어 문자열 또는 입력으로 문자열 상수를 전달할 때 아주 오래된 일부 시스템에서 작동하지 않는다는 것입니다. &lt;code&gt;sscanf&lt;/code&gt; 가 문자열 상수에 잘못 쓰려고 하기 때문 입니다. 마찬가지로 &lt;code&gt;fscanf&lt;/code&gt; 및 &lt;code&gt;scanf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">LTO의 또 다른 기능은 다른 언어로 작성된 파일에 절차 간 최적화를 적용 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">또 다른 제한 사항은 클로버 목록에 스택 포인터 레지스터가 포함되지 않아야한다는 것입니다. 컴파일러는 스택 포인터의 값이 명령문에 진입 할 때와 &lt;code&gt;asm&lt;/code&gt; 명령문 이후에 같아야하기 때문 입니다. 그러나 이전 버전의 GCC에서는이 규칙을 적용하지 않았으며 의미가 명확하지 않은 스택 포인터가 목록에 표시되도록 허용했습니다. 이 동작은 더 이상 사용되지 않으며 향후 GCC 버전에서 스택 포인터를 나열하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">또 다른 개정 된 ISO C ++ 표준은 2014 년에 ISO / IEC 14882 : 2014로 출판되었으며 C ++ 14라고합니다. 출판 전에는 때때로 C ++ 1y라고 불렸다. C ++ 14에는 C ++ 언어에 대한 몇 가지 추가 변경 사항이 포함되어 있으며 모두 GCC로 구현되었습니다. 자세한 내용은 &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14를&lt;/a&gt; 참조 하십시오 . GCC에서이 표준을 선택하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">GCC 2.5 이후로 더 이상 사용되지 않는 동일한 의미를 가진 또 다른 구문은 '</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">&lt;code&gt;__builtin_unreachable&lt;/code&gt; 의 또 다른 용도 는이 예제에서와 같이 반환되지 않지만 &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; 선언되지 않은 함수 호출을 따르는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">레이블 값의 또 다른 사용은 스레드 코드의 인터프리터입니다. 인터프리터 기능 내의 레이블은 초고속 디스패치를 ​​위해 스레드 코드에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">식의 형식을 참조하는 또 다른 방법은 &lt;code&gt;typeof&lt;/code&gt; 입니다. 이 키워드를 사용하는 구문은 &lt;code&gt;sizeof&lt;/code&gt; 와 비슷하지만 구문은 &lt;code&gt;typedef&lt;/code&gt; 로 정의 된 형식 이름처럼 의미 적으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">접두사를 지정하는 다른 방법은</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">또 다른 유사한 예는 기본 클래스의 멤버 함수 호출과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">80387 부동 소수점 (스택) 레지스터</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;symbol_ref&lt;/code&gt; 또는 &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">모든 D, P, B, M, I 또는 L 레지스터.</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">EVEX 인코딩 가능한 SSE 레지스터 ( &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">모든 MMX 레지스터.</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">모든 SSE 레지스터.</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">모든 SYMBOL_REF</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">모든 VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">lvalue가 아닌 경우에도 모든 배열을 첨자화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">const_double 값입니다.</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">16 비트 너비의 제어 레지스터 (제어 레지스터의 너비가 24 비트 인 경우 아무것도 없음)</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">폭이 24 비트 인 모든 제어 레지스터.</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">비 일반 주소 공간에 대한 모든 데이터 또는 포인터는 &lt;code&gt;const&lt;/code&gt; 즉, 읽기 전용 데이터로 규정되어야합니다 . 소프트웨어 버전 번호 또는 캘리브레이션 룩업 테이블과 같은 주소 공간 중 하나의 데이터가로드 로더, 예를 들어 부트 로더에 의해 변경되도록 의도 된 경우에도 여전히 적용됩니다. 이 경우 올바른 자격은 &lt;code&gt;const&lt;/code&gt; 를 &lt;code&gt;volatile&lt;/code&gt; 컴파일러가 최적화 멀리 값을 알려진 또는 명령의 피연산자로 immediate 만로 삽입하지 않아야 정도로는.</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">&lt;code&gt;noinit&lt;/code&gt; 속성을 가진 데이터 는 C 런타임 시작 코드 또는 프로그램 로더에 의해 초기화되지 않습니다. 이런 방식으로 데이터를 초기화하지 않으면 프로그램 시작 시간이 단축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">레이턴시가 &lt;var&gt;number&lt;/var&gt; 보다 크거나 같은 의존성 은 비용이 많이 든다.</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">상점에서로드까지의 종속성은 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">로 지정된 모든 디렉토리</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 유형의 모든 표현식 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">구현에 존재하는 확장 정수 유형 (C99 및 C11 6.2.5).</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">스택 스위치가없는 인터럽트 가능 코드는</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">선언의 시작 부분에있는 지정자 및 한정자 목록에는 해당 목록에 스토리지 클래스 지정자가 포함되어 있는지 여부에 관계없이 속성 지정자가 포함될 수 있습니다. 그러나 일부 속성은 본질적으로 스토리지 클래스 지정자의 특성에 따라 스토리지 클래스 지정자가 사용될 수있는 위치에만 적용됩니다 (예 : &lt;code&gt;section&lt;/code&gt; .)이 구문에는 한 가지 필수 제한 사항이 있습니다. 함수 정의의 첫 번째 이전 스타일 매개 변수 선언은 속성 지정자로 시작할 수 없습니다. 이러한 속성은 아래 설명 된 구문 대신 함수에 적용되기 때문입니다. 이 경우 구현). 다른 경우에는이 문법에서 속성 지정자를 허용하지만 아직 컴파일러에서 지원하지는 않습니다. 이 장소의 모든 속성 지정자는 선언 전체와 관련이 있습니다. 형식 지정자가 없기 때문에 &lt;code&gt;int&lt;/code&gt; 유형 이 암시되는 노후화 사용에서 이러한 지정자 및 규정 자 목록은 다른 지정자 또는 규정자가없는 속성 지정자 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">사전 컴파일 된 헤더가 포함되기 전에 정의 된 모든 매크로는 사전 컴파일 된 헤더가 생성 될 때와 같은 방식으로 정의되거나 사전 컴파일 된 헤더에 영향을 미치지 않아야합니다. 이는 일반적으로 사전 컴파일 된 헤더에 전혀 표시되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">원거리 주소 공간의 주소에 대한 모든 메모리 참조</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">가까운 주소 공간의 주소에 대한 모든 메모리 참조</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">함수 입력시 모든 모드가 유효하며 함수가 리턴 될 때와 다른 함수를 호출 할 때 유지되거나 복원됩니다. 이 모드는 다른 FPU 모드를 가진 다른 프로그램에 포함시키려는 라이브러리 또는 다른 컴파일 단위를 컴파일하는 데 유용하며 단일 오브젝트 파일을 사용할 수있는 편리함은 추가 모드 전환에 대한 크기 및 속도 오버 헤드보다 중요합니다. 일반적인 FPU 모드의보다 구체적인 선택에 필요한 것과 비교할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">SVE 술어 레지스터 중 하나 ( &lt;code&gt;P0&lt;/code&gt; ~ &lt;code&gt;P15&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">부동 소수점 레지스터 (AC0-AC5)</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">모든 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">모든 레지스터</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; 로 액세스 할 수있는 모든 레지스터 : &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">모든는 접근 등록 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; . 32 비트 모드에서 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; ; 64 비트 모드에서 모든 정수 레지스터</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">누산기 또는 CC를 제외한 모든 레지스터.</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">일반 레지스터가 아닌 레지스터를 제외한 모든 레지스터, 메모리 또는 즉시 정수 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;based&lt;/code&gt; 속성을 가진 변수 는 &lt;code&gt;.based&lt;/code&gt; 섹션에 할당되며 &lt;code&gt;$tp&lt;/code&gt; 레지스터 를 기준으로 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">&lt;code&gt;persistent&lt;/code&gt; 속성을 가진 변수 는 C 런타임 시작 코드에 의해 초기화되지 않습니다. 대신 응용 프로그램이로드 될 때 해당 값이 한 번 설정되고 프로세서가 재설정되거나 프로그램이 다시 시작 되더라도 다시 초기화되지 않습니다. 영구 데이터는 FLASH RAM에 저장되도록되어 있으며,이 값은 재설정 동안 유지됩니다. 응용 프로그램을 만드는 데 사용되는 링커 스크립트는 영구 데이터가 올바르게 배치되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">이전에 지정한 접두사에 &lt;var&gt;dir&lt;/var&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">I- 유닛에 상주하는 애플리케이션 레지스터</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">M 유닛에 상주하는 애플리케이션 레지스터</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">파티션 된 실행 최적화를 적용하십시오. 최적화 수준을 선택한 경우 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 속성을 모든 후속 함수 선언에 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">실행 가능한 루프에 언롤 및 잼 변형을 적용합니다. 루프 네스트에서 이것은 외부 루프를 어떤 요인으로 풀고 그 결과로 발생하는 여러 내부 루프를 융합시킵니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">&lt;code&gt;uh&lt;/code&gt; , &lt;code&gt;uw1&lt;/code&gt; , &lt;code&gt;sw1&lt;/code&gt; , &lt;code&gt;uw2&lt;/code&gt; 및 &lt;code&gt;sw2&lt;/code&gt; 유형의 인수는 런타임에 평가됩니다. 기본 FR-V 명령어의 레지스터 피연산자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">&lt;code&gt;const int&lt;/code&gt; 로 문서화 된 인수 에는 해당 연산에 필요한 범위 내의 리터럴 정수 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 포인터와 함수 포인터에 대한 산술 .</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">런타임시 길이가 계산되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">GNU 확장으로서 GCC는 복합 리터럴에 의해 정적 저장 시간을 가진 객체의 초기화를 허용합니다 (초기화자가 상수가 아니기 때문에 ISO C99에서는 불가능합니다). 복합 리터럴 및 오브젝트의 유형이 일치하는 경우 오브젝트가 중괄호로 묶인 목록으로 만 초기화 된 것처럼 처리됩니다. 복합 리터럴의 요소는 일정해야합니다. 초기화되는 객체의 크기가 알 수없는 배열 유형 인 경우 크기는 복합 리터럴의 크기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">GCC는 ACLE의 일부로 ARM C 언어 확장 사양에 설명 된대로 고급 SIMD 용 확장을 구현합니다. 고급 SIMD 내장 함수의 전체 목록은 &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt; 에서 찾을 수 있습니다 . NEON이 활성화되면 Advanced SIMD 확장을위한 내장 내장 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">결과적으로 Sun CC로 컴파일 된 함수가 &lt;code&gt;double&lt;/code&gt; 유형의 인수 주소를 가져 와서 &lt;code&gt;double *&lt;/code&gt; 유형의이 포인터 를 GCC로 컴파일 된 함수에 전달하면 포인터를 역 참조하면 치명적인 신호가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">결과적으로 파일이</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">경로가 제공하는 경우 특별한 kludge로</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">스펙 문자열을 제공하는 대신 접미어 지시문 뒤에 나오는 텍스트는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">확장으로 정수 스칼라 유형 &lt;code&gt;__int128&lt;/code&gt; 은 128 비트를 보유하기에 충분한 정수 모드의 대상에 대해 지원됩니다. 간단하게 쓰기 &lt;code&gt;__int128&lt;/code&gt; 서명 된 128 비트 정수, 또는에 대한 &lt;code&gt;unsigned __int128&lt;/code&gt; 부호 128 비트 정수. 너비가 128 비트 미만인 &lt;code&gt;long long&lt;/code&gt; 정수가있는 대상에 &lt;code&gt;__int128&lt;/code&gt; 유형의 정수 상수를 표현하기 위해 GCC에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">C 언어의 확장으로 GCC는 C99 및 C11에 제공된 위도를 사용하여 서명 된 '</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">확장으로서 GCC는 가변 길이 배열을 구조체 또는 공용체의 멤버로 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">확장으로 GNU C 및 GNU C ++는 추가 부동 유형을 지원하며 모든 대상에서 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC WDTR24732의 N1312 초안에 정의 된 십진 부동 유형을 지원합니다. GCC에서 10 진수 부동 유형에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전합니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 모든 대상이 10 진수 부동 유형을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC DTR 18037의 N1169 초안에 정의 된대로 고정 소수점 유형을 지원합니다. GCC에서 고정 소수점 유형에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전 할 것입니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 모든 대상이 고정 소수점 유형을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC DTR 18037의 N1275 초안에 정의 된대로 명명 된 주소 공간을 지원합니다. GCC에서 명명 된 주소 공간에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전 할 것입니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 현재 AVR, SPU, M32C, RL78 및 x86 대상 만 일반 주소 공간 이외의 주소 공간을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">최적화로서, G ++는 때때로 배열 복합 리터럴을 더 긴 수명을 제공합니다 : 배열이 함수 외부에 나타나거나 &lt;code&gt;const&lt;/code&gt; 한정 유형을 가질 때 . 경우 &lt;code&gt;foo&lt;/code&gt; 는 그 이니셜 라이저 타입의 요소를 가지고 &lt;code&gt;char *const&lt;/code&gt; 하기보다는 &lt;code&gt;char *&lt;/code&gt; 경우, 또는 &lt;code&gt;foo&lt;/code&gt; 전역 변수했다, 배열은 정적 저장 기간을 가질 것이다. 그러나 C ++ 코드에서 배열 복합 리터럴을 사용하지 않는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">다른 예로서,</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">또 다른 예로서, &lt;code&gt;strncpy&lt;/code&gt; 에 대한 다음 호출 은 종료 NUL을 끝에 추가하지 않고 종료 NUL 앞에 오는 문자 만 &lt;code&gt;d&lt;/code&gt; 에 복사합니다 . &lt;code&gt;strncpy&lt;/code&gt; 의 결과 가 반드시 NUL 종료 문자열 이라고 가정하는 것은 일반적인 실수이므로 호출이 진단됩니다. 결과가 NUL로 종료 될 것으로 예상되지 않을 때 경고를 피하려면 대신 &lt;code&gt;memcpy&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">비트 필드는 개별적으로 어드레스 가능하지 않기 때문에, 휘발성 비트 필드는 기록 될 때 또는 인접한 비트 필드가 액세스 될 때 암시 적으로 판독 될 수있다. 비트 필드 동작은 인접한 비트 필드가 저장 장치 경계에 걸쳐있는 경우 부분적으로 만 액세스되도록 최적화 될 수있다. 이러한 이유로 휘발성 비트 필드를 사용하여 하드웨어에 액세스하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성&lt;/a&gt; 에서 논의한 바와 같이이 속성을 사용하면 대상별 컴파일 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">'에 관해서는</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">표준 C ++ 및 ISO C99에서와 같이 자동 변수에 대한 집계 이니셜 라이저 요소는 GNU C에서 상수 표현식 일 필요는 없습니다. 다음은 런타임 가변 요소가있는 초기화 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">앞의 예제에서와 같이 컴파일러가 주어진 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 유형 에 사용할 정렬 (바이트)을 명시 적으로 지정할 수 있습니다 . 또는 정렬 인수를 제외하고 컴파일러에게 컴파일하려는 대상 머신에 대한 최대 유용한 정렬로 유형을 정렬하도록 요청할 수 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="translated">앞의 예제에서와 같이 컴파일러가 주어진 변수 또는 구조 필드에 사용할 정렬 (바이트)을 명시 적으로 지정할 수 있습니다. 또는 정렬 인수를 제외하고 컴파일러에게 변수 또는 필드를 컴파일하려는 대상 아키텍처의 기본 정렬에 정렬하도록 요청할 수 있습니다. 기본 정렬은 모든 스칼라 유형에 충분하지만 벡터 연산을 지원하는 대상의 모든 벡터 유형에 충분하지 않을 수 있습니다. 기본 정렬은 특정 대상 ABI에 대해 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="translated">스택 프레임 백 체인을 사용하지 않는 한</target>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="translated">위에서 언급했듯이 새로운 예외는 Objective-C 객체 이외의 유형을 처리하는 것을 지원하지 않습니다. 또한 Objective-C ++에서 사용될 때 Objective-C 예외 모델은 현재 C ++ 예외와 상호 운용되지 않습니다. 이 방법은 당신이 할 수 &lt;code&gt;@throw&lt;/code&gt; 목표 - C에서 예외를하고 &lt;code&gt;catch&lt;/code&gt; C ++, 또는 그 반대 (즉, 그것을 &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="translated">새로운 인텔 프로세서가 시장에 배포됨에 따라이 옵션의 동작이 변경됩니다. 따라서 최신 버전의 GCC로 업그레이드하는 경우이 옵션으로 제어되는 코드 생성은 해당 버전의 GCC가 출시 될 때 최신 인텔 프로세서를 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="translated">새로운 프로세서가 시장에 배포됨에 따라이 옵션의 동작이 변경됩니다. 따라서 최신 버전의 GCC로 업그레이드하는 경우이 옵션으로 제어되는 코드 생성은 해당 버전의 GCC가 출시 될 때 가장 일반적인 프로세서를 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="translated">GCC 4.7.1 릴리스부터 GCC는 &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1에&lt;/a&gt; 설명 된 Go 1 언어 표준을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="translated">이 글을 쓰는 시점에서 Mac OS X 10.4 이상의 NeXT 런타임에서만 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 및 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 메소드 호출을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="translated">이 글을 쓰는 시점에서 쿼드 워드 부동 소수점 명령어를 하드웨어로 지원하는 SPARC 구현은 없습니다. 이들은 모두 이들 명령어 중 하나에 대한 트랩 핸들러를 호출 한 다음 트랩 핸들러가 명령의 효과를 에뮬레이트합니다. 트랩 처리기 오버 헤드로 인해 ABI 라이브러리 루틴을 호출하는 것보다 훨씬 느립니다. 그래서</target>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="translated">보안 확장의 일부로 GCC는 아래의 내장 기능을 구현합니다. FPTR은 여기에서 함수 포인터 유형을 의미하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="translated">보안 확장의 일부로 GCC는 &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; 및 &lt;code&gt;cmse_nonsecure_call&lt;/code&gt; 의 두 가지 새로운 기능 속성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="translated">ISO C11에서 허용하고 다른 컴파일러와의 호환성을 위해 GCC를 사용하면 이름없이 필드, 구조 및 공용체를 포함하는 구조 또는 공용체를 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="translated">ISO C ++에서 요구하는대로 GCC는 클래스 본문 내에 정의 된 멤버 함수가 &lt;code&gt;inline&lt;/code&gt; 키워드로 명시 적으로 선언되지 않은 경우에도 인라인으로 표시되는 것으로 간주 합니다. 이것을 재정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="translated">모든 가장 바깥 쪽 매개 변수 한정자와 마찬가지로 &lt;code&gt;__restrict__&lt;/code&gt; 는 함수 정의 일치에서 무시됩니다. 즉 , 함수 프로토 타입이 아니라 함수 정의에 &lt;code&gt;__restrict__&lt;/code&gt; 만 지정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="translated">전역 레지스터 변수와 마찬가지로 일반적으로 시스템의 함수 호출에 의해 저장 및 복원되는 레지스터를 선택하여 라이브러리 루틴에 대한 호출이이를 방해하지 않도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="translated">C 프런트 엔드와 마찬가지로 G ++는 &lt;code&gt;__restrict__&lt;/code&gt; 또는 &lt;code&gt;__restrict&lt;/code&gt; 유형 한정자로 지정된 제한된 포인터의 C99 기능을 이해합니다 . 다음을 지정하여 C ++를 컴파일 할 수 없기 때문에</target>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="translated">어셈블러 옵션</target>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="translated">사전 처리해야하는 어셈블러 코드</target>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="translated">어셈블러 코드.</target>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="translated">데이터의 어셈블러 이름 :</target>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="translated">함수의 어셈블러 이름 :</target>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="translated">조립 출력</target>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="translated">컴파일이 독립 환경을 대상으로한다고 주장하십시오. 이것은 암시</target>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="translated">컴파일이 호스팅 된 환경을 대상으로한다고 주장하십시오. 이것은 암시</target>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="translated">할당도 표현식이며 rvalue가 있습니다. 그러나 스칼라 휘발성에 할당 할 때 할당 식의 rvalue 사용 여부에 관계없이 휘발성 객체를 다시 읽지 않습니다. 할당의 rvalue가 사용되는 경우, 값은 휘발성 객체에 할당 된 값입니다. 예를 들어 다음과 같은 모든 경우 에 &lt;var&gt;vobj&lt;/var&gt; 를 읽을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="translated">선택한 ABI에 관계없이 모든 심볼에 32 비트 값이 있다고 가정합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="translated">해당 데이터의 크기가 데이터 범위 내에 있으면 외부 정의 데이터가 작은 데이터 섹션에 있다고 가정</target>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="translated">상호 추정 명령이 PowerPC ABI에서 요구하는 것보다 더 정밀한 추정을 제공한다고 가정합니다 (상정하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="translated">상호 추정 명령이 PowerPC ABI에서 요구하는 것보다 더 정밀한 추정을 제공한다고 가정합니다 (상정하지 마십시오). 선택</target>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="translated">정적 및 동적 링커는 PLT 및 사본 재배치를 지원한다고 가정합니다 (상정하지 마십시오). 이 옵션은 다음에 만 영향을줍니다</target>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="translated">제로 변위 조건부 분기 명령 &lt;code&gt;bt&lt;/code&gt; 및 &lt;code&gt;bf&lt;/code&gt; 가 빠르다고 가정합니다. 만약</target>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 를 8 비트 정수로 가정하십시오 . 이것은 모든 유형의 크기에 영향을줍니다. &lt;code&gt;char&lt;/code&gt; 은 1 바이트, &lt;code&gt;int&lt;/code&gt; 는 1 바이트, &lt;code&gt;long&lt;/code&gt; 은 2 바이트, &lt;code&gt;long long&lt;/code&gt; 은 4 바이트입니다. 이 옵션은 C 표준을 준수하지 않지만 코드 크기가 더 작아집니다.</target>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; 은 분기 명령어의 비용 이라고 가정 합니다. 숫자가 높을수록 컴파일러는 가능하면 더 많은 분기없는 코드를 생성하려고합니다. 지정하지 않으면 값은 컴파일중인 프로세서 유형에 따라 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">스레드 로컬 코드를 생성 할 때 큰 TLS 세그먼트를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="translated">주소를 부호없는 16 비트 값으로로드 할 수 있다고 가정합니다. 기능 주소에는 적용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="translated">모든 객체가 16MB 이하의 메모리에 있고 ( &lt;code&gt;ld24&lt;/code&gt; 명령어로 주소를로드 할 수 있도록 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용 하여 모든 서브 루틴에 도달 할 수 있다고 가정합니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="translated">인라인 어셈블러가 통합 asm 구문을 사용한다고 가정합니다. 기본값은 현재 꺼져 있으며 분할 구문을 의미합니다. 이 옵션은 Thumb2에 영향을 미치지 않습니다. 그러나 이는 향후 GCC 릴리스에서 변경 될 수 있습니다. 구분 된 구문은 더 이상 사용되지 않는 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="translated">플래시에서 데이터를로드하는 것이 명령을 가져 오는 것보다 느리다고 가정하십시오. 따라서 성능 향상을 위해 리터럴로드가 최소화됩니다. 이 옵션은 ARMv7 M 프로파일을 컴파일 할 때만 지원되며 기본적으로 해제되어 있습니다. 충돌</target>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">객체가 32 비트 주소 공간의 어느 곳에 나있을 수 있다고 가정하고 (컴파일러는 주소를로드하기 위해 &lt;code&gt;seth/add3&lt;/code&gt; 명령어를 생성 함 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용 하여 모든 서브 루틴에 도달 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="translated">객체가 32 비트 주소 공간의 어느 곳에 나있을 수 있다고 가정하고 (컴파일러는 주소를로드하기 위해 &lt;code&gt;seth/add3&lt;/code&gt; 명령어를 생성 함 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용하여 서브 루틴에 도달 할 수 없다고 가정 합니다 (컴파일러는 훨씬 느린 &lt;code&gt;seth/add3/jl&lt;/code&gt; 명령어를 생성 함) 순서).</target>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="translated">&lt;code&gt;RJMP&lt;/code&gt; 및 &lt;code&gt;RCALL&lt;/code&gt; 이 전체 프로그램 메모리를 대상으로 할 수 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="translated">ICPLB가 런타임에 사용 가능하다고 가정하십시오. 이는 특정 예외 해결 방법에 영향을줍니다. Linux 대상의 경우 기본값은 ICPLB가 사용 가능한 것으로 가정하는 것입니다. 독립형 응용 프로그램의 경우 기본값은 해제입니다.</target>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="translated">이 변환 단위의 모든 Objective-C 메시지 디스패치 ( &lt;code&gt;[receiver message:arg]&lt;/code&gt; )가 수신자가 &lt;code&gt;nil&lt;/code&gt; 이 아닌지 확인한다고 가정하십시오 . 이를 통해 런타임에서보다 효율적인 진입 점이 사용될 수 있습니다. 이 옵션은 NeXT 런타임 및 ABI 버전 0 또는 1과 함께 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="translated">정적 스토리지의 모든 데이터는 LDS / STS 명령으로 액세스 할 수 있다고 가정하십시오. 이 옵션은 ATtiny40과 같이 축소 된 Tiny 장치에만 영향을줍니다. &lt;code&gt;absdata&lt;/code&gt; &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="translated">더블은 8 바이트 정렬을 가정합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="translated">부동 소수점 레지스터의 너비가 32 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="translated">부동 소수점 레지스터의 폭이 64 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="translated">부동 소수점 저장 및로드가 동일한 명령어 그룹에 배치 될 때 충돌을 일으키지 않을 것이라고 가정하십시오. 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="translated">범용 레지스터의 폭이 32 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="translated">범용 레지스터의 폭이 64 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="translated">프로그램이 널 포인터를 안전하게 역 참조 할 수없고 주소 0에 코드 나 데이터 요소가없는 것으로 가정하십시오. 이 옵션을 사용하면 모든 최적화 수준에서 간단한 상수 폴딩 최적화가 가능합니다. 또한 GCC의 다른 최적화 단계에서는이 플래그를 사용하여 null 포인터에 대한 쓸모없는 검사를 제거하는 전역 데이터 흐름 분석을 제어합니다. 이들은 주소 0에 대한 메모리 액세스가 항상 트랩을 초래한다고 가정하므로 포인터가 이미 역 참조 된 후에 포인터가 검사되면 널이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="translated">런타임 지원이 제공되었다고 가정하고 시뮬레이터 라이브러리를 생략하십시오 (</target>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="translated">런타임 지원이 제공되어 시뮬레이터 라이브러리를 포함 할 필요가 없다고 가정하십시오 (</target>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="translated">현재 컴파일 단위가 컴파일되는 전체 프로그램을 나타낸다고 가정하십시오. &lt;code&gt;main&lt;/code&gt; 을 제외한 모든 공용 함수 및 변수와 &lt;code&gt;externally_visible&lt;/code&gt; 속성으로 병합 된 변수는 정적 함수가되며 실제로는 절차 적 최적화에 의해보다 적극적으로 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="translated">장치가 Read-Modify-Write 명령어 &lt;code&gt;XCH&lt;/code&gt; , &lt;code&gt;LAC&lt;/code&gt; , &lt;code&gt;LAS&lt;/code&gt; 및 &lt;code&gt;LAT&lt;/code&gt; 를 지원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="translated">텍스트와 데이터 세그먼트 사이의 변위가 정적 링크 시간에 고정되었다고 가정하십시오. PC 기준 주소 지정이 지원되지 않으므로 GOT 대신 텍스트 주소 시작에서 오프셋으로 데이터를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="translated">텍스트와 데이터 세그먼트 사이의 변위가 정적 링크 시간에 고정되었다고 가정하십시오. 이를 통해 PC 상대 주소 지정 작업을 사용하여 데이터 세그먼트에있는 것으로 알려진 데이터에 액세스 할 수 있습니다. VxWorks RTP 대상이 아닌 경우이 옵션은 기본적으로 활성화되어 있습니다. 이러한 대상에서 비활성화되면 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="translated">플래시 메모리의 크기는 &lt;var&gt;num&lt;/var&gt; 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="translated">부동 소수점 보조 프로세서는 단 정밀도 연산 만 지원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="translated">부동 소수점 보조 프로세서는 배정도 연산을 지원한다고 가정합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="translated">핸들러가 기본 범용 레지스터 대신 새도우 레지스터 세트를 사용한다고 가정하십시오. 섀도우 레지스터 세트에 유효한 스택 포인터가 있음을 나타 내기 위해 선택적 인수 &lt;code&gt;intstack&lt;/code&gt; 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="translated">프로그램이 임의로 큰 것으로 가정하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">들어오는 스택이 2에서 &lt;var&gt;num&lt;/var&gt; 바이트 경계 까지 올렸다고 가정합니다 . 만약</target>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="translated">레벨에서 &lt;var&gt;2&lt;/var&gt; 위의 예에서 호출은 다시 진단되지만이 시간 때문에 32 비트와 동일 &lt;code&gt;INT_MIN&lt;/code&gt; 제 &lt;code&gt;%i&lt;/code&gt; 지정 목적지 버퍼의 끝을 넘어 그 숫자들을 쓸 것이다. 두 변수의 값에 관계없이 호출을 안전하게하려면 대상 버퍼의 크기를 34 바이트 이상으로 늘려야합니다. GCC는 경고 다음에 정보 메모에 버퍼의 최소 크기를 포함합니다. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="translated">현재 GCC는 32 비트 벡터에 대한 연산 만 지원합니다. 8 비트 정수 데이터와 연관된 벡터 유형은 일반적으로 호출 &lt;code&gt;v4i8&lt;/code&gt; Q7과 연관된 벡터 유형은 일반적으로 호출되면 &lt;code&gt;v4q7&lt;/code&gt; 16 비트 정수 데이터와 연관된 벡터 유형은 일반적으로 호출, &lt;code&gt;v2i16&lt;/code&gt; 및 Q15와 연관된 벡터 유형은 일반적 &lt;code&gt;v2q15&lt;/code&gt; 라고 합니다 . C에서 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;weakref&lt;/code&gt; 가 첨부 된 선언 은 &lt;code&gt;static&lt;/code&gt; 만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="translated">현재 함수 프로토 타입의 첫 번째 매개 변수에는 속성 지정자가 아닌 일부 유형 지정자가 있어야합니다. 이것은 &lt;code&gt;void f(int (__attribute__((foo)) x))&lt;/code&gt; 의 해석에 대한 모호성을 해결 하지만 변경 될 수 있습니다. 현재 함수 선언자의 괄호에 속성 만 포함 된 경우 오류나 경고를 생성하거나 int 유형의 단일 매개 변수를 암시하지 않고 해당 속성이 무시되지만 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="translated">사용자 레벨에서 확장은 새 스토리지 클래스 키워드 &lt;code&gt;__thread&lt;/code&gt; 로 볼 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="translated">이 수준에서</target>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="translated">이 레벨에서 레벨 1과 동일한 모든 구문을 진단하는 것 외에도 유형이 단일 요소의 배열이고 크기가 작은 구조의 마지막 멤버에 오브젝트를 구성하는 새 표현식 배치에 대한 진단도 발행됩니다. 구성되는 객체의 크기보다 이전 예제는 진단되었지만 다음 구성은 레벨 2의 경고를 피하기 위해 유연한 멤버 배열 확장을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="translated">메모리 모델에 내장 된 기능.</target>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="translated">비트 필드에는 원자 유형이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">레지스터 할당 후 남은 레지스터를 사용하여 스케줄 된 코드에서 잘못된 종속성을 피하십시오. 이 최적화는 레지스터가 많은 프로세서에 가장 유용합니다. 그러나 대상에서 채택한 디버그 정보 형식에 따라 변수가 더 이상 &quot;홈 레지스터&quot;에 남아 있지 않으므로 디버깅이 불가능해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="translated">호출을 가상 함수로 변환하여 직접 호출로 전환하십시오. 이는 간접 인라이닝의 일부로 절차 내에서 그리고 절차 적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="translated">가상 함수 호출을 추론 적 직접 호출로 변환하려고합니다. 유형 상속 그래프의 분석을 기반으로 주어진 호출에 대해 가능한 대상 세트를 결정하십시오. 세트가 작고, 바람직하게는 크기가 1 인 경우, 직접 및 간접 호출 사이의 조건부 결정으로 호출을 변경하십시오. 투기 호출은 인라인과 같은 더 많은 최적화를 가능하게합니다. 추가 최적화 후 쓸모가없는 것처럼 보이면 원래 형태로 다시 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="translated">레지스터 라이브 범위 축소를 ​​통해 레지스터 압력을 낮추십시오. 이는 레지스터 크기가 작거나 중간 인 고속 프로세서에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="translated">위치보기 목록에서 생략 할 수있는 위치보기를 결정하십시오. 이것은 컴파일러가 매우 정확한 insn 길이 추정치를 가져야하며, 항상 그런 것은 아니며 위치 뷰 목록을 지원하지 않는 어셈블러를 사용할 때 잘못된 뷰 목록이 자동으로 생성 될 수 있습니다. GNU 어셈블러는 이러한 오류를 &lt;code&gt;view number mismatch&lt;/code&gt; 합니다. 신뢰할 수있는 추정 기능을 정의하는 포트에서만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">스택 경계를 2에서 &lt;var&gt;num&lt;/var&gt; 바이트 경계 까지 올린 상태로 유지하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="translated">컴파일 단위에서 동일한 상수 (문자열 상수 및 부동 소수점 상수)를 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="translated">동일한 상수와 동일한 변수를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="translated">스택 사용을 최소화하십시오. 컴파일러는 프로그램을 더 느리게 만들더라도 더 적은 스택 공간을 사용하려고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="translated">중복 확장 명령을 제거하십시오. 이것은 x86-64 아키텍처에 특히 유용합니다. x86-64 아키텍처는 하위 32 비트 절반에 쓴 후 64 비트 레지스터에서 암시 적으로 0으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="translated">가장 안쪽 루프의 조건부 점프를 분기없는 등가로 변환하려고합니다. 이러한 루프를 처리하는 벡터화 패스의 기능을 향상시키기 위해 가장 안쪽 루프에서 제어 흐름을 제거하는 것이 목적입니다. 벡터화가 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="translated">조건부 점프를 분기없는 등가로 변환하려고합니다. 여기에는 조건부 이동, 최소, 최대, 설정 플래그 및 abs 명령어 사용과 표준 산술로 수행 할 수있는 몇 가지 트릭이 포함됩니다. 사용 가능한 칩에서 조건부 실행의 사용은 다음에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="translated">두 명령어 세트를 동시에 사용하십시오. 이것은 사용 가능한 레지스터의 양을 효과적으로 두 배로 늘리고 387에 대한 별도의 실행 단위를 가진 칩과 SSE의 실행 리소스도 효과적으로 배가시킵니다. GCC 레지스터 할당 기는 별도의 기능 단위를 제대로 모델링하지 않으므로 성능이 불안정하므로이 옵션은 아직 실험 중이므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="translated">속성 한정자는 배열이 암시 적으로 변환되는 포인터에 이러한 한정자가 적용되는 C99 구문에서 매개 변수 배열 선언자 의 &lt;code&gt;[]&lt;/code&gt; 안에 나타나는 형식 한정자와 혼합 될 수 있습니다 . 이러한 속성 지정자는 배열이 아닌 포인터에 적용되지만 현재는 구현되지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="translated">고려되는 속성에는 &lt;code&gt;alloc_align&lt;/code&gt; , &lt;code&gt;alloc_size&lt;/code&gt; , &lt;code&gt;cold&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;hot&lt;/code&gt; , &lt;code&gt;leaf&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;nonnull&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;returns_nonnull&lt;/code&gt; 및 &lt;code&gt;returns_twice&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="translated">행 번호 테이블에서 암시적인 점진적 뷰 번호로 변수 위치 목록을 보강하십시오. 이를 통해 디버그 정보 소비자는 해당 소스 위치와 관련된 명령이없는 경우에도 프로그램의 특정 지점에서 상태를 검사 할 수 있습니다. 어셈블러에서 행 번호 테이블의 뷰 번호에 대한 지원이 부족한 경우 컴파일러에서 행 번호 테이블을 생성하므로 일반적으로 압축이 다소 줄어 듭니다. 기능 보강 된 행 번호 테이블 및 위치 목록은 이전 버전과 완전히 호환되므로 이러한 기능 보강을 인식하지 못하는 디버그 정보 소비자가이를 사용할 수 있지만 이들 중 어느 것도 이점을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="translated">에서 상대 소스 파일 이름을 절대 경로 이름으로 자동 변환</target>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="translated">루프의 평균 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="translated">아키텍처 사양에 설명 된대로 자연 객체 경계에 정렬되지 않은 메모리 액세스 생성을 피하거나 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="translated">B 레지스터</target>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="translated">BMI 지침.</target>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="translated">BMI2 지침.</target>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="translated">BRIG 파일 (HSAIL의 이진 표현).</target>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="translated">기본 포인터 레지스터 (r28&amp;ndash;r31)</target>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="translated">제약 조건의 기본 사용.</target>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="translated">예를 들어 &lt;code&gt;some_expression&lt;/code&gt; 이 전역 상태를 변경할 수없는 경우 다음 루프를 완전히 제거 할 수있는 등 타이밍 테스트를 수행 할 때이 점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="translated">프로젝트 외부의 헤더, 특히 사용하는 다른 라이브러리의 헤더 및 시스템 헤더는 기본값 이외의 가시성으로 컴파일되지 않을 수도 있습니다. 이러한 헤더를 포함하기 전에 &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; 를 명시 적으로 말해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__builtin_longjmp&lt;/code&gt; 는 스택 컨텍스트를 복원하는 함수 반환 메커니즘에 의존 하기 때문에 &lt;var&gt;buf&lt;/var&gt; 를 초기화하기 위해 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 를 호출하는 동일한 함수에서 호출 할 수 없습니다 . &lt;code&gt;__builtin_setjmp&lt;/code&gt; 를 호출하는 함수에서 (직접 또는 간접적으로) 호출 된 함수에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="translated">동기화와 예외 처리 간의 상호 작용으로 인해 예외가 활성화 된 경우 즉, 명령 줄 옵션을 사용하여 &lt;code&gt;@synchronized&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="translated">플래그 출력 피연산자의 특성으로 인해 제약 조건에 대체 항목이 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="translated">GCC가 통화를 계측하는 방식으로 인해 개별 블록이없는 회선 뒤에 통화 수를 표시 할 수 있습니다. 보다시피, 33 행에는 실행되지 않은 기본 블록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="translated">때문에 &lt;code&gt;asm&lt;/code&gt; 문이 무조건 전송이 기능의 출력 제어, 제어 함수 본문의 끝에 도달하지 않습니다. &lt;code&gt;__builtin_unreachable&lt;/code&gt; 는 사실에 도달 할 수없는 컴파일러에이 사실을 전달한다.</target>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="translated">이 옵션을 사용하려면 먼저 프로파일 링 정보를 생성해야합니다. 에 대한 정보는 &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;계측 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="translated">선언 외에도 파일은 선언에서 선언이 암시 적이든 프로토 타입이든 프로토 타입이 아닌지 ( '원본 파일과 줄)의 출처를 나타냅니다 ('</target>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="translated">일부 ELF 시스템에서이 속성은 지연 바인딩 (기본값)이있는 공유 라이브러리의 전역 함수에 적합하지 않습니다. 지연 바인딩은 표준 호출 규칙에 따라 EAX, EDX 및 ECX가 클로버 될 수 있다고 가정 할 수있는 로더의 코드 해석을 통해 첫 번째 호출을 보냅니다. Solaris 8은이 영향을받습니다. GNU C 라이브러리 버전 2.1 이상과 FreeBSD를 갖춘 시스템은 로더가 EAX, EDX 및 ECX를 저장하므로 안전하다고 생각됩니다. (문제가 발생하지 않도록 원하는 경우 링커 또는 로더를 사용하여 지연 바인딩을 비활성화 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="translated">이진 호환성</target>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="translated">이진 산술 연산.</target>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="translated">이진 호환성에는 몇 가지 관련 개념이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="translated">'를 사용하는 이진 상수</target>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="translated">공유 객체를 만들 때 전역 심볼에 대한 참조를 바인딩합니다. 링크 에디터 옵션으로 오버라이드하지 않는 한, 해결되지 않은 참조에 대해 경고</target>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="translated">비트 반전. 비트 &lt;var&gt;value&lt;/var&gt; 을 반전 한 결과를 반환합니다 . 비트 15는 비트 0으로 교체되고 비트 14는 비트 1로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="translated">비트 연산자는 부호 비트와 값 비트를 포함하여 값의 표현에 작용합니다. 여기서 부호 비트는 최고 값 값 비트 바로 위에 간주됩니다. '서명</target>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="translated">블랙 핀 가족 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="translated">Borland C ++는 공통 블록과 동등한 코드를 링커에 추가하여 템플릿 인스턴스화 문제를 해결했습니다. 컴파일러는이를 사용하는 각 변환 단위로 템플릿 인스턴스를 생성하고 링커는이를 축소합니다. 이 모델의 장점은 링커가 객체 파일 자체 만 고려하면된다는 것입니다. 걱정할 외부 복잡성이 없습니다. 단점은 템플릿 코드가 반복적으로 컴파일되기 때문에 컴파일 시간이 증가한다는 것입니다. 이 모델 용으로 작성된 코드는 인스턴스화되는 것으로 보여야하므로 헤더 파일에 모든 템플릿의 정의를 포함하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="translated">볼랜드 모델</target>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="translated">글로벌 변수와 로컬 변수는 모두 레지스터와 연관 될 수 있습니다. 이 연결을 수행하면 아래 섹션에서 설명하는 것처럼이 연결의 결과가 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="translated">유도 변수에 대한 후보 수에 제한이 있으며,이 범위 미만에서는 유도 변수 최적화에 각 용도에 대해 모든 후보가 고려됩니다. 이보다 더 많은 후보가있는 경우, 2 차 시간 복잡성을 피하기 위해 가장 관련성이 높은 후보 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="translated">스칼라 진화 분석기에서 사용되는 표현식의 크기에 제한이 있습니다. 큰 표현은 분석기를 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="translated">스칼라 진화 분석기에서 표현의 복잡성에 바운드. 복잡한 표현은 분석기를 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="translated">반복 횟수를 계산하기 위해 식의 비용을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="translated">지점 등록</target>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="translated">분기에는 &lt;var&gt;-b&lt;/var&gt; 옵션 만 있습니다. &lt;var&gt;line&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="translated">설명없이 모든 옵션의 간략한 목록.</target>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="translated">나중에 고칠 버그.</target>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="translated">코어 별 단일 애플리케이션 프로그래밍 모델을 사용할 때 BF561의 코어 A에 대한 독립형 애플리케이션을 빌드하십시오. 코어 A를 지원하기 위해 올바른 시작 파일 및 링크 스크립트가 사용되며 매크로 &lt;code&gt;__BFIN_COREA&lt;/code&gt; 가 정의됩니다. 이 옵션은 다음과 함께 만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="translated">코어 별 단일 애플리케이션 프로그래밍 모델을 사용할 때 BF561의 코어 B에 대한 독립형 애플리케이션을 빌드하십시오. 코어 B를 지원하기 위해 올바른 시작 파일과 링크 스크립트가 사용되며 매크로 &lt;code&gt;__BFIN_COREB&lt;/code&gt; 가 정의됩니다. 이 옵션을 사용하면, &lt;code&gt;coreb_main&lt;/code&gt; 대신 사용해야합니다 &lt;code&gt;main&lt;/code&gt; . 이 옵션은 다음과 함께 만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="translated">SDRAM을위한 독립형 애플리케이션을 빌드하십시오. 올바른 시작 파일과 링크 스크립트는 응용 프로그램을 SDRAM에 넣는 데 사용되며 매크로 &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; 이 정의됩니다. 로더는 애플리케이션을로드하기 전에 SDRAM을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="translated">멀티 코어 Blackfin 프로세서를위한 독립형 애플리케이션을 구축하십시오. 이 옵션을 사용하면 멀티 코어를 지원하는 올바른 시작 파일과 링크 스크립트가 사용되고 &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt; 매크로를 정의합니다 . 함께 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="translated">아키텍처를 식별하는 10 진수로 해석되는 내장 매크로</target>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="translated">데이터 종속성을 구축하는 것은 매우 큰 루프에 비용이 많이 듭니다. 이 매개 변수는 데이터 종속성 분석에 고려되는 루프의 데이터 참조 수를 제한합니다. 이러한 큰 루프는 루프 데이터 종속성을 사용하는 최적화에 의해 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__atomic_add_fetch &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__atomic_exchange_n &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT memorder를)</target>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_load_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT memorder를)</target>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; ( &lt;var&gt;call_exp&lt;/var&gt; , &lt;var&gt;pointer_exp&lt;/var&gt; ) &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; ( &lt;var&gt;const_exp&lt;/var&gt; , &lt;var&gt;exp1&lt;/var&gt; , &lt;var&gt;exp2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_complex&lt;/strong&gt; ( &lt;var&gt;real&lt;/var&gt; , &lt;var&gt;imag&lt;/var&gt; ) &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; 발, &lt;var&gt;type&lt;/var&gt; failval)</target>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_tgmath &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;functions&lt;/var&gt; , &lt;var&gt;arguments&lt;/var&gt; )&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="translated">내장 함수 : Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</target>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t 크기, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * 예상, &lt;var&gt;type&lt;/var&gt; * 희망, 부울 약함, int success_memorder, int failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">내장 함수 : 부울 &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; * 예상 &lt;var&gt;type&lt;/var&gt; 원하는 약한, INT success_memorder을 bool에, INT failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t 크기, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; ( &lt;var&gt;type-or-expression&lt;/var&gt; , &lt;var&gt;attribute&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</target>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</target>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void * &lt;var&gt;val&lt;/var&gt; , int &lt;var&gt;alignval&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; ( &lt;var&gt;exp&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char * &lt;var&gt;feature&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char * &lt;var&gt;feature&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</target>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</target>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; , &lt;var&gt;type2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt; , long &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="translated">내장 함수 : long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</target>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="translated">내장 함수 : uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</target>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="translated">내장 함수 : uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</target>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="translated">내장 함수 : uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</target>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (* &lt;var&gt;function&lt;/var&gt; ) (), void * &lt;var&gt;arguments&lt;/var&gt; , size_t &lt;var&gt;size&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void * &lt;var&gt;exp&lt;/var&gt; , size_t &lt;var&gt;align&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (부호없는 int &lt;var&gt;level&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (부호없는 int &lt;var&gt;level&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;* __ builtin_alloca&lt;/strong&gt; (size_t size)</target>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;* __ builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</target>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;* __ builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</target>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, int memorder)</target>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void * &lt;var&gt;begin&lt;/var&gt; , void * &lt;var&gt;end&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (부호없는 int &lt;var&gt;regno&lt;/var&gt; , 부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (부호없는 int &lt;var&gt;a&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (부호없는 int &lt;var&gt;a&lt;/var&gt; , 부호없는 int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (부호없는 int &lt;var&gt;auxr&lt;/var&gt; , 부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (부호없는 int &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; , int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</target>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void * &lt;var&gt;addr&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void * &lt;var&gt;result&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</target>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</target>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void * &lt;var&gt;ptr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="translated">제한된 버퍼 오버 플로우 검사를위한 내장 기능.</target>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="translated">특정 대상에 고유 한 내장 기능.</target>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="translated">산술 및 산술 오버 플로우 검사를 수행하는 내장 함수.</target>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="translated">내장 매크로, 명령 행에 정의 된 매크로 및 포함 파일에 정의 된 매크로는 경고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="translated">그러나 메소드 시그니처 관련 문제점을 디버그해야하고 구현 방법 (예 : &quot;ABI&quot;)을 알아야하는 경우 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="translated">그러나 &lt;code&gt;foo&lt;/code&gt; 의 정의 에서는 파일 범위 유형이 상속 될 수 있기 때문에 사용됩니다. 따라서 정의와 프로토 타입이 일치하지 않아 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="translated">그러나이 예제에서 &lt;code&gt;std::move&lt;/code&gt; 호출은 복사 제거를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="translated">그러나이 정의 는 피연산자가 부작용을 갖는 경우 나쁜 결과와 함께 &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; 또는 &lt;var&gt;b&lt;/var&gt; 를 두 번 계산합니다 . GNU C에서 피연산자의 유형을 알고 있다면 (여기서는 &lt;code&gt;int&lt;/code&gt; 로 간주) 다음과 같이 매크로를 정의하여이 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="translated">반대로, 대부분의 대상 시스템의 PCC는 데이터를 정적 스토리지 영역에 복사 한 다음 포인터 값인 것처럼 해당 스토리지의 주소를 리턴하여 모든 크기의 구조 및 공용체를 리턴합니다. 호출자는 해당 메모리 영역에서 값을 원하는 위치로 데이터를 복사해야합니다. GCC는 속도가 느리고 재진입 할 ​​수 없으므로이 방법을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="translated">함수를 인라인으로 선언하면 GCC가 해당 함수를 더 빨리 호출하도록 지시 할 수 있습니다. GCC가이를 달성 할 수있는 한 가지 방법은 해당 함수의 코드를 호출자의 코드에 통합하는 것입니다. 이것은 함수 호출 오버 헤드를 제거함으로써 실행을 더 빠르게 만듭니다. 또한 실제 인수 값이 일정하면 알려진 값으로 인해 컴파일 타임에 단순화가 가능하므로 모든 인라인 함수 코드를 포함 할 필요는 없습니다. 코드 크기에 대한 영향은 예측하기 어렵습니다. 특정 경우에 따라 함수 인라인으로 객체 코드가 더 크거나 작을 수 있습니다. 또한 옵션을 사용하여 모든 &quot;간단한&quot;기능을 호출자에게 통합하도록 GCC에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="translated">기본적으로 (별도로 구성되지 않은 경우) GCC는 Visium 아키텍처의 GR5 변형에 대한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="translated">기본적으로 (다른 구성이없는 한) GCC는 SPARC 아키텍처의 V7 변형에 대한 코드를 생성합니다. 와</target>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="translated">기본적으로 GCC는 대상이 최소 4 바이트 경계에 정렬 된 것으로 알려진 경우에만 문자열 작업을 인라인합니다. 이렇게하면 인라인이 향상되고 코드 크기가 증가하지만 빠른 &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; 및 &lt;code&gt;memset&lt;/code&gt; 에 따라 짧은 길이 의 코드 성능이 향상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="translated">기본적으로 모든 통화가 멀리 떨어져 있기 때문에 더 길고 비싼 통화 순서가 필요합니다. 현재 위치에서 32MB (33,554,432 바이트)를 초과하는 통화에 필요합니다. 컴파일러가 호출을 멀리 할 수 ​​없다는 것을 알고 있으면 짧은 호출이 생성됩니다. 이 설정은 &lt;code&gt;shortcall&lt;/code&gt; 함수 속성 또는 &lt;code&gt;#pragma longcall(0)&lt;/code&gt; 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="translated">기본적으로 Objective-C의 인스턴스 변수는 선언 된 클래스의 메서드 내에서 로컬 변수 인 것처럼 액세스 할 수 있습니다. 이로 인해 인스턴스 변수와 클래스 메서드 내에서 로컬로 선언되거나 전역 적으로 선언 된 다른 변수간에 그림자가 생길 수 있습니다. 같은 이름으로. 지정</target>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="translated">기본적으로 &lt;code&gt;signed int&lt;/code&gt; 로 취급 되지만 이것은</target>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="translated">기본적으로 또는 언제</target>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="translated">기본적으로이 기능은 활성화되어 있지 않습니다. 를 통해 기본값을 복원 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="translated">기본적으로 C ++ 프론트 엔드에서 일치하지 않는 템플리트 유형을 표시하는 진단을 인쇄 할 때 오류 메시지를 단순화하기 위해 유형의 공통 부분이 &quot;[...]&quot;로 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="translated">기본적으로 GCC는 드문 경우지만 C ++ 표준과 충돌하는 C ++ 언어에 대한 추가 확장을 제공합니다. &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++ 방언 제어 옵션을&lt;/a&gt; 참조하십시오 . 의 사용</target>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="translated">피드백 프로파일이 소스 코드와 일치하지 않으면 기본적으로 GCC는 오류 메시지를 표시합니다. 이 오류는 다음을 사용하여 경고로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="translated">기본적으로 GCC는 분기 또는 분기 분기에 대한 파이프 라인 중단을 피하기 위해 분기 힌트 명령어를 생성합니다. 힌트는 브랜치에서 멀리 떨어진 8 개 명령 이상으로 생성되지 않습니다. 디버깅 목적을 제외하고 객체를 약간 작게 만드는 것을 제외하고는 비활성화 할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="translated">기본적으로 GCC는 주소가 18 비트보다 크지 않다고 가정하여 코드를 생성합니다. 와</target>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="translated">기본적으로 GCC는 3 점을 무시하지만 표준 준수 모드에서는 3 점을 변환합니다. 참조</target>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="translated">기본적으로 GCC는 NOP를 삽입하여 성능을 향상시킬 것으로 예상되는 경우 이중 문제를 증가시킵니다. &lt;var&gt;n&lt;/var&gt; 은 0에서 10 사이의 값일 수 있습니다 . &lt;var&gt;n&lt;/var&gt; 이 작을수록 NOP가 적습니다. 10은 기본값이고 0은</target>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="translated">기본적으로 GCC는 인라인 될 수있는 기능의 크기를 제한합니다. 이 플래그를 사용하면이 제한을 대략적으로 제어 할 수 있습니다. &lt;var&gt;n&lt;/var&gt; 은 여러 의사 명령어로 인라인 될 수있는 함수의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="translated">기본적으로 GCC는 SPU 스타일의 주 기능 인터페이스 (전통적인 매개 변수 목록이 있음)를 가정하는 시작 코드와 연결됩니다. 와</target>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="translated">기본적으로 GCC는 C 언어에 대한 일부 확장을 제공하며 드문 경우에 C 표준과 충돌합니다. &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;C 언어 제품군으로의 확장을&lt;/a&gt; 참조하십시오 . C99 표준의 일부인 일부 기능은 C90 모드에서 확장으로 허용되고 C11 표준의 일부인 일부 기능은 C90 및 C99 모드에서 확장으로 허용됩니다. 의 사용</target>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="translated">기본적으로 방출되는 각 진단에는 진단을 직접 제어하는 ​​명령 줄 옵션을 나타내는 텍스트가 포함됩니다 (이러한 옵션이 진단 장치에 알려진 경우). 지정</target>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="translated">기본적으로 방출되는 각 진단에는 원본 소스 라인과 캐럿 '</target>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="translated">기본적으로 &quot;높은 수준&quot;메시지 만 표시됩니다. 이 옵션을 사용하면 GCC 개발자에게만 관심이있는보다 자세한 추가 메시지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">기본적으로 소스 파일의 어셈블러 파일 이름은 접미사 '</target>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="translated">기본적으로 덤프에는 성공적인 최적화에 대한 메시지가 포함됩니다 (</target>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="translated">기본적으로 키워드 &lt;code&gt;__vector&lt;/code&gt; 가 추가됩니다. 매크로 &lt;code&gt;vector&lt;/code&gt; 는 &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; 에 정의되어 있으며 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">기본적으로 소스 파일의 오브젝트 파일 이름은 접미사 '</target>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="translated">기본적으로 소스 코드를 인쇄 할 때</target>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">바이트 스왑. &lt;var&gt;value&lt;/var&gt; 의 상위 및 하위 바이트를 교체 한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="translated">C 언어 옵션</target>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="translated">C 및 Objective-C 전용 경고 옵션</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C 코드</target>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C에는 대부분의 프로그램이 무시하기로 선택한 값을 반환하는 많은 표준 함수가 포함되어 있습니다. 한 가지 분명한 예는 &lt;code&gt;printf&lt;/code&gt; 입니다. 이러한 행위에 대해 경고 만에 캐스트 수십 혼란 프로그램에 대한 방어 프로그래머 리드 &lt;code&gt;void&lt;/code&gt; . 이러한 캐스트는 시각 노이즈가되기 위해 너무 자주 요구됩니다. 이러한 캐스트를 작성하면 프로그래머의 의도에 대한 유용한 정보를 더 이상 전달할 수 없게됩니다. 리턴 값을 무시해서는 &lt;code&gt;warn_unused_result&lt;/code&gt; 함수의 경우 warn_unused_result 함수 속성을 사용 하십시오 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="translated">C는 휘발성 객체의 개념을 가지고 있습니다. 이들은 일반적으로 포인터에 의해 액세스되며 하드웨어 또는 스레드 간 통신에 액세스하는 데 사용됩니다. 이 표준은 컴파일러가 휘발성 객체에 대한 액세스와 관련된 최적화를 자제하도록 권장하지만, 휘발성 액세스를 구성하는 요소에 대해 정의 된 구현을 유지합니다. 최소 요구 사항은 시퀀스 지점에서 휘발성 개체에 대한 이전의 모든 액세스가 안정화되고 후속 액세스가 발생하지 않은 것입니다. 따라서 구현은 시퀀스 포인트 사이에서 발생하는 휘발성 액세스를 자유롭게 재정렬하고 결합 할 수 있지만 시퀀스 포인트를 통한 액세스에는 그렇게 할 수 없습니다. 휘발성을 사용하면 두 시퀀스 포인트 사이에서 객체를 여러 번 업데이트하는 데 대한 제한을 위반할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="translated">C 레지스터.</target>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="translated">전처리해야하는 C 소스 코드.</target>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 C 소스 코드.</target>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="translated">C ++ 언어 옵션</target>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="translated">C ++ 주석이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="translated">C ++ 개념은 일반 프로그래밍에 대한 개선 된 지원을 제공합니다. 특히 템플릿 인수에 대한 제약 조건을 지정할 수 있습니다. 제약 조건은 언어의 일반적인 오버로딩 및 부분 특수화 기능을 확장하는 데 사용되므로 일반 데이터 구조 및 알고리즘을 유형 이름이 아닌 속성을 기반으로 &quot;정의&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="translated">미리 컴파일 된 헤더 또는 Ada 사양으로 변환 할 C ++ 헤더 파일</target>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="translated">C ++는 복잡한 언어이며 진화하는 언어이며 표준 정의 (ISO C ++ 표준)는 최근에 완료되었습니다. 결과적으로 C ++ 컴파일러는 동작이 올바르더라도 놀라게 할 수 있습니다. 이 섹션에서는 이러한 종류의 질문을 자주 발생시키는 일부 영역에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="translated">C ++에서는 '을 구현하기 위해 형식에 대한 정보를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="translated">사전 처리해야하는 C ++ 소스 코드. '에서</target>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 C ++ 소스 코드.</target>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="translated">C ++ 소스 파일은 일반적으로 접미사 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="translated">C ++ 템플릿은 UNIX 시스템에서 일반적으로 발견 된 것보다 환경에서 더 많은 정보를 요구하는 최초의 언어 기능이었습니다. 어떻게 든 컴파일러와 링커는 필요한 경우 각 템플릿 인스턴스가 실행 파일에서 정확히 한 번만 발생하는지 확인해야합니다. 이 문제에 대한 두 가지 기본 접근 방식이 있는데,이를 Borland 모델과 Cfront 모델이라고합니다.</target>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="translated">C ++ 가상 함수는 vtable이라는 룩업 테이블을 사용하여 대부분의 컴파일러에서 구현됩니다. vtable에는 클래스가 제공하는 가상 함수에 대한 포인터가 포함되며 클래스의 각 객체에는 해당 vtable에 대한 포인터 (또는 여러 상속 상황에서 vtable)가 포함됩니다. 클래스가 인라인이 아닌 순수한 가상 함수를 선언하면 첫 번째 함수가 클래스의 &quot;키 메소드&quot;로 선택되고 vtable은 키 메소드가 정의 된 변환 단위에서만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="translated">C ++ 17은</target>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="translated">사전 컴파일 된 헤더로 변환 될 C, C ++, Objective-C 또는 Objective-C ++ 헤더 파일 (기본값) 또는 Ada 스펙으로 변환 될 C, C ++ 헤더 파일 (</target>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="translated">C99 Annex F가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="translated">C99 제한 포인터 및 참조</target>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="translated">CET 함수 : ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="translated">CET 함수 : void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (부호없는 int)</target>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="translated">CMOV 명령.</target>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="translated">CPU에는 타임베이스가 없습니다 (예 : 601 및 403gx).</target>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="translated">CPU에는 CELL 광대역 엔진이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="translated">CPU에는 SIMD / 벡터 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="translated">CPU에는 SPE 배정도 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="translated">CPU에는 SPE 단 정밀도 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="translated">CPU에는 10 진 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="translated">CPU에는 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="translated">CPU에는 메모리 관리 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="translated">CPU에는 신호 처리 확장 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="translated">CPU에는 하드웨어 트랜잭션 메모리 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="translated">CPU가 I / D 캐시를 통합했습니다.</target>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="translated">CPU는 동시 멀티 스레딩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="translated">CPU는 128 비트 IEEE 이진 부동 소수점 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="translated">CPU는 32 비트 모드 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="translated">CPU는 64 비트 모드 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="translated">CPU는 ISA 2.00 (예 : POWER4)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="translated">CPU는 ISA 2.02 (예 : POWER5)를 지원합니다</target>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="translated">CPU는 ISA 2.03 (예 : POWER5 +)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="translated">CPU는 ISA 2.05 (예 : POWER6)를 지원합니다</target>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="translated">CPU는 ISA 2.05 (예 : POWER6) 확장 opcode mffgpr 및 mftgpr을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="translated">CPU는 ISA 2.06 (예 : POWER7)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="translated">CPU는 ISA 2.07 (예 : POWER8)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="translated">CPU는 ISA 3.0 (예 : POWER9)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="translated">CPU는 주소 스위 즐링을 사용하는 리틀 엔디안 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="translated">CPU는 이벤트 기반 분기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="translated">CPU는 하드웨어 트랜잭션 메모리를 지원하지만 &lt;code&gt;tsuspend.&lt;/code&gt; 는 지원하지 않습니다 . 교수.</target>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="translated">CPU는 icache 스누핑 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="translated">CPU는 &lt;code&gt;darn&lt;/code&gt; (난수 전달) 명령을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="translated">CPU는 Embedded ISA 범주를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="translated">CPU는 PA Semi 6T CORE ISA를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="translated">CPU는 데이터 스트림 제어 레지스터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="translated">CPU는 정수 선택 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="translated">CPU는 기존 POWER ISA를 지원합니다 (예 : 601)</target>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="translated">CPU는 호환 가능한 성능 모니터링 이벤트 세트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="translated">CPU는 대상 주소 레지스터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="translated">CPU는 벡터 암호화 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="translated">CPU는 벡터 스칼라 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="translated">CPU는 진정한 리틀 엔디안 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 10h 코어 기반 CPU. (이것은 MMX, SSE, SSE2, SSE3, SSE4A, 3DNow !, 향상된 3DNow !, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 14h 코어 기반 CPU. (이것은 MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 16h 코어 기반 CPU. 여기에는 MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX 및 64 비트 명령어 세트 확장이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="translated">CR16 아키텍처</target>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="translated">절대 호출을 위해 피연산자 const_int를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="translated">간접 호출에 대한 호출 피연산자, reg</target>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="translated">상대 호출에 대한 호출 피연산자, 기호.</target>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="translated">명명 된 함수 &lt;var&gt;function&lt;/var&gt; 호출하여 &lt;var&gt;args&lt;/var&gt; 를 전달합니다 . &lt;var&gt;args&lt;/var&gt; 는 먼저 중첩 된 스펙 문자열로 처리 된 다음 일반적인 방식으로 인수 벡터로 분할됩니다. 이 함수는 문자 그대로 현재 사양의 일부로 나타난 것처럼 처리되는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="translated">호출 규칙은 인수가 전달되고 함수 결과가 반환되는 방식을 지정하는 ABI의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="translated">0이 아닌 인수로이 함수를 호출하면 호출 프로그램의 크래쉬를 포함하여 예측할 수없는 결과가 발생할 수 있습니다. 결과적으로 안전하지 않은 것으로 간주되는 통화는</target>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">배정 밀도 부동 소수점에서 연산을 수행하는 라이브러리 함수를 호출합니다. 0으로 나누면 부동 소수점 예외가 발생합니다. 이것이 FPU를 사용한 SHcompact의 기본값입니다. 배정 밀도 FPU가없는 대상에 대해이를 지정하면 기본값은 &lt;code&gt;call-div1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">작은 제수의 경우 찾아보기 테이블을 사용하고 큰 제수의 경우 대소 문자를 구분 하는 &lt;code&gt;div1&lt;/code&gt; 명령어 를 사용하는 라이브러리 함수를 호출합니다 . 0으로 나누기는 지정되지 않은 결과를 계산하고 트랩하지 않습니다. 이것이 SH4의 기본값입니다. 동적 이동 명령이없는 대상에 대해이를 지정하면 기본값은 &lt;code&gt;call-div1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="translated">단일 단계 나누기 명령어 &lt;code&gt;div1&lt;/code&gt; 을 사용하여 작업을 수행 하는 라이브러리 함수를 호출합니다 . 0으로 나누기는 지정되지 않은 결과를 계산하고 트랩하지 않습니다. SH4, SH2A 및 SHcompact를 제외한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="translated">에 전화 &lt;code&gt;foo&lt;/code&gt; 는이 호출에 매핑되는 &lt;code&gt;foo{20040821}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="translated">이 속성을 가진 외부 함수에 대한 호출은 리턴 또는 예외 처리를 통해서만 현재 컴파일 단위로 리턴해야합니다. 특히 리프 함수는 현재 컴파일 단위에서 전달 된 콜백 함수를 호출하거나 장치에서 내 보낸 함수를 직접 호출하거나 단위로 &lt;code&gt;longjmp&lt;/code&gt; 를 호출 할 수 없습니다 . 리프 함수는 여전히 다른 컴파일 단위의 함수를 호출 할 수 있으므로 함수 호출이 전혀 없다는 의미에서 반드시 리프 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">값을 반환하는 것 이외의 다른 프로그램 상태에 영향을 미치지 않는 함수를 호출하면 일반적인 하위 표현식 제거와 같은 최적화에 적합 할 수 있습니다. &lt;code&gt;pure&lt;/code&gt; 속성으로 이러한 함수를 선언 하면 GCC는 동일한 인수 값으로 함수를 반복적으로 호출 할 때 일부 호출이 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">반환 값이 프로그램의 관찰 가능한 상태 변경에 의해 영향을받지 않고 값을 반환하는 것 이외의 상태에 대해 관찰 가능한 영향이없는 함수를 호출하면 일반적인 하위 표현식 제거와 같은 최적화에 적합 할 수 있습니다. &lt;code&gt;const&lt;/code&gt; 속성을 사용 하여 이러한 함수를 선언 하면 GCC는 동일한 인수 값으로 함수를 반복적으로 호출 할 때 일부 호출이 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">술어 &lt;var&gt;predicate&lt;/var&gt; 로 어설 션을 취소 하고 응답을 &lt;var&gt;answer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">내장 또는 제공되는 &lt;var&gt;name&lt;/var&gt; 의 이전 정의를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="translated">노조 구성원으로부터 노조 유형으로 캐스팅.</target>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="translated">가스가 바람둥이 통계를 출력하게합니다.</target>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="translated">잘못된 아키텍처를 가진 파일과 관련된 오류가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="translated">GCC가 각 &lt;code&gt;push&lt;/code&gt; 시점 의 진단 상태를 기억하고 각 &lt;code&gt;pop&lt;/code&gt; 에서 해당 지점으로 복원합니다 . 경우 &lt;code&gt;pop&lt;/code&gt; 일치가없는 &lt;code&gt;push&lt;/code&gt; 명령 줄 옵션이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">모든 기능이 &lt;code&gt;.far&lt;/code&gt; 섹션 으로 기본 설정됩니다 . 이 옵션이 없으면 기능은 기본적으로 &lt;code&gt;.near&lt;/code&gt; 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="translated">모든 변수의 기본값은 &lt;code&gt;.tiny&lt;/code&gt; 섹션입니다. 이 섹션에는 65536 바이트 제한이 있습니다. 이러한 변수에 대한 액세스는 &lt;code&gt;%gp&lt;/code&gt; 기본 레지스터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">상수 변수를 &lt;code&gt;.near&lt;/code&gt; 섹션에 배치 합니다.</target>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="translated">파일이로드되거나 시작될 때 동적 링커가 정의되지 않은 모든 참조를 바인딩하도록 출력 파일이 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="translated">기본적으로 변수가 &lt;code&gt;.far&lt;/code&gt; 섹션에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="translated">기본적으로 변수가 &lt;code&gt;.near&lt;/code&gt; 섹션에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="translated">모든 컴파일 단위에서 일치하는 특정 ABI 변경 플래그가 필요하며 링크 시간에 충돌하는 값으로이를 대체하려는 시도는 무시됩니다. 여기에는 다음과 같은 옵션이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="translated">최적화를 사용하여 컴파일 할 때 디버거가 특정 로컬 변수를 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="translated">정면 모델</target>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="translated">이중 단어 insns를 사용하도록 ABI를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="translated">단락 1 변경</target>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="translated">단락 2 변경</target>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="translated">단락 2를</target>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">IBM 확장 정밀도 long double을 사용하도록 현재 ABI를 변경하십시오. 시스템이 IEEE 확장 정밀 long double을 기본으로 사용하는 경우에는 작동하지 않을 수 있습니다. IEEE 확장 정밀도에서 long double 유형을 변경하면 컴파일러에서</target>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">IEEE 확장 정밀 long double을 사용하도록 현재 ABI를 변경하십시오. 시스템이 기본적으로 IBM 확장 정밀 long double을 사용하는 경우에는 작동하지 않을 수 있습니다. IBM 확장 정밀도에서 long double 유형을 변경하면 컴파일러는 다음을 사용하지 않는 한 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">ELFv1 ABI를 사용하도록 현재 ABI를 변경하십시오. 빅 엔디안 PowerPC 64 비트 Linux의 기본 ABI입니다. 기본 ABI를 재정의하려면 특별한 시스템 지원이 필요하며 놀라운 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">ELFv2 ABI를 사용하도록 현재 ABI를 변경하십시오. 이것은 리틀 엔디안 PowerPC 64 비트 Linux의 기본 ABI입니다. 기본 ABI를 재정의하려면 특별한 시스템 지원이 필요하며 놀라운 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="translated">선호하는 SIMD 모드를 SImode로 변경하십시오. 디폴트는</target>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="translated">종속성 생성에 의해 생성 된 규칙의 대상을 변경하십시오. 기본적으로 CPP는 기본 입력 파일의 이름을 사용하고 디렉토리 구성 요소 및 '와 같은 파일 접미 부를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="translated">제공된 인수에 지정된 형식 문자열에 적합한 유형이 있고 형식 문자열에 지정된 변환이 의미가 있는지 &lt;code&gt;printf&lt;/code&gt; 및 &lt;code&gt;scanf&lt;/code&gt; 등의 호출을 확인하십시오. 이 형식 특성 (참조가 지정한 표준 기능 등이 포함 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성&lt;/a&gt; )에서에서 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 및 &lt;code&gt;strfmon&lt;/code&gt; (안 C 표준의 X / 열기 확장) 가족 (또는 다른 대상별 가정). 형식 속성을 지정하지 않고 확인할 기능은 선택한 표준 버전에 따라 다르며, 특성을 지정하지 않은 기능 확인은</target>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="translated">추가 / 서브 명령어에 대한 64 비트 폭 상수 확인</target>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="translated">할당 된 스토리지를 수정하기 전에 &lt;code&gt;operator new&lt;/code&gt; 가 리턴 한 포인터 가 널이 아닌지 점검하십시오 . C ++ 표준은 &lt;code&gt;operator new&lt;/code&gt; 가 &lt;code&gt;throw()&lt;/code&gt; 로 선언 된 경우 &lt;code&gt;0&lt;/code&gt; 만 반환 하도록 지정하므로이 검사는 일반적으로 불필요 합니다.이 경우 컴파일러는이 옵션 없이도 항상 반환 값을 확인합니다. 다른 모든 경우에 &lt;code&gt;operator new&lt;/code&gt; 비어 있지 않은 예외 사양이있는 경우 &lt;code&gt;std::bad_alloc&lt;/code&gt; 시켜 메모리 소진을 알립니다 . 또한보십시오 '</target>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="translated">코드에 구문 오류가 있는지 확인하지만 그 이상은 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="translated">구식 정의가 있고 프로토 타입이없는 함수에 대한 인수의 수와 유형 확인</target>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">데이터 모델을 선택하십시오. &lt;var&gt;model&lt;/var&gt; 선택 은 '</target>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="translated">사용 가능한 두 가지 구현 중에서 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="translated">정수 유형을 32 비트 너비로 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="translated">시뮬레이터에 적합한 시작 파일 및 링커 스크립트를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="translated">다진 라운딩 모드. 부동 소수점 숫자는 0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="translated">parloops에 의해 병렬화 된 루프에 대한 omp 스케줄의 청크 크기.</target>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="translated">클로버 설명은 입력 또는 출력 피연산자와 겹치지 않을 수 있습니다. 예를 들어, 클로버 목록에 해당 레지스터를 나열 할 때 하나의 멤버로 레지스터 클래스를 설명하는 피연산자가 없을 수 있습니다. 특정 레지스터에 존재하도록 선언되고 ( &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수&lt;/a&gt; 참조 ) &lt;code&gt;asm&lt;/code&gt; 입력 또는 출력 피연산자 로 사용되는 변수 는 클로버 설명에 언급되지 않아야합니다. 특히, 입력 피연산자를 출력 피연산자로 지정하지 않고 입력 피연산자가 수정되도록 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">코드 생성 옵션</target>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="translated">32 비트로드 분할, 사후 증가 주소 생성 및 사후 수정 주소 생성을 각각 비활성화하는 코드 생성 조정. 기본값은</target>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="translated">이와 같은 코드는 다른 컴파일러, 특히 일반 로컬 변수와 함께 임시를 삭제하는 오래된 cfront 기반 컴파일러에서 성공적으로 실행될 수 있습니다. 그러나 GNU C ++ 동작은 표준을 준수하므로 프로그램이 일시적인 파괴에 의존하는 경우 이식성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SREG&lt;/code&gt; 의 메모리 위치에 써서 &lt;code&gt;I&lt;/code&gt; 플래그 이외 의 SREG 비트를 (효과적으로) 클로버 하는 &lt;code&gt;SREG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="translated">인라인 어셈블러를 사용하여 위에서 설명한대로 프롤로그 코드의 일부를 예상하는 다른 함수로 이동하는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="translated">내부 컴파일러 오류 (ICE)가 발생하면 디버그 정보를 임시 파일로 수집하고 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="translated">다른 입력 세트에 대한 프로파일을 수집하고이 도구를 사용하여 병합하십시오. 각 입력의 상대적 중요성을 고려하여 가중치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="translated">주소 증가 또는 감소를 메모리 액세스와 결합합니다. 이 단계는이를 지원하기위한 지침이없는 아키텍처에서는 항상 건너 뜁니다. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 및 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 의 효과를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="translated">일반적으로 출력을 너무 제한하여 표시 할 항목이 없지만 여러 클래스를 결합 할 수 있습니다. 그러나 작동하는 한 가지 경우는 클래스 중 하나가 &lt;var&gt;target&lt;/var&gt; 일 때 입니다. 예를 들어 모든 대상별 최적화 옵션을 표시하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="translated">'에서 지원하는 명령 옵션</target>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="translated">현재 트랜잭션을 커밋하십시오. 활성화 된 트랜잭션이 없으면이 결함이 발생합니다. 트랜잭션의 모든 메모리 부작용은 원자적인 방식으로 다른 스레드에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="translated">GNU C ++의 일반적인 오해.</target>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="translated">최대 &lt;var&gt;num&lt;/var&gt; 문자열 바이트를 인라인 코드와 비교하십시오 . 인라인 끝에서 문자열의 차이 또는 끝을 찾을 수 없으면 &lt;code&gt;strcmp&lt;/code&gt; 또는 &lt;code&gt;strncmp&lt;/code&gt; 에 대한 호출 이 나머지 비교를 처리합니다. 기본값은 64 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="translated">4 개의 단일 쌍 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any4t&lt;/code&gt; / &lt;code&gt;bc1any4f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any2t&lt;/code&gt; / &lt;code&gt;bc1any2f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="translated">비교 연산.</target>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="translated">C ++의 이전 정의와의 호환성</target>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="translated">컴파일은 최대 4 단계 (전처리, 적절한 컴파일, 어셈블리 및 링크)를 항상 순서대로 포함 할 수 있습니다. GCC는 여러 파일을 여러 개의 어셈블러 입력 파일 또는 한 개의 어셈블러 입력 파일로 사전 처리하고 컴파일 할 수 있습니다. 그런 다음 각 어셈블러 입력 파일은 객체 파일을 생성하고 링크는 모든 객체 파일 (새로 컴파일 된 파일 및 입력으로 지정된 파일)을 실행 파일로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">승수 설계 옵션으로 ARCv2 코드를 컴파일하십시오. &lt;var&gt;multo&lt;/var&gt; 에 문자열 또는 숫자 값을 사용하여 옵션을 지정할 수 있습니다 . '</target>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="translated">IEEE 신호 NaN이 부동 소수점 연산 중에 사용자가 볼 수있는 트랩을 생성 할 수 있다고 가정 한 코드를 컴파일하십시오. 이 옵션을 설정하면 신호 NaN에 표시되는 예외 수를 변경할 수있는 최적화가 비활성화됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="translated">부동 소수점 연산이 사용자가 볼 수있는 트랩을 생성 할 수 없다고 가정하여 코드를 컴파일하십시오. 이러한 트랩에는 0으로 나누기, 오버플로, 언더 플로, 부정확 한 결과 및 잘못된 작업이 포함됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="translated">&lt;code&gt;__ea&lt;/code&gt; 명명 된 주소 공간 한정자 를 통해 액세스 한 PPU 주소 공간에 대한 포인터의 너비 가 32 비트 또는 64 비트 라고 가정하고 코드를 컴파일합니다 . 디폴트는 32 비트입니다. 이것은 ABI 변경 옵션이므로 실행 파일의 모든 객체 코드는 동일한 설정으로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="translated">Android 플랫폼과 호환되는 코드를 컴파일하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="translated">빅 엔디안 모드를위한 코드를 컴파일하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="translated">빅 엔디안 타겟을위한 컴파일 코드. 이 옵션은 더 이상 사용되지 않습니다. big-endian 코드는 &lt;code&gt;arceb-elf32&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 을 빌드하도록 GCC를 구성하여 지원됩니다 . big endian이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="translated">리틀 엔디안 모드를위한 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="translated">리틀 엔디안 대상에 대한 코드를 컴파일하십시오. 이 옵션은 더 이상 사용되지 않습니다. 리틀 엔디안 코드는 &lt;code&gt;arc-elf32&lt;/code&gt; 및 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 대상 을 빌드하도록 GCC를 구성하여 지원되며 리틀 엔디안이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="translated">빅 엔디안 모드에서 프로세서의 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="translated">리틀 엔디안 모드에서 프로세서의 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 32x16 비트 곱하기 명령어를 사용 하여 ARC 600 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 &lt;code&gt;mul64&lt;/code&gt; 제품군 명령어를 사용 하여 ARC 600 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 명령어를 사용 하여 ARC 600 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 32x16 비트 곱하기 명령어를 사용 하여 ARC 601 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 &lt;code&gt;mul64&lt;/code&gt; -family 명령어를 사용 하여 ARC 601 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 명령어가 활성화 된 ARC 601 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="translated">NPS400 칩에서 ARC 700을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="translated">하드웨어 확장이없는 ARC EM CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="translated">레지스터 세트가 축소 된 ARC EM 미니멀리즘 구성을위한 컴파일</target>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="translated">ARC EM을 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="translated">ARC EM4 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="translated">단 정밀도 부동 소수점 및 이중 지원 명령어로 ARC EM4 DMIPS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="translated">단 정밀도 부동 소수점 확장을 사용하여 ARC EM4 DMIPS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="translated">ARC EM4 DMIPS CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="translated">원자 명령어를 제외하고 하드웨어 확장이없는 ARC HS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="translated">ARC HS를위한 컴파일</target>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="translated">ARC HS34 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="translated">모든 하드웨어 확장이 설정된 ARC HS38 CPU를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="translated">ARC HS38 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="translated">ARC600을 위해 컴파일하십시오. 별칭 :</target>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="translated">ARC601을 위해 컴파일하십시오. 별명:</target>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="translated">ARC700을 위해 컴파일하십시오. 별칭 :</target>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="translated">GCN3 피지 장치 (gfx803) 용으로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="translated">GCN5 Vega 10 장치 (gfx900) 용으로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="translated">소스 파일을 컴파일하거나 어셈블하지만 링크하지는 마십시오. 연결 단계는 단순히 수행되지 않습니다. 최종 출력은 각 소스 파일에 대한 오브젝트 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="translated">소스 파일을 추가로 컴파일</target>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="translated">소스 파일을 컴파일</target>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="translated">와 코드를 컴파일</target>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="translated">템플릿 사용 코드를 사용하여 컴파일</target>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="translated">컴파일러 인코딩</target>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="translated">유형 특성에 대한 컴파일러 지원</target>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="translated">C ++ 프로그램 컴파일</target>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="translated">헤더를 한 번 컴파일하고 여러 번 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="translated">로 컴파일</target>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="translated">복잡한 곱셈과 나눗셈은 포트란 규칙을 따릅니다. 범위 축소는 복소수 나눗셈의 일부로 수행되지만 복소수 곱셈 또는 나눗셈의 결과가 &lt;code&gt;NaN + I*NaN&lt;/code&gt; 인지 여부는 확인되지 않으며 ,이 경우 상황을 구조하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="translated">복잡한 유형</target>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="translated">Renesas가 정의한 통화 규약을 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="translated">르네사스 협약을 사용하기 전에 GCC에 대해 정의 된 통화 규칙을 준수하십시오. 이 옵션은 SH 툴체인의 모든 대상에 대한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="translated">스칼라 유형 및 공용체 유형의 복합 리터럴도 허용됩니다. 다음 예제에서 변수 &lt;code&gt;i&lt;/code&gt; 는 값 &lt;code&gt;2&lt;/code&gt; 로 초기화되며 , 그 결과 복합 리터럴에 의해 생성 된 명명되지 않은 객체가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="translated">복합 리터럴은 구조, 공용체 또는 배열을 값으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="translated">Ft32B 코드 압축 체계를 사용하여 모든 코드를 압축하십시오.</target>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="translated">지정된 두 프로파일 디렉토리 사이의 오버랩 스코어를 계산하십시오. 오버랩 점수는 아크 프로파일을 기반으로 계산됩니다. p1_counter [i] 및 p2_counter [i]는 일치하는 두 카운터이고 p1_sum_all 및 p2_sum_all은 모든 아크 카운터 i에 대해 최소의 합 (p1_counter [i] / p1_sum_all, p2_counter [i] / p2_sum_all)으로 정의됩니다. 프로필 1과 프로필 2의 카운터 값 합계</target>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="translated">조건 코드 레지스터</target>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">절대 비교에 따른 조건부 이동 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">부동 소수점 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; )에 기반한 조건부 이동 .</target>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="translated">보드 별 런타임을 구성하십시오. 이것은 newlib 보드 라이브러리 링크를 위해 링커로 전달됩니다. 기본값은 &lt;code&gt;or1ksim&lt;/code&gt; 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
