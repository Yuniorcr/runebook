<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="ea3c4fdc7ae483f6eeee71767d6d7c25afd3b747" translate="yes" xml:space="preserve">
          <source>ULLK</source>
          <target state="translated">ULLK</target>
        </trans-unit>
        <trans-unit id="bd9c57578a5fa70fa2923dfa1948bb1047652950" translate="yes" xml:space="preserve">
          <source>ULLR</source>
          <target state="translated">ULLR</target>
        </trans-unit>
        <trans-unit id="181f09b6cf6ff48fe2bced4f8717c409974c7ccb" translate="yes" xml:space="preserve">
          <source>ULR</source>
          <target state="translated">ULR</target>
        </trans-unit>
        <trans-unit id="fdf943dd853f60e8f066b9ff1db365525dfa7714" translate="yes" xml:space="preserve">
          <source>UR</source>
          <target state="translated">UR</target>
        </trans-unit>
        <trans-unit id="b92dcc34c6f88a2b085f0fcf11324b5c2cf08f22" translate="yes" xml:space="preserve">
          <source>Unary absolute value.</source>
          <target state="translated">단항 절대 값.</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">단항 부정.</target>
        </trans-unit>
        <trans-unit id="5b74b98336e7267fb4f37f0b361c833e21dc0aa0" translate="yes" xml:space="preserve">
          <source>Unary square root operation.</source>
          <target state="translated">단항 제곱근 연산.</target>
        </trans-unit>
        <trans-unit id="00399f106390204b9e8a47f8e8e78be426150d13" translate="yes" xml:space="preserve">
          <source>Unbounded uses, on the other hand, are uses of &lt;code&gt;alloca&lt;/code&gt; with no controlling predicate constraining its integer argument. For example:</source>
          <target state="translated">반면, 무제한 사용 은 정수 인수를 제한하는 제어 술어없이 &lt;code&gt;alloca&lt;/code&gt; 를 사용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba59d2b5ffc5c4e08397a280a30fb560e8436a" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; when</source>
          <target state="translated">__STDC__ &lt;code id=&quot;index-std-3&quot;&gt;__STDC__&lt;/code&gt; 할 때</target>
        </trans-unit>
        <trans-unit id="f070a98f1b801c2b6e78c0be33c88683a70671cf" translate="yes" xml:space="preserve">
          <source>Undefining &lt;code&gt;__STDC__&lt;/code&gt; in C++.</source>
          <target state="translated">정의 해제 &lt;code&gt;__STDC__&lt;/code&gt; C ++에서.</target>
        </trans-unit>
        <trans-unit id="ca3f9bb4feba0ac0f3a9b154b20506b4c489b2f4" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your &lt;code&gt;asm&lt;/code&gt; code defines symbols or labels. Using &amp;lsquo;</source>
          <target state="translated">특정 상황에서 GCC는 최적화 할 때 어셈블리 코드를 복제하거나 제거 할 수 있습니다. &lt;code&gt;asm&lt;/code&gt; 코드가 심볼 또는 레이블을 정의하는 경우 컴파일 중에 예기치 않은 중복 심볼 오류가 발생할 수 있습니다 . 사용하여</target>
        </trans-unit>
        <trans-unit id="199aae5416e814ba38647e12711c671c6b6db5a1" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, GCC may duplicate (or remove duplicates of) your assembly code when optimizing. This can lead to unexpected duplicate symbol errors during compilation if your assembly code defines symbols or labels.</source>
          <target state="translated">특정 상황에서 GCC는 최적화 할 때 어셈블리 코드를 복제하거나 제거 할 수 있습니다. 어셈블리 코드에서 기호 나 레이블을 정의하면 컴파일 중에 예기치 않은 중복 기호 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b29a25fd6f124cae730e139b0e10b10a80e560" translate="yes" xml:space="preserve">
          <source>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings:</source>
          <target state="translated">불행히도 역사적으로 GCC는 인코딩 코드에 많은 버그가있었습니다. NeXT 런타임은 GCC가이 히스토리 형식 (GCC-3.3과 호환)으로 유형 인코딩을 생성 할 것으로 예상하므로 NeXT 런타임을 사용할 때 GCC는 의도적으로 여러 가지 잘못된 인코딩을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="aeee418a8137652ee6d9ab3008a38b4d74bc2a2f" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there&amp;rsquo;s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC.</source>
          <target state="translated">불행히도, ISO C 및 ISO C ++에 의해 식별자에 허용되는 일부 문자가 있으며 NFC로 변환 될 때 식별자에 허용되지 않습니다. 즉, 휴대용 ISO C 또는 C ++에서 이러한 기호를 사용하고 NFC에 모든 식별자를 사용할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ddc1e63d4f989177759a83df41bd4b7dad20371" translate="yes" xml:space="preserve">
          <source>Unix C compilers have traditionally allocated storage for uninitialized global variables in a common block. This allows the linker to resolve all tentative definitions of the same variable in different compilation units to the same object, or to a non-tentative definition. This is the behavior specified by</source>
          <target state="translated">유닉스 C 컴파일러는 전통적으로 초기화되지 않은 전역 변수에 대한 스토리지를 공통 블록으로 할당했습니다. 이를 통해 링커는 다른 컴파일 단위에있는 동일한 변수의 모든 임시 정의를 동일한 객체 또는 비 가정 정의로 해석 할 수 있습니다. 이것은 다음에 의해 지정된 동작입니다</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="d6a3e0eb54ec1efd8ae1e1735e817354b9b6421f" translate="yes" xml:space="preserve">
          <source>Unless &lt;var&gt;*ptr&lt;/var&gt; and &lt;var&gt;vobj&lt;/var&gt; can be aliased, it is not guaranteed that the write to &lt;var&gt;*ptr&lt;/var&gt; occurs by the time the update of &lt;var&gt;vobj&lt;/var&gt; happens. If you need this guarantee, you must use a stronger memory barrier such as:</source>
          <target state="translated">하지 않는 한 &lt;var&gt;*ptr&lt;/var&gt; 및 &lt;var&gt;vobj&lt;/var&gt; 이 별명 할 수 있습니다,에 기록하지는 않습니다 &lt;var&gt;*ptr&lt;/var&gt; 의 업데이트 시간에 의해 발생 &lt;var&gt;vobj&lt;/var&gt; 가 발생합니다. 이 보증이 필요한 경우 다음과 같은 강력한 메모리 장벽을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9e3382936f0af0d7125a8bf9b98d564d02b82c4" translate="yes" xml:space="preserve">
          <source>Unless specified explicitly (with</source>
          <target state="translated">명시 적으로 지정하지 않는 한</target>
        </trans-unit>
        <trans-unit id="5eaa8563a22dc64db7ac666eb5d3e5ba11cc1996" translate="yes" xml:space="preserve">
          <source>Unlike Java, Objective-C does not allow for entire methods to be marked &lt;code&gt;@synchronized&lt;/code&gt;. Note that throwing exceptions out of &lt;code&gt;@synchronized&lt;/code&gt; blocks is allowed, and will cause the guarding object to be unlocked properly.</source>
          <target state="translated">Java와 달리 Objective-C에서는 전체 메소드를 &lt;code&gt;@synchronized&lt;/code&gt; 로 표시 할 수 없습니다 . &lt;code&gt;@synchronized&lt;/code&gt; 블록에서 예외 를 발생시키는 것이 허용되며 보호 객체가 올바르게 잠금 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd317bbd72a217068977127c104995a9862be9b" translate="yes" xml:space="preserve">
          <source>Unlike for floating-point numbers in the decimal notation the exponent is always required in the hexadecimal notation. Otherwise the compiler would not be able to resolve the ambiguity of, e.g., &lt;code&gt;0x1.f&lt;/code&gt;. This could mean &lt;code&gt;1.0f&lt;/code&gt; or &lt;code&gt;1.9375&lt;/code&gt; since &amp;lsquo;</source>
          <target state="translated">10 진수 표기법의 부동 소수점 숫자와 달리 지수는 항상 16 진수 표기법에 필요합니다. 그렇지 않으면 컴파일러는 &lt;code&gt;0x1.f&lt;/code&gt; 와 같은 모호성을 해결할 수 없습니다 . '이후 &lt;code&gt;1.0f&lt;/code&gt; 또는 &lt;code&gt;1.9375&lt;/code&gt; 를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c540371c5127336fc94b6b29fa3c46f81c44897b" translate="yes" xml:space="preserve">
          <source>Unlike in C, in C++, flowing off the end of a non-&lt;code&gt;void&lt;/code&gt; function other than &lt;code&gt;main&lt;/code&gt; results in undefined behavior even when the value of the function is not used.</source>
          <target state="translated">C와 달리 C ++에서는 &lt;code&gt;main&lt;/code&gt; 이외의 &lt;code&gt;void&lt;/code&gt; 가 아닌 함수 의 끝에서 흘러 나오면 함수 값을 사용하지 않더라도 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a830c95434f7db0cbf0fd8fd9277c1d051a3f31" translate="yes" xml:space="preserve">
          <source>Unnamed struct/union fields within structs/unions.</source>
          <target state="translated">구조체 / 연합 내의 이름없는 구조체 / 연합 필드</target>
        </trans-unit>
        <trans-unit id="205edf29824c8a0cb244fc56417458952c504c66" translate="yes" xml:space="preserve">
          <source>Unrecognized input files, not requiring compilation or assembly, are ignored.</source>
          <target state="translated">컴파일이나 어셈블리가 필요없는 인식 할 수없는 입력 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a51fd22f926dc0631cc272a22033e9d7fec59c36" translate="yes" xml:space="preserve">
          <source>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.</source>
          <target state="translated">루프가 입력 될 때 반복 횟수가 확실하지 않더라도 모든 루프를 언롤하십시오. 일반적으로 프로그램이 더 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fc450b83181b0c2161a73acfdbf2dc658513bec3" translate="yes" xml:space="preserve">
          <source>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.</source>
          <target state="translated">컴파일 시간 또는 루프 시작시 반복 횟수를 판별 할 수있는 루프를 언롤하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4d059f80e723b4d81766ec66adc71e8b2e5c48" translate="yes" xml:space="preserve">
          <source>Unsigned 12-bit constant (0&amp;ndash;4095)</source>
          <target state="translated">부호없는 12 비트 상수 (0&amp;ndash;4095)</target>
        </trans-unit>
        <trans-unit id="aec081f8e4cecc49f843970cd77df1a02a1c1643" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer (in the range 0 to 65535)</source>
          <target state="translated">부호없는 16 비트 정수 (0 ~ 65535 범위)</target>
        </trans-unit>
        <trans-unit id="01dcb67eb6663625a6596ec55251e6ebe419078e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant</source>
          <target state="translated">부호없는 16 비트 상수</target>
        </trans-unit>
        <trans-unit id="005d69054eb4a9d53e3d7fc838909272fcdf1d1e" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit constant shifted left 16 bits (use &amp;lsquo;</source>
          <target state="translated">부호없는 16 비트 상수 왼쪽으로 16 비트 이동 ( '</target>
        </trans-unit>
        <trans-unit id="803ea2cff434611bd7a889a5f8f4e2a80e2f6534" translate="yes" xml:space="preserve">
          <source>Unsigned 16-bit integer constant.</source>
          <target state="translated">부호없는 16 비트 정수 상수.</target>
        </trans-unit>
        <trans-unit id="baffe105924a920d4f7c404a4974ebe483612051" translate="yes" xml:space="preserve">
          <source>Unsigned 3 bit integer (in the range 0 to 7)</source>
          <target state="translated">부호없는 3 비트 정수 (0 ~ 7 범위)</target>
        </trans-unit>
        <trans-unit id="5d0b43b79f775a23c99274c057849b2132918314" translate="yes" xml:space="preserve">
          <source>Unsigned 5 bit integer (in the range 0 to 31)</source>
          <target state="translated">부호없는 5 비트 정수 (0 ~ 31 범위)</target>
        </trans-unit>
        <trans-unit id="ee9e535a39880e194545226484f376dc9293656d" translate="yes" xml:space="preserve">
          <source>Unsigned 7 bit integer (in the range 0 to 127)</source>
          <target state="translated">부호없는 7 비트 정수 (0 ~ 127 범위)</target>
        </trans-unit>
        <trans-unit id="64587bc80a139da54c64da1869304a4854d6ae7d" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit constant (0&amp;ndash;255)</source>
          <target state="translated">부호없는 8 비트 상수 (0&amp;ndash;255)</target>
        </trans-unit>
        <trans-unit id="389b98b2eb7e556938b37c1b397214bf77e480bb" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer constant (for &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; instructions).</source>
          <target state="translated">(부호없는 8 비트 정수 상수 &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; 지침).</target>
        </trans-unit>
        <trans-unit id="8f0359d8e4b83d3d17663b1351a70fc1f8166d35" translate="yes" xml:space="preserve">
          <source>Unsigned constant that fits in 4 bits</source>
          <target state="translated">4 비트에 맞는 부호없는 상수</target>
        </trans-unit>
        <trans-unit id="2b90c224883efa79af0519ac0faa9b9d93afd6a8" translate="yes" xml:space="preserve">
          <source>Unsigned constant valid for BccUI instructions</source>
          <target state="translated">BccUI 명령어에 유효한 부호없는 상수</target>
        </trans-unit>
        <trans-unit id="6f39b25ebfb39b4238321ae23982857dd100a843" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 15-bit value.</source>
          <target state="translated">부호없는 즉시 15 비트 값.</target>
        </trans-unit>
        <trans-unit id="643476a0dd6f53437ba7e1cc7fb664b7f588a51c" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 3-bit value.</source>
          <target state="translated">부호없는 즉시 3 비트 값.</target>
        </trans-unit>
        <trans-unit id="45a42311f5f53acd8a7d22cb085352156026813a" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 4-bit value.</source>
          <target state="translated">부호없는 즉시 4 비트 값.</target>
        </trans-unit>
        <trans-unit id="39b8bb86545b9e829db3c4d0a8f246e834af0861" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value for movpi45 instruction with range 16&amp;ndash;47.</source>
          <target state="translated">범위 16&amp;ndash;47의 movpi45 명령에 대한 부호없는 즉시 5 비트 값.</target>
        </trans-unit>
        <trans-unit id="899fe6e57441b37398096e6133a6ef0bf027d95b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 5-bit value.</source>
          <target state="translated">부호없는 즉시 5 비트 값.</target>
        </trans-unit>
        <trans-unit id="deb14acda231f891d200f45725f5e7e68bae6ef4" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</source>
          <target state="translated">addri36.sp 명령에 대한 부호없는 즉시 6 비트 값 제한 조건.</target>
        </trans-unit>
        <trans-unit id="4d84bf34896cf4e54d3ca29c18d4eaac197e6b98" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 8-bit value.</source>
          <target state="translated">부호없는 즉시 8 비트 값.</target>
        </trans-unit>
        <trans-unit id="0063ff83a123db3db2d8d12d6f824ef8fd590f5b" translate="yes" xml:space="preserve">
          <source>Unsigned immediate 9-bit value.</source>
          <target state="translated">부호없는 즉시 9 비트 값.</target>
        </trans-unit>
        <trans-unit id="39e06dafd3f0aedfc6583e0a42cd32ba3116cfa2" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;Executing code before main&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Up : &lt;a href=&quot;executing-code-before-main#Executing-code-before-main&quot;&gt;메인&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt; ] 전에 코드 실행</target>
        </trans-unit>
        <trans-unit id="a632eb28fbdc638221eda735f91ebefbd97cd0d5" translate="yes" xml:space="preserve">
          <source>Up: &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD Architecture (MSA) Support&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">위로 : &lt;a href=&quot;mips-simd-architecture-_0028msa_0029-support#MIPS-SIMD-Architecture-_0028MSA_0029-Support&quot;&gt;MIPS SIMD 아키텍처 (MSA) 지원&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="62c310f2ecc602f87c21d2fd813dc1c5d88ab539" translate="yes" xml:space="preserve">
          <source>Upon entering the &lt;code&gt;@synchronized&lt;/code&gt; block, a thread of execution shall first check whether a lock has been placed on the corresponding &lt;code&gt;guard&lt;/code&gt; object by another thread. If it has, the current thread shall wait until the other thread relinquishes its lock. Once &lt;code&gt;guard&lt;/code&gt; becomes available, the current thread will place its own lock on it, execute the code contained in the &lt;code&gt;@synchronized&lt;/code&gt; block, and finally relinquish the lock (thereby making &lt;code&gt;guard&lt;/code&gt; available to other threads).</source>
          <target state="translated">&lt;code&gt;@synchronized&lt;/code&gt; 블록 에 들어가면, 실행 스레드는 먼저 다른 스레드에 의해 해당 &lt;code&gt;guard&lt;/code&gt; 객체 에 잠금이 설정되어 있는지 확인해야합니다 . 만약 있다면, 현재 스레드는 다른 스레드가 잠금을 해제 할 때까지 기다려야합니다. 일단 &lt;code&gt;guard&lt;/code&gt; 사용할 수있게되면, 현재의 thread는, 그것을 자신의 잠금 장치를 두는에 포함 된 코드 실행됩니다 &lt;code&gt;@synchronized&lt;/code&gt; 블록을, 그리고 마지막으로 (하여 만들기 잠금을 포기 &lt;code&gt;guard&lt;/code&gt; 다른 스레드에 사용 가능).</target>
        </trans-unit>
        <trans-unit id="b8aaa5b821490b029c1a6fe5ed310256ca59552f" translate="yes" xml:space="preserve">
          <source>Upper floating point register (32-bit), floating point register (64-bit)</source>
          <target state="translated">상위 부동 소수점 레지스터 (32 비트), 부동 소수점 레지스터 (64 비트)</target>
        </trans-unit>
        <trans-unit id="06ee1205db8b9a4061f4febc2c51ef1b19f3d539" translate="yes" xml:space="preserve">
          <source>Usage of ISO string concatenation is detected.</source>
          <target state="translated">ISO 문자열 연결 사용이 감지되었습니다.</target>
        </trans-unit>
        <trans-unit id="89c2b631459be5cbc1277d90f51cb2dcbd76dfd6" translate="yes" xml:space="preserve">
          <source>Use (do not use) &amp;lsquo;</source>
          <target state="translated">사용 (사용하지 않음) '</target>
        </trans-unit>
        <trans-unit id="6c996ac92914ff016f27df663925672950a9f247" translate="yes" xml:space="preserve">
          <source>Use (do not use) GP-relative accesses for symbols that are known to be in a small data section; see</source>
          <target state="translated">작은 데이터 섹션에있는 것으로 알려진 심볼에 대해서는 GP 관련 액세스를 사용하십시오 (사용하지 마십시오). 보다</target>
        </trans-unit>
        <trans-unit id="841162f62263bc7378cda3013dbe47b1df4ab93e" translate="yes" xml:space="preserve">
          <source>Use (do not use) MIPS Digital Media Extension instructions. This option can only be used when generating 64-bit code and requires hardware floating-point support to be enabled.</source>
          <target state="translated">MIPS Digital Media Extension 지침을 사용하십시오 (사용하지 마십시오). 이 옵션은 64 비트 코드를 생성 할 때만 사용할 수 있으며 하드웨어 부동 소수점 지원을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b20024dc2d601c71b4e717f07d0f9b2a6822d063" translate="yes" xml:space="preserve">
          <source>Use (do not use) MT Multithreading instructions.</source>
          <target state="translated">MT 멀티 스레딩 명령어를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="4c4c87eb21af6765217c1c52b2b2d0c31fe5b0c7" translate="yes" xml:space="preserve">
          <source>Use (do not use) assembler relocation operators when dealing with symbolic addresses. The alternative, selected by</source>
          <target state="translated">기호 주소를 처리 할 때 어셈블러 재배치 연산자를 사용하십시오 (사용하지 마십시오). 에 의해 선택된 대안</target>
        </trans-unit>
        <trans-unit id="e2fb9fc1fd117af3b437fc4e8c7a5214e20addd7" translate="yes" xml:space="preserve">
          <source>Use (do not use) paired-single floating-point instructions. See &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS Paired-Single Support&lt;/a&gt;. This option requires hardware floating-point support to be enabled.</source>
          <target state="translated">쌍으로 된 부동 소수점 명령어를 사용 (사용하지 마십시오)하십시오. &lt;a href=&quot;mips-paired_002dsingle-support#MIPS-Paired_002dSingle-Support&quot;&gt;MIPS 단일 쌍 지원을&lt;/a&gt; 참조하십시오 . 이 옵션을 사용하려면 하드웨어 부동 소수점 지원이 활성화되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6259aa651c4c62a1528ed119090031f79dd3a9c" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 1 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macro &lt;code&gt;__mips_dsp&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 1.</source>
          <target state="translated">MIPS DSP ASE 개정 1을 사용하십시오 (사용하지 마십시오). &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP 내장 기능을&lt;/a&gt; 참조하십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__mips_dsp&lt;/code&gt; 를 정의합니다 . 또한 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; 를 1로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="84f11c6cd6e5cf30011af44cf15833421d85ad29" translate="yes" xml:space="preserve">
          <source>Use (do not use) revision 2 of the MIPS DSP ASE. See &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP Built-in Functions&lt;/a&gt;. This option defines the preprocessor macros &lt;code&gt;__mips_dsp&lt;/code&gt; and &lt;code&gt;__mips_dspr2&lt;/code&gt;. It also defines &lt;code&gt;__mips_dsp_rev&lt;/code&gt; to 2.</source>
          <target state="translated">MIPS DSP ASE 개정 2를 사용하십시오 (사용하지 마십시오). &lt;a href=&quot;mips-dsp-built_002din-functions#MIPS-DSP-Built_002din-Functions&quot;&gt;MIPS DSP 내장 기능을&lt;/a&gt; 참조하십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__mips_dsp&lt;/code&gt; 및 &lt;code&gt;__mips_dspr2&lt;/code&gt; 를 정의합니다 . 또한 &lt;code&gt;__mips_dsp_rev&lt;/code&gt; 를 2로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f05f23d689cc06c1b3087b4a4cee4ab4e3b531c1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">MIPS CRC (Cyclic Redundancy Check) 지침을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="41957dbedef9adbd80884a4e90cb75e57229baa1" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Enhanced Virtual Addressing instructions.</source>
          <target state="translated">MIPS Enhanced Virtual Addressing 지침을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="d449a2af21b4cd68389988954d474d0704ce78ae" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Global INValidate (GINV) instructions.</source>
          <target state="translated">MIPS Global INValidate (GINV) 지침을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="321d2808ff8ddfa8d27e08fae5ef2b18bb82a26d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions (EXT) instructions.</source>
          <target state="translated">MIPS Loongson EXTensions (EXT) 지침을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="7e1498ad7af62c3d7182f6f503ffa752981eda71" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson EXTensions r2 (EXT2) instructions.</source>
          <target state="translated">MIPS Loongson EXTensions r2 (EXT2) 명령을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="2dd360e823e7db9203619f4657c5c205b972d79d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Loongson MultiMedia extensions Instructions (MMI).</source>
          <target state="translated">MIPS Loongson 멀티미디어 확장 명령어 (MMI)를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="5f61baef9b142c63c1358980a670d3440a0eab96" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS MCU ASE instructions.</source>
          <target state="translated">MIPS MCU ASE 명령어를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="8ec8692f1855f7387d01c2d894055d7cd55aa28a" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS SmartMIPS ASE.</source>
          <target state="translated">MIPS SmartMIPS ASE를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="5ea0be9e9db2179c015e95d8d46f2c8b505a9fe4" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS Virtualization (VZ) instructions.</source>
          <target state="translated">MIPS 가상화 (VZ) 명령어를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="a2cdb6f5e1b2e85269c8ddd06af937bfeb499e18" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS eXtended Physical Address (XPA) instructions.</source>
          <target state="translated">MIPS eXtended Physical Address (XPA) 명령어를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="36354659118438f767b17fe9c67973e669f59454" translate="yes" xml:space="preserve">
          <source>Use (do not use) the MIPS-3D ASE. See &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D Built-in Functions&lt;/a&gt;. The option</source>
          <target state="translated">MIPS-3D ASE를 사용하십시오 (사용하지 마십시오). &lt;a href=&quot;mips_002d3d-built_002din-functions#MIPS_002d3D-Built_002din-Functions&quot;&gt;MIPS-3D 내장 함수를&lt;/a&gt; 참조하십시오 . 옵션</target>
        </trans-unit>
        <trans-unit id="9ef75b208cd56b64585639240694bc21bc152e3d" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When</source>
          <target state="translated">소수점 부동 소수점 연산에 하드웨어 소수점 부동 소수점 명령어를 사용하십시오 (사용하지 마십시오). 언제</target>
        </trans-unit>
        <trans-unit id="bf41f711c39d909ef84416fdb9864104894d7725" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When</source>
          <target state="translated">부동 소수점 연산에 하드웨어 부동 소수점 명령어 및 레지스터를 사용하십시오 (사용하지 마십시오). 언제</target>
        </trans-unit>
        <trans-unit id="de7cd0fb38e7a6dbf8bf51e3e0d617effe989eb9" translate="yes" xml:space="preserve">
          <source>Use (do not use) the hardware floating-point instructions for floating-point operations. When</source>
          <target state="translated">부동 소수점 연산에 하드웨어 부동 소수점 명령어를 사용하십시오 (사용하지 마십시오). 언제</target>
        </trans-unit>
        <trans-unit id="bd5d0dcb1bead4c9931bcc516462cf8c519e7f83" translate="yes" xml:space="preserve">
          <source>Use (do not use) the packed stack layout. When</source>
          <target state="translated">압축 스택 레이아웃을 사용하십시오 (사용하지 마십시오). 언제</target>
        </trans-unit>
        <trans-unit id="cbc7bc66fe33b21f66fff87d1b33e82b9091e241" translate="yes" xml:space="preserve">
          <source>Use (do not use) the probable-branch instructions, when static branch prediction indicates a probable branch.</source>
          <target state="translated">정적 분기 예측이 가능한 분기를 나타낼 때 가능한 분기 명령어를 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="f319b3952ec422e138086d2e7e1d3e6616dd87b3" translate="yes" xml:space="preserve">
          <source>Use 16-bit &lt;code&gt;int&lt;/code&gt;. This is the default.</source>
          <target state="translated">16 비트 &lt;code&gt;int&lt;/code&gt; 사용하십시오 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="89aa31a04c6ac47e58631515dc9a5eacae0d2be9" translate="yes" xml:space="preserve">
          <source>Use 32-bit &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">32 비트 &lt;code&gt;int&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a727b715072a7a83f64450d014d46413f9d7b5" translate="yes" xml:space="preserve">
          <source>Use 32-bit offsets in &lt;code&gt;switch&lt;/code&gt; tables. The default is to use 16-bit offsets.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 테이블 에서 32 비트 오프셋을 사용하십시오 . 기본값은 16 비트 오프셋을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="88f9f3c158d922b7a42c33cd301395b97a6091ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;brk_interrupt&lt;/code&gt; instead of &lt;code&gt;interrupt&lt;/code&gt; for handlers intended to be used with the &lt;code&gt;BRK&lt;/code&gt; opcode (i.e. those that must end with &lt;code&gt;RETB&lt;/code&gt; instead of &lt;code&gt;RETI&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;BRK&lt;/code&gt; opcode 와 함께 사용되는 핸들러 (즉 , &lt;code&gt;RETI&lt;/code&gt; 대신 &lt;code&gt;RETB&lt;/code&gt; 로 끝나야 하는 핸들러) 에는 &lt;code&gt;interrupt&lt;/code&gt; 대신 &lt;code&gt;brk_interrupt&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a90fcb500090afb38bb3e24622641ed3199bfbe3" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;class-name&lt;/var&gt; as the name of the class to instantiate for each literal string specified with the syntax &lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt;. The default class name is &lt;code&gt;NXConstantString&lt;/code&gt; if the GNU runtime is being used, and &lt;code&gt;NSConstantString&lt;/code&gt; if the NeXT runtime is being used (see below). The</source>
          <target state="translated">&lt;code&gt;@&quot;&amp;hellip;&quot;&lt;/code&gt; 구문으로 지정된 각 리터럴 문자열을 인스턴스화 하려면 &lt;var&gt;class-name&lt;/var&gt; 으로 class-name 을 사용하십시오 . GNU 런타임을 사용중인 경우 기본 클래스 이름은 &lt;code&gt;NXConstantString&lt;/code&gt; 이고 NeXT 런타임을 사용중인 경우 &lt;code&gt;NSConstantString&lt;/code&gt; 입니다 (아래 참조). 그만큼</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">대상별 C ++ 헤더를 포함하는 디렉토리의 서브 &lt;var&gt;dir&lt;/var&gt; 로 dir 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e0e3e325ab15f9c4ea6c1c5a12adf0dc5651ccc" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as the logical root directory for headers and libraries. For example, if the compiler normally searches for headers in</source>
          <target state="translated">헤더와 라이브러리의 논리적 루트 디렉토리로 &lt;var&gt;dir&lt;/var&gt; 을 사용하십시오 . 예를 들어, 컴파일러가 일반적으로</target>
        </trans-unit>
        <trans-unit id="6f28e148765dfa527c350e4d6f8a2d064b3f5447" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;script&lt;/var&gt; as the linker script. This option is supported by most systems using the GNU linker. On some targets, such as bare-board targets without an operating system, the</source>
          <target state="translated">&lt;var&gt;script&lt;/var&gt; 를 링커 스크립트 로 사용하십시오 . 이 옵션은 GNU 링커를 사용하는 대부분의 시스템에서 지원됩니다. 운영 체제가없는 베어 보드 대상과 같은 일부 대상에서</target>
        </trans-unit>
        <trans-unit id="603c63161e45119aff170517df5f944adaf08316" translate="yes" xml:space="preserve">
          <source>Use Bionic C library. This is the default on &amp;lsquo;</source>
          <target state="translated">Bionic C 라이브러리를 사용하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="e1b7e66656ee6fc5c3b9eff78bd1af4ab51c4a01" translate="yes" xml:space="preserve">
          <source>Use DEC assembler syntax.</source>
          <target state="translated">DEC 어셈블러 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cf5c1a8e637cc6c211fb5b791033642a96c7344a" translate="yes" xml:space="preserve">
          <source>Use GNU assembler syntax. This is the default.</source>
          <target state="translated">GNU 어셈블러 구문을 사용하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4ca68a7754f649f50b2ce419251af4261f6f0855" translate="yes" xml:space="preserve">
          <source>Use GP-relative &lt;code&gt;.sdata&lt;/code&gt;/&lt;code&gt;.sbss&lt;/code&gt; sections.</source>
          <target state="translated">GP 기준 &lt;code&gt;.sdata&lt;/code&gt; / &lt;code&gt;.sbss&lt;/code&gt; 섹션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a4f813886fea8ad38a8f2df1482e30df599c3e3" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&amp;gt;= 32 registers), but it can slow the compiler down.</source>
          <target state="translated">루프 불변량을 이동하기로 결정한 경우 IRA를 사용하여 루프의 레지스터 압력을 평가하십시오. 이 옵션은 일반적으로 큰 레지스터 파일 (&amp;gt; = 32 개의 레지스터)이있는 머신에서 더 빠르고 작은 코드를 생성하지만 컴파일러 속도를 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa83817840cfc83225757a8f388ff5927c560a5" translate="yes" xml:space="preserve">
          <source>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.</source>
          <target state="translated">호이스트 식에 대한 결정에 대한 코드 호이 스팅 패스의 레지스터 압력을 평가하려면 IRA를 사용하십시오. 이 옵션은 일반적으로 더 작은 코드를 생성하지만 컴파일러 속도를 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf05afd7829c886cb42acb12e1e8f5c401d38cca" translate="yes" xml:space="preserve">
          <source>Use PC-relative switch case tables to enable case table shortening. This is the default for</source>
          <target state="translated">PC 기준 스위치 케이스 테이블을 사용하여 케이스 테이블 단축을 사용하십시오. 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="00b72e087f73e29c719a0c570f2c43c4886f6d49" translate="yes" xml:space="preserve">
          <source>Use PUSH operations to store outgoing parameters. This method is shorter and usually equally fast as method using SUB/MOV operations and is enabled by default. In some cases disabling it may improve performance because of improved scheduling and reduced dependencies.</source>
          <target state="translated">PUSH 조작을 사용하여 발신 매개 변수를 저장하십시오. 이 방법은 SUB / MOV 작업을 사용하는 방법과 마찬가지로 더 짧고 일반적으로 동일하며 기본적으로 활성화되어 있습니다. 일부 경우 비활성화하면 스케줄링이 개선되고 종속성이 감소하여 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d45d39c4ac78022d817a61ee97d331c721c6435" translate="yes" xml:space="preserve">
          <source>Use SSE register passing conventions for float and double arguments and return values. You can control this behavior for a specific function by using the function attribute &lt;code&gt;sseregparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">float 및 double 인수 및 반환 값에 SSE 레지스터 전달 규칙을 사용하십시오. 함수 속성 &lt;code&gt;sseregparm&lt;/code&gt; 을 사용하여 특정 함수에 대해이 동작을 제어 할 수 있습니다 . &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b404c19baa5a518d1cdcd1a18e31cedc71ed3a2b" translate="yes" xml:space="preserve">
          <source>Use TLS descriptors as the thread-local storage mechanism for dynamic accesses of TLS variables. This is the default.</source>
          <target state="translated">TLS 디스크립터를 TLS 변수의 동적 액세스를위한 스레드 로컬 스토리지 메커니즘으로 사용하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e3576757916332969b16cf2fe6a0dad2cf57cc25" translate="yes" xml:space="preserve">
          <source>Use Unix assembler syntax.</source>
          <target state="translated">유닉스 어셈블러 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="203b2b8006e8188de9ec3c4dca584f80e20ca5d1" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">고정 된 수의 인수를 사용하는 함수는 &lt;code&gt;ret &lt;var&gt;num&lt;/var&gt;&lt;/code&gt; 명령어 와 함께 반환되는 함수 호출 규칙을 사용하여 반환하는 동안 인수를 표시합니다. 이렇게하면 인수를 표시 할 필요가 없으므로 호출자에 한 명령이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="da4193d8552139570f953ba462e87b5070659dde" translate="yes" xml:space="preserve">
          <source>Use a different function-calling convention, in which functions that take a fixed number of arguments return with the &lt;code&gt;rtd&lt;/code&gt; instruction, which pops their arguments while returning. This saves one instruction in the caller since there is no need to pop the arguments there.</source>
          <target state="translated">고정 된 수의 인수를 사용하는 함수가 &lt;code&gt;rtd&lt;/code&gt; 명령으로 리턴하는 함수 호출 규칙은 다른 함수 호출 규칙을 사용하여 리턴하는 동안 인수를 표시합니다. 이렇게하면 인수를 표시 할 필요가 없으므로 호출자에 한 명령이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="331cc29755f1e26195a1d5ecc670eb6f5d017ee2" translate="yes" xml:space="preserve">
          <source>Use a simple check for control speculation. This option is on by default.</source>
          <target state="translated">제어 추론에 대한 간단한 검사를 사용하십시오. 이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f85727b6057ae83760d6f97594f9ace81b0f7f" translate="yes" xml:space="preserve">
          <source>Use a simple data speculation check. This option is on by default.</source>
          <target state="translated">간단한 데이터 추론 검사를 사용하십시오. 이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6587349df9a9ae271539d7763d513420cd65bb" translate="yes" xml:space="preserve">
          <source>Use a suffix in a fixed-point literal constant:</source>
          <target state="translated">고정 소수점 리터럴 상수에 접미 부를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0eca7aa56a0b3e6cf63ecaa0b25877af246ac580" translate="yes" xml:space="preserve">
          <source>Use address register &lt;code&gt;X&lt;/code&gt; in a way proposed by the hardware. This means that &lt;code&gt;X&lt;/code&gt; is only used in indirect, post-increment or pre-decrement addressing.</source>
          <target state="translated">하드웨어가 제안한 방식으로 주소 레지스터 &lt;code&gt;X&lt;/code&gt; 를 사용하십시오 . 이는 &lt;code&gt;X&lt;/code&gt; 가 간접, 후행 증가 또는 사전 감소 주소 지정에서만 사용됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3b89385a22047536803090fc547fb07c50377d4f" translate="yes" xml:space="preserve">
          <source>Use all 64 floating-point registers.</source>
          <target state="translated">64 개의 부동 소수점 레지스터를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="feaeb911667dc1becc91e63f2c1dd1a8d7da1545" translate="yes" xml:space="preserve">
          <source>Use all 64 general-purpose registers.</source>
          <target state="translated">64 개의 범용 레지스터를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b82e484b31c31a6751f032044a77e4b8d923804b" translate="yes" xml:space="preserve">
          <source>Use all eight media accumulator registers.</source>
          <target state="translated">8 개의 미디어 누산기 레지스터를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f6df81f72a01bee304049bedcc53aa9e70e7e34" translate="yes" xml:space="preserve">
          <source>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for</source>
          <target state="translated">모든 기능을 단일 영역으로 사용하십시오. 일반적으로 코드 크기가 가장 작으며 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba424a2a390669d654a999945050b535cb620662" translate="yes" xml:space="preserve">
          <source>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.</source>
          <target state="translated">모든 루프를 레지스터 할당 영역으로 사용하십시오. 이는 레지스터 세트가 작거나 불규칙한 기계에 가장 적합한 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a043a5ff8ff9ce3ddafabde6a2ea3b417ae65cc6" translate="yes" xml:space="preserve">
          <source>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (</source>
          <target state="translated">레지스터 압력이 작은 루프를 제외한 모든 루프를 영역으로 사용하십시오. 이 값은 일반적으로 대부분의 경우 및 대부분의 아키텍처에서 최상의 결과를 제공하며 속도 최적화를 통해 컴파일 할 때 기본적으로 활성화됩니다 (</target>
        </trans-unit>
        <trans-unit id="812a6d3805650c2a1098b0f9c55012ae713394e0" translate="yes" xml:space="preserve">
          <source>Use caller save registers for allocation if those registers are not used by any called function. In that case it is not necessary to save and restore them around calls. This is only possible if called functions are part of same compilation unit as current function and they are compiled before it.</source>
          <target state="translated">호출 된 함수가 호출 레지스터를 사용하지 않는 경우 호출자 저장 레지스터를 사용하여 할당하십시오. 이 경우 통화 주변에 저장하고 복원 할 필요가 없습니다. 이것은 호출 된 함수가 현재 함수와 동일한 컴파일 단위의 일부이고 그 전에 컴파일 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4382016563c1274a421ee87c295b12ebd4559c24" translate="yes" xml:space="preserve">
          <source>Use color in diagnostics. &lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">진단에 색상을 사용하십시오. &lt;var&gt;WHEN&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="40d7328de5846368928e724db703acd82494276b" translate="yes" xml:space="preserve">
          <source>Use colors for lines of code that have zero coverage. We use red color for non-exceptional lines and cyan for exceptional. Same colors are used for basic blocks with</source>
          <target state="translated">적용 범위가 0 인 코드 줄에 색상을 사용하십시오. 우리는 예외가 아닌 라인에는 빨간색을, 시안에는 예외적으로 사용합니다. 기본 블록에 동일한 색상이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b78480b3c04e31f02a22c6b9fc0432c39f656a99" translate="yes" xml:space="preserve">
          <source>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.</source>
          <target state="translated">조건부 실행 (사용 가능한 경우)을 사용하여 조건부 점프를 분기없는 등가로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="cfd175a21aedd34017c2ac1e6f5bcb8597ba832d" translate="yes" xml:space="preserve">
          <source>Use features of, and schedule code for, the given CPU. Supported values are in the format &amp;lsquo;</source>
          <target state="translated">지정된 CPU의 기능 및 스케줄 코드를 사용하십시오. 지원되는 값은 '</target>
        </trans-unit>
        <trans-unit id="3784fc1428664a00120c0092c2a68e1d52938803" translate="yes" xml:space="preserve">
          <source>Use floating-point coprocessor instructions.</source>
          <target state="translated">부동 소수점 보조 프로세서 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b74dc5c253b5d41873111acddddd0a6e12b4df73" translate="yes" xml:space="preserve">
          <source>Use floating-point double instructions.</source>
          <target state="translated">부동 소수점 이중 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="92af032aeee5f8e42b7b1aaa0f92eee3c63e96e3" translate="yes" xml:space="preserve">
          <source>Use full-set registers for register allocation.</source>
          <target state="translated">레지스터 할당에 전체 세트 레지스터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16451ea3ea1710752acecdfbc9b28aca9f971795" translate="yes" xml:space="preserve">
          <source>Use hardware FPP floating point. This is the default. (FIS floating point on the PDP-11/40 is not supported.) Implies -m45.</source>
          <target state="translated">하드웨어 FPP 부동 소수점을 사용하십시오. 이것이 기본값입니다. PDP-11 / 40의 FIS 부동 소수점은 지원되지 않습니다. -m45를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1d53b0a05bad4ee0582a36e272217d96ad44c641" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point conversion instructions.</source>
          <target state="translated">하드웨어 부동 소수점 변환 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8d9f72c2a09e8bf637992aee381f0538cc91ce" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point instructions.</source>
          <target state="translated">하드웨어 부동 소수점 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a53c63d0196fe12e50c8354a0f08f23a9436376" translate="yes" xml:space="preserve">
          <source>Use hardware floating-point square root instruction.</source>
          <target state="translated">하드웨어 부동 소수점 제곱근 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9299be4448e9c807bf8ea8d91a628cfcd14cfa8d" translate="yes" xml:space="preserve">
          <source>Use hardware instructions for floating-point operations.</source>
          <target state="translated">부동 소수점 연산에는 하드웨어 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1208904e1c443035a1b8ffe0c523b26cf7b7a8b" translate="yes" xml:space="preserve">
          <source>Use indirect addressing to call functions outside the current compilation unit. This allows the functions to be placed anywhere within the 32-bit address space.</source>
          <target state="translated">간접 주소 지정을 사용하여 현재 컴파일 단위 외부에서 함수를 호출하십시오. 이를 통해 32 비트 주소 공간 내의 어느 곳에 나 기능을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fc9788b47e65039b1b1b871970de2bb141152a" translate="yes" xml:space="preserve">
          <source>Use large-model addressing (20-bit pointers, 32-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">큰 모델 주소 지정 (20 비트 포인터, 32 비트 &lt;code&gt;size_t&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="da84f773a2b422eeb1cc59880ada32d1f5127685" translate="yes" xml:space="preserve">
          <source>Use library routines for floating-point operations.</source>
          <target state="translated">부동 소수점 연산에 라이브러리 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="089ac39a7bb68a3ed32ee7b6986eee393acae4e9" translate="yes" xml:space="preserve">
          <source>Use media instructions.</source>
          <target state="translated">미디어 지침을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0eb15f40fe2c97b8f815cbb7844e284b610d0dac" translate="yes" xml:space="preserve">
          <source>Use multiply and add/subtract instructions.</source>
          <target state="translated">곱하기를 사용하고 지시를 더하거나 빼십시오.</target>
        </trans-unit>
        <trans-unit id="3113eba3d237f18c9452620ae8a871803037c9fe" translate="yes" xml:space="preserve">
          <source>Use multiply high instructions for high part of 32x32 multiply.</source>
          <target state="translated">32x32 곱하기의 많은 부분에 곱하기 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="274542aa04ed64b151c2d6a22c787feacea52bb1" translate="yes" xml:space="preserve">
          <source>Use of ISO C style function definitions. This warning intentionally is &lt;em&gt;not&lt;/em&gt; issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty&amp;rsquo;s traditional C compatibility macros, &lt;code&gt;PARAMS&lt;/code&gt; and &lt;code&gt;VPARAMS&lt;/code&gt;. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility.</source>
          <target state="translated">ISO C 스타일 함수 정의 사용 이 ISO C 기능은 libiberty의 기존 C 호환성 매크로, &lt;code&gt;PARAMS&lt;/code&gt; 및 &lt;code&gt;VPARAMS&lt;/code&gt; 를 사용할 때 코드에 나타나기 때문에 프로토 타입 선언 또는 가변 함수에 대해서는 의도적 으로이 경고가 발행 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이 기능은 이미 GCC 확장 기능이므로 기존 C 호환성과 관련이 없기 때문에 중첩 함수에 대해서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="158fc2002245113de73abd265a7ea7ceaec3a883" translate="yes" xml:space="preserve">
          <source>Use of these options requires the</source>
          <target state="translated">이 옵션을 사용하려면</target>
        </trans-unit>
        <trans-unit id="c4cc269c9473450b3919e9b442477125758842d4" translate="yes" xml:space="preserve">
          <source>Use only (or not only) &lt;code&gt;JSR&lt;/code&gt; instructions to access functions. This option can be used when code size exceeds the range of &lt;code&gt;BSR&lt;/code&gt; instructions. Note that</source>
          <target state="translated">기능에 액세스하려면 &lt;code&gt;JSR&lt;/code&gt; 명령어 만 사용하십시오 . 이 옵션은 코드 크기가 &lt;code&gt;BSR&lt;/code&gt; 명령어 범위를 초과 할 때 사용할 수 있습니다 . 참고</target>
        </trans-unit>
        <trans-unit id="3d7a23d4b8552ff506438fdaad793f73e9ba8b5c" translate="yes" xml:space="preserve">
          <source>Use only the first 32 floating-point registers.</source>
          <target state="translated">처음 32 개의 부동 소수점 레지스터 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="514349ebdaf390b152f0baa20866afbb16f28603" translate="yes" xml:space="preserve">
          <source>Use only the first four media accumulator registers.</source>
          <target state="translated">처음 네 개의 미디어 누산기 레지스터 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dbcdb22850ebf5d2eaa31bb7774cbe3b9ea3b9b1" translate="yes" xml:space="preserve">
          <source>Use options specific to GNU &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">GNU &lt;code&gt;ld&lt;/code&gt; 전용 옵션을 사용하십시오 . 이 패스</target>
        </trans-unit>
        <trans-unit id="d0990e1967b634e363212e972c2e0f4cff8a380b" translate="yes" xml:space="preserve">
          <source>Use options specific to HP &lt;code&gt;ld&lt;/code&gt;. This passes</source>
          <target state="translated">HP &lt;code&gt;ld&lt;/code&gt; 고유의 옵션을 사용하십시오 . 이 패스</target>
        </trans-unit>
        <trans-unit id="b612fc229c98c8b45507f89276f4127d6c212de2" translate="yes" xml:space="preserve">
          <source>Use or do not use assembler relocation operators when dealing with symbolic addresses. The alternative is to use assembler macros instead, which may limit optimization.</source>
          <target state="translated">기호 주소를 처리 할 때 어셈블러 재배치 연산자를 사용하거나 사용하지 마십시오. 대신 어셈블러 매크로를 사용하면 최적화가 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d238a2890f95ffe47564d56929f04ca231d7f2f" translate="yes" xml:space="preserve">
          <source>Use ordinarily cached memory accesses for volatile references. This is the default.</source>
          <target state="translated">휘발성 참조에는 일반적으로 캐시 된 메모리 액세스를 사용하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="561289d64c63454cbaa3cc42d60da8f4f3023750" translate="yes" xml:space="preserve">
          <source>Use pattern compare instructions.</source>
          <target state="translated">패턴 비교 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="040518cc797faf0101d0aa9c313c620444e4ee87" translate="yes" xml:space="preserve">
          <source>Use pipes rather than temporary files for communication between the various stages of compilation. This fails to work on some systems where the assembler is unable to read from a pipe; but the GNU assembler has no trouble.</source>
          <target state="translated">다양한 컴파일 단계 사이의 통신을 위해 임시 파일 대신 파이프를 사용하십시오. 이것은 어셈블러가 파이프에서 읽을 수없는 일부 시스템에서는 작동하지 않습니다. 그러나 GNU 어셈블러에는 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f48e58d8b4ccb76ce170698e169b17f602f7b800" translate="yes" xml:space="preserve">
          <source>Use reduced-set registers for register allocation.</source>
          <target state="translated">레지스터 할당에 축소 세트 레지스터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2593d8520ea117d76ab84232fac04161f6934239" translate="yes" xml:space="preserve">
          <source>Use reorder instructions (swap and byte reversed load/store).</source>
          <target state="translated">재정렬 명령어를 사용하십시오 (스왑 및 바이트 역로드 / 저장).</target>
        </trans-unit>
        <trans-unit id="e07ac16585fa1254cfa0cb9da67063979e26bb7c" translate="yes" xml:space="preserve">
          <source>Use scalar floating-point instructions present in the SSE instruction set. This instruction set is supported by Pentium III and newer chips, and in the AMD line by Athlon-4, Athlon XP and Athlon MP chips. The earlier version of the SSE instruction set supports only single-precision arithmetic, thus the double and extended-precision arithmetic are still done using 387. A later version, present only in Pentium 4 and AMD x86-64 chips, supports double-precision arithmetic too.</source>
          <target state="translated">SSE 명령어 세트에있는 스칼라 부동 소수점 명령어를 사용하십시오. 이 명령어 세트는 Pentium III 및 최신 칩과 AMD 라인에서 Athlon-4, Athlon XP 및 Athlon MP 칩에 의해 지원됩니다. SSE 명령어 세트의 이전 버전은 단 정밀도 산술 만 지원하므로 배정도 및 확장 정밀도 산술은 여전히 ​​387을 사용하여 수행됩니다. Pentium 4 및 AMD x86-64 칩에만있는 최신 버전은 배정도 산술을 지원합니다 너무.</target>
        </trans-unit>
        <trans-unit id="d6e4ef6e570b37c45555a81f6cdc377b4bae049b" translate="yes" xml:space="preserve">
          <source>Use small-model addressing (16-bit pointers, 16-bit &lt;code&gt;size_t&lt;/code&gt;).</source>
          <target state="translated">작은 모델 주소 지정 (16 비트 포인터, 16 비트 &lt;code&gt;size_t&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="427046297d0e2e2fa23aa9bbce2f51b1069e5680" translate="yes" xml:space="preserve">
          <source>Use software emulation for divides (default).</source>
          <target state="translated">나누기에 소프트웨어 에뮬레이션을 사용하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="28d4c98240044920040873705d9156aeeb423961" translate="yes" xml:space="preserve">
          <source>Use software emulation for floating point (default).</source>
          <target state="translated">부동 소수점에 소프트웨어 에뮬레이션을 사용하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="1da6f7e54a7af9cc7e53be95e1caa19cec640f21" translate="yes" xml:space="preserve">
          <source>Use software multiply emulation (default).</source>
          <target state="translated">소프트웨어 곱셈 에뮬레이션을 사용하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="51ebd4110af8f919b9d1120fda4a348de24109ee" translate="yes" xml:space="preserve">
          <source>Use specified regions for the integrated register allocator. The &lt;var&gt;region&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">통합 레지스터 할당 자에 지정된 영역을 사용하십시오. &lt;var&gt;region&lt;/var&gt; 인수는 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="8bf48e2b51779d631071d9653fad6d3f53bf023b" translate="yes" xml:space="preserve">
          <source>Use table lookup optimization for small signed integer divisions.</source>
          <target state="translated">작은 부호있는 정수 나누기에 대해 테이블 ​​조회 최적화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="22aeb5074275903d6cc2bc285a95ec6de6392b7d" translate="yes" xml:space="preserve">
          <source>Use the &amp;lsquo;</source>
          <target state="translated">사용 '</target>
        </trans-unit>
        <trans-unit id="4c08ac9947cb5cb5ba71955417b6bbe576595e7e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bfd&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">기본 링커 대신 &lt;code&gt;bfd&lt;/code&gt; 링커를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="49f654b96f5c6203d75686fb510717eb4b09cb8c" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dcpl&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache.</source>
          <target state="translated">&lt;code&gt;dcpl&lt;/code&gt; 명령어를 사용하여 주소 &lt;var&gt;x&lt;/var&gt; 의 내용을 데이터 캐시 에로드합니다 .</target>
        </trans-unit>
        <trans-unit id="bf6f4ab92454be3b8a7530a2bda919c27587ed37" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;gold&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">기본 링커 대신 &lt;code&gt;gold&lt;/code&gt; 링커를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ce5962b43b6bd52ef348d693006572a8183c27a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;nldub&lt;/code&gt; instruction to load the contents of address &lt;var&gt;x&lt;/var&gt; into the data cache. The instruction is issued in slot I1.</source>
          <target state="translated">&lt;code&gt;nldub&lt;/code&gt; 명령어를 사용하여 주소 &lt;var&gt;x&lt;/var&gt; 의 내용을 데이터 캐시 에로드하십시오 . 명령어는 슬롯 I1에서 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="867d5a75d613034d3b5e7a22efb5a5d5d0038d5f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;section&lt;/code&gt; attribute with &lt;em&gt;global&lt;/em&gt; variables and not &lt;em&gt;local&lt;/em&gt; variables, as shown in the example.</source>
          <target state="translated">사용 &lt;code&gt;section&lt;/code&gt; 와 속성 &lt;em&gt;전역&lt;/em&gt; 변수가 아닌 &lt;em&gt;로컬&lt;/em&gt; 로 예와 같이 변수.</target>
        </trans-unit>
        <trans-unit id="9a7c0df6001ba89f4adccf5164b3cb2c7ebaeebd" translate="yes" xml:space="preserve">
          <source>Use the GNU C library. This is the default except on &amp;lsquo;</source>
          <target state="translated">GNU C 라이브러리를 사용하십시오. '을 제외한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="750d7f5d1705c279b333b6c74a4ba7e65ef492b9" translate="yes" xml:space="preserve">
          <source>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.</source>
          <target state="translated">Graphite 데이터 의존성 분석을 사용하여 병렬화 할 수있는 루프를 식별하십시오. 루프를 병렬화하는 것이 수익성이 있는지 확인하지 않고 루프 수행 종속성을 포함하지 않도록 분석 할 수있는 모든 루프를 병렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="7a211de8053eb75fc4551a2253a98b04c844e3fd" translate="yes" xml:space="preserve">
          <source>Use the LLVM &lt;code&gt;lld&lt;/code&gt; linker instead of the default linker.</source>
          <target state="translated">기본 링커 대신 LLVM &lt;code&gt;lld&lt;/code&gt; 링커를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b872414955ba2ec914569c9ca7e852388533f1" translate="yes" xml:space="preserve">
          <source>Use the divide instruction. (Enabled by default).</source>
          <target state="translated">나누기 명령어를 사용하십시오. (기본적으로 활성화되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="558e68bc0e42df73038edd83e1eeba8d09d26633" translate="yes" xml:space="preserve">
          <source>Use the hardware barrel shifter.</source>
          <target state="translated">하드웨어 배럴 시프터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ddc7c28193ef0a55228689dee7a52062a4edc76" translate="yes" xml:space="preserve">
          <source>Use the musl C library. This is the default on &amp;lsquo;</source>
          <target state="translated">musl C 라이브러리를 사용하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="1f0e93cc02e9fe65de10db69a6186e0dc79df964" translate="yes" xml:space="preserve">
          <source>Use the new LRA register allocator. By default, the old &amp;ldquo;reload&amp;rdquo; allocator is used.</source>
          <target state="translated">새로운 LRA 레지스터 할당자를 사용하십시오. 기본적으로 이전 &quot;다시로드&quot;할당자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8160c2417cc8a5cdcd5adcb2b4ace153689638e" translate="yes" xml:space="preserve">
          <source>Use the pc-relative addressing mode of the 68000 directly, instead of using a global offset table. At present, this option implies</source>
          <target state="translated">글로벌 오프셋 테이블을 사용하는 대신 68000의 pc 기준 주소 지정 모드를 직접 사용하십시오. 현재이 옵션은</target>
        </trans-unit>
        <trans-unit id="f07a2b31cfd22ad424266d7caad833e89dee9597" translate="yes" xml:space="preserve">
          <source>Use the portable calling conventions proposed by HP for ELF systems.</source>
          <target state="translated">ELF 시스템에 대해 HP에서 제안한 휴대용 호출 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4db49c13b2cd9f44e64e88aadae4892b55bc28" translate="yes" xml:space="preserve">
          <source>Use the simulator runtime. The default is to use the libgloss board-specific runtime.</source>
          <target state="translated">시뮬레이터 런타임을 사용하십시오. 디폴트는 libgloss 보드 특정 런타임을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="41338fd388f1668b19ad991f249f38977077076b" translate="yes" xml:space="preserve">
          <source>Use the small address space model. This can produce smaller code, but it does assume that all symbolic values and addresses fit into a 20-bit range.</source>
          <target state="translated">작은 주소 공간 모델을 사용하십시오. 이는 더 작은 코드를 생성 할 수 있지만 모든 기호 값과 주소가 20 비트 범위에 맞는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="13568366d19d7f746b8b97efedd41fb9de7088bc" translate="yes" xml:space="preserve">
          <source>Use the specified algorithm for basic block reordering. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">기본 블록 재정렬에 지정된 알고리즘을 사용하십시오. &lt;var&gt;algorithm&lt;/var&gt; 인수는 '할 수있다</target>
        </trans-unit>
        <trans-unit id="ab53cd8c99a5cd67bf095646da8562b04af28820" translate="yes" xml:space="preserve">
          <source>Use the specified coloring algorithm for the integrated register allocator. The &lt;var&gt;algorithm&lt;/var&gt; argument can be &amp;lsquo;</source>
          <target state="translated">통합 레지스터 할당 자에 지정된 색상 지정 알고리즘을 사용하십시오. &lt;var&gt;algorithm&lt;/var&gt; 인수는 '할 수있다</target>
        </trans-unit>
        <trans-unit id="c25bc5036e9135cfbfa139415172d379794c44f1" translate="yes" xml:space="preserve">
          <source>Use the standard 387 floating-point coprocessor present on the majority of chips and emulated otherwise. Code compiled with this option runs almost everywhere. The temporary results are computed in 80-bit precision instead of the precision specified by the type, resulting in slightly different results compared to most of other chips. See</source>
          <target state="translated">대부분의 칩에 존재하고 그렇지 않으면 에뮬레이션 된 표준 387 부동 소수점 코 프로세서를 사용하십시오. 이 옵션으로 컴파일 된 코드는 거의 모든 곳에서 실행됩니다. 임시 결과는 유형에 의해 지정된 정밀도 대신 80 비트 정밀도로 계산되므로 다른 대부분의 칩에 비해 결과가 약간 다릅니다. 보다</target>
        </trans-unit>
        <trans-unit id="5c3eebf40b38ef456cf7b33dffd08d0bed4ad5c6" translate="yes" xml:space="preserve">
          <source>Use the string argument if you want a single implementation file to include code from multiple header files. (You must also use &amp;lsquo;</source>
          <target state="translated">단일 구현 파일에 여러 헤더 파일의 코드를 포함 시키려면 문자열 인수를 사용하십시오. ( '</target>
        </trans-unit>
        <trans-unit id="8b250eb8bd58bde677af68374494bb2406d4bfb9" translate="yes" xml:space="preserve">
          <source>Use the timing characteristics of the indicated CPU type when scheduling instructions. This does not change the targeted processor type. The CPU type must be one of &amp;lsquo;</source>
          <target state="translated">명령을 예약 할 때 표시된 CPU 유형의 타이밍 특성을 사용하십시오. 대상 프로세서 유형은 변경되지 않습니다. CPU 유형은 '</target>
        </trans-unit>
        <trans-unit id="e509cf065cb591da77c6d1b119a1c9955ae2884c" translate="yes" xml:space="preserve">
          <source>Use these attributes on the Blackfin to place the variable into L1 Data SRAM. Variables with &lt;code&gt;l1_data&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data&lt;/code&gt;. Those with &lt;code&gt;l1_data_A&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.A&lt;/code&gt;. Those with &lt;code&gt;l1_data_B&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l1.data.B&lt;/code&gt;.</source>
          <target state="translated">Blackfin에서이 속성을 사용하여 변수를 L1 Data SRAM에 배치하십시오. 와 변수 &lt;code&gt;l1_data&lt;/code&gt; 속성라는 특정 섹션에 넣고 &lt;code&gt;.l1.data&lt;/code&gt; . 와 그 &lt;code&gt;l1_data_A&lt;/code&gt; 의 속성의 이름은 특정 섹션에 넣고 &lt;code&gt;.l1.data.A&lt;/code&gt; . 와 그 &lt;code&gt;l1_data_B&lt;/code&gt; 의 속성의 이름은 특정 섹션에 넣고 &lt;code&gt;.l1.data.B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="160cca57d4e5e0f9858135c86f73f6c1abb97d0c" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either attribute is present.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는 두 속성 중 하나가 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bf93b175e1b39a6bc44235ab705a17a9dd4f6b45" translate="yes" xml:space="preserve">
          <source>Use these attributes to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when either of these attributes are present.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는 이러한 속성 중 하나가 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="713ae23784c01f8e2dec060c72284704315954a7" translate="yes" xml:space="preserve">
          <source>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format have linkers with such optimizations. On AIX, the linker rearranges sections (CSECTs) based on the call graph. The performance impact varies.</source>
          <target state="translated">링커가 명령 공간에서 참조의 지역성을 향상시키기 위해 최적화를 수행 할 수있는 시스템에서이 옵션을 사용하십시오. ELF 객체 형식을 사용하는 대부분의 시스템에는 이러한 최적화 기능이있는 링커가 있습니다. AIX에서 링커는 호출 그래프를 기반으로 섹션 (CSECT)을 재 배열합니다. 성능 영향은 다양합니다.</target>
        </trans-unit>
        <trans-unit id="78e3ee99ed9959a22e988df0584ccd7d00c7b9a6" translate="yes" xml:space="preserve">
          <source>Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the &lt;code&gt;interrupt&lt;/code&gt; attribute above.</source>
          <target state="translated">인터럽트 서비스 루틴을 작성하려면 ARM에서이 속성을 사용하십시오. 위 의 &lt;code&gt;interrupt&lt;/code&gt; 속성에 대한 별명 입니다.</target>
        </trans-unit>
        <trans-unit id="6c570cb3577b10adeb554e34c1e75804adbd4ff0" translate="yes" xml:space="preserve">
          <source>Use this attribute on SH targets to indicate that an &lt;code&gt;interrupt_handler&lt;/code&gt; function should not save and restore registers R0..R7. This can be used on SH3* and SH4* targets that have a second R0..R7 register bank for non-reentrant interrupt handlers.</source>
          <target state="translated">SH 대상에서이 속성을 사용하여 &lt;code&gt;interrupt_handler&lt;/code&gt; _ 핸들러 함수가 레지스터 R0..R7을 저장 및 복원하지 않아야 함을 나타냅니다 . 재진입 할 ​​수없는 인터럽트 처리기를위한 두 번째 R0..R7 레지스터 뱅크가있는 SH3 * 및 SH4 * 대상에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c77347991d0824e6e1b28414143e53ed7d053c" translate="yes" xml:space="preserve">
          <source>Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a &lt;code&gt;sleep&lt;/code&gt; instruction. This attribute is available only on fido.</source>
          <target state="translated">m68k의 서브 아키텍처 인 fido에서이 속성을 사용하여 지정된 함수가 스레드로 실행되도록 설계된 인터럽트 핸들러임을 나타냅니다. 컴파일러는 프롤로그 / 에필로그 시퀀스를 생성하지 않고 리턴 명령을 &lt;code&gt;sleep&lt;/code&gt; 명령으로 대체합니다 . 이 속성은 fido에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d1f324113425943e40b53dec4caee6bc8c992d2f" translate="yes" xml:space="preserve">
          <source>Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">지정된 기능이 인터럽트 핸들러임을 나타내려면 AVR에서이 속성을 사용하십시오. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a5bf0a65e4d4990ce1711a80366a15b5a93d0b22" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler generates function entry and exit sequences suitable for use in an NMI handler when this attribute is present.</source>
          <target state="translated">지정된 기능이 NMI 핸들러임을 나타내려면 Blackfin에서이 속성을 사용하십시오. 컴파일러는이 속성이 존재할 때 NMI 핸들러에서 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dfb0dab0829881fae4719db2bc2a5d4b0371e0d9" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler generates function entry and exit sequences suitable for use in an exception handler when this attribute is present.</source>
          <target state="translated">Blackfin에서이 속성을 사용하여 지정된 함수가 예외 핸들러임을 나타냅니다. 컴파일러는이 속성이 존재할 때 예외 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8869ad65102c3d5175ee58c9a5d4d12dd9377ae3" translate="yes" xml:space="preserve">
          <source>Use this attribute on the Blackfin to place the variable into L2 SRAM. Variables with &lt;code&gt;l2&lt;/code&gt; attribute are put into the specific section named &lt;code&gt;.l2.data&lt;/code&gt;.</source>
          <target state="translated">Blackfin에서이 속성을 사용하여 변수를 L2 SRAM에 배치하십시오. &lt;code&gt;l2&lt;/code&gt; 속성을 가진 변수는 &lt;code&gt;.l2.data&lt;/code&gt; 라는 특정 섹션에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="77ba6ef03647597caec122d43f2ce8b19030a7ba" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">H8 / 300, H8 / 300H 및 H8S에서이 속성을 사용하여 스택 포인터를 제외한 모든 레지스터를 사용 여부에 관계없이 프롤로그에 저장해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df02a088eeed2ddabe9512b735b51f56751782bf" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">H8 / 300, H8 / 300H 및 H8S에서이 속성을 사용하여 지정된 함수가 인터럽트 핸들러임을 나타냅니다. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fd7a5bf8f68787afcff36ce2f74606dfa6e83fb2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector reduces code size; however, the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.</source>
          <target state="translated">H8 / 300, H8 / 300H 및 H8S에서이 속성을 사용하여 지정된 함수가 함수 벡터를 통해 호출되어야 함을 나타냅니다. 함수 벡터를 통해 함수를 호출하면 코드 크기가 줄어 듭니다. 그러나 함수 벡터는 크기가 제한적이며 (H8 / 300의 최대 128 개 항목과 H8 / 300H 및 H8S의 64 개 항목) 인터럽트 벡터와 공간을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="599c44ccc726a6980df5cc0406dd5d4d98bf81c0" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight-bit data section. The compiler generates more efficient code for certain operations on data in the eight-bit data area. Note the eight-bit data area is limited to 256 bytes of data.</source>
          <target state="translated">H8 / 300, H8 / 300H 및 H8S에서이 속성을 사용하여 지정된 변수가 8 비트 데이터 섹션에 배치되어야 함을 나타냅니다. 컴파일러는 8 비트 데이터 영역의 데이터에 대한 특정 작업에 대해보다 효율적인 코드를 생성합니다. 8 비트 데이터 영역은 256 바이트의 데이터로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a601987d8058a933f8472ba9226cb9a2f96a02f6" translate="yes" xml:space="preserve">
          <source>Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler generates more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32KB of data.</source>
          <target state="translated">H8 / 300H 및 H8S에서이 속성을 사용하여 지정된 변수가 작은 데이터 섹션에 배치되어야 함을 나타냅니다. 컴파일러는 작은 데이터 섹션에서 데이터를로드하고 저장하기위한보다 효율적인 코드를 생성합니다. 작은 데이터 영역은 32KB 미만의 데이터로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="85d60dec57fe15c501fdf7e341a3a258fde629e1" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32C port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">지정된 기능이 빠른 인터럽트 핸들러임을 나타내려면 M32C 포트에서이 속성을 사용하십시오. 이 단지처럼 &lt;code&gt;interrupt&lt;/code&gt; 것을 제외하고, 속성 &lt;code&gt;freit&lt;/code&gt; 이 대신 반환하는 데 사용됩니다 &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297c80fc49a65c78b7920bfb2bee0762b9925dea" translate="yes" xml:space="preserve">
          <source>Use this attribute on the M32R/D to set the addressability of an object. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">M32R / D에서이 속성을 사용하여 객체의 주소 지정 가능성을 설정하십시오. 식별자 &lt;var&gt;model-name&lt;/var&gt; 은 각 코드 모델을 나타내는 &lt;code&gt;small&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 또는 &lt;code&gt;large&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="96da4205ef51f9f643ebc02b337015bd75a20bc4" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is a reset handler. The compiler will generate corresponding sections for use in a reset handler. You can use the following attributes to provide extra exception handling:</source>
          <target state="translated">지정된 기능이 재설정 핸들러임을 나타내려면 NDS32 대상에서이 속성을 사용하십시오. 컴파일러는 재설정 핸들러에서 사용할 해당 섹션을 생성합니다. 다음 속성을 사용하여 추가 예외 처리를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baa8e68af06ff2588951a9683b9bf9ad21db1c70" translate="yes" xml:space="preserve">
          <source>Use this attribute on the NDS32 target to indicate that the specified function is an exception handler. The compiler will generate corresponding sections for use in an exception handler.</source>
          <target state="translated">지정된 함수가 예외 핸들러임을 나타내려면 NDS32 대상에서이 속성을 사용하십시오. 컴파일러는 예외 처리기에서 사용할 해당 섹션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="420b4fa6a036410c655f106a939e0146c5f824c7" translate="yes" xml:space="preserve">
          <source>Use this attribute on the RX port to indicate that the specified function is a fast interrupt handler. This is just like the &lt;code&gt;interrupt&lt;/code&gt; attribute, except that &lt;code&gt;freit&lt;/code&gt; is used to return instead of &lt;code&gt;reit&lt;/code&gt;.</source>
          <target state="translated">지정된 기능이 빠른 인터럽트 핸들러임을 나타내려면 RX 포트에서이 속성을 사용하십시오. 이 단지처럼 &lt;code&gt;interrupt&lt;/code&gt; 것을 제외하고, 속성 &lt;code&gt;freit&lt;/code&gt; 이 대신 반환하는 데 사용됩니다 &lt;code&gt;reit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8551dfbdf943cb7774be60c5de8ba39aba7167f2" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH for an &lt;code&gt;interrupt_handler&lt;/code&gt; to return using &lt;code&gt;trapa&lt;/code&gt; instead of &lt;code&gt;rte&lt;/code&gt;. This attribute expects an integer argument specifying the trap number to be used.</source>
          <target state="translated">&lt;code&gt;interrupt_handler&lt;/code&gt; _ 핸들러 가 &lt;code&gt;rte&lt;/code&gt; 대신 &lt;code&gt;trapa&lt;/code&gt; 를 사용하여 리턴 하려면 SH에서이 속성을 사용하십시오 . 이 속성은 트랩 번호를 지정하는 정수 인수가 사용될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="96f131ead8b3e83868bdd55e3669cea512c61c77" translate="yes" xml:space="preserve">
          <source>Use this attribute on the SH to indicate an &lt;code&gt;interrupt_handler&lt;/code&gt; function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack.</source>
          <target state="translated">SH에서이 속성을 사용하여 &lt;code&gt;interrupt_handler&lt;/code&gt; 함수가 대체 스택으로 전환해야 함을 나타냅니다 . 대체 스택의 주소를 보유하는 전역 변수의 이름을 지정하는 문자열 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7835a2a9ca1e1170ad95a6f19a530b6da32924fa" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the first 32 kilobytes of memory.</source>
          <target state="translated">처음 32KB 메모리에 변수를 명시 적으로 배치하려면이 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6f81bc7b08ff6f3b4d15b67ecb7306d1b4cac77a" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the small data area, which can hold up to 64 kilobytes.</source>
          <target state="translated">작은 데이터 영역에 변수를 명시 적으로 배치하려면이 속성을 사용하십시오. 최대 64KB를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a478a508b894220fe0716716b37246794c924f" translate="yes" xml:space="preserve">
          <source>Use this attribute to explicitly place a variable in the tiny data area, which can hold up to 256 bytes in total.</source>
          <target state="translated">작은 데이터 영역에 변수를 명시 적으로 배치하려면이 속성을 사용하십시오. 총 256 바이트까지 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="236f15e780f5078ecf100afe1366fac4aadd1410" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not.</source>
          <target state="translated">스택 포인터를 제외한 모든 레지스터가 사용 여부에 관계없이 프롤로그에 저장되어야 함을 표시하려면이 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="764c3380316fc59c0e08f071dd7a44fb3d9e29ae" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) are saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt.</source>
          <target state="translated">이 속성을 사용하여 함수가 인터럽트 핸들러임을 나타냅니다. 모든 휘발성 레지스터 (비 휘발성 레지스터 외에)는 프롤로그 기능에 저장됩니다. 함수가 리프 함수 인 경우 함수에서 사용하는 휘발성 물질 만 저장됩니다. 인터럽트에서 리턴하는 대신 정상적인 함수 리턴이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e7371ecf2ac4e4a5beb340500a4170b79e5aeb2e" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function has no caller-saved registers. That is, all registers are callee-saved. For example, this attribute can be used for a function called from an interrupt handler. The compiler generates proper function entry and exit sequences to save and restore any modified registers, except for the EFLAGS register. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">지정된 함수에 호출자 저장 레지스터가 없음을 표시하려면이 속성을 사용하십시오. 즉, 모든 레지스터가 수신자 저장됩니다. 예를 들어,이 속성은 인터럽트 핸들러에서 호출 된 함수에 사용할 수 있습니다. 컴파일러는 EFLAGS 레지스터를 제외하고 수정 된 레지스터를 저장하고 복원하기 위해 적절한 함수 입력 및 종료 시퀀스를 생성합니다. GCC는 SSE, MMX 또는 x87 상태를 유지하지 않으므로 GCC 옵션</target>
        </trans-unit>
        <trans-unit id="7d075359795fbb683e03390ae2ab96a3eb2f08a2" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is a break handler. The compiler generates function entry and exit sequences suitable for use in an break handler when this attribute is present. The return from &lt;code&gt;break_handler&lt;/code&gt; is done through the &lt;code&gt;rtbd&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">지정된 함수가 중단 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는이 속성이있을 때 중단 핸들러에 사용하기에 적합한 함수 시작 및 종료 시퀀스를 생성합니다. 의 반환 &lt;code&gt;break_handler&lt;/code&gt; 는 관통 수행 &lt;code&gt;rtbd&lt;/code&gt; 대신 &lt;code&gt;rtsd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2edc9f687349668f0ff9d21a9fd536ad89ad9e2f" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler or an exception handler (depending on parameters passed to the function, explained further). The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. The &lt;code&gt;IRET&lt;/code&gt; instruction, instead of the &lt;code&gt;RET&lt;/code&gt; instruction, is used to return from interrupt handlers. All registers, except for the EFLAGS register which is restored by the &lt;code&gt;IRET&lt;/code&gt; instruction, are preserved by the compiler. Since GCC doesn&amp;rsquo;t preserve SSE, MMX nor x87 states, the GCC option</source>
          <target state="translated">이 속성을 사용하여 지정된 함수가 인터럽트 핸들러 또는 예외 핸들러임을 나타냅니다 (함수에 전달 된 매개 변수에 따라 다름). 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다. &lt;code&gt;IRET&lt;/code&gt; 의 명령이 대신의 &lt;code&gt;RET&lt;/code&gt; 의 명령, 인터럽트 핸들러에서 복귀하는 데 사용된다. &lt;code&gt;IRET&lt;/code&gt; 명령어로 복원 된 EFLAGS 레지스터를 제외한 모든 레지스터 는 컴파일러에 의해 유지됩니다. GCC는 SSE, MMX 또는 x87 상태를 유지하지 않으므로 GCC 옵션</target>
        </trans-unit>
        <trans-unit id="0c30254e85a0958ba0ac7ce6feb29ae31661d530" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d47a65245a7242658fd94eba35172dfdbe8eccc4" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. An optional argument is supported for the interrupt attribute which allows the interrupt mode to be described. By default GCC assumes the external interrupt controller (EIC) mode is in use, this can be explicitly set using &lt;code&gt;eic&lt;/code&gt;. When interrupts are non-masked then the requested Interrupt Priority Level (IPL) is copied to the current IPL which has the effect of only enabling higher priority interrupts. To use vectored interrupt mode use the argument &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt;, this will change the behavior of the non-masked interrupt support and GCC will arrange to mask all interrupts from sw0 up to and including the specified interrupt vector.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다. 인터럽트 모드를 설명 할 수있는 인터럽트 속성에 대해 선택적 인수가 지원됩니다. 기본적으로 GCC는 외부 인터럽트 컨트롤러 (EIC) 모드가 사용 &lt;code&gt;eic&lt;/code&gt; 사용하여 명시 적으로 설정할 수 있습니다 . 인터럽트가 마스킹되지 않은 경우 요청 된 IPL (Interrupt Priority Level)이 현재 IPL로 복사되어 우선 순위가 높은 인터럽트 만 활성화하는 효과가 있습니다. 벡터 인터럽트 모드를 사용하려면 인수 &lt;code&gt;vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]&lt;/code&gt; 마스킹되지 않은 인터럽트 지원의 동작이 변경되고 GCC는 sw0에서 지정된 인터럽트 벡터까지 모든 인터럽트를 마스킹하도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="0ace02ca61dedf94a751682f5d4174fdf42f160d" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. Either name may be used.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다. 어떤 이름이든 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb60152fa1da7627a1b21880311cc9395167dfd1" translate="yes" xml:space="preserve">
          <source>Use this attribute to indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. It may also generate a special section with code to initialize the interrupt vector table.</source>
          <target state="translated">지정된 속성이 인터럽트 핸들러임을 나타내려면이 속성을 사용하십시오. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다. 또한 인터럽트 벡터 테이블을 초기화하는 코드가있는 특수 섹션을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea92b79a9f3c03589b9a2bec6c52bb535643eb63" translate="yes" xml:space="preserve">
          <source>Use this attribute to place a variable in the &lt;code&gt;.shared&lt;/code&gt; memory space. This memory space is private to each cooperative thread array; only threads within one thread block refer to the same instance of the variable. The runtime does not initialize variables in this memory space.</source>
          <target state="translated">&lt;code&gt;.shared&lt;/code&gt; 메모리 공간에 변수를 배치하려면이 속성을 사용하십시오 . 이 메모리 공간은 각 협력 스레드 배열에 대해 개인용입니다. 하나의 스레드 블록 내의 스레드 만 변수의 동일한 인스턴스를 참조합니다. 런타임은이 메모리 공간에서 변수를 초기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1ecdb3757207ea0940932cf33695720d7e7f73c" translate="yes" xml:space="preserve">
          <source>Use this attribute together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt; to indicate that the function entry code should enable nested interrupts or exceptions.</source>
          <target state="translated">함수 입력 코드가 중첩 된 인터럽트 또는 예외를 사용해야 함을 나타내 &lt;code&gt;nmi_handler&lt;/code&gt; 이 속성을 &lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; 또는 nmi_handler 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="01448e4d9272cc29bf3907d177e8611ce1e38ee0" translate="yes" xml:space="preserve">
          <source>Use this directive in &lt;em&gt;header files&lt;/em&gt; that define object classes, to save space in most of the object files that use those classes. Normally, local copies of certain information (backup copies of inline member functions, debugging information, and the internal tables that implement virtual functions) must be kept in each object file that includes class definitions. You can use this pragma to avoid such duplication. When a header file containing &amp;lsquo;</source>
          <target state="translated">오브젝트 클래스를 정의하는 &lt;em&gt;헤더 파일&lt;/em&gt; 에이 지정 문 을 사용하여 해당 클래스를 사용하는 대부분의 오브젝트 파일에서 공간을 절약하십시오. 일반적으로 특정 정보의 로컬 사본 (인라인 멤버 함수의 백업 사본, 디버깅 정보 및 가상 함수를 구현하는 내부 테이블)은 클래스 정의를 포함하는 각 오브젝트 파일에 보관해야합니다. 이 pragma를 사용하여 이러한 중복을 피할 수 있습니다. '를 포함하는 헤더 파일</target>
        </trans-unit>
        <trans-unit id="d280eeca70b31bee4ab8a083eaebf1bfa7fbe798" translate="yes" xml:space="preserve">
          <source>Use this option for microcontroller with a 5200 core, including the MCF5202, MCF5203, MCF5204 and MCF5206.</source>
          <target state="translated">MCF5202, MCF5203, MCF5204 및 MCF5206을 포함하여 5200 코어가있는 마이크로 컨트롤러에이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a112527843e5614605b4e3f46e7e6138969c47d8" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a 68000 or EC000 core, including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.</source>
          <target state="translated">68008, 68302, 68306, 68307, 68322, 68328 및 68356을 포함하여 68000 또는 EC000 코어가있는 마이크로 컨트롤러에이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63187c5307bd577a4586510b3b1f06b54dea5f9f" translate="yes" xml:space="preserve">
          <source>Use this option for microcontrollers with a CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 and 68360.</source>
          <target state="translated">68330, 68331, 68332, 68333, 68334, 68336, 68340, 68341, 68349 및 68360을 포함하여 CPU32 또는 CPU32 + 코어가있는 마이크로 컨트롤러에이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41f23198542e0d6a3a5d2900310d1b7abe9d3260" translate="yes" xml:space="preserve">
          <source>Use this option to require GCC to construct &lt;em&gt;all&lt;/em&gt; integer constants using code, even if it takes more instructions (the maximum is six).</source>
          <target state="translated">더 많은 명령어가 필요한 경우에도 코드를 사용하여 &lt;em&gt;모든&lt;/em&gt; 정수 상수 를 생성하도록 GCC에 요청하려면이 옵션을 사용하십시오 (최대 값은 6 임).</target>
        </trans-unit>
        <trans-unit id="6aa829df1806f0740110776091d0764dbe5ca6cc" translate="yes" xml:space="preserve">
          <source>Use this pragma in a &lt;em&gt;main input file&lt;/em&gt;, when you want full output from included header files to be generated (and made globally visible). The included header file, in turn, should use &amp;lsquo;</source>
          <target state="translated">포함 된 헤더 파일의 전체 출력을 생성하고 전체적으로 표시하려면 &lt;em&gt;기본 입력 파일&lt;/em&gt; 에서이 pragma를 사용하십시오 . 포함 된 헤더 파일은 '</target>
        </trans-unit>
        <trans-unit id="cf5e8f8ca29a0892846d7e7fbb28cf80ccb1a6dd" translate="yes" xml:space="preserve">
          <source>Use traditional TLS as the thread-local storage mechanism for dynamic accesses of TLS variables.</source>
          <target state="translated">TLS 변수의 동적 액세스를위한 스레드 로컬 스토리지 메커니즘으로 기존 TLS를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d8a60407e03b2ced230c36ef1b80cb979fd89c1c" translate="yes" xml:space="preserve">
          <source>Use uClibc C library. This is the default on &amp;lsquo;</source>
          <target state="translated">uClibc C 라이브러리를 사용하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="5a7b4e094ebc57080c3754943807a6fa36611b6e" translate="yes" xml:space="preserve">
          <source>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by</source>
          <target state="translated">비디 버그 insns에 대해이 매개 변수에서 시작하는 uid를 사용하십시오. 매개 변수 아래의 범위는 다음에 의해 생성 된 디버그 insns 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5c902a2c872ceeb654d592edec56cf917fe25417" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the C++ ABI. The default is version 0.</source>
          <target state="translated">C ++ ABI 버전 &lt;var&gt;n&lt;/var&gt; 을 사용하십시오 . 기본값은 버전 0입니다.</target>
        </trans-unit>
        <trans-unit id="80654292da05f375c19f860e1835e2717583ea50" translate="yes" xml:space="preserve">
          <source>Use version &lt;var&gt;n&lt;/var&gt; of the Objective-C ABI for the selected runtime. This option is currently supported only for the NeXT runtime. In that case, Version 0 is the traditional (32-bit) ABI without support for properties and other Objective-C 2.0 additions. Version 1 is the traditional (32-bit) ABI with support for properties and other Objective-C 2.0 additions. Version 2 is the modern (64-bit) ABI. If nothing is specified, the default is Version 0 on 32-bit target machines, and Version 2 on 64-bit target machines.</source>
          <target state="translated">선택한 런타임에 Objective-C ABI 버전 &lt;var&gt;n&lt;/var&gt; 을 사용하십시오 . 이 옵션은 현재 NeXT 런타임에서만 지원됩니다. 이 경우 버전 0은 속성 및 기타 Objective-C 2.0 추가를 지원하지 않는 기존 (32 비트) ABI입니다. 버전 1은 속성 및 기타 Objective-C 2.0 추가 기능을 지원하는 기존 (32 비트) ABI입니다. 버전 2는 최신 (64 비트) ABI입니다. 아무것도 지정하지 않으면 기본값은 32 비트 대상 시스템에서 버전 0이고 64 비트 대상 시스템에서 버전 2입니다.</target>
        </trans-unit>
        <trans-unit id="60277ce820e41f7e776a5ef4d10492797080b9c8" translate="yes" xml:space="preserve">
          <source>User defined libraries may want to implement their own constant string class. To be able to support them, the GNU Objective-C compiler provides a new command line options</source>
          <target state="translated">사용자 정의 라이브러리는 자체 상수 문자열 클래스를 구현할 수 있습니다. 이를 지원하기 위해 GNU Objective-C 컴파일러는 새로운 명령 행 옵션을 제공합니다</target>
        </trans-unit>
        <trans-unit id="6d924128c5dfe7331fc4ebe7adabf4aa651b95c3" translate="yes" xml:space="preserve">
          <source>Users often think it is a bug when GCC reports an error for code like this:</source>
          <target state="translated">사용자는 GCC가 다음과 같은 코드에 대한 오류를보고 할 때 종종 버그라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c673f0c8f99a2c8acaf1de1f7743b24ea2d61bf5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;__auto_type&lt;/code&gt; instead of &lt;code&gt;typeof&lt;/code&gt; has two advantages:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 대신 &lt;code&gt;__auto_type&lt;/code&gt; 을 사용하면 두 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16306fd8fc8ae70da39e8eba7d569ba5d4c5f6" translate="yes" xml:space="preserve">
          <source>Using extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) typically produces smaller, safer, and more efficient code, and in most cases it is a better solution than basic &lt;code&gt;asm&lt;/code&gt;. However, there are two situations where only basic &lt;code&gt;asm&lt;/code&gt; can be used:</source>
          <target state="translated">확장 &lt;code&gt;asm&lt;/code&gt; ( &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;확장 Asm&lt;/a&gt; 참조)을 사용하면 일반적으로 더 작고 안전하며 효율적인 코드가 생성되며 대부분의 경우 기본 &lt;code&gt;asm&lt;/code&gt; 보다 나은 솔루션 입니다. 그러나 기본 &lt;code&gt;asm&lt;/code&gt; 만 사용할 수있는 두 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb3b64210e267abb96c2653531b3f456e595b0e" translate="yes" xml:space="preserve">
          <source>Using floating point parameters for indirect calls to static functions will not work when using the HP assembler. There simply is no way for GCC to specify what registers hold arguments for static functions when using the HP assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">HP 어셈블러를 사용할 때 정적 함수에 대한 간접 호출에 부동 소수점 매개 변수를 사용하면 작동하지 않습니다. HP 어셈블러를 사용할 때 GCC가 정적 함수에 대한 인수를 보유하는 레지스터를 지정할 수있는 방법은 없습니다. PA의 GAS에는이 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f26807350569d85ac77ce79b84cf07a635bf81a" translate="yes" xml:space="preserve">
          <source>Using gcov with GCC optimization.</source>
          <target state="translated">GCC 최적화와 함께 gcov 사용</target>
        </trans-unit>
        <trans-unit id="057195ec8f49950ab0bbd7ddf35c8adeaad3604e" translate="yes" xml:space="preserve">
          <source>Using that same compiler, this code:</source>
          <target state="translated">동일한 컴파일러를 사용하여이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e7015f3209d38900be9cab70f20fe385b6b0e2e" translate="yes" xml:space="preserve">
          <source>Using the GNU Compiler Collection (GCC)</source>
          <target state="translated">GCC (GNU 컴파일러 모음) 사용</target>
        </trans-unit>
        <trans-unit id="e084cdbad1b5de611e7b01b9c20a68e2bf4e6eb3" translate="yes" xml:space="preserve">
          <source>Using the argument forms of the &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;destructor&lt;/code&gt; attributes on targets where the feature is not supported is rejected with an error.</source>
          <target state="translated">기능이 지원되지 않는 대상에서 &lt;code&gt;constructor&lt;/code&gt; 와 &lt;code&gt;destructor&lt;/code&gt; 속성 의 인수 형식을 사용하면 오류와 함께 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a3e4a21bb4f065c09ef23587c979ac36262bbb" translate="yes" xml:space="preserve">
          <source>Using the built-in functions described below, you can record the arguments a function received, and call another function with the same arguments, without knowing the number or types of the arguments.</source>
          <target state="translated">아래에 설명 된 내장 함수를 사용하여 함수의 인수를 기록하고 인수의 수 또는 유형을 몰라도 동일한 인수로 다른 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1d87094917525e3f4fb29e2aa35aa01c301737" translate="yes" xml:space="preserve">
          <source>Using the cast as the right-hand side of an assignment to a variable of union type is equivalent to storing in a member of the union with the same type</source>
          <target state="translated">결합 유형의 변수에 대한 지정의 오른쪽으로 캐스트를 사용하는 것은 동일한 유형의 결합 멤버에 저장하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db9a503a051e32ac0fce6e9c55331f5affaaa22c" translate="yes" xml:space="preserve">
          <source>Using the variable</source>
          <target state="translated">변수 사용</target>
        </trans-unit>
        <trans-unit id="b34c5d037644130f54f15d5f39b3ad23e6aef200" translate="yes" xml:space="preserve">
          <source>Using these common set of HTM inline functions, we can create a more portable version of the HTM example in the previous section that will work on either PowerPC or S/390:</source>
          <target state="translated">이러한 일반적인 HTM 인라인 함수 세트를 사용하여 이전 섹션에서 PowerPC 또는 S / 390에서 작동하는보다 이식 가능한 버전의 HTM 예제를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5427ab978358d5a7992aa85bab4f2f802b870d2" translate="yes" xml:space="preserve">
          <source>Using this attribute can improve optimization. Compiler predicts that a function with the attribute returns non-null in most cases. Functions like &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;calloc&lt;/code&gt; have this property because they return a pointer to uninitialized or zeroed-out storage. However, functions like &lt;code&gt;realloc&lt;/code&gt; do not have this property, as they can return a pointer to storage containing pointers.</source>
          <target state="translated">이 속성을 사용하면 최적화가 향상 될 수 있습니다. 컴파일러는 대부분의 경우 속성이있는 함수가 널이 아닌 값을 리턴한다고 예측합니다. &lt;code&gt;malloc&lt;/code&gt; 및 &lt;code&gt;calloc&lt;/code&gt; 과 같은 함수는 초기화되지 않거나 0으로 된 스토리지에 대한 포인터를 리턴 하므로이 특성을 갖습니다. 그러나 &lt;code&gt;realloc&lt;/code&gt; 과 같은 함수 에는 포인터가 포함 된 저장소에 대한 포인터를 반환 할 수 있으므로이 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b49b124c3d34a77d39d66c92e391e732c60826d" translate="yes" xml:space="preserve">
          <source>Using vector instructions through built-in functions.</source>
          <target state="translated">내장 함수를 통한 벡터 명령어 사용.</target>
        </trans-unit>
        <trans-unit id="2dfe46da755d749792dfc6596d3900b7c7d1225d" translate="yes" xml:space="preserve">
          <source>Usually, the more IPA optimizations enabled, the larger the number of impacted functions for each function. In order to control the number of impacted functions and more easily compute the list of impacted function, IPA optimizations can be partially enabled at two different levels.</source>
          <target state="translated">일반적으로 IPA 최적화를 많이 사용할수록 각 기능에 영향을받는 기능의 수가 많아집니다. 영향을받는 기능의 수를 제어하고 영향을받는 기능의 목록을보다 쉽게 ​​계산하기 위해 IPA 최적화를 두 가지 레벨로 부분적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ec5cdb7f54185163f339da83a6bb1078cb8cdf" translate="yes" xml:space="preserve">
          <source>Usually, the specified type of a compound literal is a structure. Assume that &lt;code&gt;struct foo&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; are declared as shown:</source>
          <target state="translated">일반적으로 지정된 유형의 복합 리터럴은 구조입니다. &lt;code&gt;struct foo&lt;/code&gt; 와 &lt;code&gt;structure&lt;/code&gt; 가 다음과 같이 선언 되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="574d16a752ab33d0cef891f9de30707743042305" translate="yes" xml:space="preserve">
          <source>V850E2V3</source>
          <target state="translated">V850E2V3</target>
        </trans-unit>
        <trans-unit id="18daea8d25a1ff1128b31b35345423541b18cfb9" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d31&lt;/code&gt; and the appropriate subset &lt;code&gt;d0&lt;/code&gt;-&lt;code&gt;d15&lt;/code&gt; based on command line options. Used for 64 bit values only. Not valid for Thumb1.</source>
          <target state="translated">VFP 부동 소수점 레지스터 &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d31&lt;/code&gt; 및 명령 줄 옵션을 기반으로 적절한 하위 집합 &lt;code&gt;d0&lt;/code&gt; - &lt;code&gt;d15&lt;/code&gt; . 64 비트 값에만 사용됩니다. Thumb1에는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cbb2d892b07e55db914e77fcb2ce30c1ce00bae" translate="yes" xml:space="preserve">
          <source>VFP floating-point registers &lt;code&gt;s0&lt;/code&gt;-&lt;code&gt;s31&lt;/code&gt;. Used for 32 bit values.</source>
          <target state="translated">VFP 부동 소수점 레지스터 &lt;code&gt;s0&lt;/code&gt; - &lt;code&gt;s31&lt;/code&gt; . 32 비트 값에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d910167fb4f24dfbb3904aef13e596ce47de5f7" translate="yes" xml:space="preserve">
          <source>VGPR register</source>
          <target state="translated">VGPR 레지스터</target>
        </trans-unit>
        <trans-unit id="d5387553aab64197b27321b5224709eacf46c07a" translate="yes" xml:space="preserve">
          <source>VIA C3 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX 및 3DNow를 지원하는 VIA C3 CPU! 명령 세트 지원. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="488b543fd950a74701b966446818fb5fe7d6e4bc" translate="yes" xml:space="preserve">
          <source>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX 및 SSE 명령어 세트가 지원되는 VIA C3-2 (Nehemiah / C5XL) CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="ea585482eb4a4acc3a6360d2898743a7c9373beb" translate="yes" xml:space="preserve">
          <source>VIA C7 (Esther) CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX, SSE, SSE2 및 SSE3 명령어 세트를 지원하는 VIA C7 (Esther) CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="f935a35014da34c94c36f4bd8a1a050285f9d495" translate="yes" xml:space="preserve">
          <source>VIA Eden Esther CPU with MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX, SSE, SSE2 및 SSE3 명령어 세트를 지원하는 VIA Eden Esther CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="c111443ef87aeb29107b8a68909620c76e8f94c1" translate="yes" xml:space="preserve">
          <source>VIA Eden Nehemiah CPU with MMX and SSE instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX 및 SSE 명령어 세트를 지원하는 VIA Eden Nehemiah CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="8cce1c624bb9c2543acc6d544b6d1ed27c2158a4" translate="yes" xml:space="preserve">
          <source>VIA Eden Samuel 2 CPU with MMX and 3DNow! instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">MMX 및 3DNow가 포함 된 VIA Eden Samuel 2 CPU! 명령 세트 지원. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="2151cc7927e87e8f1c1dda8e6327ac4e0a64b7a2" translate="yes" xml:space="preserve">
          <source>VIA Eden X2 CPU with x86-64, MMX, SSE, SSE2 and SSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2 및 SSE3 명령어 세트를 지원하는 VIA Eden X2 CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="1d98ef012706e83dddd4d35e5d791491017f3e46" translate="yes" xml:space="preserve">
          <source>VIA Eden X4 CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX 및 AVX2 명령어 세트를 지원하는 VIA Eden X4 CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="b8b4d4a862d49f8ff0f8c10fa3fdc814a539ab87" translate="yes" xml:space="preserve">
          <source>VIA Nano 1xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3 및 SSSE3 명령어 세트를 지원하는 VIA Nano 1xxx CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="dd719c7a93195bbf6d07de4c172b28d8c80267d3" translate="yes" xml:space="preserve">
          <source>VIA Nano 2xxx CPU with x86-64, MMX, SSE, SSE2, SSE3 and SSSE3 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3 및 SSSE3 명령어 세트를 지원하는 VIA Nano 2xxx CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="01f9fedc3d4f11e857e6f0d9dcaa2b13176b8f56" translate="yes" xml:space="preserve">
          <source>VIA Nano 3xxx CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3, SSSE3 및 SSE4.1 명령어 세트를 지원하는 VIA Nano 3xxx CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="06b544d4bdd7d18ca4149d3c750f4127e9f983b2" translate="yes" xml:space="preserve">
          <source>VIA Nano Dual Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3, SSSE3 및 SSE4.1 명령어 세트를 지원하는 VIA Nano 듀얼 코어 CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="a67ea4083339300c1d547f346d07c9d5764525af" translate="yes" xml:space="preserve">
          <source>VIA Nano Quad Core CPU with x86-64, MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 instruction set support. (No scheduling is implemented for this chip.)</source>
          <target state="translated">x86-64, MMX, SSE, SSE2, SSE3, SSSE3 및 SSE4.1 명령어 세트를 지원하는 VIA Nano Quad Core CPU. (이 칩에는 스케줄링이 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="04026107ef9bdc35c4d06c69d4d8d9bd034df2b9" translate="yes" xml:space="preserve">
          <source>VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ 명령.</target>
        </trans-unit>
        <trans-unit id="47b598fadc542503a4dfb3ab0e7c08963d810a39" translate="yes" xml:space="preserve">
          <source>VRSAVE</source>
          <target state="translated">VRSAVE</target>
        </trans-unit>
        <trans-unit id="55aa2f856c0f4ab3cdcac26a348778a588a6f8d7" translate="yes" xml:space="preserve">
          <source>VSIB address operand.</source>
          <target state="translated">VSIB 주소 피연산자</target>
        </trans-unit>
        <trans-unit id="1e028c813fc89395b126781b62fe740e1e2e5612" translate="yes" xml:space="preserve">
          <source>VSX register if direct move instructions are enabled, or NO_REGS.</source>
          <target state="translated">직접 이동 명령이 활성화 된 경우 VSX 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="b1bf4ce917ea0e342c5ba87416d3c1425045396d" translate="yes" xml:space="preserve">
          <source>VSX register if the</source>
          <target state="translated">VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="fa37e771ee1559b7e1a74968d2d6f9d21bbad3f8" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS.</source>
          <target state="translated">IEEE 128 비트 부동 소수점 TFmode 또는 NO_REGS에 사용할 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="dceb09e56dc6976e2ceb44b306b90d48c16cdbfa" translate="yes" xml:space="preserve">
          <source>VSX register to use for IEEE 128-bit floating point, or NO_REGS.</source>
          <target state="translated">IEEE 128 비트 부동 소수점 또는 NO_REGS에 사용할 VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="5f2931cf969db5dec892ea6c97702a431f737f4f" translate="yes" xml:space="preserve">
          <source>VSX register to use for ISA 3.0 vector instructions, or NO_REGS.</source>
          <target state="translated">ISA 3.0 벡터 명령어에 사용할 VSX 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="e1e2b74202b4df2a34423d711c880f4bed5b3b14" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold 128 bit integer or NO_REGS.</source>
          <target state="translated">128 비트 정수 또는 NO_REGS를 보유하는 VSX 벡터 레지스터.</target>
        </trans-unit>
        <trans-unit id="f3dc5e0d7bbebef3893829b42a25b08c256dd4d8" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold scalar double values or NO_REGS.</source>
          <target state="translated">스칼라 double 값 또는 NO_REGS를 보유하는 VSX 벡터 레지스터.</target>
        </trans-unit>
        <trans-unit id="dc350e1093c1db7d408d43c001ed04b73c029f23" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector double data or NO_REGS.</source>
          <target state="translated">벡터 이중 데이터 또는 NO_REGS를 보유하기위한 VSX 벡터 레지스터.</target>
        </trans-unit>
        <trans-unit id="167ef2a892b4ddc57b82f58074b39f524e5008e6" translate="yes" xml:space="preserve">
          <source>VSX vector register to hold vector float data or NO_REGS.</source>
          <target state="translated">벡터 부동 데이터 또는 NO_REGS를 보유하기위한 VSX 벡터 레지스터.</target>
        </trans-unit>
        <trans-unit id="81969f619b07a96e38c916b9993cc433143a784f" translate="yes" xml:space="preserve">
          <source>VTables</source>
          <target state="translated">VTables</target>
        </trans-unit>
        <trans-unit id="f5f8e1247b6f26b263b34207afe669cb4ac9de15" translate="yes" xml:space="preserve">
          <source>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require</source>
          <target state="translated">유효한 ISO C 및 ISO C ++ 프로그램은이 옵션을 사용하거나 사용하지 않고 올바르게 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c1f687862693a87865ad97fba05738669eac5ce" translate="yes" xml:space="preserve">
          <source>Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any (C11 6.2.8).</source>
          <target state="translated">기본 유형에 대해 _Alignof 표현식에 의해 리턴 된 것 이외의 유효한 정렬 값 (C11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="b8f1ffda93c672ca444e36a4f56d16e63e5832c4" translate="yes" xml:space="preserve">
          <source>Valid alignments are powers of 2 up to and including &lt;em&gt;2^{28}&lt;/em&gt;.</source>
          <target state="translated">유효한 정렬은 2의 거듭 제곱이고 &lt;em&gt;2 ^ {28}을 포함&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e0567df87b1ea75cda27929ada4a4306a0c755cd" translate="yes" xml:space="preserve">
          <source>Valid options for &lt;var&gt;time&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 유효한 옵션 은</target>
        </trans-unit>
        <trans-unit id="bd15e3ace5dbddf7a0573a3f99038d776bddea91" translate="yes" xml:space="preserve">
          <source>Value appropriate as displacement.</source>
          <target state="translated">변위로 적절한 값.</target>
        </trans-unit>
        <trans-unit id="bb6561e8ab01989a094611590f0602e85a6c5513" translate="yes" xml:space="preserve">
          <source>Values &amp;lsquo;</source>
          <target state="translated">값 '</target>
        </trans-unit>
        <trans-unit id="d206078a63cff7bace258bb1f4bb9507b5cf8d12" translate="yes" xml:space="preserve">
          <source>Variable, function, and type attributes for C++ only.</source>
          <target state="translated">C ++ 전용 변수, 함수 및 유형 속성</target>
        </trans-unit>
        <trans-unit id="02b16fb34038c0c62719510ede0c2e29dc2b90fc" translate="yes" xml:space="preserve">
          <source>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</source>
          <target state="translated">가변 길이 자동 배열은 ISO C99에서 허용되며 확장으로 GCC는 C90 모드 및 C ++에서이를 수용합니다. 이 배열은 다른 자동 배열처럼 선언되지만 상수식이 아닌 길이로 선언됩니다. 스토리지는 선언 시점에 할당되고 선언을 포함하는 블록 범위가 종료 될 때 할당 해제됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1cafb0eff03f52681f175e65218139665f9ce2c" translate="yes" xml:space="preserve">
          <source>Variables declared at global scope.</source>
          <target state="translated">전역 범위에서 선언 된 변수</target>
        </trans-unit>
        <trans-unit id="5c01cb4a8cb1760f9b45c63f7213bd015da5c74c" translate="yes" xml:space="preserve">
          <source>Variables declared within a function.</source>
          <target state="translated">함수 내에서 선언 된 변수</target>
        </trans-unit>
        <trans-unit id="b8da0198222d30500868466badddd4041e14cce0" translate="yes" xml:space="preserve">
          <source>Variables of size &lt;var&gt;n&lt;/var&gt; bytes or smaller are placed in the &lt;code&gt;.based&lt;/code&gt; section by default. Based variables use the &lt;code&gt;$tp&lt;/code&gt; register as a base register, and there is a 128-byte limit to the &lt;code&gt;.based&lt;/code&gt; section.</source>
          <target state="translated">크기가 &lt;var&gt;n&lt;/var&gt; 바이트 이하인 변수는 기본적으로 &lt;code&gt;.based&lt;/code&gt; 섹션에 배치됩니다 . 기반 변수는 &lt;code&gt;$tp&lt;/code&gt; 레지스터를 기본 레지스터로 사용하며 &lt;code&gt;.based&lt;/code&gt; 섹션 에는 128 바이트 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10abea2eed8c32edbb792ccf39c883573091a3b2" translate="yes" xml:space="preserve">
          <source>Variables that are &lt;var&gt;n&lt;/var&gt; bytes or smaller are allocated to the &lt;code&gt;.tiny&lt;/code&gt; section. These variables use the &lt;code&gt;$gp&lt;/code&gt; base register. The default for this option is 4, but note that there&amp;rsquo;s a 65536-byte limit to the &lt;code&gt;.tiny&lt;/code&gt; section.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 바이트 이하의 변수 는 &lt;code&gt;.tiny&lt;/code&gt; 섹션에 할당됩니다 . 이 변수는 &lt;code&gt;$gp&lt;/code&gt; 기본 레지스터를 사용합니다 . 이 옵션의 기본값은 4이지만 &lt;code&gt;.tiny&lt;/code&gt; 섹션 에는 65536 바이트 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd3f9d35c079daab2745eafe9db9775e6794913e" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;cb&lt;/code&gt; attribute are used to access the control bus, using special instructions. &lt;code&gt;addr&lt;/code&gt; indicates the control bus address. Example:</source>
          <target state="translated">&lt;code&gt;cb&lt;/code&gt; 속성을 가진 변수는 특수 명령을 사용하여 제어 버스에 액세스하는 데 사용됩니다. &lt;code&gt;addr&lt;/code&gt; 는 제어 버스 주소를 나타냅니다. 예:</target>
        </trans-unit>
        <trans-unit id="de934aeb77c58838cc9846aadb82fbd1b8f30e96" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;far&lt;/code&gt; attribute are addressed using a full 32-bit address. Since this covers the entire memory space, this allows modules to make no assumptions about where variables might be stored.</source>
          <target state="translated">&lt;code&gt;far&lt;/code&gt; 속성을 가진 변수 는 전체 32 비트 주소를 사용하여 처리됩니다. 이는 전체 메모리 공간을 다루므로 모듈이 변수를 저장할 수있는 위치에 대한 가정을 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="36905cf24c84385c4961b4619b30de52faf8e512" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;io&lt;/code&gt; attribute are used to address memory-mapped peripherals. If an address is specified, the variable is assigned that address, else it is not assigned an address (it is assumed some other module assigns an address). Example:</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 속성을 가진 변수는 메모리 매핑 된 주변 장치를 처리하는 데 사용됩니다. 주소가 지정되면 변수에 해당 주소가 지정되고 그렇지 않으면 주소가 지정되지 않습니다 (다른 모듈이 주소를 지정한다고 가정). 예:</target>
        </trans-unit>
        <trans-unit id="8908399e90d6597694e9414404cf146058083fc2" translate="yes" xml:space="preserve">
          <source>Variables with the &lt;code&gt;near&lt;/code&gt; attribute are assumed to have addresses that fit in a 24-bit addressing mode. This is the default for large variables (&lt;code&gt;-mtiny=4&lt;/code&gt; is the default) but this attribute can override &lt;code&gt;-mtiny=&lt;/code&gt; for small variables, or override &lt;code&gt;-ml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;near&lt;/code&gt; 속성을 가진 변수 는 24 비트 주소 지정 모드에 맞는 주소를 갖는 것으로 가정합니다. 이 큰 변수의 기본값입니다 ( &lt;code&gt;-mtiny=4&lt;/code&gt; 는 기본입니다)하지만,이 속성은 대체 할 수 있습니다 &lt;code&gt;-mtiny=&lt;/code&gt; 작은 변수, 또는 오버라이드 (override) &lt;code&gt;-ml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f34701193da16d128be7840c2b5e27cdc6209c0" translate="yes" xml:space="preserve">
          <source>Variadic functions always use the &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; calling convention and the compiler rejects attempts to specify an alternative.</source>
          <target state="translated">Variadic 함수는 항상 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 호출 규칙을 사용하며 컴파일러는 대안을 지정하려는 시도를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="c34add3442e320001d71a4acf459f90b84551e3c" translate="yes" xml:space="preserve">
          <source>Variations on C++.</source>
          <target state="translated">C ++의 변형.</target>
        </trans-unit>
        <trans-unit id="0125a3430008ecbd7c8a33ef91916cf2ea436c9e" translate="yes" xml:space="preserve">
          <source>Variations on Objective-C and Objective-C++.</source>
          <target state="translated">Objective-C 및 Objective-C ++의 변형</target>
        </trans-unit>
        <trans-unit id="eb5d846c7919ee0bdc2338a4cc38cee42f3c00b6" translate="yes" xml:space="preserve">
          <source>Vector comparison is supported with standard comparison operators: &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</source>
          <target state="translated">벡터 비교는 표준 비교 연산자 ( &lt;code&gt;==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; 됩니다. 비교 피연산자는 정수형 또는 실수 형의 벡터 표현식 일 수 있습니다. 정수형 벡터와 실수 형 벡터의 비교는 지원되지 않습니다. 비교 결과는 부호있는 정수 요소 유형을 가진 비교 피연산자와 동일한 너비와 요소 수의 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="5abc95e73e06fb4a5dc5582edf5afa312b0850ca" translate="yes" xml:space="preserve">
          <source>Vector condition register: VCC, VCC_LO, VCC_HI</source>
          <target state="translated">벡터 조건 레지스터 : VCC, VCC_LO, VCC_HI</target>
        </trans-unit>
        <trans-unit id="53804d00035aa75837541b3ccf479dca992da7d5" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with XXSPLTIB &amp;amp; sign extension.</source>
          <target state="translated">XXSPLTIB &amp;amp; 부호 확장으로로드 할 수있는 벡터 상수.</target>
        </trans-unit>
        <trans-unit id="82f741b1697518a50ba54947e1a23cae2eaec1c0" translate="yes" xml:space="preserve">
          <source>Vector constant that can be loaded with the XXSPLTIB instruction.</source>
          <target state="translated">XXSPLTIB 명령으로로드 할 수있는 벡터 상수.</target>
        </trans-unit>
        <trans-unit id="46e517c61990308718dcf40277ed1d92f620280a" translate="yes" xml:space="preserve">
          <source>Vector constant that does not require memory</source>
          <target state="translated">메모리가 필요없는 벡터 상수</target>
        </trans-unit>
        <trans-unit id="b42c5127757a32ed5d06d2b5cf09ce9893f82ec9" translate="yes" xml:space="preserve">
          <source>Vector constant that is all zeros.</source>
          <target state="translated">모두 0 인 벡터 상수.</target>
        </trans-unit>
        <trans-unit id="9c36bdfc3b8d0b06a49e5ef972497ba956ef9bbc" translate="yes" xml:space="preserve">
          <source>Vector conversion is available using the &lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; function. &lt;var&gt;vec&lt;/var&gt; must be an expression with integral or floating vector type and &lt;var&gt;vectype&lt;/var&gt; an integral or floating vector type with the same number of elements. The result has &lt;var&gt;vectype&lt;/var&gt; type and value of a C cast of every element of &lt;var&gt;vec&lt;/var&gt; to the element type of &lt;var&gt;vectype&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;__builtin_convertvector (vec, vectype)&lt;/code&gt; 함수를 사용하여 벡터 변환을 사용할 수 있습니다 . &lt;var&gt;vec&lt;/var&gt; 는 정수 또는 부동 벡터 유형을 가진 표현식이어야하고 &lt;var&gt;vectype&lt;/var&gt; 은 동일한 수의 요소를 가진 정수 또는 부동 벡터 유형을 가져야 합니다. 결과는 &lt;var&gt;vectype&lt;/var&gt; 유형과 vectype 요소에 대한 모든 &lt;var&gt;vec&lt;/var&gt; 요소의 C 캐스트 값 을 &lt;var&gt;vectype&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bad6bdbaf23ec0df51bc6d85940b036ecbab94" translate="yes" xml:space="preserve">
          <source>Vector registers.</source>
          <target state="translated">벡터 레지스터.</target>
        </trans-unit>
        <trans-unit id="8e0df7cd51c0d162c1fce7156e6eae770327c8c2" translate="yes" xml:space="preserve">
          <source>Vector shuffling is available using functions &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; and &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt;. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The &lt;var&gt;mask&lt;/var&gt; is an integral vector with the same width (&lt;var&gt;W&lt;/var&gt;) and element count (&lt;var&gt;N&lt;/var&gt;) as the output vector.</source>
          <target state="translated">벡터 셔플 링은 &lt;code&gt;__builtin_shuffle (vec, mask)&lt;/code&gt; 및 &lt;code&gt;__builtin_shuffle (vec0, vec1, mask)&lt;/code&gt; 함수를 사용하여 사용할 수 있습니다 . 두 함수 모두 하나 또는 두 개의 벡터에서 요소의 순열을 구성하고 입력 벡터와 동일한 유형의 벡터를 반환합니다. &lt;var&gt;mask&lt;/var&gt; 동일한 폭 (와 적분 벡터이다 &lt;var&gt;W&lt;/var&gt; ) 및 소자 개수 ( &lt;var&gt;N&lt;/var&gt; 출력 벡터로서).</target>
        </trans-unit>
        <trans-unit id="58128c4d1de4d0a51bf04fac4cddbc549bd01efb" translate="yes" xml:space="preserve">
          <source>Vector zero</source>
          <target state="translated">벡터 제로</target>
        </trans-unit>
        <trans-unit id="73c5f8f62b1af06d2d8df3f66347a1a059d5cf24" translate="yes" xml:space="preserve">
          <source>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</source>
          <target state="translated">비교가 거짓이면 벡터가 요소 단위로 0을 생성하고 그렇지 않으면 -1 (모든 비트가 설정되는 적절한 유형에 따라)을 생성합니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fcd23bd0a88ba1a503b10ed5edf55ece81978ffc" translate="yes" xml:space="preserve">
          <source>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with</source>
          <target state="translated">벡터는 벡터가 동일한 개수의 요소와 기본 유형을 가진 배열 인 것처럼 첨자화할 수 있습니다. 범위를 벗어난 액세스는 런타임에 정의되지 않은 동작을 호출합니다. 벡터 구독에 대한 범위를 벗어난 액세스에 대한 경고는</target>
        </trans-unit>
        <trans-unit id="e368f0bdb096cdc80b942de26edde7361d633b14" translate="yes" xml:space="preserve">
          <source>Version 0 refers to the version conforming most closely to the C++ ABI specification. Therefore, the ABI obtained using version 0 will change in different versions of G++ as ABI bugs are fixed.</source>
          <target state="translated">버전 0은 C ++ ABI 사양과 가장 일치하는 버전을 나타냅니다. 따라서 버전 0을 사용하여 얻은 ABI는 ABI 버그가 수정되면 G ++의 다른 버전에서 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4d24a59e560f384b23499b32746ec055716a43ab" translate="yes" xml:space="preserve">
          <source>Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.</source>
          <target state="translated">버전 1은 G ++ 3.2에서 처음 등장한 C ++ ABI의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="3c0b003b505c0ed05512e30de5602e0fe9cf92cd" translate="yes" xml:space="preserve">
          <source>Version 10, which first appeared in G++ 6.1, adds mangling of attributes that affect type identity, such as ia32 calling convention attributes (e.g. &amp;lsquo;</source>
          <target state="translated">G ++ 6.1에서 처음 등장한 버전 10은 ia32 호출 규칙 속성 (예 : '</target>
        </trans-unit>
        <trans-unit id="663092bb020840a15939c0d6a393bb5154dcf611" translate="yes" xml:space="preserve">
          <source>Version 11, which first appeared in G++ 7, corrects the mangling of sizeof... expressions and operator names. For multiple entities with the same name within a function, that are declared in different scopes, the mangling now changes starting with the twelfth occurrence. It also implies</source>
          <target state="translated">G ++ 7에서 처음 등장한 버전 11은 sizeof ... 표현식과 연산자 이름의 맹 글링을 수정합니다. 다른 범위에서 선언 된 함수 내에서 동일한 이름을 가진 여러 엔티티의 경우 이제 맹 글링이 12 번째 항목부터 변경됩니다. 또한 암시</target>
        </trans-unit>
        <trans-unit id="0ca6a1ee7b0905689803a926babe92130837b997" translate="yes" xml:space="preserve">
          <source>Version 12, which first appeared in G++ 8, corrects the calling conventions for empty classes on the x86_64 target and for classes with only deleted copy/move constructors. It accidentally changes the calling convention for classes with a deleted copy constructor and a trivial move constructor.</source>
          <target state="translated">G ++ 8에서 처음 등장한 버전 12는 x86_64 대상의 빈 클래스와 삭제 된 복사 / 이동 생성자 만있는 클래스의 호출 규칙을 수정합니다. 실수로 삭제 된 복사 생성자와 간단한 이동 생성자가있는 클래스의 호출 규칙을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="50a009d60ade6b341d095db62ce8f2e0c4f1391a" translate="yes" xml:space="preserve">
          <source>Version 13, which first appeared in G++ 8.2, fixes the accidental change in version 12.</source>
          <target state="translated">G ++ 8.2에서 처음 등장한 버전 13은 실수로 버전 12의 변경 사항을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3b38c5970d57d0e95ac144e09f14ebe98042886d" translate="yes" xml:space="preserve">
          <source>Version 2 is the version of the C++ ABI that first appeared in G++ 3.4, and was the default through G++ 4.9.</source>
          <target state="translated">버전 2는 G ++ 3.4에서 처음 등장한 G ++ 4.9의 기본값 인 C ++ ABI의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b724fbb5aa7b15b70d72eb03063512067a94eeca" translate="yes" xml:space="preserve">
          <source>Version 3 corrects an error in mangling a constant address as a template argument.</source>
          <target state="translated">버전 3은 상수 주소를 템플릿 인수로 처리 할 때 발생하는 오류를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="01a6ae459293959ae77cf0ff9e1fc859781779ed" translate="yes" xml:space="preserve">
          <source>Version 4 may require GDB 7.0 and</source>
          <target state="translated">버전 4는 GDB 7.0 및</target>
        </trans-unit>
        <trans-unit id="dd83630f9225432d363943045fc9c9e3da8fa1fd" translate="yes" xml:space="preserve">
          <source>Version 4, which first appeared in G++ 4.5, implements a standard mangling for vector types.</source>
          <target state="translated">G ++ 4.5에서 처음 등장한 버전 4는 벡터 유형에 대한 표준 mangling을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bcd8e454766585098e98a3f378e25d4a3a094eb0" translate="yes" xml:space="preserve">
          <source>Version 5, which first appeared in G++ 4.6, corrects the mangling of attribute const/volatile on function pointer types, decltype of a plain decl, and use of a function parameter in the declaration of another parameter.</source>
          <target state="translated">G ++ 4.6에서 처음 등장한 버전 5는 함수 포인터 유형에서 const / volatile 속성의 mangling, 일반 decl의 decltype 및 다른 매개 변수 선언에서 함수 매개 변수 사용을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b60149f703c30d6cd13e3a5cac7ff5559e1b4439" translate="yes" xml:space="preserve">
          <source>Version 6, which first appeared in G++ 4.7, corrects the promotion behavior of C++11 scoped enums and the mangling of template argument packs, const/static_cast, prefix ++ and &amp;ndash;, and a class scope function used as a template argument.</source>
          <target state="translated">G ++ 4.7에서 처음 등장한 버전 6은 C ++ 11 범위 열거의 승격 동작 및 템플리트 인수 팩, const / static_cast, 접두사 ++ 및 &amp;ndash;의 조작 및 템플리트 인수로 사용되는 클래스 범위 함수를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4782295af04ef7af5fe54b3ee6d18f5a34a794e5" translate="yes" xml:space="preserve">
          <source>Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a builtin type and corrects the mangling of lambdas in default argument scope.</source>
          <target state="translated">G ++ 4.8에서 처음 등장한 버전 7은 nullptr_t를 내장 유형으로 취급하고 기본 인수 범위에서 람다의 맹 글링을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="d1c84e5d1ca1394d2ffa2a327b111624fb731bc7" translate="yes" xml:space="preserve">
          <source>Version 8, which first appeared in G++ 4.9, corrects the substitution behavior of function types with function-cv-qualifiers.</source>
          <target state="translated">G ++ 4.9에서 처음 등장한 버전 8은 function-cv-qualifiers로 함수 유형의 대체 동작을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4ac00f95e84165203755f6a82a57d89ac3c1bab9" translate="yes" xml:space="preserve">
          <source>Version 9, which first appeared in G++ 5.2, corrects the alignment of &lt;code&gt;nullptr_t&lt;/code&gt;.</source>
          <target state="translated">G ++ 5.2에서 처음 등장한 버전 9는 &lt;code&gt;nullptr_t&lt;/code&gt; 의 정렬을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="1cbaf9a36f9cc94b3082b235b02920043f217806" translate="yes" xml:space="preserve">
          <source>Visium&amp;mdash;</source>
          <target state="translated">Visium&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ea87a96f76fbda4a0ceea67f5b82b7da4f4e2ed4" translate="yes" xml:space="preserve">
          <source>Volatile memory access bypass the cache using the I/O variants of the load and store instructions. The default is not to bypass the cache.</source>
          <target state="translated">휘발성 메모리 액세스는로드 및 저장 명령어의 I / O 변형을 사용하여 캐시를 우회합니다. 기본값은 캐시를 무시하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="1b1d16cb93f0aa2689c3eb4f6494e062863aa127" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on</source>
          <target state="translated">ISO C ++ 1998과 ISO C ++ 2011간에 의미가 다른 C ++ 구문에 대해 경고합니다 (예 : ISO C ++ 2011의 키워드 인 ISO C ++ 1998의 식별자).이 경고는 켜집니다.</target>
        </trans-unit>
        <trans-unit id="a16be8e81dda2e7fc6c8f9439ff0fc768831de14" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by</source>
          <target state="translated">ISO C ++ 2011과 ISO C ++ 2014의 의미가 다른 C ++ 구문에 대해 경고합니다.이 경고는</target>
        </trans-unit>
        <trans-unit id="7632b789c4deefeb017ad2d53cdd4160afd5fe89" translate="yes" xml:space="preserve">
          <source>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by</source>
          <target state="translated">ISO C ++ 2014와 ISO C ++ 2017의 의미가 다른 C ++ 구문에 대해 경고합니다.이 경고는</target>
        </trans-unit>
        <trans-unit id="53b51f298dc17e10801636bad5bebb8011117716" translate="yes" xml:space="preserve">
          <source>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from &lt;code&gt;void *&lt;/code&gt; to a pointer to non-&lt;code&gt;void&lt;/code&gt; type.</source>
          <target state="translated">ISO C 및 C ++ ISO로부터 암시 적 변환에 대한 요청 등의 공통 서브셋 벗어난 ISO C 구조에 대한 경고 &lt;code&gt;void *&lt;/code&gt; 비 포인터에 &lt;code&gt;void&lt;/code&gt; 형.</target>
        </trans-unit>
        <trans-unit id="4f7de69bb81f9d506bfb6d47f928c946ab6b330c" translate="yes" xml:space="preserve">
          <source>Warn about One Definition Rule violations during link-time optimization. Requires</source>
          <target state="translated">링크 타임 최적화 중 하나의 정의 규칙 위반에 대해 경고합니다. 필요</target>
        </trans-unit>
        <trans-unit id="f7cf98ad983fadf59ea9d8e55fff149a4d55f39b" translate="yes" xml:space="preserve">
          <source>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by</source>
          <target state="translated">열거 된 다른 유형의 값 사이의 비교에 대해 경고합니다. C ++에서 조건부 표현식의 열거 된 유형 불일치도 진단되며 기본적으로 경고가 사용됩니다. C에서이 경고는</target>
        </trans-unit>
        <trans-unit id="5887fb5f81adf7425e8f523309718b847865d42f" translate="yes" xml:space="preserve">
          <source>Warn about a definition of an unsized deallocation function</source>
          <target state="translated">크기가 지정되지 않은 할당 해제 함수의 정의에 대해 경고</target>
        </trans-unit>
        <trans-unit id="a4b22fdd430cf26b4eb0550ba2a6437e719969f1" translate="yes" xml:space="preserve">
          <source>Warn about a new-expression of a type that requires greater alignment than the &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; but uses an allocation function without an explicit alignment parameter. This option is enabled by</source>
          <target state="translated">&lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 보다 큰 정렬이 필요 하지만 명시적인 정렬 매개 변수없이 할당 함수를 사용하는 유형의 새로운 표현식에 대해 경고합니다 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="57392da628b0c1cb78f8e90a0ce56848a537dcc1" translate="yes" xml:space="preserve">
          <source>Warn about anything that depends on the &amp;ldquo;size of&amp;rdquo; a function type or of &lt;code&gt;void&lt;/code&gt;. GNU C assigns these types a size of 1, for convenience in calculations with &lt;code&gt;void *&lt;/code&gt; pointers and pointers to functions. In C++, warn also when an arithmetic operation involves &lt;code&gt;NULL&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">함수 유형 또는 &lt;code&gt;void&lt;/code&gt; 의 &quot;크기&quot;에 의존하는 모든 것에 대해 경고 합니다. GNU C는 &lt;code&gt;void *&lt;/code&gt; 포인터와 함수에 대한 포인터로 계산할 때 편의를 위해 이러한 유형의 크기를 1 로 지정합니다. C ++에서 산술 연산에 &lt;code&gt;NULL&lt;/code&gt; 이 포함 된 경우에도 경고 합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="a808a76d216f717246383427b89eff52c9b874ec" translate="yes" xml:space="preserve">
          <source>Warn about boolean expression compared with an integer value different from &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;. For instance, the following comparison is always false:</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; 와 다른 정수 값과 비교하여 부울 식에 대해 경고 합니다 . 예를 들어, 다음 비교는 항상 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a9d532ae5e4af7c1749f0187b9a6c681cd5f881a" translate="yes" xml:space="preserve">
          <source>Warn about calls to allocation functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that specify zero bytes, including those to the built-in forms of the functions &lt;code&gt;aligned_alloc&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, and &lt;code&gt;realloc&lt;/code&gt;. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of &lt;code&gt;realloc&lt;/code&gt; has been deprecated) relying on it may result in subtle portability bugs and should be avoided.</source>
          <target state="translated">정렬 된 함수 &lt;code&gt;aligned_alloc&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; 및 &lt;code&gt;realloc&lt;/code&gt; 의 내장 양식에 대한 것을 포함하여 0 바이트를 지정 하는 속성 &lt;code&gt;alloc_size&lt;/code&gt; 로 장식 된 할당 함수에 대한 호출에 대해 경고합니다 . 크기가 0으로 호출 될 때 이러한 함수의 동작은 구현에 따라 다르며 ( &lt;code&gt;realloc&lt;/code&gt; 이 더 이상 사용되지 않는 경우)이 함수에 의존하면 미묘한 이식성 버그가 발생할 수 있으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cff65779e3725cfbc2854d42263f2ace49a0bba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;snprintf&lt;/code&gt; and &lt;code&gt;vsnprintf&lt;/code&gt; that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic</source>
          <target state="translated">&lt;code&gt;snprintf&lt;/code&gt; 및 &lt;code&gt;vsnprintf&lt;/code&gt; 와 같은 형식화 된 입력 / 출력 함수에 대한 호출 에서 출력 잘림을 초래할 수 있음에 대해 경고합니다 . 형식 지시문에 의해 작성된 정확한 바이트 수를 컴파일 타임에 판별 할 수없는 경우 &lt;var&gt;level&lt;/var&gt; 인수 및 최적화에 의존하는 휴리스틱을 기반으로 추정 됩니다. 최적화를 사용하면 대부분의 경우 경고 정확도가 향상되지만 오 탐지가 발생할 수도 있습니다. 달리 언급 된 경우를 제외하고 옵션은 동일한 논리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="66472dc4cd87cc63c73cb46419c0fd90cf1906ba" translate="yes" xml:space="preserve">
          <source>Warn about calls to formatted input/output functions such as &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the &lt;var&gt;level&lt;/var&gt; argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives.</source>
          <target state="translated">대상 버퍼를 오버플로 할 수있는 &lt;code&gt;sprintf&lt;/code&gt; 및 &lt;code&gt;vsprintf&lt;/code&gt; 와 같은 형식화 된 입력 / 출력 함수 호출에 대해 경고 합니다. 형식 지시문에 의해 작성된 정확한 바이트 수를 컴파일 타임에 판별 할 수없는 경우 &lt;var&gt;level&lt;/var&gt; 인수 및 최적화에 의존하는 휴리스틱을 기반으로 추정 됩니다. 최적화를 사용하면 대부분의 경우 경고 정확도가 향상되지만 오 탐지가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8986e7105a9ec8665e2dbbf6296adf8b057bee04" translate="yes" xml:space="preserve">
          <source>Warn about calls to functions decorated with attribute &lt;code&gt;alloc_size&lt;/code&gt; that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of &amp;lsquo;</source>
          <target state="translated">지정된 바이트 수보다 큰 객체를 할당하려고 시도하는 속성 &lt;code&gt;alloc_size&lt;/code&gt; 로 장식 된 함수에 대한 호출 또는 무한 정밀도를 갖는 정수 유형의 크기 계산 결과가 '</target>
        </trans-unit>
        <trans-unit id="88c937d55912c756c7716e6f943b38520ff30020" translate="yes" xml:space="preserve">
          <source>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. This level of</source>
          <target state="translated">의심스럽고 피하기 쉬운 사례에 대해 경고합니다. 예를 들어, 컴파일러는 &lt;code&gt;x + 1 &amp;gt; x&lt;/code&gt; 를 &lt;code&gt;1&lt;/code&gt; 로 단순화 합니다. 이 수준</target>
        </trans-unit>
        <trans-unit id="179fecfde091b7cc90c5093c0b77e7c3ec453920" translate="yes" xml:space="preserve">
          <source>Warn about catch handlers that do not catch via reference. With</source>
          <target state="translated">참조를 통해 catch하지 않는 catch 처리기에 대해 경고합니다. 와</target>
        </trans-unit>
        <trans-unit id="5d56df9ae38e57af735866e84e0cdb01862c2396" translate="yes" xml:space="preserve">
          <source>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided.</source>
          <target state="translated">기존 및 ISO C에서 다르게 작동하는 특정 구성에 대해 경고합니다. 또한 기존 C와 동등한 구성 요소가없는 ISO C 구성 및 / 또는 피해야 할 문제가있는 구성에 대해서도 경고합니다.</target>
        </trans-unit>
        <trans-unit id="208feed4ba7b2db7b751737e5df71463aa2d59a9" translate="yes" xml:space="preserve">
          <source>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards.</source>
          <target state="translated">C 및 C ++ 표준에서 시퀀스 포인트 규칙을 위반하여 정의되지 않은 의미를 가질 수있는 코드에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="120296c8df6378a5551d4a8157d2634bb8869dc7" translate="yes" xml:space="preserve">
          <source>Warn about constructions where there may be confusion to which &lt;code&gt;if&lt;/code&gt; statement an &lt;code&gt;else&lt;/code&gt; branch belongs. Here is an example of such a case:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문과 &lt;code&gt;else&lt;/code&gt; 브랜치 가 혼동 될 수있는 구조에 대해 경고 합니다. 다음은 그러한 경우의 예입니다.</target>
        </trans-unit>
        <trans-unit id="5a68fb773b2ee57c56ecf208d21e354737b77e2a" translate="yes" xml:space="preserve">
          <source>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space.</source>
          <target state="translated">결과 주소 공간이 수신 주소 공간에 포함되지 않은 경우 주소 공간 간 변환에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0761a82a1e056ee411ecf4ae535a9dfad8b30dfc" translate="yes" xml:space="preserve">
          <source>Warn about declarations using the &lt;code&gt;alias&lt;/code&gt; and similar attributes whose target is incompatible with the type of the alias. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 및 대상이 별명 유형과 호환되지 않는 유사한 속성을 사용하는 선언에 대해 경고 하십시오. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f643480f69fb1c621533ba0cdd904776e7e1ef4b" translate="yes" xml:space="preserve">
          <source>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code:</source>
          <target state="translated">if-else-if 체인에서 중복 조건에 대해 경고합니다. 예를 들어 다음 코드에 대해 경고하십시오.</target>
        </trans-unit>
        <trans-unit id="f7359f7ae633c3c242379554307ef603621fed1e" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, &lt;code&gt;long long&lt;/code&gt; type, &lt;code&gt;bool&lt;/code&gt; type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">ISO C90에는 없지만 ISO C99에는있는 기능에 대해 경고합니다. 예를 들어, 가변 길이 배열, &lt;code&gt;long long&lt;/code&gt; 유형, &lt;code&gt;bool&lt;/code&gt; 유형, 복합 리터럴, 지정된 이니셜 라이저 등의 사용에 대해 경고하십시오 . 이 옵션은 표준 모드와 무관합니다. &lt;code&gt;__extension__&lt;/code&gt; 다음에 오는 표현식에서는 경고가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="626c854c9715d516c67e89068f1bb76234cf669a" translate="yes" xml:space="preserve">
          <source>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, &lt;code&gt;_Atomic&lt;/code&gt; type qualifier, &lt;code&gt;_Thread_local&lt;/code&gt; storage-class specifier, &lt;code&gt;_Alignas&lt;/code&gt; specifier, &lt;code&gt;Alignof&lt;/code&gt; operator, &lt;code&gt;_Generic&lt;/code&gt; keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;.</source>
          <target state="translated">ISO C99에는 없지만 ISO C11에는있는 기능에 대해 경고합니다. 예를 들어, 익명 구조 및 공용체, &lt;code&gt;_Atomic&lt;/code&gt; 유형 한정자, &lt;code&gt;_Thread_local&lt;/code&gt; 스토리지 클래스 지정자, &lt;code&gt;_Alignas&lt;/code&gt; 지정자, &lt;code&gt;Alignof&lt;/code&gt; 연산자, &lt;code&gt;_Generic&lt;/code&gt; 키워드 등의 사용에 대해 경고하십시오 . 이 옵션은 표준 모드와 무관합니다. &lt;code&gt;__extension__&lt;/code&gt; 다음에 오는 표현식에서는 경고가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="643ea2b6cbf0ea1bcfec495e08e3195164382b91" translate="yes" xml:space="preserve">
          <source>Warn about function pointers that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with &lt;code&gt;format&lt;/code&gt; attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding &lt;code&gt;format&lt;/code&gt; attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a &lt;code&gt;format&lt;/code&gt; attribute to avoid the warning.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 속성의 후보가 될 수있는 함수 포인터에 대해 경고 합니다. 이것들은 가능한 후보 일 뿐이며 절대적인 후보는 아닙니다. GCC는 할당, 초기화, 매개 변수 전달 또는 반환 문에 사용되는 &lt;code&gt;format&lt;/code&gt; 특성이있는 함수 포인터 는 결과 &lt;code&gt;format&lt;/code&gt; 에 해당 형식 특성 이 있어야한다고 생각합니다 . 즉, 할당 또는 초기화의 왼쪽, 매개 변수 변수의 유형 또는 포함 함수의 반환 유형에는 각각 경고를 피하기 위한 &lt;code&gt;format&lt;/code&gt; 속성 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3534585cbc01893459375a2f73a721f1390a46" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for &lt;code&gt;cold&lt;/code&gt; attribute. This is based on static detection and generally will only warn about functions which always leads to a call to another &lt;code&gt;cold&lt;/code&gt; function such as wrappers of C++ &lt;code&gt;throw&lt;/code&gt; or fatal error reporting functions leading to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 속성의 후보가 될 수있는 함수에 대해 경고 합니다. 이것은 정적 감지를 기반으로하며 일반적으로 항상 C ++ &lt;code&gt;throw&lt;/code&gt; 래퍼 또는 &lt;code&gt;abort&lt;/code&gt; 이어지는 치명적 오류보고 함수 와 같은 다른 &lt;code&gt;cold&lt;/code&gt; 함수를 호출하는 함수에 대해서만 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="ad5773c66378dee79865728b1022e5f1ddb94781" translate="yes" xml:space="preserve">
          <source>Warn about functions that might be candidates for attributes &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;noreturn&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt;. The compiler only warns for functions visible in other compilation units or (in the case of &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;) if it cannot prove that the function returns normally. A function returns normally if it doesn&amp;rsquo;t contain an infinite loop or return abnormally by throwing, calling &lt;code&gt;abort&lt;/code&gt; or trapping. This analysis requires option</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;noreturn&lt;/code&gt; 또는 &lt;code&gt;malloc&lt;/code&gt; 속성의 후보가 될 수있는 함수에 대해 경고 합니다. 컴파일러는 다른 컴파일 단위에서 볼 수있는 함수 또는 함수가 정상적으로 리턴된다는 것을 증명할 수없는 경우 ( &lt;code&gt;pure&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 의 경우)에만 경고 합니다. 무한 루프를 포함하지 않거나 던지기, &lt;code&gt;abort&lt;/code&gt; 또는 트 랩핑을 통해 비정상적으로 반환되는 함수는 정상적으로 반환됩니다 . 이 분석에는 옵션이 필요합니다</target>
        </trans-unit>
        <trans-unit id="97272a64aa6772a9d1f50422c6dbb8adfe294518" translate="yes" xml:space="preserve">
          <source>Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes (and newer).</source>
          <target state="translated">왼쪽 시프트 오버 플로우에 대해 경고합니다. 이 경고는 C99 및 C ++ 11 모드 이상에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cab17a3fd72f34df7821e30e584c4c51a37bba48" translate="yes" xml:space="preserve">
          <source>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following:</source>
          <target state="translated">비교의 왼쪽 피연산자에 사용되지 않은 논리에 대해 경고합니다. 올바른 피연산자가 부울 표현식으로 간주되는 경우이 옵션은 경고하지 않습니다. 그 목적은 다음과 같은 의심스러운 코드를 탐지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48b82c0283a2915829a3ee6a3436cc1017b5ea05" translate="yes" xml:space="preserve">
          <source>Warn about macros defined in the main file that are unused. A macro is &lt;em&gt;used&lt;/em&gt; if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined.</source>
          <target state="translated">사용하지 않는 기본 파일에 정의 된 매크로에 대해 경고하십시오. 매크로는 확장 또는 존재 여부를 한 번 이상 테스트 한 경우 에 &lt;em&gt;사용&lt;/em&gt; 됩니다. 또한 사전 처리기는 매크로가 재정의되거나 정의되지 않은 시점에 매크로가 사용되지 않은 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="b4b8fd61bdb1f1846bd01a97a7bd276155ea4f4c" translate="yes" xml:space="preserve">
          <source>Warn about overriding virtual functions that are not marked with the override keyword.</source>
          <target state="translated">override 키워드로 표시되지 않은 가상 함수 재정의에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="b83b9745dc97dfb351a27bd912c00da1a8c7a2f9" translate="yes" xml:space="preserve">
          <source>Warn about passing a null pointer for arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">널이 &lt;code&gt;nonnull&lt;/code&gt; 함수 속성에 의해 널 이 아닌 값을 요구하는 것으로 표시된 인수에 대해 널 포인터를 전달하는 것에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="6aa9959edf6bc4922ebb912c9a250384b3090f7c" translate="yes" xml:space="preserve">
          <source>Warn about placement new expressions with undefined behavior, such as constructing an object in a buffer that is smaller than the type of the object. For example, the placement new expression below is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.</source>
          <target state="translated">객체 유형보다 작은 버퍼에 객체를 생성하는 것과 같이 정의되지 않은 동작으로 새로운 표현식을 배치하는 것에 대해 경고합니다. 예를 들어, 아래의 새로운 배치 식은 64 바이트 크기의 버퍼에 64 개의 정수 배열을 구성하려고 시도하기 때문에 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="185c654029973156a2e707b7e9ffcc02226e09a9" translate="yes" xml:space="preserve">
          <source>Warn about redundant semicolon after in-class function definition.</source>
          <target state="translated">클래스 내 함수 정의 후 중복 세미콜론에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="083bdeb1c857ab3b93f3cbf9b4f7687d0f51ffb4" translate="yes" xml:space="preserve">
          <source>Warn about string constants that are longer than the &amp;ldquo;minimum maximum&amp;rdquo; length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard&amp;rsquo;s minimum limit, but very portable programs should avoid using longer strings.</source>
          <target state="translated">C 표준에 지정된 &quot;최소 최대&quot;길이보다 긴 문자열 상수에 대해 경고합니다. 최신 컴파일러는 일반적으로 표준의 최소 한계보다 훨씬 긴 문자열 상수를 허용하지만 이식성이 뛰어난 프로그램은 더 긴 문자열을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e453618f3508cc5c8f222f7ad7869db1fe428a6f" translate="yes" xml:space="preserve">
          <source>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.)</source>
          <target state="translated">부울 유형의 표현식에 대한 의심스러운 조작에 대해 경고합니다. 예를 들어, 부울의 비트 단위 부정은 프로그램의 버그 일 가능성이 높습니다. C의 경우이 경고는 부울을 늘리거나 줄이는 것에 대해서도 경고합니다. (C ++에서는 부울을 감소시키는 것이 항상 유효하지 않습니다. C ++ 17에서는 부울을 증가시키는 것이 유효하지 않으며, 더 이상 사용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="2336eb6d6105fde77f9d067a2cdcc81228032540" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same:</source>
          <target state="translated">식에서 논리 연산자의 의심스러운 사용에 대해 경고합니다. 여기에는 비트 연산자가 예상되는 상황에서 논리 연산자를 사용하는 것이 포함됩니다. 논리 연산자의 피연산자가 동일한 경우에도 경고합니다.</target>
        </trans-unit>
        <trans-unit id="47cf408f4ecd083d50c4f6fada7dd8bdd9b93bb0" translate="yes" xml:space="preserve">
          <source>Warn about suspicious uses of memory addresses. These include using the address of a function in a conditional expression, such as &lt;code&gt;void func(void); if (func)&lt;/code&gt;, and comparisons against the memory address of a string literal, such as &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt;. Such uses typically indicate a programmer error: the address of a function always evaluates to true, so their use in a conditional usually indicate that the programmer forgot the parentheses in a function call; and comparisons against string literals result in unspecified behavior and are not portable in C, so they usually indicate that the programmer intended to use &lt;code&gt;strcmp&lt;/code&gt;. This warning is enabled by</source>
          <target state="translated">메모리 주소의 의심스러운 사용에 대해 경고합니다. 여기에는 &lt;code&gt;void func(void); if (func)&lt;/code&gt; 와 같은 조건식에서 함수의 주소 사용 ; if (func) 이고 문자열 리터럴의 메모리 주소와 비교 &lt;code&gt;if (x == &quot;abc&quot;)&lt;/code&gt; 예 : if (x == &quot;abc&quot;)) . 이러한 사용은 일반적으로 프로그래머의 오류를 나타냅니다. 함수의 주소는 항상 true로 평가되므로 조건부에서의 사용은 일반적으로 프로그래머가 함수 호출에서 괄호를 잊었 음을 나타냅니다. 문자열 리터럴과 비교하면 지정되지 않은 동작이 발생하고 C에서는 이식 할 수 없으므로 일반적으로 프로그래머가 &lt;code&gt;strcmp&lt;/code&gt; 를 사용하려고했음을 나타냅니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="693b5ffe72b40cbff2e2c2d99e95d2c139392a00" translate="yes" xml:space="preserve">
          <source>Warn about the use of an uncasted &lt;code&gt;NULL&lt;/code&gt; as sentinel. When compiling only with GCC this is a valid sentinel, as &lt;code&gt;NULL&lt;/code&gt; is defined to &lt;code&gt;__null&lt;/code&gt;. Although it is a null pointer constant rather than a null pointer, it is guaranteed to be of the same size as a pointer. But this use is not portable across different compilers.</source>
          <target state="translated">전송되지 않은 &lt;code&gt;NULL&lt;/code&gt; 을 센티넬로 사용하는 것에 대해 경고합니다 . GCC로만 컴파일 할 때 &lt;code&gt;NULL&lt;/code&gt; 은 &lt;code&gt;__null&lt;/code&gt; 로 정의 되므로 유효한 센티넬 입니다. 비록 그것이 널 포인터가 아닌 널 포인터 상수이지만, 포인터와 같은 크기를 보장합니다. 그러나이 사용은 다른 컴파일러에서 이식 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="047e09655cbc00205404926996b3c4d4165e9649" translate="yes" xml:space="preserve">
          <source>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">중첩 함수에 대한 포인터에 대해 생성 된 트램폴린에 대해 경고합니다. 트램폴린은 중첩 함수의 주소를 가져올 때 스택에서 런타임에 작성되는 작은 데이터 또는 코드 조각으로 중첩 함수를 간접적으로 호출하는 데 사용됩니다. 일부 대상의 경우 데이터로만 구성되므로 특별한 처리가 필요하지 않습니다. 그러나 대부분의 대상의 경우 코드로 구성되므로 프로그램이 제대로 작동하려면 스택을 실행 파일로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="038f9bc926635b6b8fb6c2afe2d9bffe1c8b0f31" translate="yes" xml:space="preserve">
          <source>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, declared in an anonymous namespace. This allows GCC to more aggressively devirtualize the polymorphic calls. This warning is more effective with link time optimization, where the information about the class hierarchy graph is more complete.</source>
          <target state="translated">유형이 C ++ 11 &lt;code&gt;final&lt;/code&gt; 지정자로 선언 된 경우 또는 가능한 경우 익명 네임 스페이스에서 선언 된 경우 코드 품질이 향상되는 가상 메소드가있는 유형에 대해 경고 합니다. 이를 통해 GCC는 다형성 통화를보다 적극적으로 활용할 수 있습니다. 이 경고는 클래스 계층 구조 그래프에 대한 정보가보다 완전한 링크 시간 최적화에서 더 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ebb96b1bde565bfb0748c8483dc57189a3190e4d" translate="yes" xml:space="preserve">
          <source>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the</source>
          <target state="translated">자체 초기화 된 초기화되지 않은 변수에 대해 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="3e4a4254c8cb8b052f1898488cd3d24c1bac24c2" translate="yes" xml:space="preserve">
          <source>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, or &lt;code&gt;while&lt;/code&gt;, in which only the first statement is actually guarded after the macro is expanded.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 과 같은 절에 의해 보호되는 것처럼 보이는 안전하지 않은 다중 명령문 매크로에 대해 경고 합니다. 여기서 매크로가 확장 된 후 첫 번째 명령문 만 실제로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="c815119ab8450282a6819d07553d786431d0bc98" translate="yes" xml:space="preserve">
          <source>Warn about violations of the following style guidelines from Scott Meyers&amp;rsquo; Effective C++ series of books:</source>
          <target state="translated">Scott Meyers의 Effective C ++ 시리즈 서적에서 다음 스타일 가이드 라인에 대한 위반에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="44cda8e3e380e8f31dd971fc6b0f31b237513dcc" translate="yes" xml:space="preserve">
          <source>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 &lt;code&gt;final&lt;/code&gt; specifier, or, if possible, its type were declared in an anonymous namespace or with the &lt;code&gt;final&lt;/code&gt; specifier. This warning is more effective with link-time optimization, where the information about the class hierarchy graph is more complete. It is recommended to first consider suggestions of</source>
          <target state="translated">방법은 C ++ (11)로 선언 된 코드의 품질이 향상 될 가상 메소드에 대해 경고 &lt;code&gt;final&lt;/code&gt; 지정하거나, 가능하다면, 해당 유형은 익명의 네임 스페이스 또는 선언 된 &lt;code&gt;final&lt;/code&gt; 지정. 이 경고는 클래스 계층 구조 그래프에 대한 정보가보다 완전한 링크 타임 최적화에서 더 효과적입니다. 의 제안을 먼저 고려하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="be3e052e75298edad5e44ae2d0677574dff86d7c" translate="yes" xml:space="preserve">
          <source>Warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">&lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; 및 &lt;code&gt;stpncpy&lt;/code&gt; 와 같은 바운딩 된 문자열 조작 함수에 대한 호출에 대해 경고 합니다. 복사 된 문자열을 자르거나 대상을 변경하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f52c63875e1d71f753bc97c51fe3992eac28f3" translate="yes" xml:space="preserve">
          <source>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling &lt;code&gt;abs(3.14)&lt;/code&gt; triggers the warning because the appropriate function to call to compute the absolute value of a double argument is &lt;code&gt;fabs&lt;/code&gt;. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by</source>
          <target state="translated">보다 적절한 표준 함수를 사용할 수있을 때 인수의 절대 값을 계산하는 표준 함수 호출에 대해 경고합니다. 예를 들어, &lt;code&gt;abs(3.14)&lt;/code&gt; 를 호출하면 double 인수의 절대 값을 계산하기 위해 호출하는 적절한 함수가 &lt;code&gt;fabs&lt;/code&gt; 이므로 경고가 트리거됩니다 . 이 함수는 또한 그러한 함수를 호출 할 때 인수에 부호없는 유형이있을 때 경고를 트리거합니다. 이 경고는 명시 적 유형 캐스트에서 억제 될 수 있으며</target>
        </trans-unit>
        <trans-unit id="c5733f483a0e2d12a12ef399d58192ff21069495" translate="yes" xml:space="preserve">
          <source>Warn for calls to string manipulation functions such as &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;strcpy&lt;/code&gt; that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like &lt;code&gt;memcpy&lt;/code&gt; which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like &lt;code&gt;__builtin_memcpy&lt;/code&gt; that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option will issue a warning for the &lt;code&gt;strcpy&lt;/code&gt; call below because it copies at least 5 characters (the string &lt;code&gt;&quot;blue&quot;&lt;/code&gt; including the terminating NUL) into the buffer of size 4.</source>
          <target state="translated">대상 버퍼가 오버플로 된 것으로 판단 되는 &lt;code&gt;memcpy&lt;/code&gt; 및 &lt;code&gt;strcpy&lt;/code&gt; 와 같은 문자열 조작 함수 호출에 대해 경고합니다 . 선택적 인수는 대상 크기를 결정하기 위해 수행 할 객체 크기 확인 유형보다 큰 것입니다. &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;객체 크기 확인을&lt;/a&gt; 참조하십시오 . 인수는 문자 배열에서 작동하는 함수에만 의미가 있지만 항상 Object Size type-0을 사용하는 &lt;code&gt;memcpy&lt;/code&gt; 와 같은 원시 메모리 함수에는 의미가 없습니다 . 이 옵션은 또한 가능한 가장 큰 객체를 초과하거나 최대 &lt;code&gt;SIZE_MAX / 2&lt;/code&gt; 크기를 지정하는 호출에 대해 경고합니다.바이트. 이 옵션을 사용하면 최적화를 통해 최상의 결과를 얻을 수 있지만 표준 함수에 해당하는 &lt;code&gt;__builtin_memcpy&lt;/code&gt; 와 같은 GCC 내장 함수를 호출하지 않아도 간단한 버퍼 오버플로의 작은 하위 집합을 감지 할 수 있습니다 . 어쨌든, 옵션은 해당 오버 플로우 검사 내장 기능에 의해 감지 된 버퍼 오버 플로우의 서브 세트에 대해서만 경고합니다. 예를 들어, 옵션은 최소 5 개의 문자 ( 종료 NUL을 포함하여 &lt;code&gt;&quot;blue&quot;&lt;/code&gt; 문자열 )를 크기가 4 인 버퍼에 복사하므로 아래 &lt;code&gt;strcpy&lt;/code&gt; 호출에 대해 경고를 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="ea89d9fe51cb214a220766e4af0abed7f830d316" translate="yes" xml:space="preserve">
          <source>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below.</source>
          <target state="translated">속성 추가가 도움이 될 수있는 경우 경고합니다. 현재 지원되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8436e41e82368d15262acc8884e5704ddb1ce7dc" translate="yes" xml:space="preserve">
          <source>Warn for conditionally-supported (C++11 [intro.defs]) constructs.</source>
          <target state="translated">조건부 지원 (C ++ 11 [intro.defs]) 구문에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ddd0db7c59c0ac572b0cd3ff62ca85c741d9e547" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like &lt;code&gt;abs (x)&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;; conversions between signed and unsigned, like &lt;code&gt;unsigned ui = -1&lt;/code&gt;; and conversions to smaller types, like &lt;code&gt;sqrtf (M_PI)&lt;/code&gt;. Do not warn for explicit casts like &lt;code&gt;abs
((int) x)&lt;/code&gt; and &lt;code&gt;ui = (unsigned) -1&lt;/code&gt;, or if the value is not changed by the conversion like in &lt;code&gt;abs (2.0)&lt;/code&gt;. Warnings about conversions between signed and unsigned integers can be disabled by using</source>
          <target state="translated">값을 변경할 수있는 암시 적 변환에 대해 경고합니다. 여기에는 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;double&lt;/code&gt; 일 때 &lt;code&gt;abs (x)&lt;/code&gt; 와 같이 실수와 정수 사이의 변환이 포함됩니다 . 부호없는 것과 같은 &lt;code&gt;unsigned ui = -1&lt;/code&gt; 것과 부호 없는 것 사이의 변환 ui = -1 ; &lt;code&gt;sqrtf (M_PI)&lt;/code&gt; 와 같은 더 작은 유형으로의 변환 . &lt;code&gt;abs ((int) x)&lt;/code&gt; 및 &lt;code&gt;ui = (unsigned) -1&lt;/code&gt; 과 같은 명시 적 캐스트 또는 &lt;code&gt;abs (2.0)&lt;/code&gt; 과 같은 변환에 의해 값이 변경되지 않은 경우에는 경고하지 마십시오 . 부호있는 정수와 부호없는 정수 사이의 변환에 대한 경고는 다음을 사용하여 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ec1638cbd7bdbbe5cf0d16d8253b596c446311e3" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by</source>
          <target state="translated">부호없는 정수 식을 부호없는 정수 변수에 할당하는 것과 같이 정수 값의 부호를 변경할 수있는 암시 적 변환에 대해 경고합니다. 명시 적 캐스트는 경고를 침묵시킵니다. C에서이 옵션은</target>
        </trans-unit>
        <trans-unit id="97be0057bd1773b0bcfe31a7fd58f64b07846102" translate="yes" xml:space="preserve">
          <source>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by</source>
          <target state="translated">실제 값의 정밀도를 낮추는 암시 적 변환에 대해 경고합니다. 여기에는 실수에서 정수로의 변환과 고정밀 실수에서 정밀도가 낮은 실수로의 변환이 포함됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="fba779234a6e85d8e28133f5b96c546a4b460be1" translate="yes" xml:space="preserve">
          <source>Warn for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">조작에 대해 유효하지 않거나 &lt;code&gt;memory_order&lt;/code&gt; 열거 의 값 범위를 벗어난 메모리 일관성 인수 로 &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; , &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt; 및 C11 원자 일반 함수 호출에 대해 경고합니다 . 예를 들어 &lt;code&gt;__atomic_store&lt;/code&gt; 및 &lt;code&gt;__atomic_store_n&lt;/code&gt; 내장 기능은 완화, 릴리스 및 순차적으로 일관된 메모리 순서에 대해서만 정의되므로 다음 코드가 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="588f265a9e502d85c1dc2042e355d13326591d0f" translate="yes" xml:space="preserve">
          <source>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like &lt;code&gt;static&lt;/code&gt; are not the first things in a declaration. This warning is also enabled by</source>
          <target state="translated">C 표준에 따라 선언에서 폐기 된 사용에 대해 경고합니다. 예를 들어 &lt;code&gt;static&lt;/code&gt; 과 같은 스토리지 클래스 지정 자가 선언의 첫 번째 항목이 아닌 경우 경고합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="e259b4649f2c39d620aa79263dfa4900b1e91328" translate="yes" xml:space="preserve">
          <source>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by</source>
          <target state="translated">포인터 인수가 전달되거나 서명이 다른 경우 경고합니다. 이 옵션은 C 및 Objective-C에서만 지원됩니다. 에 의해 암시</target>
        </trans-unit>
        <trans-unit id="9ff91ea12bc4958bf94b9d94062e90a35c47ff2b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function where the second argument is not zero and the third argument is zero. For example, the call &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; is diagnosed because &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by</source>
          <target state="translated">두 번째 인수가 0이 아니고 세 번째 인수가 0 인 &lt;code&gt;memset&lt;/code&gt; 내장 함수에 대한 의심스러운 호출에 대해 경고 합니다. 예를 들어, &lt;code&gt;memset (buf, 0, sizeof buf)&lt;/code&gt; 이 대신 사용 되었기 때문에 호출 &lt;code&gt;memset (buf, sizeof buf, 0)&lt;/code&gt; 이 진단 됩니다. 진단은 세 번째 인수가 리터럴 0 인 경우에만 발생합니다. 그렇지 않으면, 그것이 0으로 접힌식이거나 어떤 유형에 대한 0의 캐스트 인 경우, 인수가 실수로 바뀌고 경고가 발생하지 않을 가능성이 훨씬 적습니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="bc6dbae9a566682d74e9a96f0ac749b8042dc5bb" translate="yes" xml:space="preserve">
          <source>Warn for suspicious calls to the &lt;code&gt;memset&lt;/code&gt; built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by</source>
          <target state="translated">첫 번째 인수가 배열을 참조하고 세 번째 인수가 요소 수와 같지만 메모리의 배열 크기와 같지 않은 경우 &lt;code&gt;memset&lt;/code&gt; 내장 함수에 대한 의심스러운 호출에 대해 경고합니다 . 이는 사용자가 요소 크기의 곱셈을 생략했음을 나타냅니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="d71f136265b6596c9fcf21bacafb65164bba32b6" translate="yes" xml:space="preserve">
          <source>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won&amp;rsquo;t work out correctly with pointers. This warning warns e.g. about &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer. This warning is enabled by</source>
          <target state="translated">포인터 크기를 요소 크기로 나누는 두 가지 sizeof 표현식의 의심스러운 분할에 대해 경고합니다. 이는 배열 크기를 계산하는 일반적인 방법이지만 포인터로는 올바르게 작동하지 않습니다. 이 경고는 &lt;code&gt;ptr&lt;/code&gt; 이 배열이 아니라 포인터 인 경우 &lt;code&gt;sizeof (ptr) / sizeof (ptr[0])&lt;/code&gt; 에 대해 경고합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="eb46193b49397250439f9bab61fa46107f1cb89b" translate="yes" xml:space="preserve">
          <source>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses &lt;code&gt;sizeof&lt;/code&gt;. This warning triggers for example for &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; if &lt;code&gt;ptr&lt;/code&gt; is not an array, but a pointer, and suggests a possible fix, or about &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;sizeof&lt;/code&gt; 를 사용하는 경우 특정 문자열 및 메모리 내장 함수에 대한 의심스러운 길이 매개 변수에 대해 경고합니다 . 이 경고는 예를 들어 &lt;code&gt;memset (ptr, 0, sizeof (ptr));&lt;/code&gt; 대해 트리거됩니다 . 만약 &lt;code&gt;ptr&lt;/code&gt; 배열되지만 포인터되지 않고, 가능한 한 수정을 제시하거나 대한 &lt;code&gt;memcpy (&amp;amp;foo, ptr, sizeof (&amp;amp;foo));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="474691b4f69f5e3fa5e5d8572e94d30c04b806ca" translate="yes" xml:space="preserve">
          <source>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt;. Or left shifting of signed integers in boolean context, like &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt;. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by</source>
          <target state="translated">부울 컨텍스트에서 부울 정수가 아닌 상수를 사용하는 조건식 (? :)과 같이 부울 값이 예상되는 정수 값의 의심스러운 사용에 대해 경고 &lt;code&gt;if (a &amp;lt;= b ? 2 : 3)&lt;/code&gt; . 또는 &lt;code&gt;for (a = 0; 1 &amp;lt;&amp;lt; a; a++);&lt;/code&gt; 와 같이 부울 컨텍스트에서 부호있는 정수의 왼쪽 이동 . 데이터 유형에 관계없이 모든 종류의 곱셈에 대해서도 마찬가지입니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="ef3f0d67d9be730bb5bb60eec12cdf29a3590cd3" translate="yes" xml:space="preserve">
          <source>Warn for variables that might be changed by &lt;code&gt;longjmp&lt;/code&gt; or &lt;code&gt;vfork&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">&lt;code&gt;longjmp&lt;/code&gt; 또는 &lt;code&gt;vfork&lt;/code&gt; 에 의해 변경 될 수있는 변수에 대해 경고합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="dd2e7578a65337ecde9cfa288e81a35cf44426a6" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;long long&lt;/code&gt; type is used. This is enabled by either</source>
          <target state="translated">&lt;code&gt;long long&lt;/code&gt; type을 사용하는 경우 경고합니다 . 이것은 다음 중 하나에 의해 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="e19f1630667f871b7fea15d47a722bf79ecb0d1d" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, either explicitly in an &lt;code&gt;@interface&lt;/code&gt; or &lt;code&gt;@protocol&lt;/code&gt; declaration, or implicitly in an &lt;code&gt;@implementation&lt;/code&gt; section. This option always performs its checks as soon as a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression is found, while</source>
          <target state="translated">선언되지 않은 선택자를 참조 하는 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 식이 발견 되면 경고합니다 . &lt;code&gt;@interface&lt;/code&gt; 또는 &lt;code&gt;@protocol&lt;/code&gt; 선언 에서 명시 적으로 또는 &lt;code&gt;@implementation&lt;/code&gt; 섹션 에서 암시 적으로 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 식 앞에 해당 이름을 가진 메소드가 선언되지 않은 경우 선택기가 선언되지 않은 것으로 간주됩니다 . 이 옵션은 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 식이 발견 되는 즉시 항상 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="004d33c975e481dfebbcb509835b3167b8da9eba" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;goto&lt;/code&gt; statement or a &lt;code&gt;switch&lt;/code&gt; statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case.</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; 문 또는 &lt;code&gt;switch&lt;/code&gt; 문이 변수 초기화에서 앞으로 이동하거나 변수가 초기화 된 후 레이블로 뒤로 이동 하면 경고합니다 . 이것은 선언 될 때 초기화되는 변수에 대해서만 경고합니다. 이 경고는 C 및 Objective-C에만 지원됩니다. C ++에서 이런 종류의 분기는 어떤 경우에도 오류입니다.</target>
        </trans-unit>
        <trans-unit id="70a205e11ff52468e2abea9748f0e8471729efe0" translate="yes" xml:space="preserve">
          <source>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When</source>
          <target state="translated">내장 함수가 호환되지 않는 서명 또는 비 함수로 선언되었거나 프로토 타입을 포함하지 않는 유형으로 선언 된 내장 함수가 승격 된 유형이 예상 한 것과 일치하지 않는 인수와 함께 호출되는 경우 경고 함수. 언제</target>
        </trans-unit>
        <trans-unit id="7e0b0c17d1b6ef946e72a0839cb1ce3047e47301" translate="yes" xml:space="preserve">
          <source>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">클래스 유형에 기본 또는 필드가 익명 네임 스페이스를 사용하거나 링크가없는 유형에 의존하는 경우 경고합니다. 유형 A가 내부 연결이 없거나 유형 B 인 유형 B에 의존하는 경우, 여러 번역 단위로이를 정의하는 것은 각 번역 단위에서 B의 의미가 다르기 때문에 ODR 위반입니다. A가 단일 번역 단위에만 표시되는 경우 경고를 끄는 가장 좋은 방법은 익명 네임 스페이스에 넣어서 내부 연결을 제공하는 것입니다. 컴파일러는 주 .C 파일에 정의 된 유형에 대해 여러 가지 정의가 없을 가능성이 있으므로이 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f50d7f18228e548a744dc4a11054b6259740a50d" translate="yes" xml:space="preserve">
          <source>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt;. This warning is also enabled by</source>
          <target state="translated">제한된 범위의 데이터 유형으로 인해 비교가 항상 참 또는 항상 거짓 인 경우 경고하지만 상수 표현식에 대해서는 경고하지 않습니다. 예를 들어, 부호없는 변수가 0 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 과 비교되면 경고합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="2a11d0f858be1c6e9bc24aa3b844f38a2b441160" translate="yes" xml:space="preserve">
          <source>Warn if a declaration has duplicate &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; or &lt;code&gt;_Atomic&lt;/code&gt; specifier. This warning is enabled by</source>
          <target state="translated">선언이 중복 된 경우 경고 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restrict&lt;/code&gt; 또는 &lt;code&gt;_Atomic&lt;/code&gt; 의 지정. 이 경고는</target>
        </trans-unit>
        <trans-unit id="435844d61c42ac3708481fd4e2d3779e1e2c4fcb" translate="yes" xml:space="preserve">
          <source>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.)</source>
          <target state="translated">인수 유형을 지정하지 않고 함수가 선언되거나 정의 된 경우 경고합니다. (이전 스타일 함수 정의는 인수 유형을 지정하는 선언이 앞에 오는 경우 경고없이 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="a760172e23a18bb5477be698491bcdf520546606" translate="yes" xml:space="preserve">
          <source>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers.</source>
          <target state="translated">인라인으로 선언 된 함수를 인라인 할 수없는 경우 경고합니다. 이 옵션을 사용하더라도 컴파일러는 시스템 헤더에 선언 된 함수 인라인 실패에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8022445f9b194569635957ab8997ae493df541b3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use</source>
          <target state="translated">전역 함수가 사전 선언없이 정의 된 경우 경고합니다. 정의 자체가 프로토 타입을 제공하더라도 그렇게하십시오. 헤더 파일에 선언되지 않은 글로벌 함수를 감지하려면이 옵션을 사용하십시오. C에서는 이전의 비 프로토 타입 선언이있는 함수에 대해 경고가 발행되지 않습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="8accbb9b2caefa3a198b26af7aaf7ecef01e8cb3" translate="yes" xml:space="preserve">
          <source>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use</source>
          <target state="translated">이전 프로토 타입 선언없이 전역 함수가 정의 된 경우 경고합니다. 정의 자체가 프로토 타입을 제공하더라도이 경고가 발행됩니다. 헤더 파일에 일치하는 프로토 타입 선언이없는 글로벌 함수를 감지하려면이 옵션을 사용하십시오. 모든 함수 선언은 프로토 타입을 제공하고 일치하지 않는 선언은 이전 선언과 충돌하지 않고 오버로드를 선언하므로이 옵션은 C ++에 유효하지 않습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="158841ec1502166264ebd7700487b8265d3a7024" translate="yes" xml:space="preserve">
          <source>Warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">포인터가 0 문자 상수와 비교되면 경고합니다. 이것은 일반적으로 포인터가 역 참조되었음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc6737ba51245ef04a02acb681eeef00c75f1a8a" translate="yes" xml:space="preserve">
          <source>Warn if a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) is found in the search path but cannot be used.</source>
          <target state="translated">사전 컴파일 된 헤더 ( &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;사전 컴파일 된 헤더&lt;/a&gt; 참조 )가 검색 ​​경로에 있지만 사용할 수없는 경우 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="0939e5ffcf8a00c23be50c55ee10373ce78e992e" translate="yes" xml:space="preserve">
          <source>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion.</source>
          <target state="translated">프로토 타입이없는 경우 동일한 인수에서 발생하는 것과 다른 유형 변환이 프로토 타입을 유발하는 경우 경고합니다. 여기에는 고정 소수점에서 부동 소수점으로의 변환과 그 반대로의 변환과 기본 승격과 동일하지 않은 경우를 제외하고 고정 소수점 인수의 너비 또는 부호를 변경하는 변환이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f0026b1975a3aa571d75e5560f23067faee1ed8d" translate="yes" xml:space="preserve">
          <source>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by</source>
          <target state="translated">레지스터 변수가 휘발성으로 선언되면 경고합니다. 휘발성 수정자는 변수를 등록하기 위해 읽기 및 / 또는 쓰기를 제거 할 수있는 모든 최적화를 금지하지 않습니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="3798bc740d5ed1fe194f654e04bcdb3d1c47efb1" translate="yes" xml:space="preserve">
          <source>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC&amp;rsquo;s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time.</source>
          <target state="translated">요청 된 최적화 패스가 비활성화 된 경우 경고합니다. 이 경고는 일반적으로 코드에 문제가 있음을 나타내지 않습니다. 단지 GCC 최적화 프로그램이 코드를 효과적으로 처리 할 수 ​​없음을 나타냅니다. 종종 문제는 코드가 너무 크거나 복잡하다는 것입니다. GCC는 최적화 자체에 많은 시간이 걸리는 경우 프로그램 최적화를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="13c5db18900b8a64496f744ccfd5e2648bd6cc79" translate="yes" xml:space="preserve">
          <source>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as:</source>
          <target state="translated">자체 비교가 항상 참 또는 거짓으로 평가되면 경고합니다. 이 경고는 다음과 같은 다양한 실수를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="3ddcbce9d2796dc0f4331ea0e609fc2579e95907" translate="yes" xml:space="preserve">
          <source>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on &lt;code&gt;struct S&lt;/code&gt;, like, &lt;code&gt;warning: alignment 1 of
'struct S' is less than 8&lt;/code&gt;, in this code:</source>
          <target state="translated">묶음 구조체 또는 공용체에서 정렬이 명시 적으로 지정된 구조 필드가 잘못 정렬되면 경고합니다. 예를 들어, 경고가 발행됩니다 &lt;code&gt;struct S&lt;/code&gt; 처럼, &lt;code&gt;warning: alignment 1 of 'struct S' is less than 8&lt;/code&gt; 이 코드에서 :</target>
        </trans-unit>
        <trans-unit id="4090da0abd58db5d6b3c1df786fa78fbd44ccb0c" translate="yes" xml:space="preserve">
          <source>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable &lt;code&gt;f.x&lt;/code&gt; in &lt;code&gt;struct bar&lt;/code&gt; is misaligned even though &lt;code&gt;struct bar&lt;/code&gt; does not itself have the packed attribute:</source>
          <target state="translated">패킹 된 속성이 구조에 제공되지만 패킹 된 속성이 구조의 레이아웃이나 크기에 영향을 미치지 않는 경우 경고합니다. 이러한 구조는 거의 이익을 위해 잘못 정렬 될 수 있습니다. 예를 들어,이 코드에서 변수 &lt;code&gt;f.x&lt;/code&gt; 의 &lt;code&gt;struct bar&lt;/code&gt; 비록 잘못 정렬되는 &lt;code&gt;struct bar&lt;/code&gt; 자체가 포장 된 속성을 가지고 있지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="25445489d5b31008c73b432793637e0936c19aa4" translate="yes" xml:space="preserve">
          <source>Warn if a structure&amp;rsquo;s initializer has some fields missing. For example, the following code causes such a warning, because &lt;code&gt;x.h&lt;/code&gt; is implicitly zero:</source>
          <target state="translated">구조체의 이니셜 라이저에 일부 필드가없는 경우 경고합니다. 예를 들어, 다음 코드는 &lt;code&gt;x.h&lt;/code&gt; 가 암시 적으로 0 이므로 이러한 경고를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ff8391aca57a7124434de4ac423b8ea2b9835ac5" translate="yes" xml:space="preserve">
          <source>Warn if a user-supplied include directory does not exist.</source>
          <target state="translated">사용자 제공 포함 디렉토리가 존재하지 않으면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="3fc14a4903f34179ede0f1ca4ae1ec5c8d1b70b1" translate="yes" xml:space="preserve">
          <source>Warn if a variable-length array is used in the code.</source>
          <target state="translated">코드에 가변 길이 배열이 사용되면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="36f8e0d2c860d788d014b0fd6079fd78b6555ede" translate="yes" xml:space="preserve">
          <source>Warn if an &lt;code&gt;extern&lt;/code&gt; declaration is encountered within a function.</source>
          <target state="translated">함수 내에서 &lt;code&gt;extern&lt;/code&gt; 선언이 발생 하면 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="2a938c70ebc261d86f7b298216ca1b2a1c719c46" translate="yes" xml:space="preserve">
          <source>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for &lt;code&gt;a&lt;/code&gt; is not fully bracketed, but that for &lt;code&gt;b&lt;/code&gt; is fully bracketed. This warning is enabled by</source>
          <target state="translated">집계 또는 공용체 이니셜 라이저가 완전히 괄호로 묶이지 않은 경우 경고합니다. 다음 예에서의 초기화 &lt;code&gt;a&lt;/code&gt; 는 완전히 괄호되지 않지만위한 그 &lt;code&gt;b&lt;/code&gt; 를 완전히 괄호된다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="13b8026e8132cdf11c73019d5520d0d0def0ca31" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript has type &lt;code&gt;char&lt;/code&gt;. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by</source>
          <target state="translated">배열 첨자에 &lt;code&gt;char&lt;/code&gt; 유형이 있으면 경고합니다 . 프로그래머가 종종 일부 시스템에서이 유형이 서명 된 것을 잊어 버리기 때문에 이는 일반적인 오류 원인입니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="4eadd49680011e5fcccbd2afb576905c49ae4f6b" translate="yes" xml:space="preserve">
          <source>Warn if an automatic variable is used without first being initialized or if a variable may be clobbered by a &lt;code&gt;setjmp&lt;/code&gt; call. In C++, warn if a non-static reference or non-static &lt;code&gt;const&lt;/code&gt; member appears in a class without constructors.</source>
          <target state="translated">자동 변수가 먼저 초기화되지 않고 사용되거나 &lt;code&gt;setjmp&lt;/code&gt; 호출에 의해 변수가 클로버 될 수 있는지 경고합니다 . C ++에서는 비 정적 참조 또는 비 정적 &lt;code&gt;const&lt;/code&gt; 멤버가 생성자없이 클래스에 나타나는지 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="dc1ee512cf2decbbe83cea7bedf87603b46e0326" translate="yes" xml:space="preserve">
          <source>Warn if an empty body occurs in an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; or &lt;code&gt;do
while&lt;/code&gt; statement. This warning is also enabled by</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 에 &lt;code&gt;else&lt;/code&gt; 또는 &lt;code&gt;do while&lt;/code&gt; 문에 빈 바디가 있으면 경고합니다 . 이 경고는</target>
        </trans-unit>
        <trans-unit id="383fdc3973b7b5cc3531ea392827d8edfbd6eb85" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">부작용이 초기화 된 필드가 지정된 이니셜을 사용할 때 무시되는 경우 경고 (참조 &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;지정된 이니셜을&lt;/a&gt; ). 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf68e08c13104db975e1e1b5bfffcc9f671b2dc" translate="yes" xml:space="preserve">
          <source>Warn if an initialized field without side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;).</source>
          <target state="translated">부작용없이 초기화 필드가 지정된 이니셜을 사용할 때 무시되는 경우 경고 (참조 &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;지정된 이니셜을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d80a9ebeceb31bde1433b7b0306e206a1d5169eb" translate="yes" xml:space="preserve">
          <source>Warn if an old-style (C-style) cast to a non-void type is used within a C++ program. The new-style casts (&lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;, and &lt;code&gt;const_cast&lt;/code&gt;) are less vulnerable to unintended effects and much easier to search for.</source>
          <target state="translated">C ++ 프로그램 내에서 비어 있지 않은 유형으로 캐스트 된 이전 스타일 (C 스타일)이 사용 된 경우 경고합니다. 새로운 스타일의 캐스트 ( &lt;code&gt;dynamic_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , &lt;code&gt;reinterpret_cast&lt;/code&gt; 및 &lt;code&gt;const_cast&lt;/code&gt; )는 의도하지 않은 효과에 덜 취약하고 검색하기가 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c7f9169958964ae3bf708d5e9fc733f1b6f3d079" translate="yes" xml:space="preserve">
          <source>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype.</source>
          <target state="translated">구식 함수 정의가 사용되는지 경고합니다. 이전 프로토 타입이 있어도 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="da6e0c7f139a454bc8182dc0ec55a473f639305f" translate="yes" xml:space="preserve">
          <source>Warn if an undefined identifier is evaluated in an &lt;code&gt;#if&lt;/code&gt; directive. Such identifiers are replaced with zero.</source>
          <target state="translated">정의되지 않은 식별자가 &lt;code&gt;#if&lt;/code&gt; 지시문 에서 평가되면 경고합니다 . 이러한 식별자는 0으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ac1c57ed34616373c808e98ba1a7016be9451740" translate="yes" xml:space="preserve">
          <source>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.)</source>
          <target state="translated">구조체 나 공용체를 반환하는 함수가 정의되거나 호출되면 경고합니다. (배열을 반환 할 수있는 언어에서는 경고가 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="51dd1d087c6f2f3e06e53605399888ad9deb557f" translate="yes" xml:space="preserve">
          <source>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines.</source>
          <target state="translated">프로그램의 의미를 변경시킬 수있는 3 가지 그래프가 있으면 경고하십시오. 이스케이프 된 줄 바꿈을 형성하는 것을 제외하고는 주석 내의 3 부 경고에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ffcebae22b64bc0188075323e253a892fb2c53e" translate="yes" xml:space="preserve">
          <source>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing.</source>
          <target state="translated">여러 선언이 유효하고 아무것도 변경하지 않는 경우에도 동일한 범위에서 두 번 이상 선언 된 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="e116ff785f520c78cab89ec80c259fd9b971e9a1" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles are missing when using the</source>
          <target state="translated">사용시 피드백 프로파일이 누락 된 경우 경고</target>
        </trans-unit>
        <trans-unit id="159621fc69892b60a8932abc53e5e7077fd3432a" translate="yes" xml:space="preserve">
          <source>Warn if feedback profiles do not match when using the</source>
          <target state="translated">를 사용할 때 피드백 프로파일이 일치하지 않으면 경고</target>
        </trans-unit>
        <trans-unit id="4484a988d285daa67ba50d8d0068eac8b9c3b671" translate="yes" xml:space="preserve">
          <source>Warn if floating-point values are used in equality comparisons.</source>
          <target state="translated">부동 소수점 값이 동등 비교에 사용되면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5905365a7243693b281255e7cd734a616d419731" translate="yes" xml:space="preserve">
          <source>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</source>
          <target state="translated">반복 횟수가 일정한 루프에서 컴파일러는 하나 이상의 반복 중에 일부 명령문에서 정의되지 않은 동작을 감지하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="30ffd0486ea9b42613bc7458b80c284dea250c07" translate="yes" xml:space="preserve">
          <source>Warn if left shifting a negative value. This warning is enabled by</source>
          <target state="translated">음수 값을 왼쪽으로 이동하면 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="59ffb10f60449caf44bc018fb1547abe48a875a4" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods of different types for the same selector are found during compilation. The check is performed on the list of methods in the final stage of compilation. Additionally, a check is performed for each selector appearing in a &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; expression, and a corresponding method for that selector has been found during compilation. Because these checks scan the method table only at the end of compilation, these warnings are not produced if the final stage of compilation is not reached, for example because an error is found during compilation, or because the</source>
          <target state="translated">컴파일하는 동안 동일한 선택기에 대해 다른 유형의 여러 메소드가 발견되면 경고합니다. 검사는 컴파일의 마지막 단계에서 메소드 목록에서 수행됩니다. 또한 &lt;code&gt;@selector(&amp;hellip;)&lt;/code&gt; 식에 나타나는 각 선택기에 대해 검사가 수행 되고 컴파일 중에 해당 선택기에 대한 해당 방법이 발견되었습니다. 이러한 검사는 컴파일 종료시에만 메소드 테이블을 스캔하므로 컴파일 중 오류가 발생했거나 컴파일 중 오류가 발생하여 컴파일의 최종 단계에 도달하지 않으면 이러한 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd90c2f7bb5d921c657a205bebfbd186d1fe38a6" translate="yes" xml:space="preserve">
          <source>Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt;. When this flag is off (which is the default behavior), the compiler omits such warnings if any differences found are confined to types that share the same size and alignment.</source>
          <target state="translated">이 선택자를 사용하여 &lt;code&gt;id&lt;/code&gt; 또는 &lt;code&gt;Class&lt;/code&gt; 유형의 수신자에게 메시지를 보내려고 할 때 주어진 선택기에 대해 다른 인수 및 / 또는 리턴 유형을 가진 여러 메소드가 발견되면 경고합니다 . 이 플래그가 꺼져 있으면 (기본 동작), 발견 된 차이점이 동일한 크기와 정렬을 공유하는 유형으로 제한되는 경우 컴파일러는 이러한 경고를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="b4a4ef5836fcd4eb9eae356fd7d365383ac64fa2" translate="yes" xml:space="preserve">
          <source>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller.</source>
          <target state="translated">패딩이 구조에 포함 된 경우 구조의 요소를 정렬하거나 전체 구조를 정렬하도록 경고합니다. 때때로 이런 일이 발생하면 패딩을 줄이고 구조를 더 작게 만들기 위해 구조의 필드를 재 배열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd9ef45fbb8d72f1831fd326b4e220df7e2faf4b" translate="yes" xml:space="preserve">
          <source>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about.</source>
          <target state="translated">특정 값에서 괄호가 생략 된 경우 (예 : 진실 값이 필요한 컨텍스트에 지정이 있거나 사람들이 종종 혼동되는 우선 순위가있는 연산자가 중첩 된 경우)</target>
        </trans-unit>
        <trans-unit id="3dceb1e23a828c2f0ba0a906a334b86bd9449ace" translate="yes" xml:space="preserve">
          <source>Warn if shift count &amp;gt;= width of type. This warning is enabled by default.</source>
          <target state="translated">shift count&amp;gt; = type 폭인 경우 경고합니다. 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="782b64d027fe58cf65d8d3d5a2401f820f146ca7" translate="yes" xml:space="preserve">
          <source>Warn if shift count is negative. This warning is enabled by default.</source>
          <target state="translated">시프트 횟수가 음수이면 경고합니다. 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c75b9200e1a12aae1dc4d040bec33d9a26d867e" translate="yes" xml:space="preserve">
          <source>Warn if the C++17 feature making &lt;code&gt;noexcept&lt;/code&gt; part of a function type changes the mangled name of a symbol relative to C++14. Enabled by</source>
          <target state="translated">함수 유형의 일부를 &lt;code&gt;noexcept&lt;/code&gt; 시키는 C ++ 17 기능 이 C ++ 14를 기준으로 심볼의 맹 글링 된 이름을 변경하면 경고합니다 . 에 의해 활성화</target>
        </trans-unit>
        <trans-unit id="46702f45847b2104b177e9b694f3c3f7e2226105" translate="yes" xml:space="preserve">
          <source>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.</source>
          <target state="translated">ISR의 철자가 틀리면 (예 : __vector 접두사가없는 경우) 경고합니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33d88165f92bdb2b45ff7a297ce9db7215dfa02b" translate="yes" xml:space="preserve">
          <source>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when</source>
          <target state="translated">컴파일러에서 null 포인터의 역 참조로 인해 잘못되었거나 정의되지 않은 동작을 트리거하는 경로를 감지하면 경고합니다. 이 옵션은 다음과 같은 경우에만 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="201bd84a1d08c6c2787e78691ed2f3f92ff20d03" translate="yes" xml:space="preserve">
          <source>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With</source>
          <target state="translated">컴파일러가 루프 인덱스의 경계에서 아무것도 가정 할 수 없으므로 루프를 최적화 할 수없는 경우 경고합니다. 와</target>
        </trans-unit>
        <trans-unit id="6ce9dcfeb56e93b36f3824efcafb3fac2f89db30" translate="yes" xml:space="preserve">
          <source>Warn if the return type of a function has a type qualifier such as &lt;code&gt;const&lt;/code&gt;. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or &lt;code&gt;void&lt;/code&gt;. ISO C prohibits qualified &lt;code&gt;void&lt;/code&gt; return types on function definitions, so such return types always receive a warning even without this option.</source>
          <target state="translated">함수의 반환 형식에 &lt;code&gt;const&lt;/code&gt; 와 같은 형식 한정자가 있으면 경고합니다 . ISO C의 경우 함수에서 반환 한 값이 lvalue가 아니기 때문에 이러한 형식 한정자가 적용되지 않습니다. C ++의 경우 경고는 스칼라 유형 또는 &lt;code&gt;void&lt;/code&gt; 에 대해서만 생성 됩니다 . ISO C 는 함수 정의에서 규정 된 &lt;code&gt;void&lt;/code&gt; 리턴 유형을 금지 하므로 이러한 리턴 유형은이 옵션 없이도 항상 경고를받습니다.</target>
        </trans-unit>
        <trans-unit id="84e834ec069e09da87cddcf3972bf0a3064670e4" translate="yes" xml:space="preserve">
          <source>Warn if the size of a function frame exceeds &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than &lt;var&gt;byte-size&lt;/var&gt; even if you do not get a warning. In addition, any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">함수 프레임의 크기가 &lt;var&gt;byte-size&lt;/var&gt; 를 초과하면 경고합니다 . 스택 프레임 크기를 결정하기 위해 수행 된 계산은 근사치이며 보수적이지 않습니다. 경고가 표시되지 않더라도 실제 요구 사항은 &lt;var&gt;byte-size&lt;/var&gt; 보다 다소 클 수 있습니다 . 또한 &lt;code&gt;alloca&lt;/code&gt; , 가변 길이 배열 또는 관련 구문을 통해 할당 된 공간 은 경고를 발행할지 여부를 결정할 때 컴파일러에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b03e969a133a7f61dfd42668c90fbd199dc871d" translate="yes" xml:space="preserve">
          <source>Warn if the stack usage of a function might exceed &lt;var&gt;byte-size&lt;/var&gt;. The computation done to determine the stack usage is conservative. Any space allocated via &lt;code&gt;alloca&lt;/code&gt;, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning.</source>
          <target state="translated">함수의 스택 사용량이 &lt;var&gt;byte-size&lt;/var&gt; 를 초과 할 경우 경고합니다 . 스택 사용량을 결정하기 위해 수행 된 계산은 보수적입니다. &lt;code&gt;alloca&lt;/code&gt; , 가변 길이 배열 또는 관련 구문을 통해 할당 된 공간 은 경고를 발행할지 여부를 결정할 때 컴파일러에 의해 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="949e7c4b1e5fd9dd73b3df3e4dd44a3a50fb46cc" translate="yes" xml:space="preserve">
          <source>Warn if the type of &lt;code&gt;main&lt;/code&gt; is suspicious. &lt;code&gt;main&lt;/code&gt; should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 유형 이 의심스러운 경우 경고합니다 . &lt;code&gt;main&lt;/code&gt; 은 외부 링크가있는 함수이어야하며 int를 반환하며 적절한 유형의 인수 0, 2 또는 3 인수를 취합니다. 이 경고는 C ++에서 기본적으로 활성화되며 다음 중 하나에 의해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6da28b5dec8555c7e8c577e4ad18fb400e3b7e57" translate="yes" xml:space="preserve">
          <source>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The</source>
          <target state="translated">벡터 라이저 비용 모델이 사용자가 설정 한 OpenMP simd 지시문을 재정의하는 경우 경고합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="cd147a815b47d8a61a481259e6bec92f6328c4b1" translate="yes" xml:space="preserve">
          <source>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either</source>
          <target state="translated">variadic 매크로가 ISO C90 모드에서 사용되는지 또는 GNU 대체 구문이 ISO C99 모드에서 사용되는지 경고합니다. 이것은 다음 중 하나에 의해 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="55d977b102dea3867bcd6836e9a2eac79a9f6018" translate="yes" xml:space="preserve">
          <source>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented &lt;code&gt;piecewise&lt;/code&gt;, which means that the scalar operation is performed on every vector element; &lt;code&gt;in parallel&lt;/code&gt;, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and &lt;code&gt;as a single scalar&lt;/code&gt;, which means that vector fits into a scalar type.</source>
          <target state="translated">아키텍처의 SIMD 기능을 통해 벡터 작업이 구현되지 않은 경우 경고합니다. 주로 성능 조정에 유용합니다. 벡터 연산은 &lt;code&gt;piecewise&lt;/code&gt; 으로 구현 될 수 있으며 , 이는 스칼라 연산이 모든 벡터 요소에 대해 수행됨을 의미합니다. &lt;code&gt;in parallel&lt;/code&gt; , 이는 벡터 연산이 더 넓은 유형의 스칼라를 사용하여 구현됨을 의미하며, 이는 일반적으로 성능이 더 효율적입니다. 및 &lt;code&gt;as a single scalar&lt;/code&gt; 스칼라 형으로 끼워 해당 벡터를 의미한다.</target>
        </trans-unit>
        <trans-unit id="d552f4c46cc5d3bd7e299e5496e695efcda3d372" translate="yes" xml:space="preserve">
          <source>Warn on uses of the &lt;code&gt;register&lt;/code&gt; storage class specifier, except when it is part of the GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; extension. The use of the &lt;code&gt;register&lt;/code&gt; keyword as storage class specifier has been deprecated in C++11 and removed in C++17. Enabled by default with</source>
          <target state="translated">GNU &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수&lt;/a&gt; 확장의 일부인 경우를 제외하고 &lt;code&gt;register&lt;/code&gt; 스토리지 클래스 지정자 의 사용에 대해 경고 합니다. 의 용도 &lt;code&gt;register&lt;/code&gt; 스토리지 클래스 지정자 키워드 11 C ++에서 사용되지 않는 C ++ 17에서 제거되었다. 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="77c0caa2b84a54b5bcf764add54f563ae56b7071" translate="yes" xml:space="preserve">
          <source>Warn that the implicit declaration of a copy constructor or copy assignment operator is deprecated if the class has a user-provided copy constructor or copy assignment operator, in C++11 and up. This warning is enabled by</source>
          <target state="translated">클래스에 C ++ 11 이상에서 사용자 제공 복사 생성자 또는 복사 할당 연산자가있는 경우 복사 생성자 또는 복사 할당 연산자의 암시 적 선언은 더 이상 사용되지 않습니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="4d2e76892f19022181f5882885c8f72e1722da44" translate="yes" xml:space="preserve">
          <source>Warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. This is default. To inhibit the warning messages, use</source>
          <target state="translated">&lt;code&gt;va_start&lt;/code&gt; 와 같은 변수 인수를 처리하는 데 사용되는 매크로의 의심스러운 사용법에 대해 경고합니다 . 이것이 기본값입니다. 경고 메시지를 표시하지 않으려면</target>
        </trans-unit>
        <trans-unit id="3abec5289cdc959e5a13fe23b53843308a01da72" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; and &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; built-in functions are used. These functions changed semantics in GCC 4.4.</source>
          <target state="translated">&lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; 및 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 내장 함수가 사용될 때 경고 합니다. 이러한 기능은 GCC 4.4에서 의미를 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="2aa9b92f65cbea3024eccc7e04605b70f951ef46" translate="yes" xml:space="preserve">
          <source>Warn when &lt;code&gt;delete&lt;/code&gt; is used to destroy an instance of a class that has virtual functions and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer to a base class if the base class does not have a virtual destructor. This warning is enabled by</source>
          <target state="translated">가상 함수와 비 가상적 소멸자가있는 클래스의 인스턴스를 &lt;code&gt;delete&lt;/code&gt; 하기 위해 delete 를 사용할 때 경고 합니다. 기본 클래스에 가상 소멸자가없는 경우 기본 클래스에 대한 포인터를 통해 파생 클래스의 인스턴스를 삭제하는 것은 안전하지 않습니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="f21bdb487f01146075a954516a5aced86463b3d2" translate="yes" xml:space="preserve">
          <source>Warn when G++ it generates code that is probably not compatible with the vendor-neutral C++ ABI. Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">G ++가 벤더 중립적 C ++ ABI와 호환되지 않는 코드를 생성 할 때 경고합니다. G ++는 기본적으로 각 주요 릴리스로 ABI를 업데이트하도록 기본 설정되어 있으므로</target>
        </trans-unit>
        <trans-unit id="35e0de5085f6b803ca5c49ba47e5ebe4c1616823" translate="yes" xml:space="preserve">
          <source>Warn when a &lt;code&gt;#pragma&lt;/code&gt; directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the</source>
          <target state="translated">GCC에서 이해할 수없는 &lt;code&gt;#pragma&lt;/code&gt; 지시문이 발견 되면 경고 합니다. 이 명령 행 옵션을 사용하면 시스템 헤더 파일에서 알 수없는 pragma에 대해 경고가 발행됩니다. 경고를 사용하여 경고를 활성화 한 경우에는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62d4dab62f762a61b2f522842ea9ed134dd06936" translate="yes" xml:space="preserve">
          <source>Warn when a class has virtual functions and an accessible non-virtual destructor itself or in an accessible polymorphic base class, in which case it is possible but unsafe to delete an instance of a derived class through a pointer to the class itself or base class. This warning is automatically enabled if</source>
          <target state="translated">클래스에 가상 함수와 액세스 가능한 비가 상 소멸자 자체 또는 액세스 가능한 다형성 기본 클래스가있는 경우 경고합니다.이 경우 클래스 자체 또는 기본 클래스에 대한 포인터를 통해 파생 클래스의 인스턴스를 삭제할 수는 있지만 안전하지 않습니다. 이 경고는 다음과 같은 경우 자동으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="2cb7e95f48120a523e19a1fdc36b0b8e1ca72f8b" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use virtual inheritance.</source>
          <target state="translated">클래스가 가상 직접 기본 클래스로 정의되면 경고합니다. 일부 코딩 규칙은 다중 상속을 허용하지 않으며이 규칙을 적용하는 데 사용될 수 있습니다. STL과 같은 시스템 헤더 파일 내에서 경고가 비활성화되어 있으므로 여전히 STL을 사용할 수 있습니다. 가상 상속을 간접적으로 사용하는 클래스를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="856d4cae226810333db6e35bc2ec148c4f408659" translate="yes" xml:space="preserve">
          <source>Warn when a class is defined with multiple direct base classes. Some coding rules disallow multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also define classes that indirectly use multiple inheritance.</source>
          <target state="translated">클래스가 여러 개의 직접 기본 클래스로 정의 된 경우 경고합니다. 일부 코딩 규칙은 다중 상속을 허용하지 않으며이 규칙을 적용하는 데 사용될 수 있습니다. STL과 같은 시스템 헤더 파일 내에서 경고가 비활성화되어 있으므로 여전히 STL을 사용할 수 있습니다. 다중 상속을 간접적으로 사용하는 클래스를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d55cbfe764766f5f6f7218d2c7a740a50c90ce" translate="yes" xml:space="preserve">
          <source>Warn when a class seems unusable because all the constructors or destructors in that class are private, and it has neither friends nor public static member functions. Also warn if there are no non-private methods, and there&amp;rsquo;s at least one private member function that isn&amp;rsquo;t a constructor or destructor.</source>
          <target state="translated">해당 클래스의 모든 생성자 또는 소멸자가 비공개이며 친구 나 공개 정적 멤버 함수가 없기 때문에 클래스를 사용할 수없는 경우 경고합니다. 또한 비 개인 메서드가없고 생성자 또는 소멸자가 아닌 개인 멤버 함수가 하나 이상 있는지 경고합니다.</target>
        </trans-unit>
        <trans-unit id="3da6bed540b8c798c01ac10e6f991d33a93d7840" translate="yes" xml:space="preserve">
          <source>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by</source>
          <target state="translated">부호있는 값을 부호없는 것으로 변환 할 때 부호있는 값과 부호없는 값을 비교할 때 잘못된 결과가 생성 될 수있을 때 경고합니다. C ++에서이 경고는</target>
        </trans-unit>
        <trans-unit id="d0d230a7b94f00a257ce101a92be2d7094f8073f" translate="yes" xml:space="preserve">
          <source>Warn when a declaration does not specify a type. This warning is enabled by</source>
          <target state="translated">선언이 유형을 지정하지 않을 때 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="65d83d710bdf5c622a92b858d79d70755ab8010e" translate="yes" xml:space="preserve">
          <source>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;Mixed Declarations&lt;/a&gt;.</source>
          <target state="translated">블록의 명령문 이후에 선언이 발견되면 경고합니다. C ++에서 알려진이 구성은 ISO C99에서 도입되었으며 기본적으로 GCC에서 허용됩니다. ISO C90에서 지원되지 않습니다. &lt;a href=&quot;mixed-declarations#Mixed-Declarations&quot;&gt;혼합 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a51fcbd164dc3089b47299b1d3b6f2732c7c6fcc" translate="yes" xml:space="preserve">
          <source>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the</source>
          <target state="translated">함수 선언에 관련 함수가 선언되고 생성 된 코드의 정확성 또는 효율성에 부정적인 영향을 줄 수있는 하나 이상의 속성이 누락 된 경우 경고합니다. 예를 들어, 속성을 사용하여 대상의 요구 사항보다 덜 제한적인 요구 사항을 지정하는 별명 선언에 대해 경고가 발행됩니다. 이는 일반적으로 잠재적 인 최적화 기회를 나타냅니다. 대조적으로</target>
        </trans-unit>
        <trans-unit id="4f18983de88b8950abf6205674919e5d25d36a1f" translate="yes" xml:space="preserve">
          <source>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type.</source>
          <target state="translated">함수 호출이 일치하지 않는 유형으로 캐스트 될 때 경고합니다. 예를 들어, 정수 유형을 리턴하는 함수에 대한 호출이 포인터 유형으로 캐스트되는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="1fee5efa47b570695ab661666c6e4fee9e9b04a8" translate="yes" xml:space="preserve">
          <source>Warn when a function declaration hides virtual functions from a base class. For example, in:</source>
          <target state="translated">함수 선언이 기본 클래스에서 가상 함수를 숨길 때 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0dab17ca245164b1ca8348967e2bf698b2a4654" translate="yes" xml:space="preserve">
          <source>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like &lt;code&gt;int&lt;/code&gt; vs. &lt;code&gt;long&lt;/code&gt; on ILP32 targets. Likewise type qualifiers are ignored. The function type &lt;code&gt;void (*) (void)&lt;/code&gt; is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by</source>
          <target state="translated">함수 포인터가 호환되지 않는 함수 포인터로 캐스트 될 때 경고합니다. 가변 인수 목록이있는 함수 유형과 관련된 캐스트에서는 제공된 초기 인수 유형 만 고려됩니다. 포인터 유형의 모든 매개 변수는 다른 포인터 유형과 일치합니다. 정수 유형의 모든 양성 차이는 ILP32 대상의 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;long&lt;/code&gt; 과 같이 무시 됩니다. 마찬가지로 형식 한정자가 무시됩니다. 함수 유형 &lt;code&gt;void (*) (void)&lt;/code&gt; 는 특별하며 모든 것을 일치시킵니다.이 경고를 억제하는 데 사용할 수 있습니다. 멤버 유형에 대한 포인터가 포함 된 캐스트에서 유형 캐스트가 포인터를 멤버 유형으로 변경할 때마다이 경고가 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="1c95c86068b8b8d1d8a72bc94ef016e54d5ce483" translate="yes" xml:space="preserve">
          <source>Warn when a literal &amp;lsquo;</source>
          <target state="translated">문자 그대로 '</target>
        </trans-unit>
        <trans-unit id="fc5d5783ac1277dfc41a8a050b298452017de063" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to</source>
          <target state="translated">지역 변수가 유형이 그림자 변수와 호환되는 다른 지역 변수 또는 매개 변수를 음영 처리 할 때 경고합니다. C ++에서 유형 호환성은 음영 변수의 유형을 음영 변수의 유형으로 변환 할 수 있음을 의미합니다. 이 플래그의 생성</target>
        </trans-unit>
        <trans-unit id="15ad15a27db9c39d53d6f814ef18cd0f426f15bd" translate="yes" xml:space="preserve">
          <source>Warn when a local variable shadows another local variable or parameter. This warning is enabled by</source>
          <target state="translated">지역 변수가 다른 지역 변수 나 매개 변수를 가리면 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="7332bfdf0522cbf64f5e187ed28df9e9bbf190d7" translate="yes" xml:space="preserve">
          <source>Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also use using directives and qualified names.</source>
          <target state="translated">네임 스페이스 정의가 열릴 때 경고합니다. 일부 코딩 규칙은 네임 스페이스를 허용하지 않으며이 규칙을 적용하는 데 사용될 수 있습니다. STL과 같은 시스템 헤더 파일 내에서 경고가 비활성화되어 있으므로 여전히 STL을 사용할 수 있습니다. 지시어와 정규화 된 이름을 사용하여 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c68af853608801bfccea4375c872dd95f8c2c74" translate="yes" xml:space="preserve">
          <source>Warn when a noexcept-expression evaluates to false because of a call to a function that does not have a non-throwing exception specification (i.e. &lt;code&gt;throw()&lt;/code&gt; or &lt;code&gt;noexcept&lt;/code&gt;) but is known by the compiler to never throw an exception.</source>
          <target state="translated">던지지 않는 예외 스펙이없는 함수 (예 : &lt;code&gt;throw()&lt;/code&gt; 또는 &lt;code&gt;noexcept&lt;/code&gt; ) 에 대한 호출로 인해 noexcept-expression이 false로 평가 될 때 경고 하지만 컴파일러는 예외를 발생시키지 않는 것으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="64beb2070ebf4a8be0aefd1a955c78bef9d98677" translate="yes" xml:space="preserve">
          <source>Warn when a primary template declaration is encountered. Some coding rules disallow templates, and this may be used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so one can still use the STL. One may also instantiate or specialize templates.</source>
          <target state="translated">기본 템플릿 선언이 발생하면 경고합니다. 일부 코딩 규칙은 템플릿을 허용하지 않으며이 규칙을 적용하는 데 사용될 수 있습니다. STL과 같은 시스템 헤더 파일 내에서 경고가 비활성화되어 있으므로 여전히 STL을 사용할 수 있습니다. 템플릿을 인스턴스화하거나 특수화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecfd63f7bf76274a278010015f443553fb311275" translate="yes" xml:space="preserve">
          <source>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">문자열 또는 문자 리터럴 뒤에 밑줄로 시작하지 않는 ud- 접미사가 붙을 때 경고합니다. 적합한 확장으로서 GCC는 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 의 형식 매크로를 사용하는 코드와의 호환성을 유지하기 위해 이러한 접미사를 별도의 전처리 토큰으로 취급합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af55e43f2240ead9470434a0686aeb1f0a48afd9" translate="yes" xml:space="preserve">
          <source>Warn when a switch case falls through. For example:</source>
          <target state="translated">스위치 케이스가 넘어지면 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fae5e5411e11c5c48526329b8f085ab67410eafc" translate="yes" xml:space="preserve">
          <source>Warn when a type with an ABI tag is used in a context that does not have that ABI tag. See &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt; for more information about ABI tags.</source>
          <target state="translated">ABI 태그가없는 컨텍스트에서 ABI 태그가있는 유형을 사용하는 경우 경고합니다. 참조 &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C ++ 속성&lt;/a&gt; ABI 태그에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="b81088e3c7de4ba5e43b90938614126c8743c79a" translate="yes" xml:space="preserve">
          <source>Warn when a typedef locally defined in a function is not used. This warning is enabled by</source>
          <target state="translated">함수에 로컬로 정의 된 typedef가 사용되지 않을 때 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="7f92b37eeb1fc74d56bfb3de4e40a33e9756c1f8" translate="yes" xml:space="preserve">
          <source>Warn when an attribute is ignored. This is different from the</source>
          <target state="translated">속성이 무시 될 때 경고합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="69d8172c43b83e36a9fc251e2742504cc5f07f18" translate="yes" xml:space="preserve">
          <source>Warn when an expression is casted to its own type.</source>
          <target state="translated">표현식이 자체 유형으로 캐스트 될 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="68276b3f14c999ac5fd8362dd7f4c1eb0d25507e" translate="yes" xml:space="preserve">
          <source>Warn when an if-else has identical branches. This warning detects cases like</source>
          <target state="translated">if-else가 동일한 브랜치를 가질 때 경고합니다. 이 경고는 다음과 같은 경우를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="4eaddac0ef918127a66832ad98be3ebdfc801bcd" translate="yes" xml:space="preserve">
          <source>Warn when an object referenced by a &lt;code&gt;restrict&lt;/code&gt;-qualified parameter (or, in C++, a &lt;code&gt;__restrict&lt;/code&gt;-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the &lt;code&gt;strcpy&lt;/code&gt; function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into &lt;code&gt;a[4]&lt;/code&gt;, the copies overlap and the call is diagnosed.</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; -qualified 매개 변수 (또는 C ++에서는 &lt;code&gt;__restrict&lt;/code&gt; -qualified 매개 변수)가 참조하는 개체 가 다른 인수에 의해 별칭이 지정되거나 이러한 개체 간의 복사본이 겹칠 때 경고 합니다. 예를 들어 아래 &lt;code&gt;strcpy&lt;/code&gt; 함수를 호출하면 초기 문자를 마지막 4 자로 바꾸어 문자열을 자릅니다. 그러나 호출은 종료 NUL을 &lt;code&gt;a[4]&lt;/code&gt; 쓰므로 사본이 겹치며 호출이 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="48e014515a7db6fc79ef0eeec4d6a1ef40fdd1b6" translate="yes" xml:space="preserve">
          <source>Warn when comparing an argument marked with the &lt;code&gt;nonnull&lt;/code&gt; function attribute against null inside the function.</source>
          <target state="translated">&lt;code&gt;nonnull&lt;/code&gt; 이 아닌 함수 속성으로 표시된 인수를 함수 내부의 널 과 비교할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="448f3542d0488bfdc3c401daf34114424d62966e" translate="yes" xml:space="preserve">
          <source>Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">불완전한 유형에 대한 포인터를 삭제할 때 경고하여 런타임시 정의되지 않은 동작이 발생할 수 있습니다. 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aead77201e88b8231585b494878f47ece446b42" translate="yes" xml:space="preserve">
          <source>Warn when macros &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt; or &lt;code&gt;__TIMESTAMP__&lt;/code&gt; are encountered as they might prevent bit-wise-identical reproducible compilations.</source>
          <target state="translated">매크로 &lt;code&gt;__TIME__&lt;/code&gt; , &lt;code&gt;__DATE__&lt;/code&gt; 또는 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; 이 발견되면 비트 단위의 동일하게 재현 가능한 컴파일을 방해 할 수 있으므로 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="f416313a5d687fda4c349efcccdbcd43185983e0" translate="yes" xml:space="preserve">
          <source>Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size. Previous versions of G++ tried to preserve unsignedness, but the standard mandates the current behavior.</source>
          <target state="translated">과부하 해결이 동일한 크기의 부호없는 유형으로 변환 할 때 부호없는 또는 열거 된 유형에서 부호있는 유형으로 승격을 선택할 때 경고합니다. 이전 버전의 G ++에서는 서명을 유지하려고했지만 표준은 현재 동작을 위임합니다.</target>
        </trans-unit>
        <trans-unit id="6b26cc3f03f85ab2638c4cf2001a077d93732070" translate="yes" xml:space="preserve">
          <source>Warn when the &amp;lsquo;</source>
          <target state="translated">때 '경고</target>
        </trans-unit>
        <trans-unit id="8090e980ff3867e87fe893e55e71d464e21173ec" translate="yes" xml:space="preserve">
          <source>Warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 연산자가 함수 정의에서 배열로 선언 된 매개 변수에 적용될 때 경고 합니다. 이 경고는 C 및 C ++ 프로그램에 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e36c088ae2b71459782ca704065537e9a26901f" translate="yes" xml:space="preserve">
          <source>Warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">압축 된 구조체 또는 공용체 멤버 주소를 가져 오면 경고가 발생하며 일반적으로 포인터 값이 정렬되지 않습니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f87649fa1908434c721b9cad02a2282152635b" translate="yes" xml:space="preserve">
          <source>Warn when the destination of a call to a raw memory function such as &lt;code&gt;memset&lt;/code&gt; or &lt;code&gt;memcpy&lt;/code&gt; is an object of class type, and when writing into such an object might bypass the class non-trivial or deleted constructor or copy assignment, violate const-correctness or encapsulation, or corrupt virtual table pointers. Modifying the representation of such objects may violate invariants maintained by member functions of the class. For example, the call to &lt;code&gt;memset&lt;/code&gt; below is undefined because it modifies a non-trivial class object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of objects of such types is by using the appropriate constructor or assignment operator, if one is available.</source>
          <target state="translated">&lt;code&gt;memset&lt;/code&gt; 또는 &lt;code&gt;memcpy&lt;/code&gt; 와 같은 원시 메모리 함수에 대한 호출 대상이 클래스 유형의 오브젝트 일 때 경고하며, 이러한 오브젝트에 쓰면 클래스가 사소하지 않거나 삭제 된 생성자 또는 복사 지정을 우회하여 const-correctness 또는 캡슐화 또는 손상된 가상 테이블 포인터 그러한 객체의 표현을 수정하면 클래스의 멤버 함수에 의해 유지되는 불변을 위반할 수 있습니다. 예를 들어, 아래의 &lt;code&gt;memset&lt;/code&gt; 에 대한 호출 은 중요하지 않은 클래스 객체를 수정하므로 진단되지 않으므로 정의되지 않습니다. 이러한 유형의 객체 저장을 초기화하거나 지우는 안전한 방법은 적절한 생성자 또는 할당 연산자 (사용 가능한 경우)를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40608df8d0fb171d8c9fd495ba5d5a7b32bd842d" translate="yes" xml:space="preserve">
          <source>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt; clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation.</source>
          <target state="translated">코드의 들여 쓰기가 블록 구조를 반영하지 않을 때 경고합니다. 특히, 경고가 발행되는 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , 그리고 &lt;code&gt;for&lt;/code&gt; 동일한 들여 쓰기 무방비 문 다음에 괄호를 사용하지 않는 보호 문에 절.</target>
        </trans-unit>
        <trans-unit id="ccf62a55eeac02e2a52c16724b5155a1eb1a630e" translate="yes" xml:space="preserve">
          <source>Warn when the order of member initializers given in the code does not match the order in which they must be executed. For instance:</source>
          <target state="translated">코드에 지정된 멤버 이니셜 라이저의 순서가 실행해야하는 순서와 일치하지 않을 때 경고합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="761311d3e33c39156d8e3725fcf020a8f1821794" translate="yes" xml:space="preserve">
          <source>Warn when the stack frame of a function exceeds &lt;var&gt;n&lt;/var&gt; bytes.</source>
          <target state="translated">함수의 스택 프레임이 &lt;var&gt;n&lt;/var&gt; 바이트를 초과하면 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="837d376bd42b01ca86e7606408854284b9f96c39" translate="yes" xml:space="preserve">
          <source>Warn whenever &amp;lsquo;</source>
          <target state="translated">때마다 경고 '</target>
        </trans-unit>
        <trans-unit id="0c2135b897d3d5641cf8e18388c032eb11d6e43a" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">때마다 경고 &lt;code&gt;switch&lt;/code&gt; 문은 제어 표현과 실행되지 않습니다 첫 번째 경우 레이블 사이에 문이 포함되어 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3eb686177c30ed2e6e5f5f2664f95e4bb53041fa" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement does not have a &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 &lt;code&gt;default&lt;/code&gt; 사례 가 없을 때마다 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="3ee15f4deaad963ee59e6e25cbd36a97c1a0b6f8" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 부울 유형의 색인이 있고 대소 문자 값이 부울 유형의 범위를 벗어날 때마다 경고 합니다. 제어 표현식을 &lt;code&gt;bool&lt;/code&gt; 이외의 유형으로 캐스트하여이 경고를 억제 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d226ed0209ee1c2fb6432b4c47bf17b27b050c76" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. (The presence of a &lt;code&gt;default&lt;/code&gt; label prevents this warning.) &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used (even if there is a &lt;code&gt;default&lt;/code&gt; label). This warning is enabled by</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 열거 유형의 인덱스가 있고 해당 열거의 하나 이상의 명명 된 코드에 대한 &lt;code&gt;case&lt;/code&gt; 가없는 경우 경고 합니다. (A의 존재 &lt;code&gt;default&lt;/code&gt; 레이블은이 경고를 방지 할 수 있습니다.) &lt;code&gt;case&lt;/code&gt; 이 옵션의 (a있는 경우에도 사용하는 경우 열거 범위를 벗어난 라벨도 경고를 유발 &lt;code&gt;default&lt;/code&gt; 라벨). 이 경고는</target>
        </trans-unit>
        <trans-unit id="de11d7b668ccdb23ca7bd8a246e58548a37f3260" translate="yes" xml:space="preserve">
          <source>Warn whenever a &lt;code&gt;switch&lt;/code&gt; statement has an index of enumerated type and lacks a &lt;code&gt;case&lt;/code&gt; for one or more of the named codes of that enumeration. &lt;code&gt;case&lt;/code&gt; labels outside the enumeration range also provoke warnings when this option is used. The only difference between</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 열거 유형의 인덱스가 있고 해당 열거의 하나 이상의 명명 된 코드에 대한 &lt;code&gt;case&lt;/code&gt; 가없는 경우 경고 합니다. 열거 범위 밖의 &lt;code&gt;case&lt;/code&gt; 레이블도이 옵션을 사용할 때 경고를 유발합니다. 유일한 차이점</target>
        </trans-unit>
        <trans-unit id="2d59fb66fde78bda0a4dd35cce84a5db357b0d28" translate="yes" xml:space="preserve">
          <source>Warn whenever a comment-start sequence &amp;lsquo;</source>
          <target state="translated">주석이 시작될 때마다 경고 '</target>
        </trans-unit>
        <trans-unit id="017d9dfe987bf5077b04f6ad0db50c54e128c51c" translate="yes" xml:space="preserve">
          <source>Warn whenever a constant static variable is unused aside from its declaration.</source>
          <target state="translated">상수 정적 변수가 선언과 별도로 사용되지 않을 때마다 경고합니다.</target>
        </trans-unit>
        <trans-unit id="44c2f3d6fa32cff8b5706f1e4a38180d5b65ee57" translate="yes" xml:space="preserve">
          <source>Warn whenever a function is defined with a return type that defaults to &lt;code&gt;int&lt;/code&gt;. Also warn about any &lt;code&gt;return&lt;/code&gt; statement with no return value in a function whose return type is not &lt;code&gt;void&lt;/code&gt; (falling off the end of the function body is considered returning without a value).</source>
          <target state="translated">함수가 기본값이 &lt;code&gt;int&lt;/code&gt; 인 반환 유형으로 정의 될 때마다 경고 합니다. 또한 리턴 유형이 &lt;code&gt;void&lt;/code&gt; 가 아닌 함수에 리턴 값이없는 &lt;code&gt;return&lt;/code&gt; 문 에 대해 경고 합니다 (함수 본문 끝에서 떨어지는 것은 값이없는 리턴으로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="89fb51e22730b538a06b8e80540c16d1c3734cc8" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration).</source>
          <target state="translated">함수 매개 변수가 할당 될 때마다 (하지만 선언과는 별도로) 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7522f02e51d59309d9911182c3c068a365219bc7" translate="yes" xml:space="preserve">
          <source>Warn whenever a function parameter is unused aside from its declaration.</source>
          <target state="translated">함수 매개 변수가 선언과 별도로 사용되지 않을 때마다 경고합니다.</target>
        </trans-unit>
        <trans-unit id="c0a7eb9ab9f17ff83adfaf6aff2a67a4af1e6664" translate="yes" xml:space="preserve">
          <source>Warn whenever a label is declared but not used. This warning is enabled by</source>
          <target state="translated">라벨이 선언되었지만 사용되지 않을 때마다 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="2d58d8f5ceb022d5ba0d30591a67aed1db06f84d" translate="yes" xml:space="preserve">
          <source>Warn whenever a local or static variable is unused aside from its declaration. This option implies</source>
          <target state="translated">지역 변수 나 정적 변수를 선언과 함께 사용하지 않을 때마다 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="6e4150091f2d91d35b21758f7af8935b067c74b6" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by</source>
          <target state="translated">로컬 변수가 할당되었지만 선언되지 않은 한 사용되지 않을 때마다 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="79ce592a35665d53c155cc3462735224db9a9571" translate="yes" xml:space="preserve">
          <source>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Same as</source>
          <target state="translated">로컬 변수 또는 형식 선언이 다른 변수, 매개 변수, 형식, 클래스 멤버 (C ++) 또는 인스턴스 변수 (Objective-C)를 가리거나 내장 함수가 그림자 일 때마다 경고합니다. C ++에서 컴파일러는 로컬 변수가 명시 적 typedef를 가리면 경고하지만 struct / class / enum을 가리면 경고하지 않습니다. 와 동일</target>
        </trans-unit>
        <trans-unit id="05ffb9a97b76e12ea54aaaeb8badea77adb678ae" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a &lt;code&gt;const char *&lt;/code&gt; is cast to an ordinary &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">대상 유형에서 유형 한정자를 제거하도록 포인터를 캐스트 할 때마다 경고합니다. 예를 들어, &lt;code&gt;const char *&lt;/code&gt; 가 일반 &lt;code&gt;char *&lt;/code&gt; 로 캐스트 되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="9c63ef9e66f9b18bee95bf1723987dfd5d11a58f" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; on machines where integers can only be accessed at two- or four-byte boundaries.</source>
          <target state="translated">대상의 필요한 정렬이 증가하도록 포인터가 캐스팅 될 때마다 경고합니다. 예를 들어, 2 바이트 또는 4 바이트 경계에서만 정수에 액세스 할 수있는 시스템에서 &lt;code&gt;char *&lt;/code&gt; 가 &lt;code&gt;int *&lt;/code&gt; 로 캐스트되는 경우 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ef7fc95a5c54b16b21f690678e6321f329b8c724" translate="yes" xml:space="preserve">
          <source>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a &lt;code&gt;char *&lt;/code&gt; is cast to an &lt;code&gt;int *&lt;/code&gt; regardless of the target machine.</source>
          <target state="translated">대상의 필요한 정렬이 증가하도록 포인터가 캐스팅 될 때마다 경고합니다. 예를 들어, 대상 시스템에 관계없이 &lt;code&gt;char *&lt;/code&gt; 가 &lt;code&gt;int *&lt;/code&gt; 로 캐스트 되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="f17199fabf0d6edb5e8d9320d9584ee47f24d757" translate="yes" xml:space="preserve">
          <source>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to &lt;code&gt;void&lt;/code&gt;. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as &lt;code&gt;x[i,j]&lt;/code&gt; causes a warning, while &lt;code&gt;x[(void)i,j]&lt;/code&gt; does not.</source>
          <target state="translated">명령문이 명시 적으로 사용되지 않은 결과를 계산할 때마다 경고합니다. 이 경고를 표시하지 않으려면 사용하지 않는 표현식을 &lt;code&gt;void&lt;/code&gt; 로 캐스팅하십시오 . 여기에는 부작용이없는 쉼표 식의 expression-statement 또는 왼쪽이 포함됩니다. 예를 들어 &lt;code&gt;x[i,j]&lt;/code&gt; 와 같은 식은 경고를 발생시키는 반면 &lt;code&gt;x[(void)i,j]&lt;/code&gt; 는 경고를 발생 시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9ed26895683fb69327818c06ae2df9969d8a9f1" translate="yes" xml:space="preserve">
          <source>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by</source>
          <target state="translated">정적 함수가 선언되었지만 정의되지 않았거나 인라인이 아닌 정적 함수가 사용되지 않을 때마다 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="682ef1b46b2728b71e94a89b2010ca06ceb12456" translate="yes" xml:space="preserve">
          <source>Warn whenever an Objective-C assignment is being intercepted by the garbage collector.</source>
          <target state="translated">가비지 수집기에서 Objective-C 할당을 가로 챌 때마다 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5f84fae543b9699e7c995142a54b65f353ecae8d" translate="yes" xml:space="preserve">
          <source>Warn whenever an object is defined whose size exceeds &lt;var&gt;byte-size&lt;/var&gt;.</source>
          <target state="translated">크기가 &lt;var&gt;byte-size&lt;/var&gt; 를 초과하는 객체가 정의 될 때마다 경고 합니다 .</target>
        </trans-unit>
        <trans-unit id="ea0ef30fd9bda293d78af05a20b81fc75c62d811" translate="yes" xml:space="preserve">
          <source>Warning Options</source>
          <target state="translated">경고 옵션</target>
        </trans-unit>
        <trans-unit id="986ddebcadb3fa23d23a5b826b014fe8f130debb" translate="yes" xml:space="preserve">
          <source>Warning about assigning a signed value to an unsigned variable.</source>
          <target state="translated">부호없는 값을 부호없는 변수에 할당하는 것에 대한 경고.</target>
        </trans-unit>
        <trans-unit id="e9e66e7d69e59ab3855b10526f1e61fff27e7187" translate="yes" xml:space="preserve">
          <source>Warning about using an expression whose type is signed as a shift count.</source>
          <target state="translated">유형이 시프트 횟수로 서명 된 표현식 사용에 대한 경고.</target>
        </trans-unit>
        <trans-unit id="418dee8a9f5c36e0b14dc254214604e6561b0bc6" translate="yes" xml:space="preserve">
          <source>Warning when a non-void function value is ignored.</source>
          <target state="translated">비 공백 기능 값이 무시 될 때 경고.</target>
        </trans-unit>
        <trans-unit id="6016747760c907aec70fe12b355cb7c681c5c0db" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error.</source>
          <target state="translated">경고는 본질적으로 오류가 아니지만 위험하거나 오류가 있음을 시사하는 구조물을보고하는 진단 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="0dd982bec66fde4c74400108fddfd5cb384244af" translate="yes" xml:space="preserve">
          <source>Warnings may indicate danger points where you should check to make sure that your program really does what you intend; or the use of obsolete features; or the use of nonstandard features of GNU C or C++. Many warnings are issued only if you ask for them, with one of the</source>
          <target state="translated">경고는 프로그램이 실제로 의도 한대로 작동하는지 확인해야 할 위험 지점을 나타냅니다. 또는 쓸모없는 기능의 사용; 또는 GNU C 또는 C ++의 비표준 기능 사용. 많은 경고는 요청한 경우에만 발행되며</target>
        </trans-unit>
        <trans-unit id="774110e2ee23eade4be0249d185f9d3f531f461a" translate="yes" xml:space="preserve">
          <source>Weak pointers are supported through a new type character specifier represented by the &amp;lsquo;</source>
          <target state="translated">약한 포인터는 '로 표시되는 새로운 유형 문자 지정자를 통해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="833f5330898dc442fd023004015464621900910e" translate="yes" xml:space="preserve">
          <source>What constitutes an access to a volatile object.</source>
          <target state="translated">휘발성 개체에 대한 액세스를 구성하는 것.</target>
        </trans-unit>
        <trans-unit id="29d1640b5550a77154368675da8078c8ec35026f" translate="yes" xml:space="preserve">
          <source>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</source>
          <target state="translated">휘발성 정규 유형 (C90 6.5.3, C99 및 C11 6.7.3)을 가진 개체에 대한 액세스를 구성하는 것.</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="73ab9ffb5b7365deaf1034842a4b9d0c5073a1f3" translate="yes" xml:space="preserve">
          <source>When G++ and another C++ compiler conform to the same C++ ABI, but the implementations of the Standard C++ Library that they normally use do not follow the same ABI for the Standard C++ Library, object files built with those compilers can be used in the same program only if they use the same C++ library. This requires specifying the location of the C++ library header files when invoking the compiler whose usual library is not being used. The location of GCC&amp;rsquo;s C++ header files depends on how the GCC build was configured, but can be seen by using the G++</source>
          <target state="translated">G ++ 및 다른 C ++ 컴파일러가 동일한 C ++ ABI를 준수하지만 일반적으로 사용하는 표준 C ++ 라이브러리 구현이 표준 C ++ 라이브러리에 대해 동일한 ABI를 따르지 않는 경우 해당 컴파일러로 빌드 된 오브젝트 파일을 동일한 프로그램에서 사용할 수 있습니다 동일한 C ++ 라이브러리를 사용하는 경우에만. 일반적인 라이브러리를 사용하지 않는 컴파일러를 호출 할 때 C ++ 라이브러리 헤더 파일의 위치를 ​​지정해야합니다. GCC의 C ++ 헤더 파일의 위치는 GCC 빌드가 구성된 방식에 따라 다르지만 G ++를 사용하여 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b318e1653c6b6dda339c34d9872ce5b96093ce" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of</source>
          <target state="translated">IPA-CP가 클로닝 후보가 어레이 액세스의 인덱스를 알 것으로 결정할 때 보너스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3fbfba2a71ffaa54417e4d873e33ec3bbc19a7e4" translate="yes" xml:space="preserve">
          <source>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of</source>
          <target state="translated">IPA-CP가 클로닝 후보가 루프의 반복 횟수를 알고 있다고 판단하면 보너스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b074b049fd7c7f48c6da34e1272635cac52856d" translate="yes" xml:space="preserve">
          <source>When a base class is virtual, only one subobject of the base class belongs to each full object. Also, the constructors and destructors are invoked only once, and called from the most-derived class. However, such objects behave unspecified when being assigned. For example:</source>
          <target state="translated">기본 클래스가 가상 인 경우 기본 클래스의 하나의 하위 오브젝트 만 각 전체 오브젝트에 속합니다. 또한 생성자와 소멸자는 한 번만 호출되며 가장 파생 된 클래스에서 호출됩니다. 그러나 이러한 오브젝트는 지정 될 때 지정되지 않은 것으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67be4830f6cdd00004022ad6db1aaae5471c2589" translate="yes" xml:space="preserve">
          <source>When a class has static data members, it is not enough to &lt;em&gt;declare&lt;/em&gt; the static member; you must also &lt;em&gt;define&lt;/em&gt; it. For example:</source>
          <target state="translated">클래스에 정적 데이터 멤버가 있는 경우 정적 멤버 를 &lt;em&gt;선언&lt;/em&gt; 하는 것만으로는 충분하지 않습니다 . 또한 &lt;em&gt;정의&lt;/em&gt; 해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d927dabaa85a2fec9fca96ddc5e395f531b27e67" translate="yes" xml:space="preserve">
          <source>When a division strategy has not been specified the default strategy is selected based on the current target. For SH2A the default strategy is to use the &lt;code&gt;divs&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions instead of library function calls.</source>
          <target state="translated">디비전 전략이 지정되지 않은 경우 기본 목표는 현재 목표를 기반으로 선택됩니다. SH2A의 기본 전략은 라이브러리 함수 호출 대신 &lt;code&gt;divs&lt;/code&gt; 및 &lt;code&gt;divu&lt;/code&gt; 명령어 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a75adb840378c14dc9a655e4aba002e527f73a2" translate="yes" xml:space="preserve">
          <source>When a file is compiled with</source>
          <target state="translated">파일을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="0cd90cdfd69b208961a20a866e993339b4b5f840" translate="yes" xml:space="preserve">
          <source>When a function is both inline and &lt;code&gt;static&lt;/code&gt;, if all calls to the function are integrated into the caller, and the function&amp;rsquo;s address is never used, then the function&amp;rsquo;s own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option</source>
          <target state="translated">함수가 inline 및 &lt;code&gt;static&lt;/code&gt; 인 경우 함수에 대한 모든 호출이 호출자에 통합되고 함수의 주소가 사용되지 않으면 함수의 자체 어셈블러 코드가 참조되지 않습니다. 이 경우 옵션을 지정하지 않으면 GCC는 실제로 함수에 대한 어셈블러 코드를 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="678a6d73dd419ef65f8fe5fe05b5c39fad57f23c" translate="yes" xml:space="preserve">
          <source>When a list constructor stores the &lt;code&gt;begin&lt;/code&gt; pointer from the &lt;code&gt;initializer_list&lt;/code&gt; argument, this doesn&amp;rsquo;t extend the lifetime of the array, so if a class variable is constructed from a temporary &lt;code&gt;initializer_list&lt;/code&gt;, the pointer is left dangling by the end of the variable declaration statement.</source>
          <target state="translated">리스트 생성자 가 &lt;code&gt;initializer_list&lt;/code&gt; 인수 에서 &lt;code&gt;begin&lt;/code&gt; 포인터를 저장할 때 이것은 배열의 수명을 연장하지 않으므로 클래스 변수가 임시 &lt;code&gt;initializer_list&lt;/code&gt; 에서 구성되면 포인터는 변수 선언문의 끝에 매달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f542136163060bf7630e6166417f9110c29edb" translate="yes" xml:space="preserve">
          <source>When a lock acquire fails, it is required for good performance to abort the transaction quickly. This can be done with a &lt;code&gt;_mm_pause&lt;/code&gt;.</source>
          <target state="translated">잠금 획득에 실패하면 성능을 향상시켜 트랜잭션을 신속하게 중단해야합니다. 이것은 &lt;code&gt;_mm_pause&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f7415b6c4bfc3b8582a73345fc35229f98c2491" translate="yes" xml:space="preserve">
          <source>When a type involving an ABI tag is used as the type of a variable or return type of a function where that tag is not already present in the signature of the function, the tag is automatically applied to the variable or function.</source>
          <target state="translated">ABI 태그와 관련된 유형이 변수의 유형으로 사용되거나 해당 태그가 함수의 서명에없는 함수의 리턴 유형으로 사용되는 경우 태그는 자동으로 변수 또는 함수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6dad89b8cb0d35ea0fd46b863a5983c0e559d839" translate="yes" xml:space="preserve">
          <source>When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack.</source>
          <target state="translated">M32C 포트를 사용하여 인터럽트 처리기에 추가하면 프롤로그와 에필로그가 뱅크 전환을 사용하여 레지스터를 스택에 저장하지 않고 보존합니다.</target>
        </trans-unit>
        <trans-unit id="f8717fcf897c9e046dd756abc024e5f7d502ccd8" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;initializer_list&lt;/code&gt; variable is assigned from a brace-enclosed initializer list, the temporary array created for the right side of the assignment only lives until the end of the full-expression, so at the next statement the &lt;code&gt;initializer_list&lt;/code&gt; variable has a dangling pointer.</source>
          <target state="translated">때 &lt;code&gt;initializer_list&lt;/code&gt; 변수가 중괄호로 둘러싸인 목록 초기화에서 할당, 할당의 오른쪽을 위해 만든 임시 배열에만 그래서 다음 문장에서, 전체 표현이 끝날 때까지 살아 &lt;code&gt;initializer_list&lt;/code&gt; 변수가 매달려 포인터를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="f82873b6d13dce7be3f4357951354ec118469799" translate="yes" xml:space="preserve">
          <source>When an error message refers to a specialization of a function template, the compiler normally prints the signature of the template followed by the template arguments and any typedefs or typenames in the signature (e.g. &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; rather than &lt;code&gt;void f(int)&lt;/code&gt;) so that it&amp;rsquo;s clear which template is involved. When an error message refers to a specialization of a class template, the compiler omits any template arguments that match the default template arguments for that template. If either of these behaviors make it harder to understand the error message rather than easier, you can use</source>
          <target state="translated">에러 메시지가 함수 템플릿의 특수화를 언급 할 때, 컴파일러는 일반적으로 템플릿의 서명 다음에 템플릿 인수와 서명의 형식 정의 또는 형식 이름을 인쇄합니다 (예 : &lt;code&gt;void f(T) [with T = int]&lt;/code&gt; 대신 &lt;code&gt;void f(int)&lt;/code&gt; ) 어떤 템플릿이 관련되어 있는지 명확하게합니다. 오류 메시지가 클래스 템플릿의 특수화를 나타내는 경우 컴파일러는 해당 템플릿의 기본 템플릿 인수와 일치하는 템플릿 인수를 생략합니다. 이러한 동작 중 하나가 오류 메시지를 이해하기보다 이해하기 어렵게 만드는 경우</target>
        </trans-unit>
        <trans-unit id="4a0782c5484322bfadd7fe79666979332dd01a38" translate="yes" xml:space="preserve">
          <source>When an executable is run in a massive parallel environment, it is recommended to save profile to different folders. That can be done with variables in &lt;var&gt;path&lt;/var&gt; that are exported during run-time:</source>
          <target state="translated">대규모 병렬 환경에서 실행 파일을 실행할 때는 프로필을 다른 폴더에 저장하는 것이 좋습니다. 런타임 중에 내보내 지는 &lt;var&gt;path&lt;/var&gt; 변수를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c4f8c7d6b26eab60b9d9e100920ff031a8aaf4" translate="yes" xml:space="preserve">
          <source>When an inline function is not &lt;code&gt;static&lt;/code&gt;, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-&lt;code&gt;static&lt;/code&gt; inline function is always compiled on its own in the usual fashion.</source>
          <target state="translated">인라인 함수가 &lt;code&gt;static&lt;/code&gt; 이 아닌 경우 컴파일러는 다른 소스 파일에서 호출이있을 수 있다고 가정해야합니다. 전역 기호는 모든 프로그램에서 한 번만 정의 할 수 있으므로 다른 소스 파일에서 함수를 정의하면 안되므로 호출을 통합 할 수 없습니다. 따라서 &lt;code&gt;static&lt;/code&gt; 이 아닌 인라인 함수는 항상 일반적인 방식으로 자체 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="b338539fbe33495121e46c5661e5bc16f008a3e0" translate="yes" xml:space="preserve">
          <source>When an insn has two alternative constraint-patterns.</source>
          <target state="translated">insn에 두 개의 대체 제약 패턴이있는 경우</target>
        </trans-unit>
        <trans-unit id="4cbff59218859bab09c21980b2597e3d4c6294f2" translate="yes" xml:space="preserve">
          <source>When an unrecognized warning option is requested (e.g.,</source>
          <target state="translated">인식 할 수없는 경고 옵션이 요청 된 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="537d39cd77a447e897b80dd75224237bdc4e0719" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of 4-operand &lt;code&gt;madd.s&lt;/code&gt;, &lt;code&gt;madd.d&lt;/code&gt; and related instructions. Enabled by default.</source>
          <target state="translated">해당되는 경우, 4-operand &lt;code&gt;madd.s&lt;/code&gt; , &lt;code&gt;madd.d&lt;/code&gt; 및 관련 지침 의 생성을 활성화 (비활성화)합니다 . 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c26cdde33cc06bf31aab1a7bf63c69c29f00704" translate="yes" xml:space="preserve">
          <source>When applicable, enable (disable) the generation of &lt;code&gt;lwxc1&lt;/code&gt;, &lt;code&gt;swxc1&lt;/code&gt;, &lt;code&gt;ldxc1&lt;/code&gt;, &lt;code&gt;sdxc1&lt;/code&gt; instructions. Enabled by default.</source>
          <target state="translated">해당되는 경우 &lt;code&gt;lwxc1&lt;/code&gt; , &lt;code&gt;swxc1&lt;/code&gt; , &lt;code&gt;ldxc1&lt;/code&gt; , &lt;code&gt;sdxc1&lt;/code&gt; 명령어 생성을 활성화 (비활성화)합니다 . 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7184e15e5684528f54729686834cdf00887683be" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class.</source>
          <target state="translated">C ++ 클래스에 적용될 때 속성은 인라인되지 않은 멤버 함수 및 정적 데이터 멤버를 내보내기로 정의합니다. 클래스 내에서 초기화 된 정적 const는 클래스 외부에서 정의되지 않은 한 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d9feaafaf97b8f7fe46d8b6b598964809d89431" translate="yes" xml:space="preserve">
          <source>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks.</source>
          <target state="translated">C ++ 클래스에 적용되면이 속성은 인라인되지 않은 멤버 함수 및 정적 데이터 멤버를 가져 오기로 표시합니다. 그러나 가상 메소드의 경우 속성을 무시하여 썽크를 사용하여 vtable을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf180b63c03eb34a3aba311a968f02d5135ed3e" translate="yes" xml:space="preserve">
          <source>When applied to a member function of a C++ class template, the attribute also means that the function is instantiated if the class itself is instantiated.</source>
          <target state="translated">C ++ 클래스 템플리트의 멤버 함수에 적용되는 경우 속성은 클래스 자체가 인스턴스화 된 경우 함수가 인스턴스화됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cabddb6e825602d843a117fb734ca3aff3112d1a" translate="yes" xml:space="preserve">
          <source>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</source>
          <target state="translated">C ++ 클래스 템플리트의 정적 데이터 멤버에 적용되는 경우 속성은 클래스 자체가 인스턴스화 된 경우 멤버가 인스턴스화됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="59f0e6f1d8d71dac3701cee27ca42c33aae99e5f" translate="yes" xml:space="preserve">
          <source>When attached to a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, this attribute sets the storage order, aka endianness, of the scalar fields of the type, as well as the array fields whose component is scalar. The supported endiannesses are &lt;code&gt;big-endian&lt;/code&gt; and &lt;code&gt;little-endian&lt;/code&gt;. The attribute has no effects on fields which are themselves a &lt;code&gt;union&lt;/code&gt;, a &lt;code&gt;struct&lt;/code&gt; or an array whose component is a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;, and it is possible for these fields to have a different scalar storage order than the enclosing type.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 첨부되면 이 속성은 유형이 스칼라 필드의 스토리지 순서 (일명 엔디안)와 구성 요소가 스칼라 인 배열 필드를 설정합니다. 지원되는 엔디안은 &lt;code&gt;big-endian&lt;/code&gt; 및 &lt;code&gt;little-endian&lt;/code&gt; 입니다. 이 속성은 자신이 &lt;code&gt;union&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; 또는 구성 요소가 &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 인 배열 인 필드에는 영향을 미치지 않으며 , 이러한 필드는 엔 클로징 유형과 다른 스칼라 저장 순서를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5370f9b64efe5c0ffe3fe15dfade832ac9be14df" translate="yes" xml:space="preserve">
          <source>When attached to a type (including a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt;), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.</source>
          <target state="translated">유형 ( &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 포함)에 첨부 된 경우이 속성은 해당 유형의 변수가 사용되지 않는 것으로 나타납니다. GCC는 변수가 아무 것도 보이지 않는 경우에도 해당 유형의 변수에 대해 경고를 생성하지 않습니다. 이것은 일반적으로 정의되고 참조되지 않지만 잠금이 아닌 스레드 클래스의 경우이지만 사소한 부기 기능을 가진 생성자와 소멸자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="607b6b9a753f4dcb8aa6e646687045411231d9db" translate="yes" xml:space="preserve">
          <source>When attached to an &lt;code&gt;enum&lt;/code&gt; definition, the &lt;code&gt;packed&lt;/code&gt; attribute indicates that the smallest integral type should be used. Specifying the</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 정의에 첨부 된 경우 &lt;code&gt;packed&lt;/code&gt; 속성은 가장 작은 정수 유형을 사용해야 함을 나타냅니다. 지정</target>
        </trans-unit>
        <trans-unit id="3212c36750452527c536dd1eddfa9228aa24bc41" translate="yes" xml:space="preserve">
          <source>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable.</source>
          <target state="translated">분기가이 임계 값 (%)보다 낮은 확률로 취해질 것으로 예상되면 잘 예측 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f92818ac1f6c1cf9820bd7ad2460f0b770895e75" translate="yes" xml:space="preserve">
          <source>When branch probabilities are given, include those of unconditional branches. Unconditional branches are normally not interesting.</source>
          <target state="translated">분기 확률이 주어지면 무조건 분기를 포함하십시오. 무조건 분기는 일반적으로 흥미롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ae42b215512052c2cadc23355c16f5c5dd443cf" translate="yes" xml:space="preserve">
          <source>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of &lt;code&gt;qsort&lt;/code&gt;, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will &lt;em&gt;not&lt;/em&gt; restore them before calling &lt;code&gt;qsort&lt;/code&gt;&amp;rsquo;s comparison function. As a result, global values will not reliably be available to the comparison function unless the &lt;code&gt;qsort&lt;/code&gt; function itself is rebuilt.</source>
          <target state="translated">예약을 인식하지 않는 루틴을 호출 할 때 해당 루틴이이를 사용하는 코드를 다시 호출하는 경우주의하십시오. 예를 들어, 시스템 라이브러리 버전 &lt;code&gt;qsort&lt;/code&gt; 를 호출하면 실행 중에 레지스터가 손상 될 수 있지만 (적절한 레지스터를 선택한 경우) 반환하기 전에 레지스터를 복원합니다. 그러나 &lt;code&gt;qsort&lt;/code&gt; 의 비교 함수를 호출하기 전에 복원 &lt;em&gt;하지 않습니다&lt;/em&gt; . 결과적으로 &lt;code&gt;qsort&lt;/code&gt; 함수 자체가 재 구축 되지 않으면 전역 값을 비교 함수에 안정적으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce64a23abaaddcfa5831e43098fffe47be4e539" translate="yes" xml:space="preserve">
          <source>When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</source>
          <target state="translated">포인터에서 정수로 캐스트하고 다시 되돌릴 때 결과 포인터는 원래 포인터와 동일한 객체를 참조해야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 즉, C99 및 C11 6.5.6 / 8에 규정 된 포인터 산술의 정의되지 않은 동작을 피하기 위해 정수 산술을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a6770a95cb182eb94130a66a137214e2a89e539" translate="yes" xml:space="preserve">
          <source>When code compiled with</source>
          <target state="translated">코드를 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="2694a5fd19642dc29f67abfd4afa306ec8d78457" translate="yes" xml:space="preserve">
          <source>When compiling C++, warn about the deprecated conversion from string literals to &lt;code&gt;char *&lt;/code&gt;. This warning is enabled by default for C++ programs.</source>
          <target state="translated">C ++를 컴파일 할 때 사용되지 않는 문자열 리터럴에서 &lt;code&gt;char *&lt;/code&gt; 로의 변환에 대해 경고하십시오 . 이 경고는 C ++ 프로그램에 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b58e8f8f470141f0b7d65fa2b304a55713649c15" translate="yes" xml:space="preserve">
          <source>When compiling C, give string constants the type &lt;code&gt;const
char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; so that copying the address of one into a non-&lt;code&gt;const&lt;/code&gt;&lt;code&gt;char *&lt;/code&gt; pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using &lt;code&gt;const&lt;/code&gt; in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make</source>
          <target state="translated">C를 컴파일 할 때 문자열 상수에 &lt;code&gt;const char[&lt;var&gt;length&lt;/var&gt;]&lt;/code&gt; 유형을 지정하여 하나의 주소를 &lt;code&gt;const&lt;/code&gt; 가 아닌 &lt;code&gt;char *&lt;/code&gt; 포인터에 복사하면 경고가 발생합니다. 이 경고는 컴파일 타임 코드에서 문자열 상수에 쓰려고 시도 할 수 있지만 선언 및 프로토 타입에서 &lt;code&gt;const&lt;/code&gt; 사용에 대해 매우 신중한 경우에만 찾을 수 있습니다 . 그렇지 않으면, 그것은 단지 성가신 것입니다. 우리가하지 않은 이유입니다</target>
        </trans-unit>
        <trans-unit id="cd87062968fd1ca6c15b5a9b85fba86d8a5ccfc2" translate="yes" xml:space="preserve">
          <source>When compiling code for single processor systems, it is generally safe to use &lt;code&gt;synci&lt;/code&gt;. However, on many multi-core (SMP) systems, it does not invalidate the instruction caches on all cores and may lead to undefined behavior.</source>
          <target state="translated">단일 프로세서 시스템 용 코드를 컴파일 할 때는 일반적으로 &lt;code&gt;synci&lt;/code&gt; 를 사용하는 것이 안전합니다 . 그러나 많은 다중 코어 (SMP) 시스템에서는 모든 코어의 명령 캐시를 무효화하지 않으며 동작이 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c10c0020a810534faa4083bee532dbff326c982" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol &lt;code&gt;__mips16&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">혼합 MIPS16과 비 MIPS16 코드를 포함하는 파일을 컴파일 할 때 전 처리기 기호 &lt;code&gt;__mips16&lt;/code&gt; 은 개별 기능이 아닌 명령 줄의 설정을 반영합니다. 혼합 MIPS16과 비 MIPS16 코드는 &lt;code&gt;__builtin_apply&lt;/code&gt; 와 같은 일부 GCC 확장과 잘못 상호 작용할 수 있습니다 ( &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;호출 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="60deff215e04b72131ce496d836442fb3376a9ed" translate="yes" xml:space="preserve">
          <source>When compiling files containing mixed microMIPS and non-microMIPS code, the preprocessor symbol &lt;code&gt;__mips_micromips&lt;/code&gt; reflects the setting on the command line, not that within individual functions. Mixed microMIPS and non-microMIPS code may interact badly with some GCC extensions such as &lt;code&gt;__builtin_apply&lt;/code&gt; (see &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;Constructing Calls&lt;/a&gt;).</source>
          <target state="translated">혼합 microMIPS 및 비 microMIPS 코드가 포함 된 파일을 컴파일 할 때 전 처리기 기호 &lt;code&gt;__mips_micromips&lt;/code&gt; 는 개별 기능이 아닌 명령 줄의 설정을 반영합니다. 혼합 microMIPS와 비 microMIPS 코드는 &lt;code&gt;__builtin_apply&lt;/code&gt; 와 같은 일부 GCC 확장과 잘못 상호 작용할 수 있습니다 ( &lt;a href=&quot;constructing-calls#Constructing-Calls&quot;&gt;호출 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b21353af5c286cba09d175d058607a98bab9646" translate="yes" xml:space="preserve">
          <source>When compiling files residing in directory</source>
          <target state="translated">디렉토리에있는 파일을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="fb1c662fe80e2a5daa84889e9b20929141a1f39e" translate="yes" xml:space="preserve">
          <source>When compiling for Nios II, the following options are allowed:</source>
          <target state="translated">Nios II를 컴파일 할 때 다음 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="47a745ce02eda6e5b8af0283813b8d27ac893e5a" translate="yes" xml:space="preserve">
          <source>When compiling for the NeXT runtime, the compiler ordinarily replaces calls to &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; (when the name of the class is known at compile time) with static class references that get initialized at load time, which improves run-time performance. Specifying the</source>
          <target state="translated">NeXT 런타임 용으로 컴파일 할 때, 컴파일러는 보통 &lt;code&gt;objc_getClass(&quot;&amp;hellip;&quot;)&lt;/code&gt; 호출 ( 클래스 이름이 컴파일 타임에 알려진 경우)을로드시 초기화되는 정적 클래스 참조로 대체하여 런타임 성능을 향상시킵니다. 지정</target>
        </trans-unit>
        <trans-unit id="7acd9f9e9a72745fc09c352c58646de2d43a5f5e" translate="yes" xml:space="preserve">
          <source>When compiling functions that return &lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt;, PCC converts it to a double. GCC actually returns a &lt;code&gt;float&lt;/code&gt;. If you are concerned with PCC compatibility, you should declare your functions to return &lt;code&gt;double&lt;/code&gt;; you might as well say what you mean.</source>
          <target state="translated">&lt;code id=&quot;index-float-as-function-value-type&quot;&gt;float&lt;/code&gt; 를 반환하는 함수를 컴파일 할 때 PCC는이 함수를 double로 변환합니다. GCC는 실제로 &lt;code&gt;float&lt;/code&gt; 를 반환합니다 . PCC 호환성에 관심이 있다면 &lt;code&gt;double&lt;/code&gt; 을 리턴하도록 함수를 선언해야합니다 . 당신은 또한 당신이 무슨 뜻인지 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5db0043541449725fbfb6c49474d3dea04ea8f6" translate="yes" xml:space="preserve">
          <source>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.</source>
          <target state="translated">GCC 출력 코드는 구조체 나 공용체를 반환하는 함수를 컴파일 할 때 일반적으로 대부분의 Unix 버전에서 사용되는 것과 다른 방법을 사용합니다. 결과적으로 GCC로 컴파일 된 코드는 PCC로 컴파일 된 구조 반환 함수를 호출 할 수 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="42802196182be1a26f30e794627d93f753ad7250" translate="yes" xml:space="preserve">
          <source>When compiling using the AAPCS ABI (or a variant of it) then valid values for the argument are &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; and &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;. In order to use a variant other than &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt;). For example,</source>
          <target state="translated">AAPCS ABI (또는 그 변형)를 사용하여 컴파일 할 때 인수에 유효한 값은 &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; 입니다. &lt;code&gt;&quot;aapcs&quot;&lt;/code&gt; 이외의 변형을 사용 하려면 컴파일러에서 적절한 보조 프로세서 레지스터를 사용해야합니다 (즉, &lt;code&gt;&quot;aapcs-vfp&quot;&lt;/code&gt; 를 사용하려면 VFP 레지스터를 사용할 수 있어야 함 ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f269c2c80bc0b6cd00bdccd1a4ad395d3f1e317" translate="yes" xml:space="preserve">
          <source>When compiling, this option enables</source>
          <target state="translated">컴파일 할 때이 옵션을 사용하면</target>
        </trans-unit>
        <trans-unit id="315f128e4ce30c782f28bfb565507bc8d99b6552" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps (see</source>
          <target state="translated">디버깅 덤프를 수행 할 때 (참조</target>
        </trans-unit>
        <trans-unit id="dce8f6e7dddb2ada38853381a56083f98e91e173" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso start locations.</source>
          <target state="translated">디버깅 덤프를 수행 할 때 주소 출력을 억제하십시오. 이것은 다른 컴파일러 바이너리 및 / 또는 다른 텍스트 / bss / data / heap / stack / dso start 위치로 컴파일러 호출을 위해 디버깅 덤프에서 diff를 사용하는 것이 더 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5cb94325a71b749cb8e5d8b4041d1d7a131d0f11" translate="yes" xml:space="preserve">
          <source>When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use diff on debugging dumps for compiler invocations with different options, in particular with and without</source>
          <target state="translated">디버깅 덤프를 수행 할 때 명령어 번호와 주소 출력을 억제하십시오. 이것은 다른 옵션, 특히 유무에 관계없이 컴파일러 호출을 위해 디버깅 덤프에서 diff를 사용하는 것이 더 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6a3f0b550d9291ec66729667f3f7ca83fd2f4d8b" translate="yes" xml:space="preserve">
          <source>When dumping RTL, print the RTL in slim (condensed) form instead of the default LISP-like representation.</source>
          <target state="translated">RTL을 덤프 할 때 기본 LISP와 유사한 표현 대신 슬림 (축소) 형태로 RTL을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="74301d6d6862291588f10bf29b45b4967ce13d2f" translate="yes" xml:space="preserve">
          <source>When dumping front-end intermediate representations, inhibit dumping of members of a scope or body of a function merely because that scope has been reached. Only dump such items when they are directly reachable by some other path.</source>
          <target state="translated">프런트 엔드 중간 표현을 덤프 할 때는 해당 범위에 도달했기 때문에 함수의 범위 또는 본문 멤버의 덤프를 금지하십시오. 다른 경로로 직접 접근 할 수있는 경우에만 해당 항목을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="f945883699fc9792ba3afeb26f744a7773586ecc" translate="yes" xml:space="preserve">
          <source>When dumping pretty-printed trees, this option inhibits dumping the bodies of control structures.</source>
          <target state="translated">정교하게 인쇄 된 트리를 덤프 할 때이 옵션은 제어 구조의 본문 덤프를 금지합니다.</target>
        </trans-unit>
        <trans-unit id="6fc1555729570caee324aa057f7026754c896f3e" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural bitwise constant propagation. This flag is enabled by default at</source>
          <target state="translated">사용 가능한 경우, 절차 적 비트 단위 상수 전파를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="bf82f180e269afc159377aa835c2b162d457aecd" translate="yes" xml:space="preserve">
          <source>When enabled, perform interprocedural propagation of value ranges. This flag is enabled by default at</source>
          <target state="translated">사용 가능한 경우 값 범위의 프로 시저 간 전파를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="5a6db9d98413978e8951a290a39c293b6dbce38a" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain CSYNC or SSYNC instructions too soon after conditional branches. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; is defined.</source>
          <target state="translated">활성화되면 컴파일러는 조건부 분기 후 생성 된 코드에 CSYNC 또는 SSYNC 명령어가 너무 빨리 포함되지 않도록합니다. 이 옵션을 사용하면 &lt;code&gt;__WORKAROUND_SPECULATIVE_SYNCS&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5cabeafae5f5d65fb548beb5767960c04d9a35b8" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler ensures that the generated code does not contain speculative loads after jump instructions. If this option is used, &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; is defined.</source>
          <target state="translated">활성화되면 컴파일러는 생성 된 코드에 점프 명령 후 추론 적로드가 포함되지 않도록합니다. 이 옵션을 사용하면 &lt;code&gt;__WORKAROUND_SPECULATIVE_LOADS&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="177174ed256fb1fc5ac1ff6e0a69365e95922527" translate="yes" xml:space="preserve">
          <source>When enabled, the compiler is free to take advantage of the knowledge that the entire program fits into the low 64k of memory.</source>
          <target state="translated">활성화되면 컴파일러는 전체 프로그램이 낮은 64k 메모리에 적합하다는 지식을 자유롭게 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1158beec156e6a8ecff5cd217a56a66d53e95d9" translate="yes" xml:space="preserve">
          <source>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case. The default is</source>
          <target state="translated">이 옵션을 활성화하면 복잡한 나눗셈을 수행 할 때 범위 축소 단계가 필요하지 않습니다. 또한, 곱셈 또는 나눗셈의 결과가 &lt;code&gt;NaN + I*NaN&lt;/code&gt; 인지 여부를 확인하지 않으며,이 경우 상황을 구제하려고합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="5c41cf550423b99323059ab9102f75c243821bb0" translate="yes" xml:space="preserve">
          <source>When estimated performance improvement of caller + callee runtime exceeds this threshold (in percent), the function can be inlined regardless of the limit on</source>
          <target state="translated">발신자 + 수신자 런타임의 예상 성능 향상이이 임계 값 (백분율)을 초과하면 기능의 한계에 관계없이 인라인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0546498041d4ec0ccfc5ce36934cf27647842a41" translate="yes" xml:space="preserve">
          <source>When generating PIC code, do or don&amp;rsquo;t allow the use of PLTs. Ignored for non-PIC. The default is</source>
          <target state="translated">PIC 코드를 생성 할 때 PLT를 사용하거나 사용하지 마십시오. 비 PIC에 대해서는 무시됩니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="511bcbbf68adbe04ec79792863471cde6b014863" translate="yes" xml:space="preserve">
          <source>When generating a function that returns a pointer, return the pointer in both &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;d0&lt;/code&gt;. Otherwise, the pointer is returned only in &lt;code&gt;a0&lt;/code&gt;, and attempts to call such functions without a prototype result in errors. Note that this option is on by default; use</source>
          <target state="translated">포인터를 반환하는 함수를 생성 할 때 &lt;code&gt;a0&lt;/code&gt; 과 &lt;code&gt;d0&lt;/code&gt; 모두에서 포인터를 반환하십시오 . 그렇지 않으면 포인터는 &lt;code&gt;a0&lt;/code&gt; 에서만 반환 되고 프로토 타입없이 이러한 함수를 호출하려고하면 오류가 발생합니다. 이 옵션은 기본적으로 켜져 있습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="dd2029500976920c4504065ca16226229e4f7c22" translate="yes" xml:space="preserve">
          <source>When generating assembler output use a syntax that is compatible with Renesas&amp;rsquo;s AS100 assembler. This syntax can also be handled by the GAS assembler, but it has some restrictions so it is not generated by default.</source>
          <target state="translated">어셈블러 출력을 생성 할 때 Renesas의 AS100 어셈블러와 호환되는 구문을 사용하십시오. 이 구문은 GAS 어셈블러에서도 처리 할 수 ​​있지만 몇 가지 제한 사항이 있으므로 기본적으로 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34010eecdc80bda1996b3453a5842eca5948c6ad" translate="yes" xml:space="preserve">
          <source>When generating code for shared libraries,</source>
          <target state="translated">공유 라이브러리에 대한 코드를 생성 할 때</target>
        </trans-unit>
        <trans-unit id="ee57ba558572772d8e7d0fd148c855146cc649ba" translate="yes" xml:space="preserve">
          <source>When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">SSE 확장이 비활성화 된 x86-64 아키텍처 용 코드를 생성 할 때</target>
        </trans-unit>
        <trans-unit id="8c85713507dce4f24637fdca8c9dd42ecd242b3b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code for ColdFire, generate code that works if the GOT has more than 8192 entries. This code is larger and slower than code generated without this option. On M680x0 processors, this option is not needed;</source>
          <target state="translated">ColdFire에 대해 위치 독립적 인 코드를 생성 할 때 GOT에 8192 개가 넘는 항목이있는 경우 작동하는 코드를 생성하십시오. 이 코드는이 옵션없이 생성 된 코드보다 크고 느립니다. M680x0 프로세서에서는이 옵션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddb821edf6cd4d8eabb391980c4305801a4dd35b" translate="yes" xml:space="preserve">
          <source>When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.</source>
          <target state="translated">위치 독립적 인 코드를 생성 할 때 프로 시저 링크 테이블 대신 글로벌 오프셋 테이블을 사용하여 함수 호출을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="58318867846389e3f00483e730d9cdc45f04b844" translate="yes" xml:space="preserve">
          <source>When implementing patterns for these built-in functions, the memory order parameter can be ignored as long as the pattern implements the most restrictive &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; memory order. Any of the other memory orders execute correctly with this memory order but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</source>
          <target state="translated">이러한 내장 함수에 대한 패턴을 구현할 때 패턴이 가장 제한적인 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 메모리 순서를 구현하는 한 메모리 순서 매개 변수는 무시할 수 있습니다 . 다른 메모리 순서는이 메모리 순서로 올바르게 실행되지만 완화 된 요구 사항을보다 적절하게 구현하면 최대한 효율적으로 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9af953ed4f40761c964f415712e4b881671dfb2" translate="yes" xml:space="preserve">
          <source>When linking a big-endian image select between BE8 and BE32 formats. The option has no effect for little-endian images and is ignored. The default is dependent on the selected target architecture. For ARMv6 and later architectures the default is BE8, for older architectures the default is BE32. BE32 format has been deprecated by ARM.</source>
          <target state="translated">빅 엔디안 이미지를 연결할 때 BE8과 BE32 형식 중에서 선택하십시오. 이 옵션은 리틀 엔디안 이미지에는 영향을 미치지 않으며 무시됩니다. 기본값은 선택한 대상 아키텍처에 따라 다릅니다. ARMv6 이상 아키텍처의 경우 기본값은 BE8이고 이전 아키텍처의 경우 기본값은 BE32입니다. BE32 형식은 ARM에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="920068058745daad77bac4500e9d9b0ac2200c05" translate="yes" xml:space="preserve">
          <source>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using</source>
          <target state="translated">트랜잭션에서 스레드 로컬 변수의 사본을 작성할 때이 매개 변수는 코드 시퀀스 저장 / 복원 쌍이 아닌 로깅 기능으로 변수를 저장 한 후 바이트 단위의 크기를 지정합니다. 이 옵션은 사용할 때만 적용됩니다</target>
        </trans-unit>
        <trans-unit id="20fd5eb54a80ab92bcf13e1600542aa28ff5d13b" translate="yes" xml:space="preserve">
          <source>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate.</source>
          <target state="translated">function-cv-qualifiers를 사용하여 함수 유형을 처리 할 때 규정되지 않은 함수 유형이 대체 후보로 잘못 처리되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e16f38a870c014c4bf05a4ba66aff0d8f015c53" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are three output operands, use &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;asmSymbolicName&lt;/var&gt; 을 사용 하지 않는 경우 어셈블러 템플릿의 피연산자 목록에서 피연산자의 위치 (0 부터 시작 )를 사용하십시오. 예를 들어 출력 피연산자가 세 개인 경우 '</target>
        </trans-unit>
        <trans-unit id="f7f108470bcf6e6b304f3263a3362bac9bf0990f" translate="yes" xml:space="preserve">
          <source>When not using an &lt;var&gt;asmSymbolicName&lt;/var&gt;, use the (zero-based) position of the operand in the list of operands in the assembler template. For example if there are two output operands and three inputs, use &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;asmSymbolicName&lt;/var&gt; 을 사용 하지 않는 경우 어셈블러 템플릿의 피연산자 목록에서 피연산자의 위치 (0 부터 시작 )를 사용하십시오. 예를 들어 출력 피연산자 2 개와 입력 3 개가있는 경우 '</target>
        </trans-unit>
        <trans-unit id="9ab94547949a5e4c3215ae42df94303adb7916f4" translate="yes" xml:space="preserve">
          <source>When optimizing for size (using</source>
          <target state="translated">크기를 최적화 할 때 (</target>
        </trans-unit>
        <trans-unit id="97bc78492cc0f58dc12735620055de6a1daa4843" translate="yes" xml:space="preserve">
          <source>When passed this option, GCC produces a dynamic library instead of an executable when linking, using the Darwin</source>
          <target state="translated">이 옵션을 전달하면 GCC는 Darwin을 사용하여 링크 할 때 실행 파일 대신 동적 라이브러리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f2411855bc2157c02295a4d406d5bb74f6ed2885" translate="yes" xml:space="preserve">
          <source>When performing a stack backtrace, code can inspect the value of &lt;code&gt;pc&lt;/code&gt; stored at &lt;code&gt;fp + 0&lt;/code&gt;. If the trace function then looks at location &lt;code&gt;pc - 12&lt;/code&gt; and the top 8 bits are set, then we know that there is a function name embedded immediately preceding this location and has length &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt;.</source>
          <target state="translated">스택 역 추적을 수행 할 때 코드는 &lt;code&gt;fp + 0&lt;/code&gt; 저장된 &lt;code&gt;pc&lt;/code&gt; 값을 검사 할 수 있습니다 . 트레이스 함수가 &lt;code&gt;pc - 12&lt;/code&gt; 위치를보고 상위 8 비트가 설정되면이 위치 바로 앞에 함수 이름이 포함되어 있고 길이가 &lt;code&gt;((pc[-3]) &amp;amp; 0xff000000)&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f597a9e8b63ff1121b0842bcdb388264d1b3c5ff" translate="yes" xml:space="preserve">
          <source>When performing branch target register load optimization, don&amp;rsquo;t reuse branch target registers within any basic block.</source>
          <target state="translated">분기 대상 레지스터로드 최적화를 수행 할 때는 기본 블록 내에서 분기 대상 레지스터를 재사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9c01537a52102dd8946fc5982208fe491740f320" translate="yes" xml:space="preserve">
          <source>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless</source>
          <target state="translated">선택적 스케줄링 중에 파이프 라이닝이 루프되면 파이프 라인 외부 루프도 있습니다. 이 옵션은 다음을 제외하고는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1280e31b08d3497c525b6d236dd8d4d87c36c837" translate="yes" xml:space="preserve">
          <source>When preprocessing files residing in directory</source>
          <target state="translated">디렉토리에있는 파일을 전처리 할 때</target>
        </trans-unit>
        <trans-unit id="18019b7cb63563a2a1382c41adbfffdfc589112f" translate="yes" xml:space="preserve">
          <source>When preprocessing, do not shorten system header paths with canonicalization.</source>
          <target state="translated">사전 처리시 정규화로 시스템 헤더 경로를 줄이지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2727468a8d8ea18794592843d12955ca0144b622" translate="yes" xml:space="preserve">
          <source>When preprocessing, handle directives, but do not expand macros.</source>
          <target state="translated">사전 처리시 지시문을 처리하지만 매크로를 확장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bb09a7ade548f20e19021a30661ff4362be9b030" translate="yes" xml:space="preserve">
          <source>When printing percentages, 0% and 100% are only printed when the values are &lt;em&gt;exactly&lt;/em&gt; 0% and 100% respectively. Other values which would conventionally be rounded to 0% or 100% are instead printed as the nearest non-boundary value.</source>
          <target state="translated">백분율을 인쇄 할 때 값이 각각 &lt;em&gt;정확히&lt;/em&gt; 0 %와 100 % 인 경우에만 0 %와 100 %가 인쇄됩니다 . 일반적으로 0 % 또는 100 %로 반올림되는 다른 값은 가장 가까운 비 경계 값으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="814abd66e9c273530f2d56ad0a0cd6cc246294fd" translate="yes" xml:space="preserve">
          <source>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</source>
          <target state="translated">최종 바이너리를 생성 할 때 GCC는 바이트 코드가 포함 된 파일에만 링크 타임 최적화를 적용합니다. 따라서 객체 파일과 라이브러리를 GIMPLE 바이트 코드 및 최종 객체 코드와 혼합하고 일치시킬 수 있습니다. GCC는 LTO 모드에서 최적화 할 파일과 추가 처리없이 링크 할 파일을 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b96765bcbef2cdc563af58e2e7b14e500edcf025" translate="yes" xml:space="preserve">
          <source>When profile feedback is available (see</source>
          <target state="translated">프로필 피드백이 제공되는 경우 (참조</target>
        </trans-unit>
        <trans-unit id="21ec7c5b40c9ae6af5acdf4a048ad5c0d3bce4e5" translate="yes" xml:space="preserve">
          <source>When profile feedback is available, via</source>
          <target state="translated">프로필 피드백을 사용할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="2f272057236473f0d19fb086d6183a38dfbd5bad" translate="yes" xml:space="preserve">
          <source>When reading data from memory in sizes shorter than 64 bits, use (do not use) zero-extending load instructions by default, rather than sign-extending ones.</source>
          <target state="translated">메모리에서 64 비트보다 짧은 크기의 데이터를 읽을 때는 부호 확장 명령 대신 기본적으로 0 확장로드 명령을 사용하십시오 (사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="f96511339203319c533d1e5bb317204cec489683" translate="yes" xml:space="preserve">
          <source>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.</source>
          <target state="translated">레지스터 할당 후 스케줄링 할 때는 수퍼 블록 스케줄링을 사용하십시오. 이를 통해 기본 블록 경계를 가로 지르는 모션이 가능 해져 일정이 빨라집니다. 이 옵션은 GCC에서 사용하는 모든 기계 설명이 알고리즘의 신뢰할 수없는 결과를 피할 수있을 정도로 CPU를 모델링하는 것은 아니기 때문에 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="711283accf977e698dde3a25dc400a61116947e3" translate="yes" xml:space="preserve">
          <source>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning.</source>
          <target state="translated">레지스터를 선택할 때 일반적으로 컴퓨터에서 함수 호출로 저장 및 복원되는 것을 선택하십시오. 이렇게하면이 예약을 모르는 코드 (예 : 라이브러리 루틴)가 리턴하기 전에 코드를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="935d1b181ddc0bd3e6f68299a5752f8a09580e76" translate="yes" xml:space="preserve">
          <source>When selecting this option, be aware that the standard library headers do not obey all of these guidelines; use &amp;lsquo;</source>
          <target state="translated">이 옵션을 선택할 때 표준 라이브러리 헤더가 이러한 지침을 모두 준수하지는 않습니다. 사용하다 '</target>
        </trans-unit>
        <trans-unit id="30da98647c378a61b9ead522311838c64d97cf26" translate="yes" xml:space="preserve">
          <source>When supplied with a 128-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a quad-precision ieee floating point value. The sign bit of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 15 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 112 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">128 비트의 첫 번째 인수가 제공되면 &lt;code&gt;scalar_insert_exp&lt;/code&gt; 내장 함수는 쿼드 정밀도 ieee 부동 소수점 값을 리턴합니다. 결과의 부호 비트는 &lt;code&gt;significand&lt;/code&gt; 인수 의 최상위 비트에서 복사됩니다 . 결과의 유효 및 지수 성분은 각각 &lt;code&gt;exponent&lt;/code&gt; 인수 의 최하위 15 비트 및 &lt;code&gt;significand&lt;/code&gt; 인수 의 최하위 112 비트로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82085de4f0e784cd78a6493470847db57c3b16cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;g++&lt;/code&gt; program is used to link a C++ program, it normally automatically links against</source>
          <target state="translated">때 &lt;code&gt;g++&lt;/code&gt; 프로그램은, 그것은 일반적으로 자동으로 링크에 대해 C ++ 프로그램을 연결하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="9d1f5e646a4aa7fceb07c0207db652e826f24dbb" translate="yes" xml:space="preserve">
          <source>When the address-of operator is applied to a thread-local variable, it is evaluated at run time and returns the address of the current thread&amp;rsquo;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.</source>
          <target state="translated">주소 연산자가 스레드 로컬 변수에 적용되면 런타임시 평가되어 해당 변수의 현재 스레드 인스턴스 주소를 리턴합니다. 이렇게 얻은 주소는 모든 스레드에서 사용할 수 있습니다. 스레드가 종료되면 해당 스레드의 스레드 로컬 변수에 대한 포인터가 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="0b679da0a8fd732962aaaa73513d25a32daf4775" translate="yes" xml:space="preserve">
          <source>When the compiled program exits it saves this data to a file called</source>
          <target state="translated">컴파일 된 프로그램이 종료되면이 데이터를</target>
        </trans-unit>
        <trans-unit id="ba14367decd6810d3de98e37ab796a274e5fcb83" translate="yes" xml:space="preserve">
          <source>When the compiler creates the statically allocated constant string object, the &lt;code&gt;c_string&lt;/code&gt; field will be filled by the compiler with the string; the &lt;code&gt;length&lt;/code&gt; field will be filled by the compiler with the string length; the &lt;code&gt;isa&lt;/code&gt; pointer will be filled with &lt;code&gt;NULL&lt;/code&gt; by the compiler, and it will later be fixed up automatically at runtime by the GNU Objective-C runtime library to point to the class which was set by the</source>
          <target state="translated">컴파일러가 정적으로 할당 된 상수 문자열 객체를 만들면 &lt;code&gt;c_string&lt;/code&gt; 필드는 컴파일러에 의해 문자열로 채워집니다. &lt;code&gt;length&lt;/code&gt; 필드는 문자열 길이 컴파일러에 의해 채워집니다; &lt;code&gt;isa&lt;/code&gt; 포인터가 가득합니다 &lt;code&gt;NULL&lt;/code&gt; 에 의해 설정된 클래스에 지점으로 GNU 목표 - C 런타임 라이브러리 런타임에 컴파일러에 의해, 그리고 나중에 자동으로 해결 될 것입니다</target>
        </trans-unit>
        <trans-unit id="75d541d9bedf275908dc64ccacf78982bc497338" translate="yes" xml:space="preserve">
          <source>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &amp;lsquo;</source>
          <target state="translated">컴파일러가 제약 조건을 만족시키기 위해 피연산자를 수정하는 경우 명령에서 읽은 피연산자와 그에 의해 기록 된 피연산자를 알아야합니다. '</target>
        </trans-unit>
        <trans-unit id="fe9038c60a954d7fa872648aae2a7292450a7e26" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the input operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">컴파일러가 입력 피연산자를 나타내는 데 사용할 레지스터를 선택하면 클로버 된 레지스터를 사용하지 않습니다 ( &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;클로버 및 스크래치 레지스터&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fc0664d7c952e60ae422d980b70454766a66b5fe" translate="yes" xml:space="preserve">
          <source>When the compiler selects the registers to use to represent the output operands, it does not use any of the clobbered registers (see &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;).</source>
          <target state="translated">컴파일러가 출력 피연산자를 나타내는 데 사용할 레지스터를 선택하면 클로버 된 레지스터를 사용하지 않습니다 ( &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;클로버 및 스크래치 레지스터&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9af3756142eed3c562da1e3a657ce9b62976062a" translate="yes" xml:space="preserve">
          <source>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</source>
          <target state="translated">컴파일러가 입력 및 출력 피연산자를 나타내는 데 사용할 레지스터를 선택하면 클로버 된 레지스터를 사용하지 않습니다. 그 결과 어셈블러 코드에서 사용하기 위해 클로버 된 레지스터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d75a61bee977e603b0ea8873c523597d8f39fa" translate="yes" xml:space="preserve">
          <source>When the garbage collector is used, the objects are allocated using the so-called typed memory allocation mechanism available in the Boehm-Demers-Weiser collector. This mode requires precise information on where pointers are located inside objects. This information is computed once per class, immediately after the class has been initialized.</source>
          <target state="translated">가비지 수집기를 사용하면 Boehm-Demers-Weiser 수집기에서 사용할 수있는 소위 형식화 된 메모리 할당 메커니즘을 사용하여 개체가 할당됩니다. 이 모드에서는 포인터가 객체 내부에있는 위치에 대한 정확한 정보가 필요합니다. 이 정보는 클래스가 초기화 된 직후 클래스 당 한 번 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ce04df43b58d0607f55d930a3e25d2b0c0d86fd3" translate="yes" xml:space="preserve">
          <source>When the instructions are enabled GCC defines the C preprocessor symbol &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt;, otherwise it defines the symbol &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt;.</source>
          <target state="translated">명령어가 활성화되면 GCC는 C 전 처리기 기호 &lt;code&gt;__RX_ALLOW_STRING_INSNS__&lt;/code&gt; 를 정의하고 그렇지 않으면 &lt;code&gt;__RX_DISALLOW_STRING_INSNS__&lt;/code&gt; 기호를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="237034d602a7895e4b871df52b8d8208437c1b5e" translate="yes" xml:space="preserve">
          <source>When the option</source>
          <target state="translated">옵션이</target>
        </trans-unit>
        <trans-unit id="f59a2028d7f7059c14cfbb4f7cac2e937416cda2" translate="yes" xml:space="preserve">
          <source>When the value of a decimal floating type cannot be represented in the integer type to which it is being converted, the result is undefined rather than the result value specified by the draft technical report.</source>
          <target state="translated">10 진수 부동 유형의 값을 변환 할 정수 유형으로 표시 할 수없는 경우 기술 보고서 ​​초안에서 지정한 결과 값이 아니라 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43dfcc6f2fffee0a3a2515bfa1a37e71e51242de" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 1.</source>
          <target state="translated">이 플래그가 설정되면 매크로 &lt;code&gt;__pic__&lt;/code&gt; 및 &lt;code&gt;__PIC__&lt;/code&gt; 이 1로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="44c57deb401735025dc176c7c63debf58618c2fc" translate="yes" xml:space="preserve">
          <source>When this flag is set, the macros &lt;code&gt;__pic__&lt;/code&gt; and &lt;code&gt;__PIC__&lt;/code&gt; are defined to 2.</source>
          <target state="translated">이 플래그가 설정되면 매크로 &lt;code&gt;__pic__&lt;/code&gt; 및 &lt;code&gt;__PIC__&lt;/code&gt; 이 2로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4a1317c4b8d2af979d94b62164c9d7ecd9184a36" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC inserts &lt;code&gt;MEMW&lt;/code&gt; instructions before &lt;code&gt;volatile&lt;/code&gt; memory references to guarantee sequential consistency. The default is</source>
          <target state="translated">이 옵션이 활성화되면 GCC는 &lt;code&gt;volatile&lt;/code&gt; 메모리 참조 앞에 &lt;code&gt;MEMW&lt;/code&gt; 명령어를 삽입 하여 순차적 일관성을 보장합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="4f8fad713a34ff4dd67014e2a8d65e863876b686" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening is performed. The default is</source>
          <target state="translated">이 옵션을 활성화하면 GCC는 일부 코드 밀도를 희생하면서 분기 페널티를 줄이기 위해 명령어를 자동으로 정렬하도록 어셈블러에 지시합니다. 어셈블러에서는 분기 명령과 호출 명령 다음에 오는 명령을 정렬하기 위해 밀도 명령을 확장하려고합니다. 대상을 정렬하기위한 선행 안전 밀도 명령이 충분하지 않으면 확대가 수행되지 않습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="6aace4cd615149f89dea8fcd082fb55d9878fa43" translate="yes" xml:space="preserve">
          <source>When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct &lt;code&gt;CALL&lt;/code&gt; instruction into an &lt;code&gt;L32R&lt;/code&gt; followed by a &lt;code&gt;CALLX&lt;/code&gt; instruction. The default is</source>
          <target state="translated">이 옵션을 활성화하면 GCC는 직접 통화의 대상이 통화 명령에 의해 허용되는 범위에 있지 않다고 판단 할 수없는 한 직접 통화를 간접 통화로 변환하도록 어셈블러에 지시합니다. 이 변환은 일반적으로 다른 소스 파일에서 함수를 호출 할 때 발생합니다. 특히 어셈블러는 직접 &lt;code&gt;CALL&lt;/code&gt; 명령어를 &lt;code&gt;L32R&lt;/code&gt; 로 변환 한 다음 &lt;code&gt;CALLX&lt;/code&gt; 명령어를 변환 합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="932f419fffb4962ea09a2d68b7d48f6dd70fbe9a" translate="yes" xml:space="preserve">
          <source>When this option is not used, GCC optimizes for the processor specified by</source>
          <target state="translated">이 옵션을 사용하지 않으면 GCC는</target>
        </trans-unit>
        <trans-unit id="d8e1351858aa322f0a55264f24813443d8991eb4" translate="yes" xml:space="preserve">
          <source>When this option is passed to the compiler driver, it causes the &lt;em&gt;first&lt;/em&gt; compilation to be skipped, which makes it useful for little other than debugging the compiler proper.</source>
          <target state="translated">이 옵션이 컴파일러 드라이버에 전달되면 &lt;em&gt;첫 번째&lt;/em&gt; 컴파일이 생략되므로 컴파일러를 올바르게 디버깅하는 것 외에는 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e23f54eaa8f9101922e305be1e7015dd6fc78fe" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">이 버전의 ABI가 활성화되면 C 전 처리기 기호 &lt;code&gt;__V850_GCC_ABI__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2a3a63e7e68adaacd52d22d0fef6ef4e247546c7" translate="yes" xml:space="preserve">
          <source>When this version of the ABI is enabled the C preprocessor symbol &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; is defined.</source>
          <target state="translated">이 버전의 ABI가 활성화되면 C 전 처리기 기호 &lt;code&gt;__V850_RH850_ABI__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ffcbc5063df93d534e3fd1a9be3948f3d608cc53" translate="yes" xml:space="preserve">
          <source>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.</source>
          <target state="translated">지연 슬롯을 채울 때 유효한 라이브 레지스터 정보가있는 블록을 검색 할 때 고려해야 할 최대 명령 수입니다. 임의로 선택한 값을 늘리면보다 적극적인 최적화를 통해 컴파일 시간이 늘어납니다. 제어 흐름 그래프를 유지하기 위해 지연 슬롯 코드를 다시 작성할 때이 매개 변수를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca1100086e04f30d15e50b0b6ef7fef7de69d02a" translate="yes" xml:space="preserve">
          <source>When used as part of the register variable extension, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">레지스터 변수 확장의 일부로 사용되는 경우 &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="106a6c1a466d5af73cd467f48ab954141e8dae1a" translate="yes" xml:space="preserve">
          <source>When used as the pattern of a pack expansion within a template definition, expands to a template argument pack containing integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;length-1&lt;/code&gt;. This is provided for efficient implementation of &lt;code&gt;std::make_integer_sequence&lt;/code&gt;.</source>
          <target state="translated">템플리트 정의 내에서 팩 확장의 패턴으로 사용되는 경우 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;length-1&lt;/code&gt; 사이의 정수를 포함하는 템플리트 인수 팩으로 확장됩니다 . 이것은 &lt;code&gt;std::make_integer_sequence&lt;/code&gt; 의 효율적인 구현을 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="780fee7b38bbbc14d6460730fc730c12ac99a32c" translate="yes" xml:space="preserve">
          <source>When used from GCC without</source>
          <target state="translated">GCC에서 사용하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="0e9e8833e240e4ed56f0fb1a36eb014753411cc2" translate="yes" xml:space="preserve">
          <source>When used in combination with</source>
          <target state="translated">와 함께 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="4ec2dc1132b93e0ccc417d346f716fa8317dce1d" translate="yes" xml:space="preserve">
          <source>When used in combination with the</source>
          <target state="translated">와 함께 사용될 때</target>
        </trans-unit>
        <trans-unit id="7e7b12188944613e3ecc2fd00ed8b819fb8ad2ca" translate="yes" xml:space="preserve">
          <source>When used in conjunction with</source>
          <target state="translated">와 함께 사용될 때</target>
        </trans-unit>
        <trans-unit id="49cb60ae0da0fc7302708101bdf54d1b69871514" translate="yes" xml:space="preserve">
          <source>When used on a struct, or struct member, the &lt;code&gt;aligned&lt;/code&gt; attribute can only increase the alignment; in order to decrease it, the &lt;code&gt;packed&lt;/code&gt; attribute must be specified as well. When used as part of a typedef, the &lt;code&gt;aligned&lt;/code&gt; attribute can both increase and decrease alignment, and specifying the &lt;code&gt;packed&lt;/code&gt; attribute generates a warning.</source>
          <target state="translated">구조체 또는 구조체 멤버에서 사용될 때 &lt;code&gt;aligned&lt;/code&gt; 속성은 정렬 만 증가시킬 수 있습니다. 이를 줄이려면 &lt;code&gt;packed&lt;/code&gt; 속성도 지정해야합니다. typedef의 일부로 사용될 경우 &lt;code&gt;aligned&lt;/code&gt; 속성은 정렬을 늘리거나 줄일 수 있으며 &lt;code&gt;packed&lt;/code&gt; 속성을 지정하면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5e1c3d3ae3ca589eb9e745a2edd3f0de6b0b04" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;interrupt_handler&lt;/code&gt;, &lt;code&gt;exception_handler&lt;/code&gt; or &lt;code&gt;nmi_handler&lt;/code&gt;, code is generated to load the stack pointer from the USP register in the function prologue.</source>
          <target state="translated">&lt;code&gt;interrupt_handler&lt;/code&gt; , &lt;code&gt;exception_handler&lt;/code&gt; 또는 &lt;code&gt;nmi_handler&lt;/code&gt; 와 함께 사용 하면 함수 프롤로그의 USP 레지스터에서 스택 포인터를로드하는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa555d9978b74bbd46ce823e883fc5dc96ece10" translate="yes" xml:space="preserve">
          <source>When used together,</source>
          <target state="translated">함께 사용하면</target>
        </trans-unit>
        <trans-unit id="dd9e3fff8e9f3de600aeb120c0ac434ae6e8fd7f" translate="yes" xml:space="preserve">
          <source>When used with</source>
          <target state="translated">함께 사용될 때</target>
        </trans-unit>
        <trans-unit id="92cecb0d71e3d06f0f2ee726aec0670791ccea60" translate="yes" xml:space="preserve">
          <source>When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at link time. This is known as COMDAT support.</source>
          <target state="translated">GNU / Linux 또는 Solaris 2와 같은 ELF 시스템 또는 Microsoft Windows에서 GNU ld 버전 2.8 이상과 함께 사용하는 경우 이러한 구문의 복제본은 링크 타임에 삭제됩니다. 이것을 COMDAT 지원이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3e4af787046ae7ade38ea86db68f50943f9b708f" translate="yes" xml:space="preserve">
          <source>When used with the driver options</source>
          <target state="translated">드라이버 옵션과 함께 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="c37b9bb49622ff1b2c39fa2ca14e91b87c1c3e6e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;__vector&lt;/code&gt; instead of &lt;code&gt;vector&lt;/code&gt;; for example,</source>
          <target state="translated">사용하는 경우 &lt;code&gt;__vector&lt;/code&gt; 대신 &lt;code&gt;vector&lt;/code&gt; ; 예를 들어</target>
        </trans-unit>
        <trans-unit id="6b2bcfc1c3c9cde870c3782ea70e6faf69a223bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;gcov&lt;/code&gt;, you must first compile your program with a special GCC option &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 를 사용할 때는 먼저 특수 GCC 옵션을 사용하여 프로그램을 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="813ae21e068ea720242cb9123e52a1c2bfc86b90" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vector&lt;/code&gt; in keyword-and-predefine mode; for example,</source>
          <target state="translated">키워드 및 사전 정의 모드에서 &lt;code&gt;vector&lt;/code&gt; 를 사용할 때 ; 예를 들어</target>
        </trans-unit>
        <trans-unit id="5643f8856029d91e0b316af45e590b017e03b023" translate="yes" xml:space="preserve">
          <source>When using &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt;, gcov uses the full pathname of the source files to create an output filename. This can lead to long filenames that can overflow filesystem limits. This option creates names of the form</source>
          <target state="translated">&lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; 를 사용할 때 gcov는 소스 파일의 전체 경로 이름을 사용하여 출력 파일 이름을 만듭니다. 이로 인해 파일 시스템 제한을 초과 할 수있는 긴 파일 이름이 생성 될 수 있습니다. 이 옵션은 양식의 이름을 만듭니다</target>
        </trans-unit>
        <trans-unit id="86e384abcdbbd0ac6dda953fb252a5fa852b9cab" translate="yes" xml:space="preserve">
          <source>When using DWARF Version 4 or higher, type DIEs can be put into their own &lt;code&gt;.debug_types&lt;/code&gt; section instead of making them part of the &lt;code&gt;.debug_info&lt;/code&gt; section. It is more efficient to put them in a separate comdat section since the linker can then remove duplicates. But not all DWARF consumers support &lt;code&gt;.debug_types&lt;/code&gt; sections yet and on some objects &lt;code&gt;.debug_types&lt;/code&gt; produces larger instead of smaller debugging information.</source>
          <target state="translated">DWARF 버전 4 이상을 사용하는 경우, 유형 다이는 자신의에 넣어 수 있습니다 &lt;code&gt;.debug_types&lt;/code&gt; 의 섹션 대신의 그 부분을 만드는 &lt;code&gt;.debug_info&lt;/code&gt; 절을 참조하십시오. 링커가 중복을 제거 할 수 있으므로 별도의 명령 섹션에 배치하는 것이 더 효율적입니다. 그러나 모든 DWARF 소비자가 아직 &lt;code&gt;.debug_types&lt;/code&gt; 섹션을 지원하는 것은 아니며 일부 개체에서 &lt;code&gt;.debug_types&lt;/code&gt; 는 작은 디버깅 정보 대신 더 큰 크기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7fb27cfc2abe0d594f6b16d8710a96a8aeba9d2c" translate="yes" xml:space="preserve">
          <source>When using a reference to volatile, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, if you wish to force a read, cast the reference to an rvalue.</source>
          <target state="translated">휘발성에 대한 참조를 사용할 때 G ++는 동등한 표현식을 휘발성에 대한 액세스로 취급하지 않지만 휘발성에 액세스하지 않는다는 경고를 발행합니다. 이것에 대한 근거는 그렇지 않으면 휘발성 액세스가 발생하는 위치를 결정하는 것이 어려워지고 휘발성 참조를 반환하는 함수의 반환 값을 무시할 수 없다는 것입니다. 다시 한 번 읽어 보려면 참조를 rvalue로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ffb95a64a466d2bd4851566c5320aa64fa40418e" translate="yes" xml:space="preserve">
          <source>When using a type that occupies multiple registers, such as &lt;code&gt;long
long&lt;/code&gt; on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.</source>
          <target state="translated">32 비트 시스템에서 &lt;code&gt;long long&lt;/code&gt; 과 같이 여러 레지스터를 차지하는 유형을 사용하는 경우 레지스터를 분리하여 독립적으로 할당하십시오. 일반적으로 이러한 유형에 대해 더 나은 코드를 생성하지만 디버깅이 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38f792e072335436a4ef70d8d149701336de24f" translate="yes" xml:space="preserve">
          <source>When using any of the register constraints (&lt;code&gt;wa&lt;/code&gt;, &lt;code&gt;wd&lt;/code&gt;, &lt;code&gt;wf&lt;/code&gt;, &lt;code&gt;wg&lt;/code&gt;, &lt;code&gt;wh&lt;/code&gt;, &lt;code&gt;wi&lt;/code&gt;, &lt;code&gt;wj&lt;/code&gt;, &lt;code&gt;wk&lt;/code&gt;, &lt;code&gt;wl&lt;/code&gt;, &lt;code&gt;wm&lt;/code&gt;, &lt;code&gt;wo&lt;/code&gt;, &lt;code&gt;wp&lt;/code&gt;, &lt;code&gt;wq&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;wu&lt;/code&gt;, &lt;code&gt;wv&lt;/code&gt;, &lt;code&gt;ww&lt;/code&gt;, or &lt;code&gt;wy&lt;/code&gt;) that take VSX registers, you must use &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering.</source>
          <target state="translated">VSX를 사용하는 레지스터 제약 조건 ( &lt;code&gt;wa&lt;/code&gt; , &lt;code&gt;wd&lt;/code&gt; , &lt;code&gt;wf&lt;/code&gt; , &lt;code&gt;wg&lt;/code&gt; , &lt;code&gt;wh&lt;/code&gt; , &lt;code&gt;wi&lt;/code&gt; , &lt;code&gt;wj&lt;/code&gt; , &lt;code&gt;wk&lt;/code&gt; , &lt;code&gt;wl&lt;/code&gt; , &lt;code&gt;wm&lt;/code&gt; , &lt;code&gt;wo&lt;/code&gt; , &lt;code&gt;wp&lt;/code&gt; , &lt;code&gt;wq&lt;/code&gt; , &lt;code&gt;ws&lt;/code&gt; , &lt;code&gt;wt&lt;/code&gt; , &lt;code&gt;wu&lt;/code&gt; , &lt;code&gt;wv&lt;/code&gt; , &lt;code&gt;ww&lt;/code&gt; 또는 &lt;code&gt;wy&lt;/code&gt; )을 사용할 때 레지스터를 사용하려면 &lt;code&gt;%x&amp;lt;n&amp;gt;&lt;/code&gt; 을 사용해야합니다올바른 레지스터가 사용되도록 템플릿에서. 그렇지 않으면 Altivec 레지스터가 VSX 레지스터 번호 지정이 필요한 VSX 명령어의 피연산자 인 경우 어셈블리 파일의 레지스터 번호 출력이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c184ccdd41991ac034a44b8741c7f1fabbb85a41" translate="yes" xml:space="preserve">
          <source>When using precompiled headers (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;), this flag causes the dependency-output flags to also list the files from the precompiled header&amp;rsquo;s dependencies. If not specified, only the precompiled header are listed and not the files that were used to create it, because those files are not consulted when a precompiled header is used.</source>
          <target state="translated">미리 컴파일 된 헤더를 사용하는 경우 (참조 &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;미리 컴파일 된 헤더는&lt;/a&gt; ,이 플래그는 미리 컴파일 된 헤더의 종속에서 파일을 나열 종속성 출력 플래그가 발생합니다). 지정하지 않으면 사전 컴파일 된 헤더 만 사용될 때 해당 파일이 참조되지 않으므로 사전 컴파일 된 헤더 만 나열되고 헤더를 작성하는 데 사용 된 파일은 나열되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d73200be5ca0030ca174cac8ec7eb66631895c5" translate="yes" xml:space="preserve">
          <source>When using the GNU linker, it is usually more convenient to pass arguments to linker options using the</source>
          <target state="translated">GNU 링커를 사용할 때 일반적으로 다음을 사용하여 인수를 링커 옵션에 전달하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="07d62f57e8744ee5ede23dc9a1e4cfca2395afa4" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;goto&lt;/code&gt; form of &lt;code&gt;asm&lt;/code&gt;, this section contains the list of all C labels to which the code in the &lt;var&gt;AssemblerTemplate&lt;/var&gt; may jump. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;goto&lt;/code&gt; 의 형태로 &lt;code&gt;asm&lt;/code&gt; ,이 섹션은의 코드되는 모든 C 라벨의 목록이 포함되어 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 가 점프 할 수 있습니다. &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1da9d83d815287fc18f851fe43c98fefdf50af5" translate="yes" xml:space="preserve">
          <source>When you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language; or command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;, for explanations of options for languages related to C. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;, for explanations of options that are meaningful only for C++ programs.</source>
          <target state="translated">C ++ 프로그램을 컴파일 할 때 모든 언어로 프로그램을 컴파일하는 데 사용하는 동일한 명령 행 옵션을 여러 개 지정할 수 있습니다. 또는 C 및 관련 언어에 의미있는 명령 줄 옵션; 또는 C ++ 프로그램에만 의미있는 옵션. 보기 &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;옵션 제어 C 방언을&lt;/a&gt; C. 페이지와 관련된 언어 옵션에 대한 설명은, &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;옵션 제어 C ++ 방언&lt;/a&gt; 에만 C ++ 프로그램을위한 의미있는 옵션에 대한 설명은.</target>
        </trans-unit>
        <trans-unit id="628daae8697f91bc17f481bc0199bf74cc7f3f93" translate="yes" xml:space="preserve">
          <source>When you invoke GCC, it normally does preprocessing, compilation, assembly and linking. The &amp;ldquo;overall options&amp;rdquo; allow you to stop this process at an intermediate stage. For example, the</source>
          <target state="translated">GCC를 호출하면 일반적으로 전처리, 컴파일, 어셈블리 및 링크를 수행합니다. &quot;전체 옵션&quot;을 사용하면 중간 단계에서이 프로세스를 중지 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="dc4bcf9de739295968f25374fa0b9b82393e8d47" translate="yes" xml:space="preserve">
          <source>When you use</source>
          <target state="translated">사용할 때</target>
        </trans-unit>
        <trans-unit id="8bb9a5cb938f4f893dfe56300e7991ff5d9ac371" translate="yes" xml:space="preserve">
          <source>When you use &lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;, the only automatic variables guaranteed to remain valid are those declared &lt;code&gt;volatile&lt;/code&gt;. This is a consequence of automatic register allocation. Consider this function:</source>
          <target state="translated">&lt;code id=&quot;index-longjmp-incompatibilities&quot;&gt;setjmp&lt;/code&gt; 및 &lt;code&gt;longjmp&lt;/code&gt; 를 사용할 때 유효한 것으로 유지되는 유일한 자동 변수는 &lt;code&gt;volatile&lt;/code&gt; 로 선언 된 변수 입니다. 이것은 자동 레지스터 할당의 결과입니다. 이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4f5a87979f362a282d672c1cd391334d27dc161a" translate="yes" xml:space="preserve">
          <source>When you use the</source>
          <target state="translated">사용할 때</target>
        </trans-unit>
        <trans-unit id="cef8b3831d50a66f25ff90c61c375348a6eba6bf" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use the general-purpose constraint letters in &lt;code&gt;asm&lt;/code&gt; arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &amp;lsquo;</source>
          <target state="translated">가능하면 코드를 읽는 사람들에게보다 쉽게 ​​의미를 전달할 수 있으므로 범용 제약 조건 문자를 &lt;code&gt;asm&lt;/code&gt; 인수 로 사용해야합니다 . 실패하면 일반적으로 아키텍처에서 매우 유사한 의미를 갖는 제약 조건 문자를 사용하십시오. 가장 일반적으로 사용되는 제약 조건은 '</target>
        </trans-unit>
        <trans-unit id="3a4007ba3fafc819a7924ea3b2d8632c8709039c" translate="yes" xml:space="preserve">
          <source>Whenever you leave out the alignment factor in an &lt;code&gt;aligned&lt;/code&gt; attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 속성 스펙 에서 정렬 인수를 생략 할 때마다 컴파일러는 유형에 대한 정렬을 컴파일하려는 대상 시스템의 모든 데이터 유형에 사용 된 최대 정렬로 자동 설정합니다. 컴파일러는 이러한 방법으로 정렬 된 유형의 변수에 대해 복사를 수행 할 때 가장 큰 메모리 청크를 복사하는 명령어를 사용할 수 있기 때문에 복사 작업을보다 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08306a1126e7ec7f2d356c52bfc279fbbf71d360" translate="yes" xml:space="preserve">
          <source>Where &lt;var&gt;op&lt;/var&gt; is the name of the instruction. Refer to the ISA manual for the complete list of instructions.</source>
          <target state="translated">여기서 &lt;var&gt;op&lt;/var&gt; 는 명령어 이름입니다. 전체 지침 목록은 ISA 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a66402f17809117f1d29c4b80df406d4e2f11bba" translate="yes" xml:space="preserve">
          <source>Where G++ puts inlines, vtables and such.</source>
          <target state="translated">G ++은 인라인, vtable 등을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="f97bcbccf23129ffc3f54b71abd0f18cfe88a7d0" translate="yes" xml:space="preserve">
          <source>Where none of</source>
          <target state="translated">어디에도없는</target>
        </trans-unit>
        <trans-unit id="18ba47ae48773e2f3f0699ad79e05aa7bd3185d2" translate="yes" xml:space="preserve">
          <source>Where the standard specified with</source>
          <target state="translated">표준으로 지정된 곳</target>
        </trans-unit>
        <trans-unit id="7c95dc097ed9e81e390e81810c6f3d829c025cc5" translate="yes" xml:space="preserve">
          <source>Where the unused arguments lie between used arguments that are specified with &amp;lsquo;</source>
          <target state="translated">사용되지 않은 인수가 '로 지정된 인수 사이에있는 경우</target>
        </trans-unit>
        <trans-unit id="b3e4d8bab3e588a9e2b728940ccf589c5438a70e" translate="yes" xml:space="preserve">
          <source>Where the value in &lt;var&gt;dest&lt;/var&gt; will be the result returned from the built-in.</source>
          <target state="translated">&lt;var&gt;dest&lt;/var&gt; 의 값 은 내장에서 반환 된 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e57ba6952af402ae437a5e3309d0cfb54d03b1f3" translate="yes" xml:space="preserve">
          <source>Where to find header files and libraries. Where to find the compiler executable files.</source>
          <target state="translated">헤더 파일 및 라이브러리를 찾을 수있는 곳 컴파일러 실행 파일을 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="3c00f7db25c9cf9b37e3952008b0e2f58aade5fa" translate="yes" xml:space="preserve">
          <source>Whether a &amp;ldquo;plain&amp;rdquo; &lt;code&gt;int&lt;/code&gt; bit-field is treated as a &lt;code&gt;signed int&lt;/code&gt; bit-field or as an &lt;code&gt;unsigned int&lt;/code&gt; bit-field (C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).</source>
          <target state="translated">&quot;일반&quot; &lt;code&gt;int&lt;/code&gt; 비트 필드가 &lt;code&gt;signed int&lt;/code&gt; 비트 필드 또는 &lt;code&gt;unsigned int&lt;/code&gt; 비트 필드로 처리 되는지 여부 (C90 6.5.2, C90 6.5.2.1, C99 및 C11 6.7.2, C99 및 C11 6.7.2.1 ).</target>
        </trans-unit>
        <trans-unit id="7531059d0a25c98e7ca278e75f82acc76daa9a55" translate="yes" xml:space="preserve">
          <source>Whether a bit-field can straddle a storage-unit boundary (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">비트 필드가 스토리지 장치 경계를 넘어갈 수 있는지 여부 (C90 6.5.2.1, C99 및 C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="fe2aebfc599d584921175261d958d43ef0f0aec0" translate="yes" xml:space="preserve">
          <source>Whether a function in a binary built by one set of tools can call a function in a binary built by a different set of tools is a subset of interoperability.</source>
          <target state="translated">하나의 툴 세트로 빌드 된 바이너리의 함수가 다른 툴 세트로 빌드 된 바이너리의 함수를 호출 할 수 있는지 여부는 상호 운용성의 서브 세트입니다.</target>
        </trans-unit>
        <trans-unit id="c06b8898733d76cc9dce4e56a21efa3845ac1918" translate="yes" xml:space="preserve">
          <source>Whether an argument of class type with a non-trivial copy constructor or destructor can be passed to ... (C++0x 5.2.2).</source>
          <target state="translated">사소하지 않은 복사 생성자 또는 소멸자가있는 클래스 유형의 인수를 ... (C ++ 0x 5.2.2)로 전달할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="f086235b38a936fb8979e808d23b4c24d86f5d9b" translate="yes" xml:space="preserve">
          <source>Whether and how floating expressions are contracted when not disallowed by the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 6.5).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 및 C11 6.5)에서 허용하지 않는 경우 부동 표현식이 축소되는지 여부 및 방법 .</target>
        </trans-unit>
        <trans-unit id="f8840ea94992b3ba6df4412ec15b47848948aba5" translate="yes" xml:space="preserve">
          <source>Whether any extended alignments are supported and the contexts in which they are supported (C11 6.2.8).</source>
          <target state="translated">확장 정렬 지원 여부 및 지원되는 컨텍스트 (C11 6.2.8).</target>
        </trans-unit>
        <trans-unit id="5e7ac927cf9e33f4c488cef419402e9a193f27f2" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted for bit-fields (C11 6.7.2.1).</source>
          <target state="translated">비트 필드에 원자 유형이 허용되는지 여부 (C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="1b73e138d1b7cf4eb52da0986b7749369200c235" translate="yes" xml:space="preserve">
          <source>Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).</source>
          <target state="translated">외부 연결이있는 식별자에서 대소 문자 구분이 중요한지 여부 (C90 6.1.2).</target>
        </trans-unit>
        <trans-unit id="f11ebb9d3de47abc2e0ca0f87e800f9634ac636f" translate="yes" xml:space="preserve">
          <source>Whether codegen errors should be ICEs when</source>
          <target state="translated">다음과 같은 경우 codegen 오류가 ICE 여야하는지 여부</target>
        </trans-unit>
        <trans-unit id="354a46344b75f29340cafb16fbb91450a8587db2" translate="yes" xml:space="preserve">
          <source>Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence (C11 6.4.5).</source>
          <target state="translated">다르게 접두사로 사용되는 넓은 문자열 리터럴 토큰을 연결할 수 있는지 여부에 따라 결과 멀티 바이트 문자 시퀀스 처리 (C11 6.4.5)</target>
        </trans-unit>
        <trans-unit id="3b5528cb4a8a2228a3304685d15fcf34a763a7fb" translate="yes" xml:space="preserve">
          <source>Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">개행 이외의 공백이 아닌 일련의 공백 문자가 변환 단계 3에서 하나의 공백 문자로 유지되거나 대체되는지 여부 (C90, C99 및 C11 5.1.1.2).</target>
        </trans-unit>
        <trans-unit id="599547a438479475d1d2cda798d15d3f35866c27" translate="yes" xml:space="preserve">
          <source>Whether signed integer types are represented using sign and magnitude, two&amp;rsquo;s complement, or one&amp;rsquo;s complement, and whether the extraordinary value is a trap representation or an ordinary value (C99 and C11 6.2.6.2).</source>
          <target state="translated">부호있는 정수 유형이 부호와 크기, 2의 보수 또는 1의 보수를 사용하여 표시되는지 여부와 특별한 값이 트랩 표시인지 또는 일반 값인지 여부 (C99 및 C11 6.2.6.2).</target>
        </trans-unit>
        <trans-unit id="40b6d1461dda1b8f55b388b60612f0a1c5dc15ae" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;inexact&amp;rdquo; floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">반올림 결과가 실제로 IEC 60559 준수 구현 (C99 F.9)의 수학적 결과와 같을 때 &quot;inexact&quot;부동 소수점 예외가 발생할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c1f63f009e459571f2431bd617b7dca64a11adca" translate="yes" xml:space="preserve">
          <source>Whether the &amp;ldquo;underflow&amp;rdquo; (and &amp;ldquo;inexact&amp;rdquo;) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).</source>
          <target state="translated">IEC 60559 준수 구현 (C99 F.9)에서 결과가 작지만 정확하지 않은 경우 &quot;언더 플로우&quot;(및 &quot;inexact&quot;) 부동 소수점 예외가 발생할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="945b6d4fa9a5ecbaf6bafbdb8d0d89ae5b700edc" translate="yes" xml:space="preserve">
          <source>Whether the &amp;lsquo;</source>
          <target state="translated">'여부</target>
        </trans-unit>
        <trans-unit id="bba97b060da98c792876d4d0754d818ca89f0204" translate="yes" xml:space="preserve">
          <source>Whether the compiler should use the &amp;ldquo;canonical&amp;rdquo; type system. Should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.</source>
          <target state="translated">컴파일러가 &quot;표준&quot;유형 시스템을 사용해야하는지 여부 C ++ 및 Objective-C ++에서 유형을 비교하기 위해보다 효율적인 내부 메커니즘을 사용하는 항상 1이어야합니다. 그러나 표준 유형 시스템의 버그로 인해 컴파일이 실패하면이 값을 0으로 설정하여 표준 유형을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="9bf07719435931f48daf3148b7f591b08eee6622" translate="yes" xml:space="preserve">
          <source>Whether the loop array prefetch pass should issue software prefetch hints for strides that are non-constant. In some cases this may be beneficial, though the fact the stride is non-constant may make it hard to predict when there is clear benefit to issuing these hints.</source>
          <target state="translated">루프 배열 프리 페치 패스가 일정하지 않은 보폭에 대해 소프트웨어 프리 페치 힌트를 발행해야하는지 여부 보폭이 일정하지 않다는 사실이 이러한 힌트를 발행 할 때 분명한 이점이 있는지 예측하기가 어려울 수 있지만 경우에 따라이 방법이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3783705a05be7fc566fd28d14a20893e46a49fb1" translate="yes" xml:space="preserve">
          <source>Whether the value of a character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">조건부 포함을 제어하는 ​​상수 표현식의 문자 상수 값이 실행 문자 세트 (C90 6.8.1, C99 및 C11 6.10.1)에서 동일한 문자 상수 값과 일치하는지 여부</target>
        </trans-unit>
        <trans-unit id="c36d4d5da07291b1b8267749102489e31d3d638e" translate="yes" xml:space="preserve">
          <source>Whether the value of a single-character character constant in a constant expression that controls conditional inclusion may have a negative value (C90 6.8.1, C99 and C11 6.10.1).</source>
          <target state="translated">조건부 포함을 제어하는 ​​상수 표현식에서 단일 문자 문자 상수 값이 음수 값을 가질 수 있는지 여부 (C90 6.8.1, C99 및 C11 6.10.1).</target>
        </trans-unit>
        <trans-unit id="9cb3bdf69d2ad24cba5875ebe4f0cafed80a2719" translate="yes" xml:space="preserve">
          <source>Which additional multibyte characters may appear in identifiers and their correspondence to universal character names (C99 and C11 6.4.2).</source>
          <target state="translated">식별자에 나타날 수있는 추가 멀티 바이트 문자 및 범용 문자 이름 (C99 및 C11 6.4.2)과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d42124c28b1baab39d06e79c2e6fbc80bcb8c3b0" translate="yes" xml:space="preserve">
          <source>Which of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; has the same range, representation, and behavior as &amp;ldquo;plain&amp;rdquo; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 중 &quot;일반&quot; &lt;code&gt;char&lt;/code&gt; (C90 6.1.2.5, C90 6.2.1.1, C99 및 C11 6.2.5, C99 및 C11 6.3.1.1)와 동일한 범위, 표현 및 동작을 갖는 문자 는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a3f8e01950ee5a5eeec136d809212bfccead4676" translate="yes" xml:space="preserve">
          <source>Which problems in your code get warnings, and which get errors.</source>
          <target state="translated">코드에서 어떤 문제가 경고를 받고 어떤 오류가 발생합니까</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="78cfea135064bce5a81b5bd15458f3f64f56702d" translate="yes" xml:space="preserve">
          <source>While it is possible to leave the function undefined and thus invoke a link failure (to define the function with a message in &lt;code&gt;.gnu.warning*&lt;/code&gt; section), when using these attributes the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information.</source>
          <target state="translated">함수를 정의하지 않은 상태로두고 링크 실패 ( &lt;code&gt;.gnu.warning*&lt;/code&gt; 섹션에 메시지로 함수를 정의하기 위해)를 호출 할 수 있지만 , 이러한 속성을 사용할 때 문제는 이전에 정확한 호출 위치로 진단됩니다. 인라인 함수의 존재 또는 디버깅 정보를 방출하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="652d59cea2004903b4f313a4a1b258897728e71e" translate="yes" xml:space="preserve">
          <source>While the compiler is aware of changes to entries listed in the output operands, the inline &lt;code&gt;asm&lt;/code&gt; code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</source>
          <target state="translated">컴파일러는 출력 피연산자에 나열된 항목의 변경 사항을 알고 있지만 인라인 &lt;code&gt;asm&lt;/code&gt; 코드는 출력 이상을 수정할 수 있습니다. 예를 들어, 계산에는 추가 레지스터가 필요하거나 프로세서가 특정 어셈블러 명령어의 부작용으로 레지스터를 덮어 쓸 수 있습니다. 컴파일러에 이러한 변경 사항을 알리려면 클로버 목록에 해당 변경 사항을 나열하십시오. 클로버 목록 항목은 레지스터 이름 또는 특수 클로버 (아래에 나열)입니다. 각 클로버 목록 항목은 큰 따옴표로 묶고 쉼표로 구분 된 문자열 상수입니다.</target>
        </trans-unit>
        <trans-unit id="e21fa2c7a90a60eea68201dc97480d9a5390c69c" translate="yes" xml:space="preserve">
          <source>While the uses of &lt;code&gt;asm&lt;/code&gt; are many and varied, it may help to think of an &lt;code&gt;asm&lt;/code&gt; statement as a series of low-level instructions that convert input parameters to output parameters. So a simple (if not particularly useful) example for i386 using &lt;code&gt;asm&lt;/code&gt; might look like this:</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 의 사용법은 다양하고 다양하지만 &lt;code&gt;asm&lt;/code&gt; 문을 입력 매개 변수를 출력 매개 변수로 변환하는 일련의 저수준 명령어 로 생각하면 도움이 될 수 있습니다 . 따라서 &lt;code&gt;asm&lt;/code&gt; 을 사용하는 i386의 간단한 (특히 유용하지 않은 경우) 예제 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39d000e8aa5910f6d9ef12595235838dbefbbb8c" translate="yes" xml:space="preserve">
          <source>While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with</source>
          <target state="translated">SSA 표현에서 프로그램을 변환하는 동안 컴파일러 임시 대신 다른 사용자 정의 변수 버전을 통합하여 복사를 줄이십시오. 이로 인해 컴파일 된 최적화 된 프로그램을 디버깅하는 기능이 심각하게 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e29563eb1f68f27cd54dba1d78ec9cc5f02f0e" translate="yes" xml:space="preserve">
          <source>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers.</source>
          <target state="translated">공백 문자는 무시되며 첫 문자를 제외한 모든 위치에 삽입 할 수 있습니다. 이를 통해 서로 다른 수의 제약 조건과 수정자가있는 경우에도 서로 다른 피연산자에 대한 각 대안을 기계 설명에 시각적으로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45faa4599697b06106508c630a671752d1b455fb" translate="yes" xml:space="preserve">
          <source>Wint-to-pointer-cast</source>
          <target state="translated">Wint-to-pointer-cast</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="db41302cf4b363b4a1378448e9a36c920e1a7fca" translate="yes" xml:space="preserve">
          <source>With both</source>
          <target state="translated">둘다</target>
        </trans-unit>
        <trans-unit id="a29e68e9d153083133283a2db9d7b73482a032a4" translate="yes" xml:space="preserve">
          <source>With extended &lt;code&gt;asm&lt;/code&gt; you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended &lt;code&gt;asm&lt;/code&gt; syntax uses colons (&amp;lsquo;</source>
          <target state="translated">확장 &lt;code&gt;asm&lt;/code&gt; 을 사용하면 어셈블러에서 C 변수를 읽고 쓸 수 있으며 어셈블러 코드에서 C 레이블로 점프를 수행 할 수 있습니다. 확장 &lt;code&gt;asm&lt;/code&gt; 구문은 콜론 ( '</target>
        </trans-unit>
        <trans-unit id="b2027ec70d531c569c806c46a0ed0d35bbfbe374" translate="yes" xml:space="preserve">
          <source>With no modifiers, this is what the output from the operands would be for the &amp;lsquo;</source>
          <target state="translated">수정자가 없으면 피연산자의 출력이 '</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="translated">와 더불어</target>
        </trans-unit>
        <trans-unit id="9cd37ca8139ba8f0077df8728d69e1509b46cb93" translate="yes" xml:space="preserve">
          <source>With the GNU C++ front end, for x86 targets, you may specify multiple versions of a function, where each function is specialized for a specific target feature. At runtime, the appropriate version of the function is automatically executed depending on the characteristics of the execution platform. Here is an example.</source>
          <target state="translated">x86 대상의 경우 GNU C ++ 프론트 엔드를 사용하여 여러 버전의 기능을 지정할 수 있습니다. 각 기능은 특정 대상 기능에 특화되어 있습니다. 런타임시, 적절한 버전의 기능이 실행 플랫폼의 특성에 따라 자동으로 실행됩니다. 다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="872450a8fc748ddfde2cdc81d3d1bdedfaa16509" translate="yes" xml:space="preserve">
          <source>With the GNU runtime, exceptions are always implemented as &amp;ldquo;native&amp;rdquo; exceptions and it is recommended that the</source>
          <target state="translated">GNU 런타임의 경우 예외는 항상 &quot;기본&quot;예외로 구현되므로 다음을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="ede352de48f14dbfe64db09513e522c73f079435" translate="yes" xml:space="preserve">
          <source>With the NeXT runtime, although currently designed to be binary compatible with &lt;code&gt;NS_HANDLER&lt;/code&gt;-style idioms provided by the &lt;code&gt;NSException&lt;/code&gt; class, the new exceptions can only be used on Mac OS X 10.3 (Panther) and later systems, due to additional functionality needed in the NeXT Objective-C runtime.</source>
          <target state="translated">NeXT 런타임을 사용하면 현재 &lt;code&gt;NSException&lt;/code&gt; 클래스에서 제공하는 &lt;code&gt;NS_HANDLER&lt;/code&gt; 스타일 관용구 와 바이너리 호환 가능하도록 설계되었지만 NeXT 에 필요한 추가 기능으로 인해 새로운 예외는 Mac OS X 10.3 (Panther) 이상 시스템에서만 사용할 수 있습니다 Objective-C 런타임.</target>
        </trans-unit>
        <trans-unit id="dab61d2e9aaa3623f28b2c32d76967b2c680ed03" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one &lt;var&gt;storage-class-specifier&lt;/var&gt; shall appear in a given &lt;var&gt;decl-specifier-seq&lt;/var&gt;. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers. [&amp;hellip;]</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 를 제외 하고, 지정된 &lt;var&gt;decl-specifier-seq&lt;/var&gt; 에 최대 하나의 &lt;var&gt;storage-class-specifier&lt;/var&gt; 자가 나타납니다 . &lt;code&gt;__thread&lt;/code&gt; 의 지정은 단독으로 사용하거나 바로 다음 될 수 &lt;code&gt;extern&lt;/code&gt; 이나 &lt;code&gt;static&lt;/code&gt; 지정자를. [&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="292a47839ebc29dbb70ec7b25cc162b60e68673e" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;__thread&lt;/code&gt;, at most one storage-class specifier may be given [&amp;hellip;]. The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, or immediately following &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 를 제외 하고 최대 하나의 스토리지 클래스 지정자에 [&amp;hellip;]를 지정할 수 있습니다. &lt;code&gt;__thread&lt;/code&gt; 의 지정은 다음 즉시 단독으로 사용하거나 할 수있다 &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3f5b76de67732f25dfbe9b7ab3c5b977a603b2" translate="yes" xml:space="preserve">
          <source>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error.</source>
          <target state="translated">아래에 설명 된 표준 C 라이브러리 함수와 같은 라이브러리가 있거나 라이브러리 호출로 확장되는 내장 기능을 제외하고 GCC 내장 기능은 항상 인라인으로 확장되므로 해당 진입 점이 없으므로 해당 주소를 사용할 수 없습니다. 획득. 함수 호출 이외의 표현식에서 이들을 사용하려고하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e736ee71288d11d1b230f0b89bdd35b5282b45ac" translate="yes" xml:space="preserve">
          <source>With the latter choice the options</source>
          <target state="translated">후자의 선택으로 옵션</target>
        </trans-unit>
        <trans-unit id="a6637ce41dda1dbfc19245d823fa7fce4d91f90f" translate="yes" xml:space="preserve">
          <source>With the linker plugin enabled, the linker extracts the needed GIMPLE files from</source>
          <target state="translated">링커 플러그인을 사용하면 링커에서 필요한 GIMPLE 파일을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="8b0e7753b83f2f64fc1212f98878b05c847daa5e" translate="yes" xml:space="preserve">
          <source>With the specification of an output file, the output is appended to the named file, and it looks like this:</source>
          <target state="translated">출력 파일을 지정하면 출력이 명명 된 파일에 추가되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51ee435d4a40a1b09c0e1be2e1a80aec4607b86e" translate="yes" xml:space="preserve">
          <source>With this interface, &lt;code&gt;wait&lt;/code&gt;&amp;rsquo;s implementation might look like this:</source>
          <target state="translated">이 인터페이스를 사용하면 &lt;code&gt;wait&lt;/code&gt; 구현이 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="901e3b5288c53d25410e3fbe70a050954297b494" translate="yes" xml:space="preserve">
          <source>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.</source>
          <target state="translated">이 옵션을 사용하면 루프를 풀 때 컴파일러에서 일부 로컬 변수의 사본을 여러 개 만들어 우수한 코드를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8a418995461de4210630163f948f5da9423e89" translate="yes" xml:space="preserve">
          <source>With this option, the compiler turns the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call into a diagnostics message call instead. When reaching the &lt;code&gt;__builtin_unreachable&lt;/code&gt; call, the behavior is undefined.</source>
          <target state="translated">이 옵션을 사용하면 컴파일러는 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 호출을 진단 메시지 호출로 바꿉니다 . &lt;code&gt;__builtin_unreachable&lt;/code&gt; 호출 에 도달하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="756db1c4a886455bb3e77429e2aacb2477c5e4e1" translate="yes" xml:space="preserve">
          <source>With this pragma, the programmer asserts that there are no loop-carried dependencies which would prevent consecutive iterations of the following loop from executing concurrently with SIMD (single instruction multiple data) instructions.</source>
          <target state="translated">이 pragma를 사용하면 프로그래머는 다음 루프의 연속 반복이 SIMD (단일 명령 다중 데이터) 명령과 동시에 실행되지 못하게하는 루프 전달 종속성이 없다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="a8d9a31f26b7d1b3f16e1e66c83efb3ffbd755c5" translate="yes" xml:space="preserve">
          <source>Within either execution environment, a &lt;em&gt;thread&lt;/em&gt; is a flow of control within a program. It is implementation defined whether or not there may be more than one thread associated with a program. It is implementation defined how threads beyond the first are created, the name and type of the function called at thread startup, and how threads may be terminated. However, objects with thread storage duration shall be initialized before thread startup.</source>
          <target state="translated">각 실행 환경에서 &lt;em&gt;스레드&lt;/em&gt; 는 프로그램 내의 제어 흐름입니다. 프로그램과 연관된 둘 이상의 스레드가있을 수 있는지 여부가 정의 된 구현입니다. 첫 번째 이후의 스레드가 작성되는 방법, 스레드 시작시 호출 된 함수의 이름 및 유형, 스레드가 종료되는 방법을 정의한 구현입니다. 그러나 스레드 저장 기간이있는 객체는 스레드 시작 전에 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e894809a49c1ed8c2eb1cfd50b560eb03dca15f" translate="yes" xml:space="preserve">
          <source>Within the body of &lt;code&gt;T::fn&lt;/code&gt;, &lt;var&gt;this&lt;/var&gt; has the effective definition &lt;code&gt;T *__restrict__ const this&lt;/code&gt;. Notice that the interpretation of a &lt;code&gt;__restrict__&lt;/code&gt; member function qualifier is different to that of &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt; qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers.</source>
          <target state="translated">의 몸 안에서 &lt;code&gt;T::fn&lt;/code&gt; , &lt;var&gt;this&lt;/var&gt; 유효 정의가 &lt;code&gt;T *__restrict__ const this&lt;/code&gt; . &lt;code&gt;__restrict__&lt;/code&gt; 멤버 함수 한정자 의 해석은 객체가 아닌 포인터에 적용된다는 점에서 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;volatile&lt;/code&gt; 한정자와 해석 이 다릅니다 . 이것은 제한된 포인터를 구현하는 다른 컴파일러와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="06d91320f48b09da02ef917261dcfd59521156ff" translate="yes" xml:space="preserve">
          <source>Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this are output potentially unaligned at the next fitting location.</source>
          <target state="translated">값을 지정하지 않으면 모든 구조 부재를 구멍없이 함께 포장하십시오. 값이 지정되면 (2의 작은 거듭 제곱이어야 함) 최대 정렬 (즉, 기본 정렬 요구 사항이 이보다 큰 객체)이 다음 피팅 위치에서 정렬되지 않은 출력을 나타내는이 값에 따라 구조 멤버를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="4610e8cd3674760f9e34246c3335f6375dea470e" translate="yes" xml:space="preserve">
          <source>Without any optimization option, the compiler&amp;rsquo;s goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</source>
          <target state="translated">최적화 옵션이 없으면 컴파일러의 목표는 컴파일 비용을 줄이고 디버깅 결과가 예상되는 것입니다. 명령문은 독립적입니다. 명령문 사이에 중단 점이있는 프로그램을 중지하면 변수에 새 값을 지정하거나 함수의 다른 명령문으로 프로그램 카운터를 변경하고 소스 코드에서 예상 한 결과를 정확하게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d4a33aae2a07ecc8c812bfec17c5e5d451e08a" translate="yes" xml:space="preserve">
          <source>Without the specification of an output file, the output looks like this:</source>
          <target state="translated">출력 파일을 지정하지 않으면 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f36069c670576f1745c3bcd64036649a26fba3f" translate="yes" xml:space="preserve">
          <source>Without this option, &amp;lsquo;</source>
          <target state="translated">이 옵션이 없으면 '</target>
        </trans-unit>
        <trans-unit id="810b49b99b225fdb366e04ce850176fc78b9dace" translate="yes" xml:space="preserve">
          <source>Without this option, the &lt;code&gt;X&lt;/code&gt; register may be used in the same way as &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;Z&lt;/code&gt; which then is emulated by additional instructions. For example, loading a value with &lt;code&gt;X+const&lt;/code&gt; addressing with a small non-negative &lt;code&gt;const &amp;lt; 64&lt;/code&gt; to a register &lt;var&gt;Rn&lt;/var&gt; is performed as</source>
          <target state="translated">이 옵션이 없으면 &lt;code&gt;X&lt;/code&gt; 레지스터는 &lt;code&gt;Y&lt;/code&gt; 또는 &lt;code&gt;Z&lt;/code&gt; 와 같은 방식으로 사용될 수 있으며 추가 명령으로 에뮬레이션됩니다. 예를 들어, 작은 음이 아닌 &lt;code&gt;const &amp;lt; 64&lt;/code&gt; 를 갖는 &lt;code&gt;X+const&lt;/code&gt; 어드레싱 값을 레지스터 &lt;var&gt;Rn&lt;/var&gt; 에로드하는 것은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7069fd8666957ba9eac9efad054fa1d2f74644" translate="yes" xml:space="preserve">
          <source>Work around a bug in the &lt;code&gt;muls&lt;/code&gt; and &lt;code&gt;mulu&lt;/code&gt; instructions for CPU models where it applies. This option is active by default.</source>
          <target state="translated">적용되는 CPU 모델 에 대한 &lt;code&gt;muls&lt;/code&gt; 및 &lt;code&gt;mulu&lt;/code&gt; 명령어 의 버그를 해결하십시오 . 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9517982144bf04b0b47a4d85a09581d177ba1cbb" translate="yes" xml:space="preserve">
          <source>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the &lt;code&gt;hbrp&lt;/code&gt; instruction to make sure this stall won&amp;rsquo;t happen.</source>
          <target state="translated">SPU가 무기한 정지되는 하드웨어 버그를 해결하십시오. 기본적으로 GCC는이 &lt;code&gt;hbrp&lt;/code&gt; 이 발생하지 않도록 hbrp 명령어를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="8c4b8e3f13ae11240c809eb84fd3edb5d1bba62a" translate="yes" xml:space="preserve">
          <source>Work around certain R10000 errata:</source>
          <target state="translated">특정 R10000 정오표를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="9074be04c7616416ed213f212eeb7c6c7c183d4c" translate="yes" xml:space="preserve">
          <source>Work around certain R4000 CPU errata:</source>
          <target state="translated">특정 R4000 CPU 정오표를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="fd709a4ced203846b02db64672dd131b123d5504" translate="yes" xml:space="preserve">
          <source>Work around certain R4400 CPU errata:</source>
          <target state="translated">특정 R4400 CPU 정오표를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="9c76802dfaf86b35388bb6eac2a9a428f20a7a39" translate="yes" xml:space="preserve">
          <source>Work around certain SB-1 CPU core errata. (This flag currently works around the SB-1 revision 2 &amp;ldquo;F1&amp;rdquo; and &amp;ldquo;F2&amp;rdquo; floating-point errata.)</source>
          <target state="translated">특정 SB-1 CPU 코어 정오표를 해결하십시오. (이 플래그는 현재 SB-1 개정 2 &quot;F1&quot;및 &quot;F2&quot;부동 소수점 정오표에서 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="f1322c2c26c7f8a2ae0c4abcf920ab6e36d8883e" translate="yes" xml:space="preserve">
          <source>Work around certain VR4120 errata:</source>
          <target state="translated">특정 VR4120 정오표를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="70f65ee28d3f60e1570e5c0565d3bacdc0372408" translate="yes" xml:space="preserve">
          <source>Work around the 24K E48 (lost data on stores during refill) errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">24K E48 (리필 중 매장에서 손실 된 데이터) 오류를 해결하십시오. 해결 방법은 GCC가 아닌 어셈블러에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="eecdf3e0ad9c1e4373885008c446ef1d15e0de5a" translate="yes" xml:space="preserve">
          <source>Work around the RM7000 &lt;code&gt;dmult&lt;/code&gt;/&lt;code&gt;dmultu&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC.</source>
          <target state="translated">RM7000 &lt;code&gt;dmult&lt;/code&gt; / &lt;code&gt;dmultu&lt;/code&gt; errata를 해결하십시오. 해결 방법은 GCC가 아닌 어셈블러에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f514e8f6d3c8232406871016402b0b519b9f1bff" translate="yes" xml:space="preserve">
          <source>Work around the VR4130 &lt;code&gt;mflo&lt;/code&gt;/&lt;code&gt;mfhi&lt;/code&gt; errata. The workarounds are implemented by the assembler rather than by GCC, although GCC avoids using &lt;code&gt;mflo&lt;/code&gt; and &lt;code&gt;mfhi&lt;/code&gt; if the VR4130 &lt;code&gt;macc&lt;/code&gt;, &lt;code&gt;macchi&lt;/code&gt;, &lt;code&gt;dmacc&lt;/code&gt; and &lt;code&gt;dmacchi&lt;/code&gt; instructions are available instead.</source>
          <target state="translated">VR4130 &lt;code&gt;mflo&lt;/code&gt; / &lt;code&gt;mfhi&lt;/code&gt; errata를 해결하십시오. GCC 사용 피할 수 있지만 해결 방법은, 어셈블러보다는 GCC에 의해 구현되는 &lt;code&gt;mflo&lt;/code&gt; 와 &lt;code&gt;mfhi&lt;/code&gt; 을 VR4130의 경우 &lt;code&gt;macc&lt;/code&gt; , &lt;code&gt;macchi&lt;/code&gt; , &lt;code&gt;dmacc&lt;/code&gt; 및 &lt;code&gt;dmacchi&lt;/code&gt; 지침 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a937c64e2a5b7eba62b666d7ca837eb48731984" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into Y.</source>
          <target state="translated">&lt;var&gt;src1&lt;/var&gt; 을 Y에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b99c5ddd130a32b9357572f70d99408237dc24f1" translate="yes" xml:space="preserve">
          <source>Write &lt;var&gt;src1&lt;/var&gt; into the least significant half of X and &lt;var&gt;src2&lt;/var&gt; into the most significant half of X.</source>
          <target state="translated">X의 최하위 반에 &lt;var&gt;src1&lt;/var&gt; 을 쓰고 X의 최상위 반에 &lt;var&gt;src2&lt;/var&gt; 를 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="282a09ed773c8ef9852a2c6377ed12597d3a9c69" translate="yes" xml:space="preserve">
          <source>Write a SRCFILE.opt-record.json.gz file detailing what optimizations were performed, for those optimizations that support</source>
          <target state="translated">지원하는 최적화를 위해 수행 된 최적화를 자세히 설명하는 SRCFILE.opt-record.json.gz 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="40d1ca8852e0dec6c7d4fad7e6bc0514fe5d1c54" translate="yes" xml:space="preserve">
          <source>Write branch frequencies as the number of branches taken, rather than the percentage of branches taken.</source>
          <target state="translated">분기 빈도를 분기 수가 아닌 분기 수로 적습니다.</target>
        </trans-unit>
        <trans-unit id="1423ee2af8243360b137ebe26d7ad382ca0b3b1e" translate="yes" xml:space="preserve">
          <source>Write branch frequencies to the output file, and write branch summary info to the standard output. This option allows you to see how often each branch in your program was taken. Unconditional branches will not be shown, unless the</source>
          <target state="translated">분기 주파수를 출력 파일에 쓰고 분기 요약 정보를 표준 출력에 씁니다. 이 옵션을 사용하면 프로그램의 각 분기가 얼마나 자주 수행되었는지 확인할 수 있습니다. 무조건 분기는 표시되지 않는 한 표시되지 않습니다</target>
        </trans-unit>
        <trans-unit id="1fecc6871d15f561a1a398ebd76fa3a7a1663e9e" translate="yes" xml:space="preserve">
          <source>Write counts in human readable format (like 24.6k).</source>
          <target state="translated">사람이 읽을 수있는 형식 (예 : 24.6k)으로 쓰기 수</target>
        </trans-unit>
        <trans-unit id="e00e26a5662df1b01236462f99618d8089824cf9" translate="yes" xml:space="preserve">
          <source>Write individual execution counts for every basic block. Normally gcov outputs execution counts only for the main blocks of a line. With this option you can determine if blocks within a single line are not being executed.</source>
          <target state="translated">모든 기본 블록에 대한 개별 실행 횟수를 씁니다. 일반적으로 gcov는 라인의 메인 블록에 대해서만 실행 횟수를 출력합니다. 이 옵션을 사용하면 한 줄 내의 블록이 실행되고 있지 않은지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b79e5dd909fed4a63697002ecabe6d4fcefd2b" translate="yes" xml:space="preserve">
          <source>Write the name of each function into the text section, directly preceding the function prologue. The generated code is similar to this:</source>
          <target state="translated">함수 프롤로그 바로 앞에 텍스트 섹션에 각 함수의 이름을 쓰십시오. 생성 된 코드는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2c144edd2dd673b9ae13db81c4f7c41356844426" translate="yes" xml:space="preserve">
          <source>XER[CA]</source>
          <target state="translated">XER[CA]</target>
        </trans-unit>
        <trans-unit id="edd05eca97855bc49145e43cb3ab5438e61cd98b" translate="yes" xml:space="preserve">
          <source>XOP instructions.</source>
          <target state="translated">XOP 명령어.</target>
        </trans-unit>
        <trans-unit id="e69dd5b634eb9535ab5de7682e5d1e10df284ccf" translate="yes" xml:space="preserve">
          <source>Xstormy16&amp;mdash;</source>
          <target state="translated">Xstormy16&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8341de0a85a327eb2d7c97b77086eb0bff937ecb" translate="yes" xml:space="preserve">
          <source>Xtensa&amp;mdash;</source>
          <target state="translated">Xtensa&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cbfadbe232364f5b4cd1f9250a9cda7fadbb0042" translate="yes" xml:space="preserve">
          <source>You can additionally specify a string parameter: &amp;lsquo;</source>
          <target state="translated">문자열 매개 변수를 추가로 지정할 수 있습니다. '</target>
        </trans-unit>
        <trans-unit id="37f047474bb2991bbc870836a4b1dc7ea6a7e179" translate="yes" xml:space="preserve">
          <source>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here:</source>
          <target state="translated">아래 설명과 같이 C ++에서는 위험하지만 배열을 구성 할 수도 있습니다. 복합 리터럴의 모든 요소가 정적 저장 기간의 객체의 이니셜 라이저에 사용하기에 적합한 간단한 상수 표현식으로 구성된 경우 복합 리터럴은 첫 번째 요소에 대한 포인터로 강제 변환되어 이러한 초기화 프로그램에서 사용될 수 있습니다. 여기에 표시된대로 :</target>
        </trans-unit>
        <trans-unit id="7e3923b44bbc7d66662628b3637d89fe21e428bc" translate="yes" xml:space="preserve">
          <source>You can also include type attributes in a &lt;code&gt;typedef&lt;/code&gt; declaration. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 선언 에 유형 속성을 포함시킬 수도 있습니다 . &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36aaae0a5a83266e8e76c432773d2ebb3588799" translate="yes" xml:space="preserve">
          <source>You can also override the ARM and Thumb mode for each function by using the &lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; and &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;target(&quot;thumb&quot;)&lt;/code&gt; 및 &lt;code&gt;target(&quot;arm&quot;)&lt;/code&gt; 함수 속성 ( &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM 함수 속성&lt;/a&gt; 참조 ) 또는 pragma ( &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;함수 특정 옵션 Pragma&lt;/a&gt; 참조) 를 사용하여 각 함수에 대한 ARM 및 Thumb 모드를 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70f9f23d58cf9ce6f889493d1bc7a0c90625f3a7" translate="yes" xml:space="preserve">
          <source>You can also record the return value of that function call, and later return that value, without knowing what data type the function tried to return (as long as your caller expects that data type).</source>
          <target state="translated">또한 호출자가 해당 데이터 유형을 예상하는 한 함수가 어떤 데이터 유형을 리턴하려고했는지 몰라도 해당 함수 호출의 리턴 값을 기록한 후 나중에 해당 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1165641e4d4b9af84b909635ee9d9e9c442957c3" translate="yes" xml:space="preserve">
          <source>You can also set the fpu name at function level by using the &lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; function attributes (see &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;) or pragmas (see &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;Function Specific Option Pragmas&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;target(&quot;fpu=&quot;)&lt;/code&gt; 함수 속성 ( &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM 함수 속성&lt;/a&gt; 참조 ) 또는 pragma ( &lt;a href=&quot;function-specific-option-pragmas#Function-Specific-Option-Pragmas&quot;&gt;함수 특정 옵션 Pragmas&lt;/a&gt; 참조) 를 사용하여 함수 수준에서 fpu 이름을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7268dd0eaeb17935e5094a8029ba22d93c31a1ac" translate="yes" xml:space="preserve">
          <source>You can also specify</source>
          <target state="translated">지정할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="08bf03c9c6ff7624c857011e74954c5c6f9f4300" translate="yes" xml:space="preserve">
          <source>You can also specify the alignment of structure fields. For example, to create a double-word aligned &lt;code&gt;int&lt;/code&gt; pair, you could write:</source>
          <target state="translated">구조 필드의 정렬을 지정할 수도 있습니다. 예를 들어, 이중 단어로 정렬 된 &lt;code&gt;int&lt;/code&gt; 쌍 을 만들려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="282b6d022cb9c27fb3bb9103220d6eb51129f71a" translate="yes" xml:space="preserve">
          <source>You can also use attributes to control memory placement, code generation options or call/return conventions within the function being annotated. Many of these attributes are target-specific. For example, many targets support attributes for defining interrupt handler functions, which typically must follow special register usage and return conventions. Such attributes are described in the subsection for each target. However, a considerable number of attributes are supported by most, if not all targets. Those are described in the &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt; section.</source>
          <target state="translated">속성을 사용하여 주석을 달고있는 함수 내에서 메모리 배치, 코드 생성 옵션 또는 호출 / 반환 규칙을 제어 할 수 있습니다. 이러한 속성 중 다수는 대상별로 다릅니다. 예를 들어, 많은 대상은 일반적으로 특수 레지스터 사용 및 반환 규칙을 따라야하는 인터럽트 처리기 함수를 정의하기위한 특성을 지원합니다. 이러한 속성은 각 대상의 하위 섹션에 설명되어 있습니다. 그러나 모든 대상이 아닌 경우 대부분의 속성이 지원됩니다. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성&lt;/a&gt; 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="972bfbc14b560aee91d8b7d5cfbc635d959441aa" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;asm&lt;/code&gt; keyword to override the assembler name for a C symbol, or to place a C variable in a specific register.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 키워드를 사용하여 C 심볼의 어셈블러 이름을 재정의하거나 C 변수를 특정 레지스터에 배치 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="354710c3fd8ed8d70c6d2f210156da0243dc4ade" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;nocf_check&lt;/code&gt; attribute to identify which functions and calls should be skipped from instrumentation (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; 속성을 사용하여 계측에서 건너 뛸 기능 및 호출을 식별 할 수도 있습니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d1c6ca2bbbe80bcabecefea25be4aa8fafd6e4d0" translate="yes" xml:space="preserve">
          <source>You can also use the union cast as a function argument:</source>
          <target state="translated">유니언 캐스트를 함수 인수로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b750e5491b307807c28732748047266dbd8e2a" translate="yes" xml:space="preserve">
          <source>You can also use variable-length arrays as arguments to functions:</source>
          <target state="translated">가변 길이 배열을 함수의 인수로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed04a1e1ec2d18dcef36c3f37e8523ec33398b1" translate="yes" xml:space="preserve">
          <source>You can also write a series of &amp;lsquo;</source>
          <target state="translated">일련의 '</target>
        </trans-unit>
        <trans-unit id="9a5d42d9b4feab1feb11ac3d7558132f70441d15" translate="yes" xml:space="preserve">
          <source>You can combine this technique of naming elements with ordinary C initialization of successive elements. Each initializer element that does not have a designator applies to the next consecutive element of the array or structure. For example,</source>
          <target state="translated">이 요소 이름 지정 기술을 연속 요소의 일반 C 초기화와 결합 할 수 있습니다. 지정자가없는 각 이니셜 라이저 요소는 배열 또는 구조의 다음 연속 요소에 적용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="dafe9f6d4d43d75c6afd7b0ee12396460454db2d" translate="yes" xml:space="preserve">
          <source>You can compile C or C++ programs.</source>
          <target state="translated">C 또는 C ++ 프로그램을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a148541552bb61abf1cc1bf716d6d5d34812ff" translate="yes" xml:space="preserve">
          <source>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</source>
          <target state="translated">변수를 선언하고 함수 호출 및 반환, 할당 및 일부 캐스트에서 변수를 사용할 수 있습니다. 벡터 유형을 함수의 반환 유형으로 지정할 수 있습니다. 벡터 유형은 함수 인수로도 사용할 수 있습니다. 동일한 벡터 크기 인 경우 한 벡터 유형에서 다른 벡터 유형으로 캐스트 할 수 있습니다 (사실, 동일한 크기의 다른 데이터 유형간에 벡터를 캐스트 할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="1ab5d021681ed2c7cdd4c44a866c9249ac2dea29" translate="yes" xml:space="preserve">
          <source>You can define a global register variable and associate it with a specified register like this:</source>
          <target state="translated">전역 레지스터 변수를 정의하고 다음과 같이 지정된 레지스터와 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ca46933320ecebc543d5687d368957991075a9" translate="yes" xml:space="preserve">
          <source>You can define a local register variable and associate it with a specified register like this:</source>
          <target state="translated">로컬 레지스터 변수를 정의하고 다음과 같이 지정된 레지스터와 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca45e2aac1a5f53872ccff8b57eb4700a2d304e0" translate="yes" xml:space="preserve">
          <source>You can define an &lt;code&gt;enum&lt;/code&gt; tag without specifying its possible values. This results in an incomplete type, much like what you get if you write &lt;code&gt;struct foo&lt;/code&gt; without describing the elements. A later declaration that does specify the possible values completes the type.</source>
          <target state="translated">가능한 값을 지정하지 않고 &lt;code&gt;enum&lt;/code&gt; 태그를 정의 할 수 있습니다 . 이것은 요소를 설명하지 않고 &lt;code&gt;struct foo&lt;/code&gt; 를 작성하면 얻을 수있는 것과 매우 유사하게 불완전한 유형이됩니다 . 가능한 값을 지정하는 나중에 선언하면 유형이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="fb2a1d08a5c520db79d7874dd1dd146adad124cb" translate="yes" xml:space="preserve">
          <source>You can easily find more examples by running the &amp;ldquo;strings&amp;rdquo; program on an Objective-C object file compiled by GCC. You&amp;rsquo;ll see a lot of strings that look very much like &lt;code&gt;i8@0:4&lt;/code&gt;. They are signatures of Objective-C methods.</source>
          <target state="translated">GCC가 컴파일 한 Objective-C 객체 파일에서&amp;ldquo;strings&amp;rdquo;프로그램을 실행하면 더 많은 예제를 쉽게 찾을 수 있습니다. &lt;code&gt;i8@0:4&lt;/code&gt; 와 매우 유사한 문자열이 많이 나타납니다 . 이들은 Objective-C 메소드의 시그니처입니다.</target>
        </trans-unit>
        <trans-unit id="c91ff1d5bc0072fabb3f73c5cf99e1426b54e8b7" translate="yes" xml:space="preserve">
          <source>You can extract a function pointer to the method denoted by a &amp;lsquo;</source>
          <target state="translated">'로 표시된 메소드에 대한 함수 포인터를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a467dff38136e5694516c0b9fa42d9b5384c2d1" translate="yes" xml:space="preserve">
          <source>You can get the address of a label defined in the current function (or a containing function) with the unary operator &amp;lsquo;</source>
          <target state="translated">단항 연산자 '를 사용하여 현재 함수 (또는 포함 함수)에 정의 된 레이블의 주소를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a39a597ab8644152ae7afe5488f241a221884a" translate="yes" xml:space="preserve">
          <source>You can locally override stack limit checking by using the &lt;code&gt;no_stack_limit&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">당신은 로컬로 사용하여 스택 제한 검사를 무시할 수 있습니다 &lt;code&gt;no_stack_limit&lt;/code&gt; 의 (참조 기능 속성 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="017844d9ef74d08a2197a10acca046c6aa9a28bc" translate="yes" xml:space="preserve">
          <source>You can make</source>
          <target state="translated">당신은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f287c383d16164fdc862549b5e329c619384b24c" translate="yes" xml:space="preserve">
          <source>You can mix options and other arguments. For the most part, the order you use doesn&amp;rsquo;t matter. Order does matter when you use several options of the same kind; for example, if you specify</source>
          <target state="translated">옵션과 다른 인수를 혼합 할 수 있습니다. 대부분의 경우 사용 순서는 중요하지 않습니다. 같은 종류의 여러 옵션을 사용할 때는 순서가 중요합니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="a60d360fa80936234f5b0e4eae813689b9ce29d9" translate="yes" xml:space="preserve">
          <source>You can partially avoid this problem by using the</source>
          <target state="translated">다음을 사용하여이 문제를 부분적으로 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9e0967154278910b1a4d13c152f96dcaf35354" translate="yes" xml:space="preserve">
          <source>You can pass options to the assembler.</source>
          <target state="translated">옵션을 어셈블러에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="394017d54ef624457656b3872471fba70d98d59b" translate="yes" xml:space="preserve">
          <source>You can provide an argument to the interrupt attribute which specifies a name or number. If the argument is a number it indicates the slot in the interrupt vector table (0 - 31) to which this handler should be assigned. If the argument is a name it is treated as a symbolic name for the vector slot. These names should match up with appropriate entries in the linker script. By default the names &lt;code&gt;watchdog&lt;/code&gt; for vector 26, &lt;code&gt;nmi&lt;/code&gt; for vector 30 and &lt;code&gt;reset&lt;/code&gt; for vector 31 are recognized.</source>
          <target state="translated">이름 또는 번호를 지정하는 인터럽트 속성에 인수를 제공 할 수 있습니다. 인수가 숫자이면이 핸들러가 지정 될 인터럽트 벡터 테이블 (0-31)의 슬롯을 나타냅니다. 인수가 이름이면 벡터 슬롯의 기호 이름으로 처리됩니다. 이러한 이름은 링커 스크립트의 해당 항목과 일치해야합니다. 기본적으로 벡터 26의 &lt;code&gt;watchdog&lt;/code&gt; 이름 , 벡터 30의 &lt;code&gt;nmi&lt;/code&gt; 및 벡터 31의 &lt;code&gt;reset&lt;/code&gt; 이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="21a34f7c6e1539af9716888a85e0e6ebdfedbecf" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning with &amp;lsquo;</source>
          <target state="translated">'로 시작하는 옵션으로 많은 특정 경고를 요청할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7fbbe3966a5814f26c4830b1276b72ab5f2dc01c" translate="yes" xml:space="preserve">
          <source>You can specify a range of consecutive values in a single &lt;code&gt;case&lt;/code&gt; label, like this:</source>
          <target state="translated">다음 과 같이 단일 &lt;code&gt;case&lt;/code&gt; 레이블 에 연속 값 범위를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97b79ea591cef9266e325e711531c14dffd1c998" translate="yes" xml:space="preserve">
          <source>You can specify any number or combination of these options on the command line to search for header files in several directories. The lookup order is as follows:</source>
          <target state="translated">여러 디렉토리에서 헤더 파일을 검색하기 위해 명령 행에서이 옵션의 수 또는 조합을 지정할 수 있습니다. 조회 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0856d34db6c364c78838eb5dc1f8a6703a890626" translate="yes" xml:space="preserve">
          <source>You can specify that an individual function is called with this calling sequence with the function attribute &lt;code&gt;stdcall&lt;/code&gt;. You can also override the</source>
          <target state="translated">함수 속성 &lt;code&gt;stdcall&lt;/code&gt; 을 사용하여이 호출 순서로 개별 함수가 호출되도록 지정할 수 있습니다 . 당신은 또한</target>
        </trans-unit>
        <trans-unit id="e32757ea6fc6362ed46b9b724d574c0143bee986" translate="yes" xml:space="preserve">
          <source>You can specify the input language explicitly with the</source>
          <target state="translated">입력 언어를 사용하여 입력 언어를 명시 적으로 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5a6c68a45d3cab174002900881189fc68df355b1" translate="yes" xml:space="preserve">
          <source>You can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this:</source>
          <target state="translated">다음과 같이 인터럽트 속성에 선택적 매개 변수를 추가하여 처리 할 인터럽트 종류를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee1f7bf9410ab86d8dd30e2bec2be1b2b043010" translate="yes" xml:space="preserve">
          <source>You can specify the name to be used in the assembler code for a C function or variable by writing the &lt;code&gt;asm&lt;/code&gt; (or &lt;code&gt;__asm__&lt;/code&gt;) keyword after the declarator. It is up to you to make sure that the assembler names you choose do not conflict with any other assembler symbols, or reference registers.</source>
          <target state="translated">선언자 뒤에 &lt;code&gt;asm&lt;/code&gt; (또는 &lt;code&gt;__asm__&lt;/code&gt; ) 키워드 를 작성하여 C 함수 또는 변수에 대한 어셈블러 코드에서 사용할 이름을 지정할 수 있습니다 . 선택한 어셈블러 이름이 다른 어셈블러 기호 또는 참조 레지스터와 충돌하지 않는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="30703f7905f24c8604a78167a64a5e3a31da9d67" translate="yes" xml:space="preserve">
          <source>You can switch the warning off for all characters by writing</source>
          <target state="translated">당신은 모든 문자에 대해 경고를 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="95dff15ddf46fdf8429aae6e46c8c16ce4977196" translate="yes" xml:space="preserve">
          <source>You can tell GCC to use a compatible convention for all structure and union returning with the option</source>
          <target state="translated">옵션으로 모든 구조 및 공용체 반환에 대해 호환 가능한 규칙을 사용하도록 GCC에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="4f81d4b126c2797fc5e8e7dc1694c11a9c296047" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllexport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;__declspec(dllexport)&lt;/code&gt; 을 다른 컴파일러와의 호환성을 위해 &lt;code&gt;__attribute__ ((dllexport))&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50005d4562495b37fc24571844dc1743ca746f4c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;__declspec(dllimport)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;__declspec(dllimport)&lt;/code&gt; 을 다른 컴파일러와의 호환성을 위해 &lt;code&gt;__attribute__ ((dllimport))&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86cd667b81efa67cbffa6feec930a1fbdb8eae9f" translate="yes" xml:space="preserve">
          <source>You can use a single C++ header file for both declarations and definitions.</source>
          <target state="translated">선언과 정의 모두에 단일 C ++ 헤더 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d208552bb3a27bb1eed945c45c53009e9054861" translate="yes" xml:space="preserve">
          <source>You can use any combination of these attributes, as shown below:</source>
          <target state="translated">아래와 같이 이러한 속성의 조합을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db76755964be4e6b6be71f9e85d1a8d93663640f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;copy&lt;/code&gt; attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;), or types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 속성을 사용하여 속성을 명시 적으로 열거하지 않고 다른 선언의 선언과 동일한 속성 세트를 선언에 적용 할 수 있습니다 . 이 속성은 함수 선언 ( &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성&lt;/a&gt; 참조 ) 또는 유형 ( &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성&lt;/a&gt; 참조 )에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b5b15d997a3489b69c6b152372fee0f86bbdac" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_choose_expr&lt;/code&gt; to evaluate code depending on the value of a constant expression. This built-in function returns &lt;var&gt;exp1&lt;/var&gt; if &lt;var&gt;const_exp&lt;/var&gt;, which is an integer constant expression, is nonzero. Otherwise it returns &lt;var&gt;exp2&lt;/var&gt;.</source>
          <target state="translated">내장 함수 &lt;code&gt;__builtin_choose_expr&lt;/code&gt; 을 사용하여 상수 표현식의 값에 따라 코드를 평가할 수 있습니다 . 이 내장 함수는 정수 상수 표현식 인 &lt;var&gt;const_exp&lt;/var&gt; 가 0이 아닌 경우 &lt;var&gt;exp1&lt;/var&gt; 을 리턴합니다 . 그렇지 않으면 &lt;var&gt;exp2&lt;/var&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd9fec295629e67098066cf6cb3c9ec92e5bb68" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_constant_p&lt;/code&gt; to determine if a value is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the value to test. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. A return of 0 does not indicate that the value is &lt;em&gt;not&lt;/em&gt; a constant, but merely that GCC cannot prove it is a constant with the specified value of the</source>
          <target state="translated">내장 함수 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 를 사용하여 컴파일 타임에 값이 상수인지 여부를 결정하고 GCC가 해당 값과 관련된 표현식에서 상수 폴딩을 수행 할 수 있는지 확인할 수 있습니다. 함수의 인수는 테스트 할 값입니다. 이 함수는 인수가 컴파일 타임 상수 인 경우 정수 1을 반환하고 컴파일 타임 상수 인 경우 0을 반환합니다. 0의 리턴은 값이 상수 가 &lt;em&gt;아니라는&lt;/em&gt; 것을 나타내지 않지만 GCC는 값이 지정된 값의 상수임을 증명할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9782a2381707d838ed59767d72501592b95036b5" translate="yes" xml:space="preserve">
          <source>You can use the built-in function &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; to determine whether two types are the same.</source>
          <target state="translated">내장 함수 &lt;code&gt;__builtin_types_compatible_p&lt;/code&gt; 를 사용하여 두 유형이 같은지 여부를 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43fa60b9360490e7ba0b03452edb689c2650070f" translate="yes" xml:space="preserve">
          <source>You can use the following attributes to modify the behavior of an interrupt handler:</source>
          <target state="translated">다음 속성을 사용하여 인터럽트 핸들러의 동작을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c72ec7b7bacac9ecd4a1fee983fedeb76ad118" translate="yes" xml:space="preserve">
          <source>You can use the function &lt;code&gt;alloca&lt;/code&gt; to get an effect much like variable-length arrays. The function &lt;code&gt;alloca&lt;/code&gt; is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</source>
          <target state="translated">&lt;code&gt;alloca&lt;/code&gt; 함수를 사용하여 가변 길이 배열과 같은 효과를 얻을 수 있습니다. &lt;code&gt;alloca&lt;/code&gt; 함수 는 다른 많은 C 구현에서 사용할 수 있지만 전부는 아닙니다. 반면에 가변 길이 배열은 더 우아합니다.</target>
        </trans-unit>
        <trans-unit id="50e67953531648188b117541d8b8b4fa30e96296" translate="yes" xml:space="preserve">
          <source>You can use the function attribute &lt;code&gt;no_instrument_function&lt;/code&gt; to suppress profiling of individual functions when compiling with these options. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">이 옵션으로 컴파일 할 때 개별 속성의 프로파일 링을 억제하기 위해 &lt;code&gt;no_instrument_function&lt;/code&gt; 함수 속성을 사용할 수 있습니다 . &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0525436fc5cc0248b7f78e573bd26eb006c5427" translate="yes" xml:space="preserve">
          <source>You can use the sequence &amp;lsquo;</source>
          <target state="translated">'시퀀스를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="25c48302e37cab0b76739d2efc98f5300353b6c4" translate="yes" xml:space="preserve">
          <source>You can use these attributes on Microsoft Windows targets. &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; for additional Windows compatibility attributes available on all x86 targets.</source>
          <target state="translated">Microsoft Windows 대상에서 이러한 속성을 사용할 수 있습니다. 모든 x86 대상에서 사용 가능한 추가 Windows 호환성 속성에 대한 &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 변수 속성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="349076840f0960c3892315d6f39c00e2e8d77252" translate="yes" xml:space="preserve">
          <source>You can use these types in arithmetic like any other integer types. Addition, subtraction, and bitwise boolean operations on these types are open-coded on all types of machines. Multiplication is open-coded if the machine supports a fullword-to-doubleword widening multiply instruction. Division and shifts are open-coded only on machines that provide special support. The operations that are not open-coded use special library routines that come with GCC.</source>
          <target state="translated">다른 정수 유형과 마찬가지로이 유형을 산술로 사용할 수 있습니다. 이러한 유형에 대한 더하기, 빼기 및 비트 부울 연산은 모든 유형의 컴퓨터에서 공개 코딩됩니다. 기계가 전체 워드에서 더블 워드로 확대하는 곱셈 명령어를 지원하는 경우 곱셈은 오픈 코딩됩니다. 구분 및 교대는 특별한 지원을 제공하는 기계에서만 개방형으로 코딩됩니다. 오픈 코드되지 않은 작업은 GCC와 함께 제공되는 특수 라이브러리 루틴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5aa1044e05ab82d1a453a9feb88c6b31c8d70c35" translate="yes" xml:space="preserve">
          <source>You can use this pragma to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt; loop or a &lt;code&gt;#pragma GCC ivdep&lt;/code&gt;, and applies only to the loop that follows. &lt;var&gt;n&lt;/var&gt; is an integer constant expression specifying the unrolling factor. The values of &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;1&lt;/em&gt; block any unrolling of the loop.</source>
          <target state="translated">이 pragma를 사용하여 루프를 언롤해야하는 횟수를 제어 할 수 있습니다. &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 루프 또는 &lt;code&gt;#pragma GCC ivdep&lt;/code&gt; 바로 앞에 위치해야하며 다음 루프에만 적용됩니다. &lt;var&gt;n&lt;/var&gt; 은 언 롤링 팩터를 지정하는 정수 상수 표현식입니다. &lt;em&gt;0&lt;/em&gt; 과 &lt;em&gt;1&lt;/em&gt; 의 값은 루프의 언 롤링을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="d29715d375c9f43b63580c5f152e79229b459a6b" translate="yes" xml:space="preserve">
          <source>You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &amp;ldquo;real&amp;rdquo; parameter declarations. Each forward declaration must match a &amp;ldquo;real&amp;rdquo; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.</source>
          <target state="translated">매개 변수 목록에 그러한 매개 변수 전달 선언을 얼마든지 작성할 수 있습니다. 쉼표 나 세미콜론으로 구분할 수 있지만 마지막은 세미콜론으로 끝나야하며 그 뒤에&amp;ldquo;실제&amp;rdquo;매개 변수 선언이옵니다. 각 전달 선언은 매개 변수 이름 및 데이터 유형의 &quot;실제&quot;선언과 일치해야합니다. ISO C99는 매개 변수 전달 선언을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d285fcb57d29c445f5c75a81399654db437434b" translate="yes" xml:space="preserve">
          <source>You cannot allocate variables or storage using the type while it is incomplete. However, you can work with pointers to that type.</source>
          <target state="translated">불완전한 유형을 사용하여 변수 또는 스토리지를 할당 할 수 없습니다. 그러나 해당 유형에 대한 포인터로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53335da409471fbe7935a617fd9f6ebf473abc26" translate="yes" xml:space="preserve">
          <source>You cannot operate between vectors of different lengths or different signedness without a cast.</source>
          <target state="translated">캐스트가 없으면 길이가 다르거 나 부호가 다른 벡터간에 작업 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="13abf1800307e25590d2602f0489f433955f9bc6" translate="yes" xml:space="preserve">
          <source>You have freedom to copy and modify this GNU Manual, like GNU software. Copies published by the Free Software Foundation raise funds for GNU development.</source>
          <target state="translated">GNU 소프트웨어와 같이이 GNU 매뉴얼을 자유롭게 복사하고 수정할 수 있습니다. 자유 소프트웨어 재단이 발행 한 사본은 GNU 개발을위한 기금을 모금합니다.</target>
        </trans-unit>
        <trans-unit id="35918096a4cd3290ec21ef1581f71b03f35bc6de" translate="yes" xml:space="preserve">
          <source>You have the following options for dealing with template instantiations:</source>
          <target state="translated">템플릿 인스턴스화를 처리하기위한 다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ae29ebda55f943f2de3641f83fdea66157c750" translate="yes" xml:space="preserve">
          <source>You have to expect a certain amount of disagreement between the executable and your source code, when you use optimization.</source>
          <target state="translated">최적화를 사용할 때 실행 파일과 소스 코드 사이에 어느 정도의 불일치가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c18143538d54c0195224945ef42bc5ea23853737" translate="yes" xml:space="preserve">
          <source>You may also specify whether a member function&amp;rsquo;s &lt;var&gt;this&lt;/var&gt; pointer is unaliased by using &lt;code&gt;__restrict__&lt;/code&gt; as a member function qualifier.</source>
          <target state="translated">멤버 함수 한정자로 &lt;code&gt;__restrict__&lt;/code&gt; 를 사용하여 멤버 함수 &lt;var&gt;this&lt;/var&gt; 포인터가 앨리어싱 해제 되는지 여부를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c9c1785a9b73c6c0c84000e89963aae3de9c571" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;__builtin_constant_p&lt;/code&gt; in initializers for static data. For instance, you can write</source>
          <target state="translated">정적 데이터의 초기화 프로그램에서 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 를 사용할 수도 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="77816405062bcfbd54b0c2d088c0cfe9f5a2c604" translate="yes" xml:space="preserve">
          <source>You may mark a method as having a visibility explicitly to negate the effect of the switch for that method. For example, if you do want to compare pointers to a particular inline method, you might mark it as having default visibility. Marking the enclosing class with explicit visibility has no effect.</source>
          <target state="translated">해당 메소드의 스위치 효과를 무효화하기 위해 메소드에 가시성을 명시 적으로 표시 할 수 있습니다. 예를 들어 포인터를 특정 인라인 메서드와 비교하려는 경우 기본 가시성을 갖는 것으로 표시 할 수 있습니다. 엔 클로징 클래스를 명시적인 가시성으로 표시해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e445da5feb655d87cca8dbc770cb3f7e24dc970f" translate="yes" xml:space="preserve">
          <source>You may need to experiment to determine the best settings for your application.</source>
          <target state="translated">응용 프로그램에 가장 적합한 설정을 결정하기 위해 실험해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad95174418ab8218d171a6375d9166859a034cf" translate="yes" xml:space="preserve">
          <source>You may need to specify</source>
          <target state="translated">지정해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="48a08602699410d27da97f57d05daf9841a17a43" translate="yes" xml:space="preserve">
          <source>You may not use this mechanism to jump to code in a different function. If you do that, totally unpredictable things happen. The best way to avoid this is to store the label address only in automatic variables and never pass it as an argument.</source>
          <target state="translated">이 메커니즘을 사용하여 다른 기능의 코드로 이동할 수 없습니다. 그렇게하면 완전히 예측할 수없는 일이 발생합니다. 이를 피하는 가장 좋은 방법은 레이블 주소를 자동 변수에만 저장하고 인수로 전달하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bff5113fa76e9e5005f3a00a7843919b5149c765" translate="yes" xml:space="preserve">
          <source>You may only specify the &lt;code&gt;packed&lt;/code&gt; attribute on the definition of an &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;class&lt;/code&gt;, not on a &lt;code&gt;typedef&lt;/code&gt; that does not also define the enumerated type, structure, union, or class.</source>
          <target state="translated">경우에만 지정할 수 있습니다 &lt;code&gt;packed&lt;/code&gt; 의 정의에 속성을 &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;class&lt;/code&gt; 가 아니라에, &lt;code&gt;typedef&lt;/code&gt; 또한 열거 형, 구조, 노동 조합, 또는 클래스를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54442d3018c5bf124a5cec286579f5b0f4a37809" translate="yes" xml:space="preserve">
          <source>You may only use the &lt;code&gt;shared&lt;/code&gt; attribute along with &lt;code&gt;section&lt;/code&gt; attribute with a fully-initialized global definition because of the way linkers work. See &lt;code&gt;section&lt;/code&gt; attribute for more information.</source>
          <target state="translated">링커 작동 방식으로 인해 완전히 초기화 된 전역 정의가있는 &lt;code&gt;section&lt;/code&gt; 속성과 함께 &lt;code&gt;shared&lt;/code&gt; 속성 만 사용할 수 있습니다 . 자세한 정보는 &lt;code&gt;section&lt;/code&gt; 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c7b80e390300159d4993b9cd813e610830fb794" translate="yes" xml:space="preserve">
          <source>You may optionally specify attribute names with &amp;lsquo;</source>
          <target state="translated">선택적으로 '로 속성 이름을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b744bc45d5f9c7b517250c91d7d9ce559fd58615" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character (written as &amp;lsquo;</source>
          <target state="translated">시스템의 어셈블리 코드에서 일반적으로 사용되는 문자로 구분 된 단일 &lt;code&gt;asm&lt;/code&gt; 문자열 에 여러 어셈블러 명령어를 함께 배치 할 수 있습니다 . 대부분의 장소에서 작동하는 조합은 줄 바꿈을위한 줄 바꿈과 탭 문자 ( '</target>
        </trans-unit>
        <trans-unit id="c17cdd78fed8e2f19f13ed7c6a72d4082d16e577" translate="yes" xml:space="preserve">
          <source>You may place multiple assembler instructions together in a single &lt;code&gt;asm&lt;/code&gt; string, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as &amp;lsquo;</source>
          <target state="translated">시스템의 어셈블리 코드에서 일반적으로 사용되는 문자로 구분 된 단일 &lt;code&gt;asm&lt;/code&gt; 문자열 에 여러 어셈블러 명령어를 함께 배치 할 수 있습니다 . 대부분의 장소에서 작동하는 조합은 줄 바꿈을위한 줄 바꿈과 명령어 필드로 이동하는 탭 문자 ( '</target>
        </trans-unit>
        <trans-unit id="f0570114f2ecbb2dbeed78e2cafecfaebd377566" translate="yes" xml:space="preserve">
          <source>You may specify type attributes in an enum, struct or union type declaration or definition by placing them immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword. You can also place them just past the closing curly brace of the definition, but this is less preferred because logically the type should be fully defined at the closing brace.</source>
          <target state="translated">enum, struct 또는 union 유형 선언 또는 정의에서 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 키워드 바로 뒤에 배치하여 유형 속성을 지정할 수 있습니다 . 정의의 닫는 중괄호를 지나서 배치 할 수도 있지만 논리적으로 닫는 중괄호에서 유형을 완전히 정의해야하기 때문에이 방법은 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fcc73998e38d45743d93a8c5804d34b2fb5bae5" translate="yes" xml:space="preserve">
          <source>You may use &lt;code&gt;__builtin_expect&lt;/code&gt; to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (</source>
          <target state="translated">&lt;code&gt;__builtin_expect&lt;/code&gt; 를 사용 하여 분기 예측 정보를 컴파일러에 제공 할 수 있습니다 . 일반적으로 실제 프로필 피드백을 사용하는 것이 좋습니다 (</target>
        </trans-unit>
        <trans-unit id="dd9213edd154d9e31cb91aff441ba460289ac018" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;section&lt;/code&gt; attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the &lt;code&gt;common&lt;/code&gt; (or &lt;code&gt;bss&lt;/code&gt;) section and can be multiply &amp;ldquo;defined&amp;rdquo;. Using the &lt;code&gt;section&lt;/code&gt; attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the</source>
          <target state="translated">초기화되거나 초기화되지 않은 전역 변수와 함께 &lt;code&gt;section&lt;/code&gt; 속성을 사용할 수 있지만, 링커는 초기화되지 않은 변수가 &lt;code&gt;common&lt;/code&gt; (또는 &lt;code&gt;bss&lt;/code&gt; ) 섹션 에 잠정적 으로 곱하여 &quot;정의&quot;될 수 있다는 점을 제외하고 각 객체를 한 번 정의해야합니다 . &lt;code&gt;section&lt;/code&gt; 속성을 사용하면 변수가 들어가는 섹션이 변경되고 초기화되지 않은 변수에 여러 정의가 있으면 링커에서 오류가 발생할 수 있습니다. 변수를 사용하여 변수를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0897ffec25d2d3e9ff5e4c9a12cc715a05821b36" translate="yes" xml:space="preserve">
          <source>You may use this built-in function in either a macro or an inline function. However, if you use it in an inlined function and pass an argument of the function as the argument to the built-in, GCC never returns 1 when you call the inline function with a string constant or compound literal (see &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;) and does not return 1 when you pass a constant numeric value to the inline function unless you specify the</source>
          <target state="translated">이 내장 함수를 매크로 또는 인라인 함수로 사용할 수 있습니다. 그러나 인라인 함수에서 함수를 사용하고 함수의 인수를 내장 인수로 전달하면 GCC는 문자열 상수 또는 복합 리터럴을 사용하여 인라인 함수를 호출 할 때 1을 반환하지 않습니다 ( &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt; 참조 ). 상수 숫자 값을 인라인 함수에 전달하면 1을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="179c17b93d49191ff63b1b0b1b00b166383a79b3" translate="yes" xml:space="preserve">
          <source>You must move the data files to the expected directory tree in order to use them for profile directed optimizations (</source>
          <target state="translated">프로파일 지정 최적화에 사용하려면 데이터 파일을 예상 디렉토리 트리로 이동해야합니다 (</target>
        </trans-unit>
        <trans-unit id="65535d14a26d4547fe9b855313a51330599397c9" translate="yes" xml:space="preserve">
          <source>You must never create such structures that cause ambiguous field definitions. For example, in this structure:</source>
          <target state="translated">모호한 필드 정의를 유발하는 구조를 작성해서는 안됩니다. 예를 들어,이 구조에서 :</target>
        </trans-unit>
        <trans-unit id="364d53586a93cb7dd4166336e04c54defad73c15" translate="yes" xml:space="preserve">
          <source>You must specify</source>
          <target state="translated">지정해야합니다</target>
        </trans-unit>
        <trans-unit id="a0fd70e362d1f4b760a9cd038d96c07ea7f21b49" translate="yes" xml:space="preserve">
          <source>You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly.</source>
          <target state="translated">이 속성이 올바르게 작동하려면 GNU binutils 버전 2.7 이상에서 GAS 및 GLD를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6993ebfa9e3b6b6d6560ac8997eeb7ede6d0e9b1" translate="yes" xml:space="preserve">
          <source>You need this special case of the</source>
          <target state="translated">이 특별한 경우가 필요합니다</target>
        </trans-unit>
        <trans-unit id="5a83a0c884ced5b1afbf8e0b73de9c85e4e8c7bb" translate="yes" xml:space="preserve">
          <source>You should be prepared for side effects when using</source>
          <target state="translated">사용할 때 부작용에 대비해야합니다</target>
        </trans-unit>
        <trans-unit id="fc2603d33fd81fe37c5c600db9786f0599bb7f89" translate="yes" xml:space="preserve">
          <source>You should compile your code without optimization if you plan to use &lt;code&gt;gcov&lt;/code&gt; because the optimization, by combining some lines of code into one function, may not give you as much information as you need to look for &amp;lsquo;hot spots&amp;rsquo; where the code is using a great deal of computer time. Likewise, because &lt;code&gt;gcov&lt;/code&gt; accumulates statistics by line (at the lowest resolution), it works best with a programming style that places only one statement on each line. If you use complicated macros that expand to loops or to other control structures, the statistics are less helpful&amp;mdash;they only report on the line where the macro call appears. If your complex macros behave like functions, you can replace them with inline functions to solve this problem.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 를 사용하려는 경우 일부 코드 줄을 하나의 함수로 결합하여 코드에서 사용하는 '핫스팟'을 찾는 데 필요한만큼 많은 정보를 제공하지 못할 수 있으므로 gcov 를 사용하려는 경우 최적화없이 코드를 컴파일 해야합니다. 많은 컴퓨터 시간. 마찬가지로 &lt;code&gt;gcov&lt;/code&gt; 는 통계를 한 줄씩 (최저 해상도에서) 누적 하기 때문에 각 줄에 하나의 명령문 만 배치하는 프로그래밍 스타일에 가장 적합합니다. 루프 나 다른 제어 구조로 확장되는 복잡한 매크로를 사용하는 경우 통계가 덜 유용합니다. 매크로 호출이 나타나는 회선에만보고합니다. 복잡한 매크로가 함수처럼 동작하는 경우 인라인 함수로 대체하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe80fe3d98f647e191798f4bf1cd85c0708a7905" translate="yes" xml:space="preserve">
          <source>You should declare the jump buffer argument &lt;var&gt;buf&lt;/var&gt; to the built-in functions as:</source>
          <target state="translated">다음과 같이 점프 버퍼 인수 &lt;var&gt;buf&lt;/var&gt; 를 내장 함수에 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d1fbba229a2654e9c51633205d301f0603b772d" translate="yes" xml:space="preserve">
          <source>You should make no assumptions about receiving &lt;code&gt;+load&lt;/code&gt; in sibling classes when you write &lt;code&gt;+load&lt;/code&gt; of a class. The order in which sibling classes receive &lt;code&gt;+load&lt;/code&gt; is not guaranteed.</source>
          <target state="translated">클래스의 &lt;code&gt;+load&lt;/code&gt; 를 작성할 때 형제 클래스에서 &lt;code&gt;+load&lt;/code&gt; 를 받는 것에 대한 가정을해서는 안됩니다 . 형제 클래스가 &lt;code&gt;+load&lt;/code&gt; 받는 순서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a466242a3e9760eaada5a308649a4f792fde67b" translate="yes" xml:space="preserve">
          <source>You should not write this &lt;code&gt;#pragma&lt;/code&gt; in your own code, but it is safe to edit the filename if the PCH file is available in a different location. The filename may be absolute or it may be relative to GCC&amp;rsquo;s current directory.</source>
          <target state="translated">이 &lt;code&gt;#pragma&lt;/code&gt; 를 자신의 코드로 작성해서는 안되지만 PCH 파일이 다른 위치에있는 경우 파일 이름을 편집하는 것이 안전합니다. 파일 이름은 절대적이거나 GCC의 현재 디렉토리에 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5b58bacb34de248a5caa9e1d70684a5e3e9e81a" translate="yes" xml:space="preserve">
          <source>You should rewrite your code to avoid these warnings if you are concerned about the fact that code generated by G++ may not be binary compatible with code generated by other compilers.</source>
          <target state="translated">G ++에서 생성 된 코드가 다른 컴파일러에서 생성 된 코드와 이진 호환되지 않을 수 있다는 사실에 대해 우려가있을 경우 이러한 경고를 피하려면 코드를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3200321f5c777dbbacc4f9ef21ac598c37fa6c47" translate="yes" xml:space="preserve">
          <source>You typically use this function in an embedded application where memory is a critical resource. If you have some complex calculation, you may want it to be folded if it involves constants, but need to call a function if it does not. For example:</source>
          <target state="translated">일반적으로 메모리가 중요한 리소스 인 내장 응용 프로그램에서이 기능을 사용합니다. 복잡한 계산이있는 경우 상수가 포함 된 경우 접 히기를 원할 수 있지만 그렇지 않은 경우 함수를 호출해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1963db30d39d58a295ec397d230925d0854ee73" translate="yes" xml:space="preserve">
          <source>You typically use this function in code whose execution varies depending on the arguments&amp;rsquo; types. For example:</source>
          <target state="translated">일반적으로 인수의 유형에 따라 실행이 다른 코드에서이 함수를 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a382ebf878d522cc46ae079d7811d40f2d546d5e" translate="yes" xml:space="preserve">
          <source>You typically use this option to build a shared library dynamic loader. Itself a shared library, it must relocate itself in memory before it can find the variables and constants in its own data segment.</source>
          <target state="translated">일반적으로이 옵션을 사용하여 공유 라이브러리 동적 로더를 빌드하십시오. 공유 라이브러리 자체는 자체 데이터 세그먼트에서 변수와 상수를 찾기 전에 메모리에 자신을 재배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff2858040c7368b4f7687d2e4605dbe04fb48ce1" translate="yes" xml:space="preserve">
          <source>You use these options to specify which instructions are available on the processor you are using. The default value of these options is determined when configuring GCC. Specifying the</source>
          <target state="translated">이 옵션을 사용하여 사용중인 프로세서에서 사용할 수있는 명령어를 지정하십시오. 이 옵션의 기본값은 GCC를 구성 할 때 결정됩니다. 지정</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="553f12b0c01c796a9c01fbfbed6d38920ed5b259" translate="yes" xml:space="preserve">
          <source>Zero-length arrays.</source>
          <target state="translated">길이가 0 인 배열.</target>
        </trans-unit>
        <trans-unit id="258478ec83495aa79136f18ffc9233ee1f0db5ed" translate="yes" xml:space="preserve">
          <source>Zero-length bit-fields following non-bit-field members are ignored:</source>
          <target state="translated">비 비트 필드 멤버 뒤에 오는 길이가 0 인 비트 필드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c2ceddaf3c2e5b315ce6df93a6d703e090097e2" translate="yes" xml:space="preserve">
          <source>[.A-Za-z]*</source>
          <target state="translated">[.A-Za-z]*</target>
        </trans-unit>
        <trans-unit id="abf3f56fd4893df51cec0f301e1d141ec4cf5a54" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">[&lt;var&gt;first&lt;/var&gt; ... &lt;var&gt;last&lt;/var&gt;] = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="893b2523426b47e65f5145303772e8166d192d46" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;]</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;]</target>
        </trans-unit>
        <trans-unit id="96a90e0b102b000a44c98efbcdab9b6dee99bbd8" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;index&lt;/var&gt;] =</source>
          <target state="translated">[&lt;var&gt;index&lt;/var&gt;] =</target>
        </trans-unit>
        <trans-unit id="aaf8c573d70607ca295cc0cde78f8a6154aa6363" translate="yes" xml:space="preserve">
          <source>[&lt;var&gt;suffix&lt;/var&gt;] spec</source>
          <target state="translated">[&lt;var&gt;suffix&lt;/var&gt;] spec</target>
        </trans-unit>
        <trans-unit id="323d9668ca564c93e740198e5fd45fcacecbe669" translate="yes" xml:space="preserve">
          <source>[dir/]include</source>
          <target state="translated">[dir/]include</target>
        </trans-unit>
        <trans-unit id="14aee59b80f3ae18852c214fd35ef6a55a3b42a6" translate="yes" xml:space="preserve">
          <source>[dir/]stage&lt;var&gt;N&lt;/var&gt;/</source>
          <target state="translated">[dir/]stage&lt;var&gt;N&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="08534f33c201a45017b502e90a800f1b708ebcb3" translate="yes" xml:space="preserve">
          <source>\</source>
          <target state="translated">\</target>
        </trans-unit>
        <trans-unit id="ec24514fcd2c759e6e733c1219e798f6a27080dd" translate="yes" xml:space="preserve">
          <source>\,</source>
          <target state="translated">\,</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="5260fdfe19fbab22b26fb10a5b1cdaa4e4d5fa1f" translate="yes" xml:space="preserve">
          <source>\n\t</source>
          <target state="translated">\n\t</target>
        </trans-unit>
        <trans-unit id="dd56ac3bfe32e89d0b9eada9071564fe17a96c3a" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;L&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;L&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f2b8017c21a3fa06728ebdd896c9f0840460e437" translate="yes" xml:space="preserve">
          <source>_&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">_&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bef0f1b1eda1a69cc6d7593689c6ad7764f8486b" translate="yes" xml:space="preserve">
          <source>_Complex double x;</source>
          <target state="translated">_Complex double x;</target>
        </trans-unit>
        <trans-unit id="be1a596019bc728455ca6e661ae186a03fbaf2a6" translate="yes" xml:space="preserve">
          <source>_Complex short int y;</source>
          <target state="translated">_Complex short int y;</target>
        </trans-unit>
        <trans-unit id="4efeab93d874226b7c2975a5130348c4a300a2cf" translate="yes" xml:space="preserve">
          <source>_MAX</source>
          <target state="translated">_MAX</target>
        </trans-unit>
        <trans-unit id="dde95929ec72357d1a78e9ef9086ad031a0699b2" translate="yes" xml:space="preserve">
          <source>_MIN</source>
          <target state="translated">_MIN</target>
        </trans-unit>
        <trans-unit id="9624af4051d439e5359b9152ec698ceaa0261659" translate="yes" xml:space="preserve">
          <source>__atomic</source>
          <target state="translated">__atomic</target>
        </trans-unit>
        <trans-unit id="011657d58155e0e3541069c651cbe40aace6f116" translate="yes" xml:space="preserve">
          <source>__atomic_thread_fence</source>
          <target state="translated">__atomic_thread_fence</target>
        </trans-unit>
        <trans-unit id="b5190ca2a20962ff5fe42fd3d915ec20ed74f142" translate="yes" xml:space="preserve">
          <source>__attribute__ ((aligned (16), packed))</source>
          <target state="translated">__attribute__ ((aligned (16), packed))</target>
        </trans-unit>
        <trans-unit id="9763de6eac5cd7741fca26ac575ae576079de73c" translate="yes" xml:space="preserve">
          <source>__builtin_</source>
          <target state="translated">__builtin_</target>
        </trans-unit>
        <trans-unit id="9ffdd3b639dbcc260c36604d951401b356ebdfa9" translate="yes" xml:space="preserve">
          <source>__builtin_frame_address</source>
          <target state="translated">__builtin_frame_address</target>
        </trans-unit>
        <trans-unit id="77d71c429ddc63ee19bd5fc63e5f0770c3745449" translate="yes" xml:space="preserve">
          <source>__builtin_return_address</source>
          <target state="translated">__builtin_return_address</target>
        </trans-unit>
        <trans-unit id="090f89da9d6d5b98fdd005c2ae6006ce69c1facf" translate="yes" xml:space="preserve">
          <source>__f</source>
          <target state="translated">__f</target>
        </trans-unit>
        <trans-unit id="3535355516b8a7449fdf619b53778778636b0eea" translate="yes" xml:space="preserve">
          <source>__int128</source>
          <target state="translated">__int128</target>
        </trans-unit>
        <trans-unit id="39a41d9f01352f9be126d019a0f55223b6f117ec" translate="yes" xml:space="preserve">
          <source>__sync</source>
          <target state="translated">__sync</target>
        </trans-unit>
        <trans-unit id="36fb58f934823421b6f9498810790aeee97de129" translate="yes" xml:space="preserve">
          <source>__v850*__</source>
          <target state="translated">__v850*__</target>
        </trans-unit>
        <trans-unit id="e748065bbc4c0e6c0efc4285894458b89aaf5dff" translate="yes" xml:space="preserve">
          <source>_flush_cache</source>
          <target state="translated">_flush_cache</target>
        </trans-unit>
        <trans-unit id="43bf149a9ed61bc94557723db25e4af7f39d8d75" translate="yes" xml:space="preserve">
          <source>_foo</source>
          <target state="translated">_foo</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="20276f54b2fb0d6340042fdc1e284afc48a41106" translate="yes" xml:space="preserve">
          <source>a hard limit, disallowing more than that number in an instruction group. Otherwise, the limit is &amp;ldquo;soft&amp;rdquo;, meaning that non-memory operations are preferred when the limit is reached, but memory operations may still be scheduled.</source>
          <target state="translated">명령 그룹에서 해당 숫자보다 많은 수를 허용하지 않는 하드 한계. 그렇지 않으면, 한계는 &quot;소프트&quot;입니다. 즉, 한계에 도달하면 비 메모리 작업이 선호되지만 메모리 작업은 계속 예약 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d45fbf9e18e03187144f653f6c867ab6a4cb2ce" translate="yes" xml:space="preserve">
          <source>a signed doubleword</source>
          <target state="translated">부호가있는 더블 워드</target>
        </trans-unit>
        <trans-unit id="9efaa9ee2486d205847ff7f6eb2734e13064b3d6" translate="yes" xml:space="preserve">
          <source>a signed word</source>
          <target state="translated">서명 된 단어</target>
        </trans-unit>
        <trans-unit id="2e5e828ebf29441ab1d17abe9b59440764703bd5" translate="yes" xml:space="preserve">
          <source>a.c</source>
          <target state="translated">a.c</target>
        </trans-unit>
        <trans-unit id="2ef04052181a3bcb9eb40398327d275b7122b76b" translate="yes" xml:space="preserve">
          <source>a.c##x.h.gcov</source>
          <target state="translated">a.c##x.h.gcov</target>
        </trans-unit>
        <trans-unit id="937373b898e354572539c11778b8369b6021d02b" translate="yes" xml:space="preserve">
          <source>a.out</source>
          <target state="translated">a.out</target>
        </trans-unit>
        <trans-unit id="b9f85daa6f83cf02ce5c31913d1f64d3f5c8fade" translate="yes" xml:space="preserve">
          <source>a2</source>
          <target state="translated">a2</target>
        </trans-unit>
        <trans-unit id="62352d3d034a492b743d85067daad3ede5b2104b" translate="yes" xml:space="preserve">
          <source>aapcs</source>
          <target state="translated">aapcs</target>
        </trans-unit>
        <trans-unit id="cb76f70bd27803c92785136c45fbc376f9dd2652" translate="yes" xml:space="preserve">
          <source>aapcs-linux</source>
          <target state="translated">aapcs-linux</target>
        </trans-unit>
        <trans-unit id="973eb567623a16af6cc4b072efcf2388a12b9404" translate="yes" xml:space="preserve">
          <source>aarch64-*-*</source>
          <target state="translated">aarch64-*-*</target>
        </trans-unit>
        <trans-unit id="c10ebf10559ad9cfd389b344d22aa0551d5fd166" translate="yes" xml:space="preserve">
          <source>aarch64_be-*-*</source>
          <target state="translated">aarch64_be-*-*</target>
        </trans-unit>
        <trans-unit id="715a5d4d840064196cfa2f6763ef29067adb4d87" translate="yes" xml:space="preserve">
          <source>abi</source>
          <target state="translated">abi</target>
        </trans-unit>
        <trans-unit id="dcd67d1087e07b87a59bb90a9324a369479ccb75" translate="yes" xml:space="preserve">
          <source>abm</source>
          <target state="translated">abm</target>
        </trans-unit>
        <trans-unit id="f3bf4a18bc12d3fd665f34273aa77398ca033388" translate="yes" xml:space="preserve">
          <source>about invoking</source>
          <target state="translated">호출에 대한</target>
        </trans-unit>
        <trans-unit id="de671ae4cf4c6f58efe6bf4db141ff43ea23375f" translate="yes" xml:space="preserve">
          <source>above). Currently, the following sets are defined:</source>
          <target state="translated">위). 현재 다음 세트가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="614cd09c5357289d30936d7b18d4378a9149026f" translate="yes" xml:space="preserve">
          <source>above, generate Ada specs as child units of parent &lt;var&gt;unit&lt;/var&gt;.</source>
          <target state="translated">위의 부모의 하위 단위로 에이다 사양 생성 &lt;var&gt;unit&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="76726f07acaef7a675fe282314fc6d7f44669323" translate="yes" xml:space="preserve">
          <source>accidentally contains floating-point operations, it is likely to suffer a link-time or run-time failure.</source>
          <target state="translated">실수로 부동 소수점 연산이 포함되어 있으면 링크 타임 또는 런타임 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466afffe5fc6585663064937defed67d00d3e3b4" translate="yes" xml:space="preserve">
          <source>acml</source>
          <target state="translated">acml</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="798db27fb8836547e7eae5cbf51a015317e5a479" translate="yes" xml:space="preserve">
          <source>adds keywords &lt;code&gt;__vector&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;__pixel&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt;, &lt;code&gt;__bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;. When compiling ISO C, the context-sensitive substitution of the keywords &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;pixel&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; is disabled. To use them, you must include &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">키워드 &lt;code&gt;__vector&lt;/code&gt; , &lt;code&gt;vector&lt;/code&gt; , &lt;code&gt;__pixel&lt;/code&gt; , &lt;code&gt;pixel&lt;/code&gt; , &lt;code&gt;__bool&lt;/code&gt; 및 &lt;code&gt;bool&lt;/code&gt; 을 추가 합니다. ISO C를 컴파일 할 때 키워드 &lt;code&gt;vector&lt;/code&gt; , &lt;code&gt;pixel&lt;/code&gt; 및 &lt;code&gt;bool&lt;/code&gt; 의 상황에 맞는 대체 는 비활성화됩니다. 이를 사용하려면 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 를 대신 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a4611cf85989cfb032315de1816f14ac9f3517b" translate="yes" xml:space="preserve">
          <source>adiw</source>
          <target state="translated">adiw</target>
        </trans-unit>
        <trans-unit id="70115ea66975f8392735da74af10a532c95caaf7" translate="yes" xml:space="preserve">
          <source>adx</source>
          <target state="translated">adx</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="1ba7d6d2d5d6b99ecac4784439f26289cba856d4" translate="yes" xml:space="preserve">
          <source>align-stringops</source>
          <target state="translated">align-stringops</target>
        </trans-unit>
        <trans-unit id="3bea4606b8381d936b8f862d721bc4422652b565" translate="yes" xml:space="preserve">
          <source>aligned</source>
          <target state="translated">aligned</target>
        </trans-unit>
        <trans-unit id="a8d2e4967b2627fcbbcd7bab5490853d70874e12" translate="yes" xml:space="preserve">
          <source>aligns &lt;code&gt;long double&lt;/code&gt; to a 16-byte boundary by padding the &lt;code&gt;long double&lt;/code&gt; with an additional 32-bit zero.</source>
          <target state="translated">가지런 &lt;code&gt;long double&lt;/code&gt; 패딩에 의해 16 바이트 경계 &lt;code&gt;long double&lt;/code&gt; 으로 추가로 제로 32 비트.</target>
        </trans-unit>
        <trans-unit id="3efdc33c698275c6bba0bfe0a5cc4bb1ae2af995" translate="yes" xml:space="preserve">
          <source>aligns functions to the next 32-byte boundary,</source>
          <target state="translated">다음 32 바이트 경계에 함수를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="244280ce7bd1f8e5d39e22b8ef0ce1ca3d784e6f" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less,</source>
          <target state="translated">23 바이트 이하로 건너 뛰어 수행 할 수있는 경우에만 다음 32 바이트 경계에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cfa7e3dfee8e7262fa433d58f986a5d3347143cb" translate="yes" xml:space="preserve">
          <source>aligns to the next 32-byte boundary only if this can be done by skipping 6 bytes or less.</source>
          <target state="translated">6 바이트 이하를 건너 뛰어이를 수행 할 수있는 경우에만 다음 32 바이트 경계에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="79635748432e8322454f167c344ee1a5dee023d5" translate="yes" xml:space="preserve">
          <source>aligns to the next 64-byte boundary if this can be done by skipping 6 bytes or less, otherwise aligns to the next 32-byte boundary if this can be done by skipping 2 bytes or less. If &lt;var&gt;m2&lt;/var&gt; is not specified, it defaults to &lt;var&gt;n2&lt;/var&gt;.</source>
          <target state="translated">6 바이트 이하로 건너 뛸 수 있으면 다음 64 바이트 경계에 정렬되고, 그렇지 않으면 2 바이트 이하로 건너 뛰면 다음 32 바이트 경계에 정렬됩니다. 경우 &lt;var&gt;m2&lt;/var&gt; 가 에 지정되지 않은 경우 기본값 &lt;var&gt;n2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="a8901683ad5f4f61f902c68d29d69c8b1ad5d90d" translate="yes" xml:space="preserve">
          <source>all external symbols are resolved at load time.</source>
          <target state="translated">로드시 모든 외부 심볼이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="bbe28b8276e31a373247e1c8a94a3beb37c5b6fa" translate="yes" xml:space="preserve">
          <source>all.h</source>
          <target state="translated">all.h</target>
        </trans-unit>
        <trans-unit id="3b0a792c2b1703577a069f12d469a0473536a471" translate="yes" xml:space="preserve">
          <source>all.h.gch</source>
          <target state="translated">all.h.gch</target>
        </trans-unit>
        <trans-unit id="b9bf38b9b4d225abc840bc0ee7480fcc2434e2b3" translate="yes" xml:space="preserve">
          <source>allclass.cc</source>
          <target state="translated">allclass.cc</target>
        </trans-unit>
        <trans-unit id="ca4599448f2501f9fa384de7b7038a3e242e0dfb" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to arbitrary objects;</source>
          <target state="translated">임의의 객체의 할당 또는 메시지 전송;</target>
        </trans-unit>
        <trans-unit id="32b74672543fdbbdcfc868ba07acb1ff2110d200" translate="yes" xml:space="preserve">
          <source>allocation of or sending messages to objects whose classes have a category implemented in the same file;</source>
          <target state="translated">클래스가 동일한 파일에서 구현 된 범주를 갖는 오브젝트에 메시지를 할당하거나 전송합니다.</target>
        </trans-unit>
        <trans-unit id="453b7342a6d3f523c8d652e090720e4f47db0bd8" translate="yes" xml:space="preserve">
          <source>allow you to switch between producing output that works with the GNU Objective-C runtime library and output that works with the Apple/NeXT Objective-C runtime library.</source>
          <target state="translated">GNU Objective-C 런타임 라이브러리에서 작동하는 출력과 Apple / NeXT Objective-C 런타임 라이브러리에서 작동하는 출력간에 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4aebec0f6653650ee91987b02de80dc8963201" translate="yes" xml:space="preserve">
          <source>allowing the user to call &lt;code&gt;memcpy&lt;/code&gt; as a regular function, unaware of the actual implementation. Finally, the indirect function needs to be defined in the same translation unit as the resolver function:</source>
          <target state="translated">사용자 는 실제 구현을 알지 못하고 &lt;code&gt;memcpy&lt;/code&gt; 를 일반 함수로 호출 할 수 있습니다. 마지막으로, 간접 함수는 리졸버 함수와 동일한 변환 단위로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="66438aaa4bea9ecc573f56890befc19245624f30" translate="yes" xml:space="preserve">
          <source>allows GCC to generate code that may not run at all on processors other than the one indicated. Specifying</source>
          <target state="translated">GCC가 표시된 프로세서 이외의 프로세서에서는 전혀 실행되지 않는 코드를 생성 할 수 있습니다. 지정</target>
        </trans-unit>
        <trans-unit id="cf49e111caf7da05b98404623112872b82a367f9" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root. Specifying</source>
          <target state="translated">GCC는 부동 소수점 제곱근을 포함하여 범용 그룹에서 선택적 PowerPC 아키텍처 명령어를 사용할 수 있습니다. 지정</target>
        </trans-unit>
        <trans-unit id="f5666aaba4ff4d9843997efb2fce32365976d352" translate="yes" xml:space="preserve">
          <source>allows GCC to use the optional PowerPC architecture instructions in the Graphics group, including floating-point select.</source>
          <target state="translated">GCC는 부동 소수점 선택을 포함하여 그래픽 그룹에서 선택적 PowerPC 아키텍처 명령어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2abc9f7d66d3a1198b14bbaa01458338cdf813bd" translate="yes" xml:space="preserve">
          <source>allows some nonconforming code to compile.</source>
          <target state="translated">부적합한 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bedf43ad0a95e8d3ef4a98d57277220a9905abdc" translate="yes" xml:space="preserve">
          <source>along with</source>
          <target state="translated">와 함께</target>
        </trans-unit>
        <trans-unit id="eec221c0b71d49bdac9cb852917ed960c85ad0a8" translate="yes" xml:space="preserve">
          <source>also being enabled.</source>
          <target state="translated">또한 활성화되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fad31864ed398f45dae03d45460e898d7d29f7e" translate="yes" xml:space="preserve">
          <source>also being specified, the code is tuned to perform well across a range of target processors implementing the target architecture.</source>
          <target state="translated">또한 코드를 지정하면 대상 아키텍처를 구현하는 다양한 대상 프로세서에서 잘 수행되도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d6a07b9735308ca8e95431227809c536d7831ad" translate="yes" xml:space="preserve">
          <source>also by</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="187a158ae4568f3cc3e2b692351e6276268ce95b" translate="yes" xml:space="preserve">
          <source>also checks for null format arguments for several functions,</source>
          <target state="translated">또한 여러 함수에 대해 널 형식 인수를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f587f4ff38f8c2cccf85ae4104732656fd8bb96d" translate="yes" xml:space="preserve">
          <source>also diagnoses cases where the attributes of the alias declaration are more restrictive than the attributes applied to its target. These mismatches can potentially result in incorrect code generation. In other cases they may be benign and could be resolved simply by adding the missing attribute to the target. For comparison, see the</source>
          <target state="translated">또한 별명 선언의 속성이 대상에 적용된 속성보다 더 제한적인 경우를 진단합니다. 이러한 불일치는 잠재적으로 잘못된 코드 생성을 초래할 수 있습니다. 다른 경우에는 양성일 수 있으며 누락 된 속성을 대상에 추가하여 간단히 해결할 수 있습니다. 비교를 위해</target>
        </trans-unit>
        <trans-unit id="cb860f8821c8635791611ff058e7157ab855da31" translate="yes" xml:space="preserve">
          <source>also implies</source>
          <target state="translated">또한 암시</target>
        </trans-unit>
        <trans-unit id="6f42e4ce494f5b76f2544a0f03b983119cfbce78" translate="yes" xml:space="preserve">
          <source>also includes dependence info.</source>
          <target state="translated">의존성 정보도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="be3f59c6748c3a9b4a7ae21f5715d657a72eeb15" translate="yes" xml:space="preserve">
          <source>also prints warning messages for the following cases:</source>
          <target state="translated">다음과 같은 경우에도 경고 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2e5682119037273f933c083ad00d7701aba2cf5c" translate="yes" xml:space="preserve">
          <source>also provides equivalent macros called &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; that can be used for programming ease and improved readability. The following macros for DMA control are also provided:</source>
          <target state="translated">또한 프로그래밍 편의성 및 가독성 향상에 사용할 수있는 &lt;code&gt;_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; 이라는 동등한 매크로를 제공합니다 . DMA 제어를위한 다음 매크로도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f34eaf4f6ae89eb9588e134559245afad4e138e4" translate="yes" xml:space="preserve">
          <source>also sets</source>
          <target state="translated">또한 세트</target>
        </trans-unit>
        <trans-unit id="e117a2e5dfc7efe817347989346d6cd665ab904c" translate="yes" xml:space="preserve">
          <source>also suppresses preprocessed output, as a missing header file renders this useless.</source>
          <target state="translated">누락 된 헤더 파일이이를 쓸모 없게하므로 사전 처리 된 출력도 억제합니다.</target>
        </trans-unit>
        <trans-unit id="63a0640542d5918d3932396f482586803338d771" translate="yes" xml:space="preserve">
          <source>also takes into account control flow statements, such as ifs, and only warns when appropriate. E.g.</source>
          <target state="translated">또한 if와 같은 제어 흐름 설명을 고려하고 적절한 경우에만 경고합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="30f35ed6e318ea969ed59edf47b9b26381d2be26" translate="yes" xml:space="preserve">
          <source>also warns about calls to bounded string copy functions like &lt;code&gt;strncat&lt;/code&gt; or &lt;code&gt;strncpy&lt;/code&gt; that specify as the bound a &lt;code&gt;sizeof&lt;/code&gt; expression of the source array. For example, in the following function the call to &lt;code&gt;strncat&lt;/code&gt; specifies the size of the source string as the bound. That is almost certainly a mistake and so the call is diagnosed.</source>
          <target state="translated">또한 같은 경계 문자열 복사 함수를 호출에 대해 경고 &lt;code&gt;strncat&lt;/code&gt; 또는 &lt;code&gt;strncpy&lt;/code&gt; 에서 바운드 A와 지정 &lt;code&gt;sizeof&lt;/code&gt; 소스 배열의 식입니다. 예를 들어 다음 함수에서 &lt;code&gt;strncat&lt;/code&gt; 에 대한 호출 은 소스 문자열의 크기를 바운드로 지정합니다. 그것은 거의 확실히 실수이므로 호출이 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="4f244ab7b0dd86244a85d676a4e7e6a378a2f85e" translate="yes" xml:space="preserve">
          <source>also warns about class member allocation functions.</source>
          <target state="translated">또한 클래스 멤버 할당 함수에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="b62db011fc5c4e0ddffda8c03fb7a1020abe09e6" translate="yes" xml:space="preserve">
          <source>also warns about this situation; this warning can be avoided by explicitly tagging the variable or function or moving it into a tagged inline namespace.</source>
          <target state="translated">이 상황에 대해서도 경고합니다. 변수 나 함수에 명시 적으로 태그를 지정하거나 태그가있는 인라인 네임 스페이스로 이동하면이 경고를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816d63e63c53fbbcdc73b605731fb850111597ab" translate="yes" xml:space="preserve">
          <source>alternative</source>
          <target state="translated">alternative</target>
        </trans-unit>
        <trans-unit id="cbcd5fa05a97da31161499a40e885c28da334f58" translate="yes" xml:space="preserve">
          <source>altivec</source>
          <target state="translated">altivec</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="a17ce9b6918e1f1ff5f858aa6106831fa7297c8c" translate="yes" xml:space="preserve">
          <source>always has a large stack. Support for this is implemented in the gold linker in GNU binutils release 2.21 and later.</source>
          <target state="translated">항상 큰 스택이 있습니다. 이것에 대한 지원은 GNU binutils 릴리스 2.21 이상의 골드 링커에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="80e7ce3e370a6dda4a9fb0810b8685ac34fc5708" translate="yes" xml:space="preserve">
          <source>always_inline</source>
          <target state="translated">always_inline</target>
        </trans-unit>
        <trans-unit id="8dbe12ece6858c4818dac43b3d526c9a1f59fee3" translate="yes" xml:space="preserve">
          <source>am33</source>
          <target state="translated">am33</target>
        </trans-unit>
        <trans-unit id="11b883c428dac39d27e1d63b6df041f0638d659b" translate="yes" xml:space="preserve">
          <source>am33-2</source>
          <target state="translated">am33-2</target>
        </trans-unit>
        <trans-unit id="534aa547f58efe57e7088bffcb38a66eaac8a75f" translate="yes" xml:space="preserve">
          <source>am34</source>
          <target state="translated">am34</target>
        </trans-unit>
        <trans-unit id="1ea0b794e1acd33fc0e733b79c72bf9252569c11" translate="yes" xml:space="preserve">
          <source>amd</source>
          <target state="translated">amd</target>
        </trans-unit>
        <trans-unit id="2395059e740ec74ddaadf44ba1fd6be5abeb4f3f" translate="yes" xml:space="preserve">
          <source>amd64</source>
          <target state="translated">amd64</target>
        </trans-unit>
        <trans-unit id="b35a515e5c6e1bbc58411f2be892a9ab16847ea8" translate="yes" xml:space="preserve">
          <source>amdfam10</source>
          <target state="translated">amdfam10</target>
        </trans-unit>
        <trans-unit id="3a6d03b94ef74592e176a5d5190e78a646119762" translate="yes" xml:space="preserve">
          <source>amdfam10h</source>
          <target state="translated">amdfam10h</target>
        </trans-unit>
        <trans-unit id="261cb5d6b8474d348d7cc4b9daa4299477e3581e" translate="yes" xml:space="preserve">
          <source>amdfam15h</source>
          <target state="translated">amdfam15h</target>
        </trans-unit>
        <trans-unit id="77c479bd3bd5a6e9817c756457f45b3383bfda8b" translate="yes" xml:space="preserve">
          <source>amdfam17h</source>
          <target state="translated">amdfam17h</target>
        </trans-unit>
        <trans-unit id="fd4a625a31a18d16fe04662ffe5a54c9d06947f3" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;enum&lt;/code&gt; is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration values. Often the compiler users &lt;code&gt;unsigned int&lt;/code&gt;, which is then encoded as &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 정수형 그대로 부호화 열거 값에 따라 그에 대한 컴파일러 용도있다. 종종 컴파일러 사용자는 &lt;code&gt;unsigned int&lt;/code&gt; 를 &lt;code&gt;I&lt;/code&gt; 로 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="4a2ad1f0fd30a224aa1740e4739fe7eb9ee94f86" translate="yes" xml:space="preserve">
          <source>an ACC register number</source>
          <target state="translated">ACC 등록 번호</target>
        </trans-unit>
        <trans-unit id="45bc278ac53a1060e69cab091ecac756552d2721" translate="yes" xml:space="preserve">
          <source>an IACC register number</source>
          <target state="translated">IACC 레지스터 번호</target>
        </trans-unit>
        <trans-unit id="0666bd4cf85f6a8a3d638122033f89aff472392a" translate="yes" xml:space="preserve">
          <source>an integer constant</source>
          <target state="translated">정수 상수</target>
        </trans-unit>
        <trans-unit id="6d3c084323cc6197a38855b1039213d1fa5e3a22" translate="yes" xml:space="preserve">
          <source>an unsigned doubleword</source>
          <target state="translated">부호없는 더블 워드</target>
        </trans-unit>
        <trans-unit id="3657f24217b612273b00133ebb412d287de01a77" translate="yes" xml:space="preserve">
          <source>an unsigned halfword</source>
          <target state="translated">부호없는 하프 워드</target>
        </trans-unit>
        <trans-unit id="1773204396a38972d97d6f1c14d98973abbaa970" translate="yes" xml:space="preserve">
          <source>an unsigned word</source>
          <target state="translated">부호없는 단어</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="70913d37024f402445c0df52a7fadf651367bc49" translate="yes" xml:space="preserve">
          <source>and &amp;ldquo;on&amp;rdquo; for</source>
          <target state="translated">그리고 &quot;에&quot;</target>
        </trans-unit>
        <trans-unit id="16ef79c113045b4dd6e920ca55a6a62dad230d8e" translate="yes" xml:space="preserve">
          <source>and 2 for</source>
          <target state="translated">그리고 2</target>
        </trans-unit>
        <trans-unit id="6e8bd910160e77b35630d8e9ecd21b71ad3f3f1e" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; instead of &lt;code&gt;__declspec(dllexport)&lt;/code&gt; you get almost identical semantics with identical syntax. This is a great boon to those working with cross-platform projects.</source>
          <target state="translated">및 &lt;code&gt;__attribute__ ((visibility(&quot;default&quot;)))&lt;/code&gt; 대신 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 사용하면 동일한 구문과 거의 동일한 의미를 얻는다. 이것은 크로스 플랫폼 프로젝트를 수행하는 사람들에게 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd7bafc40d24575da004f86f8a90c2aaf8b6d10" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;gold&lt;/code&gt; is used as the linker plugin, &lt;code&gt;externally_visible&lt;/code&gt; attributes are automatically added to functions (not variable yet due to a current &lt;code&gt;gold&lt;/code&gt; issue) that are accessed outside of LTO objects according to resolution file produced by &lt;code&gt;gold&lt;/code&gt;. For other linkers that cannot generate resolution file, explicit &lt;code&gt;externally_visible&lt;/code&gt; attributes are still necessary.</source>
          <target state="translated">및 &lt;code&gt;gold&lt;/code&gt; 링커 플러그로서 사용된다 &lt;code&gt;externally_visible&lt;/code&gt; 특성 자동 (전류에 의한 가변 아직없는 기능을 추가 &lt;code&gt;gold&lt;/code&gt; 제조 해상도 파일에 따라 개체 LTO 외부 액세스 월호) &lt;code&gt;gold&lt;/code&gt; . 분석 파일을 생성 할 수없는 다른 링커의 경우 명시 적 &lt;code&gt;externally_visible&lt;/code&gt; 속성이 여전히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc057aa007baa6ea326398d0908a19dee419f14d" translate="yes" xml:space="preserve">
          <source>and CSE is often sufficient to obtain the same effect. However, that is not reliable in cases where the loop body is more complicated than a single basic block. It also does not work at all on some architectures due to restrictions in the CSE pass.</source>
          <target state="translated">CSE는 종종 동일한 효과를 얻기에 충분합니다. 그러나 루프 본체가 단일 기본 블록보다 복잡한 경우에는 신뢰할 수 없습니다. CSE 패스의 제한으로 인해 일부 아키텍처에서는 전혀 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d730a90936bf795bf3e3ee8f9ba908c353e4fdf" translate="yes" xml:space="preserve">
          <source>and PowerPC64 ELFv1 (big-endian) do not support inline PLT calls.</source>
          <target state="translated">PowerPC64 ELFv1 (big-endian)은 인라인 PLT 호출을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b187d89af0f244b0d50df4ccd6e399a3d2177284" translate="yes" xml:space="preserve">
          <source>and above).</source>
          <target state="translated">이상).</target>
        </trans-unit>
        <trans-unit id="540943c2bc2692326429df85dfa3348df4f1b753" translate="yes" xml:space="preserve">
          <source>and above). It warns about subscripts to arrays that are always out of bounds. This warning is enabled by</source>
          <target state="translated">이상). 항상 범위를 벗어난 배열에 대한 첨자에 대해 경고합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="3763092639f876f5583517a9d0eb30243e45a887" translate="yes" xml:space="preserve">
          <source>and above.</source>
          <target state="translated">이상.</target>
        </trans-unit>
        <trans-unit id="e116e2dfbcfa1008e272a76654ceabd0ae9dcd52" translate="yes" xml:space="preserve">
          <source>and above. For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine. This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior. Setting a value of 0 for this parameter allows an unlimited set length.</source>
          <target state="translated">이상. 일부 소스 코드의 경우 향상된 부분 중복 제거 최적화가 실행되어 호스트 시스템에서 사용 가능한 모든 메모리를 소비 할 수 있습니다. 이 매개 변수는 계산 된 세트의 길이에 대한 한계를 설정하여 런 어웨이 동작을 방지합니다. 이 파라미터의 값을 0으로 설정하면 무제한 길이를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c36d2256d758a63a43d0d687d1ad18856d0f48" translate="yes" xml:space="preserve">
          <source>and above. It is included in</source>
          <target state="translated">이상. 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8ca6f8b65a307f3565d2bdeac5195f1e6675246e" translate="yes" xml:space="preserve">
          <source>and above. It works in tandem with the</source>
          <target state="translated">이상. 그것은 함께 작동</target>
        </trans-unit>
        <trans-unit id="196478f2d301e69e64852ded07da61f6a1994c32" translate="yes" xml:space="preserve">
          <source>and above. The flag</source>
          <target state="translated">이상. 깃발</target>
        </trans-unit>
        <trans-unit id="16cca3a59f077ac790f119f67104a42b8a0ffc3d" translate="yes" xml:space="preserve">
          <source>and accordingly for the postamble of the epilogue &amp;mdash; no matter whether the mentioned registers are actually used in the ISR or not. Situations where you might want to use this attribute include:</source>
          <target state="translated">따라서 언급 된 레지스터가 실제로 ISR에 사용되는지 여부에 관계없이 에필로그의 포스트 앰블에 적용됩니다. 이 속성을 사용하려는 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cba2aa225bdda89770493d09134f7ac4e9d6a51" translate="yes" xml:space="preserve">
          <source>and all C files starting with &amp;rsquo;module&amp;rsquo;.</source>
          <target state="translated">그리고 'module'로 시작하는 모든 C 파일.</target>
        </trans-unit>
        <trans-unit id="bab3e293e424c711fb965241b4ac9719742de334" translate="yes" xml:space="preserve">
          <source>and all the</source>
          <target state="translated">그리고 모든</target>
        </trans-unit>
        <trans-unit id="c05c88d23f63de9b36f3b812e4c3b3636aa4477a" translate="yes" xml:space="preserve">
          <source>and also turns on the following optimization flags:</source>
          <target state="translated">또한 다음 최적화 플래그를 켭니다.</target>
        </trans-unit>
        <trans-unit id="2ebde484284695bea6e3641a94d76fb9524875f9" translate="yes" xml:space="preserve">
          <source>and another with</source>
          <target state="translated">그리고 다른</target>
        </trans-unit>
        <trans-unit id="a66594753907e18391761122d0c6251f7905b621" translate="yes" xml:space="preserve">
          <source>and another with the default options. GCC must be configured to use GLIBC 2.23 or newer in order to use the &lt;code&gt;target_clones&lt;/code&gt; attribute.</source>
          <target state="translated">다른 하나는 기본 옵션입니다. &lt;code&gt;target_clones&lt;/code&gt; 속성 을 사용하려면 GLIBC 2.23 이상을 사용하도록 GCC를 구성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="be06f33f42d5fdd847c8ef1a054178ef64e8d724" translate="yes" xml:space="preserve">
          <source>and by</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="bd91aa685e568528bf96de5c3a56f0d28ba7fac2" translate="yes" xml:space="preserve">
          <source>and by default a cost model defined with</source>
          <target state="translated">기본적으로 다음과 같이 정의 된 비용 모델</target>
        </trans-unit>
        <trans-unit id="b58b6b69e9a6e2dffafda6e336f4d4562a450054" translate="yes" xml:space="preserve">
          <source>and code compiled with</source>
          <target state="translated">와 코드 컴파일</target>
        </trans-unit>
        <trans-unit id="5f781abb49c37ac3e1988d7f276013bdf87a40b0" translate="yes" xml:space="preserve">
          <source>and either</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="db999ebc24b4a98f48dfa65e6948013de37b01d1" translate="yes" xml:space="preserve">
          <source>and emitting the result direct to stdout via</source>
          <target state="translated">및 결과를 통해 표준 출력으로 직접 방출하는 단계</target>
        </trans-unit>
        <trans-unit id="1769c9699ef4ab291d81bfc70d0f12e25b85fd42" translate="yes" xml:space="preserve">
          <source>and export those classes that are intended to be externally visible. Unfortunately it is possible for code to rely, perhaps accidentally, on the Visual Studio behavior.</source>
          <target state="translated">외부에서 볼 수있는 클래스를 내 보냅니다. 불행히도 코드가 실수로 Visual Studio 동작에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b302c13ab3c153e6cac498496443414d3fce07" translate="yes" xml:space="preserve">
          <source>and finally</source>
          <target state="translated">그리고 마지막으로</target>
        </trans-unit>
        <trans-unit id="8b3b299fce213f2a1e237365ea4fcb9e5607c1e3" translate="yes" xml:space="preserve">
          <source>and higher and depends on</source>
          <target state="translated">이상에 따라</target>
        </trans-unit>
        <trans-unit id="d3ee9cb1836394c3283e4bf670015859583e15fc" translate="yes" xml:space="preserve">
          <source>and higher as well as</source>
          <target state="translated">뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="5a9bec14cd65cb6407309dcf8b220e22883b3c85" translate="yes" xml:space="preserve">
          <source>and higher if</source>
          <target state="translated">그리고 더 높은 경우</target>
        </trans-unit>
        <trans-unit id="bcbf9cf724baaa2c05cb8d8ef447ba9db9b1d32e" translate="yes" xml:space="preserve">
          <source>and higher on architectures that support this.</source>
          <target state="translated">이를 지원하는 아키텍처에서 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="5652f51541248dfcd407bf27224a828b6323954d" translate="yes" xml:space="preserve">
          <source>and higher,</source>
          <target state="translated">이상</target>
        </trans-unit>
        <trans-unit id="20df9f0858c9d558bdf3ec73ab7b30c8be3693c7" translate="yes" xml:space="preserve">
          <source>and higher, and also at</source>
          <target state="translated">이상</target>
        </trans-unit>
        <trans-unit id="d997e6f0b5d9397ce43f624b10d7171a88e8eab8" translate="yes" xml:space="preserve">
          <source>and higher, except for</source>
          <target state="translated">제외하고</target>
        </trans-unit>
        <trans-unit id="de9609e65fe8304aa2b84c02990d0ddd0b347ca8" translate="yes" xml:space="preserve">
          <source>and higher.</source>
          <target state="translated">이상.</target>
        </trans-unit>
        <trans-unit id="4822df6fd07924d846e61249bdf13788d9ead31a" translate="yes" xml:space="preserve">
          <source>and higher. Higher optimization levels improve the accuracy of the analysis.</source>
          <target state="translated">이상. 최적화 수준이 높을수록 분석의 정확성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="afc0a14fb13d8311f68301c0ecd98042f1e9800d" translate="yes" xml:space="preserve">
          <source>and higher. It is not enabled for</source>
          <target state="translated">이상. 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="a76fab721d9a45aaff56d37fa7059d4d07c6bf05" translate="yes" xml:space="preserve">
          <source>and higher. Null pointer check elimination is only done if</source>
          <target state="translated">이상. 널 포인터 점검 제거는 다음 경우에만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="17f12a1567309243f3153a113c5c9b0dc8b04f9a" translate="yes" xml:space="preserve">
          <source>and higher. The compilation time in this pass can be limited using</source>
          <target state="translated">이상. 이 패스의 컴파일 시간은</target>
        </trans-unit>
        <trans-unit id="1352c6defb413a9629f8a883262aafbdf1d73c3e" translate="yes" xml:space="preserve">
          <source>and if the variable arguments are omitted or empty, the &amp;lsquo;</source>
          <target state="translated">변수 인수가 생략되거나 비어 있으면 '</target>
        </trans-unit>
        <trans-unit id="97253136342a86d551cb8f938043a04fa09b8e17" translate="yes" xml:space="preserve">
          <source>and in the</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="71e7f852efd77608e67d67f4769c27771f643624" translate="yes" xml:space="preserve">
          <source>and in the cases of</source>
          <target state="translated">그리고의 경우</target>
        </trans-unit>
        <trans-unit id="8e1a25c4625f2b80697437af8a97194c0476ac2c" translate="yes" xml:space="preserve">
          <source>and introduces new signatures for user-defined literals:</source>
          <target state="translated">사용자 정의 리터럴에 대한 새로운 서명을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="4a1b1d4b275aa98ab0a4a65283ca64d508b23283" translate="yes" xml:space="preserve">
          <source>and is defined for compatibility with Diab.</source>
          <target state="translated">Diab와의 호환성을 위해 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="b6b1e55ec15f2cb25e78716d325961ca33806bb5" translate="yes" xml:space="preserve">
          <source>and is deprecated.</source>
          <target state="translated">더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c32e4dd09aae4d64ecbad3933f8c85c732ca5ff" translate="yes" xml:space="preserve">
          <source>and is enabled by</source>
          <target state="translated">에 의해 활성화</target>
        </trans-unit>
        <trans-unit id="60f868f3a7c169f71793f02a83a16555d3150a50" translate="yes" xml:space="preserve">
          <source>and is enabled by default in C99 and C++11 modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit. (However, in C, such an overflow is still rejected in contexts where an integer constant expression is required.) No warning is emitted in C++2A mode (and newer), as signed left shifts always wrap.</source>
          <target state="translated">C99 및 C ++ 11 모드 이상에서 기본적으로 사용됩니다. 이 경고 레벨은 왼쪽 시프트 1을 부호 비트로 경고하는 것은 아닙니다. 그러나 C에서는 정수 상수 표현식이 필요한 상황에서는 이러한 오버 플로우가 여전히 거부됩니다. 부호있는 왼쪽 시프트가 항상 랩되므로 C ++ 2A 모드 (및 그 이상)에서는 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18a6194526a99bc8a75aa2625ef50b249a3cc54a" translate="yes" xml:space="preserve">
          <source>and is ignored at link time.</source>
          <target state="translated">링크 타임에 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8cdd0a931822d69709608b564b7f6b552ac906b1" translate="yes" xml:space="preserve">
          <source>and its related options. Both absolute and relative paths can be used. By default, GCC uses the current directory as &lt;var&gt;path&lt;/var&gt;, thus the profile data file appears in the same directory as the object file. In order to prevent the file name clashing, if the object file name is not an absolute path, we mangle the absolute path of the</source>
          <target state="translated">및 관련 옵션. 절대 및 상대 경로를 모두 사용할 수 있습니다. 기본적으로 GCC는 현재 디렉토리를 &lt;var&gt;path&lt;/var&gt; 로 사용하므로 프로파일 데이터 파일은 객체 파일과 동일한 디렉토리에 나타납니다. 파일 이름 충돌을 방지하기 위해 객체 파일 이름이 절대 경로가 아닌 경우 파일 이름의 절대 경로를 맹 글링합니다.</target>
        </trans-unit>
        <trans-unit id="8aaeb495a9e5b482acebee2f5a8a0a37a7e8745c" translate="yes" xml:space="preserve">
          <source>and joined by spaces. This list is intended to be passed to the LTO linker plugin.</source>
          <target state="translated">공백으로 연결됩니다. 이 목록은 LTO 링커 플러그인으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c7acf5a5b05ac0929c1671052424680580734fbc" translate="yes" xml:space="preserve">
          <source>and let the driver handle the options instead.</source>
          <target state="translated">대신 드라이버가 옵션을 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="bfccb2c5c250efe79e7d9930697e9b24c391e2ac" translate="yes" xml:space="preserve">
          <source>and libraries in</source>
          <target state="translated">라이브러리</target>
        </trans-unit>
        <trans-unit id="f0e01a5c55ee31dbcc71234d1f7dd13b04392356" translate="yes" xml:space="preserve">
          <source>and must be explicitly requested since in C++ this isn&amp;rsquo;t an error and in C it might be harder to clean up all headers included.</source>
          <target state="translated">C ++에서는 오류가 아니기 때문에 명시 적으로 요청해야하며 C에서는 포함 된 모든 헤더를 정리하기가 더 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b774402ab6984eabd550c359a10ea00ca9ffbe" translate="yes" xml:space="preserve">
          <source>and optimization options should be specified at compile time and during the final link. It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time. For example:</source>
          <target state="translated">최적화 옵션은 컴파일 타임과 최종 링크 중에 지정해야합니다. 동일한 링크에 참여하는 모든 파일을 동일한 옵션으로 컴파일하고 링크 타임에 해당 옵션을 지정하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7904d214a56c9420eebba683732a4bd59f75475" translate="yes" xml:space="preserve">
          <source>and other options cause warnings for many GNU C extensions. You can prevent such warnings within one expression by writing &lt;code&gt;__extension__&lt;/code&gt; before the expression. &lt;code&gt;__extension__&lt;/code&gt; has no effect aside from this.</source>
          <target state="translated">다른 옵션은 많은 GNU C 확장에 경고를 유발합니다. 식 앞에 &lt;code&gt;__extension__&lt;/code&gt; 을 작성하여 한 식 내에서 이러한 경고를 방지 할 수 있습니다 . &lt;code&gt;__extension__&lt;/code&gt; 은 이것 외에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="737b71e6d8426b3fda4249cd8c1165da4988f20d" translate="yes" xml:space="preserve">
          <source>and outputs the command-line option</source>
          <target state="translated">명령 행 옵션을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="4a51075a2d63bdd9c031332e64282ebb86738b8f" translate="yes" xml:space="preserve">
          <source>and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.</source>
          <target state="translated">최적화 된 집계 된 GIMPLE 이미지의 일부로 만들기 위해 실행중인 GCC로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b7483c73e6a38e6274495270d12341498eeacbbb" translate="yes" xml:space="preserve">
          <source>and prevents linking with the shared libraries. On other systems, this option has no effect.</source>
          <target state="translated">공유 라이브러리와의 연결을 방지합니다. 다른 시스템에서는이 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123217ee99d19efe020f3f3466fda26930ff804c" translate="yes" xml:space="preserve">
          <source>and remove the</source>
          <target state="translated">그리고 제거</target>
        </trans-unit>
        <trans-unit id="d0ba1984262756dc3e97eba7054a343cd95b906e" translate="yes" xml:space="preserve">
          <source>and sets the start address of the program to 0x800.</source>
          <target state="translated">프로그램의 시작 주소를 0x800으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ca533d5e239b86c5bce8e5223c75d9799ce24658" translate="yes" xml:space="preserve">
          <source>and so on. Most of these have both positive and negative forms; the negative form of</source>
          <target state="translated">등등. 이들 중 대부분은 긍정적이고 부정적인 형태를 가지고 있습니다. 부정적인 형태</target>
        </trans-unit>
        <trans-unit id="8448c2525daee3e2e6799cb7b66fc64c9ee09e88" translate="yes" xml:space="preserve">
          <source>and that the standard C libraries are</source>
          <target state="translated">표준 C 라이브러리는</target>
        </trans-unit>
        <trans-unit id="673968187c298fea9b969fc56a05d8e49cf79c7d" translate="yes" xml:space="preserve">
          <source>and the Fortran-specific</source>
          <target state="translated">포트란 별</target>
        </trans-unit>
        <trans-unit id="584bb0d053da62487d41fcb63d90a5569011ef09" translate="yes" xml:space="preserve">
          <source>and the application be linked with</source>
          <target state="translated">응용 프로그램은</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
