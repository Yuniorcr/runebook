<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="3e45126d173c9f83af0c8a4d42e612d7cbdfdcc5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options are supported on the TILEPro:</source>
          <target state="translated">TILEPro에서 지원되는 옵션 :</target>
        </trans-unit>
        <trans-unit id="e2d4212fc8e500ed936c66f91d94bb442c281361" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options defined for M680x0 and ColdFire processors. The default settings depend on which architecture was selected when the compiler was configured; the defaults for the most common choices are given below.</source>
          <target state="translated">'M680x0 및 ColdFire 프로세서에 대해 정의 된 옵션입니다. 기본 설정은 컴파일러를 구성 할 때 선택한 아키텍처에 따라 다릅니다. 가장 일반적인 선택의 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12ed028d54d90074036536de35874efd099113cc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options defined for the Intel IA-64 architecture.</source>
          <target state="translated">옵션은 인텔 IA-64 아키텍처에 대해 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9361b6e6a0248c72de91480eff99a4173461130" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options defined for the Motorola M*Core processors.</source>
          <target state="translated">Motorola M * Core 프로세서에 대해 정의 된 옵션.</target>
        </trans-unit>
        <trans-unit id="f9d7728363a1c57b4f3fe364b1f6ae217cf26e85" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options defined for the S/390 and zSeries architecture.</source>
          <target state="translated">S / 390 및 zSeries 아키텍처에 정의 된 옵션.</target>
        </trans-unit>
        <trans-unit id="88146812c5c99870bce47654591da4916f1e6098" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options) arrange (eliminate arrangements) for the stack frame, individual data and constants to be aligned for the maximum single data access size for the chosen CPU model. The default is to arrange for 32-bit alignment. ABI details such as structure layout are not affected by these options.</source>
          <target state="translated">옵션은 스택 프레임, 개별 데이터 및 상수가 선택된 CPU 모델의 최대 단일 데이터 액세스 크기에 맞게 정렬되도록합니다 (배열 제거). 기본 설정은 32 비트 정렬입니다. 구조 레이아웃과 같은 ABI 세부 정보는 이러한 옵션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="209637ec6e6c0e100a8945dd77c54299e981870e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; options.</source>
          <target state="translated">옵션.</target>
        </trans-unit>
        <trans-unit id="c051371f8937469bcb7c2e99a74ceea414f863fe" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or &amp;lsquo;</source>
          <target state="translated">'또는'</target>
        </trans-unit>
        <trans-unit id="48c689e2cc2e0209a8b3a065951640655d746c00" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or &lt;code&gt;$SYSROOT&lt;/code&gt; is replaced by the sysroot prefix; see</source>
          <target state="translated">'또는 &lt;code&gt;$SYSROOT&lt;/code&gt; 는 sysroot 접두어로 대체됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="f8481e5d860c5d8e5ecdd2c50ff1cbdcb024c8a5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or &lt;code&gt;$SYSROOT&lt;/code&gt;, then the &amp;lsquo;</source>
          <target state="translated">'또는 &lt;code&gt;$SYSROOT&lt;/code&gt; 이면'</target>
        </trans-unit>
        <trans-unit id="043be17ae0f7c3d7a9c4cfb6ac1b0185fec22c5b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or &lt;var&gt;native&lt;/var&gt;.</source>
          <target state="translated">'또는 &lt;var&gt;native&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cadc57fbc541ed8d0539abc5c5699327ee54af17" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or adding it.</source>
          <target state="translated">또는 추가.</target>
        </trans-unit>
        <trans-unit id="bf736093218c75ec4e7cd3f976f459490e75a82e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or declared in system or compiler headers.</source>
          <target state="translated">'또는 시스템 또는 컴파일러 헤더에서 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="86487df2bc959d5aea33992acd350f051b6c32c0" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or higher. If hardware floating point instructions are being generated then the C preprocessor symbol &lt;code&gt;__FPU_OK__&lt;/code&gt; is defined, otherwise the symbol &lt;code&gt;__NO_FPU__&lt;/code&gt; is defined.</source>
          <target state="translated">' 또는 더 높게. 하드웨어 부동 소수점 명령어가 생성되면 C 프리 프로세서 기호 &lt;code&gt;__FPU_OK__&lt;/code&gt; 가 정의되고 그렇지 않으면 &lt;code&gt;__NO_FPU__&lt;/code&gt; 기호 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b5132656d002ad4ce3177e193b5c68ce50e74230" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or larger.</source>
          <target state="translated">'이상.</target>
        </trans-unit>
        <trans-unit id="5fa602c893b7540ffbd1e91c955d1716a1576b57" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or later. This is the default. This option defines the preprocessor macro &lt;code&gt;__LIW__&lt;/code&gt;.</source>
          <target state="translated">'이상. 이것이 기본값입니다. 이 옵션은 전 처리기 매크로 &lt;code&gt;__LIW__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c4dd904c5fb4fcbd7cc13e0bb383a3e3c6aa4701" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or later. This is the default. This option defines the preprocessor macro &lt;code&gt;__SETLB__&lt;/code&gt;.</source>
          <target state="translated">'이상. 이것이 기본값입니다. 이 옵션은 전 처리기 매크로 &lt;code&gt;__SETLB__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="52aec7fe31e35c40ade8a8360102a82b38ee165a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or more or by</source>
          <target state="translated">'이상</target>
        </trans-unit>
        <trans-unit id="83573bfb082de6c4b0dcb6f0417cd6cee355e722" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or similar construct can use a backslash to ignore the special meaning of the character following it, thus allowing literal matching of a character that is otherwise specially treated. For example, &amp;lsquo;</source>
          <target state="translated">'또는 이와 유사한 구문은 백 슬래시를 사용하여 뒤에 오는 문자의 특수한 의미를 무시할 수 있으므로 특별히 처리되는 문자의 리터럴 일치를 허용합니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="beeb97ada8e276e8fa205b82d44514b8ccfab523" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or similar construct may contain other nested &amp;lsquo;</source>
          <target state="translated">'또는 이와 유사한 구문에는 다른 중첩 된'</target>
        </trans-unit>
        <trans-unit id="61372132dd71c601ee73c08a55327505acf9f3b9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or the special string &amp;lsquo;</source>
          <target state="translated">'또는 특수 문자열'</target>
        </trans-unit>
        <trans-unit id="bda6b24116bb0d9742b26847ffae3657cecd50ae" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; or with &amp;lsquo;</source>
          <target state="translated">'또는'</target>
        </trans-unit>
        <trans-unit id="cc9f2412c49de044b897ed121f0f9ca8709a12cd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; otherwise. &amp;lsquo;</source>
          <target state="translated">그렇지 않으면. '</target>
        </trans-unit>
        <trans-unit id="ec149ba66b939f8546f4e2bdaebf6bea6a1c7fc5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; otherwise. The GCC driver automatically selects &amp;lsquo;</source>
          <target state="translated">그렇지 않으면. GCC 드라이버는 자동으로 '</target>
        </trans-unit>
        <trans-unit id="4aad7874be07f1faef249c25cdae44bd2f76410a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pair. All lines after this directive and up to the next directive or blank line are considered to make up the spec string for the indicated suffix. When the compiler encounters an input file with the named suffix, it processes the spec string in order to work out how to compile that file. For example:</source>
          <target state="translated">'쌍. 이 지시문 다음과 다음 지시문 또는 빈 행까지의 모든 행은 표시된 접미사의 스펙 문자열을 구성하는 것으로 간주됩니다. 컴파일러는 이름이 지정된 접미사가있는 입력 파일을 발견하면 해당 파일을 컴파일하는 방법을 찾기 위해 스펙 문자열을 처리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5cd41e49b746cd8aacc2f300c1e7c9ce59a1f43" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pair. The set of call-saved registers also remains the same in that the even-numbered double-precision registers are saved.</source>
          <target state="translated">'쌍. 호출 저장 레지스터 세트도 짝수 배정 밀도 레지스터가 저장된다는 점에서 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4d2f7d31ef55c034e21e0b00c9d0c1b28e605f5a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; parameter has to be specified as well.</source>
          <target state="translated">'매개 변수도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c445adefb3dc0e5666af740dcde3fc1c3feb5a32" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; parameter inserted as the first parameter indicating the size of the object being pointed to. All objects must be the same size.</source>
          <target state="translated">'매개 변수가 가리키는 객체의 크기를 나타내는 첫 번째 매개 변수로 삽입되었습니다. 모든 객체의 크기가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="4d4d62c248b664f4f828763b22a0a69cb6809c0b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; partitioning is intended for internal testing only. The value &amp;lsquo;</source>
          <target state="translated">'파티셔닝은 내부 테스트 전용입니다. 가치 '</target>
        </trans-unit>
        <trans-unit id="d4d7aab219721f35503df410bd55382075bf2c9e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; performs complex conjugation when used on a value with a complex type. This is a GNU extension; for values of floating type, you should use the ISO C99 functions &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt; and &lt;code&gt;conjl&lt;/code&gt;, declared in &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and also provided as built-in functions by GCC.</source>
          <target state="translated">'는 복잡한 유형의 값에 사용될 때 복잡한 컨쥬 게이션을 수행합니다. 이것은 GNU 확장입니다. 부동 유형의 값의 경우 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 에 선언되어 있고 GCC에서 내장 함수로 제공되는 ISO C99 함수 &lt;code&gt;conjf&lt;/code&gt; , &lt;code&gt;conj&lt;/code&gt; 및 &lt;code&gt;conjl&lt;/code&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3fdb823002dc6dfd9b967615f77b498f39af6f0c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pointer, and if the function pointed to is virtual, where to find the vtable, and where in the vtable to look for the member function. If you are using PMFs in an inner loop, you should really reconsider that decision. If that is not an option, you can extract the pointer to the function that would be called for a given object/PMF pair and call it directly inside the inner loop, to save a bit of time.</source>
          <target state="translated">'포인터를 가리키고 함수가 가상 인 경우 vtable을 찾을 위치와 vtable에서 멤버 함수를 찾을 위치를 지정하십시오. 내부 루프에서 PMF를 사용하는 경우 해당 결정을 다시 고려해야합니다. 이것이 옵션이 아닌 경우, 주어진 객체 / PMF 쌍에 대해 호출 될 함수에 대한 포인터를 추출하여 내부 루프 내에서 직접 호출하여 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4563c051a6a6c66cf5ff3c3a90291d825d095381" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pragmas.</source>
          <target state="translated">'pragmas.</target>
        </trans-unit>
        <trans-unit id="d9a7dcbf0dc6de330b210ef05aa967c5a5670ddc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pre-processor directives, and the &amp;lsquo;</source>
          <target state="translated">'전 처리기 지시문 및'</target>
        </trans-unit>
        <trans-unit id="5641c689cca07cacc9259cf5cbc868ef50ea405f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; preceding and following the name. This allows you to use them in header files without being concerned about a possible macro of the same name. For example, you may use the attribute name &lt;code&gt;__noreturn__&lt;/code&gt; instead of &lt;code&gt;noreturn&lt;/code&gt;.</source>
          <target state="translated">'이름 앞뒤로. 이를 통해 동일한 이름의 가능한 매크로에 대해 염려하지 않고 헤더 파일에서 사용할 수 있습니다. 예를 들어, &lt;code&gt;noreturn&lt;/code&gt; 대신 속성 이름 &lt;code&gt;__noreturn__&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35189e0b3ea3ee398947b0a83eca5595687c8f18" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; prefix and also by being overloaded so that they work on multiple types.</source>
          <target state="translated">접두사와 오버로드되어 여러 유형에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="96ab426a6b5a3c861e723eb2367dd608173e34fd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; prefix.</source>
          <target state="translated">'접두사.</target>
        </trans-unit>
        <trans-unit id="3f227e9083fdcdf835eb89a3b7e5aea560e8c746" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; prefix. Arguments to options that specify a size threshold of some sort may be arbitrarily large decimal or hexadecimal integers followed by a byte size suffix designating a multiple of bytes such as &lt;code&gt;kB&lt;/code&gt; and &lt;code&gt;KiB&lt;/code&gt; for kilobyte and kibibyte, respectively, &lt;code&gt;MB&lt;/code&gt; and &lt;code&gt;MiB&lt;/code&gt; for megabyte and mebibyte, &lt;code&gt;GB&lt;/code&gt; and &lt;code&gt;GiB&lt;/code&gt; for gigabyte and gigibyte, and so on. Such arguments are designated by &lt;var&gt;byte-size&lt;/var&gt; in the following text. Refer to the NIST, IEC, and other relevant national and international standards for the full listing and explanation of the binary and decimal byte size prefixes.</source>
          <target state="translated">'접두사. 어떤 종류의 크기 임계 값을 지정하는 옵션에 대한 인수는 임의로 큰 10 진수 또는 16 진 정수 다음에 킬로바이트 및 킬비 바이트의 &lt;code&gt;kB&lt;/code&gt; 및 &lt;code&gt;KiB&lt;/code&gt; , 각각 메가 바이트 및 메비 바이트의 경우 &lt;code&gt;MB&lt;/code&gt; 및 &lt;code&gt;MiB&lt;/code&gt; , 기가 바이트 및 기가 바이트 등의 &lt;code&gt;GB&lt;/code&gt; 및 &lt;code&gt;GiB&lt;/code&gt; 이러한 인수는 다음 텍스트에서 &lt;var&gt;byte-size&lt;/var&gt; 로 지정됩니다 . 이진 및 십진 바이트 크기 접두사에 대한 전체 목록과 설명은 NIST, IEC 및 기타 관련 국가 및 국제 표준을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f50153a267c6e375eec867e2a3730edf61454105" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; prefixes. The number parsed is placed in the significand such that the least significant bit of the number is at the least significant bit of the significand. The number is truncated to fit the significand field provided. The significand is forced to be a quiet NaN.</source>
          <target state="translated">접두사. 구문 분석 된 숫자는 유효 숫자에 배치되어 숫자의 최하위 비트가 유효 숫자의 최하위 비트에있게됩니다. 제공된 significand 필드에 맞게 숫자가 잘립니다. 중요한 것은 조용한 NaN이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="355872b2b1a3c3bd3ba8d658ef382e09e32073a3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; preprocessor constant is defined.</source>
          <target state="translated">'전 처리기 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d73ba346be03f7ededf629759b3e3a744322a7e4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; present for backward compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6fcfb1d20306c0f703ac5ec60dac33f6fdbd9821" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pseudo target defaults to VFPv3 with 16 double-precision registers. It supports the following extension options: &amp;lsquo;</source>
          <target state="translated">의사 대상의 기본값은 16 개의 배정 밀도 레지스터가있는 VFPv3입니다. 다음 확장 옵션을 지원합니다 : '</target>
        </trans-unit>
        <trans-unit id="50fd8239eabc9a97d95bc4f4d278515e31bcaee2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; pseudo-op). Default visibility is supported everywhere. Hidden visibility is supported on Darwin targets.</source>
          <target state="translated">'의사). 기본 가시성은 모든 곳에서 지원됩니다. 숨겨진 가시성은 Darwin 대상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="defa7344a1649b93a1b43c1af97fa03cea56040a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; rather than &amp;lsquo;</source>
          <target state="translated">'보다는'</target>
        </trans-unit>
        <trans-unit id="3486fdf02e76707d71811fb7d79c2ba2a04a89c9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; rather than the usual &amp;lsquo;</source>
          <target state="translated">'평소보다'</target>
        </trans-unit>
        <trans-unit id="8582e11d6dddda4b9f538d0f60eda9549f5f57ed" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refer to processors with FPUs clocked a ratio of 3:2 with respect to the core. For compatibility reasons, &amp;lsquo;</source>
          <target state="translated">FPU가 코어에 대해 3 : 2의 비율로 클럭킹 된 프로세서를 말합니다. 호환성을 위해 '</target>
        </trans-unit>
        <trans-unit id="dabe2122a4b1653e8a50e28085b2b8047b7632bb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refer to processors with FPUs clocked at half the rate of the core, names of the form &amp;lsquo;</source>
          <target state="translated">'FPU가 코어 속도의 절반 속도로 클럭 된 프로세서를 의미하며'</target>
        </trans-unit>
        <trans-unit id="abe7c7597ca8ffa158c739f3718b9881c80ffc3f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refer to processors with FPUs clocked at the same rate as the core, and names of the form &amp;lsquo;</source>
          <target state="translated">'코어와 동일한 속도로 클럭 된 FPU가있는 프로세서와 이름이'</target>
        </trans-unit>
        <trans-unit id="600d3de7356da0b80ca6cd07490e0619b1e142c7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refer to the formats accepted by the</source>
          <target state="translated">'에서 허용하는 형식을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e92b96d2b6c894c413be8d124af5dac7f82f1609" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refers to a literal capital C.</source>
          <target state="translated">'는 리터럴 대문자 C를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2f55ba0d5f66754cf295ecfc832192516dfb2ed7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; refers to a literal capital M.</source>
          <target state="translated">'는 리터럴 대문자 M을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5d17117b0897deb757c55ae8924e7ef2b5b9f25" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register</source>
          <target state="translated">'등록</target>
        </trans-unit>
        <trans-unit id="56f95697e72cd24b02f414593adabf5fb04e9dd8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register (condition register)</source>
          <target state="translated">'레지스터 (조건 레지스터)</target>
        </trans-unit>
        <trans-unit id="27ddc79ec0fe4e9db1fc81b7565ee71dfb87254d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register (condition register) number 0</source>
          <target state="translated">'레지스터 (조건 레지스터) 번호 0</target>
        </trans-unit>
        <trans-unit id="dbe7571283716a455bbbea92bd21b227f87e5595" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register names for the stacked registers. This may make assembler output more readable.</source>
          <target state="translated">스택 된 레지스터의 레지스터 이름. 이것은 어셈블러 출력을 더 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a24f843d58a90ab3ed3bce4238729c6f6a2d9b15" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register to the specified value &lt;var&gt;ptr&lt;/var&gt;. This is usually used by system code that manages threads and execution contexts. The compiler normally does not generate code that modifies the contents of &amp;lsquo;</source>
          <target state="translated">'지정된 값 &lt;var&gt;ptr&lt;/var&gt; 에 등록하십시오 . 이것은 일반적으로 스레드 및 실행 컨텍스트를 관리하는 시스템 코드에서 사용됩니다. 컴파일러는 일반적으로 '의 내용을 수정하는 코드를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15b6a8cc1ce090db804f62155ebcfe9fdfd32f43" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register to the specified value &lt;var&gt;val&lt;/var&gt;, while preserving the current values of the FR, SZ and PR bits.</source>
          <target state="translated">FR, SZ 및 PR 비트의 현재 값을 유지하면서 지정된 값 &lt;var&gt;val&lt;/var&gt; 에 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="32b88b9c6f4ce4c1ae7fce0458bc87eef665ddf1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register.</source>
          <target state="translated">'등록.</target>
        </trans-unit>
        <trans-unit id="794978d8b41ed92d143d12ac181aca522b22af26" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; register. Memory loads and stores that use the thread pointer as a base address are turned into &amp;lsquo;</source>
          <target state="translated">'등록. 스레드 포인터를 기본 주소로 사용하는 메모리로드 및 저장소는 '</target>
        </trans-unit>
        <trans-unit id="d17477141c67c1f66f16dcaf910190f1c3cc4e3f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; respectively.</source>
          <target state="translated">'.</target>
        </trans-unit>
        <trans-unit id="a9b7acec614e26d84f44c29e6daaf9dc7fd3103e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; searches library &amp;lsquo;</source>
          <target state="translated">'검색 라이브러리'</target>
        </trans-unit>
        <trans-unit id="cef525c893fe2c7450842b9e7aea51bac5e3d29d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; selects the most compatible architecture for the selected ABI (that is, &amp;lsquo;</source>
          <target state="translated">'는 선택한 ABI에 대해 가장 호환 가능한 아키텍처를 선택합니다 (즉,'</target>
        </trans-unit>
        <trans-unit id="481f5997a73ce97b055885eccc211f2b92c9474d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; selects vector-length agnostic output. At present &amp;lsquo;</source>
          <target state="translated">'는 벡터 길이에 구애받지 않는 출력을 선택합니다. 현재 '</target>
        </trans-unit>
        <trans-unit id="b23ede7a85c283a7ae7da9db47d3be845ba3234c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; separated fields along with program source code. The format is</source>
          <target state="translated">프로그램 소스 코드와 함께 구분 된 필드. 형식은</target>
        </trans-unit>
        <trans-unit id="74c9d5f175b9ec00e30e09a9e05f50d72f5e873f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; separated option keywords to select the dump details and optimizations.</source>
          <target state="translated">'옵션 키워드를 구분하여 덤프 세부 사항 및 최적화를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5425a69eadc821abc7b54b5f2baa8ba205522d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; separated options which control the details of the dump. Not all options are applicable to all dumps; those that are not meaningful are ignored. The following options are available</source>
          <target state="translated">'옵션은 덤프의 세부 사항을 제어합니다. 모든 옵션이 모든 덤프에 적용되는 것은 아닙니다. 의미가없는 것은 무시됩니다. 다음과 같은 옵션을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="21bc80d788388475b1818d47e86cbacdf33c7152" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; sequences.</source>
          <target state="translated">'서열.</target>
        </trans-unit>
        <trans-unit id="74e190e05401bca34927b5278656e6d6e921333c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; series does not have a hardware floating-point unit and so</source>
          <target state="translated">'시리즈에는 하드웨어 부동 소수점 장치가 없으므로</target>
        </trans-unit>
        <trans-unit id="10f09dc09551560e9a45030ebd6e30695d66a5fd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; series hardware and the specific &amp;lsquo;</source>
          <target state="translated">'시리즈 하드웨어 및 특정'</target>
        </trans-unit>
        <trans-unit id="fec78580cc0226cf2394840560a7d651e6983bdb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; sets it to its standard level. &amp;lsquo;</source>
          <target state="translated">'표준 수준으로 설정합니다. '</target>
        </trans-unit>
        <trans-unit id="c07d079738bce040037eb1f1fd2ea5c8fff94a71" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; should be passed to the program &amp;lsquo;</source>
          <target state="translated">'프로그램으로 전달되어야합니다.'</target>
        </trans-unit>
        <trans-unit id="5e6948a2dfdcbe5c825830e9f31be0f8b5635e9d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; should be relied on for producing code that is portable across different hardware SVE vector lengths.</source>
          <target state="translated">'는 서로 다른 하드웨어 SVE 벡터 길이에서 이식 가능한 코드를 생성하는 데 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee57cff3cefff28a9da8ab2e18f679a918744aec" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; sign, the type of the members and by &amp;lsquo;</source>
          <target state="translated">'기호, 회원 유형 및'</target>
        </trans-unit>
        <trans-unit id="6656ef212b86feb4280e0b002e306faab678402b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; sign, the type of the members followed by &amp;lsquo;</source>
          <target state="translated">'기호, 멤버의 유형 다음에'</target>
        </trans-unit>
        <trans-unit id="77b4ad927c69486a178202aa19e5e3eef2cea0ca" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; since the &amp;lsquo;</source>
          <target state="translated">'이후'</target>
        </trans-unit>
        <trans-unit id="6eb85024f3ec55e7b20f046424d94f4a06238808" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; spec string.</source>
          <target state="translated">사양 문자열.</target>
        </trans-unit>
        <trans-unit id="081e2943adf837892353eab8656e6ca9e7c091b9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; specifies that exactly one partition should be used while the value &amp;lsquo;</source>
          <target state="translated">'는 정확히 하나의 파티션을 사용하고 값은'</target>
        </trans-unit>
        <trans-unit id="7b6c33ed91a7375352c2955837851068b44100e9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; specify that GCC should tune for a big.LITTLE system.</source>
          <target state="translated">'GCC가 big.LITTLE 시스템에 맞게 조정되도록 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1d64ff9d9b4091a4c3b0888ad9aa14c25dc75e79" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; stack it is. Precompiled header files are also printed, even if they are found to be invalid; an invalid precompiled header file is printed with &amp;lsquo;</source>
          <target state="translated">'스택입니다. 사전 컴파일 된 헤더 파일도 유효하지 않은 것으로 판명되어 인쇄됩니다. 유효하지 않은 사전 컴파일 된 헤더 파일이 '</target>
        </trans-unit>
        <trans-unit id="3f77b91c30a3d55044b432a8c79262b81f7739ab" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; stands for &amp;lsquo;</source>
          <target state="translated">'는'</target>
        </trans-unit>
        <trans-unit id="9f4f579e9779d89eea635da5e3420f9b0583a365" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; stands for the character</source>
          <target state="translated">'는 캐릭터를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="35c9d4dd0e4446cfda2d97ec7fdbd6cdd2482a57" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; style name or the corresponding chip number. GCC supports scheduling parameters for the EV4, EV5 and EV6 family of processors and chooses the default values for the instruction set from the processor you specify. If you do not specify a processor type, GCC defaults to the processor on which the compiler was built.</source>
          <target state="translated">'스타일 이름 또는 해당 칩 번호. GCC는 EV4, EV5 및 EV6 프로세서 제품군에 대한 예약 매개 변수를 지원하고 지정한 프로세서에서 명령어 세트의 기본값을 선택합니다. 프로세서 유형을 지정하지 않으면 GCC는 기본적으로 컴파일러가 구축 된 프로세서로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ad544dab08dbd46c0ae98eb0c3361e463712c3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; substitutes &lt;code&gt;X&lt;/code&gt; if the</source>
          <target state="translated">'는 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다</target>
        </trans-unit>
        <trans-unit id="9990d2165de1099320d97e468af32ce23f811dac" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; substitutes a single dash and &amp;lsquo;</source>
          <target state="translated">'는 단일 대시를 대체하고'</target>
        </trans-unit>
        <trans-unit id="321b67c29454d786acc2b137adecd33a765095df" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; substitutes nothing at all. These are the two most common ways to instruct a program that it should read from standard input or write to standard output. If you need something more elaborate you can use an &amp;lsquo;</source>
          <target state="translated">'는 아무것도 대체하지 않습니다. 표준 입력에서 읽거나 표준 출력에 쓰도록 프로그램에 지시하는 가장 일반적인 두 가지 방법입니다. 좀 더 정교한 것이 필요한 경우 '</target>
        </trans-unit>
        <trans-unit id="b4019cbfa1ecf968c67a059f9d69da825719629e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; substitutes.</source>
          <target state="translated">'대용품.</target>
        </trans-unit>
        <trans-unit id="2c28b4998a4a5763c08ba06a5a430c91622a6962" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; substitution. (See below.)</source>
          <target state="translated">대체. (아래 참조)</target>
        </trans-unit>
        <trans-unit id="4484966b786972befcd67913fd7e8210357446c9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; subtype, instead of one controlled by the</source>
          <target state="translated">'에 의해 제어되는 하위 유형 대신</target>
        </trans-unit>
        <trans-unit id="16138baa8e830027f4d37afba05054893e7eb9a4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; suffix on integer constants.) Note, these suffixes appear in macros defined in the system headers of most modern systems, e.g. the &amp;lsquo;</source>
          <target state="translated">'정수 상수의 접미사.) 참고,이 접미사는 대부분의 최신 시스템의 시스템 헤더에 정의 된 매크로 (예 :'</target>
        </trans-unit>
        <trans-unit id="b1ee32f9ff27eda9c15d4b6f0b5915be69d929b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; suffix still has the GNU meaning.</source>
          <target state="translated">'접미사는 여전히 GNU 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa90fa86d89bb8805ba9eee92f744e653e7869" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; suffix) when assembling them.</source>
          <target state="translated">'접미사) 조립할 때.</target>
        </trans-unit>
        <trans-unit id="97dcee030c8836a2865e8ecc2f203cfd153ad2e4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; suffix, so C++14 code that includes the &amp;lsquo;</source>
          <target state="translated">'접미사이므로'</target>
        </trans-unit>
        <trans-unit id="139aaebaa57ad8962a5b2ee4325f224e112ed95f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; suffix. You can specify &amp;lsquo;</source>
          <target state="translated">접미사. '를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6b06d5de8e85da80af8c020ff2227f4057f93e6c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; switches are supported in addition to the above on x86-64 processors in 64-bit environments.</source>
          <target state="translated">64 비트 환경의 x86-64 프로세서에서 위의 스위치 외에도 '스위치가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8401ca4577a9a8d882babc3aea71e1a25aaa9f59" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; takes highest priority over both &amp;lsquo;</source>
          <target state="translated">'둘 다보다 우선 순위가 높습니다'</target>
        </trans-unit>
        <trans-unit id="1f54e26bc87a0a2fab77340b077d9aa7e37e715b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; takes priority over &amp;lsquo;</source>
          <target state="translated">'가'보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="cd16d9a7076736808720d07350c776f80630d493" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; target, this option implies</source>
          <target state="translated">'대상,이 옵션은</target>
        </trans-unit>
        <trans-unit id="7e92a2604d0f7fdca7e7d5ac91e19423966fc2ec" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; target.</source>
          <target state="translated">' 표적.</target>
        </trans-unit>
        <trans-unit id="cd6f1baebf517b27b1ba1e0f0c7818c2f92d4d56" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; targets default to</source>
          <target state="translated">'는 기본적으로</target>
        </trans-unit>
        <trans-unit id="5b4ffd0a68cd7722edb8438d55a609340643f57f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; targets, the default is</source>
          <target state="translated">'대상, 기본값은</target>
        </trans-unit>
        <trans-unit id="056147ad41bb52b66af9ed7beb627c0f9b4a5179" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; targets.</source>
          <target state="translated">'목표.</target>
        </trans-unit>
        <trans-unit id="38cba9e03a9a92a6fd1bda85caf604b0dd55e559" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; the code generation is configured to produce</source>
          <target state="translated">'코드 생성은 생성하도록 구성되어 있습니다</target>
        </trans-unit>
        <trans-unit id="9c9ed84575adb586ca1346600f1a87f2b54c62a5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; the code generation is configured to produce shared library. In this case</source>
          <target state="translated">'코드 생성은 공유 라이브러리를 생성하도록 구성되어 있습니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="3ac92faa0283305d0be528c0c722ea1eddd63670" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; the code generation is configured to produce static binary. In this case</source>
          <target state="translated">'코드 생성은 정적 바이너리를 생성하도록 구성되어 있습니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="751dbcee70e5f93858d0abf30ebf091c78065bd6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; the compiler assumes that incremental linking is done. The sections containing intermediate code for link-time optimization are merged, pre-optimized, and output to the resulting object file. In addition, if</source>
          <target state="translated">컴파일러는 증분 연결이 완료된 것으로 가정합니다. 링크 타임 최적화를위한 중간 코드가 포함 된 섹션은 병합되고 사전 최적화되어 결과 개체 파일로 출력됩니다. 또한</target>
        </trans-unit>
        <trans-unit id="d35eaaffc6295c79621d7febc295f4cc0cbff4c6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; the member template definitions.</source>
          <target state="translated">'회원 템플릿 정의.</target>
        </trans-unit>
        <trans-unit id="ef6fed6549190b0d965e5cf7e0fced517211eb29" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; through &amp;lsquo;</source>
          <target state="translated">'통해'</target>
        </trans-unit>
        <trans-unit id="1c96ef5db986721c2692b006a74b2645ab6ec4d7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to &amp;lsquo;</source>
          <target state="translated">'에서'</target>
        </trans-unit>
        <trans-unit id="25e045794d45b41e40a15ba6b03ecbcf2cab0b14" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to all global symbols, so the assembly code can be used with the &lt;code&gt;PREFIX&lt;/code&gt; assembly directive.</source>
          <target state="translated">'를 모든 전역 기호에 적용하므로 어셈블리 코드를 &lt;code&gt;PREFIX&lt;/code&gt; 어셈블리 지시문 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f5fd08a143b7e4c653b1c16c9d4a22c5e44257f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to an expression, throwing an object, or referring to a type in a catch clause or exception specification.</source>
          <target state="translated">'를 표현식, 오브젝트를 던지거나 catch 절 또는 예외 스펙의 유형을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="8ba7bcaeb175b51595a5178d5d588175c55cc008" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to assign no, highest, or second-highest (respectively) priority to dispatch-slot restricted instructions.</source>
          <target state="translated">디스패치 슬롯 제한 명령에 '아니오', '높은'또는 '가장 높은'(각각) 우선 순위를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e7d610fcebfd8bd1b6f66db74974496ebfc8cee4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to be 32-bit), and that floating-point values up to 64 bits wide are passed in F registers. Contrast this with &amp;lsquo;</source>
          <target state="translated">'는 32 비트)이고 최대 64 비트의 부동 소수점 값은 F 레지스터로 전달됩니다. 이것을 '</target>
        </trans-unit>
        <trans-unit id="a9bf81d3dc1a8984b11d4917576184cf1038fef8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to be a weak alias for &amp;lsquo;</source>
          <target state="translated">'에 대한 약한 별칭이됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4b68da81b75fb6eeb1e3d153c58913b646be22" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to be overridden by one returning a different pointer type. This extension to the covariant return type rules is now deprecated and will be removed from a future version.</source>
          <target state="translated">다른 포인터 유형을 리턴하는 것으로 대체됩니다. 공변량 리턴 유형 규칙에 대한이 확장은 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="747bcf06703eb0d0d706c568a3d7c0b245716a7f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to be used as a keyword to define vector type variables and arguments. &amp;lsquo;</source>
          <target state="translated">'는 벡터 유형 변수 및 인수를 정의하기위한 키워드로 사용됩니다. '</target>
        </trans-unit>
        <trans-unit id="a9bcbfddd43a7864ab14d920c726549a936b1ba3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to create new partition for every symbol where possible. Specifying &amp;lsquo;</source>
          <target state="translated">가능하면 모든 기호에 대해 새 파티션을 작성하십시오. '지정</target>
        </trans-unit>
        <trans-unit id="cd03b9ee76c923a101cf9ae36c90388c61a93702" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to distinguish them from error messages.</source>
          <target state="translated">'를 사용하여 오류 메시지와 구별하십시오.</target>
        </trans-unit>
        <trans-unit id="1e10686e6c0bbadc7a760bb97c53700373049cef" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to dump to standard output, and &amp;lsquo;</source>
          <target state="translated">'를 표준 출력으로 덤프하고'</target>
        </trans-unit>
        <trans-unit id="5221e3fc33dc129b4de8fa80d8b7b8406130587f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to filter out those warnings.</source>
          <target state="translated">경고를 걸러냅니다.</target>
        </trans-unit>
        <trans-unit id="e207edb06c44e1ffee14b09d2bd576241fa09fbb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to include the header file; &amp;lsquo;</source>
          <target state="translated">헤더 파일을 포함하려면 '; '</target>
        </trans-unit>
        <trans-unit id="94c280763e15f6827a82d3da1b06a402bc2dda96" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to invert the option:</source>
          <target state="translated">옵션을 반전 시키려면 :</target>
        </trans-unit>
        <trans-unit id="28dcd81706e9335d54173713faabbb0a53ff42ed" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to link his or her application. Applications are not required to use the</source>
          <target state="translated">'를 사용하여 애플리케이션을 연결합니다. 응용 프로그램을 사용할 필요는 없습니다</target>
        </trans-unit>
        <trans-unit id="29b9f008a5a0614cea796c50934c1070f0f7fcb0" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to mean &amp;ldquo;any integer outside the range -128 to 127&amp;rdquo;, and then specifying &amp;lsquo;</source>
          <target state="translated">'-128-127 범위를 벗어난 정수'를 의미 한 다음 '</target>
        </trans-unit>
        <trans-unit id="7319c1f5fe9cd726827d4fd8725f43a46c30b5e3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to specify a nested subobject to initialize; the list is taken relative to the subobject corresponding to the closest surrounding brace pair. For example, with the &amp;lsquo;</source>
          <target state="translated">'중첩 된 하위 오브젝트를 초기화하도록 지정합니다. 리스트는 가장 가까운 주변 괄호 쌍에 해당하는 서브 오브젝트를 기준으로합니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="cb981e4b7c234addc580de918e72cb9b746b3955" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to specify a partitioning mirroring the original source files or &amp;lsquo;</source>
          <target state="translated">'원본 소스 파일을 미러링하는 파티션을 지정하려면'</target>
        </trans-unit>
        <trans-unit id="9c0690b069e16610f3dde8f4da1fa3b45e233474" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to specify partitioning into equally sized chunks (whenever possible) or &amp;lsquo;</source>
          <target state="translated">'가능한 경우 동일한 크기의 청크로 분할을 지정하려면'</target>
        </trans-unit>
        <trans-unit id="b96b741c5b8c6ab7fbc59d6b6f9ecbfec23495f3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the architecture name. Extension options are processed in order and capabilities accumulate. An extension will also enable any necessary base extensions upon which it depends. For example, the &amp;lsquo;</source>
          <target state="translated">'를 아키텍처 이름으로 확장 옵션은 순서대로 처리되고 기능이 누적됩니다. 확장은 또한 필요한 기본 확장을 가능하게합니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="1e325ed7f61f460b2ad46963e7303d06823e0742" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the command recipe in the parent Makefile for this to work. This option likely only works if &lt;code&gt;MAKE&lt;/code&gt; is GNU make.</source>
          <target state="translated">이 작업을 수행하려면 상위 Makefile의 명령 레시피에 추가하십시오. 이 옵션 은 &lt;code&gt;MAKE&lt;/code&gt; 가 GNU make 인 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="876029c6ecf433b4603b8318f33435182f18ba71" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the integer.</source>
          <target state="translated">'를 정수로</target>
        </trans-unit>
        <trans-unit id="94b553527276f98960779fb5b0a35d9e9c86b311" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the integer. To make an integer constant of type &lt;code&gt;unsigned long
long int&lt;/code&gt;, add the suffix &amp;lsquo;</source>
          <target state="translated">'를 정수로 &lt;code&gt;unsigned long long int&lt;/code&gt; 유형의 정수 상수를 만들려면 접미사 '</target>
        </trans-unit>
        <trans-unit id="2e70c71b754410dd31984a69e3cab392094feb24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the prefix.</source>
          <target state="translated">접두사로.</target>
        </trans-unit>
        <trans-unit id="c69d15f8e44a888d4bd1368919fd60293ccc2c89" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to the source file name, and the file is created in the same directory as the output file. If the &amp;lsquo;</source>
          <target state="translated">'를 소스 파일 이름으로 바꾸면 파일이 출력 파일과 동일한 디렉토리에 작성됩니다. '</target>
        </trans-unit>
        <trans-unit id="8ed3c9950521cf53b071d8dd20633754dbb7cc1c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to treat it like a warning (even if</source>
          <target state="translated">'경고처럼 취급합니다 (</target>
        </trans-unit>
        <trans-unit id="1c80b7645a1d854bbd17006c82f06144b4c40be4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to treat this diagnostic as an error, &amp;lsquo;</source>
          <target state="translated">'이 진단을 오류로 취급하려면'</target>
        </trans-unit>
        <trans-unit id="5bef1515c6834bc8f9c7e30752b5e04672e84850" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; to turn off warnings; for example,</source>
          <target state="translated">'경고를 끄려면; 예를 들어</target>
        </trans-unit>
        <trans-unit id="39a6c2233326ca538b521ebba35c17f6f6321fff" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; toolchain, this option causes the hardware BSP provided by libgloss to be linked in if</source>
          <target state="translated">'툴체인,이 옵션은 libgloss가 제공하는 하드웨어 BSP가</target>
        </trans-unit>
        <trans-unit id="2da113e399a1a9773ce6971dff90293032832143" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; toolchain. Certain other options, such as</source>
          <target state="translated">'툴체인. 다음과 같은 특정 옵션</target>
        </trans-unit>
        <trans-unit id="78d9fddfa8f96adddd4fef84d8627d7567c4c3c1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; tracks tokens locations completely. This value is the most memory hungry. When this option is given no argument, the default parameter value is &amp;lsquo;</source>
          <target state="translated">'는 토큰 위치를 완전히 추적합니다. 이 값은 가장 많은 배고픈 메모리입니다. 이 옵션에 인수가 없으면 기본 매개 변수 값은 '</target>
        </trans-unit>
        <trans-unit id="76c937e0b6cc89a062161ae10ec3d7d4988e175f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; tracks tokens locations in a degraded mode for the sake of minimal memory overhead. In this mode all tokens resulting from the expansion of an argument of a function-like macro have the same location. Value &amp;lsquo;</source>
          <target state="translated">'은 메모리 오버 헤드를 최소화하기 위해 성능 저하 모드에서 토큰 위치를 추적합니다. 이 모드에서는 함수형 매크로의 인수 확장으로 인해 발생하는 모든 토큰의 위치가 동일합니다. 가치 '</target>
        </trans-unit>
        <trans-unit id="03e39be116fd453fb19403f3e451fbe0a4fb7794" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; tunes performance to the host system. This option has no effect if the compiler is unable to recognize the processor of the host system.</source>
          <target state="translated">호스트 시스템에 성능을 조정합니다. 컴파일러가 호스트 시스템의 프로세서를 인식 할 수없는 경우에는이 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54a47e25cf94d29dd512a01ee7945fbe67643846" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; turns on all types of branch protection features. If a feature has additional tuning options, then &amp;lsquo;</source>
          <target state="translated">'는 모든 유형의 분기 보호 기능을 켭니다. 기능에 추가 조정 옵션이 있으면 '</target>
        </trans-unit>
        <trans-unit id="13ac0da77896e4b23930650fa879227a5fd24579" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; turns on branch target identification mechanism.</source>
          <target state="translated">'는 분기 대상 식별 메커니즘을 켭니다.</target>
        </trans-unit>
        <trans-unit id="0d18f91c55c591d82a20ec7351429f79b0975340" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; turns on return address signing to its standard level: signing functions that save the return address to memory (non-leaf functions will practically always do this) using the a-key. The optional argument &amp;lsquo;</source>
          <target state="translated">'는 리턴 주소 서명을 표준 레벨로 설정합니다. a 키를 사용하여 리턴 주소를 메모리에 저장하는 서명 기능 (리프 기능이 아닌 기능은 실제로 항상 수행함). 선택적 인수 '</target>
        </trans-unit>
        <trans-unit id="0b6b662caf8ef50e43f9e777831f3d1e52831fb5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; uses alignment value as specified by the psABI, and &amp;lsquo;</source>
          <target state="translated">'는 psABI에서 지정한 정렬 값을 사용하고'</target>
        </trans-unit>
        <trans-unit id="7f8fb1eb4d4587ebe559311c119a4e77b06ec6d9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; uses increased alignment value compatible uses GCC 4.8 and earlier, &amp;lsquo;</source>
          <target state="translated">'GCC 4.8 및 이전 버전과 호환되는 증가 된 정렬 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9f23d00d56c1931b522364fd1aa0e1c9e7ed44aa" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; uses increased alignment value to match the cache line size. &amp;lsquo;</source>
          <target state="translated">'은 증가 된 정렬 값을 사용하여 캐시 라인 크기와 일치시킵니다. '</target>
        </trans-unit>
        <trans-unit id="e15400798f607d653c6916b38ea136006f4471a6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; value in user code must be done with caution, since the compiler might use &amp;lsquo;</source>
          <target state="translated">'컴파일러는 다음을 사용할 수 있으므로 사용자 코드의 값은주의해서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f6f876c00cb87147116ea210761a7c389fcc9ef" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; values are used to exactly determine which path is taken more often.</source>
          <target state="translated">'값은 어떤 경로를 더 자주 사용하는지 정확하게 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ca6633de11e82e2247b004389f4aa468fffbdd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; vs &amp;lsquo;</source>
          <target state="translated">'대'</target>
        </trans-unit>
        <trans-unit id="0779050ce9987f679c1038a47da66263698a9c04" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; was simply substituted with a file name chosen for the previous &amp;lsquo;</source>
          <target state="translated">'는 단순히 이전의'파일 이름으로 선택된 파일 이름으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="502558e63736c003256f143d104a28598f133cdb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; was simply substituted with a file name chosen once per compilation, without regard to any appended suffix (which was therefore treated just like ordinary text), making such attacks more likely to succeed.</source>
          <target state="translated">'는 추가 된 접미사 (일반 텍스트처럼 처리됨)와 상관없이 컴파일 당 한 번 선택한 파일 이름으로 간단히 대체되어 이러한 공격이 성공할 가능성이 높아졌습니다.</target>
        </trans-unit>
        <trans-unit id="f519e5816b445a4462f7c6c074b8d53555f7ae7c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; when</source>
          <target state="translated">' 언제</target>
        </trans-unit>
        <trans-unit id="4581798a42fc267b5b88d8c529c59a7d48e1ec83" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; when inverted (ones complement)</source>
          <target state="translated">'거꾸로 될 때 (하나 보완)</target>
        </trans-unit>
        <trans-unit id="b1b16141646060bcac76d2f93a69ece24464912b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; when negated (twos complement)</source>
          <target state="translated">'부정 될 때 (2 보완)</target>
        </trans-unit>
        <trans-unit id="16f8cbcf9ad14072c85731a453e55d733f44faf0" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; when not used together with &amp;lsquo;</source>
          <target state="translated">'와 함께 사용하지 않으면'</target>
        </trans-unit>
        <trans-unit id="05f1b1569a8bb4f983fcf2762d48347bd3c8a75b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; where &lt;var&gt;cond&lt;/var&gt; is one of the standard conditions defined in the ISA manual for &lt;code&gt;j&lt;var&gt;cc&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;set&lt;var&gt;cc&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;var&gt;cond&lt;/var&gt; 는 &lt;code&gt;j&lt;var&gt;cc&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;set&lt;var&gt;cc&lt;/var&gt;&lt;/code&gt; 에 대한 ISA 설명서에 정의 된 표준 조건 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="224bfa989cb06395bf3f62406fb52c196c7e4a54" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; where &lt;var&gt;n&lt;/var&gt; is the size of the data type.</source>
          <target state="translated">'여기서 &lt;var&gt;n&lt;/var&gt; 은 데이터 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="7d34efd1eefc71bdc46e1c691387ffc6d0f440a5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; which appear to be two hexadecimal constants separated by the minus operator. Actually, this string is a single &lt;em&gt;preprocessing token&lt;/em&gt;. Each such token must correspond to one token in C. Since this does not, GCC prints an error message. Although it may appear obvious that what is meant is an operator and two values, the ISO C standard specifically requires that this be treated as erroneous.</source>
          <target state="translated">빼기 연산자로 구분 된 두 개의 16 진 상수 인 것처럼 보입니다. 실제로이 문자열은 단일 &lt;em&gt;전처리 토큰&lt;/em&gt; 입니다. 이러한 각 토큰은 C에서 하나의 토큰에 해당해야합니다. 그렇지 않은 경우 GCC는 오류 메시지를 인쇄합니다. 의미가 연산자와 두 개의 값이라는 것이 명백해 보일 수 있지만, ISO C 표준은 특히 이것이 잘못된 것으로 취급되도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="ce548baa3dcfd80050cebbf016ad0a342bb4bbe1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; while &amp;lsquo;</source>
          <target state="translated">' 동안 '</target>
        </trans-unit>
        <trans-unit id="1b2d77e78180f9351e6cde7ef400900cba22c2ba" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; while others do not. See, for example, the &amp;lsquo;</source>
          <target state="translated">다른 사람들은 그렇지 않습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="d6e59717a41934fe3634c5f40aca5aa391956453" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; will do.</source>
          <target state="translated">'할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a93d327d16920f7102563d1856dfddf404a0da93" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; will override the available floating-point and SIMD extension instructions.</source>
          <target state="translated">'는 사용 가능한 부동 소수점 및 SIMD 확장 명령어보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3f4ab9547533f8fc34d036f65d0098a66594fbf6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; with a new one. The new definition adds in some extra command-line options before including the text of the old definition.</source>
          <target state="translated">새로운 것과 함께. 새로운 정의는 이전 정의의 텍스트를 포함하기 전에 몇 가지 명령 줄 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c9f1bf742bc9d084b36bd3cb92ef2565aa5bbfbe" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; with no argument, it applies to an include file with the same basename&lt;a href=&quot;#FOOT4&quot; id=&quot;DOCF4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; as your source file. For example, in</source>
          <target state="translated">'는 인수없이 소스 파일과 동일한 기본 이름 &lt;a href=&quot;#FOOT4&quot; id=&quot;DOCF4&quot; name=&quot;DOCF4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 를 포함 파일에 적용됩니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="e7a3015dda596b394c38dca135d21f85aa3ebffe" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; without &amp;lsquo;</source>
          <target state="translated">'없이'</target>
        </trans-unit>
        <trans-unit id="0dc205d9bf0c9ff774def5e928c5c2881b5a3c50" translate="yes" xml:space="preserve">
          <source>&amp;rsquo; would be transformed either to &amp;lsquo;</source>
          <target state="translated">'는'</target>
        </trans-unit>
        <trans-unit id="bc804106108f7bd979f6feca0e37d799668925a5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;&amp;mdash;for example,</source>
          <target state="translated">'&amp;mdash; 예를 들어</target>
        </trans-unit>
        <trans-unit id="00de7c01d30f729b5e62e59bad477a85d24c72f1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;&amp;mdash;not for other compilers such as plain &lt;code&gt;gcc&lt;/code&gt;. Whatever the ISO C standard says is relevant to the design of plain &lt;code&gt;gcc&lt;/code&gt; without</source>
          <target state="translated">'&amp;mdash; 일반 &lt;code&gt;gcc&lt;/code&gt; 와 같은 다른 컴파일러에는 해당되지 않습니다 . 무엇이든 ISO C 표준 말한다 것은 일반의 디자인과 관련이 &lt;code&gt;gcc&lt;/code&gt; 없이</target>
        </trans-unit>
        <trans-unit id="dcb0f5083283b8ed0056439fc5a6b003ecdf5b70" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;&amp;rsquo; is preferable for &lt;code&gt;asm&lt;/code&gt; statements)</source>
          <target state="translated">'' &lt;code&gt;asm&lt;/code&gt; 문에 바람직 합니다)</target>
        </trans-unit>
        <trans-unit id="3d710ff823f1d10d2285e509ae3146f07fa57416" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;)</source>
          <target state="translated">&amp;rsquo;)</target>
        </trans-unit>
        <trans-unit id="53a06a250ae2821edd769135818cefa09c3a1422" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) can be controlled, and not all of them. Use</source>
          <target state="translated">')를 제어 할 수 있으며 모두는 아닙니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="66a59b09899d33d90f56a9d67697d71807563efb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) followed by its (zero-based) position in &lt;var&gt;GotoLabels&lt;/var&gt; plus the number of input operands. For example, if the &lt;code&gt;asm&lt;/code&gt; has three inputs and references two labels, refer to the first label as &amp;lsquo;</source>
          <target state="translated">') 다음에 &lt;var&gt;GotoLabels&lt;/var&gt; 에서 (0부터 시작) 위치 와 입력 피연산자 수가 이어집니다. 예를 들어, &lt;code&gt;asm&lt;/code&gt; 에 세 개의 입력이 있고 두 개의 레이블을 참조하는 경우 첫 번째 레이블을 '</target>
        </trans-unit>
        <trans-unit id="e475de6573c410ed9174c3f23c2d0b2c68dd6feb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) from the option name. Unless documented otherwise, an argument can be either numeric or a string. Numeric arguments must typically be small unsigned decimal or hexadecimal integers. Hexadecimal arguments must begin with the &amp;lsquo;</source>
          <target state="translated">옵션 이름에서 '). 달리 문서화되지 않은 한 인수는 숫자 또는 문자열 일 수 있습니다. 숫자 인수는 일반적으로 부호없는 작은 10 진수 또는 16 진수 정수 여야합니다. 16 진 인수는 '</target>
        </trans-unit>
        <trans-unit id="757956e655505260d48be09c6401ced2f6616e52" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) instead of digits.</source>
          <target state="translated">숫자 대신 ').</target>
        </trans-unit>
        <trans-unit id="7b40161a5ee52fced90ad21e794bbab6943bfce4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) instruct &lt;code&gt;gcc&lt;/code&gt; to do nothing at all.</source>
          <target state="translated">') &lt;code&gt;gcc&lt;/code&gt; 에게 아무 것도하지 말라고 지시 한다.</target>
        </trans-unit>
        <trans-unit id="f48998525d685598cafa634dea469c07a14f8c01" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) is determined by the flags that specify the ISA that GCC is targeting, like</source>
          <target state="translated">')는 GCC가 타겟팅하는 ISA를 지정하는 플래그에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e3b8003d677b625cc848dc562e266c1883c1bf49" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) is used. Usually they indicate a typo in the user&amp;rsquo;s code, as they have implementation-defined values, and should not be used in portable code.</source>
          <target state="translated">') 사용. 일반적으로 구현 정의 값이 있으므로 휴대용 코드에서는 사용하면 안되므로 사용자 코드에 오타가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bce679860a255116638f86cdf1bdd003a1e6221f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) or generic structs (&amp;lsquo;</source>
          <target state="translated">') 또는 일반 구조체 ('</target>
        </trans-unit>
        <trans-unit id="774731d593e5209e46f6cf8756de5fe9e5ea50e2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) or used indirectly (&amp;lsquo;</source>
          <target state="translated">') 또는 간접적으로 사용 ('</target>
        </trans-unit>
        <trans-unit id="a55dc4d3813615932e15b8e05793ff32f4eb5bb3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) take effect in combination with other atomic operations on specific memory locations (e.g., atomic loads); operations on specific memory locations do not necessarily affect other operations in the same way.</source>
          <target state="translated">') 특정 메모리 위치 (예 : 원자 부하)에 대한 다른 원자 연산과 함께 적용됩니다. 특정 메모리 위치에서의 조작이 다른 조작에 반드시 같은 방식으로 영향을 미치는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="101017a161e8a4a5da8f0b61d9487a84646ffa42" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) to delimit the operand parameters after the assembler template:</source>
          <target state="translated">')를 사용하여 어셈블러 템플릿 다음에 피연산자 매개 변수를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="c24500a4d6202ccddafac06900a7b0060daebcfb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;) within a single string. Spaces are not permitted within the strings.</source>
          <target state="translated">단일 문자열 내에서 '). 문자열 내에 공백이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7de57a249813f45c8bb234a3b77cdb949b14668" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;)&amp;mdash;and don&amp;rsquo;t do anything else.</source>
          <target state="translated">') &amp;mdash; 다른 일을하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="920418559681c5ff8ecbd8a0896c35c865a62667" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), &amp;lsquo;</source>
          <target state="translated">'),'</target>
        </trans-unit>
        <trans-unit id="9d955da2a687bb782e3a613396d318419036d3fc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), an assembler template such as this:</source>
          <target state="translated">'), 다음과 같은 어셈블러 템플릿 :</target>
        </trans-unit>
        <trans-unit id="ed22c9b62e2fac731d3fa0a84f6b34a16db9b4bf" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), and &amp;lsquo;</source>
          <target state="translated">') 및'</target>
        </trans-unit>
        <trans-unit id="70b742c0a760f2ed8a2f4e6eff2d6ab3826154ad" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), no object is needed to obtain the address of the function. They can be converted to function pointers directly:</source>
          <target state="translated">'), 함수의 주소를 얻는 데 객체가 필요하지 않습니다. 함수 포인터로 직접 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa12a264be1002a46fabd882b95b79338c094c3e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), placing the value in a register (&amp;lsquo;</source>
          <target state="translated">'), 값을 레지스터 ('</target>
        </trans-unit>
        <trans-unit id="d4de0145c847e059e54316341fcc9c9a246eb97b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;), the compiler chooses the most efficient one based on the current context. If you must use a specific register, but your Machine Constraints do not provide sufficient control to select the specific register you want, local register variables may provide a solution (see &lt;a href=&quot;local-register-variables#Local-Register-Variables&quot;&gt;Local Register Variables&lt;/a&gt;).</source>
          <target state="translated">')에서 컴파일러는 현재 컨텍스트를 기반으로 가장 효율적인 것을 선택합니다. 특정 레지스터를 사용해야하지만 머신 제약 조건이 원하는 특정 레지스터를 선택하기에 충분한 제어를 제공하지 않으면 로컬 레지스터 변수가 솔루션을 제공 할 수 있습니다 ( &lt;a href=&quot;local-register-variables#Local-Register-Variables&quot;&gt;로컬 레지스터 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b1384fe0c31b5149aeb485dfa12fc6e40b1ee80a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;).</source>
          <target state="translated">&amp;rsquo;).</target>
        </trans-unit>
        <trans-unit id="247554dea8017ceed4ebc2f0ddf4c1c56122fdae" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). A struct type is used directly when it is the type of a variable, member. Indirect uses arise through pointers to structs. That is, when use of an incomplete struct is valid, the use is indirect. An example is &amp;lsquo;</source>
          <target state="translated">'). 구조체 형식은 변수 멤버 형식 인 경우 직접 사용됩니다. 구조체에 대한 포인터를 통해 간접적으로 사용됩니다. 즉, 불완전한 구조체의 사용이 유효하면 사용은 간접적입니다. 예를 들면 '</target>
        </trans-unit>
        <trans-unit id="241137680944e9803782618a7c6234ee4be1718b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). Generic structs are a bit complicated to explain. For C++, these are non-explicit specializations of template classes, or non-template classes within the above. Other programming languages have generics, but</source>
          <target state="translated">'). 일반적인 구조체는 설명하기가 약간 복잡합니다. C ++의 경우 템플릿 클래스의 명시 적 특수화 또는 위의 템플릿이 아닌 클래스입니다. 다른 프로그래밍 언어에는 제네릭이 있지만</target>
        </trans-unit>
        <trans-unit id="9c4f339ea1f6efdfdb3f1de7007ecc1e689a70f6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). ISA strings must be lower-case. Examples include &amp;lsquo;</source>
          <target state="translated">'). ISA 문자열은 소문자 여야합니다. 예는 '</target>
        </trans-unit>
        <trans-unit id="c515e25ab72e950aedab4e643cd942c7acaaf78a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). ISA strings must be lower-case. Valid ISA strings include &amp;lsquo;</source>
          <target state="translated">'). ISA 문자열은 소문자 여야합니다. 유효한 ISA 문자열에는 '</target>
        </trans-unit>
        <trans-unit id="28dcb04b7cec7c1948f9a3d1e0eeb18abfddd844" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). If</source>
          <target state="translated">'). 만약</target>
        </trans-unit>
        <trans-unit id="1db301197128435967c7812046b072aff4533c56" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). Instead, the object files contain references to be resolved at link time.</source>
          <target state="translated">'). 대신, 오브젝트 파일에는 링크시 분석 할 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e7133c2944aa60bfeb0d20f3c591dd62c46fdc22" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). Some assemblers allow semicolons as a line separator. However, note that some assembler dialects use semicolons to start a comment.</source>
          <target state="translated">'). 일부 어셈블러에서는 세미콜론을 줄 구분 기호로 사용할 수 있습니다. 그러나 일부 어셈블러 언어에서는 세미콜론을 사용하여 주석을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="77387bea931c55865e91e9c6e518282a6ee31286" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). The scope of the name is the &lt;code&gt;asm&lt;/code&gt; statement that contains the definition. Any valid C variable name is acceptable, including names already defined in the surrounding code. No two operands within the same &lt;code&gt;asm&lt;/code&gt; statement can use the same symbolic name.</source>
          <target state="translated">'). 이름의 범위 는 정의가 포함 된 &lt;code&gt;asm&lt;/code&gt; 문입니다. 주변 코드에 이미 정의 된 이름을 포함하여 유효한 C 변수 이름을 사용할 수 있습니다. 동일한 &lt;code&gt;asm&lt;/code&gt; 문 내에서 두 피연산자 가 동일한 기호 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="feab9b68ab784ee007bfd9ffdaf2fcdc72d72d96" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). Typically these qualifiers are hardware dependent. The list of supported modifiers for x86 is found at &lt;a href=&quot;#x86Operandmodifiers&quot;&gt;x86 Operand modifiers&lt;/a&gt;.</source>
          <target state="translated">'). 일반적으로 이러한 한정자는 하드웨어에 따라 다릅니다. x86에 지원되는 수정 자 목록은 &lt;a href=&quot;#x86Operandmodifiers&quot;&gt;x86 피연산자 수정 자에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d92a4f78d17aa1decb8d93c9e38d473afcd7d8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;). Using the generic &amp;lsquo;</source>
          <target state="translated">'). 일반 '</target>
        </trans-unit>
        <trans-unit id="8e06582ed3f8a32ea5ee39b25a0290e388c00c24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, &amp;hellip; &amp;lsquo;</source>
          <target state="translated">',&amp;hellip;'</target>
        </trans-unit>
        <trans-unit id="5539094fa0b03be2ecf5d76b2f76c3ceb8adb603" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, &amp;lsquo;</source>
          <target state="translated">','</target>
        </trans-unit>
        <trans-unit id="3b63c535f0550f2343414feda1dd2f0ebecc5480" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, 0&amp;lsquo;</source>
          <target state="translated">', 0'</target>
        </trans-unit>
        <trans-unit id="8fb52f327e38a530b04e2b3ae2d13a53b83a7fe3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, a reference to a previously defined structure or union such as &amp;lsquo;</source>
          <target state="translated">', 이전에 정의 된 구조 또는'</target>
        </trans-unit>
        <trans-unit id="55abc55e6306905b6823631c506fd0ec75ff0f27" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, all workarounds for the targeted processor are enabled. The &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; macro is defined to two hexadecimal digits representing the major and minor numbers in the silicon revision. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">', 대상 프로세서에 대한 모든 해결 방법이 활성화되었습니다. &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; 의 매크로는 실리콘 개정의 메이저와 마이너 번호를 나타내는 두 개의 16 진수로 정의된다. 만약 &lt;var&gt;sirevision&lt;/var&gt; 가 '있다</target>
        </trans-unit>
        <trans-unit id="b4c2b924dddb74784fdc00cbc01bb9d353155e30" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, and &amp;lsquo;</source>
          <target state="translated">'및'</target>
        </trans-unit>
        <trans-unit id="483d46fded9becc232dbdb93e3158f3f42b791e2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, and &lt;code&gt;*&lt;/code&gt; sequences as well, although they have a stronger binding than the &amp;lsquo;</source>
          <target state="translated">', 및 &lt;code&gt;*&lt;/code&gt; 시퀀스는'</target>
        </trans-unit>
        <trans-unit id="025eab9a1b6623d94918f0efdf239940346391b4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, and GNU dialects of those standards, such as &amp;lsquo;</source>
          <target state="translated">'와 같은 표준의 GNU 방언</target>
        </trans-unit>
        <trans-unit id="9269f03454f6ba284543f68ccb8599de5d8e5ca8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, and appends the platform&amp;rsquo;s usual object suffix. The result is the target.</source>
          <target state="translated">', 플랫폼의 일반적인 객체 접미사를 추가합니다. 결과는 목표입니다.</target>
        </trans-unit>
        <trans-unit id="2073c52a5a4291471a2c1778b6a5d6aa27011cd9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, and each switch starts with an &amp;lsquo;</source>
          <target state="translated">', 각 스위치는'</target>
        </trans-unit>
        <trans-unit id="f905781c589b0e4579c81050815f957daef62254" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, as shown here:</source>
          <target state="translated">', 여기에 표시된대로 :</target>
        </trans-unit>
        <trans-unit id="e9ce993e58d935c75aafba5b1fdb485a8a776db3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, because of the need for those to form complete file names. The handling is such that &amp;lsquo;</source>
          <target state="translated">완전한 파일 이름을 구성 할 필요가 있기 때문입니다. 취급은 '</target>
        </trans-unit>
        <trans-unit id="21e67ee4ffd5a5984f784e0175ae5cd377da2fd5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but a function call is only used if a trap is not available.</source>
          <target state="translated">함수 호출은 트랩을 사용할 수없는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87f33fe8f4938fd885f3212c8d4fcaa4cd1d82de" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but also generate GP-relative accesses for small data objects that are external, weak, or common. If you use this option, you must ensure that all parts of your program (including libraries) are compiled with the same</source>
          <target state="translated">'이지만 외부, 약하거나 일반적인 작은 데이터 개체에 대한 GP 상대 액세스를 생성합니다. 이 옵션을 사용하는 경우 프로그램의 모든 부분 (라이브러리 포함)이 동일하게 컴파일되어야합니다</target>
        </trans-unit>
        <trans-unit id="2411a70f498933e6be4a4e9d0ef8e6b417a49aa8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but do not generate an error message if the include file cannot be found.</source>
          <target state="translated">포함 파일을 찾을 수없는 경우 오류 메시지를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f242eacde5ab79e86477338531360b8ba9ecec37" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but generates a new temporary file name each time it appears instead of once per compilation.</source>
          <target state="translated">'이지만 컴파일 할 때마다 한 번 표시 될 때마다 새 임시 파일 이름이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae3620a4615e0395e0b6bb2723f394be5b4513b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but include the file suffix (text after the last period).</source>
          <target state="translated">파일 접미사 (마지막 기간 이후의 텍스트)를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="092a366239711ab0e1774f55ad486f40925b2c39" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but inexact traps are enabled as well.</source>
          <target state="translated">정확하지 않은 트랩도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="dba30ddb7f54c0471e6b8c42e687a833e9c23aee" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but puts &amp;lsquo;</source>
          <target state="translated">'하지만</target>
        </trans-unit>
        <trans-unit id="39218b3d97dc3ec712bf382cd7959367acbcf492" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, but the instructions are marked to be safe for software completion (see Alpha architecture manual for details).</source>
          <target state="translated">'이지만 소프트웨어 지침에는 안전하다고 표시되어 있습니다 (자세한 내용은 Alpha 아키텍처 매뉴얼 참조).</target>
        </trans-unit>
        <trans-unit id="a95b52d04a925b481ffc7ad53fe6eb07f0a4eebe" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, depending on whether a basic block is reachable via non-exceptional or exceptional paths. Executed basic blocks having a statement with zero &lt;var&gt;execution_count&lt;/var&gt; end with &amp;lsquo;</source>
          <target state="translated">'는 예외가 아닌 경로 또는 예외적 인 경로를 통해 기본 블록에 도달 할 수 있는지 여부에 따라 다릅니다. &lt;var&gt;execution_count&lt;/var&gt; 가 0 인 명령문이있는 기본 블록을 실행 하여 '</target>
        </trans-unit>
        <trans-unit id="66d00e224ec92d1c22749474d1e91e24964ab5c2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, depending on whether they are reachable by non-exceptional paths or only exceptional paths such as C++ exception handlers, respectively. Given the &amp;lsquo;</source>
          <target state="translated">'가 예외가 아닌 경로로 도달 할 수 있는지 또는 C ++ 예외 처리기와 같은 예외 경로에서만 도달 할 수 있는지에 따라 주어진 '</target>
        </trans-unit>
        <trans-unit id="136c3d628fc50dc61e6297006309885a5d8aee50" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, do not assume the location contains the existing value on entry to the &lt;code&gt;asm&lt;/code&gt;, except when the operand is tied to an input; see &lt;a href=&quot;#InputOperands&quot;&gt;Input Operands&lt;/a&gt;.</source>
          <target state="translated">', 피연산자가 입력에 연결되어있는 경우를 제외하고, 위치에 &lt;code&gt;asm&lt;/code&gt; 진입시 기존 값이 있다고 가정하지 마십시오 . &lt;a href=&quot;#InputOperands&quot;&gt;입력 피연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eebd87ad91943223aef3936c3e20f0c176f9150" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, e.g.</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="de40d739dfc6920248f5b9046b3c9b839f920f68" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, etc., with &amp;lsquo;</source>
          <target state="translated">'등으로'</target>
        </trans-unit>
        <trans-unit id="2aa5684705ecc6e2def69b7b8430a853ec505c39" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, even if they are executed earlier. The phase letter is one of &amp;lsquo;</source>
          <target state="translated">더 일찍 실행 되더라도 위상 글자는 '</target>
        </trans-unit>
        <trans-unit id="09e3614efaea8eab44d2d073c727d9df85c09585" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, except if</source>
          <target state="translated">'를 제외하고</target>
        </trans-unit>
        <trans-unit id="05234cf66772b81ecd442f963fde2d9cf3f3b580" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, except that it verifies that bits that are not in the lower 32-bit range are all zero. Must be used instead of &amp;lsquo;</source>
          <target state="translated">하위 32 비트 범위에없는 비트가 모두 0인지 확인하는 것을 제외하고는 '입니다. '대신에 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="066ab954d39195c280a98dc287f05dc34c467231" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, except they don&amp;rsquo;t share the same suffix &lt;em&gt;space&lt;/em&gt;, so &amp;lsquo;</source>
          <target state="translated">'같은 접미사 &lt;em&gt;공간을&lt;/em&gt; 공유하지 않는 것을 제외하고는 '</target>
        </trans-unit>
        <trans-unit id="98d65587f22436a3a12d35d6fe27c3546587cef2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, for example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="0d4f3e8108a13ab29d4b2e0e63a1ca33c2b22454" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, generating a new one if there is no such last file name. In the absence of any &amp;lsquo;</source>
          <target state="translated">', 마지막 파일 이름이 없으면 새 파일을 생성합니다. '가없는 경우</target>
        </trans-unit>
        <trans-unit id="9db8be9dbf00d53f36b02e299cb40c1ccf21b3d5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, i.e., make every symbol public.</source>
          <target state="translated">즉, 모든 심볼을 공개합니다.</target>
        </trans-unit>
        <trans-unit id="f9417c06d6d376990e78c94bffca4a185de5c4ea" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, in which case the &lt;code&gt;__fp16&lt;/code&gt; type is not defined. See &lt;a href=&quot;half_002dprecision#Half_002dPrecision&quot;&gt;Half-Precision&lt;/a&gt;, for more information.</source>
          <target state="translated">'인 경우 &lt;code&gt;__fp16&lt;/code&gt; 유형이 정의되지 않았습니다. 자세한 내용은 &lt;a href=&quot;half_002dprecision#Half_002dPrecision&quot;&gt;반 정밀도&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01f1d4ba970d96674fdfce27113ede13dd96c83c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, in which case the rules are written to file &lt;var&gt;file&lt;/var&gt; using &lt;var&gt;target&lt;/var&gt; as the target name.</source>
          <target state="translated">이 경우 규칙을 대상 이름으로 &lt;var&gt;target&lt;/var&gt; 을 사용하여 파일 &lt;var&gt;file&lt;/var&gt; 규칙이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="18c4ce616b187a8cd7e37370e7c2a4558687b5bd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, in which no floating-point arguments will be passed in registers.</source>
          <target state="translated">'에서 부동 소수점 인수가 레지스터에 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3e7b4dd0f31f9fc49145a20fdc34f56d6192b15" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, meaning no alignment. The maximum allowed &lt;var&gt;n&lt;/var&gt; option value is 65536.</source>
          <target state="translated">', 정렬이 없음을 의미합니다. 허용되는 최대 &lt;var&gt;n&lt;/var&gt; 옵션 값은 65536입니다.</target>
        </trans-unit>
        <trans-unit id="b1df550e442c6ce053b25ec1d413b95d867426aa" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, no workarounds are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">', 해결 방법이 활성화되어 있지 않습니다. 만약 &lt;var&gt;sirevision&lt;/var&gt; 가 '있다</target>
        </trans-unit>
        <trans-unit id="4638287656ac02959e2cefcae6acca031d4bd193" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, only the preprocessor macro is defined.</source>
          <target state="translated">', 전 처리기 매크로 만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f307dbc595c36b91f1275e80e0395cbaf3c6504c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or &amp;lsquo;</source>
          <target state="translated">'또는'</target>
        </trans-unit>
        <trans-unit id="9b3c982032ea0459140427383a85dba0acd2e1fd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or (for shared template code) &amp;lsquo;</source>
          <target state="translated">'또는 (공유 템플릿 코드의 경우)'</target>
        </trans-unit>
        <trans-unit id="5eab487e4b72d07293fe7c795f5de0ccb7970c25" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or a reference to a &lt;code&gt;typedef&lt;/code&gt; name for a previously defined structure or union type.</source>
          <target state="translated">'또는 이전에 정의 된 구조 또는 공용체 유형 의 &lt;code&gt;typedef&lt;/code&gt; 이름에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="3f4b0ae84ca34d4bad67d128809cab75207b33d0" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or even &amp;lsquo;</source>
          <target state="translated">', 또는 '</target>
        </trans-unit>
        <trans-unit id="1d1087187ab3a7e62992e275357cb57bcfa1c106" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or it might get &amp;lsquo;</source>
          <target state="translated">', 또는'</target>
        </trans-unit>
        <trans-unit id="3aca8c8acb74e379a3304f127abf609845bc280e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, or make the path absolute when generating a relative prefix.</source>
          <target state="translated">'또는 상대 접두사를 생성 할 때 경로를 절대 경로로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b6358603813ed89a66fd98d2859d299f75ccce85" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, otherwise, it is turned off.</source>
          <target state="translated">그렇지 않으면 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="0f1fda70fb0c46563a4357bb73dfbd4447b31663" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, respectively, in the following character). In the case of function definitions, a K&amp;amp;R-style list of arguments followed by their declarations is also provided, inside comments, after the declaration.</source>
          <target state="translated">다음 문자에서 '). 함수 정의의 경우, 선언 후 주석 안에 K &amp;amp; R 스타일 인수 목록과 선언이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c3101771b9632d8f958f8bd2e3b3975e5bd0ed02" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, so &amp;lsquo;</source>
          <target state="translated">', 그래서'</target>
        </trans-unit>
        <trans-unit id="c5b364cf3dc5ad7fb131b66cc0868f3b8543e70b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, that are defined by ISO C to stand for single characters. For example, &amp;lsquo;</source>
          <target state="translated">', 단일 문자를 나타 내기 위해 ISO C에 의해 정의됩니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="4931b59d68a18af6c7fbe7e255d105b5cb1219bb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the &amp;ldquo;software trace cache&amp;rdquo; algorithm, which tries to put all often executed code together, minimizing the number of branches executed by making extra copies of code.</source>
          <target state="translated">'소프트웨어 추적 캐시'알고리즘으로, 자주 실행되는 모든 코드를 모아서 추가 코드 복사본을 만들어 실행되는 분기 수를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="2073bc4d3052c9d45b6e4d60d51421cb09ad40d8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; is defined to be &lt;code&gt;0xffff&lt;/code&gt;. If this optional &lt;var&gt;sirevision&lt;/var&gt; is not used, GCC assumes the latest known silicon revision of the targeted Blackfin processor.</source>
          <target state="translated">', &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; 은 &lt;code&gt;0xffff&lt;/code&gt; 로 정의됩니다 . 이 선택적 &lt;var&gt;sirevision&lt;/var&gt; 을 사용하지 않으면 GCC는 대상 Blackfin 프로세서의 알려진 최신 실리콘 버전을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a7faca6a353f0ed8bbbd7fe58280558417f88bc1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; is not defined. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">', &lt;code&gt;__SILICON_REVISION__&lt;/code&gt; 이 (가) 정의되지 않았습니다. 만약 &lt;var&gt;sirevision&lt;/var&gt; 가 '있다</target>
        </trans-unit>
        <trans-unit id="f5c8011c2f55c0ac81c5d9ceb64477468b6c9a9e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the compiler emits code for the function itself; this defines a version of the function that can be found via pointers (or by callers compiled without inlining). If all calls to the function can be inlined, you can avoid emitting the function by compiling with</source>
          <target state="translated">', 컴파일러는 함수 자체에 대한 코드를 생성합니다. 포인터를 통해 (또는 인라인없이 컴파일 된 호출자가) 찾을 수있는 함수 버전을 정의합니다. 함수에 대한 모든 호출을 인라인 할 수 있으면 다음과 같이 컴파일하여 함수가 방출되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fce4bbe106b081174a0f5bef32f95cbfa790ac6" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the effect on an inline function defined in that class is similar to an explicit &lt;code&gt;extern&lt;/code&gt; declaration&amp;mdash;the compiler emits no code at all to define an independent version of the function. Its definition is used only for inlining with its callers.</source>
          <target state="translated">', 해당 클래스에 정의 된 인라인 함수에 대한 효과는 명시 적 &lt;code&gt;extern&lt;/code&gt; 선언 과 유사 합니다. 컴파일러는 함수의 독립적 인 버전을 정의하기 위해 코드를 전혀 생성하지 않습니다. 정의는 호출자와 인라인하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf5bc1539de695c3b4d3767d9c103937369811c1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the last two letters must both be literally &amp;lsquo;</source>
          <target state="translated">', 마지막 두 글자는 문자 그대로'</target>
        </trans-unit>
        <trans-unit id="db79a20c00080e7d5e4b192fe6de466faac9115a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the macro names the resolved architecture (either &lt;code&gt;&quot;mips1&quot;&lt;/code&gt; or &lt;code&gt;&quot;mips3&quot;&lt;/code&gt;). It names the default architecture when no</source>
          <target state="translated">', 매크로는 확인 된 아키텍처의 이름을 지정합니다 ( &lt;code&gt;&quot;mips1&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;mips3&quot;&lt;/code&gt; ). 없을 때 기본 아키텍처 이름을 지정합니다</target>
        </trans-unit>
        <trans-unit id="8d83a5ecd0c633a33d12c8a0921f9d9646b8105f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the operand can have postincrement and postdecrement which require printing with &amp;lsquo;</source>
          <target state="translated">', 피연산자는 후행 증가 및 후퇴 감소를 가질 수 있으며'</target>
        </trans-unit>
        <trans-unit id="780d16f0177d79dcb186b26e4731ad4f3ff27e90" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, the operand can have postincrement which requires printing with &amp;lsquo;</source>
          <target state="translated">', 피연산자는 후행 증분을 가질 수 있으며'</target>
        </trans-unit>
        <trans-unit id="958abf9b2ba30ada1927e0d18d675fed8d221758" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, then updates the &amp;lsquo;</source>
          <target state="translated">', 그런 다음'</target>
        </trans-unit>
        <trans-unit id="6f80d08a483db41013d0e0117c5b88a8e8ad1bd3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, there is a corresponding &lt;em&gt;base standard&lt;/em&gt;, the version of ISO C on which the GNU extended dialect is based. Warnings from</source>
          <target state="translated">' 에는 GNU 확장 된 방언이 기반으로하는 ISO C 버전의 해당 &lt;em&gt;기본 표준&lt;/em&gt; 이 있습니다. 의 경고</target>
        </trans-unit>
        <trans-unit id="a8483af113196f523d78cdfed023c2f13973b39e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, this contributes no text to the argument.</source>
          <target state="translated">', 이것은 논증에 텍스트를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d636acf24a127bc2b95b62fa251ecc17f5cc915" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, this is just like &amp;lsquo;</source>
          <target state="translated">', 이것은'</target>
        </trans-unit>
        <trans-unit id="e894972486d8d6096ff2223f65e4a8883430900a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, this macro is not defined.</source>
          <target state="translated">',이 매크로는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6db9d39068e98a34cf2dbeda58f4d7c72ad17119" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, this works even when infinities, NaNs and negative zeros are involved.</source>
          <target state="translated">', 이것은 무한대, NaN 및 음의 0이 포함 된 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f9f6f2167738a6bc27a8918056c08bdf0ac8ac61" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, those functions may not be loaded.</source>
          <target state="translated">', 해당 기능이로드되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848c5ba958a75e22dba01b795952aac18411fbbf" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, thus the invocation of &lt;code&gt;cc1&lt;/code&gt; is &amp;lsquo;</source>
          <target state="translated">따라서 &lt;code&gt;cc1&lt;/code&gt; 의 호출 은 '</target>
        </trans-unit>
        <trans-unit id="6d98c164b412ee8aa5fd4b179a66947857f9efe0" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, underflow traps are enabled as well.</source>
          <target state="translated">언더 플로우 트랩도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="412c73084b584a3fd2f571e198882146b578aafa" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, usually the letter indicating the most common immediate-constant format.</source>
          <target state="translated">', 일반적으로 가장 일반적인 즉시 상수 형식을 나타내는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="5b2af747b468ebcf98a4ed4b7baee2a44d3c411c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, when supported by a target, or to &amp;lsquo;</source>
          <target state="translated">', 대상에서 지원하는 경우'</target>
        </trans-unit>
        <trans-unit id="4efda24d512ee43a5706f4bdf3be7939f7f6d247" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, when the structure field has the misaligned offset:</source>
          <target state="translated">', 구조 필드에 잘못 정렬 된 오프셋이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="93aa1e264ff57887de5dc1cb5417f8dd989d1e09" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, where &lt;var&gt;L&lt;/var&gt; is an uppercase letter. This is for ISO C.</source>
          <target state="translated">', 여기서 &lt;var&gt;L&lt;/var&gt; 은 대문자입니다. ISO C 용입니다.</target>
        </trans-unit>
        <trans-unit id="739a7d9d6e619ecc7399139269b374ab43d85367" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, where &lt;var&gt;X&lt;/var&gt; is a major version, &lt;var&gt;YY&lt;/var&gt; is the minor version, and &lt;var&gt;Z&lt;/var&gt; is compatibility code. Example values are &amp;lsquo;</source>
          <target state="translated">', 여기서 &lt;var&gt;X&lt;/var&gt; 는 주 버전이고 &lt;var&gt;YY&lt;/var&gt; 는 부 버전이고 &lt;var&gt;Z&lt;/var&gt; 는 호환성 코드입니다. 예제 값은 '</target>
        </trans-unit>
        <trans-unit id="d769a376fcd2331ff3efeece4ef65cc094eb46d9" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, where the name of the friend is an unqualified-id, could be interpreted as a particular specialization of a template function; the warning exists to diagnose compatibility problems, and is enabled by default.</source>
          <target state="translated">', 친구의 이름이 규정되지 않은 ID 인 경우 템플릿 기능의 특정 전문화로 해석 될 수 있습니다. 경고는 호환성 문제를 진단하기 위해 존재하며 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4545941e1a456d9e76018c4df8a40b960f1b83" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which can be confusing. Use the</source>
          <target state="translated">혼란 스러울 수 있습니다. 사용</target>
        </trans-unit>
        <trans-unit id="3a9a59268985f9334c00a17967c54ff7c32a0e16" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which disables return address signing, &amp;lsquo;</source>
          <target state="translated">', 반송 주소 서명을 비활성화합니다.'</target>
        </trans-unit>
        <trans-unit id="87f652520c80de99647e10eb1ff77ab629d99978" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which does not increase code size (except sometimes due to secondary effects like alignment), or &amp;lsquo;</source>
          <target state="translated">'는 코드 크기를 늘리지 않습니다 (일부 정렬과 같은 보조 효과로 인한 경우 제외)</target>
        </trans-unit>
        <trans-unit id="8659feb795576fd08fccb6d569ea2287637015e4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which enables pointer signing for all functions. The default value is &amp;lsquo;</source>
          <target state="translated">'를 사용하면 모든 기능에 대한 포인터 서명이 가능합니다. 기본값은 '</target>
        </trans-unit>
        <trans-unit id="4bcf01b8de353a2ead74230ef433e9b1d5c42c5f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which enables pointer signing for functions which are not leaf functions, and &amp;lsquo;</source>
          <target state="translated">리프 함수가 아닌 함수에 대한 포인터 서명을 활성화하는 '및</target>
        </trans-unit>
        <trans-unit id="919dfa4777ff858a1ffee761219e579bcc47fff2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which fetches the thread pointer from &lt;code&gt;cp15&lt;/code&gt; directly (supported in the arm6k architecture), and &amp;lsquo;</source>
          <target state="translated">', &lt;code&gt;cp15&lt;/code&gt; 에서 직접 스레드 포인터를 가져옵니다 (arm6k 아키텍처에서 지원됨).</target>
        </trans-unit>
        <trans-unit id="c0bc21f369e03da1ff0fbdfedd85fac2ceffcf5f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which generates calls to &lt;code&gt;__aeabi_read_tp&lt;/code&gt;, &amp;lsquo;</source>
          <target state="translated">', &lt;code&gt;__aeabi_read_tp&lt;/code&gt; 호출을 생성합니다 .'</target>
        </trans-unit>
        <trans-unit id="be7bc52286a0fa82e570dab15353ed73c224a194" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which is treated exactly as if &amp;lsquo;</source>
          <target state="translated">'처럼 정확하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="4b8132d93b5b364fb4107d3f7f7e80d8cb8cca0a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which keeps function return unmodified. &amp;lsquo;</source>
          <target state="translated">함수 반환을 수정하지 않고 유지합니다. '</target>
        </trans-unit>
        <trans-unit id="7c0ef144ca1606cff5c2fcba721912c1bf504b40" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which keeps indirect call and jump unmodified. &amp;lsquo;</source>
          <target state="translated">', 간접 통화를 유지하고 수정되지 않은 상태로 점프합니다. '</target>
        </trans-unit>
        <trans-unit id="beca4baa89360933636ffbc7ac4cf4af22fdf467" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which means that no register is used for this purpose. The default is</source>
          <target state="translated">'는이 목적으로 레지스터가 사용되지 않음을 의미합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="1101672b2c1cf966ba104538143c46f9af09e54f" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which means to dump messages about successful optimizations from all the passes, omitting messages that are treated as &amp;ldquo;internals&amp;rdquo;.</source>
          <target state="translated">'는 모든 단계에서 성공적인 최적화에 대한 메시지를 덤프하고 &quot;내부&quot;로 취급되는 메시지는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="3faa7f76311e939879aa32607e1cbda0c78aeffc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which produces vector-length agnostic code.</source>
          <target state="translated">'는 벡터 길이에 관계없이 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="eebb01c01a4dcc45ae8a85f860ce121ea49fd1a8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which selects the best architecture option for the host processor.</source>
          <target state="translated">호스트 프로세서에 가장 적합한 아키텍처 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="13bf69f8c2ad5370a2f855e913a0eaf2e0a40255" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which should be invoked with the command-line switch</source>
          <target state="translated">', 명령 행 스위치로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="06afe658b05579d643bf49716402cd959b627012" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which specifies Chaitin-Briggs coloring. Chaitin-Briggs coloring is not implemented for all architectures, but for those targets that do support it, it is the default because it generates better code.</source>
          <target state="translated">', Chaitin-Briggs 색상 지정을 지정합니다. Chaitin-Briggs 채색은 모든 아키텍처에서 구현되지는 않지만이를 지원하는 대상의 경우 더 나은 코드를 생성하기 때문에 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="79c08f6e9afbde3eae65486c01beb0bfcedf5e50" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which specifies Chow&amp;rsquo;s priority coloring, or &amp;lsquo;</source>
          <target state="translated">', 차우의 우선 색상을 지정하거나'</target>
        </trans-unit>
        <trans-unit id="b6395fd7f5367f1a12df6a010dc30044349a64d3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which specifies to use IBM&amp;rsquo;s Mathematical Acceleration Subsystem (MASS) libraries for vectorizing intrinsics using external libraries. GCC currently emits calls to &lt;code&gt;acosd2&lt;/code&gt;, &lt;code&gt;acosf4&lt;/code&gt;, &lt;code&gt;acoshd2&lt;/code&gt;, &lt;code&gt;acoshf4&lt;/code&gt;, &lt;code&gt;asind2&lt;/code&gt;, &lt;code&gt;asinf4&lt;/code&gt;, &lt;code&gt;asinhd2&lt;/code&gt;, &lt;code&gt;asinhf4&lt;/code&gt;, &lt;code&gt;atan2d2&lt;/code&gt;, &lt;code&gt;atan2f4&lt;/code&gt;, &lt;code&gt;atand2&lt;/code&gt;, &lt;code&gt;atanf4&lt;/code&gt;, &lt;code&gt;atanhd2&lt;/code&gt;, &lt;code&gt;atanhf4&lt;/code&gt;, &lt;code&gt;cbrtd2&lt;/code&gt;, &lt;code&gt;cbrtf4&lt;/code&gt;, &lt;code&gt;cosd2&lt;/code&gt;, &lt;code&gt;cosf4&lt;/code&gt;, &lt;code&gt;coshd2&lt;/code&gt;, &lt;code&gt;coshf4&lt;/code&gt;, &lt;code&gt;erfcd2&lt;/code&gt;, &lt;code&gt;erfcf4&lt;/code&gt;, &lt;code&gt;erfd2&lt;/code&gt;, &lt;code&gt;erff4&lt;/code&gt;, &lt;code&gt;exp2d2&lt;/code&gt;, &lt;code&gt;exp2f4&lt;/code&gt;, &lt;code&gt;expd2&lt;/code&gt;, &lt;code&gt;expf4&lt;/code&gt;, &lt;code&gt;expm1d2&lt;/code&gt;, &lt;code&gt;expm1f4&lt;/code&gt;, &lt;code&gt;hypotd2&lt;/code&gt;, &lt;code&gt;hypotf4&lt;/code&gt;, &lt;code&gt;lgammad2&lt;/code&gt;, &lt;code&gt;lgammaf4&lt;/code&gt;, &lt;code&gt;log10d2&lt;/code&gt;, &lt;code&gt;log10f4&lt;/code&gt;, &lt;code&gt;log1pd2&lt;/code&gt;, &lt;code&gt;log1pf4&lt;/code&gt;, &lt;code&gt;log2d2&lt;/code&gt;, &lt;code&gt;log2f4&lt;/code&gt;, &lt;code&gt;logd2&lt;/code&gt;, &lt;code&gt;logf4&lt;/code&gt;, &lt;code&gt;powd2&lt;/code&gt;, &lt;code&gt;powf4&lt;/code&gt;, &lt;code&gt;sind2&lt;/code&gt;, &lt;code&gt;sinf4&lt;/code&gt;, &lt;code&gt;sinhd2&lt;/code&gt;, &lt;code&gt;sinhf4&lt;/code&gt;, &lt;code&gt;sqrtd2&lt;/code&gt;, &lt;code&gt;sqrtf4&lt;/code&gt;, &lt;code&gt;tand2&lt;/code&gt;, &lt;code&gt;tanf4&lt;/code&gt;, &lt;code&gt;tanhd2&lt;/code&gt;, and &lt;code&gt;tanhf4&lt;/code&gt; when generating code for power7. Both</source>
          <target state="translated">'는 외부 라이브러리를 사용하여 내장 함수를 벡터화하기 위해 IBM의 수학 가속 서브 시스템 (MASS) 라이브러리를 사용하도록 지정합니다. GCC는 현재 &lt;code&gt;acosd2&lt;/code&gt; , &lt;code&gt;acosf4&lt;/code&gt; , &lt;code&gt;acoshd2&lt;/code&gt; , &lt;code&gt;acoshf4&lt;/code&gt; , &lt;code&gt;asind2&lt;/code&gt; , &lt;code&gt;asinf4&lt;/code&gt; , &lt;code&gt;asinhd2&lt;/code&gt; , &lt;code&gt;asinhf4&lt;/code&gt; , &lt;code&gt;atan2d2&lt;/code&gt; , &lt;code&gt;atan2f4&lt;/code&gt; , &lt;code&gt;atand2&lt;/code&gt; , &lt;code&gt;atanf4&lt;/code&gt; , &lt;code&gt;atanhd2&lt;/code&gt; , &lt;code&gt;atanhf4&lt;/code&gt; , &lt;code&gt;cbrtd2&lt;/code&gt; , &lt;code&gt;cbrtf4&lt;/code&gt; , &lt;code&gt;cosd2&lt;/code&gt; , &lt;code&gt;cosf4&lt;/code&gt; , &lt;code&gt;coshd2&lt;/code&gt; , &lt;code&gt;coshf4&lt;/code&gt; , &lt;code&gt;erfcd2&lt;/code&gt; , &lt;code&gt;erfcf4&lt;/code&gt; , &lt;code&gt;erfd2&lt;/code&gt; , &lt;code&gt;erff4&lt;/code&gt; , &lt;code&gt;exp2d2&lt;/code&gt; , &lt;code&gt;exp2f4&lt;/code&gt; , &lt;code&gt;expd2&lt;/code&gt; , &lt;code&gt;expf4&lt;/code&gt; , &lt;code&gt;expm1d2&lt;/code&gt; , &lt;code&gt;expm1f4&lt;/code&gt; , &lt;code&gt;hypotd2&lt;/code&gt; , &lt;code&gt;hypotf4&lt;/code&gt; , &lt;code&gt;lgammad2&lt;/code&gt; , &lt;code&gt;lgammaf4&lt;/code&gt; , &lt;code&gt;log10d2&lt;/code&gt; , &lt;code&gt;log10f4&lt;/code&gt; , &lt;code&gt;log1pd2&lt;/code&gt; , &lt;code&gt;log1pf4&lt;/code&gt; , &lt;code&gt;log2d2&lt;/code&gt; , &lt;code&gt;log2f4&lt;/code&gt; , &lt;code&gt;logd2&lt;/code&gt; , &lt;code&gt;logf4&lt;/code&gt; , &lt;code&gt;powd2&lt;/code&gt; , &lt;code&gt;powf4&lt;/code&gt; , &lt;code&gt;sind2&lt;/code&gt; &lt;code&gt;sinf4&lt;/code&gt; 에 대한 코드를 생성 할 때 , sinf4 , &lt;code&gt;sinhd2&lt;/code&gt; , &lt;code&gt;sinhf4&lt;/code&gt; , &lt;code&gt;sqrtd2&lt;/code&gt; , &lt;code&gt;sqrtf4&lt;/code&gt; , &lt;code&gt;tand2&lt;/code&gt; , &lt;code&gt;tanf4&lt;/code&gt; , &lt;code&gt;tanhd2&lt;/code&gt; 및 &lt;code&gt;tanhf4&lt;/code&gt; 양자 모두</target>
        </trans-unit>
        <trans-unit id="ec52c6c8b68900c9a1b37331cf41ae5885dd6c8c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which specify use of that register as a fixed register, and &amp;lsquo;</source>
          <target state="translated">해당 레지스터를 고정 레지스터로 사용하도록 지정하는 '및</target>
        </trans-unit>
        <trans-unit id="0fa47f8504586e908692f17a17fab12ae381513a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which still allows the compiler to generate code that uses the F and D extensions but only allows floating-point values up to 32 bits long to be passed in registers; or &amp;lsquo;</source>
          <target state="translated">컴파일러는 F 및 D 확장명을 사용하는 코드를 생성 할 수 있지만 최대 32 비트의 부동 소수점 값만 레지스터에 전달할 수 있습니다. 또는 '</target>
        </trans-unit>
        <trans-unit id="53d99d4b03fe4435b89eadd0e9f6c614ea297088" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, which uses the best available method for the selected processor. The default setting is &amp;lsquo;</source>
          <target state="translated">선택한 프로세서에 가장 적합한 방법을 사용합니다. 기본 설정은 '</target>
        </trans-unit>
        <trans-unit id="2e084164fbfa7bff5a69b7598f6c58a8fcd0c7b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, without regard to any appended suffix.</source>
          <target state="translated">추가 된 접미사에 관계없이 '.</target>
        </trans-unit>
        <trans-unit id="b27846e206f9ebe9eb4cd3b594b0158dff325fe5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;, without spaces between multiple switches. This is supposed to ease shell processing.</source>
          <target state="translated">', 여러 스위치 사이에 공백이 없습니다. 이것은 쉘 처리를 용이하게해야합니다.</target>
        </trans-unit>
        <trans-unit id="86308658ed645552e296e3e286b374ae7fff10b1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;,&amp;lsquo;</source>
          <target state="translated">&amp;rsquo;,&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="3525fe92d1fe943317ddfb69e6b92954c6550401" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;-newline. The rule has no commands.</source>
          <target state="translated">'-줄 바꿈. 규칙에는 명령이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ae559764dfeb5b5e27bbbecfa78f7d761264167" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;-prefixed sequences to substitute variable text or to conditionally insert text into the command line. Using these constructs it is possible to generate quite complex command lines.</source>
          <target state="translated">'-접두사 시퀀스는 변수 텍스트를 대체하거나 조건부로 텍스트를 명령 줄에 삽입합니다. 이러한 구성을 사용하면 매우 복잡한 명령 행을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1c5c0d2a49660e4c22ef3e1e1704e0f798a0eb" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;-sequences for spec strings. Note that spaces are not generated automatically around the results of expanding these sequences. Therefore you can concatenate them together or combine them with constant text in a single argument.</source>
          <target state="translated">스펙 문자열에 대한 '-시퀀스. 이 시퀀스를 확장 한 결과 주위에 공백이 자동으로 생성되지 않습니다. 따라서 하나의 인수로 함께 연결하거나 상수 텍스트와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dece5708020cd65d858b4b08e3d8683a52a6a69" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;.</source>
          <target state="translated">&amp;rsquo;.</target>
        </trans-unit>
        <trans-unit id="c07eebce021b49b4fc041471ed4831d6137b2147" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. %{o*} substitutes this text, including the space. Thus two arguments are generated.</source>
          <target state="translated">'. % {o *}는 공백을 포함하여이 텍스트를 대체합니다. 따라서 두 개의 인수가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5d70589a69d369e7bf4347c7ccd68068ef698e63" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. &amp;lsquo;</source>
          <target state="translated">'. '</target>
        </trans-unit>
        <trans-unit id="bd99174a74b07be99af73cd2272c2a9644b883d1" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. (This is currently a subset of what</source>
          <target state="translated">'. (이것은 현재</target>
        </trans-unit>
        <trans-unit id="ebabbca2f175db2d4ffdc366591326dd41543c2b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. &lt;var&gt;SUFFIX&lt;/var&gt; is terminated by the next space or %.</source>
          <target state="translated">'. &lt;var&gt;SUFFIX&lt;/var&gt; 는 다음 공백 또는 %로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="cb17f136b28af159a54ba2b3c86d8d1f3eca0e5d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. &lt;var&gt;suffix&lt;/var&gt; matches the regexp &amp;lsquo;</source>
          <target state="translated">'. &lt;var&gt;suffix&lt;/var&gt; 는 정규 표현식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c2bfbba1f4c17d6ec9876dae8da4ae1e45397993" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. All values of &lt;var&gt;model&lt;/var&gt; have the same meaning as described in</source>
          <target state="translated">'. &lt;var&gt;model&lt;/var&gt; 모든 값 은 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="26a41e2a6f327d47909ecc0aba5f40c82b05f73e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. As &lt;em&gt;earlyclobber&lt;/em&gt; operands are always written, a read-only &lt;em&gt;earlyclobber&lt;/em&gt; operand is ill-formed and will be rejected by the compiler.</source>
          <target state="translated">'. 으로 &lt;em&gt;earlyclobber&lt;/em&gt; 피연산자는 항상 기록, 읽기 전용 &lt;em&gt;earlyclobber&lt;/em&gt; 잘못 형성되고 컴파일러에 의해 거부됩니다 피연산자.</target>
        </trans-unit>
        <trans-unit id="c0112416480771c639f69f4bcd6e44161edeb27a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Aside from that, you can use any other GCC options; but if you want to prove that every single line in your program was executed, you should not compile with optimization at the same time. On some machines the optimizer can eliminate some simple code lines by combining them with other lines. For example, code like this:</source>
          <target state="translated">'. 그 외에도 다른 GCC 옵션을 사용할 수 있습니다. 그러나 프로그램의 모든 단일 행이 실행되었음을 증명하려면 동시에 최적화를 사용하여 컴파일해서는 안됩니다. 일부 기계에서는 옵티마이 저가 다른 코드와 결합하여 간단한 코드 행을 제거 할 수 있습니다. 예를 들어, 다음과 같은 코드 :</target>
        </trans-unit>
        <trans-unit id="34668a2e06b3aadb0dbe019b921c38fc3dbab69b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Backup copies of inline member functions, debugging information, and the internal tables used to implement virtual functions are all generated in implementation files.</source>
          <target state="translated">'. 인라인 멤버 함수, 디버깅 정보 및 가상 함수를 구현하는 데 사용되는 내부 테이블의 백업 사본은 모두 구현 파일에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ef3f97180bfe2b9e9474f1ef401797f93dc9d108" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. ColdFire architectures are selected according to Freescale&amp;rsquo;s ISA classification and the permissible values are: &amp;lsquo;</source>
          <target state="translated">'. ColdFire 아키텍처는 Freescale의 ISA 분류에 따라 선택되며 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="ce9fac1370b0628735cce987d97cf16c0ec23915" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Darwin does not support &amp;lsquo;</source>
          <target state="translated">'. 다윈은 '</target>
        </trans-unit>
        <trans-unit id="144515adfb3f2fe5defdce77d168399c9e3984b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Disables the floating-point and SIMD instructions on &amp;lsquo;</source>
          <target state="translated">'. '에서 부동 소수점 및 SIMD 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7f011d7b5d4cc55f295dd9f02d73db5853869155" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. For example,</source>
          <target state="translated">'. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fb7234b5dfd962028dcfee17fd1c40d6becee595" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. GCC recognizes files with these names and compiles them as C++ programs even if you call the compiler the same way as for compiling C programs (usually with the name &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">'. GCC는 이러한 이름을 가진 파일을 인식하고 C 프로그램을 컴파일 할 때와 같은 방식으로 (일반적으로 이름이 &lt;code&gt;gcc&lt;/code&gt; 인 ) 컴파일러를 호출하더라도 C ++ 프로그램으로 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="f3dbb764224c436ae5269f0b14a98e9ab5220599" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. GCC, following the ISO standard, does not allow this.</source>
          <target state="translated">'. ISO 표준에 따른 GCC는이를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08bff4931e5584bd604b402499372284b96ce5ff" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. If &lt;code&gt;%*&lt;/code&gt; appears in &lt;code&gt;X&lt;/code&gt;, all of the alternatives must be starred, and only the first matching alternative is substituted.</source>
          <target state="translated">'. 경우 &lt;code&gt;%*&lt;/code&gt; 에 나타납니다 &lt;code&gt;X&lt;/code&gt; , 대안 모두 출연해야하며, 첫 번째 일치하는 대안은 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7d68d3cf1754b449dca6cd9f416805cacc80a2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. If a function is named that is not built-in in this version of GCC, this option is ignored. There is no corresponding</source>
          <target state="translated">'. 이 버전의 GCC에 내장되어 있지 않은 함수가 명명 된 경우이 옵션은 무시됩니다. 해당 사항이 없습니다</target>
        </trans-unit>
        <trans-unit id="d4266bea6ec9a1e6780e56907ca8d131f13801c3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. If instead you write</source>
          <target state="translated">'. 대신에 당신이 쓰는 경우</target>
        </trans-unit>
        <trans-unit id="b591f0ca58fd0c9f6c02aaebea340ca453078cbf" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. In C++, the mangled name for the target must be used. It is an error if &amp;lsquo;</source>
          <target state="translated">'. C ++에서는 대상에 대한 맹 글링 된 이름을 사용해야합니다. '</target>
        </trans-unit>
        <trans-unit id="b088c9c98ee027b033a647cf3092141c87b2c30d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. In the case of &amp;lsquo;</source>
          <target state="translated">'. '의 경우</target>
        </trans-unit>
        <trans-unit id="9036ed5683fc147515f005ff7457f833667588ae" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. In the past, the system header files on many systems did not actually declare &lt;code&gt;time&lt;/code&gt;, so it did not matter what type your program declared it to return. But in systems with ISO C headers, &lt;code&gt;time&lt;/code&gt; is declared to return &lt;code&gt;time_t&lt;/code&gt;, and if that is not the same as &lt;code&gt;long&lt;/code&gt;, then &amp;lsquo;</source>
          <target state="translated">'. 과거에는 많은 시스템의 시스템 헤더 파일이 실제로 &lt;code&gt;time&lt;/code&gt; 선언 하지 않았으므로 프로그램이 어떤 유형을 반환하도록 선언했는지는 중요하지 않았습니다. 그러나 ISO C 헤더가있는 시스템에서 &lt;code&gt;time_t&lt;/code&gt; 를 반환하도록 &lt;code&gt;time&lt;/code&gt; 이 선언되고 , &lt;code&gt;long&lt;/code&gt; 가 같지 않으면 '</target>
        </trans-unit>
        <trans-unit id="71de86373b2c95a3f4d64f72180d98333b9c245b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. It is used to define &lt;code&gt;struct foo&lt;/code&gt; in such a way that &lt;code&gt;struct foo&lt;/code&gt; has the same layout and the structure field &lt;code&gt;x&lt;/code&gt; has the same alignment when &lt;code&gt;__u64&lt;/code&gt; is aligned at either 4 or 8 bytes. Align &lt;code&gt;struct foo&lt;/code&gt; to 8 bytes:</source>
          <target state="translated">'. &lt;code&gt;__u64&lt;/code&gt; 가 4 또는 8 바이트로 정렬 될 때 &lt;code&gt;struct foo&lt;/code&gt; 의 레이아웃이 동일하고 구조 필드 &lt;code&gt;x&lt;/code&gt; 의 정렬이 동일한 방식으로 &lt;code&gt;struct foo&lt;/code&gt; 를 정의하는 데 사용됩니다 . &lt;code&gt;struct foo&lt;/code&gt; 를 8 바이트로 정렬하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b7b69fb74833b9999f7b2578bf27a179fd441fc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Likewise, &amp;lsquo;</source>
          <target state="translated">'. 마찬가지로 '</target>
        </trans-unit>
        <trans-unit id="b25ae87870095d116e612875bacad3ca68d7deb7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Not available for ARC EM.</source>
          <target state="translated">'. ARC EM에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5033799763d08b021660d520078ce1d7313d968" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Note that &amp;lsquo;</source>
          <target state="translated">'. '</target>
        </trans-unit>
        <trans-unit id="318b20bba0b9b6136cc75e83b5151d88416e904c" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Note that only unnamed structs and unions are allowed, you may not have, for example, an unnamed &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">'. 명명되지 않은 구조체와 공용체 만 허용되며, 예를 들어 명명되지 않은 &lt;code&gt;int&lt;/code&gt; 를 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c2efd7a1f09ee927b7431e335115931670665373" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Note that the choice is subject to optimization: the compiler may use a more efficient model for symbols not visible outside of the translation unit, or if</source>
          <target state="translated">'. 선택은 최적화의 대상이됩니다. 컴파일러는 변환 단위 외부에서 보이지 않거나 심볼이있는 경우 더 효율적인 모델을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d84fd44705faa919710e5a5a567c03be82e4e5e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Pedantic warnings are also disabled in the expression that follows &lt;code&gt;__extension__&lt;/code&gt;. However, only system header files should use these escape routes; application programs should avoid them. See &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;Alternate Keywords&lt;/a&gt;.</source>
          <target state="translated">'. &lt;code&gt;__extension__&lt;/code&gt; 다음에 오는 표현식에서는 의미 론적 경고도 비활성화되어 있습니다. 그러나 시스템 헤더 파일 만이 이스케이프 라우트를 사용해야합니다. 응용 프로그램은 피해야합니다. &lt;a href=&quot;alternate-keywords#Alternate-Keywords&quot;&gt;대체 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d106126450d402defd32926b6a07b8058193e8cd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Previously, &amp;lsquo;</source>
          <target state="translated">'. 이전에는 '</target>
        </trans-unit>
        <trans-unit id="91fec6793e91142970cbc2f94e0e2d931265d9a7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Refer to</source>
          <target state="translated">'. 인용하다</target>
        </trans-unit>
        <trans-unit id="1311df9de660e63cadb852066da316d261298d24" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. See &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;.</source>
          <target state="translated">'. &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;환경 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaf91ece2d881a3cd32c835822bcb56d2ad0243e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Some calling conventions are impossible to implement on some ISAs: for example, &amp;lsquo;</source>
          <target state="translated">'. 일부 호출 규칙은 일부 ISA에서 구현할 수 없습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="a190d1fbd8df2eaeb97bf8dfebcec6e9fb64c0b2" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Specifying &amp;lsquo;</source>
          <target state="translated">'. '지정</target>
        </trans-unit>
        <trans-unit id="b517fa930eabc5143e6a2488d57edbae11688ae8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. Such a setting will name the data file</source>
          <target state="translated">'. 이러한 설정은 데이터 파일의 이름을 지정합니다</target>
        </trans-unit>
        <trans-unit id="fd1611dd4569a88af914da509268caa5134b1296" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The &amp;lsquo;</source>
          <target state="translated">'. '</target>
        </trans-unit>
        <trans-unit id="95987fef4e179da34ae695b2d604db02e1ef2507" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The ColdFire &lt;var&gt;cpu&lt;/var&gt;s are given by the table below, which also classifies the CPUs into families:</source>
          <target state="translated">'. ColdFire &lt;var&gt;cpu&lt;/var&gt; 는 아래 표에 나와 있으며 CPU를 제품군으로 분류합니다.</target>
        </trans-unit>
        <trans-unit id="39f26c85467bca2a86cf187cdaa1f82a92dd500b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The ColdFire microarchitectures are: &amp;lsquo;</source>
          <target state="translated">'. ColdFire 마이크로 아키텍처는 다음과 같습니다. '</target>
        </trans-unit>
        <trans-unit id="1ea24288b4005507fd45c41a5bb5599705b6e6fd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The compiler also issues a warning, like &amp;lsquo;</source>
          <target state="translated">'. 컴파일러는 '</target>
        </trans-unit>
        <trans-unit id="c67138f86f8bd3b4491ad0910cc95a4fc7e9b819" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The compiler gives errors for such constructs.</source>
          <target state="translated">'. 컴파일러는 이러한 구성에 오류를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0726de9452e52fbfdda6ff6a4218547b363e917e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The default ISA is sm_30.</source>
          <target state="translated">'. 기본 ISA는 sm_30입니다.</target>
        </trans-unit>
        <trans-unit id="984545af201446c7e2041d27d40b9dfbdfc1d480" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The default cache size is 64KB.</source>
          <target state="translated">'. 기본 캐시 크기는 64KB입니다.</target>
        </trans-unit>
        <trans-unit id="c5f007e66a67a47ccee24c846b7d52a755cea4ae" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The default depends on how the compiler has been configured, it can be any of the above &lt;var&gt;WHEN&lt;/var&gt; options or also &amp;lsquo;</source>
          <target state="translated">'. 기본값은 컴파일러의 구성 방식에 따라 다르며 위의 &lt;var&gt;WHEN&lt;/var&gt; 옵션 중 하나이거나 '</target>
        </trans-unit>
        <trans-unit id="99f888b01addeed94f74efc8a92fbac99be06433" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The default if</source>
          <target state="translated">'. 기본 경우</target>
        </trans-unit>
        <trans-unit id="ea0c5ec8fd22ea6fee202ca6916c9e682ee6e7fd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The default is &amp;lsquo;</source>
          <target state="translated">'. 기본값은 '</target>
        </trans-unit>
        <trans-unit id="d0e259ad7b9cda818e8d39201ed478f72bec6ec5" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The first one is useful for single-threaded applications, while the second one prevents profile corruption by emitting thread-safe code.</source>
          <target state="translated">'. 첫 번째는 단일 스레드 응용 프로그램에 유용하고 두 번째는 스레드 안전 코드를 생성하여 프로필 손상을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="3a7b6db71fd3de95568e7e8bb18be320b22766cf" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The label must still be listed in the &lt;var&gt;GotoLabels&lt;/var&gt; section when using this approach.</source>
          <target state="translated">'. 이 방법을 사용할 때 레이블은 여전히 &lt;var&gt;GotoLabels&lt;/var&gt; 섹션에 나열되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="509f5bcf7e8400bc0491d4aeedccc1df5fdbcc82" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The meanings are the same as for the extensions to</source>
          <target state="translated">'. 의미는 확장 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a50a8e414947d71b3be5444f7bfdf7f9c5a0d74e" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The option is needed when the program extends the lifetime of a scoped local variable or a compiler generated temporary beyond the end point defined by the language. When a lifetime of a variable ends, and if the variable lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. Legacy code extending local lifetime is likely to break with the stack reuse optimization.</source>
          <target state="translated">'. 이 옵션은 프로그램이 범위가 지정된 로컬 변수의 수명을 연장하거나 컴파일러가 언어로 정의 된 끝점을 넘어 임시로 생성 된 경우에 필요합니다. 변수의 수명이 끝나고 변수가 메모리에 있으면 최적화 컴파일러는 스택 범위를 다른 임시 또는 범위 변수와 겹치지 않는 범위가 지정된 로컬 변수와 함께 자유롭게 재사용 할 수 있습니다. 로컬 수명을 연장하는 레거시 코드는 스택 재사용 최적화로 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e76650fa4e064c904802723a282ea409b1c512" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The processor names are: &amp;lsquo;</source>
          <target state="translated">'. 프로세서 이름은 '</target>
        </trans-unit>
        <trans-unit id="0c7ab966964d35b1d65d62764fbde6b02ce185c3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The special value &amp;lsquo;</source>
          <target state="translated">'. 특별한 가치 '</target>
        </trans-unit>
        <trans-unit id="ec1d5e9115273904b0d4e3217c9f9dadfb94a592" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. The value has type &lt;code&gt;void *&lt;/code&gt;. This value is a constant and can be used wherever a constant of that type is valid. For example:</source>
          <target state="translated">'. 값의 유형은 &lt;code&gt;void *&lt;/code&gt; 입니다. 이 값은 상수이며 해당 유형의 상수가 유효한 모든 곳에서 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a49ed6249ec64656dcc28e26855c09a1e70be82" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. These are the extensions that GCC uses for preprocessed files created by</source>
          <target state="translated">'. GCC에서 생성 한 사전 처리 된 파일에 사용하는 확장명입니다.</target>
        </trans-unit>
        <trans-unit id="c340165ed2781f436e620f363d28887620b552e8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. These can be used to improve optimization. Currently, they are only used in one place: in</source>
          <target state="translated">'. 이들은 최적화를 향상시키는 데 사용될 수 있습니다. 현재는 한 곳에서만 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="80fa6be15a7162a6632d31e099a63ea1a1b003cc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This in turn is used by the</source>
          <target state="translated">'. 이것은 차례로</target>
        </trans-unit>
        <trans-unit id="60a420a1dc9c2b1ba63eb51ebb8e08cd0a754a3a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This is a GNU extension. For example,</source>
          <target state="translated">'. 이것은 GNU 확장입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="877bd31f7e2057375c174895bb473eb44a99c3aa" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This is particularly useful in environments that operate a lot on the bit level (like microcontrollers).</source>
          <target state="translated">'. 이것은 특히 마이크로 컨트롤러와 같이 비트 수준에서 많이 작동하는 환경에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d54f292cb6286085f0e53e7d45c832d8af478541" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This is useful if sourcefiles are in several different directories.</source>
          <target state="translated">'. 소스 파일이 여러 다른 디렉토리에있는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dea282d75128e2e55025b832d35cd242bed89773" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This option has been deprecated by -mbranch-protection.</source>
          <target state="translated">'. 이 옵션은 -mbranch-protection에 의해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7480b51fde68ea2f5ca5289f9811faf70d22a0f8" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This option is deprecated. The</source>
          <target state="translated">'. 이 옵션은 더 이상 사용되지 않습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="ef37fc6184ad856cae988d5c0a2b60736e5c1c04" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This option is only available on the 64-bit HP-UX GCC, i.e. configured with &amp;lsquo;</source>
          <target state="translated">'. 이 옵션은 64 비트 HP-UX GCC에서만 사용할 수 있습니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="78af1a2b0f317b8f65a1549c2905f6cec65ef3c4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This tells the compiler to generate additional information needed by gcov (basically a flow graph of the program) and also includes additional code in the object files for generating the extra profiling information needed by gcov. These additional files are placed in the directory where the object file is located.</source>
          <target state="translated">'. 이것은 컴파일러에게 gcov에 필요한 추가 정보 (기본적으로 프로그램의 플로우 그래프)를 생성하도록 지시하고 gcov에 필요한 추가 프로파일 링 정보를 생성하기위한 오브젝트 파일에 추가 코드도 포함합니다. 이러한 추가 파일은 오브젝트 파일이있는 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5ae572b044573aa8167cfdeb5660a51ca4f5cf3" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. This temporary file is not meant for communication between processes, but rather as a junk disposal mechanism.</source>
          <target state="translated">'. 이 임시 파일은 프로세스 간 통신이 아니라 정크 처리 메커니즘으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de80f6d77c61c199645e26590cde27dc448403bc" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. To maintain the whole program optimization it is recommended to link such objects into static library instead. Alternatively it is possible to use H.J. Lu&amp;rsquo;s binutils with support for mixed objects.</source>
          <target state="translated">'. 전체 프로그램 최적화를 유지하려면 대신 이러한 객체를 정적 라이브러리에 연결하는 것이 좋습니다. 또는 혼합 객체를 지원하는 HJ Lu의 binutils를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d05b6029dd2a7b939fe9201df9c734ba3996a7" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. To reduce exposure to denial-of-service attacks, the file name is now chosen in a way that is hard to predict even when previously chosen file names are known. For example, &amp;lsquo;</source>
          <target state="translated">'. 서비스 거부 공격에 대한 노출을 줄이기 위해 이전에 선택한 파일 이름이 알려진 경우에도 예측하기 어려운 방식으로 파일 이름이 선택됩니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="10bcdbe30a9c3f088aa63dfc7f0c5f6692a7ef56" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. To resolve this you either need to put</source>
          <target state="translated">'. 이 문제를 해결하려면</target>
        </trans-unit>
        <trans-unit id="95c6715f73aa5d0af712fb6134880b9fcbd79120" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. When a base standard is specified, the compiler accepts all programs following that standard plus those using GNU extensions that do not contradict it. For example,</source>
          <target state="translated">'. 기본 표준이 지정되면 컴파일러는 해당 표준을 따르지 않는 GNU 확장명을 사용하는 프로그램과 그 표준을 따르는 모든 프로그램을 승인합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d141ae557c3ffdb3753a6a41a13d3a2b084753bd" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. When you list more than one possible location (for example, &amp;lsquo;</source>
          <target state="translated">'. 둘 이상의 가능한 위치를 나열하면 (예 : '</target>
        </trans-unit>
        <trans-unit id="83fe51260eb75dd9c72893e7b9b2fb9495d8b24d" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. While &amp;lsquo;</source>
          <target state="translated">'. 동안 '</target>
        </trans-unit>
        <trans-unit id="99b60c3edd35097ae5312da98dd3e4613c5c59db" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. With native Solaris and GNU/Linux toolchains, &amp;lsquo;</source>
          <target state="translated">'. 기본 Solaris 및 GNU / Linux 툴체인으로 '</target>
        </trans-unit>
        <trans-unit id="1fa61258c1cd78b2c137d2dd13766886720e3936" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;. With the &amp;lsquo;</source>
          <target state="translated">'. 이랑 '</target>
        </trans-unit>
        <trans-unit id="f3dc366f61d8fabb2ad615ae2f691b7fc061f609" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;/&amp;lsquo;</source>
          <target state="translated">&amp;rsquo;/&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="156309a7b165cae2860384c8bd41ff8b92b091f4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;:</source>
          <target state="translated">&amp;rsquo;:</target>
        </trans-unit>
        <trans-unit id="1eb8135cc50a6d10a9fd22ec9ddc97deda072b07" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;: these extensions disable the specified option and any other extensions that may depend on the presence of that extension.</source>
          <target state="translated">':이 확장은 지정된 옵션 및 해당 확장의 존재 여부에 따라 다른 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="10548d28e15289950fa348ee543ccdceadc64c48" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; &amp;lsquo;</source>
          <target state="translated">'; '</target>
        </trans-unit>
        <trans-unit id="d056957801202f4b885351da27e86f96b001e71b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; C++ header files often use &amp;lsquo;</source>
          <target state="translated">'; C ++ 헤더 파일은 종종 '</target>
        </trans-unit>
        <trans-unit id="14a65bdd12d63f7386ba288ffd05e53d2b1b3353" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; and any setting of</source>
          <target state="translated">'; 그리고 어떤 설정</target>
        </trans-unit>
        <trans-unit id="879ada406a8ceb853c0f4a2d334e5423ad141c4b" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; and preprocessed C++ files use the suffix &amp;lsquo;</source>
          <target state="translated">'; 사전 처리 된 C ++ 파일은 접미사 '</target>
        </trans-unit>
        <trans-unit id="779783ef739406f991e6471784da6ce1c3d86b00" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; the default is &amp;lsquo;</source>
          <target state="translated">'; 기본값은 '</target>
        </trans-unit>
        <trans-unit id="8e4fbe0f7061332ebc6307b11d6557e735e43959" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;; with</source>
          <target state="translated">'; 와</target>
        </trans-unit>
        <trans-unit id="532b1a64c747914b89bd10f272d06140e5c954e4" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;? Sometimes it allows better code to be generated.</source>
          <target state="translated">'? 때로는 더 나은 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026366245e3ea8296dbdd0b1b6034424cc1ac47a" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;](&amp;lsquo;</source>
          <target state="translated">&amp;rsquo;](&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="60b0b92b2462673ed5f8cdc4eda20e78b1b728aa" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;][&amp;lsquo;</source>
          <target state="translated">&amp;rsquo;][&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="1de782ae7763bac352b0e9b09d14d7a9ac06ff61" translate="yes" xml:space="preserve">
          <source>&amp;rsquo;|&amp;lsquo;</source>
          <target state="translated">&amp;rsquo;|&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="eb6294d9bae2e5ca823e84066b30abc5ef143039" translate="yes" xml:space="preserve">
          <source>'??/n'</source>
          <target state="translated">'??/n'</target>
        </trans-unit>
        <trans-unit id="4262b9cfb91c51cbf3f44b62fe2a7b81e2676c78" translate="yes" xml:space="preserve">
          <source>'FOOF'</source>
          <target state="translated">'FOOF'</target>
        </trans-unit>
        <trans-unit id="caa61a56c1bf4b89298cbbce30e9181117ce2f54" translate="yes" xml:space="preserve">
          <source>(C++ only) A base class is not initialized in the copy constructor of a derived class.</source>
          <target state="translated">(C ++ 전용) 파생 클래스의 복사 생성자에서 기본 클래스가 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee2291a0563b01ff7fdfe4e8efa7650f8a5b537a" translate="yes" xml:space="preserve">
          <source>(C++ only) Ambiguous virtual bases.</source>
          <target state="translated">(C ++ 전용) 모호한 가상 기반.</target>
        </trans-unit>
        <trans-unit id="dc6745c9fc96f11cdd3ca8018b2f16a7465a02cc" translate="yes" xml:space="preserve">
          <source>(C++ only) An enumerator and a non-enumerator both appear in a conditional expression.</source>
          <target state="translated">(C ++에만 해당) 열거 자와 비 열거자는 모두 조건식으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3c9a648042433eeec71305942c0962bdaedafbb1" translate="yes" xml:space="preserve">
          <source>(C++ only) Subscripting an array that has been declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">(C ++ 전용) &lt;code&gt;register&lt;/code&gt; 로 선언 된 배열을 첨자 화합니다 .</target>
        </trans-unit>
        <trans-unit id="68eedac95edd544dcb28cc6aa2281a183f6f6c6a" translate="yes" xml:space="preserve">
          <source>(C++ only) Taking the address of a variable that has been declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">(C ++ 전용) &lt;code&gt;register&lt;/code&gt; 로 선언 된 변수의 주소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="daf861b43184d4153abb4df39cb8f7fd94eb561a" translate="yes" xml:space="preserve">
          <source>(C, Objective-C, C++, Objective-C++ and Fortran only)</source>
          <target state="translated">(C, Objective-C, C ++, Objective-C ++ 및 Fortran 만 해당)</target>
        </trans-unit>
        <trans-unit id="2df280ab593af30434215cb8468898676012fc21" translate="yes" xml:space="preserve">
          <source>(Dis/En)able control speculative scheduling. This feature is available only during region scheduling (i.e. before reload). This results in generation of the &lt;code&gt;ld.s&lt;/code&gt; instructions and the corresponding check instructions &lt;code&gt;chk.s&lt;/code&gt;. The default setting is disabled.</source>
          <target state="translated">(Dis / En) 제어 추론 스케줄링. 이 기능은 리전 예약 중 (즉, 다시로드하기 전)에만 사용할 수 있습니다. 결과적으로 &lt;code&gt;ld.s&lt;/code&gt; 명령어와 해당 검사 명령어 &lt;code&gt;chk.s&lt;/code&gt; 가 생성 됩니다. 기본 설정은 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="9221df4a228447987ae95de2115c69067f514593" translate="yes" xml:space="preserve">
          <source>(Dis/En)able data speculative scheduling before reload. This results in generation of &lt;code&gt;ld.a&lt;/code&gt; instructions and the corresponding check instructions (&lt;code&gt;ld.c&lt;/code&gt; / &lt;code&gt;chk.a&lt;/code&gt;). The default setting is disabled.</source>
          <target state="translated">다시로드하기 전에 (Dis / En) able 데이터 추론 스케줄링. 이로 인해 &lt;code&gt;ld.a&lt;/code&gt; 명령어와 해당 검사 명령어 ( &lt;code&gt;ld.c&lt;/code&gt; / &lt;code&gt;chk.a&lt;/code&gt; )가 생성됩니다. 기본 설정은 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="bb4563f137d6532d80529c92294b38b94e3d50f0" translate="yes" xml:space="preserve">
          <source>(En/Dis)able data speculative scheduling after reload. This results in generation of &lt;code&gt;ld.a&lt;/code&gt; instructions and the corresponding check instructions (&lt;code&gt;ld.c&lt;/code&gt; / &lt;code&gt;chk.a&lt;/code&gt;). The default setting is enabled.</source>
          <target state="translated">재로드 후 (En / Dis) able 데이터 추론 스케줄링. 이로 인해 &lt;code&gt;ld.a&lt;/code&gt; 명령어와 해당 검사 명령어 ( &lt;code&gt;ld.c&lt;/code&gt; / &lt;code&gt;chk.a&lt;/code&gt; )가 생성됩니다. 기본 설정은 활성화입니다.</target>
        </trans-unit>
        <trans-unit id="9b5d3dd642fecc8c54f3574ae7e4eca939a0223d" translate="yes" xml:space="preserve">
          <source>(En/Dis)able speculative scheduling of the instructions that are dependent on the control speculative loads. This is effective only with</source>
          <target state="translated">제어 추론 부하에 의존하는 명령의 (En / Dis) able 추론 스케줄링. 이 기능은</target>
        </trans-unit>
        <trans-unit id="6e24e206b19deaa607df74a2a03c88ca434715e8" translate="yes" xml:space="preserve">
          <source>(En/Dis)able speculative scheduling of the instructions that are dependent on the data speculative loads after reload. This is effective only with</source>
          <target state="translated">재로드 후 데이터 추론로드에 의존하는 명령의 (En / Dis) able 추론 스케줄링. 이 기능은</target>
        </trans-unit>
        <trans-unit id="9ed5d4687734c1c08a3521f633f36f3d8b047751" translate="yes" xml:space="preserve">
          <source>(En/Dis)able speculative scheduling of the instructions that are dependent on the data speculative loads before reload. This is effective only with</source>
          <target state="translated">다시로드하기 전에 데이터 추론로드에 의존하는 명령의 (En / Dis) able 추론 스케줄링. 이 기능은</target>
        </trans-unit>
        <trans-unit id="f65f29a10482b00bc5d910c9f1c1ebf21261bfb6" translate="yes" xml:space="preserve">
          <source>(NOTE: This manual does not describe the Objective-C and Objective-C++ languages themselves. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for references.)</source>
          <target state="translated">(참고 :이 매뉴얼은 Objective-C 및 Objective-C ++ 언어 자체를 설명하지 않습니다. 참조에 대해서는 &lt;a href=&quot;standards#Standards&quot;&gt;GCC가 지원하는 언어 표준&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="255cb0de41656d1d88145ac9a013fc923a373d29" translate="yes" xml:space="preserve">
          <source>(Of course, users strongly concerned about portability should indicate explicitly in each bit-field whether it is signed or not. In this way, they write programs which have the same meaning in both C dialects.)</source>
          <target state="translated">(물론, 이식성에 관심이있는 사용자는 각 비트 필드에 부호가 있는지 여부를 명시 적으로 표시해야합니다. 이러한 방식으로 두 C 방언에서 동일한 의미를 가진 프로그램을 작성합니다.)</target>
        </trans-unit>
        <trans-unit id="8f6b7736e459a50ee7bbeb56f3d58bf288b8bded" translate="yes" xml:space="preserve">
          <source>(a) The FSF&amp;rsquo;s Front-Cover Text is:</source>
          <target state="translated">(a) FSF의 프론트 커버 텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e75bfc57ae0ab8bcba864cc9d8834305f57fa0d" translate="yes" xml:space="preserve">
          <source>(although &lt;code&gt;inline&lt;/code&gt; can be used in a program compiled with</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 을 사용하여 컴파일 된 프로그램에서 사용할 수는 있지만</target>
        </trans-unit>
        <trans-unit id="d32ccfc33694fd3b9b08e15cd17089eb0baac7ce" translate="yes" xml:space="preserve">
          <source>(and</source>
          <target state="translated">(and</target>
        </trans-unit>
        <trans-unit id="e7c1e631efc5e951a858a5546de3f08168476af8" translate="yes" xml:space="preserve">
          <source>(and its suboptions except for</source>
          <target state="translated">(및 제외하고 하위 옵션</target>
        </trans-unit>
        <trans-unit id="cf05f29eaa82449ea9aa6a568e24067dd4305c19" translate="yes" xml:space="preserve">
          <source>(b) The FSF&amp;rsquo;s Back-Cover Text is:</source>
          <target state="translated">(b) FSF의 백 커버 텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c5c07cd3e0584e5f83e6eca859aaee8270b6f9f" translate="yes" xml:space="preserve">
          <source>(equivalent to</source>
          <target state="translated">(와 동등한</target>
        </trans-unit>
        <trans-unit id="6fe1e95fb4f3ef08fb68e78f655aad948380249c" translate="yes" xml:space="preserve">
          <source>(for C++11 with GNU extensions), or</source>
          <target state="translated">(GNU 확장이있는 C ++ 11의 경우) 또는</target>
        </trans-unit>
        <trans-unit id="6749511020de741ea49c56137cabe2321f62325a" translate="yes" xml:space="preserve">
          <source>(for C++14 with GNU extensions), or</source>
          <target state="translated">(GNU 확장이있는 C ++ 14의 경우) 또는</target>
        </trans-unit>
        <trans-unit id="347f5b597e85d7cf2b587972a2d1be7fc90d299d" translate="yes" xml:space="preserve">
          <source>(for C++17 with GNU extensions).</source>
          <target state="translated">(GNU 확장이있는 C ++ 17의 경우).</target>
        </trans-unit>
        <trans-unit id="fddd4e75314207e7b4d93d5aeca459aee1caa67b" translate="yes" xml:space="preserve">
          <source>(for C++98 with GNU extensions), or</source>
          <target state="translated">(GNU 확장이있는 C ++ 98의 경우) 또는</target>
        </trans-unit>
        <trans-unit id="acd73cb6eb7c3001e16e7f350d58f1e37fd35077" translate="yes" xml:space="preserve">
          <source>(for C11 with GNU extensions).</source>
          <target state="translated">(GNU 확장이있는 C11의 경우).</target>
        </trans-unit>
        <trans-unit id="0d304bbeefe2e485104adfe1c8dd44203659ea72" translate="yes" xml:space="preserve">
          <source>(for C90 with GNU extensions),</source>
          <target state="translated">(GNU 확장이있는 C90의 경우)</target>
        </trans-unit>
        <trans-unit id="bb0092b8683dbd00186e0dece89ae6c032549670" translate="yes" xml:space="preserve">
          <source>(for C99 with GNU extensions) or</source>
          <target state="translated">(GNU 확장이있는 C99의 경우) 또는</target>
        </trans-unit>
        <trans-unit id="945ebd24fda58f96cbbedd3f15dfad1eeef3b869" translate="yes" xml:space="preserve">
          <source>(included in</source>
          <target state="translated">(포함 된</target>
        </trans-unit>
        <trans-unit id="5272e337f576fd3bc809f60d0191a6671ae86a93" translate="yes" xml:space="preserve">
          <source>(long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;, double &lt;var&gt;probability&lt;/var&gt;)</source>
          <target state="translated">(긴 &lt;var&gt;exp&lt;/var&gt; , 긴 &lt;var&gt;c&lt;/var&gt; , 이중 &lt;var&gt;probability&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="dfc8504e187c996290246ad495a2cf2c1a3b31b8" translate="yes" xml:space="preserve">
          <source>(made from &lt;code&gt;COMPILER_PATH&lt;/code&gt; and</source>
          <target state="translated">(만든 &lt;code&gt;COMPILER_PATH&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="e6745aa693d17e821abd67ed4aeeb14aefa9e2c8" translate="yes" xml:space="preserve">
          <source>(made from &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;),</source>
          <target state="translated">( &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 로 제작 ),</target>
        </trans-unit>
        <trans-unit id="682280673e3fef822f44e59e9eab0b6b94a02145" translate="yes" xml:space="preserve">
          <source>(made from &lt;code&gt;TARGET_SYSTEM_ROOT&lt;/code&gt;),</source>
          <target state="translated">( &lt;code&gt;TARGET_SYSTEM_ROOT&lt;/code&gt; 로 제작 ),</target>
        </trans-unit>
        <trans-unit id="519f5cd783a31489bdabb22db2101a6aba0c69bb" translate="yes" xml:space="preserve">
          <source>(note that</source>
          <target state="translated">(참고</target>
        </trans-unit>
        <trans-unit id="762b7473fc9b01f5f7e845131d0e7c1d72ee12cc" translate="yes" xml:space="preserve">
          <source>(note the single quote surrounding the option).</source>
          <target state="translated">(옵션을 둘러싼 작은 따옴표를 참고하십시오).</target>
        </trans-unit>
        <trans-unit id="7739136dc697141cd8d76585cab6736b910f012b" translate="yes" xml:space="preserve">
          <source>(or</source>
          <target state="translated">(or</target>
        </trans-unit>
        <trans-unit id="9d3b478758763e62fffcc112311a494edb86b8e2" translate="yes" xml:space="preserve">
          <source>(or at least</source>
          <target state="translated">(아니면 적어도</target>
        </trans-unit>
        <trans-unit id="13837ddf736eb9effbcf49bb601c63831ec49562" translate="yes" xml:space="preserve">
          <source>(or filename suffixes) to tell &lt;code&gt;gcc&lt;/code&gt; where to start, and one of the options</source>
          <target state="translated">(또는 파일 이름 접미사) &lt;code&gt;gcc&lt;/code&gt; 에게 시작 위치를 알려주고 옵션 중 하나</target>
        </trans-unit>
        <trans-unit id="09db8785647fde935fa1f767fe4c0bab3ab319f9" translate="yes" xml:space="preserve">
          <source>(or the above option combination), and doesn&amp;rsquo;t need</source>
          <target state="translated">(또는 위의 옵션 조합), 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="80093bb361ef2b4667b08e10b253d923200ffc1e" translate="yes" xml:space="preserve">
          <source>(or the equivalent</source>
          <target state="translated">(또는 동등한</target>
        </trans-unit>
        <trans-unit id="590d907ceee53a6f5e07761d6444edeed40345ad" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;adapteva-epiphany-options#Adapteva-Epiphany-Options&quot;&gt;Adapteva Epiphany Options&lt;/a&gt;) command-line switch and &lt;code&gt;#pragma long_calls&lt;/code&gt; settings.</source>
          <target state="translated">( &lt;a href=&quot;adapteva-epiphany-options#Adapteva-Epiphany-Options&quot;&gt;Adapteva Epiphany 옵션&lt;/a&gt; 참조 ) 명령 행 스위치 및 &lt;code&gt;#pragma long_calls&lt;/code&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="fed4f9fc14b26a8f1cd77a672d74ba7284e93bc1" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;arc-options#ARC-Options&quot;&gt;ARC Options&lt;/a&gt;) command-line switches and &lt;code&gt;#pragma long_calls&lt;/code&gt; settings.</source>
          <target state="translated">( &lt;a href=&quot;arc-options#ARC-Options&quot;&gt;ARC 옵션&lt;/a&gt; 참조 ) 명령 행 스위치 및 &lt;code&gt;#pragma long_calls&lt;/code&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="f60b07f30fcef804891a61a3656e18507e9fc89c" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM Options&lt;/a&gt;) command-line switch and &lt;code&gt;#pragma long_calls&lt;/code&gt; settings. For ARM, the &lt;code&gt;long_call&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;short_call&lt;/code&gt; attribute always places the offset to the function from the call site into the &amp;lsquo;</source>
          <target state="translated">( &lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM 옵션&lt;/a&gt; 참조 ) 명령 줄 스위치 및 &lt;code&gt;#pragma long_calls&lt;/code&gt; 설정. ARM의 경우 &lt;code&gt;long_call&lt;/code&gt; 속성은 함수가 호출 사이트에서 멀리 떨어져 있고 다른 (더 비싼) 호출 시퀀스 가 필요함을 나타냅니다. &lt;code&gt;short_call&lt;/code&gt; 의 속성은 항상 '는로 호출 사이트에서 함수에 오프셋을 위치하게</target>
        </trans-unit>
        <trans-unit id="4ba0ed75e8c7540c11c10cb8062d5bc95aac39de" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;Code Gen Options&lt;/a&gt;) to reserve the register.</source>
          <target state="translated">레지스터를 예약하려면 ( &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;코드 생성 옵션&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="7d740585c10f26409831f844bd55d5eedd751463" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;Directory Options&lt;/a&gt;). These take precedence over places specified using environment variables, which in turn take precedence over those specified by the configuration of GCC. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Driver.html#Driver&quot;&gt;Controlling the Compilation Driver &lt;samp&gt;gcc&lt;/samp&gt;&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">( &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;디렉토리 옵션&lt;/a&gt; 참조 ). 환경 변수를 사용하여 지정된 장소보다 우선하며, GCC 구성으로 지정된 장소보다 우선합니다. &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Driver.html#Driver&quot;&gt;컴파일 드라이버 제어를&lt;/a&gt; 참조하십시오.&lt;samp&gt;gcc&lt;/samp&gt; GNU 컴파일러 컬렉션 (GCC) 내부.</target>
        </trans-unit>
        <trans-unit id="cd1e6772aba404587464a979947570da09643511" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) in the called function, to serve as a special side effect.</source>
          <target state="translated">특수한 부작용으로 작용하기 위해 호출 된 함수에서 ( &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;확장 Asm&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="0938503247a790a7b4b9f4207e5e89f7a4253b1c" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;), you can compile it a second time using</source>
          <target state="translated">( &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;계측 옵션&lt;/a&gt; 참조 )을 사용하여 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9cd77b4be10b663ba5f3b9cb3608966fbd644ed" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;mips-options#MIPS-Options&quot;&gt;MIPS Options&lt;/a&gt;) command-line switch. The &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;far&lt;/code&gt; attributes are synonyms, and cause the compiler to always call the function by first loading its address into a register, and then using the contents of that register. The &lt;code&gt;short_call&lt;/code&gt; and &lt;code&gt;near&lt;/code&gt; attributes are synonyms, and have the opposite effect; they specify that non-PIC calls should be made using the more efficient &lt;code&gt;jal&lt;/code&gt; instruction.</source>
          <target state="translated">( &lt;a href=&quot;mips-options#MIPS-Options&quot;&gt;MIPS 옵션&lt;/a&gt; 참조 ) 명령 행 스위치. &lt;code&gt;long_call&lt;/code&gt; 와 &lt;code&gt;far&lt;/code&gt; 속성은 동의어이며, 항상 레지스터의 내용을 사용하여 다음 레지스터에 처음으로로드하여 주소를 함수를 호출하고, 컴파일러 원인이됩니다. &lt;code&gt;short_call&lt;/code&gt; 와 &lt;code&gt;near&lt;/code&gt; 속성은 동의어이며, 반대의 효과가; 보다 효율적인 &lt;code&gt;jal&lt;/code&gt; 명령어를 사용하여 비 PIC 통화를하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0e3f80e361ac2552514137893b0ab9fabcabe627" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Optimize Options&lt;/a&gt;) option for this function.</source>
          <target state="translated">이 기능에 대한 옵션을 &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;최적화&lt;/a&gt; 하십시오 ( 옵션 최적화 ).</target>
        </trans-unit>
        <trans-unit id="9a18948f20eb8ae98ad70a254b90243efbc88d0d" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Optimize Options&lt;/a&gt;) with</source>
          <target state="translated">( &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;옵션 최적화&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d571704fcdb9d5ed79e67b473e0539ffd1606ce1" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Options that Control Optimization&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;최적화를 제어하는 ​​옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8a4d90f4989adf26f774e757c32cb8c9fd263bdf" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;Preprocessor Options&lt;/a&gt;), with an optional</source>
          <target state="translated">&lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;옵션이있는&lt;/a&gt; (전 처리기 옵션 참조 )</target>
        </trans-unit>
        <trans-unit id="d55bcbae0d9eedb8abddb17abab718a9163fc72b" translate="yes" xml:space="preserve">
          <source>(see below).</source>
          <target state="translated">(아래 참조).</target>
        </trans-unit>
        <trans-unit id="02b70b58cd98cdafb11bf8a667440d592448e3c5" translate="yes" xml:space="preserve">
          <source>(the default), the compiler generates save/restore instructions (except for leaf functions). This is the normal operating mode.</source>
          <target state="translated">(기본값) 컴파일러는 저장 / 복원 명령어를 생성합니다 (리프 기능 제외). 이것이 정상 작동 모드입니다.</target>
        </trans-unit>
        <trans-unit id="af40e6cb84087d46922c5a0ffb4867733e5cd979" translate="yes" xml:space="preserve">
          <source>(the default), this defaults to 11 (GCC 7 compatibility). If another ABI version is explicitly selected, this defaults to 0. For compatibility with GCC versions 3.2 through 4.9, use</source>
          <target state="translated">(기본값), 기본값은 11 (GCC 7 호환성)입니다. 다른 ABI 버전이 명시 적으로 선택된 경우 기본값은 0입니다. GCC 버전 3.2에서 4.9와의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="3ab143adbc1c1395faeaddeb77a75ce40da712c0" translate="yes" xml:space="preserve">
          <source>(the latter implies the former).</source>
          <target state="translated">(후자는 전자를 의미한다).</target>
        </trans-unit>
        <trans-unit id="ca51205aa488fda3fdecbf1f2de750f45ca42e49" translate="yes" xml:space="preserve">
          <source>(when compiling) and</source>
          <target state="translated">(컴파일 할 때)</target>
        </trans-unit>
        <trans-unit id="175effdff8d2479be4f59b65047aecd27e3b8b4c" translate="yes" xml:space="preserve">
          <source>(when linking). See the documentation for those options for more details.</source>
          <target state="translated">(연결할 때). 자세한 내용은 해당 옵션에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20cd831899eee396a27bb94a8bab7bfba3524de0" translate="yes" xml:space="preserve">
          <source>(which it assumes are the names of linker input library archive files) and returns a result containing all the found arguments each prepended by</source>
          <target state="translated">(링커 입력 라이브러리 아카이브 파일의 이름이라고 가정) 각각 앞에 붙인 모든 인수가 포함 된 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e73e5132b6755a2681bf9ea218d8fb5be273c29d" translate="yes" xml:space="preserve">
          <source>(which was the default from GCC 3.4 to 4.9) include:</source>
          <target state="translated">(GCC 3.4에서 4.9까지의 기본값이었습니다)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d29cb22dfbd079dd15c9c9ee6ecc9e019d9f6e2b" translate="yes" xml:space="preserve">
          <source>(which will eventually be the default) or</source>
          <target state="translated">(결국 기본값이 됨) 또는</target>
        </trans-unit>
        <trans-unit id="4bf191089af86ec5288ab306c89094f4d0e110a0" translate="yes" xml:space="preserve">
          <source>(with no level) is the same as</source>
          <target state="translated">(레벨이 없음)은</target>
        </trans-unit>
        <trans-unit id="6b302cd20aa6ae0c1658b03d1a00c7adf9543273" translate="yes" xml:space="preserve">
          <source>(with, as for other standard versions,</source>
          <target state="translated">(다른 표준 버전의 경우</target>
        </trans-unit>
        <trans-unit id="2c929d8cb2c9ae0178197af8deb9b389a6c64e0e" translate="yes" xml:space="preserve">
          <source>(without the version), the version from this option is used for the warning.</source>
          <target state="translated">(버전없이)이 옵션의 버전이 경고에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46c5daf75d33dba3c64b315f704b39ce85f4840a" translate="yes" xml:space="preserve">
          <source>) and FP64A (</source>
          <target state="translated">) 및 FP64A (</target>
        </trans-unit>
        <trans-unit id="563d45d6df052b34a41617f5f0d2d22fbf1bbfc5" translate="yes" xml:space="preserve">
          <source>) and a new value of &lt;code&gt;__STDC_VERSION__&lt;/code&gt;, and so is supported to the same extent as C11.</source>
          <target state="translated">) 및 새 값 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 이므로 C11과 같은 정도로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f02ab141e40e964aecd5ca279400c7bf4b18cea" translate="yes" xml:space="preserve">
          <source>) and interprocedural constant propagation (</source>
          <target state="translated">) 및 절차 간 상수 전파 (</target>
        </trans-unit>
        <trans-unit id="e3fcef972d7d590f262c1cc874b47cd439afbe43" translate="yes" xml:space="preserve">
          <source>) and the ARM processor type for which to tune for performance (as if specified by</source>
          <target state="translated">) 및 성능을 조정할 ARM 프로세서 유형 (</target>
        </trans-unit>
        <trans-unit id="676ea35ac4fbc9be6e247e62c7b74cdadd4458d2" translate="yes" xml:space="preserve">
          <source>) and the debug info format supports it.</source>
          <target state="translated">) 및 디버그 정보 형식이 지원합니다.</target>
        </trans-unit>
        <trans-unit id="959a7bd87d034ba23c5bbe122892dd9a038669b8" translate="yes" xml:space="preserve">
          <source>) and to determine the target processor for which to tune for performance (as if by</source>
          <target state="translated">)와 같이 성능을 조정할 대상 프로세서를 결정</target>
        </trans-unit>
        <trans-unit id="fa1fd71dcd9a799b64dd5ef03786633f6c950ba5" translate="yes" xml:space="preserve">
          <source>) are available:</source>
          <target state="translated">) 사용 가능 :</target>
        </trans-unit>
        <trans-unit id="fff7787a85186574fddbf94130d99816fffebb35" translate="yes" xml:space="preserve">
          <source>) does not allow the use of the &lt;code&gt;icbi&lt;/code&gt; instruction. If the selected code generation option does not allow the use of the &lt;code&gt;icbi&lt;/code&gt; instruction, and</source>
          <target state="translated">)는 &lt;code&gt;icbi&lt;/code&gt; 명령어 사용을 허용하지 않습니다 . 선택한 코드 생성 옵션으로 &lt;code&gt;icbi&lt;/code&gt; 명령을 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="66d488336d845c3e11422345df2d9abe3c655b7d" translate="yes" xml:space="preserve">
          <source>) except that they do not change any feature macros. For example,</source>
          <target state="translated">)을 제외하고는 기능 매크로를 변경하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b94ca66fe63e931f27878f6ec1bb8e784a2fccf3" translate="yes" xml:space="preserve">
          <source>) in size. The default is</source>
          <target state="translated">) 크기입니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="542a755b0afdbf00d8d31e36ba9bc4cd6e84a889" translate="yes" xml:space="preserve">
          <source>) is available:</source>
          <target state="translated">) 사용할 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="a0553b2d9cf564cc761c6f8046ff2ebb991b33b4" translate="yes" xml:space="preserve">
          <source>) is based on the idea that when a local variable shadows another one of incompatible type, it is most likely intentional, not a bug or typo, as shown in the following example:</source>
          <target state="translated">)는 지역 변수가 호환되지 않는 유형의 다른 변수를 가리면 다음 예제와 같이 버그 나 오타가 아닌 의도적입니다.</target>
        </trans-unit>
        <trans-unit id="52d2a999f75dccc509e90809d18c6096a16a88e5" translate="yes" xml:space="preserve">
          <source>) is disabled.</source>
          <target state="translated">)가 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="2378d185f16386ef083035250a3ab4f0f7c4dd3b" translate="yes" xml:space="preserve">
          <source>) is enabled;</source>
          <target state="translated">) 사용 가능;</target>
        </trans-unit>
        <trans-unit id="ff4d48ebc04f7eef9f0f196eb714e862d444f2d8" translate="yes" xml:space="preserve">
          <source>) is not supported on the HP PA machine, unless you use the preliminary GNU tools.</source>
          <target state="translated">예비 GNU 도구를 사용하지 않으면 HP PA 시스템에서)가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1de6a4c82af0028ed53010748154e492d457ccee" translate="yes" xml:space="preserve">
          <source>) on a 64-bit system, the IEEE 128-bit floating point support will also enable the generation of ISA 3.0 IEEE 128-bit floating point instructions. Otherwise, if you do not specify to generate ISA 3.0 instructions or you are targeting a 32-bit big endian system, IEEE 128-bit floating point will be done with software emulation.</source>
          <target state="translated">) 64 비트 시스템에서 IEEE 128 비트 부동 소수점 지원을 통해 ISA 3.0 IEEE 128 비트 부동 소수점 명령어를 생성 할 수도 있습니다. 그렇지 않으면 ISA 3.0 명령어를 생성하도록 지정하지 않거나 32 비트 빅 엔디안 시스템을 대상으로하는 경우 소프트웨어 에뮬레이션을 사용하여 IEEE 128 비트 부동 소수점을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="372ab2853846c6ec09a1a55a70087f0853ac4490" translate="yes" xml:space="preserve">
          <source>) on the linker command line.</source>
          <target state="translated">)를 링커 명령 행에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0f87b9dafadcd5c3f21d76f5c33546bb45833f59" translate="yes" xml:space="preserve">
          <source>) or 32 bits (</source>
          <target state="translated">) 또는 32 비트 (</target>
        </trans-unit>
        <trans-unit id="88214b46b51ead2248a33b5dc3fb87a39aea5aca" translate="yes" xml:space="preserve">
          <source>) or &lt;code&gt;gprof&lt;/code&gt; (for</source>
          <target state="translated">) 또는 &lt;code&gt;gprof&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="92223374d02859d95dcd004e6050947644805c23" translate="yes" xml:space="preserve">
          <source>) or a 16-bit boundary (</source>
          <target state="translated">) 또는 16 비트 경계 (</target>
        </trans-unit>
        <trans-unit id="de09a263a8cf42ae108ce7d225322cce5d807572" translate="yes" xml:space="preserve">
          <source>) or disables (</source>
          <target state="translated">) 또는 비활성화 (</target>
        </trans-unit>
        <trans-unit id="6c992e85f9d035d560971258dac3cd10814fe987" translate="yes" xml:space="preserve">
          <source>) or if callee&amp;rsquo;s register usage cannot be known exactly (this happens on targets that do not expose prologues and epilogues in RTL).</source>
          <target state="translated">) 또는 수신자의 레지스터 사용을 정확하게 알 수없는 경우 (RTL에서 프롤로그 및 에필로그를 노출시키지 않는 대상에서 발생)</target>
        </trans-unit>
        <trans-unit id="665e2cbf7c203c26ee0978de2346b3d2559b1e78" translate="yes" xml:space="preserve">
          <source>) or if-conversion (</source>
          <target state="translated">) 또는 if-conversion (</target>
        </trans-unit>
        <trans-unit id="f0fe0e76237f815ccac9b5973949d2128c4d25ab" translate="yes" xml:space="preserve">
          <source>) or later:</source>
          <target state="translated">) 이상 :</target>
        </trans-unit>
        <trans-unit id="18fb7a4971f7182b1d06e123c98d77026a5601b8" translate="yes" xml:space="preserve">
          <source>) or size (</source>
          <target state="translated">) 또는 크기 (</target>
        </trans-unit>
        <trans-unit id="b61d90f715da7fa5414c6199e285572c09d6de3a" translate="yes" xml:space="preserve">
          <source>) or suffer significant run time performance penalties. On Pentium III, the Streaming SIMD Extension (SSE) data type &lt;code&gt;__m128&lt;/code&gt; may not work properly if it is not 16-byte aligned.</source>
          <target state="translated">) 또는 상당한 런타임 성능 처벌을받습니다. Pentium III에서 SSE (Streaming SIMD Extension) 데이터 형식 &lt;code&gt;__m128&lt;/code&gt; 이 16 바이트로 정렬되지 않으면 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf692b44ef780ecaea543ddcdee9cc9544aea8a5" translate="yes" xml:space="preserve">
          <source>) passes information to the compiler about used and externally visible symbols. When the linker plugin is not available,</source>
          <target state="translated">)는 사용 된 심볼과 외부에서 볼 수있는 심볼에 대한 정보를 컴파일러에 전달합니다. 링커 플러그인을 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="5293f6bbeebb606bbb53bc3a56ae4ac32132f596" translate="yes" xml:space="preserve">
          <source>) plus the other libraries and startup files it needs, in the proper order.</source>
          <target state="translated">) 및 필요한 다른 라이브러리 및 시작 파일을 올바른 순서로 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="e31a598c844d6a572bc984c25f00bb8bb60ffaa7" translate="yes" xml:space="preserve">
          <source>) requires a diagnostic, in some cases where there is undefined behavior at compile-time and in some other cases that do not prevent compilation of programs that are valid according to the standard. This is not equivalent to</source>
          <target state="translated">)에는 컴파일 타임에 정의되지 않은 동작이 있거나 표준에 따라 유효한 프로그램의 컴파일을 방해하지 않는 일부 경우 진단이 필요합니다. 이것은 동등하지 않습니다</target>
        </trans-unit>
        <trans-unit id="606a6881ab81487da34e0ec67cc4569c78f1b735" translate="yes" xml:space="preserve">
          <source>) respectively.</source>
          <target state="translated">).</target>
        </trans-unit>
        <trans-unit id="c651c41b3e1b6730da2636dadc62cb5aca1af853" translate="yes" xml:space="preserve">
          <source>) retain a reference to DWARF Version 2 in their names, but apply to all currently-supported versions of DWARF.</source>
          <target state="translated">)은 이름으로 DWARF 버전 2에 대한 참조를 유지하지만 현재 지원되는 모든 DWARF 버전에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d5778382dc7872cededaaa8c3f62d9e97c5db9" translate="yes" xml:space="preserve">
          <source>) that you don&amp;rsquo;t expect.</source>
          <target state="translated">) 예상하지 못한</target>
        </trans-unit>
        <trans-unit id="096e30d6e1308807356b1a8243bd8e1c2bc7b4bc" translate="yes" xml:space="preserve">
          <source>) the actual recursion depth can be guessed from the probability that function recurses via a given call expression. This parameter limits inlining only to call expressions whose probability exceeds the given threshold (in percents).</source>
          <target state="translated">) 실제 재귀 깊이는 함수가 주어진 호출 표현식을 통해 재발 할 확률로부터 추측 할 수 있습니다. 이 매개 변수는 확률이 주어진 임계 값 (백분율)을 초과하는 호출 표현식에만 인라인을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9cc56b0abbda97d9e58f8de7d0f1f4cdbeb16304" translate="yes" xml:space="preserve">
          <source>) the linker plugin will default to</source>
          <target state="translated">) 링커 플러그인의 기본값은</target>
        </trans-unit>
        <trans-unit id="a788f4704d0fa869be2f93937e1eeb5d09c8018e" translate="yes" xml:space="preserve">
          <source>) the security feature that verifies at run time, for every virtual call, that the vtable pointer through which the call is made is valid for the type of the object, and has not been corrupted or overwritten. If an invalid vtable pointer is detected at run time, an error is reported and execution of the program is immediately halted.</source>
          <target state="translated">) 런타임시, 모든 가상 호출에 대해 호출을 수행하는 vtable 포인터가 오브젝트 유형에 유효하며 손상되거나 겹쳐지지 않았는지 검증하는 보안 기능. 런타임에 유효하지 않은 vtable 포인터가 감지되면 오류가보고되고 프로그램 실행이 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="1574f5807a54ab6b1e028d7e41ef97567b726e97" translate="yes" xml:space="preserve">
          <source>) the use of RX floating-point hardware. The default is enabled for the RX600 series and disabled for the RX200 series.</source>
          <target state="translated">) RX 부동 소수점 하드웨어 사용. RX600 시리즈에서는 기본값이 활성화되어 있고 RX200 시리즈에서는 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21d4e93e91989fd8efa13649a6d484d18b95cd7" translate="yes" xml:space="preserve">
          <source>) together with low-level details about the analysis.</source>
          <target state="translated">)를 분석에 대한 상세 수준과 함께 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1653c12d8093ecbaf09e84a2fda310d1cb9789be" translate="yes" xml:space="preserve">
          <source>) when optimizing at</source>
          <target state="translated">)에서 최적화 할 때</target>
        </trans-unit>
        <trans-unit id="9b7ff0a38348e09a4d3f591bcc731db366000ffd" translate="yes" xml:space="preserve">
          <source>) will diagnose such cases. They are also diagnosed where constant expressions are required.</source>
          <target state="translated">)는 이러한 경우를 진단합니다. 상수 표현이 필요한 곳에서도 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="3d35521355b1a26451fecea1d0fdb8e861ae1a63" translate="yes" xml:space="preserve">
          <source>),</source>
          <target state="translated">),</target>
        </trans-unit>
        <trans-unit id="a44ea070f83a2ea8c508a0d94a9ffe92f0311a7b" translate="yes" xml:space="preserve">
          <source>), GCC emits a diagnostic stating that the option is not recognized. However, if the</source>
          <target state="translated">)에서 GCC는 옵션이 인식되지 않는다는 진단을 내 보냅니다. 그러나</target>
        </trans-unit>
        <trans-unit id="d7b3ec32632cffbf1f22cdfe57cb8374a735a269" translate="yes" xml:space="preserve">
          <source>), a left margin is printed, showing line numbers. This option suppresses this left margin.</source>
          <target state="translated">)에 왼쪽 여백이 인쇄되어 줄 번호가 표시됩니다. 이 옵션은이 왼쪽 여백을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="7416bd69e56d2b6037f51624d54028dd4e475dde" translate="yes" xml:space="preserve">
          <source>), a lot of functions that would otherwise not be considered for inlining by the compiler are investigated. To those functions, a different (more restrictive) limit compared to functions declared inline can be applied.</source>
          <target state="translated">), 그렇지 않으면 컴파일러가 인라인하지 않는 많은 함수가 조사됩니다. 이러한 함수에는 인라인으로 선언 된 함수와 비교하여 다른 (보다 제한적인) 제한을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b95b8c10c47af6db88c3c798a9c8a9008ca4712" translate="yes" xml:space="preserve">
          <source>), and disabled by default when the GCC ABI is in use. If &lt;code&gt;CALLT&lt;/code&gt; instructions are being generated then the C preprocessor symbol &lt;code&gt;__V850_CALLT__&lt;/code&gt; is defined.</source>
          <target state="translated">)로 설정되어 있으며 GCC ABI가 사용 중일 때는 기본적으로 비활성화되어 있습니다. 경우 &lt;code&gt;CALLT&lt;/code&gt; 의 설명은 다음 생성중인 C 전처리 심볼 &lt;code&gt;__V850_CALLT__&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="ffd387280782b84825cc54fe2e5fd6641710f278" translate="yes" xml:space="preserve">
          <source>), and the third is used when compiling C++.</source>
          <target state="translated">), 세 번째는 C ++를 컴파일 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9246fb085de724853f192d16ca8ae6d5505d2a" translate="yes" xml:space="preserve">
          <source>), as programmers are notoriously bad at predicting how their programs actually perform. However, there are applications in which this data is hard to collect.</source>
          <target state="translated">), 프로그래머가 자신의 프로그램이 실제로 어떻게 수행되는지 예측하는 데 악명이 높기 때문입니다. 그러나이 데이터를 수집하기 어려운 응용 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="930d1fcc66826401b7d140d9007bf2954e451307" translate="yes" xml:space="preserve">
          <source>), diagnostics can label ranges of source code with pertinent information, such as the types of expressions:</source>
          <target state="translated">) 진단 프로그램은 표현식 유형과 같은 관련 정보로 소스 코드 범위에 레이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69723fbefd38a710c7dfc1692eb17c0f6c610d10" translate="yes" xml:space="preserve">
          <source>), dump a representation of the control flow graph suitable for viewing with GraphViz to</source>
          <target state="translated">), GraphViz로보기에 적합한 제어 흐름 그래프 표현을 덤프</target>
        </trans-unit>
        <trans-unit id="80b590ade0ab221ac5e4234e6d4d4d05949c0482" translate="yes" xml:space="preserve">
          <source>), generate a __mcount_loc section that contains pointers to each profiling call. This is useful for automatically patching and out calls.</source>
          <target state="translated">)에서 각 프로파일 링 호출에 대한 포인터가 포함 된 __mcount_loc 섹션을 생성하십시오. 이 기능은 자동으로 전화를 패치하고 발신 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bfdc126f96f3450b0ed80efdbbcd69285411c30e" translate="yes" xml:space="preserve">
          <source>), generate the calls to the profiling functions as NOPs. This is useful when they should be patched in later dynamically. This is likely only useful together with</source>
          <target state="translated">)에서 NOP로 프로파일 링 함수에 대한 호출을 생성하십시오. 나중에 동적으로 패치해야 할 때 유용합니다. 이 기능은</target>
        </trans-unit>
        <trans-unit id="bfef96d377a3855452441f358e957e550d74a331" translate="yes" xml:space="preserve">
          <source>), note that floating-point operations are not generated by GCC&amp;rsquo;s auto-vectorization pass unless</source>
          <target state="translated">), 부동 소수점 연산은 GCC의 자동 벡터화 패스에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a08d1f37fdd01ee828e85c675c534b9eb820d73e" translate="yes" xml:space="preserve">
          <source>), or</source>
          <target state="translated">) 또는</target>
        </trans-unit>
        <trans-unit id="365febad52ba5ae4b17e37fcd01c2774f61022fd" translate="yes" xml:space="preserve">
          <source>), or an option for a later standard version, is used.</source>
          <target state="translated">) 또는 이후 표준 버전의 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="70001bcdb1cc025e535a21f20ec6e5a609d02cd6" translate="yes" xml:space="preserve">
          <source>), or for test coverage analysis (</source>
          <target state="translated">) 또는 테스트 범위 분석 (</target>
        </trans-unit>
        <trans-unit id="7f71af6d58f5588e5885753f35af7b050e937149" translate="yes" xml:space="preserve">
          <source>), or separately specify</source>
          <target state="translated">) 또는 별도로 지정</target>
        </trans-unit>
        <trans-unit id="19c045589af9c59852e87b276d0de6f5db11fc66" translate="yes" xml:space="preserve">
          <source>), or the</source>
          <target state="translated">), 아니면 그</target>
        </trans-unit>
        <trans-unit id="c1b08d7982a47273210539150a95f97d162673a4" translate="yes" xml:space="preserve">
          <source>), or to use the &lt;code&gt;gcov&lt;/code&gt; tool.</source>
          <target state="translated">) 또는 &lt;code&gt;gcov&lt;/code&gt; 도구 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="130bb4348d8251fa594f2be0aac3510a4118bbf1" translate="yes" xml:space="preserve">
          <source>), or when an optimization option such as</source>
          <target state="translated">) 또는 최적화 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="a68247a8af7280a00643481b52bb4ec6cbad2c43" translate="yes" xml:space="preserve">
          <source>), prologues and epilogues that have to save or restore a large number of registers are often shortened by using call to a special function in libgcc; this is referred to as a &lt;em&gt;millicode&lt;/em&gt; call. As these calls can pose performance issues, and/or cause linking issues when linking in a nonstandard way, this option is provided to turn on or off millicode call generation.</source>
          <target state="translated">) 많은 수의 레지스터를 저장하거나 복원해야하는 프롤로그 및 에필로그는 종종 libgcc의 특수 함수 호출을 사용하여 단축됩니다. 이것을 &lt;em&gt;밀리 코드&lt;/em&gt; 호출이라고합니다. 이러한 호출은 비표준 방식으로 링크 할 때 성능 문제가 발생하거나 연결 문제가 발생할 수 있으므로 밀리 코드 통화 생성을 설정하거나 해제하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a7ba7846130c7a8e45123ef7d125b09931d28b" translate="yes" xml:space="preserve">
          <source>), put the profiling counter call before the prologue. Note: On x86 architectures the attribute &lt;code&gt;ms_hook_prologue&lt;/code&gt; isn&amp;rsquo;t possible at the moment for</source>
          <target state="translated">), 프로파일 링 카운터 콜을 프롤로그 앞에 두십시오. 참고 : x86 아키텍처에서는 &lt;code&gt;ms_hook_prologue&lt;/code&gt; 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d86644ae2fc8bedabf27beb5cf2316aa496946c" translate="yes" xml:space="preserve">
          <source>), so it is not available everywhere.</source>
          <target state="translated">)이므로 어디에서나 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="775107e56917b7498a4a855146131dd87d5bd5fa" translate="yes" xml:space="preserve">
          <source>), so there is no need to modify the header file</source>
          <target state="translated">)이므로 헤더 파일을 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f69e7a52d8ea74d2d69c66bfa16bc63677452746" translate="yes" xml:space="preserve">
          <source>), the following additional functions are available for both 32-bit and 64-bit targets.</source>
          <target state="translated">), 32 비트 및 64 비트 대상 모두에 대해 다음 추가 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c38b1d1acd0f20276ad32aafe94d807c81016f3" translate="yes" xml:space="preserve">
          <source>), the following builtins are enabled.</source>
          <target state="translated">)에서 다음과 같은 기본 제공 기능이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="d18e82cc2e16d79a4313376dbe885b7ba013e3c7" translate="yes" xml:space="preserve">
          <source>), the functions &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;bcmp&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;dcgettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, &lt;code&gt;dremf&lt;/code&gt;, &lt;code&gt;dreml&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, &lt;code&gt;exp10f&lt;/code&gt;, &lt;code&gt;exp10l&lt;/code&gt;, &lt;code&gt;exp10&lt;/code&gt;, &lt;code&gt;ffsll&lt;/code&gt;, &lt;code&gt;ffsl&lt;/code&gt;, &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;fprintf_unlocked&lt;/code&gt;, &lt;code&gt;fputs_unlocked&lt;/code&gt;, &lt;code&gt;gammaf&lt;/code&gt;, &lt;code&gt;gammal&lt;/code&gt;, &lt;code&gt;gamma&lt;/code&gt;, &lt;code&gt;gammaf_r&lt;/code&gt;, &lt;code&gt;gammal_r&lt;/code&gt;, &lt;code&gt;gamma_r&lt;/code&gt;, &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;isascii&lt;/code&gt;, &lt;code&gt;j0f&lt;/code&gt;, &lt;code&gt;j0l&lt;/code&gt;, &lt;code&gt;j0&lt;/code&gt;, &lt;code&gt;j1f&lt;/code&gt;, &lt;code&gt;j1l&lt;/code&gt;, &lt;code&gt;j1&lt;/code&gt;, &lt;code&gt;jnf&lt;/code&gt;, &lt;code&gt;jnl&lt;/code&gt;, &lt;code&gt;jn&lt;/code&gt;, &lt;code&gt;lgammaf_r&lt;/code&gt;, &lt;code&gt;lgammal_r&lt;/code&gt;, &lt;code&gt;lgamma_r&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;pow10f&lt;/code&gt;, &lt;code&gt;pow10l&lt;/code&gt;, &lt;code&gt;pow10&lt;/code&gt;, &lt;code&gt;printf_unlocked&lt;/code&gt;, &lt;code&gt;rindex&lt;/code&gt;, &lt;code&gt;scalbf&lt;/code&gt;, &lt;code&gt;scalbl&lt;/code&gt;, &lt;code&gt;scalb&lt;/code&gt;, &lt;code&gt;signbit&lt;/code&gt;, &lt;code&gt;signbitf&lt;/code&gt;, &lt;code&gt;signbitl&lt;/code&gt;, &lt;code&gt;signbitd32&lt;/code&gt;, &lt;code&gt;signbitd64&lt;/code&gt;, &lt;code&gt;signbitd128&lt;/code&gt;, &lt;code&gt;significandf&lt;/code&gt;, &lt;code&gt;significandl&lt;/code&gt;, &lt;code&gt;significand&lt;/code&gt;, &lt;code&gt;sincosf&lt;/code&gt;, &lt;code&gt;sincosl&lt;/code&gt;, &lt;code&gt;sincos&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;stpncpy&lt;/code&gt;, &lt;code&gt;strcasecmp&lt;/code&gt;, &lt;code&gt;strdup&lt;/code&gt;, &lt;code&gt;strfmon&lt;/code&gt;, &lt;code&gt;strncasecmp&lt;/code&gt;, &lt;code&gt;strndup&lt;/code&gt;, &lt;code&gt;strnlen&lt;/code&gt;, &lt;code&gt;toascii&lt;/code&gt;, &lt;code&gt;y0f&lt;/code&gt;, &lt;code&gt;y0l&lt;/code&gt;, &lt;code&gt;y0&lt;/code&gt;, &lt;code&gt;y1f&lt;/code&gt;, &lt;code&gt;y1l&lt;/code&gt;, &lt;code&gt;y1&lt;/code&gt;, &lt;code&gt;ynf&lt;/code&gt;, &lt;code&gt;ynl&lt;/code&gt; and &lt;code&gt;yn&lt;/code&gt; may be handled as built-in functions. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;, which may be used even in strict C90 mode.</source>
          <target state="translated">) 기능이 &lt;code&gt;_exit&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; 를 , &lt;code&gt;bcmp&lt;/code&gt; , &lt;code&gt;bzero&lt;/code&gt; , &lt;code&gt;dcgettext&lt;/code&gt; 를 , &lt;code&gt;dgettext&lt;/code&gt; , &lt;code&gt;dremf&lt;/code&gt; , &lt;code&gt;dreml&lt;/code&gt; , &lt;code&gt;drem&lt;/code&gt; , &lt;code&gt;exp10f&lt;/code&gt; , &lt;code&gt;exp10l&lt;/code&gt; , &lt;code&gt;exp10&lt;/code&gt; , &lt;code&gt;ffsll&lt;/code&gt; , &lt;code&gt;ffsl&lt;/code&gt; , &lt;code&gt;ffs&lt;/code&gt; , &lt;code&gt;fprintf_unlocked&lt;/code&gt; , &lt;code&gt;fputs_unlocked&lt;/code&gt; , &lt;code&gt;gammaf&lt;/code&gt; , &lt;code&gt;gammal&lt;/code&gt; , &lt;code&gt;gamma&lt;/code&gt; , &lt;code&gt;gammaf_r&lt;/code&gt; , &lt;code&gt;gammal_r&lt;/code&gt; , &lt;code&gt;gamma_r&lt;/code&gt; , &lt;code&gt;gettext&lt;/code&gt; 에 , &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;isascii&lt;/code&gt; , &lt;code&gt;j0f&lt;/code&gt; , &lt;code&gt;j0l&lt;/code&gt; , &lt;code&gt;j0&lt;/code&gt; , &lt;code&gt;j1f&lt;/code&gt; , &lt;code&gt;j1l&lt;/code&gt; , &lt;code&gt;j1&lt;/code&gt; , &lt;code&gt;jnf&lt;/code&gt; , &lt;code&gt;jnl&lt;/code&gt; , &lt;code&gt;jn&lt;/code&gt; , &lt;code&gt;lgammaf_r&lt;/code&gt; , &lt;code&gt;lgammal_r&lt;/code&gt; , &lt;code&gt;lgamma_r&lt;/code&gt; , &lt;code&gt;mempcpy&lt;/code&gt; , &lt;code&gt;pow10f&lt;/code&gt; , &lt;code&gt;pow10l&lt;/code&gt; , &lt;code&gt;pow10&lt;/code&gt; , &lt;code&gt;printf_unlocked&lt;/code&gt; , &lt;code&gt;rindex&lt;/code&gt; , &lt;code&gt;scalbf&lt;/code&gt; , &lt;code&gt;scalbl&lt;/code&gt; , &lt;code&gt;scalb&lt;/code&gt; , &lt;code&gt;signbit&lt;/code&gt; , &lt;code&gt;signbitf&lt;/code&gt; , &lt;code&gt;signbitl&lt;/code&gt; , &lt;code&gt;signbitd32&lt;/code&gt; , &lt;code&gt;signbitd64&lt;/code&gt; , &lt;code&gt;signbitd128&lt;/code&gt; , &lt;code&gt;significandf&lt;/code&gt; , &lt;code&gt;significandl&lt;/code&gt; , &lt;code&gt;significand&lt;/code&gt; , &lt;code&gt;sincosf&lt;/code&gt; , &lt;code&gt;sincosl&lt;/code&gt; , &lt;code&gt;sincos&lt;/code&gt; , &lt;code&gt;stpcpy&lt;/code&gt; , &lt;code&gt;stpncpy&lt;/code&gt; , &lt;code&gt;strcasecmp&lt;/code&gt; , &lt;code&gt;strdup&lt;/code&gt; , &lt;code&gt;strfmon&lt;/code&gt; , &lt;code&gt;strncasecmp&lt;/code&gt; , &lt;code&gt;strndup&lt;/code&gt; , &lt;code&gt;strnlen&lt;/code&gt; , &lt;code&gt;toascii&lt;/code&gt; , &lt;code&gt;y0f&lt;/code&gt; , &lt;code&gt;y0l&lt;/code&gt; , &lt;code&gt;y0&lt;/code&gt; , &lt;code&gt;y1f&lt;/code&gt; , &lt;code&gt;y1l&lt;/code&gt; , &lt;code&gt;y1&lt;/code&gt; , &lt;code&gt;ynf&lt;/code&gt; , &lt;code&gt;ynl&lt;/code&gt; 및 &lt;code&gt;yn&lt;/code&gt; 은 내장 함수로 처리 될 수 있습니다. 이러한 모든 함수에는 &lt;code&gt;__builtin_&lt;/code&gt; 접두사가있는 해당 버전 이 있으며 엄격한 C90 모드에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a50cce50d0febfb570490b6c070e49f51ddec8b" translate="yes" xml:space="preserve">
          <source>), the object file name consists of the name of the source file with any suffix replaced with object file suffix and with any leading directory parts removed. If there are many included files then the rule is split into several lines using &amp;lsquo;</source>
          <target state="translated">)에서 오브젝트 파일 이름은 소스 파일 이름으로 구성되며 접미 부는 오브젝트 파일 접미 부로 대체되고 선행 디렉토리 부분은 제거됩니다. 포함 된 파일이 많은 경우 규칙은 '</target>
        </trans-unit>
        <trans-unit id="3be8ddc45c8138713e4ff9590a244293505edbcb" translate="yes" xml:space="preserve">
          <source>), this switch only affects the &lt;code&gt;asm&lt;/code&gt; and &lt;code&gt;typeof&lt;/code&gt; keywords, since &lt;code&gt;inline&lt;/code&gt; is a standard keyword in ISO C99.</source>
          <target state="translated">) &lt;code&gt;inline&lt;/code&gt; 이 ISO C99의 표준 키워드 &lt;code&gt;typeof&lt;/code&gt; 스위치는 &lt;code&gt;asm&lt;/code&gt; 및 typeof 키워드 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="ad6667c074281d3be9d0a577eef269311cbfb9cd" translate="yes" xml:space="preserve">
          <source>), this warning is enabled by default and it is made into an error by</source>
          <target state="translated">),이 경고는 기본적으로 활성화되어 있으며 다음과 같은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d41919407ce8f78b6cd89401353e39179fec9ab2" translate="yes" xml:space="preserve">
          <source>).</source>
          <target state="translated">).</target>
        </trans-unit>
        <trans-unit id="a8da6016236d20b9786efd699df04e211b746377" translate="yes" xml:space="preserve">
          <source>). Aligning variables on 32-bit boundaries produces code that runs somewhat faster on processors with 32-bit busses at the expense of more memory.</source>
          <target state="translated">). 32 비트 경계에서 변수를 정렬하면 더 많은 메모리를 희생하면서 32 비트 버스가있는 프로세서에서 다소 빠르게 실행되는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="010b7cdc441046d989a9ea1b15cc97865b1b6636" translate="yes" xml:space="preserve">
          <source>). Each object file&amp;rsquo;s &lt;var&gt;auxname&lt;/var&gt; is generated from the name of the output file, if explicitly specified and it is not the final executable, otherwise it is the basename of the source file. In both cases any suffix is removed (e.g.</source>
          <target state="translated">). 각 오브젝트 파일의 &lt;var&gt;auxname&lt;/var&gt; 은 명시 적으로 지정되고 최종 실행 파일이 아닌 경우 출력 파일 이름에서 생성되며, 그렇지 않으면 소스 파일의 기본 이름입니다. 두 경우 모두 접미사가 제거됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="6634ed39eb6b3c05c70ac15c64888e1587ddc721" translate="yes" xml:space="preserve">
          <source>). Enabled at levels</source>
          <target state="translated">). 레벨에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="015eb4d6e320fdcb40dde6916b75b927e7ad003c" translate="yes" xml:space="preserve">
          <source>). For example, the default is &amp;ldquo;off&amp;rdquo; for</source>
          <target state="translated">). 예를 들어, 기본값은 &quot;off&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c13df8815400fcd95d3934f417b07b1b26f46a2a" translate="yes" xml:space="preserve">
          <source>). If the file that contains a function definition matches with one of &lt;var&gt;file&lt;/var&gt;, then that function is not instrumented. The match is done on substrings: if the &lt;var&gt;file&lt;/var&gt; parameter is a substring of the file name, it is considered to be a match.</source>
          <target state="translated">). 만약 중 하나와 함수 정의 일치가 포함 된 파일 &lt;var&gt;file&lt;/var&gt; 기능이 계측되지 않도록 다음. 일치는 하위 문자열에서 수행됩니다. &lt;var&gt;file&lt;/var&gt; 매개 변수가 파일 이름의 하위 문자열 인 경우 일치하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2f212a70a9e377734872d88e49501c0700d10f3e" translate="yes" xml:space="preserve">
          <source>). Note that while the throughput of the sequence is generally higher than the throughput of the non-reciprocal instruction, the precision of the sequence can be decreased by up to 2 ulp (i.e. the inverse of 1.0 equals 0.99999994) for reciprocal square roots.</source>
          <target state="translated">). 시퀀스의 스루풋은 일반적으로 비가역 명령어의 스루풋보다 높지만, 시퀀스의 정밀도는 역 제곱근에 대해 최대 2ulp (즉 1.0의 역수는 0.99999994)까지 감소 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b164e85e3a5e96ef823e8a23d64cc8f7c10af4b" translate="yes" xml:space="preserve">
          <source>). Only a few systems support this option.</source>
          <target state="translated">). 이 옵션은 일부 시스템에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="55e185f80b2ff3ddce6d7f09c20e1548417dee24" translate="yes" xml:space="preserve">
          <source>). PowerPC with</source>
          <target state="translated">). 와 PowerPC</target>
        </trans-unit>
        <trans-unit id="dfb510fceebf36036dd894fdfbce120124fc5b07" translate="yes" xml:space="preserve">
          <source>). Prefixes are optional, and &amp;lsquo;</source>
          <target state="translated">). 접두사는 선택 사항이며 '</target>
        </trans-unit>
        <trans-unit id="6d10a247e2259eeac52b647017863fe87f5b993d" translate="yes" xml:space="preserve">
          <source>). See &lt;a href=&quot;cross_002dprofiling#Cross_002dprofiling&quot;&gt;Cross-profiling&lt;/a&gt;.</source>
          <target state="translated">). &lt;a href=&quot;cross_002dprofiling#Cross_002dprofiling&quot;&gt;교차 프로파일 링을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acde331edf16a3ec956afda9f9ff904e45d22d8e" translate="yes" xml:space="preserve">
          <source>). Similarly, Objective-C++ compilations may use C++-specific options (e.g.,</source>
          <target state="translated">). 마찬가지로 Objective-C ++ 컴파일은 C ++ 관련 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="e87d6a9687ee8b259d715c98478384173b51aa0b" translate="yes" xml:space="preserve">
          <source>). The FPXX extension mandates that all code must execute correctly when run using 32-bit or 64-bit registers. The code can be interlinked with either FP32 or FP64, but not both. The FP64A extension is similar to the FP64 extension but forbids the use of odd-numbered single-precision registers. This can be used in conjunction with the &lt;code&gt;FRE&lt;/code&gt; mode of FPUs in MIPS32R5 processors and allows both FP32 and FP64A code to interlink and run in the same process without changing FPU modes.</source>
          <target state="translated">). FPXX 확장은 32 비트 또는 64 비트 레지스터를 사용하여 실행할 때 모든 코드가 올바르게 실행되어야합니다. 코드는 FP32 또는 FP64와 상호 연결할 수 있지만 둘다는 아닙니다. FP64A 확장은 FP64 확장과 유사하지만 홀수의 단 정밀도 레지스터 사용을 금지합니다. 이것은 MIPS32R5 프로세서에서 FPU 의 &lt;code&gt;FRE&lt;/code&gt; 모드 와 함께 사용될 수 있으며 FP32 및 FP64A 코드가 FPU 모드를 변경하지 않고 동일한 프로세스에서 상호 연결되고 실행될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="69623fc03f16d40bf923fc859f6aee6a12d3da3b" translate="yes" xml:space="preserve">
          <source>). The ISO C99 keyword &lt;code&gt;restrict&lt;/code&gt; is only available when</source>
          <target state="translated">). ISO C99 키워드 &lt;code&gt;restrict&lt;/code&gt; 은 다음 경우에만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="58c4c654ef7ee136377ef2cafd1f5c6d8c816f58" translate="yes" xml:space="preserve">
          <source>). The number of available registers reserved for some other purposes is given by this parameter. Default of the parameter is the best found from numerous experiments.</source>
          <target state="translated">). 다른 목적으로 예약 된 사용 가능한 레지스터 수는이 매개 변수에 의해 제공됩니다. 매개 변수의 기본값은 수많은 실험에서 가장 잘 나타납니다.</target>
        </trans-unit>
        <trans-unit id="13df10237921e86399697b2a5237e0144f1e89b4" translate="yes" xml:space="preserve">
          <source>). These heuristics are based on the control flow graph. If some branch probabilities are specified by &lt;code&gt;__builtin_expect&lt;/code&gt;, then the heuristics are used to guess branch probabilities for the rest of the control flow graph, taking the &lt;code&gt;__builtin_expect&lt;/code&gt; info into account. The interactions between the heuristics and &lt;code&gt;__builtin_expect&lt;/code&gt; can be complex, and in some cases, it may be useful to disable the heuristics so that the effects of &lt;code&gt;__builtin_expect&lt;/code&gt; are easier to understand.</source>
          <target state="translated">). 이러한 휴리스틱은 제어 흐름 그래프를 기반으로합니다. 일부 분기 확률이 &lt;code&gt;__builtin_expect&lt;/code&gt; 로 지정 되면 휴리스틱은 &lt;code&gt;__builtin_expect&lt;/code&gt; 정보를 고려 하여 나머지 제어 플로우 그래프의 분기 확률을 추측하는 데 사용 됩니다. 휴리스틱과 &lt;code&gt;__builtin_expect&lt;/code&gt; 간의 상호 작용은 복잡 할 수 있으며 경우에 따라 &lt;code&gt;__builtin_expect&lt;/code&gt; 의 영향 을 이해하기 쉽게 휴리스틱을 비활성화하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2023f757a7ebb820a975281ad23d01e574d8eb79" translate="yes" xml:space="preserve">
          <source>). These string functions are described separately in order to group the descriptions closer to the function prototypes:</source>
          <target state="translated">). 이러한 문자열 함수는 설명을 함수 프로토 타입에 더 가깝게 그룹화하기 위해 별도로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="751af366ba575d9d108cd1b4000d9ad97eaf52b1" translate="yes" xml:space="preserve">
          <source>). This flag is enabled by default at</source>
          <target state="translated">). 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="389d320cf2fd3c5618d226a643e286a8173a0850" translate="yes" xml:space="preserve">
          <source>). This option implies that the sign of a zero result isn&amp;rsquo;t significant.</source>
          <target state="translated">). 이 옵션은 결과 0의 부호가 중요하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="40cd47fb3faf85196691543d50eeceb26496714f" translate="yes" xml:space="preserve">
          <source>). Valid values are 0 (no compression) to 9 (maximum compression). Values outside this range are clamped to either 0 or 9. If the option is not given, a default balanced compression setting is used.</source>
          <target state="translated">). 유효한 값은 0 (압축 없음)에서 9 (최대 압축)입니다. 이 범위를 벗어난 값은 0 또는 9로 고정됩니다. 옵션을 제공하지 않으면 기본 균형 압축 설정이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e275b6410662c14eec9fb78d9ba464e2a4ade618" translate="yes" xml:space="preserve">
          <source>). Where this option is used in conjunction with</source>
          <target state="translated">). 이 옵션이 함께 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="df74c471c52df8eca98a9d8f78604ccd98630755" translate="yes" xml:space="preserve">
          <source>). You must use this option when compiling the source files you want data about, and you must also use it when linking.</source>
          <target state="translated">). 데이터를 원하는 소스 파일을 컴파일 할 때이 옵션을 사용해야하며 링크 할 때도 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="67f69ef0c07d30c0476bd886f60193097cb47f3e" translate="yes" xml:space="preserve">
          <source>):</source>
          <target state="translated">):</target>
        </trans-unit>
        <trans-unit id="59f6dde452eff2a7dd073297be960fa570d00ed5" translate="yes" xml:space="preserve">
          <source>): Should have very few false positives and few false negatives. Slightly slower than levels 1 or 2 when optimization is enabled. Takes care of the common pun+dereference pattern in the front end: &lt;code&gt;*(int*)&amp;amp;some_float&lt;/code&gt;. If optimization is enabled, it also runs in the back end, where it deals with multiple statement cases using flow-sensitive points-to information. Only warns when the converted pointer is dereferenced. Does not warn about incomplete types.</source>
          <target state="translated">) : 오 탐지 및 오 탐지가 거의 없어야합니다. 최적화가 활성화 된 경우 레벨 1 또는 2보다 약간 느립니다. 프론트 엔드에서 일반적인 pun + dereference 패턴을 처리합니다 : &lt;code&gt;*(int*)&amp;amp;some_float&lt;/code&gt; . 최적화가 활성화 된 경우 백엔드에서도 실행되며 흐름에 민감한 포인트 투 포인트 정보를 사용하여 여러 명령문 사례를 처리합니다. 변환 된 포인터가 역 참조 될 때만 경고합니다. 불완전한 유형에 대해서는 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68b94bb7c80d730c9c375c35b16cf1f64733269c" translate="yes" xml:space="preserve">
          <source>*-*-linux-*android*</source>
          <target state="translated">*-*-linux-*android*</target>
        </trans-unit>
        <trans-unit id="e2b642adbe68e3ea2f08e73036fb686d4e5ecf65" translate="yes" xml:space="preserve">
          <source>*-*-linux-*musl*</source>
          <target state="translated">*-*-linux-*musl*</target>
        </trans-unit>
        <trans-unit id="7d44bb0c460c86f6ed20b427ab87b20e89c94940" translate="yes" xml:space="preserve">
          <source>*-*-linux-*uclibc*</source>
          <target state="translated">*-*-linux-*uclibc*</target>
        </trans-unit>
        <trans-unit id="feb21874a106e7fdaf91fadac43af22b0bea36ab" translate="yes" xml:space="preserve">
          <source>+&lt;var&gt;extension&lt;/var&gt;</source>
          <target state="translated">+&lt;var&gt;extension&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="dad15bd181e6b2d074037dd769cb892a10dcffa3" translate="yes" xml:space="preserve">
          <source>+Accept TypeMismatch</source>
          <target state="translated">+ 유형 불일치 수락</target>
        </trans-unit>
        <trans-unit id="0245508ac3119cf85af276774b536b3c6eb57300" translate="yes" xml:space="preserve">
          <source>+crc</source>
          <target state="translated">+crc</target>
        </trans-unit>
        <trans-unit id="172554656681a361758276db1e3c43b8560fd73f" translate="yes" xml:space="preserve">
          <source>+crypto</source>
          <target state="translated">+crypto</target>
        </trans-unit>
        <trans-unit id="f593a9cfed56aa8c5b2310dadc6602a92650e09b" translate="yes" xml:space="preserve">
          <source>+dotprod</source>
          <target state="translated">+dotprod</target>
        </trans-unit>
        <trans-unit id="c8958e48ef48898eea0aeee1b68eea46b1f26e18" translate="yes" xml:space="preserve">
          <source>+dsp</source>
          <target state="translated">+dsp</target>
        </trans-unit>
        <trans-unit id="9b8ca1a7ee75f7f450c6bed427a6d3f35d9847c6" translate="yes" xml:space="preserve">
          <source>+fp</source>
          <target state="translated">+fp</target>
        </trans-unit>
        <trans-unit id="12e90b41b5bbb85590517841a4eb99cb4b8a9251" translate="yes" xml:space="preserve">
          <source>+fp.dp</source>
          <target state="translated">+fp.dp</target>
        </trans-unit>
        <trans-unit id="61e1348f2cad78b911fccf2797471ad0d18e2b02" translate="yes" xml:space="preserve">
          <source>+fp.sp</source>
          <target state="translated">+fp.sp</target>
        </trans-unit>
        <trans-unit id="3c19a7766116f6a5d109b2fea2da2b1d277f1660" translate="yes" xml:space="preserve">
          <source>+fp16</source>
          <target state="translated">+fp16</target>
        </trans-unit>
        <trans-unit id="e36321f6f8d57d187d3bc885adca3f8e1fec74a2" translate="yes" xml:space="preserve">
          <source>+fp16fml</source>
          <target state="translated">+fp16fml</target>
        </trans-unit>
        <trans-unit id="9a28b8bd1ff670d2e1d8a6d041e8af642964b47f" translate="yes" xml:space="preserve">
          <source>+fpv5</source>
          <target state="translated">+fpv5</target>
        </trans-unit>
        <trans-unit id="6ce605d1bb51ed3fd5a75aed8a1d4c5fce2fbd02" translate="yes" xml:space="preserve">
          <source>+idiv</source>
          <target state="translated">+idiv</target>
        </trans-unit>
        <trans-unit id="298d552ef880bc40f53842de04e0129e8d4cbb7f" translate="yes" xml:space="preserve">
          <source>+k</source>
          <target state="translated">+k</target>
        </trans-unit>
        <trans-unit id="6bb6aad86a880aa66a62f4e67215e2922bf4ed3b" translate="yes" xml:space="preserve">
          <source>+lse</source>
          <target state="translated">+lse</target>
        </trans-unit>
        <trans-unit id="d3da1bfe2d64d68808b0b119209078764008b84e" translate="yes" xml:space="preserve">
          <source>+mp</source>
          <target state="translated">+mp</target>
        </trans-unit>
        <trans-unit id="c660acf5e4ec641d8c613d3f784064715b71970f" translate="yes" xml:space="preserve">
          <source>+neon</source>
          <target state="translated">+neon</target>
        </trans-unit>
        <trans-unit id="8aaddfb72d070d6159cd823fe6182666f17c4053" translate="yes" xml:space="preserve">
          <source>+neon-fp16</source>
          <target state="translated">+neon-fp16</target>
        </trans-unit>
        <trans-unit id="435f84a487ef70561af83eda3e1d7dd3d2436c1c" translate="yes" xml:space="preserve">
          <source>+neon-vfpv3</source>
          <target state="translated">+neon-vfpv3</target>
        </trans-unit>
        <trans-unit id="0ac1405d972e784cdc766f54e29dbf5ab415cbc9" translate="yes" xml:space="preserve">
          <source>+neon-vfpv4</source>
          <target state="translated">+neon-vfpv4</target>
        </trans-unit>
        <trans-unit id="718b50d5dae644e3a124de95caf9ccb46a386417" translate="yes" xml:space="preserve">
          <source>+no&amp;hellip;</source>
          <target state="translated">+no&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="ce8806c0fb02e176c7399646baa9a9c06a0ab272" translate="yes" xml:space="preserve">
          <source>+nocrypto</source>
          <target state="translated">+nocrypto</target>
        </trans-unit>
        <trans-unit id="c75685c50bbed60e49ef2d3d9ba5984a9087c460" translate="yes" xml:space="preserve">
          <source>+nodsp</source>
          <target state="translated">+nodsp</target>
        </trans-unit>
        <trans-unit id="bdad84fda97226b66790281c1f74f43e25c5dc2a" translate="yes" xml:space="preserve">
          <source>+nofp</source>
          <target state="translated">+nofp</target>
        </trans-unit>
        <trans-unit id="32d14ccb6dff53c000b7d0f3c1e570e199920277" translate="yes" xml:space="preserve">
          <source>+nofp.dp</source>
          <target state="translated">+nofp.dp</target>
        </trans-unit>
        <trans-unit id="70443bdbf953fd7737440bd1233875efade5e298" translate="yes" xml:space="preserve">
          <source>+noidiv</source>
          <target state="translated">+noidiv</target>
        </trans-unit>
        <trans-unit id="a12c1141d2021a4ae5103e34f0cb2e216132188d" translate="yes" xml:space="preserve">
          <source>+nosimd</source>
          <target state="translated">+nosimd</target>
        </trans-unit>
        <trans-unit id="4563e8723e89439d475e61672e05fb7dae35dfaf" translate="yes" xml:space="preserve">
          <source>+predres</source>
          <target state="translated">+predres</target>
        </trans-unit>
        <trans-unit id="612586060d4d1d6ca16cb6e8342ccd8cd466f161" translate="yes" xml:space="preserve">
          <source>+rdma</source>
          <target state="translated">+rdma</target>
        </trans-unit>
        <trans-unit id="50c84004301c1955521d1c5085a4e86bef9ad37a" translate="yes" xml:space="preserve">
          <source>+sb</source>
          <target state="translated">+sb</target>
        </trans-unit>
        <trans-unit id="523966f68f6b5229e9feb691969161ec915c6cc9" translate="yes" xml:space="preserve">
          <source>+sec</source>
          <target state="translated">+sec</target>
        </trans-unit>
        <trans-unit id="572761324c6cd16274d84a93b069f3f7bc8d622d" translate="yes" xml:space="preserve">
          <source>+simd</source>
          <target state="translated">+simd</target>
        </trans-unit>
        <trans-unit id="80493528a9034722885b8e9132606dd4336778f5" translate="yes" xml:space="preserve">
          <source>+vfpv2</source>
          <target state="translated">+vfpv2</target>
        </trans-unit>
        <trans-unit id="5e4ee72860cab166418a73e306a0921f5e6d4794" translate="yes" xml:space="preserve">
          <source>+vfpv3</source>
          <target state="translated">+vfpv3</target>
        </trans-unit>
        <trans-unit id="96f6116b06a306c4fe8edf91f7e6e981c085f418" translate="yes" xml:space="preserve">
          <source>+vfpv3-d16</source>
          <target state="translated">+vfpv3-d16</target>
        </trans-unit>
        <trans-unit id="efba751c5beb6a30957dc58f177e360fdd017763" translate="yes" xml:space="preserve">
          <source>+vfpv3-d16-fp16</source>
          <target state="translated">+vfpv3-d16-fp16</target>
        </trans-unit>
        <trans-unit id="2a14509c282a0dde2ff082ee3afda5e8f9d14e09" translate="yes" xml:space="preserve">
          <source>+vfpv3-fp16</source>
          <target state="translated">+vfpv3-fp16</target>
        </trans-unit>
        <trans-unit id="9b899bf3010c596d9deefcc3943f2e83ea96543a" translate="yes" xml:space="preserve">
          <source>+vfpv3xd</source>
          <target state="translated">+vfpv3xd</target>
        </trans-unit>
        <trans-unit id="e6dd5253fa77b609bac67127de01e8db18c70caa" translate="yes" xml:space="preserve">
          <source>+vfpv3xd-d16-fp16</source>
          <target state="translated">+vfpv3xd-d16-fp16</target>
        </trans-unit>
        <trans-unit id="1c9a97c629a2f14166d7a967313c8b311aaf24b4" translate="yes" xml:space="preserve">
          <source>+vfpv4</source>
          <target state="translated">+vfpv4</target>
        </trans-unit>
        <trans-unit id="f0753fa13c2da206656b61cc9e300da99d614fad" translate="yes" xml:space="preserve">
          <source>+vfpv4-d16</source>
          <target state="translated">+vfpv4-d16</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="0ed174b8649b3795e9bab6e28051e111ece3d5a1" translate="yes" xml:space="preserve">
          <source>, &amp;hellip;), and outputting DWARF 2 debug information at the normal level.</source>
          <target state="translated">,&amp;hellip;) 및 정상 수준에서 DWARF 2 디버그 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1e892a0963fbddbf57a2e50e77e246f310118c85" translate="yes" xml:space="preserve">
          <source>, &amp;hellip;), debugging information (</source>
          <target state="translated">,&amp;hellip;), 디버깅 정보 (</target>
        </trans-unit>
        <trans-unit id="9ce3d91211464125b1a2c5c681940a8dbbed2997" translate="yes" xml:space="preserve">
          <source>, &amp;hellip;).</source>
          <target state="translated">,&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="3637dc66fe00abd3e693687e7b9b0ff7e487e998" translate="yes" xml:space="preserve">
          <source>, ...).</source>
          <target state="translated">...).</target>
        </trans-unit>
        <trans-unit id="e8373b7b9cf04295923fb7dd353f8cd016c13806" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;dbg_cnt(dce)&lt;/code&gt; returns true only for third and fourth invocation. For &lt;code&gt;dbg_cnt(tail_call)&lt;/code&gt; true is returned for first 10 invocations.</source>
          <target state="translated">, &lt;code&gt;dbg_cnt(dce)&lt;/code&gt; 만 세 번째와 네 번째 호출에 대해 true를 반환합니다. 들어 &lt;code&gt;dbg_cnt(tail_call)&lt;/code&gt; 사실은 처음 10 호출에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d0cb298b65dc1dd5a8ad63030abc502d65e4a5" translate="yes" xml:space="preserve">
          <source>, &lt;var&gt;charset&lt;/var&gt; can be any encoding supported by the system&amp;rsquo;s &lt;code&gt;iconv&lt;/code&gt; library routine; however, you will have problems with encodings that do not fit exactly in &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">, &lt;var&gt;charset&lt;/var&gt; 시스템의 지원하는 모든 인코딩 할 수 &lt;code&gt;iconv&lt;/code&gt; 라이브러리 루틴; 그러나 &lt;code&gt;wchar_t&lt;/code&gt; 에 정확히 맞지 않는 인코딩에는 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dacad0f81d1e260f88c4393b4848193fe16ac2b7" translate="yes" xml:space="preserve">
          <source>, &lt;var&gt;max_size&lt;/var&gt; specifies the max byte size with which inline algorithm &lt;var&gt;alg&lt;/var&gt; is allowed. For the last triplet, the &lt;var&gt;max_size&lt;/var&gt; must be &lt;code&gt;-1&lt;/code&gt;. The &lt;var&gt;max_size&lt;/var&gt; of the triplets in the list must be specified in increasing order. The minimal byte size for &lt;var&gt;alg&lt;/var&gt; is &lt;code&gt;0&lt;/code&gt; for the first triplet and &lt;code&gt;&lt;var&gt;max_size&lt;/var&gt; + 1&lt;/code&gt; of the preceding range.</source>
          <target state="translated">, &lt;var&gt;max_size&lt;/var&gt; 지정 최대 바이트 크기되는 인라인 알고리즘 &lt;var&gt;alg&lt;/var&gt; 허용된다. 마지막 삼중 항의 경우 &lt;var&gt;max_size&lt;/var&gt; 는 &lt;code&gt;-1&lt;/code&gt; 이어야합니다 . 목록에서 삼중 항의 &lt;var&gt;max_size&lt;/var&gt; 는 증가하는 순서로 지정해야합니다. 최소한의 바이트 크기 &lt;var&gt;alg&lt;/var&gt; 인 &lt;code&gt;0&lt;/code&gt; 제 트리플렛과 대 &lt;code&gt;&lt;var&gt;max_size&lt;/var&gt; + 1&lt;/code&gt; 항 범위.</target>
        </trans-unit>
        <trans-unit id="f9690121c5628f2c0341ffa6132d72efc83193d9" translate="yes" xml:space="preserve">
          <source>, GCC assumes that doubles have 8-byte alignment only if they are contained in another type, or if they have an absolute address. Otherwise, it assumes they have 4-byte alignment. Specifying this option avoids some rare compatibility problems with code generated by other compilers. It is not the default because it results in a performance loss, especially for floating-point code.</source>
          <target state="translated">GCC는 더블이 다른 유형에 포함되어 있거나 절대 주소가있는 경우에만 8 바이트 정렬을 가정합니다. 그렇지 않으면 4 바이트 정렬을 가정합니다. 이 옵션을 지정하면 다른 컴파일러에서 생성 한 코드와의 드문 호환성 문제가 발생하지 않습니다. 특히 부동 소수점 코드의 경우 성능이 저하되므로 기본값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="91d079c553ba54a17781d7096ca0de1c9399ce98" translate="yes" xml:space="preserve">
          <source>, GCC assumes that the stack pointer, and frame pointer if present, are offset by -2047 which must be added back when making stack frame references. This is the default in 64-bit mode. Otherwise, assume no such offset is present.</source>
          <target state="translated">GCC는 스택 포인터와 존재하는 경우 프레임 포인터가 스택 프레임 참조를 만들 때 다시 추가해야하는 -2047만큼 오프셋되어 있다고 가정합니다. 64 비트 모드의 기본값입니다. 그렇지 않으면, 그러한 오프셋이 존재하지 않는다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="32d107fd8d29cc4e25c76f6bc2b8616923401802" translate="yes" xml:space="preserve">
          <source>, GCC defaults to whichever convention is standard for the target. If there is no standard convention, GCC defaults to</source>
          <target state="translated">, GCC는 기본적으로 어떤 규칙이 대상에 대한 표준으로 설정됩니다. 표준 규칙이없는 경우 GCC는 기본적으로</target>
        </trans-unit>
        <trans-unit id="a2827008d6317586583dcd9e0510d8d39bdf6108" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the GR6 variant of the Visium architecture. The only difference from GR5 code is that the compiler will generate block move instructions.</source>
          <target state="translated">GCC는 Visium 아키텍처의 GR6 변형에 대한 코드를 생성합니다. GR5 코드와의 유일한 차이점은 컴파일러가 블록 이동 명령을 생성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="682c348ce24eeeb97abc0387035df3b607a2756f" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the SPARC-V8+ ABI. The difference from the V8 ABI is that the global and out registers are considered 64 bits wide. This is enabled by default on Solaris in 32-bit mode for all SPARC-V9 processors.</source>
          <target state="translated">GCC는 SPARC-V8 + ABI 용 코드를 생성합니다. V8 ABI와의 차이점은 전역 및 출력 레지스터가 64 비트 폭으로 간주된다는 것입니다. 모든 SPARC-V9 프로세서에 대해 32 비트 모드의 Solaris에서 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5be22faf79e798733855688a8ebf060dd61b85ec" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the SPARClet variant of the SPARC architecture. This adds the integer multiply, multiply/accumulate, integer divide step and scan (&lt;code&gt;ffs&lt;/code&gt;) instructions which exist in SPARClet but not in SPARC-V7. With</source>
          <target state="translated">GCC는 SPARC 아키텍처의 SPARClet 변형에 대한 코드를 생성합니다. 이는 SPARClet에는 있지만 SPARC-V7에는없는 정수 곱하기, 곱하기 / 누적, 정수 나누기 단계 및 스캔 ( &lt;code&gt;ffs&lt;/code&gt; ) 명령어를 추가합니다. 와</target>
        </trans-unit>
        <trans-unit id="246eb4b1205aee50122a8441dd133501e413f7d4" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the SPARClite variant of the SPARC architecture. This adds the integer multiply, integer divide step and scan (&lt;code&gt;ffs&lt;/code&gt;) instructions which exist in SPARClite but not in SPARC-V7. With</source>
          <target state="translated">GCC는 SPARC 아키텍처의 SPARClite 변형에 대한 코드를 생성합니다. SPARC-V7에는 없지만 SPARClite에는 존재 하는 정수 곱하기, 정수 나누기 단계 및 스캔 ( &lt;code&gt;ffs&lt;/code&gt; ) 명령어가 추가됩니다. 와</target>
        </trans-unit>
        <trans-unit id="5ea3b70bf876bbac6bd786d282b058e0a48e593e" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the V8 variant of the SPARC architecture. The only difference from V7 code is that the compiler emits the integer multiply and integer divide instructions which exist in SPARC-V8 but not in SPARC-V7. With</source>
          <target state="translated">GCC는 SPARC 아키텍처의 V8 변형에 대한 코드를 생성합니다. V7 코드와의 유일한 차이점은 컴파일러가 SPARC-V8에는 있지만 SPARC-V7에는없는 정수 곱하기 및 정수 나누기 명령어를 내 보냅니다. 와</target>
        </trans-unit>
        <trans-unit id="d35cc98b9577afb980907076a54d84b7ee83c49b" translate="yes" xml:space="preserve">
          <source>, GCC generates code for the V9 variant of the SPARC architecture. This adds 64-bit integer and floating-point move instructions, 3 additional floating-point condition code registers and conditional move instructions. With</source>
          <target state="translated">GCC는 SPARC 아키텍처의 V9 변형에 대한 코드를 생성합니다. 64 비트 정수 및 부동 소수점 이동 명령, 3 개의 추가 부동 소수점 조건 코드 레지스터 및 조건부 이동 명령이 추가됩니다. 와</target>
        </trans-unit>
        <trans-unit id="6f52fa8335df2d3bb842c72b269dbd31476ebe55" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the Floating-point Multiply Single to Double (FsMULd) instruction. The default is</source>
          <target state="translated">GCC는 부동 소수점 곱하기 단일 대 이중 (FsMULd) 명령을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="1475f8fe9a2a4d3740626e73d0883412752df34d" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the UltraSPARC Compare-and-Branch-on-Condition instructions. The default is</source>
          <target state="translated">GCC는 UltraSPARC 비교 및 ​​분기시 조건 명령어를 활용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="a1d737bb2dcd98336bc50c965bd13e7436a7dd37" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the UltraSPARC Fused Multiply-Add Floating-point instructions. The default is</source>
          <target state="translated">, GCC는 UltraSPARC 융합 다중 추가 부동 소수점 명령어를 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="d23766f73710826fb3194882a59b3abf6466a524" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the UltraSPARC Population Count instruction. The default is</source>
          <target state="translated">GCC는 UltraSPARC Population Count 명령을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="ef6c463793daa79795e5bac108508d4c88d9bbdb" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the UltraSPARC Subtract-Extended-with-Carry instruction. The default is</source>
          <target state="translated">, GCC는 UltraSPARC 빼기 확장 포함 명령을 활용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="3ca4c46815c6d5d35fbb9551d58365f816e41479" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of the UltraSPARC Visual Instruction Set extensions. The default is</source>
          <target state="translated">GCC는 UltraSPARC Visual Instruction Set 확장을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="cd5db5aaa75f0186e12c2a3c5260dce368624e0c" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of version 2.0 of the UltraSPARC Visual Instruction Set extensions. The default is</source>
          <target state="translated">GCC는 UltraSPARC Visual Instruction Set 확장 버전 2.0을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="2806fca697379e7dde9c87801608b121305c7d2b" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of version 3.0 of the UltraSPARC Visual Instruction Set extensions. The default is</source>
          <target state="translated">GCC는 UltraSPARC Visual Instruction Set 확장 버전 3.0을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="ba290b8a2744f98c0c8c96a2dd45eb3cf029cb39" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of version 4.0 of the UltraSPARC Visual Instruction Set extensions, plus the additional VIS instructions introduced in the Oracle SPARC Architecture 2017. The default is</source>
          <target state="translated">GCC는 UltraSPARC Visual Instruction Set 확장 버전 4.0과 Oracle SPARC Architecture 2017에 도입 된 추가 VIS 명령어를 이용하는 코드를 생성합니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="18714e7f456c9768e056f11bedffefc81537d103" translate="yes" xml:space="preserve">
          <source>, GCC generates code that takes advantage of version 4.0 of the UltraSPARC Visual Instruction Set extensions. The default is</source>
          <target state="translated">GCC는 버전 4.0 UltraSPARC Visual Instruction Set 확장을 이용하는 코드를 생성합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="18afbe646df06ef482b90a4ea8101ba75a14fb36" translate="yes" xml:space="preserve">
          <source>, GCC links your program against startup code that assumes a C99-style interface to &lt;code&gt;main&lt;/code&gt;, including a local copy of &lt;code&gt;argv&lt;/code&gt; strings.</source>
          <target state="translated">, GCC 는 &lt;code&gt;argv&lt;/code&gt; 문자열 의 로컬 사본을 포함하여 C99 스타일의 인터페이스를 가정하는 시작 코드와 프로그램을 &lt;code&gt;main&lt;/code&gt; 에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="4b0d7b4c7ae6e8aba0c9f72af55f5d304c58fb90" translate="yes" xml:space="preserve">
          <source>, GCC puts a &amp;lsquo;</source>
          <target state="translated">, GCC는 '</target>
        </trans-unit>
        <trans-unit id="dbb40763e80347d1210476d472706d4ce77f51a6" translate="yes" xml:space="preserve">
          <source>, GCC searches</source>
          <target state="translated">, GCC 검색</target>
        </trans-unit>
        <trans-unit id="ae1262a6470e2ff7634d806e9ee5903d47af8ad6" translate="yes" xml:space="preserve">
          <source>, GOT offsets are computed with 32 bits. With a &amp;lsquo;</source>
          <target state="translated">GOT 오프셋은 32 비트로 계산됩니다. '</target>
        </trans-unit>
        <trans-unit id="398ba4aaa11c3bac9f0e3777574e92dc704d4bf0" translate="yes" xml:space="preserve">
          <source>, a library of internal subroutines which GCC uses to overcome shortcomings of particular machines, or special needs for some languages. (See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Interface.html#Interface&quot;&gt;Interfacing to GCC Output&lt;/a&gt; in GNU Compiler Collection (GCC) Internals, for more discussion of</source>
          <target state="translated">GCC가 특정 기계의 단점 또는 일부 언어의 특별한 요구를 극복하기 위해 사용하는 내부 서브 루틴 라이브러리. ( GNU (GNU Compiler Collection) 내부의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Interface.html#Interface&quot;&gt;GCC 출력 인터페이스에&lt;/a&gt; 대한 자세한 내용은 GCC 출력 내부 인터페이스 참조 )</target>
        </trans-unit>
        <trans-unit id="58f77b34e40291c68cd5f9eb195333d97f9c0b55" translate="yes" xml:space="preserve">
          <source>, a precompiled header file in</source>
          <target state="translated">미리 컴파일 된 헤더 파일</target>
        </trans-unit>
        <trans-unit id="902dbfb563932162e68ce134dadacceccbcb8994" translate="yes" xml:space="preserve">
          <source>, allowing at most a 16-bit offset for pc-relative addressing.</source>
          <target state="translated">pc 기준 주소 지정을 위해 최대 16 비트 오프셋을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ee68baaad88f470b7b533567d25dcdc3a379ac30" translate="yes" xml:space="preserve">
          <source>, allowing the exception to be raised. This option does nothing unless</source>
          <target state="translated">예외가 발생할 수 있습니다. 이 옵션은 그렇지 않으면 아무것도하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6a9e05e836489ac9950ec8969e19d268991d8395" translate="yes" xml:space="preserve">
          <source>, along with options to silence warnings, and omitting other options that would cause the compiler to produce output to files or to standard output as a side effect. Dump files and preserved temporary files are renamed so as to contain the &lt;code&gt;.gk&lt;/code&gt; additional extension during the second compilation, to avoid overwriting those generated by the first.</source>
          <target state="translated">, 경고를 끄는 옵션과 함께 컴파일러가 파일 또는 표준 출력으로 부작용을 일으키는 다른 옵션을 생략합니다. 덤프 파일과 보존 된 임시 파일은 첫 번째 컴파일에서 생성 된 파일을 덮어 쓰지 않도록 두 번째 컴파일 중에 &lt;code&gt;.gk&lt;/code&gt; 추가 확장자 를 포함하도록 이름이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7934c6ea7ba618a96b99457fbe7b3b543c732ec" translate="yes" xml:space="preserve">
          <source>, also deprecate if the class has a user-provided destructor.</source>
          <target state="translated">클래스에 사용자 제공 소멸자가있는 경우 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f80346a34a1c0832eaef10e9fb85d47cd2333b2" translate="yes" xml:space="preserve">
          <source>, an accompanying</source>
          <target state="translated">, 동반</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="f426f972d9e2e410d1cd265b7d8eb71579d193d3" translate="yes" xml:space="preserve">
          <source>, and &amp;lsquo;</source>
          <target state="translated">, '</target>
        </trans-unit>
        <trans-unit id="23adf1a81d00b9577caedac00d8bb053cb588e55" translate="yes" xml:space="preserve">
          <source>, and &lt;var&gt;Mod&lt;/var&gt; references a variable &lt;var&gt;Var&lt;/var&gt; that is no bigger than &lt;var&gt;num&lt;/var&gt; bytes, you must make sure that &lt;var&gt;Var&lt;/var&gt; is placed in a small data section. If &lt;var&gt;Var&lt;/var&gt; is defined by another module, you must either compile that module with a high-enough</source>
          <target state="translated">과 &lt;var&gt;Mod&lt;/var&gt; 참조 변수의 &lt;var&gt;Var&lt;/var&gt; 보다 더 큰 없습니다 &lt;var&gt;num&lt;/var&gt; 바이트, 당신은 있는지 확인해야한다 &lt;var&gt;Var&lt;/var&gt; 작은 데이터 섹션에 배치됩니다. &lt;var&gt;Var&lt;/var&gt; 이 다른 모듈에 의해 정의 된 경우 해당 모듈을 충분히 높은 수준으로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="743749c4efffebe81ffd20a194825f3fc850b511" translate="yes" xml:space="preserve">
          <source>, and add the resulting directory to the include search path.</source>
          <target state="translated">을 포함하고 결과 디렉토리를 포함 검색 경로에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a16ad3ad201ad0e9edb67f4182af2991296c2f83" translate="yes" xml:space="preserve">
          <source>, and all preprocessed C source on standard output.</source>
          <target state="translated">표준 출력의 모든 사전 처리 된 C 소스</target>
        </trans-unit>
        <trans-unit id="90ed666d7d769802b6beda7c0dcee29960956ee6" translate="yes" xml:space="preserve">
          <source>, and by</source>
          <target state="translated">으로</target>
        </trans-unit>
        <trans-unit id="d71752f09e96fc62366114cf7f0e7ed6dfc15ba5" translate="yes" xml:space="preserve">
          <source>, and can be disabled with</source>
          <target state="translated">와 함께 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e2ece9623c1b6de007925f8291dd7e268326a4" translate="yes" xml:space="preserve">
          <source>, and is now deprecated in favor of that option.</source>
          <target state="translated">, 이제 해당 옵션에 찬성하여 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c621a5f8adf6dadb74b46610241e3bcd04d2e32" translate="yes" xml:space="preserve">
          <source>, and is the default for GCC on most targets. On the other hand, this behavior is not required by ISO C, and on some targets may carry a speed or code size penalty on variable references.</source>
          <target state="translated">이며 대부분의 타겟에서 GCC의 기본값입니다. 반면에이 동작은 ISO C에서 필요하지 않으며 일부 대상에서 가변 참조에 속도 또는 코드 크기 위약금이 부과 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a5ea6b58f23701d3aa4146ace54029e8823718" translate="yes" xml:space="preserve">
          <source>, and only available for ARCv1 cores. This option is deprecated.</source>
          <target state="translated">ARCv1 코어에만 사용할 수 있습니다. 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6256dac04a1e70e1c010f7986affe3cfbc4b96" translate="yes" xml:space="preserve">
          <source>, and put each precompiled header in the directory, perhaps using</source>
          <target state="translated">을 사용하여 미리 컴파일 된 각 헤더를 디렉토리에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c2c2c76da72f0a333b5ed5016704ad851d0c39af" translate="yes" xml:space="preserve">
          <source>, and suppresses warnings with an implicit</source>
          <target state="translated">암시 적으로 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34f17ce4557bcdf5b55dbd872b85dc9b982eafa1" translate="yes" xml:space="preserve">
          <source>, and the only difference between the options is the value of &lt;code&gt;__STDC_VERSION__&lt;/code&gt;.</source>
          <target state="translated">옵션 사이의 유일한 차이점은 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="96e931096776aece1fe3f0a9e4be616b683405e9" translate="yes" xml:space="preserve">
          <source>, and this one:</source>
          <target state="translated">, 그리고 이것:</target>
        </trans-unit>
        <trans-unit id="e7d139345f8f88ea2b0370b518948a4897eef2d7" translate="yes" xml:space="preserve">
          <source>, and thus is only supported on targets that have support for</source>
          <target state="translated">을 지원하는 대상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b113e8bcc5e9f320f4732a36fdcbc4f0f5e0d09c" translate="yes" xml:space="preserve">
          <source>, and/or</source>
          <target state="translated">, 및 / 또는</target>
        </trans-unit>
        <trans-unit id="c57f45466533085df41649cdee0f603a5cb41c26" translate="yes" xml:space="preserve">
          <source>, any</source>
          <target state="translated">, 어떤</target>
        </trans-unit>
        <trans-unit id="866ed9c2b2d2bad8e5d74a3106d1846d7046ccca" translate="yes" xml:space="preserve">
          <source>, are also relevant for C++ programs. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">C ++ 프로그램과도 관련이 있습니다. &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;C 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51481c8b24c31c23ddc1a3abcf6ba83a1ef51299" translate="yes" xml:space="preserve">
          <source>, are ignored.</source>
          <target state="translated">, 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="79a943208a4fedad276a1aa123b394ce668bbff3" translate="yes" xml:space="preserve">
          <source>, are ignored. The standard startup files are used normally, unless</source>
          <target state="translated">, 무시됩니다. 표준 시작 파일은 일반적으로 사용되지 않는 한</target>
        </trans-unit>
        <trans-unit id="6379405f41516ac12b0f4139833678105195c0a4" translate="yes" xml:space="preserve">
          <source>, as a collection of messages with source file, line number and column number, with the following additional data for each message:</source>
          <target state="translated">소스 파일, 줄 번호 및 열 번호가있는 메시지 모음으로 각 메시지에 대해 다음과 같은 추가 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb00d545d0d5607110a98e502d1a1edbbdaa2098" translate="yes" xml:space="preserve">
          <source>, as the CR16C architecture does not support the far data model.</source>
          <target state="translated">CR16C 아키텍처는 원거리 데이터 모델을 지원하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5b479d70daa1736f38f38cdacfc0aca31404acb9" translate="yes" xml:space="preserve">
          <source>, as well as</source>
          <target state="translated">, 만큼 잘</target>
        </trans-unit>
        <trans-unit id="33d60ffd6d107c4c32d8b7981fa36d4a32ef8dab" translate="yes" xml:space="preserve">
          <source>, as well as by</source>
          <target state="translated">뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="399b3f0e115711c4cd717ca3bbb79382e386fd0b" translate="yes" xml:space="preserve">
          <source>, because this passes the entire string as a single argument, which is not what the linker expects.</source>
          <target state="translated">이것은 전체 문자열을 단일 인수로 전달하기 때문에 링커가 기대하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="865e3dfce7701d87918161573fe82bb85b8c9703" translate="yes" xml:space="preserve">
          <source>, but additionally asserts that the program being compiled does not perform any floating-point operations. This option is presently supported only by some bare-metal MIPS configurations, where it may select a special set of libraries that lack all floating-point support (including, for example, the floating-point &lt;code&gt;printf&lt;/code&gt; formats). If code compiled with</source>
          <target state="translated">또한 컴파일되는 프로그램이 부동 소수점 연산을 수행하지 않는다고 주장합니다. 이 옵션은 현재 일부 베어 메탈 MIPS 구성에서만 지원되며 모든 부동 소수점 지원이없는 특수 라이브러리 세트 (예 : 부동 소수점 &lt;code&gt;printf&lt;/code&gt; 형식 포함)를 선택할 수 있습니다 . 코드가 컴파일 된 경우</target>
        </trans-unit>
        <trans-unit id="e44afa57519c3ebb51125bff96010b68f9e7c42e" translate="yes" xml:space="preserve">
          <source>, but after any paths given with</source>
          <target state="translated">그러나 경로가 주어진 후</target>
        </trans-unit>
        <trans-unit id="da29ebe06aeaf8eeb2af99d65acf35ce314f7a2d" translate="yes" xml:space="preserve">
          <source>, but causes CSE to follow jumps that conditionally skip over blocks. When CSE encounters a simple &lt;code&gt;if&lt;/code&gt; statement with no else clause,</source>
          <target state="translated">CSE가 조건부로 블록을 건너 뛰는 점프를 수행하게합니다. CSE가 else 절이없는 간단한 &lt;code&gt;if&lt;/code&gt; 문을 발견하면</target>
        </trans-unit>
        <trans-unit id="cc018337da61987ae8a9683d2e8189ee04860e67" translate="yes" xml:space="preserve">
          <source>, but debug insns may get (non-overlapping) uids above it if the reserved range is exhausted.</source>
          <target state="translated">하지만 예약 된 범위가 소진되면 디버그 insns가 겹치지 않는 uid를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005377f41b9be83224f58308ed6955447f64b6d1" translate="yes" xml:space="preserve">
          <source>, but does not override the pipeline info. This helps reduce code size while still giving good performance.</source>
          <target state="translated">파이프 라인 정보를 재정의하지는 않습니다. 이렇게하면 코드 크기를 줄이면서도 우수한 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594ba3ce9f3f33a1e11308ab98fb068b622db145" translate="yes" xml:space="preserve">
          <source>, but emit only the macro names, not their expansions.</source>
          <target state="translated">확장이 아닌 매크로 이름 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2d142b0d539e9cf1b604cc78dc509f4e7229fde5" translate="yes" xml:space="preserve">
          <source>, but is enabled by</source>
          <target state="translated">에 의해 활성화되지만</target>
        </trans-unit>
        <trans-unit id="8fc78f584be2b6aad9e5e5043f9934d5b9b136e4" translate="yes" xml:space="preserve">
          <source>, but it quotes any characters which are special to Make. &lt;code&gt;-MQ '$(objpfx)foo.o'&lt;/code&gt; gives</source>
          <target state="translated">하지만 Make에 특수한 모든 문자를 인용합니다. &lt;code&gt;-MQ '$(objpfx)foo.o'&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4c4a33264da0720530175142264eac24f6ae7161" translate="yes" xml:space="preserve">
          <source>, but not</source>
          <target state="translated">, 하지만</target>
        </trans-unit>
        <trans-unit id="bddcaf1db7854ec894bd29481c117d0421a3605f" translate="yes" xml:space="preserve">
          <source>, but not at</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="9c0770373d31ca6185df409b28c1a619d6e08d53" translate="yes" xml:space="preserve">
          <source>, but not other header files. The value &amp;lsquo;</source>
          <target state="translated">다른 헤더 파일은 아닙니다. 가치 '</target>
        </trans-unit>
        <trans-unit id="159001fe4af9e263248a6b95afa82d085080520c" translate="yes" xml:space="preserve">
          <source>, but not to skip more bytes than the size of the function.</source>
          <target state="translated">함수의 크기보다 많은 바이트를 건너 뛰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d958259abb765b7f6d8dcadea03974d1a2f40bf6" translate="yes" xml:space="preserve">
          <source>, but not with</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="b216118818bb69b17957ca8878a61bc6b92bed60" translate="yes" xml:space="preserve">
          <source>, but only print for the WPA phase of Link Time Optimization.</source>
          <target state="translated">링크 시간 최적화의 WPA 단계에만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4e35d7567098d27b15b90e10171d5a8dcf120925" translate="yes" xml:space="preserve">
          <source>, but pass linker options to locate initialized data at 0x40000000 and zero-initialized data at 0x80000000.</source>
          <target state="translated">하지만 링커 옵션을 전달하여 0x40000000에서 초기화 된 데이터를 찾고 0x80000000에서 초기화 된 데이터를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6f70c180932b6b9e56fc718a1092901e76994fec" translate="yes" xml:space="preserve">
          <source>, but requests an additional pass of instruction scheduling after register allocation has been done. This is especially useful on machines with a relatively small number of registers and where memory load instructions take more than one cycle.</source>
          <target state="translated">레지스터 할당이 완료된 후 명령 스케줄링의 추가 패스를 요청합니다. 이는 비교적 적은 수의 레지스터가 있고 메모리로드 명령이 두 번 이상 사이클을 수행하는 시스템에서 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="830b9851b653de89541a42c034a463a6fc26cd47" translate="yes" xml:space="preserve">
          <source>, but searches for a program such as &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; 와 같은 프로그램을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="d72133be23d29e86bec8e3866d2ef1a66344d808" translate="yes" xml:space="preserve">
          <source>, but the default can be overridden by configuring GCC with</source>
          <target state="translated">을 사용하여 GCC를 구성하여 기본값을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="387e7f946ae452eacdf73af60a95f99f5b4e63e8" translate="yes" xml:space="preserve">
          <source>, but the extension options do not affect the tuning of the generated code.</source>
          <target state="translated">확장 옵션은 생성 된 코드의 튜닝에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b9a159b4f28ed957d67b57c420c44a30c73f5f0" translate="yes" xml:space="preserve">
          <source>, but the generated position-independent code can be only linked into executables. Usually these options are used to compile code that will be linked using the</source>
          <target state="translated">그러나 생성 된 위치 독립적 코드는 실행 파일에만 링크 될 수 있습니다. 일반적으로 이러한 옵션은 다음을 사용하여 링크 될 코드를 컴파일하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce00db4a928b7a01e2c8e7726b40ed1e61c2d0a0" translate="yes" xml:space="preserve">
          <source>, but the only useful values are those that select a particular CPU implementation. Those are &amp;lsquo;</source>
          <target state="translated">그러나 유용한 유용한 값은 특정 CPU 구현을 선택하는 값입니다. 사람들은 '</target>
        </trans-unit>
        <trans-unit id="8192753a9d1c499d01af47f83e4414507c8efbb8" translate="yes" xml:space="preserve">
          <source>, but the scheduling parameters set by</source>
          <target state="translated">하지만 예약 매개 변수는</target>
        </trans-unit>
        <trans-unit id="b748f41055c10d610a28ba47d6bb381220696d14" translate="yes" xml:space="preserve">
          <source>, but there are a few exceptions. GCC requires the freestanding environment provide &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcmp&lt;/code&gt;. Finally, if &lt;code&gt;__builtin_trap&lt;/code&gt; is used, and the target does not implement the &lt;code&gt;trap&lt;/code&gt; pattern, then GCC emits a call to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">하지만 몇 가지 예외가 있습니다. GCC는 독립 환경에서 &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;memmove&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; 및 &lt;code&gt;memcmp&lt;/code&gt; 를 제공해야합니다 . 마지막으로 &lt;code&gt;__builtin_trap&lt;/code&gt; 이 사용되고 대상이 &lt;code&gt;trap&lt;/code&gt; 패턴을 구현하지 않으면 GCC는 &lt;code&gt;abort&lt;/code&gt; 호출을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e915a38ee11f159ae6606fe3c6ba38c9e85ffd1a" translate="yes" xml:space="preserve">
          <source>, but this can be overridden at configure time using</source>
          <target state="translated">을 사용하여 구성 시간에 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff7f24239f93384ee139821001cb13bd9242f98" translate="yes" xml:space="preserve">
          <source>, but this option sets the list of function names to be excluded from instrumentation. The function name to be matched is its user-visible name, such as &lt;code&gt;vector&amp;lt;int&amp;gt; blah(const vector&amp;lt;int&amp;gt; &amp;amp;)&lt;/code&gt;, not the internal mangled name (e.g., &lt;code&gt;_Z4blahRSt6vectorIiSaIiEE&lt;/code&gt;). The match is done on substrings: if the &lt;var&gt;sym&lt;/var&gt; parameter is a substring of the function name, it is considered to be a match. For C99 and C++ extended identifiers, the function name must be given in UTF-8, not using universal character names.</source>
          <target state="translated">그러나이 옵션은 기능 이름 목록이 계측에서 제외되도록 설정합니다. 일치하는 함수 이름 은 내부 맹 글링 이름이 아닌 &lt;code&gt;vector&amp;lt;int&amp;gt; blah(const vector&amp;lt;int&amp;gt; &amp;amp;)&lt;/code&gt; 와 같이 사용자가 볼 수있는 이름입니다 (예 : &lt;code&gt;_Z4blahRSt6vectorIiSaIiEE&lt;/code&gt; ). 하위 문자열에서 일치가 수행됩니다. &lt;var&gt;sym&lt;/var&gt; 매개 변수가 함수 이름의 하위 문자열 인 경우 일치하는 것으로 간주됩니다. C99 및 C ++ 확장 ID의 경우 함수 이름은 범용 문자 이름을 사용하지 않고 UTF-8로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4b542e5e2900b33582894496dd2fb25f7a186a1" translate="yes" xml:space="preserve">
          <source>, callers of such functions use an inlined PLT.</source>
          <target state="translated">이러한 함수의 호출자는 인라인 PLT를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1bc40ffb21955611ebc01b821b57a8fb97abe447" translate="yes" xml:space="preserve">
          <source>, causes debug versions of the runtime functions for the vtable verification feature to be called. This flag also causes the compiler to log information about which vtable pointers it finds for each class. This information is written to a file named</source>
          <target state="translated">vtable 확인 기능에 대한 런타임 함수의 디버그 버전이 호출됩니다. 이 플래그는 또한 컴파일러가 각 클래스에 대해 찾은 vtable 포인터에 대한 정보를 기록하게합니다. 이 정보는라는 파일에 기록됩니다</target>
        </trans-unit>
        <trans-unit id="186899d07725833e558a3f1b37bca7595dd4ab80" translate="yes" xml:space="preserve">
          <source>, causes the compiler to tune for code size rather than execution speed, and performs further optimizations designed to reduce code size.</source>
          <target state="translated">컴파일러가 실행 속도가 아닌 코드 크기를 조정하도록하고 코드 크기를 줄 이도록 설계된 추가 최적화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="77a4aca34a1bfb27eca2f4c5b85088c452ff661a" translate="yes" xml:space="preserve">
          <source>, cold functions are automatically detected and this attribute is ignored.</source>
          <target state="translated">콜드 기능은 자동으로 감지되며이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f796dad3806ccc12e4efbb979242edaefd9c68ac" translate="yes" xml:space="preserve">
          <source>, debug information is generated for types declared in that file and</source>
          <target state="translated">해당 파일에 선언 된 유형에 대해 디버그 정보가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="602f9aefc82b94f79ccc91c4e0a2d6024a300032" translate="yes" xml:space="preserve">
          <source>, defaulting to</source>
          <target state="translated">, 기본값은</target>
        </trans-unit>
        <trans-unit id="63e7e7ca16f5d6ce188c6f1a13bb0cfb59a90f05" translate="yes" xml:space="preserve">
          <source>, depending on the other options used, so that headers may for example be found in</source>
          <target state="translated">사용 된 다른 옵션에 따라 헤더가 예를 들어</target>
        </trans-unit>
        <trans-unit id="59850229d9fda282df9f43c3238d9cc1fe2f9ca4" translate="yes" xml:space="preserve">
          <source>, don&amp;rsquo;t generate (do generate) instruction sequences that load addresses for functions from the PLT part of the GOT rather than (traditional on other architectures) calls to the PLT. The default is</source>
          <target state="translated">, PLT에 대한 (다른 아키텍처의 전통적인) 호출보다는 GOT의 PLT 부분에서 함수의 주소를로드하는 명령 시퀀스를 생성 (생성)하지 마십시오. 디폴트는</target>
        </trans-unit>
        <trans-unit id="899cb9db2c2edf8462bd1866fd07b4a282dd26dc" translate="yes" xml:space="preserve">
          <source>, each</source>
          <target state="translated">, 각각</target>
        </trans-unit>
        <trans-unit id="a212453865c3ae5d769c013e9814daf8f2a214a4" translate="yes" xml:space="preserve">
          <source>, etc.</source>
          <target state="translated">등</target>
        </trans-unit>
        <trans-unit id="2025ee33109115d150095e4dc9fbc6cecdccc59c" translate="yes" xml:space="preserve">
          <source>, etc. GCC considers</source>
          <target state="translated">등 GCC가 고려하는 사항</target>
        </trans-unit>
        <trans-unit id="c230b2ae171538a9903d9c6f4c54262988ff8a11" translate="yes" xml:space="preserve">
          <source>, except for that it outputs the &lt;code&gt;.code16gcc&lt;/code&gt; assembly directive at the beginning of the assembly output so that the binary can run in 16-bit mode.</source>
          <target state="translated">바이너리 출력이 16 비트 모드에서 실행될 수 있도록 어셈블리 출력의 시작 부분에 &lt;code&gt;.code16gcc&lt;/code&gt; 어셈블리 지시문을 출력한다는 점을 제외하고</target>
        </trans-unit>
        <trans-unit id="36187c82da4acd270eb00cabfd2754e7a35d89ac" translate="yes" xml:space="preserve">
          <source>, except on targets where GCC is the principal compiler. In those cases, we can choose the standard, and we chose the more efficient register return alternative.</source>
          <target state="translated">GCC가 주요 컴파일러 인 대상을 제외하고 이 경우 표준을 선택할 수 있으며보다 효율적인 레지스터 리턴 대안을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="4a7bfad050613cd89b494934c041ad85c96a7f4e" translate="yes" xml:space="preserve">
          <source>, except that</source>
          <target state="translated">제외하고</target>
        </trans-unit>
        <trans-unit id="424ca99182001aa93e0255bf1521df6608849e1a" translate="yes" xml:space="preserve">
          <source>, except that any output produced by scanning &lt;var&gt;file&lt;/var&gt; is thrown away. Macros it defines remain defined. This allows you to acquire all the macros from a header without also processing its declarations.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 을 스캔하여 생성 된 출력은 모두 제외 됩니다. 정의한 매크로는 정의 된 상태로 유지됩니다. 이를 통해 선언을 처리하지 않고도 헤더에서 모든 매크로를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af31397d348022357555d43ae6b6602db7237c77" translate="yes" xml:space="preserve">
          <source>, except that comments contained within macros are also passed through to the output file where the macro is expanded.</source>
          <target state="translated">매크로에 포함 된 주석도 매크로가 확장 된 출력 파일로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8293df57b65690a6a5b17ad151fb7402defdb639" translate="yes" xml:space="preserve">
          <source>, except that it implicitly passes</source>
          <target state="translated">암시 적으로 통과한다는 점을 제외하고</target>
        </trans-unit>
        <trans-unit id="f4ee9476717ae169b601f810748e3fbaeb86e2f3" translate="yes" xml:space="preserve">
          <source>, except that it just generates any needed static data, but does not affect the generated code in any other way. You normally do not need to enable this option; instead, a language processor that needs this handling enables it on your behalf.</source>
          <target state="translated">필요한 정적 데이터 만 생성하지만 다른 방식으로 생성 된 코드에는 영향을 미치지 않습니다. 일반적으로이 옵션을 활성화 할 필요는 없습니다. 대신,이 처리가 필요한 언어 프로세서가 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa2d6de31b71426a7c88a1aee1560252b4b2a7d" translate="yes" xml:space="preserve">
          <source>, except when selective scheduling is enabled.</source>
          <target state="translated">선택적 스케줄링이 활성화 된 경우를 제외하고.</target>
        </trans-unit>
        <trans-unit id="dce06a184830559e813d9f5a2f13966eb3de4b64" translate="yes" xml:space="preserve">
          <source>, expand the &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__BASE_FILE__&lt;/code&gt; macros as if the files resided in directory</source>
          <target state="translated">파일이 디렉토리에있는 것처럼 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__BASE_FILE__&lt;/code&gt; 매크로를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="537e3d3f4595296c4732ae2914f89aff5f7a7f43" translate="yes" xml:space="preserve">
          <source>, fails and prints an error if asked to create a shared library with a less restrictive subtype than its input files (for instance, trying to put a &amp;lsquo;</source>
          <target state="translated">입력 파일보다 덜 제한적인 하위 유형을 가진 공유 라이브러리를 작성하라는 요청을 받으면 (예 : '</target>
        </trans-unit>
        <trans-unit id="fdb43e7f5581dd318ba35a4b1b7bd3f3204a8b2e" translate="yes" xml:space="preserve">
          <source>, for each function of your program GCC creates a program flow graph, then finds a spanning tree for the graph. Only arcs that are not on the spanning tree have to be instrumented: the compiler adds code to count the number of times that these arcs are executed. When an arc is the only exit or only entrance to a block, the instrumentation code can be added to the block; otherwise, a new basic block must be created to hold the instrumentation code.</source>
          <target state="translated">, 프로그램의 각 기능에 대해 GCC는 프로그램 흐름 그래프를 생성 한 다음 그래프의 스패닝 트리를 찾습니다. 스패닝 트리에없는 아크만 계측해야합니다. 컴파일러는 이러한 아크가 실행되는 횟수를 세는 코드를 추가합니다. 호가 블록의 유일한 출구이거나 유일한 입구 인 경우 계측 코드를 블록에 추가 할 수 있습니다. 그렇지 않으면 인스 트루먼 테이션 코드를 보유하기 위해 새 기본 블록을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a62702328e51c81c8d14351efa5231be254fb50" translate="yes" xml:space="preserve">
          <source>, for which this feature is experimental.</source>
          <target state="translated">이 기능은 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="de44d1d94e89d69c9312fa31d05de00107553327" translate="yes" xml:space="preserve">
          <source>, forcibly change the way C symbols are represented in the object file. One use is to help link with legacy assembly code.</source>
          <target state="translated">객체 파일에서 C 기호가 표시되는 방식을 강제로 변경합니다. 레거시 어셈블리 코드와 연결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3d5d86fcab0fccd2357fb760ccfdbc87239051" translate="yes" xml:space="preserve">
          <source>, function calls with a such function as the callee or caller uses inlined PLT.</source>
          <target state="translated">, 수신자 또는 발신자가 인라인 PLT를 사용하는 것과 같은 기능을 가진 함수 호출</target>
        </trans-unit>
        <trans-unit id="b73db41c359e5e1618dc5e96de50a7c0cce9c547" translate="yes" xml:space="preserve">
          <source>, generating &lt;var&gt;N&lt;/var&gt; NOPs, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP instruction. &lt;var&gt;M&lt;/var&gt; defaults to 0 if omitted e.g. function entry point is before the first NOP.</source>
          <target state="translated">, &lt;var&gt;M&lt;/var&gt; 번째 NOP 명령 이전에 함수 진입 점이있는 &lt;var&gt;N&lt;/var&gt; NOP를 생성 합니다. 생략 된 경우 &lt;var&gt;M&lt;/var&gt; 의 기본값은 0입니다. 예를 들어 기능 진입 점이 첫 번째 NOP 이전입니다.</target>
        </trans-unit>
        <trans-unit id="66281c83f494cfe2e9913aed90954ff6500be7df" translate="yes" xml:space="preserve">
          <source>, giving just &amp;lsquo;</source>
          <target state="translated">, 단지 '</target>
        </trans-unit>
        <trans-unit id="7edb54e230ef45c40c202a2070aee0bf8eea9a7f" translate="yes" xml:space="preserve">
          <source>, hot functions are automatically detected and this attribute is ignored.</source>
          <target state="translated">핫 기능은 자동으로 감지되며이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd70bd4accf5ece1456ab2be03ed1e6ee41d4b1c" translate="yes" xml:space="preserve">
          <source>, however the option is disabled if generated code will be instrumented for profiling (</source>
          <target state="translated">그러나 생성 된 코드가 프로파일 링을 위해 계측되는 경우이 옵션은 비활성화됩니다 (</target>
        </trans-unit>
        <trans-unit id="1bce44abc1a9262df8cac0c50152864f825ccf63" translate="yes" xml:space="preserve">
          <source>, i.e. to store data in the little-endian format.</source>
          <target state="translated">즉, 리틀 엔디안 형식으로 데이터를 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da5060e991a7ba759c2592a069e08cef00119e51" translate="yes" xml:space="preserve">
          <source>, i.e., do not enable</source>
          <target state="translated">즉, 활성화하지 마십시오</target>
        </trans-unit>
        <trans-unit id="fe023c621e2a7b2cf31927bbba4a961d25408a71" translate="yes" xml:space="preserve">
          <source>, i.e., pass standard Linux linking options to the linker.</source>
          <target state="translated">즉, 표준 Linux 연결 옵션을 링커에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c940f0489137021ec5391fb7b7ac2f5ace9d8059" translate="yes" xml:space="preserve">
          <source>, if OS libraries are present in</source>
          <target state="translated">OS 라이브러리가있는 경우</target>
        </trans-unit>
        <trans-unit id="c3dd87cad0ef7982b3ab32988714c6ca54cf2f9e" translate="yes" xml:space="preserve">
          <source>, imply</source>
          <target state="translated">, 암시</target>
        </trans-unit>
        <trans-unit id="1f808929dc7d65506fc3a70039f1c27ca90486ac" translate="yes" xml:space="preserve">
          <source>, in addition to the</source>
          <target state="translated">, 여기에 덧붙여</target>
        </trans-unit>
        <trans-unit id="cf07eced2fe9d18835b5764136236b3da619529d" translate="yes" xml:space="preserve">
          <source>, in the same way that</source>
          <target state="translated">같은 방식으로</target>
        </trans-unit>
        <trans-unit id="b30d7a5cabdcb5756c85bb67b0a58b128c10f3cc" translate="yes" xml:space="preserve">
          <source>, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">라이브러리를 포함하여 여기에는 시스템 라이브러리 및 시작 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7b04496200d4f3af930e39d995d950d3bfbff027" translate="yes" xml:space="preserve">
          <source>, instead of guessing which path a branch is most likely to take, the &amp;lsquo;</source>
          <target state="translated">, 지점이 어떤 경로를 취할지 추측하는 대신 '</target>
        </trans-unit>
        <trans-unit id="f26cdfc5e353e2972712fe3c4c6c2c7061cd6b42" translate="yes" xml:space="preserve">
          <source>, is also specified with</source>
          <target state="translated">으로도 지정됩니다</target>
        </trans-unit>
        <trans-unit id="297f123a9478230dfaae1454a7a30d8603dbe525" translate="yes" xml:space="preserve">
          <source>, is to use assembler macros instead.</source>
          <target state="translated">대신 어셈블러 매크로를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9865f992f80d724f0d28f2e68445911d448f9a75" translate="yes" xml:space="preserve">
          <source>, it accesses the variables from a common anchor point instead. The effect is similar to the following pseudocode (which isn&amp;rsquo;t valid C):</source>
          <target state="translated">대신 공통 앵커 포인트에서 변수에 액세스합니다. 효과는 다음 의사 코드 (유효하지 않은 C)와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="37c7d699148009585bcbfd24104e627443f4227f" translate="yes" xml:space="preserve">
          <source>, it adds code so that some data about values of expressions in the program is gathered.</source>
          <target state="translated">프로그램의 표현식 값에 대한 일부 데이터가 수집되도록 코드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8bb937a2afd69efa3de1fcfec93c85b21cd8d3c0" translate="yes" xml:space="preserve">
          <source>, it assumes GOT entries and small data are within a 12-bit range from the GOT base address; with</source>
          <target state="translated">GOT 엔트리와 작은 데이터가 GOT 기본 주소로부터 12 비트 범위 내에 있다고 가정한다. 와</target>
        </trans-unit>
        <trans-unit id="70db58101b4a4dd5508449ddae97a05be51b3c50" translate="yes" xml:space="preserve">
          <source>, it defines the macros for every architecture in the range.</source>
          <target state="translated">범위 내의 모든 아키텍처에 대한 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a7334c92634fb9a0df41a81a512187c2464430d0" translate="yes" xml:space="preserve">
          <source>, it dumps debugging information about location maps. Every token in the output is preceded by the dump of the map its location belongs to.</source>
          <target state="translated">위치 맵에 대한 디버깅 정보를 덤프합니다. 출력의 모든 토큰 앞에는 해당 위치가 속한 맵 덤프가옵니다.</target>
        </trans-unit>
        <trans-unit id="085a445042571b2a530ccf02bdc7d3dca3e56d18" translate="yes" xml:space="preserve">
          <source>, it has the same meaning as &amp;lsquo;</source>
          <target state="translated">'와 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="0b7ad38301fa6cb9702cdcc46f4b9ac21cbe6bd6" translate="yes" xml:space="preserve">
          <source>, it instead searches</source>
          <target state="translated">대신 검색</target>
        </trans-unit>
        <trans-unit id="da805275b6a01ffed7306b21a2664c3c591d7da2" translate="yes" xml:space="preserve">
          <source>, it is possible to extract and use them in an LTO link if you are using a linker with plugin support. To create static libraries suitable for LTO, use &lt;code&gt;gcc-ar&lt;/code&gt; and &lt;code&gt;gcc-ranlib&lt;/code&gt; instead of &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;ranlib&lt;/code&gt;; to show the symbols of object files with GIMPLE bytecode, use &lt;code&gt;gcc-nm&lt;/code&gt;. Those commands require that &lt;code&gt;ar&lt;/code&gt;, &lt;code&gt;ranlib&lt;/code&gt; and &lt;code&gt;nm&lt;/code&gt; have been compiled with plugin support. At link time, use the flag</source>
          <target state="translated">플러그인을 지원하는 링커를 사용하는 경우 LTO 링크에서 추출하여 사용할 수 있습니다. LTO, 사용하기에 적합한 정적 라이브러리를 만들려면 &lt;code&gt;gcc-ar&lt;/code&gt; 및 &lt;code&gt;gcc-ranlib&lt;/code&gt; 대신 &lt;code&gt;ar&lt;/code&gt; 와 &lt;code&gt;ranlib&lt;/code&gt; ; GIMPLE 바이트 코드를 사용하여 객체 파일의 심볼을 표시하려면 &lt;code&gt;gcc-nm&lt;/code&gt; 을 사용하십시오 . 이러한 명령을 사용하려면 &lt;code&gt;ar&lt;/code&gt; , &lt;code&gt;ranlib&lt;/code&gt; 및 &lt;code&gt;nm&lt;/code&gt; 가 플러그인 지원으로 컴파일되어 있어야합니다. 링크 타임에 플래그를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="0fdbc0dcc1b3d3cf0a25782f0c9d99618712795c" translate="yes" xml:space="preserve">
          <source>, it links the shared version of</source>
          <target state="translated">의 공유 버전을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d873388541d922fb56183db4bb2553adba035d5a" translate="yes" xml:space="preserve">
          <source>, it reads back the data gathered and actually performs the optimizations based on them. Currently the optimizations include specialization of division operations using the knowledge about the value of the denominator.</source>
          <target state="translated">, 수집 된 데이터를 읽고 실제로이를 기반으로 최적화를 수행합니다. 현재 최적화에는 분모 값에 대한 지식을 사용하여 나누기 작업의 전문화가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a2f260537ad6dfb12892a249886247f016bc9ba2" translate="yes" xml:space="preserve">
          <source>, it reads back the data gathered from profiling values of expressions for usage in optimizations.</source>
          <target state="translated">최적화에서 사용하기 위해 표현식의 프로파일 링 값에서 수집 된 데이터를 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="33fdaf8607572ca9dfc5db8fb8a043fa47838f46" translate="yes" xml:space="preserve">
          <source>, it trades 3 instructions for 4, one of which may be shared by multiple symbols, and it avoids the need for a GOT entry for the referenced symbol, so it&amp;rsquo;s more likely to be a win. If it is not,</source>
          <target state="translated">, 그것은 4에 대한 3 개의 명령을 교환하는데, 그 중 하나는 여러 개의 심볼에 의해 공유 될 수 있고, 참조 된 심볼에 대한 GOT 엔트리의 필요성을 피하므로, 승리 할 가능성이 더 높습니다. 그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="597abb8e1070ef05bc7ec2edf56f3622f0ab3d9c" translate="yes" xml:space="preserve">
          <source>, its assembler file in</source>
          <target state="translated">의 어셈블러 파일</target>
        </trans-unit>
        <trans-unit id="2a5e7591ba964c2077d7342b00d00d8531ffe32b" translate="yes" xml:space="preserve">
          <source>, linking with the static version of libgcc by default. This allows exceptions to propagate through such shared libraries, without incurring relocation costs at library load time.</source>
          <target state="translated">정적 버전의 libgcc와 기본적으로 연결됩니다. 따라서 라이브러리로드시 재배치 비용이 발생하지 않고 예외가 이러한 공유 라이브러리를 통해 전파 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f86f918c25844c67aabc1b85407cae7e6da5fdd5" translate="yes" xml:space="preserve">
          <source>, loops containing a load/store sequence can be changed to a load before the loop and a store after the loop.</source>
          <target state="translated">,로드 / 저장 시퀀스를 포함하는 루프는 루프 전의로드와 루프 후의 스토어로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cfaf303daa057f828f7c2dbdcc5ee00d114011c" translate="yes" xml:space="preserve">
          <source>, merges the two files into a single internal image, and compiles the result as usual. Since both</source>
          <target state="translated">, 두 파일을 하나의 내부 이미지로 병합하고 평소와 같이 결과를 컴파일합니다. 둘 다</target>
        </trans-unit>
        <trans-unit id="42efed7c6b6343d536a66fe0302d3bcf2db50bff" translate="yes" xml:space="preserve">
          <source>, merges them together into a single GIMPLE representation and optimizes them as usual to produce</source>
          <target state="translated">을 하나의 GIMPLE 표현으로 병합하고 평소처럼 최적화하여 제작합니다.</target>
        </trans-unit>
        <trans-unit id="4de233cb30f72a91f767198fb4088b9d8434017e" translate="yes" xml:space="preserve">
          <source>, only calls to prototyped variable argument functions set or clear the bit.</source>
          <target state="translated">프로토 타입 변수 인수 함수에 대한 호출 만 설정하거나 비트를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="500ad22c367338ded2a7f587262dff6519e20900" translate="yes" xml:space="preserve">
          <source>, only permits instructions to be used that are valid for the subtype of the file it is generating, so you cannot put 64-bit instructions in a &amp;lsquo;</source>
          <target state="translated">, 생성중인 파일의 하위 유형에 유효한 명령 만 사용할 수 있으므로 64 비트 명령을 '</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="9dc64f385a34f50d73ecc913e204ce42b3b016bf" translate="yes" xml:space="preserve">
          <source>, or if OS libraries are present in</source>
          <target state="translated">또는 OS 라이브러리가있는 경우</target>
        </trans-unit>
        <trans-unit id="80b0984b332cb5904969fd0c26d2d20fdad7a2a9" translate="yes" xml:space="preserve">
          <source>, or model suboptions) when you specify this linker option.</source>
          <target state="translated">이 링커 옵션을 지정할 때, 또는 모델 하위 옵션)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7f73a9aa24d964050dc3b77a89839f46d5544c2" translate="yes" xml:space="preserve">
          <source>, or model suboptions) when you specify this linker option.&lt;a href=&quot;#FOOT1&quot; id=&quot;DOCF1&quot; name=&quot;DOCF1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">이 링커 옵션을 지정할 때, 또는 모델 하위 옵션)을 참조하십시오. &lt;a href=&quot;#FOOT1&quot; id=&quot;DOCF1&quot; name=&quot;DOCF1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7df955ad07564d81affa3b0a58d1230baa30b079" translate="yes" xml:space="preserve">
          <source>, or tagged with the equivalent &lt;code&gt;arch=armv8-a+crc&lt;/code&gt; attribute, can inline a function &lt;code&gt;bar&lt;/code&gt; compiled with</source>
          <target state="translated">또는 해당 태그 &lt;code&gt;arch=armv8-a+crc&lt;/code&gt; 특성 함수 인라인 수 &lt;code&gt;bar&lt;/code&gt; 컴파일을</target>
        </trans-unit>
        <trans-unit id="c0d16ff2ecb94e39dbd670079ddc6dfea8cf86c2" translate="yes" xml:space="preserve">
          <source>, or use an environment variable like &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; (see &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;). Debug output is still sent to the regular output stream as normal.</source>
          <target state="translated">&lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; 과 같은 환경 변수를 사용 하십시오 ( &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;환경 변수&lt;/a&gt; 참조 ). 디버그 출력은 여전히 ​​정상 출력 스트림으로 보내집니다.</target>
        </trans-unit>
        <trans-unit id="114413bb4f72c7de7da72bbb1c49201af1736906" translate="yes" xml:space="preserve">
          <source>, or use multiple</source>
          <target state="translated">또는 여러 개 사용</target>
        </trans-unit>
        <trans-unit id="b9de57a8368cc0be9e412c8156861efc31380ddb" translate="yes" xml:space="preserve">
          <source>, or with</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="42fd3001192750dfc840e657f931b977a68bb8c9" translate="yes" xml:space="preserve">
          <source>, otherwise GCC will allow some non-ISO C++ features as extensions. See &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Warning Options&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 GCC는 일부 비 ISO C ++ 기능을 확장으로 허용합니다. &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;경고 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4efb03b3f7239b259ed4938692deb4cfeedb504b" translate="yes" xml:space="preserve">
          <source>, otherwise compile code the same as</source>
          <target state="translated">그렇지 않으면 다음과 동일한 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9f722d4c3e2124084fb81e45309c5309f6a0001c" translate="yes" xml:space="preserve">
          <source>, otherwise it takes the name of the input file, removes any directory components and suffix, and applies a</source>
          <target state="translated">그렇지 않으면 입력 파일의 이름을 사용하고 디렉토리 구성 요소와 접미사를 제거하고</target>
        </trans-unit>
        <trans-unit id="2fdbcf702ccfe5b30e705c3cbb40781443600e37" translate="yes" xml:space="preserve">
          <source>, permits passing pointers to structures with anonymous fields to functions that expect pointers to elements of the type of the field, and permits referring to anonymous fields declared using a typedef. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details. This is only supported for C, not C++.</source>
          <target state="translated">, 익명 필드를 가진 구조체에 대한 포인터를 필드 유형의 요소에 대한 포인터를 기대하는 함수에 전달하고 typedef를 사용하여 선언 된 익명 필드를 참조 할 수 있습니다. 자세한 내용 &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;은 structs / unions 내의 Unnamed struct / union 필드&lt;/a&gt; 를 참조하십시오. 이것은 C ++가 아닌 C에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="efd6d891db77cd5a6b32757579c81c42fb30122c" translate="yes" xml:space="preserve">
          <source>, predefinition of command line and most builtin macros is disabled. Macros such as &lt;code&gt;__LINE__&lt;/code&gt;, which are contextually dependent, are handled normally. This enables compilation of files previously preprocessed with &lt;code&gt;-E -fdirectives-only&lt;/code&gt;.</source>
          <target state="translated">, 명령 줄 및 대부분의 내장 매크로의 사전 정의가 비활성화되어 있습니다. 상황에 따라 달라지는 &lt;code&gt;__LINE__&lt;/code&gt; 과 같은 매크로 는 정상적으로 처리됩니다. 이를 통해 이전에 &lt;code&gt;-E -fdirectives-only&lt;/code&gt; 로 사전 처리 된 파일을 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="415eb48854af3a6a56014b4f60405d06dc891dcf" translate="yes" xml:space="preserve">
          <source>, preprocessing is limited to the handling of directives such as &lt;code&gt;#define&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, and &lt;code&gt;#error&lt;/code&gt;. Other preprocessor operations, such as macro expansion and trigraph conversion are not performed. In addition, the</source>
          <target state="translated">사전 처리는 &lt;code&gt;#define&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; 및 &lt;code&gt;#error&lt;/code&gt; 와 같은 지시문 처리로 제한됩니다 . 매크로 확장 및 트리 그래프 변환과 같은 다른 전 처리기 작업은 수행되지 않습니다. 또한</target>
        </trans-unit>
        <trans-unit id="b0bfd8775564ba9a386c05bd93a1f015b33ee831" translate="yes" xml:space="preserve">
          <source>, rather than Newlib.</source>
          <target state="translated">Newlib 대신에.</target>
        </trans-unit>
        <trans-unit id="382a63ed22ee293d350fb2ac1e8963f3b5af303b" translate="yes" xml:space="preserve">
          <source>, record any references to them in the result of the compilation as if the files resided in directory</source>
          <target state="translated">파일이 디렉토리에있는 것처럼 컴파일 결과에 참조를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="5596d7a7c540b768140fc8e0589b7003ee3db084" translate="yes" xml:space="preserve">
          <source>, record debugging information describing them as if the files resided in directory</source>
          <target state="translated">파일이 디렉토리에있는 것처럼이를 설명하는 디버깅 정보를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="a257c20cceb3376fd5c996cb7d116ca7848455c5" translate="yes" xml:space="preserve">
          <source>, regardless of the order of the options on the command line.</source>
          <target state="translated">명령 행의 옵션 순서에 관계없이</target>
        </trans-unit>
        <trans-unit id="12d501570d9936bde7534d9241ac0db13d604a8d" translate="yes" xml:space="preserve">
          <source>, respectively.</source>
          <target state="translated">각각.</target>
        </trans-unit>
        <trans-unit id="5bb4669872f9d1911aecb2ff977742a0d6c1e477" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af7e2fbf0415afcfbd5453b3d8148325e06b13e2" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Optimize Options&lt;/a&gt;), and if GNU Binutils support &lt;a href=&quot;https://sourceware.org/PR21683&quot;&gt;PR21683&lt;/a&gt;.</source>
          <target state="translated">GNU Binutils가 &lt;a href=&quot;https://sourceware.org/PR21683&quot;&gt;PR21683을&lt;/a&gt; 지원하는 경우 &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;최적화 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f23b4d8e2af9ccece653777203cc633cc8613584" translate="yes" xml:space="preserve">
          <source>, since floating-point division by zero can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">부동 소수점을 0으로 나누면 무한대와 NaN을 얻는 합법적 인 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48743acb3c50007ccd27cb69772fa5958efec8aa" translate="yes" xml:space="preserve">
          <source>, since it usually increases code size.</source>
          <target state="translated">일반적으로 코드 크기가 증가하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1142d002e80f61cb8906ee6ff983e94d926cb47b" translate="yes" xml:space="preserve">
          <source>, since slightly larger code is generated when</source>
          <target state="translated">때 약간 더 큰 코드가 생성되므로</target>
        </trans-unit>
        <trans-unit id="8489f86e2aa5976abda688075895e8c118642126" translate="yes" xml:space="preserve">
          <source>, since there are errors enabled by this option and not enabled by the latter and vice versa.</source>
          <target state="translated">이 옵션에 의해 활성화 된 오류가 있고,이 옵션에 의해 활성화 된 오류는 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="94ac58ccd302f428780f22989ed14b633a5da687" translate="yes" xml:space="preserve">
          <source>, so a lot of code can be recompiled with</source>
          <target state="translated">많은 코드를 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7164620902b23499669819ffa895173a5aa25027" translate="yes" xml:space="preserve">
          <source>, so that the libraries leave more room for the main program.</source>
          <target state="translated">라이브러리는 기본 프로그램을위한 더 많은 공간을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="68680f64842e4482b6c97e2407b39d9d533a072a" translate="yes" xml:space="preserve">
          <source>, specifies a file to write the dependencies to. If no</source>
          <target state="translated">, 종속성을 작성할 파일을 지정합니다. 그렇지 않다면</target>
        </trans-unit>
        <trans-unit id="3a902c43a69a00e9f2cfce60ce9290e659912859" translate="yes" xml:space="preserve">
          <source>, strip mine each loop in the loop nest by a given number of iterations. The strip length can be changed using the</source>
          <target state="translated">주어진 반복 횟수만큼 루프 둥지의 각 루프를 제거하십시오. 스트립 길이는</target>
        </trans-unit>
        <trans-unit id="3b9b4086b33c372adc8859729f0f2fda99df10f0" translate="yes" xml:space="preserve">
          <source>, such that it is linked with the shared</source>
          <target state="translated">공유와 연결되도록</target>
        </trans-unit>
        <trans-unit id="a3ab4b910db14b52efa18ff9cf025cb41c0d39a2" translate="yes" xml:space="preserve">
          <source>, tells the compiler to not pass</source>
          <target state="translated">컴파일러에게 전달하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="a9bcafc2113daaac812f1518346b8bb3f4ad5920" translate="yes" xml:space="preserve">
          <source>, the</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="2b63f3bf562cc464d10a5f414760217b5e6be781" translate="yes" xml:space="preserve">
          <source>, the &lt;code&gt;gcc&lt;/code&gt; program instead returns with the numerically highest error produced by any phase returning an error indication. The C, C++, and Fortran front ends return 4 if an internal compiler error is encountered.</source>
          <target state="translated">상기 &lt;code&gt;gcc&lt;/code&gt; 프로그램 대신에 에러 표시를 리턴 어느 단계에 의해 생성 된 수치 높은 오류로 리턴한다. 내부 컴파일러 오류가 발생하면 C, C ++ 및 Fortran 프런트 엔드는 4를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac3ce9581fef6bdbd359e9f45a5a99604a8cf6c7" translate="yes" xml:space="preserve">
          <source>, the Pentium Pro instruction set is used, so the code runs on all i686 family chips. When used with</source>
          <target state="translated">Pentium Pro 명령어 세트가 사용되므로 모든 i686 제품군 칩에서 코드가 실행됩니다. 함께 사용될 때</target>
        </trans-unit>
        <trans-unit id="fa194889cd144e6bbf27af39f845ba26d861d086" translate="yes" xml:space="preserve">
          <source>, the command</source>
          <target state="translated">, 명령</target>
        </trans-unit>
        <trans-unit id="e92a035b4927c9fce1d07fc2c810360ae211e587" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Oracle M8 chips.</source>
          <target state="translated">컴파일러는 Oracle M8 칩에 맞게 추가로 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="6a39a5fbbad7fe0ed957cc74cab0d30798133fa7" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Oracle SPARC M7 chips. With</source>
          <target state="translated">컴파일러는 Oracle SPARC M7 칩에 대해 추가로 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="1ac0c6c3a7e57517af6c1fd4d8c2f4ab55e3234b" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Sun UltraSPARC T1 chips. With</source>
          <target state="translated">컴파일러는 Sun UltraSPARC T1 칩에 대해 추가로 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="a5cb47d14afa8a18feae7e3577d1c2f7f39aa3a3" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Sun UltraSPARC T2 chips. With</source>
          <target state="translated">컴파일러는 Sun UltraSPARC T2 칩에 맞게 추가로 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="4372efad9448f8e7c66d51c59cc8061f932390e7" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Sun UltraSPARC T3 chips. With</source>
          <target state="translated">컴파일러는 추가로 Sun UltraSPARC T3 칩에 맞게 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="04c02ac5cdda7b9f9e1bd562613ee0b12cbaa11d" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for Sun UltraSPARC T4 chips. With</source>
          <target state="translated">컴파일러는 추가로 Sun UltraSPARC T4 칩에 맞게 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="fe8343d3123cbd58bc0f4cfc4dca465aa9ceca09" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the Cypress CY7C602 chip, as used in the SPARCStation/SPARCServer 3xx series. This is also appropriate for the older SPARCStation 1, 2, IPX etc.</source>
          <target state="translated">컴파일러는 SPARCStation / SPARCServer 3xx 시리즈에서 사용되는 Cypress CY7C602 칩에 맞게 추가로 최적화합니다. 이것은 이전 SPARCStation 1, 2, IPX 등에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1e916d47d43e0128f6a11b321665069d28bed521" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the Fujitsu MB86930 chip, which is the original SPARClite, with no FPU. With</source>
          <target state="translated">또한 컴파일러는 FPU없이 원래 SPARClite 인 Fujitsu MB86930 칩에 맞게이를 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="59e587eb3c489ffd26283628358ebe3722a023bf" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the Fujitsu MB86934 chip, which is the more recent SPARClite with FPU.</source>
          <target state="translated">컴파일러는 FPU가 포함 된 최신 SPARClite 인 Fujitsu MB86934 칩에 맞게 추가로 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="7d99095dcd3228954410a8eb6f64d85dbeae0243" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the Sun UltraSPARC I/II/IIi chips. With</source>
          <target state="translated">컴파일러는 추가로 Sun UltraSPARC I / II / IIi 칩에 맞게 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="841fa825f3bff788d457becd582c25c57258d89d" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips. With</source>
          <target state="translated">컴파일러는 추가로 Sun UltraSPARC III / III + / IIIi / IIIi + / IV / IV + 칩에 맞게 최적화합니다. 와</target>
        </trans-unit>
        <trans-unit id="858687102dd55ff8fc87c92e71e8832cd4e35c97" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and 2000 series.</source>
          <target state="translated">컴파일러는 SPARCStation 10, 1000 및 2000 시리즈에서 사용되는 SuperSPARC 칩에 맞게 추가로 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="aecd3e58e2014147bddadb0ae32ec7d9dee9a11b" translate="yes" xml:space="preserve">
          <source>, the compiler additionally optimizes it for the TEMIC SPARClet chip.</source>
          <target state="translated">컴파일러는 TEMIC SPARClet 칩에 대해 추가로 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="a86eac710e38d27a598505cf74f39473202849dd" translate="yes" xml:space="preserve">
          <source>, the compiler assumes that structures should have 8-byte alignment. This enables the use of pairs of &lt;code&gt;ldd&lt;/code&gt; and &lt;code&gt;std&lt;/code&gt; instructions for copies in structure assignment, in place of twice as many &lt;code&gt;ld&lt;/code&gt; and &lt;code&gt;st&lt;/code&gt; pairs. However, the use of this changed alignment directly violates the SPARC ABI. Thus, it&amp;rsquo;s intended only for use on targets where the developer acknowledges that their resulting code is not directly in line with the rules of the ABI.</source>
          <target state="translated">컴파일러는 구조에 8 바이트 정렬이 있어야한다고 가정합니다. 이를 통해 &lt;code&gt;ld&lt;/code&gt; 및 &lt;code&gt;st&lt;/code&gt; 쌍 의 두 배 대신 구조 할당에서 사본에 &lt;code&gt;ldd&lt;/code&gt; 및 &lt;code&gt;std&lt;/code&gt; 명령어 쌍을 사용할 수 있습니다 . 그러나이 변경된 정렬을 사용하면 SPARC ABI를 직접 위반합니다. 따라서 개발자가 결과 코드가 ABI의 규칙과 직접적으로 일치하지 않는다는 것을 인정하는 대상에서만 사용하도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e95df22d51cc97b41caac28bfc5b9326fa6b5f0" translate="yes" xml:space="preserve">
          <source>, the compiler could use the extended instruction sets even if the built-ins are not used explicitly in the program. For this reason, applications that perform run-time CPU detection must compile separate files for each supported architecture, using the appropriate flags. In particular, the file containing the CPU detection code should be compiled without these options.</source>
          <target state="translated">내장 프로그램이 프로그램에서 명시 적으로 사용되지 않더라도 컴파일러는 확장 명령어 세트를 사용할 수 있습니다. 이러한 이유로 런타임 CPU 감지를 수행하는 애플리케이션은 적절한 플래그를 사용하여 지원되는 각 아키텍처마다 별도의 파일을 컴파일해야합니다. 특히 CPU 감지 코드가 포함 된 파일은 이러한 옵션없이 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffdc7f53e47734d83c7e14a48d5c0f0132cfcca4" translate="yes" xml:space="preserve">
          <source>, the compiler does not generate save/restore instructions and uses a &amp;ldquo;flat&amp;rdquo; or single register window model. This model is compatible with the regular register window model. The local registers and the input registers (0&amp;ndash;5) are still treated as &amp;ldquo;call-saved&amp;rdquo; registers and are saved on the stack as needed.</source>
          <target state="translated">컴파일러는 저장 / 복원 명령어를 생성하지 않으며 &quot;플랫&quot;또는 단일 레지스터 창 모델을 사용합니다. 이 모델은 일반 레지스터 창 모델과 호환됩니다. 로컬 레지스터와 입력 레지스터 (0-5)는 여전히 &quot;호출 저장&quot;레지스터로 취급되며 필요에 따라 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="69e78890820dcd7f981ed8ef33a3a8c043e8ebf1" translate="yes" xml:space="preserve">
          <source>, the compiler generates checking code in functions returning structures or unions to detect size mismatches between the two sides of function calls, as per the 32-bit ABI.</source>
          <target state="translated">컴파일러는 32 비트 ABI에 따라 함수 호출의 두 측면 사이의 크기 불일치를 감지하기 위해 구조 또는 공용체를 리턴하는 함수에서 검사 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="428fba5d393e56eabf7998e3fc175cb944f8ad09" translate="yes" xml:space="preserve">
          <source>, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time.</source>
          <target state="translated">컴파일러는 컴파일 시간이 많이 걸리는 최적화를 수행하지 않고 코드 크기와 실행 시간을 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="daf303df50714bc573b14a3f51a8300fe4c948bd" translate="yes" xml:space="preserve">
          <source>, the declaration of the function is diagnosed as well.</source>
          <target state="translated">함수의 선언도 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="3026241c180440d0e9f94ba76190f2ca96852cd8" translate="yes" xml:space="preserve">
          <source>, the default for GCC 5.1.</source>
          <target state="translated">, GCC 5.1의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="692722d8e42a4b8d2a2c2032a7f0a3bed13e40ff" translate="yes" xml:space="preserve">
          <source>, the default for GCC 5.2.</source>
          <target state="translated">, GCC 5.2의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c8c05f1d08fd7c0969883bbc9f062051a4b0a7b0" translate="yes" xml:space="preserve">
          <source>, the default for GCC 6.1.</source>
          <target state="translated">, GCC 6.1의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b6fc73f89ebea91385b893380c45e9780bb3d84a" translate="yes" xml:space="preserve">
          <source>, the default is &amp;ldquo;on&amp;rdquo; for ColdFire architectures and &amp;ldquo;off&amp;rdquo; for M680x0 architectures. Otherwise, the default is taken from the target CPU (either the default CPU, or the one specified by</source>
          <target state="translated">ColdFire 아키텍처의 경우 기본값은 &quot;on&quot;이고 M680x0 아키텍처의 경우 &quot;off&quot;입니다. 그렇지 않으면 대상 CPU (기본 CPU 또는</target>
        </trans-unit>
        <trans-unit id="772f6bbc0f9a324fca50c11ff8483df72f8e4584" translate="yes" xml:space="preserve">
          <source>, the default, causes the extra information to be omitted and is useful when comparing two assembler files.</source>
          <target state="translated">기본값 인 추가 정보는 생략되며 두 어셈블러 파일을 비교할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b4cd5e116a47d28493b581dcab5dad877c0c34fd" translate="yes" xml:space="preserve">
          <source>, the files with the profile feedback can fail to match the source file and GCC cannot use the profile feedback information. By default, this warning is enabled and is treated as an error.</source>
          <target state="translated">, 프로필 피드백이있는 파일이 소스 파일과 일치하지 않아 GCC가 프로필 피드백 정보를 사용할 수 없습니다. 기본적으로이 경고는 활성화되어 있으며 오류로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="49cbd8fc1988c38d8b75e8d548b8bb8d2f822f61" translate="yes" xml:space="preserve">
          <source>, the final executable will try to create the data file</source>
          <target state="translated">, 최종 실행 파일은 데이터 파일을 만들려고합니다</target>
        </trans-unit>
        <trans-unit id="815a1ce8e00e3334738617eb00c2c9266ebafe03" translate="yes" xml:space="preserve">
          <source>, the generated object file is larger than a regular object file because it contains GIMPLE bytecodes and the usual final code (see</source>
          <target state="translated">, 생성 된 객체 파일은 GIMPLE 바이트 코드와 일반적인 최종 코드를 포함하기 때문에 일반 객체 파일보다 큽니다 (참조</target>
        </trans-unit>
        <trans-unit id="93c87c2482200581ada6b793353d563f5ec679ac" translate="yes" xml:space="preserve">
          <source>, the library that comes with GCC, with</source>
          <target state="translated">, GCC와 함께 제공되는 라이브러리</target>
        </trans-unit>
        <trans-unit id="b7a1837ffa642bc6e9d87b5530ec03163e746678" translate="yes" xml:space="preserve">
          <source>, the literals are interspersed in the text section in order to keep them as close as possible to their references. This may be necessary for large assembly files. Literals for each function are placed right before that function.</source>
          <target state="translated">, 리터럴은 가능한 한 참조에 가깝게 유지하기 위해 텍스트 섹션에 산재되어 있습니다. 큰 조립품 파일에 필요할 수 있습니다. 각 기능에 대한 리터럴은 해당 기능 바로 앞에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="3874c30a889fc4550891f54d685ec72df06fd5db" translate="yes" xml:space="preserve">
          <source>, the normal function prologue and epilogue which set up the stack frame are omitted and no return instructions or return sequences are generated in the code. Use this option only together with visual inspection of the compiled code: no warnings or errors are generated when call-saved registers must be saved, or storage for local variables needs to be allocated.</source>
          <target state="translated">스택 프레임을 설정하는 정규 함수 프롤로그 및 에필로그는 생략되고 리턴 코드 또는 리턴 시퀀스는 코드에서 생성되지 않는다. 이 옵션은 컴파일 된 코드를 육안으로 검사 할 때만 사용하십시오. 호출 저장 레지스터를 저장하거나 로컬 변수에 대한 스토리지를 할당해야 할 때 경고 나 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50289040a36706f3a23d65e893eec4854af6d2e0" translate="yes" xml:space="preserve">
          <source>, the object file for</source>
          <target state="translated">에 대한 객체 파일</target>
        </trans-unit>
        <trans-unit id="4f57e72cae764cab6dfaa8a6b984d61c8fcfcea0" translate="yes" xml:space="preserve">
          <source>, the profiling code first attempts to read in an existing</source>
          <target state="translated">프로파일 링 코드는 먼저 기존 코드를 읽으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c6a1f5530e3d7b4711a9e708a49cfd47c423f4f7" translate="yes" xml:space="preserve">
          <source>, the rules for</source>
          <target state="translated">에 대한 규칙</target>
        </trans-unit>
        <trans-unit id="8699bd16ca7024ea46de08dda1f9050558b25386" translate="yes" xml:space="preserve">
          <source>, the sign of the remainder follows the sign of the dividend. Both methods are arithmetically valid, the latter being almost exclusively used.</source>
          <target state="translated">나머지의 부호는 배당금의 부호를 따릅니다. 두 방법 모두 산술적으로 유효하며 후자는 거의 독점적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="29acbd1d62bfd215ea629596b9c554886b91017d" translate="yes" xml:space="preserve">
          <source>, the single-application/dual-core programming model is used. In this model, the main function of Core B should be named as &lt;code&gt;coreb_main&lt;/code&gt;.</source>
          <target state="translated">단일 응용 프로그램 / 듀얼 코어 프로그래밍 모델이 사용됩니다. 이 모델에서 코어 B의 주요 기능은 &lt;code&gt;coreb_main&lt;/code&gt; 으로 이름이 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="667fda1f9e48385c0210894fbc7037623d1a4111" translate="yes" xml:space="preserve">
          <source>, the structure is aligned to a 1-byte boundary and is 1 byte in size.</source>
          <target state="translated">구조는 1 바이트 경계에 정렬되며 크기는 1 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="e189049326051591313d1c5688fafbf491aeaf0f" translate="yes" xml:space="preserve">
          <source>, then</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="7ee186a18ff42c73f0354082e8ef090089e5effc" translate="yes" xml:space="preserve">
          <source>, then running &lt;code&gt;gcov&lt;/code&gt; on the file</source>
          <target state="translated">파일 에서 &lt;code&gt;gcov&lt;/code&gt; 실행</target>
        </trans-unit>
        <trans-unit id="6fd5514ee17d5d19d7515ba2ea9a77e61ac8a324" translate="yes" xml:space="preserve">
          <source>, then the dependencies are written to</source>
          <target state="translated">그런 다음 종속성이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b8fa8d9a1275fa5b175ea2e48216447ff905c8" translate="yes" xml:space="preserve">
          <source>, then the precompiled header file is used if possible, and the original header is used otherwise.</source>
          <target state="translated">그러면 사전 컴파일 된 헤더 파일이 가능한 경우 사용되고 원본 헤더는 그렇지 않은 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="564c028c79c98b2596f511c52750e11cf8ed8aa0" translate="yes" xml:space="preserve">
          <source>, then you must disable instrumentation on all functions that are part of the instrumentation framework with the attribute &lt;code&gt;patchable_function_entry (0)&lt;/code&gt; to prevent recursion.</source>
          <target state="translated">그런 다음 재귀를 방지하기 위해 &lt;code&gt;patchable_function_entry (0)&lt;/code&gt; 속성을 사용하여 인스 트루먼 테이션 프레임 워크의 일부인 모든 함수에서 인스 트루먼 테이션을 사용 안함으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8d64d7606f91920bd635808a8350a26f4f43160" translate="yes" xml:space="preserve">
          <source>, then:</source>
          <target state="translated">그런 다음 :</target>
        </trans-unit>
        <trans-unit id="18b1ddc03f8c4f7114c6642a980a4266ab4ee91d" translate="yes" xml:space="preserve">
          <source>, there is a small window between the time that the stack pointer is updated and the address of the previous frame is stored, which means code that walks the stack frame across interrupts or signals may get corrupted data.</source>
          <target state="translated">스택 포인터가 업데이트되는 시간과 이전 프레임의 주소가 저장되는 시간 사이에 작은 창이 있습니다. 즉, 인터럽트를 가로 질러 스택 프레임을 걷는 코드가 신호를 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50141233a4a222a2ad6dabbea63d30e01eee8b71" translate="yes" xml:space="preserve">
          <source>, there may not be much stack space available for the latter code to run. If compiling all code, including library code, with</source>
          <target state="translated">후자의 코드를 실행할 수있는 스택 공간이 많지 않을 수 있습니다. 라이브러리 코드를 포함하여 모든 코드를 컴파일하는 경우</target>
        </trans-unit>
        <trans-unit id="326afd2af91c7cd70009eaf4d8cb90f6936cddbc" translate="yes" xml:space="preserve">
          <source>, they invoke &lt;code&gt;rdval&lt;/code&gt; and &lt;code&gt;wrval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rdval&lt;/code&gt; 및 &lt;code&gt;wrval&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="4b91ca3210bb29fc4dfea84458ae04652f30e451" translate="yes" xml:space="preserve">
          <source>, this causes the compiler to keep track of the total number of virtual calls it encounters and the number of verifications it inserts. It also counts the number of calls to certain run-time library functions that it inserts and logs this information for each compilation unit. The compiler writes this information to a file named</source>
          <target state="translated">이로 인해 컴파일러는 발생하는 총 가상 호출 수와 삽입하는 확인 수를 추적합니다. 또한 각 컴파일 단위에 대해이 정보를 삽입하고 기록하는 특정 런타임 라이브러리 함수에 대한 호출 수를 계산합니다. 컴파일러는이 정보를 이름이 지정된 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f01188017d3c123848733d9fd6dfb22206ff1e87" translate="yes" xml:space="preserve">
          <source>, this is what you see when you use the basic &lt;code&gt;gcov&lt;/code&gt; facility:</source>
          <target state="translated">기본 &lt;code&gt;gcov&lt;/code&gt; 기능 을 사용할 때 다음과 같이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e5bfa587207f7380ee4c3bb705530423614bbd5" translate="yes" xml:space="preserve">
          <source>, this optimization can be performed by the assembler and the linker alone without help from the compiler.</source>
          <target state="translated">이 최적화는 컴파일러의 도움없이 어셈블러와 링커만으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d459e76328a6d385857ebd663c3475f17a65af0" translate="yes" xml:space="preserve">
          <source>, this option has no effect.</source>
          <target state="translated">이 옵션은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d3c6490f4076f4eee8ed0cae6ad3221f0b61401" translate="yes" xml:space="preserve">
          <source>, this option increases both compilation time and the performance of the generated code.</source>
          <target state="translated">이 옵션은 컴파일 시간과 생성 된 코드의 성능을 모두 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="d8fd13fa8750caa49540ff0768629b8cca833a35" translate="yes" xml:space="preserve">
          <source>, this option instructs the compiler to add code to gather information about values of expressions.</source>
          <target state="translated">이 옵션은 컴파일러에게 표현식 값에 대한 정보를 수집하는 코드를 추가하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="429b287e8d0f22a8e7c02112f3cd1eb77566d212" translate="yes" xml:space="preserve">
          <source>, those directories are searched for all &amp;lsquo;</source>
          <target state="translated">해당 디렉토리는 모두 '</target>
        </trans-unit>
        <trans-unit id="4d73a0b8dae23d131af59205c0f51492334fc033" translate="yes" xml:space="preserve">
          <source>, those options take precedence over the appropriate part of this option.</source>
          <target state="translated">해당 옵션이이 옵션의 해당 부분보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="32971533b36b13d8be7306c0655e0cba1b20c8f9" translate="yes" xml:space="preserve">
          <source>, though this could be supported for 68020 and higher processors.</source>
          <target state="translated">68020 이상의 프로세서에서 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0255e1660d4339b2ecf6c91d1ccb336078135f" translate="yes" xml:space="preserve">
          <source>, to improve optimizations based on the number of times each branch was taken. When a program compiled with</source>
          <target state="translated">, 각 분기가 수행 된 횟수를 기반으로 최적화를 개선합니다. 프로그램이</target>
        </trans-unit>
        <trans-unit id="ac44f21a3de295129d64b5a774011adcf28ae140" translate="yes" xml:space="preserve">
          <source>, turn on other options, such as</source>
          <target state="translated">와 같은 다른 옵션을 켭니다.</target>
        </trans-unit>
        <trans-unit id="446f5cf91d366f03eddeeaf354f183b84e577619" translate="yes" xml:space="preserve">
          <source>, type-punning is allowed, provided the memory is accessed through the union type. So, the code above works as expected. See &lt;a href=&quot;structures-unions-enumerations-and-bit_002dfields-implementation#Structures-unions-enumerations-and-bit_002dfields-implementation&quot;&gt;Structures unions enumerations and bit-fields implementation&lt;/a&gt;. However, this code might not:</source>
          <target state="translated">메모리가 공용체 유형을 통해 액세스되는 경우 유형 제거가 허용됩니다. 따라서 위의 코드는 예상대로 작동합니다. &lt;a href=&quot;structures-unions-enumerations-and-bit_002dfields-implementation#Structures-unions-enumerations-and-bit_002dfields-implementation&quot;&gt;구조체 유니온 열거 및 비트 필드 구현을&lt;/a&gt; 참조하십시오 . 그러나이 코드는 :</target>
        </trans-unit>
        <trans-unit id="3eb3379edebd14fb24a32aa3130ec6c35394eeb8" translate="yes" xml:space="preserve">
          <source>, unless</source>
          <target state="translated">을 제외하고</target>
        </trans-unit>
        <trans-unit id="ac2274935835d1d79884f7f27c0ba51679421f90" translate="yes" xml:space="preserve">
          <source>, used in addition to</source>
          <target state="translated">에 추가로 사용</target>
        </trans-unit>
        <trans-unit id="a56bae807872361f6ddda9c5d7baa9d2dc802cb0" translate="yes" xml:space="preserve">
          <source>, warnings are given about format features not in the selected standard version (but not for &lt;code&gt;strfmon&lt;/code&gt; formats, since those are not in any version of the C standard). See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">, 선택한 표준 버전이 아닌 형식 기능에 대한 경고가 표시됩니다 (그러나 C 표준 버전이 없으므로 &lt;code&gt;strfmon&lt;/code&gt; 형식에는 해당되지 않습니다). &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;C 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88a2f4ea153e2f7cf779ca618429b6ec5801bf5c" translate="yes" xml:space="preserve">
          <source>, where &lt;var&gt;N&lt;/var&gt; is a number in the range 0 to 9, then it is replaced by</source>
          <target state="translated">여기서 &lt;var&gt;N&lt;/var&gt; 은 0에서 9 사이의 숫자이며 다음과 같이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="4756ea8500a07b5870d68c2dc4135f0e24797100" translate="yes" xml:space="preserve">
          <source>, where the &lt;var&gt;source-file&lt;/var&gt; component is the final filename part and the &lt;var&gt;md5&lt;/var&gt; component is calculated from the full mangled name that would have been used otherwise. The option is an alternative to the &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; on systems which have a filesystem limit.</source>
          <target state="translated">여기서 &lt;var&gt;source-file&lt;/var&gt; 구성 요소는 최종 파일 이름 부분이고 &lt;var&gt;md5&lt;/var&gt; 구성 요소는 그렇지 않은 경우 사용 된 전체 맹 글링 된 이름에서 계산됩니다. 이 옵션은 파일 시스템 한계가있는 시스템 에서 &lt;var&gt;&amp;ndash;preserve-paths&lt;/var&gt; 의 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="230f86319e28b7455f7d53c3723a16687bfdfc57" translate="yes" xml:space="preserve">
          <source>, where the permissible values for &lt;var&gt;cpu&lt;/var&gt; are the same as those available for</source>
          <target state="translated">&lt;var&gt;cpu&lt;/var&gt; 에 허용되는 값은 사용 가능한 값 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2254d7466842a921ec0e93daa8a81e8d02ab2cfb" translate="yes" xml:space="preserve">
          <source>, which GCC rejects as an invalid option in any actual compilation (rather than preprocessing, assembly or linking). To get just a warning, setting &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; to &amp;lsquo;</source>
          <target state="translated">GCC는 사전 처리, 어셈블리 또는 링크가 아닌 실제 컴파일에서 잘못된 옵션으로 거부합니다. 경고 만 받으려면 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; 를 '</target>
        </trans-unit>
        <trans-unit id="e989e4cf45165ab34bb6bb136c281cdf9203ee24" translate="yes" xml:space="preserve">
          <source>, which allows GCC to inline most constant-sized copies.</source>
          <target state="translated">GCC는 일정한 크기의 사본을 대부분 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46699ca278faeacb3ea5e4e0e6aa330bfab42c0d" translate="yes" xml:space="preserve">
          <source>, which applies only to functions that are declared using the &lt;code&gt;dllexport&lt;/code&gt; attribute or declspec. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dllexport&lt;/code&gt; 속성 또는 declspec을 사용하여 선언 된 함수에만 적용됩니다 . &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd54cb18e1d323986e9f863c779e1f697545e855" translate="yes" xml:space="preserve">
          <source>, which can be disabled with</source>
          <target state="translated">로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b72facf8cc43915080a973ea5dda407d52591f" translate="yes" xml:space="preserve">
          <source>, which causes the compiler to recognize the same Objective-C language syntax recognized by GCC 4.0, and to produce an error if one of the new features is used.</source>
          <target state="translated">컴파일러는 GCC 4.0에서 인식 한 것과 동일한 Objective-C 언어 구문을 인식하고 새 기능 중 하나가 사용되면 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2de0e70e7120f7592acf3b303b06e39b57acee0c" translate="yes" xml:space="preserve">
          <source>, which disables the dumping of the final representation and the second compilation, preventing even &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; from taking effect.</source>
          <target state="translated">최종 표현 및 두 번째 컴파일의 덤프를 비활성화하여 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; 도 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10e713fcad2fa12372ddfaea05c7df9060097043" translate="yes" xml:space="preserve">
          <source>, which implies</source>
          <target state="translated">을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f2f82387a05712f0b55c15013dd25fcda2c6d51f" translate="yes" xml:space="preserve">
          <source>, which is also one of the effective C++ recommendations. However, the check is extended to warn about the lack of virtual destructor in accessible non-polymorphic bases classes too.</source>
          <target state="translated">또한 효과적인 C ++ 권장 사항 중 하나입니다. 그러나 액세스 가능한 비다 형성베이스 클래스에서도 가상 소멸자가 없다는 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8d738471a73ffb8b526b91636ca0ef2885217f80" translate="yes" xml:space="preserve">
          <source>, which is enabled by</source>
          <target state="translated">에 의해 활성화되는</target>
        </trans-unit>
        <trans-unit id="4502a0e761188e5c8233a9411a8864fc6121c93b" translate="yes" xml:space="preserve">
          <source>, which is enabled by default at</source>
          <target state="translated">에서 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b03cadb73bdb5b121b37c664acf4102564be1aa" translate="yes" xml:space="preserve">
          <source>, which is on by default at</source>
          <target state="translated">기본적으로 켜져있는</target>
        </trans-unit>
        <trans-unit id="65e8924d8e634e11e3e3c8423a5c0bf3ec344ab3" translate="yes" xml:space="preserve">
          <source>, which is still supported, because it does not use shell special characters.</source>
          <target state="translated">쉘 특수 문자를 사용하지 않기 때문에 여전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce4b030ad0c9a1e1625f5d28ae9b41b1de635be" translate="yes" xml:space="preserve">
          <source>, which is the negative form of</source>
          <target state="translated">의 부정적인 형태 인</target>
        </trans-unit>
        <trans-unit id="6ec90d1ff3ca86f96f89ef39059823f9658e3e1e" translate="yes" xml:space="preserve">
          <source>, which may turn on further options, such as</source>
          <target state="translated">와 같은 추가 옵션을 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="082e8aad8694962e494d7d77884c7dfe5926bb26" translate="yes" xml:space="preserve">
          <source>, which merely tunes the generated code for the specified &lt;var&gt;cpu-type&lt;/var&gt;,</source>
          <target state="translated">지정된 &lt;var&gt;cpu-type&lt;/var&gt; 에 대해 생성 된 코드 만 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="f59e35e5dc78b628f6809a4752d27ac48bb1f008" translate="yes" xml:space="preserve">
          <source>, which must come from a separate C library implementation. Because of this the GNU C compiler does not define macro &lt;code&gt;__STDC_DEC_FP__&lt;/code&gt; to indicate that the implementation conforms to the technical report.</source>
          <target state="translated">별도의 C 라이브러리 구현에서 가져와야합니다. 이 때문에 GNU C 컴파일러는 구현이 기술 보고서를 준수 함을 나타 내기 위해 매크로 &lt;code&gt;__STDC_DEC_FP__&lt;/code&gt; 를 정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9578678819c9dfdf597d5e59c8c2d0c2abbab9d6" translate="yes" xml:space="preserve">
          <source>, which places literals in a separate section in the output file unless</source>
          <target state="translated">출력 파일에서 별도의 섹션에 리터럴을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="883ecbd65c15c80691c67d2f907d5c7aa2ef6aac" translate="yes" xml:space="preserve">
          <source>, which places literals in a separate section in the output file. This allows the literal pool to be placed in a data RAM/ROM, and it also allows the linker to combine literal pools from separate object files to remove redundant literals and improve code size. With</source>
          <target state="translated">출력 파일의 별도 섹션에 리터럴을 배치합니다. 이를 통해 리터럴 풀을 데이터 RAM / ROM에 배치 할 수 있으며 링커가 별도의 객체 파일에서 리터럴 풀을 결합하여 중복 리터럴을 제거하고 코드 크기를 개선 할 수 있습니다. 와</target>
        </trans-unit>
        <trans-unit id="c4a3cc602f61d3b174e82540c1b8773914df0766" translate="yes" xml:space="preserve">
          <source>, which selects the one-application-per-core programming model. Without</source>
          <target state="translated">코어 당 하나의 응용 프로그램 프로그래밍 모델을 선택합니다. 없이</target>
        </trans-unit>
        <trans-unit id="fa953aa1d2a4a6171c0b8ff19c074aba480082a9" translate="yes" xml:space="preserve">
          <source>, which serves for most needs.</source>
          <target state="translated">대부분의 요구에 부응합니다.</target>
        </trans-unit>
        <trans-unit id="a4f2d97a4a669aa53418fe3954e59b741a6fbbdf" translate="yes" xml:space="preserve">
          <source>, which tells GCC to ignore the attribute for inlined functions unless the</source>
          <target state="translated">는 GCC에 인라인 된 함수의 속성을 무시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="09a4ee6a5e86260dc3373c4048b2d477f6cfcda4" translate="yes" xml:space="preserve">
          <source>, which uses DImode as preferred SIMD mode.</source>
          <target state="translated">DI 모드를 선호하는 SIMD 모드로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f76a67230e5947e1c451436d1b658485d290c47" translate="yes" xml:space="preserve">
          <source>, which uses slower, but IEEE-compliant, software comparisons.</source>
          <target state="translated">느리지 만 IEEE 호환 소프트웨어 비교를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="556b07890fce44f6b6132283c9ed18c93acca22b" translate="yes" xml:space="preserve">
          <source>, which warns about any identifier that is not in the ISO 10646 &amp;ldquo;C&amp;rdquo; normalized form, &lt;em&gt;NFC&lt;/em&gt;. NFC is the recommended form for most uses. It is equivalent to</source>
          <target state="translated">ISO 10646&amp;ldquo;C&amp;rdquo;정규화 형식이 아닌 식별자 인 &lt;em&gt;NFC&lt;/em&gt; 에 대해 경고합니다 . NFC는 대부분의 용도에 권장되는 양식입니다. 그것은</target>
        </trans-unit>
        <trans-unit id="32e2fd6d52e014696dd3032ae2240c099458a6e3" translate="yes" xml:space="preserve">
          <source>, which warns for pointer argument passing or assignment with different signedness.</source>
          <target state="translated">포인터 인자 전달 또는 다른 서명으로 할당에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="8937da5834fe58a4195b5beccef41b08b4ec15c4" translate="yes" xml:space="preserve">
          <source>, which will turn these warnings into errors.</source>
          <target state="translated">이 경고를 오류로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="49d2d73c488287ee47e9e23a7bde89fad3f5a395" translate="yes" xml:space="preserve">
          <source>, while</source>
          <target state="translated">, 동안</target>
        </trans-unit>
        <trans-unit id="c986d828f7d9c3017ba629babae8bb52ae352cf6" translate="yes" xml:space="preserve">
          <source>, while the &amp;lsquo;</source>
          <target state="translated">하면서 '</target>
        </trans-unit>
        <trans-unit id="a9eafc1b8f96cf25eb2fe2756bd682cb2dd19e7d" translate="yes" xml:space="preserve">
          <source>, with the equal sign but without &lt;var&gt;opts&lt;/var&gt;, is equivalent to</source>
          <target state="translated">등호가 있지만 &lt;var&gt;opts&lt;/var&gt; 가 없는 ,는</target>
        </trans-unit>
        <trans-unit id="af1f38353679ab12cc97376ba65588d3f11963ec" translate="yes" xml:space="preserve">
          <source>, without regenerating the profiles. In these cases, the profile feedback data files do not contain any profile feedback information for the newly added function or file respectively. Also, in the case when profile count data (.gcda) files are removed, GCC cannot use any profile feedback information. In all these cases, warnings are issued to inform the user that a profile generation step is due.</source>
          <target state="translated">프로필을 다시 생성하지 않고 이 경우 프로파일 피드백 데이터 파일에는 새로 추가 된 기능 또는 파일에 대한 프로파일 피드백 정보가 각각 포함되지 않습니다. 또한 프로필 개수 데이터 (.gcda) 파일이 제거 된 경우 GCC는 프로필 피드백 정보를 사용할 수 없습니다. 이러한 모든 경우에, 프로파일 생성 단계가 완료되었음을 사용자에게 알리기 위해 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="52a27dd7fbbb21792c986b2b6824d02997f4ba52" translate="yes" xml:space="preserve">
          <source>, you cannot successfully use &amp;lsquo;</source>
          <target state="translated">, '</target>
        </trans-unit>
        <trans-unit id="23ef02ca85f6b31d2291f491abea6f9361c6b954" translate="yes" xml:space="preserve">
          <source>, you may define macros such as:</source>
          <target state="translated">, 다음과 같은 매크로를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a514e8bd0a877b0e43d2a6e4382e7592decbff8f" translate="yes" xml:space="preserve">
          <source>, you must write</source>
          <target state="translated">, 당신은 작성해야합니다</target>
        </trans-unit>
        <trans-unit id="9d27805c306f9f2234b2f442e2c3ae50e7f6b738" translate="yes" xml:space="preserve">
          <source>, you should compile all source code with</source>
          <target state="translated">모든 소스 코드를 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1d8dc37d34101f1c1384f1753d981d4a4b19c09" translate="yes" xml:space="preserve">
          <source>- &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;ddiv&lt;/code&gt; do not always produce the correct result if one of the operands is negative.</source>
          <target state="translated">- 피연산자 중 하나가 음수이면 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;ddiv&lt;/code&gt; 가 항상 올바른 결과를 생성하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e45c9b5be01af93079947067a03297d9a5481bf" translate="yes" xml:space="preserve">
          <source>- &lt;code&gt;dmultu&lt;/code&gt; does not always produce the correct result.</source>
          <target state="translated">- &lt;code&gt;dmultu&lt;/code&gt; 은 항상 올바른 결과를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28d877a0732ecb70d1b0d29bb8a8ac0cbdc46350" translate="yes" xml:space="preserve">
          <source>- &lt;code&gt;ll&lt;/code&gt;/&lt;code&gt;sc&lt;/code&gt; sequences may not behave atomically on revisions prior to 3.0. They may deadlock on revisions 2.6 and earlier.</source>
          <target state="translated">- &lt;code&gt;ll&lt;/code&gt; / &lt;code&gt;sc&lt;/code&gt; 시퀀스는 3.0 이전 버전에 원자 적으로 동작하지 않을 수 있습니다. 2.6 이전 버전에서는 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7a5e7633b9a3ecd053316c95969628f0544ee8" translate="yes" xml:space="preserve">
          <source>- A double-word or a variable shift may give an incorrect result if executed immediately after starting an integer division.</source>
          <target state="translated">-정수 나누기를 시작한 직후에 더블 워드 또는 가변 시프트를 실행하면 잘못된 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9f449d4a2d00742e6bf85e117d9a7f43dbe3ac3" translate="yes" xml:space="preserve">
          <source>- A double-word or a variable shift may give an incorrect result if executed while an integer multiplication is in progress.</source>
          <target state="translated">-정수 곱셈이 진행되는 동안 더블 워드 또는 가변 쉬프트를 실행하면 잘못된 결과가 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37b5a028a0a61d0deef86c72ae21ad424fb6e2b5" translate="yes" xml:space="preserve">
          <source>- An integer division may give an incorrect result if started in a delay slot of a taken branch or a jump.</source>
          <target state="translated">-취한 분기의 지연 슬롯 또는 점프에서 시작하면 정수 나누기가 잘못된 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f936f979fbda07460d599549f1df49a28fec083" translate="yes" xml:space="preserve">
          <source>- C and C++ constructors/destructors called during startup/shutdown.</source>
          <target state="translated">-C / C ++ 생성자 / 소멸자가 시작 / 종료 중에 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="d917511b7e91146ed81c5690753d05a01acc4a7f" translate="yes" xml:space="preserve">
          <source>- Computed goto.</source>
          <target state="translated">-계산 된 고토.</target>
        </trans-unit>
        <trans-unit id="0d12a6b873acc6a7dc115ab6c3ad7b78003c597b" translate="yes" xml:space="preserve">
          <source>- If prologue-save function is used, see</source>
          <target state="translated">-프롤로그 저장 기능을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="f404d504a2d046d8eb074ad64c1ff4564f204db6" translate="yes" xml:space="preserve">
          <source>- If the tools hit a &lt;code&gt;gs()&lt;/code&gt; modifier explained above.</source>
          <target state="translated">-도구가 위에서 설명한 &lt;code&gt;gs()&lt;/code&gt; 수정자를 칠 경우</target>
        </trans-unit>
        <trans-unit id="8544c24c038210d50588d230bbce1287f212a4a7" translate="yes" xml:space="preserve">
          <source>- Switch/case dispatch tables. If you do not want such dispatch tables you can specify the</source>
          <target state="translated">-스위치 / 케이스 디스패치 테이블. 이러한 디스패치 테이블을 원하지 않으면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c2c384d1ba94948e8054a096aa485c0fc12ae5" translate="yes" xml:space="preserve">
          <source>- Taking address of a function or code label.</source>
          <target state="translated">-기능 또는 코드 라벨의 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d7148d1a6b1975ea9d5965578463516097e7671d" translate="yes" xml:space="preserve">
          <source>- The address of a label is taken by means of the &lt;code&gt;gs&lt;/code&gt; modifier (short for &lt;em&gt;generate stubs&lt;/em&gt;) like so:</source>
          <target state="translated">-레이블의 주소는 다음과 같이 &lt;code&gt;gs&lt;/code&gt; 수정 자 ( &lt;em&gt;생성 스텁의&lt;/em&gt; 줄임말)를 &lt;em&gt;사용합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="14b71f67f8e45a2a107c7b5baf13d693803269da" translate="yes" xml:space="preserve">
          <source>- The final location of that label is in a code segment &lt;em&gt;outside&lt;/em&gt; the segment where the stubs are located.</source>
          <target state="translated">-해당 라벨의 최종 위치 는 스텁이있는 세그먼트 &lt;em&gt;외부&lt;/em&gt; 의 코드 세그먼트 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d63ce6052f4c54b84829f0b7d6e03edecb61ff" translate="yes" xml:space="preserve">
          <source>--coverage</source>
          <target state="translated">--coverage</target>
        </trans-unit>
        <trans-unit id="dfd9358562e69140980df6448abfc0be3f647ed5" translate="yes" xml:space="preserve">
          <source>--eh-frame-hdr</source>
          <target state="translated">--eh-frame-hdr</target>
        </trans-unit>
        <trans-unit id="a0a2fefd37a87ad5d2972a5d58e4ea49ca4f3287" translate="yes" xml:space="preserve">
          <source>--enable-auto-import</source>
          <target state="translated">--enable-auto-import</target>
        </trans-unit>
        <trans-unit id="19ec31a0c9370e4ca1653c6162cf9b8a97cdc3b1" translate="yes" xml:space="preserve">
          <source>--enable-cld</source>
          <target state="translated">--enable-cld</target>
        </trans-unit>
        <trans-unit id="45d75f7f8e031e18a19b4310578eef230b726c86" translate="yes" xml:space="preserve">
          <source>--enable-secureplt</source>
          <target state="translated">--enable-secureplt</target>
        </trans-unit>
        <trans-unit id="b4e2ad8851d273611b45f3eaa2ac10287c874b49" translate="yes" xml:space="preserve">
          <source>--export-all</source>
          <target state="translated">--export-all</target>
        </trans-unit>
        <trans-unit id="b9e9f25c1c659f705184cc8a6309a762e9c03bc8" translate="yes" xml:space="preserve">
          <source>--gc-sections</source>
          <target state="translated">--gc-sections</target>
        </trans-unit>
        <trans-unit id="9a8265a5ba2c33881e2717e7581df323a5188174" translate="yes" xml:space="preserve">
          <source>--help</source>
          <target state="translated">--help</target>
        </trans-unit>
        <trans-unit id="88d3346c36ef09ed6fcd3041d7c7328e66a82c3d" translate="yes" xml:space="preserve">
          <source>--help=</source>
          <target state="translated">--help=</target>
        </trans-unit>
        <trans-unit id="83e48cc5863539edea576aba905cb078520ec230" translate="yes" xml:space="preserve">
          <source>--help=param -Q</source>
          <target state="translated">--help = param -Q</target>
        </trans-unit>
        <trans-unit id="142fdbe422fca8e1f0ae90e0fded107cf3324105" translate="yes" xml:space="preserve">
          <source>--help=target</source>
          <target state="translated">--help=target</target>
        </trans-unit>
        <trans-unit id="f4b42adb9ab9af50964868976f43d9f709933d73" translate="yes" xml:space="preserve">
          <source>--json-format</source>
          <target state="translated">--json-format</target>
        </trans-unit>
        <trans-unit id="7ee16625a2f5c7c7f5e47fea7979ac8403afdfad" translate="yes" xml:space="preserve">
          <source>--mlink-relax</source>
          <target state="translated">--mlink-relax</target>
        </trans-unit>
        <trans-unit id="c39e62a5d2c5adeeb352ed945b13bb7e7648c763" translate="yes" xml:space="preserve">
          <source>--param</source>
          <target state="translated">--param</target>
        </trans-unit>
        <trans-unit id="a016b2a12b436dad6a4936a8b629b5250cf51ab2" translate="yes" xml:space="preserve">
          <source>--param &lt;var&gt;name&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">--param &lt;var&gt;name&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2f053c2b9af56f4f6906583b62e669a5032f9c48" translate="yes" xml:space="preserve">
          <source>--param asan-globals=0</source>
          <target state="translated">--param asan-globals = 0</target>
        </trans-unit>
        <trans-unit id="046d1ab314aca2f65f8567874fe4552e8783d6c2" translate="yes" xml:space="preserve">
          <source>--param asan-instrument-reads=0</source>
          <target state="translated">--param asan-instrument-reads = 0</target>
        </trans-unit>
        <trans-unit id="6e97d7ea0a0d892c251b0b7c4fe2f043e62e2970" translate="yes" xml:space="preserve">
          <source>--param asan-instrument-writes=0</source>
          <target state="translated">--param asan-instrument-writes = 0</target>
        </trans-unit>
        <trans-unit id="4ad1600c2aab619b0afbc4bed8fa363a8a811bd2" translate="yes" xml:space="preserve">
          <source>--param asan-instrumentation-with-call-threshold=0</source>
          <target state="translated">--param asan-instrumentation-with-call-threshold = 0</target>
        </trans-unit>
        <trans-unit id="5802988b85eab2d413194fa277ff796a934b235b" translate="yes" xml:space="preserve">
          <source>--param asan-memintrin=0</source>
          <target state="translated">--param asan-memintrin = 0</target>
        </trans-unit>
        <trans-unit id="a85fa50efbf436bcb5274b389e28cd4ffa16e8f6" translate="yes" xml:space="preserve">
          <source>--param asan-stack=0</source>
          <target state="translated">--param asan-stack = 0</target>
        </trans-unit>
        <trans-unit id="3920aceaa4d0c4dbb9588dedd47f103a9721fd30" translate="yes" xml:space="preserve">
          <source>--param asan-use-after-return=0</source>
          <target state="translated">--param asan-use-after-return = 0</target>
        </trans-unit>
        <trans-unit id="d8104705ceeecd8dca5c855b23c02129d03fd3aa" translate="yes" xml:space="preserve">
          <source>--param hsa-gen-debug-stores=1</source>
          <target state="translated">--param hsa-gen-debug-stores = 1</target>
        </trans-unit>
        <trans-unit id="1b19ff06086c5a2903176b02fdbced7b43f5cec1" translate="yes" xml:space="preserve">
          <source>--param inline-unit-growth</source>
          <target state="translated">--param 인라인 단위 성장</target>
        </trans-unit>
        <trans-unit id="8ac078b12b033a45803b6b1ea17aa4781ed84483" translate="yes" xml:space="preserve">
          <source>--param ipcp-unit-growth=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">--param ipcp-unit-growth = &lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2af4ac3074fc1a44dab1c358abd5d1228d27f563" translate="yes" xml:space="preserve">
          <source>--param large-function-growth</source>
          <target state="translated">-매우 큰 기능 성장</target>
        </trans-unit>
        <trans-unit id="534f801afcf7bc7c50134ff6ca99009838d8d944" translate="yes" xml:space="preserve">
          <source>--param large-unit-insns</source>
          <target state="translated">--param-unit-insns</target>
        </trans-unit>
        <trans-unit id="915ddae1eb68b21bdc842f115e64d429b3a14b72" translate="yes" xml:space="preserve">
          <source>--param max-inline-insns-auto</source>
          <target state="translated">--param max-inline-insns-auto</target>
        </trans-unit>
        <trans-unit id="9a19e51c5b5d56bc48d8a8f9a2089239ebe6236a" translate="yes" xml:space="preserve">
          <source>--param max-inline-insns-recursive</source>
          <target state="translated">--param max-inline-insns-recursive</target>
        </trans-unit>
        <trans-unit id="9361003e3d8e46181c22efb4985b02854d7dc435" translate="yes" xml:space="preserve">
          <source>--param max-inline-insns-recursive-auto</source>
          <target state="translated">--param max-inline-insns-recursive-auto</target>
        </trans-unit>
        <trans-unit id="f6e4e737c314e908bf52516ae5bf889ce65ae668" translate="yes" xml:space="preserve">
          <source>--param max-inline-insns-single</source>
          <target state="translated">--param max-inline-insns-single</target>
        </trans-unit>
        <trans-unit id="57cb16654bf412f81b669b2d34821dd4ba8b7030" translate="yes" xml:space="preserve">
          <source>--param max-inline-recursive-depth</source>
          <target state="translated">--param max-inline-recursive-depth</target>
        </trans-unit>
        <trans-unit id="4c6a76bb4d81a18fea0e7297c5fd8760d647efe2" translate="yes" xml:space="preserve">
          <source>--param max-inline-recursive-depth-auto</source>
          <target state="translated">--param max-inline-recursive-depth-auto</target>
        </trans-unit>
        <trans-unit id="d1ba2dbdecea126c7e23c04d6ac886321cc7733c" translate="yes" xml:space="preserve">
          <source>--param uninlined-function-insns</source>
          <target state="translated">--param inlined-function-insns</target>
        </trans-unit>
        <trans-unit id="17eda58b27eb24c794dbf2670f811bb35cf8bb9b" translate="yes" xml:space="preserve">
          <source>--param uninlined-function-time</source>
          <target state="translated">--param 인라인 함수 시간</target>
        </trans-unit>
        <trans-unit id="113c521d2174c60ad8429bab21a4d69ce45c9a47" translate="yes" xml:space="preserve">
          <source>--relax</source>
          <target state="translated">--relax</target>
        </trans-unit>
        <trans-unit id="f7c1ba277b846444ae3bd4ca793dbb934e79fdf7" translate="yes" xml:space="preserve">
          <source>--script</source>
          <target state="translated">--script</target>
        </trans-unit>
        <trans-unit id="a5ede7e0c2ae6c6fcf84131f816c957863ebd19e" translate="yes" xml:space="preserve">
          <source>--sysroot</source>
          <target state="translated">--sysroot</target>
        </trans-unit>
        <trans-unit id="03871aeb9fd58907b7f973a64c5639cb4e7185ee" translate="yes" xml:space="preserve">
          <source>--target-help</source>
          <target state="translated">--target-help</target>
        </trans-unit>
        <trans-unit id="0f1594e7e448c852207a80bcddef0a2c01be7c40" translate="yes" xml:space="preserve">
          <source>--with-avrlibc</source>
          <target state="translated">--with-avrlibc</target>
        </trans-unit>
        <trans-unit id="ce9b1aff97fde9fd43d3f25318e7f2c14d645d1a" translate="yes" xml:space="preserve">
          <source>--with-cpu=arc700</source>
          <target state="translated">--with-cpu=arc700</target>
        </trans-unit>
        <trans-unit id="43e7f9aa9f26e4a2140d9c389827315bea74b448" translate="yes" xml:space="preserve">
          <source>--with-divide=breaks</source>
          <target state="translated">--with-divide=breaks</target>
        </trans-unit>
        <trans-unit id="7f443db828f8e3d777f4a1b60d95db10836b91e6" translate="yes" xml:space="preserve">
          <source>--with-isl</source>
          <target state="translated">--with-isl</target>
        </trans-unit>
        <trans-unit id="fc41d3ef057a00c64ae7cfb6d19252d3b367b2b9" translate="yes" xml:space="preserve">
          <source>--with-ld</source>
          <target state="translated">--with-ld</target>
        </trans-unit>
        <trans-unit id="24da4df978f0b486d9ec64db5c1fe252e850e793" translate="yes" xml:space="preserve">
          <source>--with-llsc</source>
          <target state="translated">--with-llsc</target>
        </trans-unit>
        <trans-unit id="1182831e20ca3f6e430a11ff6d48f902300343ce" translate="yes" xml:space="preserve">
          <source>--with-mips-plt</source>
          <target state="translated">--with-mips-plt</target>
        </trans-unit>
        <trans-unit id="a4590555ef66878c596cf76dc3d4c90c6be76b04" translate="yes" xml:space="preserve">
          <source>--with-mode=</source>
          <target state="translated">--with-mode=</target>
        </trans-unit>
        <trans-unit id="b2fa43af3d4a14a383fec6e2351ddb4e36831862" translate="yes" xml:space="preserve">
          <source>--with-nan=2008</source>
          <target state="translated">--with-nan=2008</target>
        </trans-unit>
        <trans-unit id="4fe96070a351e01e2af2b6f7d024cdf8a1c61bd9" translate="yes" xml:space="preserve">
          <source>--with-stack-offset=&lt;var&gt;num&lt;/var&gt;</source>
          <target state="translated">--with-stack-offset=&lt;var&gt;num&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="e3ffd80c526299889fd686be4f265343646380d2" translate="yes" xml:space="preserve">
          <source>--with-synci</source>
          <target state="translated">--with-synci</target>
        </trans-unit>
        <trans-unit id="e5d3f84c56bdf1f37e55e0e34007337c1b87dd64" translate="yes" xml:space="preserve">
          <source>--without-llsc</source>
          <target state="translated">--without-llsc</target>
        </trans-unit>
        <trans-unit id="72f9a64e69c07f336c27b858328ddec628bce662" translate="yes" xml:space="preserve">
          <source>-128 &amp;hellip; 127</source>
          <target state="translated">-128&amp;hellip; 127</target>
        </trans-unit>
        <trans-unit id="41c5556471c9c41b7ed8d4466077fcfe0f771ce6" translate="yes" xml:space="preserve">
          <source>-16 &amp;hellip; -1 or 1 &amp;hellip; 16</source>
          <target state="translated">-16&amp;hellip; -1 또는 1&amp;hellip; 16</target>
        </trans-unit>
        <trans-unit id="e33f307ec56ac23f4e4b4cd23eca5268e342d56c" translate="yes" xml:space="preserve">
          <source>-32 &amp;hellip; -1 or 1 &amp;hellip; 32</source>
          <target state="translated">-32&amp;hellip; -1 또는 1&amp;hellip; 32</target>
        </trans-unit>
        <trans-unit id="062ce7901f883b6a36571195d14fb1488ff09f89" translate="yes" xml:space="preserve">
          <source>-32768 &amp;hellip; 32767</source>
          <target state="translated">-32768&amp;hellip; 32767</target>
        </trans-unit>
        <trans-unit id="6ceb2ac9236a010c304bc55d35af577b401a0019" translate="yes" xml:space="preserve">
          <source>-65536 &amp;hellip; -1</source>
          <target state="translated">-65536&amp;hellip; -1</target>
        </trans-unit>
        <trans-unit id="00eb96584e50e203a95b3cbcd93bc48c817a99ec" translate="yes" xml:space="preserve">
          <source>-8 &amp;hellip; -1 or 1 &amp;hellip; 8</source>
          <target state="translated">-8&amp;hellip; -1 또는 1&amp;hellip; 8</target>
        </trans-unit>
        <trans-unit id="e7f0f7286a983e45fbfd1fff997afcee609f2333" translate="yes" xml:space="preserve">
          <source>-8 &amp;hellip; 7</source>
          <target state="translated">-8&amp;hellip; 7</target>
        </trans-unit>
        <trans-unit id="85ed27503e75a7fd173b61c00239456e00cdb29a" translate="yes" xml:space="preserve">
          <source>-&lt;var&gt;option&lt;/var&gt;</source>
          <target state="translated">-&lt;var&gt;option&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="bd6bd9306c20157668da23673684c32891f58798" translate="yes" xml:space="preserve">
          <source>-&lt;var&gt;options&lt;/var&gt;</source>
          <target state="translated">-&lt;var&gt;options&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2a0d6e4753e404846b3da72d44a72c18a4eee19e" translate="yes" xml:space="preserve">
          <source>-A &lt;var&gt;predicate&lt;/var&gt;(&lt;var&gt;answer&lt;/var&gt;)</source>
          <target state="translated">-A &lt;var&gt;predicate&lt;/var&gt; ( &lt;var&gt;answer&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="07015ed8e6ee6c7fcd387da7930e1833c2e01479" translate="yes" xml:space="preserve">
          <source>-B</source>
          <target state="translated">-B</target>
        </trans-unit>
        <trans-unit id="987830b431e9134788ba712f6d0c48ea63e3891a" translate="yes" xml:space="preserve">
          <source>-Bfoo/</source>
          <target state="translated">-Bfoo/</target>
        </trans-unit>
        <trans-unit id="ee7e59e9e3033b6eb4d3599f36b9eb1d9d8f8078" translate="yes" xml:space="preserve">
          <source>-C</source>
          <target state="translated">-C</target>
        </trans-unit>
        <trans-unit id="ef7ee7cfb43b9008958829efd8d64b7848e321ab" translate="yes" xml:space="preserve">
          <source>-CC</source>
          <target state="translated">-CC</target>
        </trans-unit>
        <trans-unit id="ad9aee0e02aa7df5696f88c33c3f5b0003d54711" translate="yes" xml:space="preserve">
          <source>-D</source>
          <target state="translated">-D</target>
        </trans-unit>
        <trans-unit id="2047ccb3e8e0a61bccca0248688e755cb3f236c4" translate="yes" xml:space="preserve">
          <source>-D'&lt;var&gt;name&lt;/var&gt;(&lt;var&gt;args&amp;hellip;&lt;/var&gt;)=&lt;var&gt;definition&lt;/var&gt;'</source>
          <target state="translated">-D'&lt;var&gt;name&lt;/var&gt;(&lt;var&gt;args&amp;hellip;&lt;/var&gt;)=&lt;var&gt;definition&lt;/var&gt;'</target>
        </trans-unit>
        <trans-unit id="262528920a804b8fb5e7b87c7c093b02463ba1cd" translate="yes" xml:space="preserve">
          <source>-D_MT</source>
          <target state="translated">-D_MT</target>
        </trans-unit>
        <trans-unit id="ff8015eb2b1855f53bb4336bf8d4411ac6c84c5b" translate="yes" xml:space="preserve">
          <source>-E</source>
          <target state="translated">-E</target>
        </trans-unit>
        <trans-unit id="ccdf319fc9b8ab52413c4b1c6ce664c414d5cf27" translate="yes" xml:space="preserve">
          <source>-F</source>
          <target state="translated">-F</target>
        </trans-unit>
        <trans-unit id="1b2ad08f13af60d02a993673ad6cf8e4e6ac9e81" translate="yes" xml:space="preserve">
          <source>-G</source>
          <target state="translated">-G</target>
        </trans-unit>
        <trans-unit id="62f512c8380c514e868d4031e89e0f8d880a99c6" translate="yes" xml:space="preserve">
          <source>-G &lt;var&gt;num&lt;/var&gt;</source>
          <target state="translated">-G &lt;var&gt;num&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="47e3d2cf8ea0d633536dbd3e2533af100b37d5e7" translate="yes" xml:space="preserve">
          <source>-G0</source>
          <target state="translated">-G0</target>
        </trans-unit>
        <trans-unit id="f71e105f8a133b9bda2f781740d497e34f38d669" translate="yes" xml:space="preserve">
          <source>-I</source>
          <target state="translated">-I</target>
        </trans-unit>
        <trans-unit id="9b83cd11508a2476b5a96c6035b9a6d7d73f1bc7" translate="yes" xml:space="preserve">
          <source>-I-</source>
          <target state="translated">-I-</target>
        </trans-unit>
        <trans-unit id="9ea6fab88b8bd0f497a7d564844eba74cf1296b9" translate="yes" xml:space="preserve">
          <source>-I.-I/special/include</source>
          <target state="translated">-I.-I/special/include</target>
        </trans-unit>
        <trans-unit id="c20a39eb3af4897aa4dea2bd9a1ba1a16fa16352" translate="yes" xml:space="preserve">
          <source>-L</source>
          <target state="translated">-L</target>
        </trans-unit>
        <trans-unit id="a865f5c84febf7bb127859a28c7f9921091e23e9" translate="yes" xml:space="preserve">
          <source>-M</source>
          <target state="translated">-M</target>
        </trans-unit>
        <trans-unit id="766dfebbd99ff335150e93696f0b424fd8c884b0" translate="yes" xml:space="preserve">
          <source>-M -MF &lt;var&gt;file&lt;/var&gt;</source>
          <target state="translated">-M -MF &lt;var&gt;file&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ca5f6d54e9f48e990f7a171ec03e9e3fb86dc230" translate="yes" xml:space="preserve">
          <source>-MD</source>
          <target state="translated">-MD</target>
        </trans-unit>
        <trans-unit id="0c6eb383fb3a09b37160c5897c59b00a3fd4c667" translate="yes" xml:space="preserve">
          <source>-MF</source>
          <target state="translated">-MF</target>
        </trans-unit>
        <trans-unit id="a1ac59d9d86036b584dd02c67da6433d94b6b0f8" translate="yes" xml:space="preserve">
          <source>-MG</source>
          <target state="translated">-MG</target>
        </trans-unit>
        <trans-unit id="8810841d9136e2ca78adcc2ef8fd22d1eec3b60d" translate="yes" xml:space="preserve">
          <source>-MM</source>
          <target state="translated">-MM</target>
        </trans-unit>
        <trans-unit id="ac72c219f25f02f5d3d4ba7f54c6fa61185a2d4f" translate="yes" xml:space="preserve">
          <source>-MMD</source>
          <target state="translated">-MMD</target>
        </trans-unit>
        <trans-unit id="44589fb1200176e2d38b10e3ce3a48fbb5d2da13" translate="yes" xml:space="preserve">
          <source>-MQ</source>
          <target state="translated">-MQ</target>
        </trans-unit>
        <trans-unit id="49af70a99559eb861cc6d4a1f4b6ab5846f595da" translate="yes" xml:space="preserve">
          <source>-MT</source>
          <target state="translated">-MT</target>
        </trans-unit>
        <trans-unit id="6fbdbbd677a18274726c99020f0c77540e6fc0b6" translate="yes" xml:space="preserve">
          <source>-Map output.map</source>
          <target state="translated">-지도 출력.지도</target>
        </trans-unit>
        <trans-unit id="baef33bc876a687b961751394c8f81f05f3e79c2" translate="yes" xml:space="preserve">
          <source>-O</source>
          <target state="translated">-O</target>
        </trans-unit>
        <trans-unit id="28001261ce59788011325a3412244c444a2a24a2" translate="yes" xml:space="preserve">
          <source>-O0</source>
          <target state="translated">-O0</target>
        </trans-unit>
        <trans-unit id="3a2ea76ea5223ba5c06c330d567a466f18648faf" translate="yes" xml:space="preserve">
          <source>-O1</source>
          <target state="translated">-O1</target>
        </trans-unit>
        <trans-unit id="de7f63e37a3bbff37b896a3d357f24b36e7159e1" translate="yes" xml:space="preserve">
          <source>-O2</source>
          <target state="translated">-O2</target>
        </trans-unit>
        <trans-unit id="41db216f1b5121805a5bb23bb3b564099b2c7fec" translate="yes" xml:space="preserve">
          <source>-O3</source>
          <target state="translated">-O3</target>
        </trans-unit>
        <trans-unit id="16fca30851efb6bbe0fbe6acc177926861ea29f4" translate="yes" xml:space="preserve">
          <source>-Ofast</source>
          <target state="translated">-Ofast</target>
        </trans-unit>
        <trans-unit id="adea5820536ffc0a9b797d47ab6d3adf9d9ed815" translate="yes" xml:space="preserve">
          <source>-Og</source>
          <target state="translated">-Og</target>
        </trans-unit>
        <trans-unit id="0559338fd0e1684606077707239d6bae957b3bb3" translate="yes" xml:space="preserve">
          <source>-Os</source>
          <target state="translated">-Os</target>
        </trans-unit>
        <trans-unit id="5bb32e12d567b52d9769dd6d1b502cbafaf5b407" translate="yes" xml:space="preserve">
          <source>-P</source>
          <target state="translated">-P</target>
        </trans-unit>
        <trans-unit id="6422eedc12255e6b5d4e04ab2b26ee196c74c4c7" translate="yes" xml:space="preserve">
          <source>-Q</source>
          <target state="translated">-Q</target>
        </trans-unit>
        <trans-unit id="4710db6d0ebf661a7c7bc7c7c770a03430609ef3" translate="yes" xml:space="preserve">
          <source>-Q --help=optimizers</source>
          <target state="translated">-Q --help = 최적화 기</target>
        </trans-unit>
        <trans-unit id="3e0eab9f94000d4317af98881d10968930b431a1" translate="yes" xml:space="preserve">
          <source>-S</source>
          <target state="translated">-S</target>
        </trans-unit>
        <trans-unit id="332ec780f224383a9f30f4660fe42ecd1206e248" translate="yes" xml:space="preserve">
          <source>-T</source>
          <target state="translated">-T</target>
        </trans-unit>
        <trans-unit id="444a425ff4c74a2fbb3eec1cff25a92779a43296" translate="yes" xml:space="preserve">
          <source>-U</source>
          <target state="translated">-U</target>
        </trans-unit>
        <trans-unit id="561dfc356741ed4dc2784b39dba88c011c483888" translate="yes" xml:space="preserve">
          <source>-W</source>
          <target state="translated">-W</target>
        </trans-unit>
        <trans-unit id="f1db1304ad8ec2215aa07b2c6516c04dc1215726" translate="yes" xml:space="preserve">
          <source>-W&amp;hellip;</source>
          <target state="translated">-W&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="89e2891e8f37be83f9c4bbc3ad937b765c7867d7" translate="yes" xml:space="preserve">
          <source>-Wa</source>
          <target state="translated">-Wa</target>
        </trans-unit>
        <trans-unit id="78e4eeec44c73c0709f08dfe65f2539018eeb610" translate="yes" xml:space="preserve">
          <source>-Wabi</source>
          <target state="translated">-Wabi</target>
        </trans-unit>
        <trans-unit id="d58ff6fc53401d8eda6a61783ff443c03944ecdf" translate="yes" xml:space="preserve">
          <source>-Wabi-tag</source>
          <target state="translated">-Wabi-tag</target>
        </trans-unit>
        <trans-unit id="14c081a12c248967ddd5ccb1d2a8308ff6b812d8" translate="yes" xml:space="preserve">
          <source>-Wabi=2</source>
          <target state="translated">-Wabi=2</target>
        </trans-unit>
        <trans-unit id="cb87f86c75f94fb00e8f95b218c0027c524468e9" translate="yes" xml:space="preserve">
          <source>-Wabi=&lt;var&gt;n&lt;/var&gt;</source>
          <target state="translated">-Wabi=&lt;var&gt;n&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="12bc07aa073e0cde04567bf4f2d0123be6273b70" translate="yes" xml:space="preserve">
          <source>-Waligned-new=all</source>
          <target state="translated">-Waligned-new=all</target>
        </trans-unit>
        <trans-unit id="b6b6e46e1b3d43237d6e550d71cf4cf2b90c3a8a" translate="yes" xml:space="preserve">
          <source>-Wall</source>
          <target state="translated">-Wall</target>
        </trans-unit>
        <trans-unit id="8a1df80bae0bb2af66d8760bcc6aca7540345ff0" translate="yes" xml:space="preserve">
          <source>-Walloc-size-larger-than=</source>
          <target state="translated">-Walloc-size-larger-than=</target>
        </trans-unit>
        <trans-unit id="70b896f5f10e7a03de8e140d1d0164ee9a5116b9" translate="yes" xml:space="preserve">
          <source>-Walloca-larger-than</source>
          <target state="translated">-Walloca-larger-than</target>
        </trans-unit>
        <trans-unit id="2860f925943af1afcf90db4872877134ce06c7d8" translate="yes" xml:space="preserve">
          <source>-Walloca-larger-than=</source>
          <target state="translated">-Walloca-larger-than=</target>
        </trans-unit>
        <trans-unit id="203ef4e344ed1a739410037a96a4f5884e3ad233" translate="yes" xml:space="preserve">
          <source>-Walloca-larger-than=&lt;var&gt;byte-size&lt;/var&gt;</source>
          <target state="translated">-Walloca-larger-than=&lt;var&gt;byte-size&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="ecf85114b7f201d851b51f913e4be7748b3daf38" translate="yes" xml:space="preserve">
          <source>-Warray-bounds</source>
          <target state="translated">-Warray-bounds</target>
        </trans-unit>
        <trans-unit id="02eb1999df7f54d17603e0c053b76e8646947ef9" translate="yes" xml:space="preserve">
          <source>-Wattribute-alias</source>
          <target state="translated">-Wattribute-alias</target>
        </trans-unit>
        <trans-unit id="9765196f48ad96fec0d363f505ef6647f8de704a" translate="yes" xml:space="preserve">
          <source>-Wattribute-alias=0</source>
          <target state="translated">-Wattribute-alias=0</target>
        </trans-unit>
        <trans-unit id="5262f3c705c4c2a054e60db092066d5efc924685" translate="yes" xml:space="preserve">
          <source>-Wattribute-alias=1</source>
          <target state="translated">-Wattribute-alias=1</target>
        </trans-unit>
        <trans-unit id="dd676c93fb4ef29b129c7d4a0691ad65153e5461" translate="yes" xml:space="preserve">
          <source>-Wattribute-alias=2</source>
          <target state="translated">-Wattribute-alias=2</target>
        </trans-unit>
        <trans-unit id="249e9d32bb64eaa64fa45f88c041339894c5afa7" translate="yes" xml:space="preserve">
          <source>-Wattributes</source>
          <target state="translated">-Wattributes</target>
        </trans-unit>
        <trans-unit id="0565c965bfa6e13bd545739e5b8cedad7f28b624" translate="yes" xml:space="preserve">
          <source>-Wc++-compat</source>
          <target state="translated">-Wc++-compat</target>
        </trans-unit>
        <trans-unit id="cf32a3ff936d346c50f3d6e060af97d91bc935c4" translate="yes" xml:space="preserve">
          <source>-Wc++11-compat</source>
          <target state="translated">-Wc++11-compat</target>
        </trans-unit>
        <trans-unit id="09f352680749e550bb3a5012c7b09d7cc7c718b0" translate="yes" xml:space="preserve">
          <source>-Wc++17-compat</source>
          <target state="translated">-Wc++17-compat</target>
        </trans-unit>
        <trans-unit id="c6f069075c8d3297a054cce44dcb77db6345da27" translate="yes" xml:space="preserve">
          <source>-Wcatch-value</source>
          <target state="translated">-Wcatch-value</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
