<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="90c655a8d399c68ec546283b401cd86c6d3da561" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command conforms to the SQL standard, except that the &lt;code&gt;OPTIONS&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a88d188f36cc114975839b521433281fe355dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN ROLE&lt;/code&gt; clause lists one or more existing roles to which the new role will be immediately added as a new member. (Note that there is no option to add the new role as an administrator; use a separate &lt;code&gt;GRANT&lt;/code&gt; command to do that.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0c6bd082b9438730c44b123984d29738293313" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute governs inheritance of grantable privileges (that is, access privileges for database objects and role memberships). It does not apply to the special role attributes set by &lt;code&gt;CREATE ROLE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt;. For example, being a member of a role with &lt;code&gt;CREATEDB&lt;/code&gt; privilege does not immediately grant the ability to create databases, even if &lt;code&gt;INHERIT&lt;/code&gt; is set; it would be necessary to become that role via &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; before creating a database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11950124f137ab1b3b29d5312c33140b0085fa30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute is the default for reasons of backwards compatibility: in prior releases of PostgreSQL, users always had access to all privileges of groups they were members of. However, &lt;code&gt;NOINHERIT&lt;/code&gt; provides a closer match to the semantics specified in the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a4f9690ce7e26c8924892aa7417c3dc21a3ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INSERT&lt;/code&gt; statement is used to populate a table with rows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb164c110048f642f9967f6798e5f2daa48843e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; clause has this general form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0af4aa2cff56983554b5dfd6aea4022d42a30a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; operator computes the set intersection of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the intersection of two result sets if it appears in both result sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3710966a5964edf86a5e94dad6ccef2f09e50690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ISBN&lt;/code&gt;, &lt;code&gt;ISMN&lt;/code&gt;, and &lt;code&gt;ISSN&lt;/code&gt; types will display the short version of the number (ISxN 10) whenever it's possible, and will show ISxN 13 format for numbers that do not fit in the short version. The &lt;code&gt;EAN13&lt;/code&gt;, &lt;code&gt;ISBN13&lt;/code&gt;, &lt;code&gt;ISMN13&lt;/code&gt; and &lt;code&gt;ISSN13&lt;/code&gt; types will always display the long version of the ISxN (EAN13).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1a2d9b3af27ec14ac83825b4e9390e81b28ab6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IntervalStyle&lt;/code&gt; parameter also affects the interpretation of ambiguous interval input. See &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;Section 8.5.4&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb07a7b0b456e75c7d7fb8309d5a950ea4dfdb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LATERAL&lt;/code&gt; key word can precede a sub-&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item. This allows the sub-&lt;code&gt;SELECT&lt;/code&gt; to refer to columns of &lt;code&gt;FROM&lt;/code&gt; items that appear before it in the &lt;code&gt;FROM&lt;/code&gt; list. (Without &lt;code&gt;LATERAL&lt;/code&gt;, each sub-&lt;code&gt;SELECT&lt;/code&gt; is evaluated independently and so cannot cross-reference any other &lt;code&gt;FROM&lt;/code&gt; item.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a14b782795f85302f04f02639a6c4f62ab4e062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g., &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; from a view) are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396ab12c5362824aaa283637f9c77c9a00f331f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572dfcd3f9f7897b067c547ebc46891efd6417fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; expression returns true if the &lt;code&gt;string&lt;/code&gt; matches the supplied &lt;code&gt;pattern&lt;/code&gt;. (As expected, the &lt;code&gt;NOT LIKE&lt;/code&gt; expression returns false if &lt;code&gt;LIKE&lt;/code&gt; returns true, and vice versa. An equivalent expression is &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258e69d1b09cf77569de7c47f8a8dba66e04bb7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; operator does pattern matching and is explained in &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7480e6b2427d5d0d2afbc0d3981cabf8d8c5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIMIT&lt;/code&gt; clause consists of two independent sub-clauses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5092a579b1157c3ece79f6e0b69fb148ae975b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MATERIALIZED&lt;/code&gt; and &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; options of &lt;code&gt;WITH&lt;/code&gt; are extensions of the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c245095fff9e37994e71505cc2de7e6fbaeb07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MergeJoin&lt;/code&gt; node similarly demands the first row from its right subplan. Then it compares the two rows to see if they can be joined; if so, it returns a join row to its caller. On the next call, or immediately if it cannot join the current pair of inputs, it advances to the next row of one table or the other (depending on how the comparison came out), and again checks for a match. Eventually, one subplan or the other is exhausted, and the &lt;code&gt;MergeJoin&lt;/code&gt; node returns NULL to indicate that no more join rows can be formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c96e90dd3ca2b2b4787fd18890dca99f28ab8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NONE&lt;/code&gt; and &lt;code&gt;RESET&lt;/code&gt; forms reset the current user identifier to be the current session user identifier. These forms can be executed by any user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b13dc16a3a4fce3da18ccb704fb39295955bdea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOT NULL&lt;/code&gt; constraint has an inverse: the &lt;code&gt;NULL&lt;/code&gt; constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The &lt;code&gt;NULL&lt;/code&gt; constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea1d2c35460104bbb73410ce7cfdee6383ad73d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOTIFY&lt;/code&gt; command sends a notification event together with an optional &amp;ldquo;payload&amp;rdquo; string to each client application that has previously executed &lt;code&gt;LISTEN channel&lt;/code&gt; for the specified channel name in the current database. Notifications are visible to all users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1aa8547d4f45a3a74ddce2ee6f66c1ad2e63b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt; keyword is case-insensitive. Double-quote the &lt;code&gt;NULL&lt;/code&gt; to treat it as the ordinary string &amp;ldquo;NULL&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962da68b59592e76d7efdc84ac1e5105db667c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;constraint&amp;rdquo; (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the &lt;code&gt;NOT NULL&lt;/code&gt; constraint). Since it is the default for any column, its presence is simply noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89a70ab2187a4125b8af941eb48d2104a35aae4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLIF&lt;/code&gt; function returns a null value if &lt;code&gt;value1&lt;/code&gt; equals &lt;code&gt;value2&lt;/code&gt;; otherwise it returns &lt;code&gt;value1&lt;/code&gt;. This can be used to perform the inverse operation of the &lt;code&gt;COALESCE&lt;/code&gt; example given above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fdd1712e7b0454ab7f170cffda1945f0082b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLS FIRST&lt;/code&gt; and &lt;code&gt;NULLS LAST&lt;/code&gt; options can be used to determine whether nulls appear before or after non-null values in the sort ordering. By default, null values sort as if larger than any non-null value; that is, &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;DESC&lt;/code&gt; order, and &lt;code&gt;NULLS LAST&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3f6d7975c35350055f22165f8267b483d36caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON COMMIT&lt;/code&gt; clause for temporary tables also resembles the SQL standard, but has some differences. If the &lt;code&gt;ON COMMIT&lt;/code&gt; clause is omitted, SQL specifies that the default behavior is &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt;. However, the default behavior in PostgreSQL is &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt;. The &lt;code&gt;ON COMMIT DROP&lt;/code&gt; option does not exist in SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472f32dda3820f4f49769a24b22c0964256b23e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON&lt;/code&gt; clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a &lt;code&gt;WHERE&lt;/code&gt; clause. A pair of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; match if the &lt;code&gt;ON&lt;/code&gt; expression evaluates to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793025f43fd046d2375fc2d1347d2ad6be35fd9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt; and &lt;code&gt;FUNCTION&lt;/code&gt; clauses can appear in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed146b628b9143aa8d465b9f6a969399e0078fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt;, &lt;code&gt;FUNCTION&lt;/code&gt;, and &lt;code&gt;STORAGE&lt;/code&gt; clauses can appear in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7408278e5a49c7a21e1d564882fc738063e8ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02f359cd58f3fe912dce4590fe56eb7fd3fc933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause specifies the sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c192bece45872266b8038f6a0a05d716d357e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc9e5eec52a1ba378bd2fb8274d7c97650e7deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. If specified, this association replaces any previously specified association for the sequence. The specified table must have the same owner and be in the same schema as the sequence. Specifying &lt;code&gt;OWNED BY NONE&lt;/code&gt; removes any existing association, making the sequence &amp;ldquo;free-standing&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fdd5a6277f3365172855b96f924d0b384fe495" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. The specified table must have the same owner and be in the same schema as the sequence. &lt;code&gt;OWNED BY NONE&lt;/code&gt;, the default, specifies that there is no such association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2d7bf96f2a0b5a81febb7cc2f04c359a2ce962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARSER&lt;/code&gt; and &lt;code&gt;COPY&lt;/code&gt; options are mutually exclusive, because when an existing configuration is copied, its parser selection is copied too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad47e1225da856fc1e4e1ae21e6437e7c3be2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause groups the rows of the query into &lt;em&gt;partitions&lt;/em&gt;, which are processed separately by the window function. &lt;code&gt;PARTITION BY&lt;/code&gt; works similarly to a query-level &lt;code&gt;GROUP BY&lt;/code&gt; clause, except that its expressions are always just expressions and cannot be output-column names or numbers. Without &lt;code&gt;PARTITION BY&lt;/code&gt;, all rows produced by the query are treated as a single partition. The &lt;code&gt;ORDER BY&lt;/code&gt; clause determines the order in which the rows of a partition are processed by the window function. It works similarly to a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, but likewise cannot use output-column names or numbers. Without &lt;code&gt;ORDER BY&lt;/code&gt;, rows are processed in an unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b20c2706e18115ac776637bd86595bd36306e04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393ad05ac9e0d59452b4a8f8039dc3a261130b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION OF&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0614d6d969b75211746fef3527fa36c2e0bf9b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGDATA&lt;/code&gt; directory contains several subdirectories and control files, as shown in &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;Table 68.1&lt;/a&gt;. In addition to these required items, the cluster configuration files &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, and &lt;code&gt;pg_ident.conf&lt;/code&gt; are traditionally stored in &lt;code&gt;PGDATA&lt;/code&gt;, although it is possible to place them elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c212a5664d9166a52f4030be9966cfbd740b8e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGTZ&lt;/code&gt; environment variable is used by libpq clients to send a &lt;code&gt;SET TIME ZONE&lt;/code&gt; command to the server upon connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a48a54277ef76ad5806acc41cf35d3fff139d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46186111e10cd3fae630f6ffd1000b220d009aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Planning time&lt;/code&gt; shown by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; is the time it took to generate the query plan from the parsed query and optimize it. It does not include parsing or rewriting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e8e781faa2b1b8c5b786d22498b3437e1d217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command does not affect any privileges granted to the &lt;code&gt;old_roles&lt;/code&gt; on objects that are not owned by them. Likewise, it does not affect default privileges created with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;. Use &lt;code&gt;DROP OWNED&lt;/code&gt; to revoke such privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1105a54870883f7696c90d586d2ea0eba9685c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532c71d7a7a8a330117caf1f3776cf4f07cbb57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REFERENCING&lt;/code&gt; option enables collection of &lt;em&gt;transition relations&lt;/em&gt;, which are row sets that include all of the rows inserted, deleted, or modified by the current SQL statement. This feature lets the trigger see a global view of what the statement did, not just one row at a time. This option is only allowed for an &lt;code&gt;AFTER&lt;/code&gt; trigger that is not a constraint trigger; also, if the trigger is an &lt;code&gt;UPDATE&lt;/code&gt; trigger, it must not specify a &lt;code&gt;column_name&lt;/code&gt; list. &lt;code&gt;OLD TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;before-images&lt;/em&gt; of all rows updated or deleted by the statement. Similarly, &lt;code&gt;NEW TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;after-images&lt;/em&gt; of all rows updated or inserted by the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128c0fd3af0b907c660e6b2d23e97c6334b157b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; form changes the name of the index. If the index is associated with a table constraint (either &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt;), the constraint is renamed as well. There is no effect on the stored data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e19c1e234f0ed8c9c4710a3c3098a7ed897e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a foreign table or the name of an individual column in a foreign table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e7a50326fd3c3ba151f96454fa2cb157ff1c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e363fe4d9083d2f665b243a400d5bf63d40f84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RETURNING&lt;/code&gt; clause is also very useful with &lt;code&gt;INSERT ... SELECT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622683abc0fee3cca0a4ff24efb6bac3bc69274b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REVOKE&lt;/code&gt; command revokes previously granted privileges from one or more roles. The key word &lt;code&gt;PUBLIC&lt;/code&gt; refers to the implicitly defined group of all roles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7eb06850162cc121e0dcb4f71d5d5cc238a6fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROLE&lt;/code&gt; clause lists one or more existing roles which are automatically added as members of the new role. (This in effect makes the new role a &amp;ldquo;group&amp;rdquo;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90b140ccb8d754cc8582d110f40bb1462ca56ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; constructor syntax is usually easier to work with than the composite-literal syntax when writing composite values in SQL commands. In &lt;code&gt;ROW&lt;/code&gt;, individual field values are written the same way they would be written when not members of a composite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc33402fa9910608d16738542893ffc3652dba40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax can also be used to construct composite values. In most cases this is considerably simpler to use than the string-literal syntax since you don't have to worry about multiple layers of quoting. We already used this method above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec4fc51d12e7ec5b1c6011953c7d9a01518ad18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66771ec27e64ee38d7a73db993c4f98dda1eefb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SCROLL&lt;/code&gt; option should be specified when defining a cursor that will be used to fetch backwards. This is required by the SQL standard. However, for compatibility with earlier versions, PostgreSQL will allow backward fetches without &lt;code&gt;SCROLL&lt;/code&gt;, if the cursor's query plan is simple enough that no extra overhead is needed to support it. However, application developers are advised not to rely on using backward fetches from a cursor that has not been created with &lt;code&gt;SCROLL&lt;/code&gt;. If &lt;code&gt;NO SCROLL&lt;/code&gt; is specified, then backward fetches are disallowed in any case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7724f5cbcba172f246fa8b7c71da000b2776330f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands acquire a lock of this mode on the target table(s) (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other tables that are referenced but not selected &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e7802d4cb7db701f609eba9f870f4c8748bdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; command acquires a lock of this mode on referenced tables. In general, any query that only &lt;em&gt;reads&lt;/em&gt; a table and does not modify it will acquire this lock mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a31e8d24fd1e02295c813f049f933c4c7dd023e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; list (between the key words &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;FROM&lt;/code&gt;) specifies expressions that form the output rows of the &lt;code&gt;SELECT&lt;/code&gt; statement. The expressions can (and usually do) refer to columns computed in the &lt;code&gt;FROM&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d3b2383acf67ec80d1e37ede72853554a335de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; statement will return one tuple, even though the &lt;code&gt;nick&lt;/code&gt; column was set to &lt;code&gt;larry&lt;/code&gt; and the query was for &lt;code&gt;Larry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1ef68b6a727bfef21aefb3a5eb92e57da175a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SERIAL&lt;/code&gt; shorthand is discussed further in &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a726476c5c9f5995fa747df038eaa20f04dca47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers act the same as for the regular &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2d0dd2017fb0dc1fe3da723f3e961e02aaf3eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET ROLE&lt;/code&gt; command always allows selecting any role that the original login role is directly or indirectly a member of. Thus, in the above example, it is not necessary to become &lt;code&gt;admin&lt;/code&gt; before becoming &lt;code&gt;wheel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d850a29f519a30a60f848219dab3f598ebc95064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command allows a new transaction to run with the same &lt;em&gt;snapshot&lt;/em&gt; as an existing transaction. The pre-existing transaction must have exported its snapshot with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt;). That function returns a snapshot identifier, which must be given to &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; to specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example &lt;code&gt;'000003A1-1'&lt;/code&gt;. &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; can only be executed at the start of a transaction, before the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of the transaction. Furthermore, the transaction must already be set to &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level (otherwise, the snapshot would be discarded immediately, since &lt;code&gt;READ COMMITTED&lt;/code&gt; mode takes a new snapshot for each command). If the importing transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6c2a89c55f352db834e7ae3a14fa98c839cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION&lt;/code&gt; command sets the characteristics of the current transaction. It has no effect on any subsequent transactions. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; sets the default transaction characteristics for subsequent transactions of a session. These defaults can be overridden by &lt;code&gt;SET TRANSACTION&lt;/code&gt; for an individual transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6625f1cde96b5821cc50429e57aa65382ce3cbff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cb501cbc3608b578aae96ed6d694a6c1181e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the procedure is entered, and then restored to its prior value when the procedure exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4ac1bc1f3cd753f1587a3604ac6e4583d02fa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; command changes run-time configuration parameters. Many of the run-time parameters listed in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; can be changed on-the-fly with &lt;code&gt;SET&lt;/code&gt;. (But some require superuser privileges to change, and others cannot be changed after server or session start.) &lt;code&gt;SET&lt;/code&gt; only affects the value used by the current session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020c7ebd698e864a60548a6b3a70eb85bc868cc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SETOF&lt;/code&gt; modifier indicates that the function will return a set of items, rather than a single item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fb6cd6b15fe6f84ab20f8db329dfba5800e08d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHOW&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bda179acb0a4ef77b97eb421bed8ee9a254cd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGHUP&lt;/code&gt; signal will reload the server configuration files. It is also possible to send &lt;code&gt;SIGHUP&lt;/code&gt; to an individual server process, but that is usually not sensible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdafa6a0951a5a4f8ae3d651aa4483d02aaf656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIMILAR TO&lt;/code&gt; operator returns true or false depending on whether its pattern matches the given string. It is similar to &lt;code&gt;LIKE&lt;/code&gt;, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between &lt;code&gt;LIKE&lt;/code&gt; notation and common regular expression notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0015ba66976ccc10a8545b59f15f445b21a50742" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SQL_ASCII&lt;/code&gt; setting behaves considerably differently from the other settings. When the server character set is &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server interprets byte values 0-127 according to the ASCII standard, while byte values 128-255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is &lt;code&gt;SQL_ASCII&lt;/code&gt;. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the &lt;code&gt;SQL_ASCII&lt;/code&gt; setting because PostgreSQL will be unable to help you by converting or validating non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7d5e46d6c54b21b25eeef48c6ca4551b1f61a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSID&lt;/code&gt; clause is ignored, but is accepted for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9a4c3ee7dd77407d80711565ddf84296946777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to any &lt;code&gt;FROM&lt;/code&gt; item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3600170fb18cff60f53eb4ba51d9dce974f3e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUSTED&lt;/code&gt; option and the support function name(s) are ignored if the server has an entry for the specified language name in &lt;code&gt;pg_pltemplate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53faeaca5564f551951f6575a18b776e07cb73f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; clause has this general form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37a98042f90333d3d9b66690fc343fe11354a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; operator computes the set union of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two &lt;code&gt;SELECT&lt;/code&gt; statements that represent the direct operands of the &lt;code&gt;UNION&lt;/code&gt; must produce the same number of columns, and corresponding columns must be of compatible data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2f42f8ff2203573828998bc521aa46717845dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNIQUE&lt;/code&gt; constraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440900ea1c49963507f35e80410def61bdfb2e10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; clause is an obsolete spelling of the &lt;code&gt;ROLE&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5573cea50ffa4699b0e7de14e2efa40e40f614" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; with &lt;code&gt;USING (a, b)&lt;/code&gt; produces the join condition &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd69a2ff12f6e6b4d3bf9a9a6b47532dc2d1194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbe3012f251c3e27b73557dcb624091be7838ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; option of &lt;code&gt;SET DATA TYPE&lt;/code&gt; can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with the &lt;code&gt;SET DATA TYPE&lt;/code&gt; syntax. Because of this flexibility, the &lt;code&gt;USING&lt;/code&gt; expression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type, &lt;code&gt;SET DATA TYPE&lt;/code&gt; might fail to convert the default even though a &lt;code&gt;USING&lt;/code&gt; clause is supplied. In such cases, drop the default with &lt;code&gt;DROP DEFAULT&lt;/code&gt;, perform the &lt;code&gt;ALTER TYPE&lt;/code&gt;, and then use &lt;code&gt;SET DEFAULT&lt;/code&gt; to add a suitable new default. Similar considerations apply to indexes and constraints involving the column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac72d27e393aaa10fa09ec0c99e41bf31ba8f68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause defines an expiration time for a password only, not for the role &lt;em&gt;per se&lt;/em&gt;. In particular, the expiration time is not enforced when logging in using a non-password-based authentication method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4254f4cbb5558ecbcabbf94985890347bc617c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause sets a date and time after which the role's password is no longer valid. If this clause is omitted the password will be valid for all time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c44efcbdf803edc09491650dc604f24489fb4e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH CHECK&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f909d6d352b763da5996539ec5a35b3e1508bd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;DELETE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86cbf90270e40ca5022ce8fed26f2e4b7126438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;INSERT&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5376c90f6e32eea66f4e1b2c109c7f56e3b3b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;UPDATE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36279616fce39b7667637feae639cf048d9729b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement. When writing a data-modifying statement (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;, it is usual to include a &lt;code&gt;RETURNING&lt;/code&gt; clause. It is the output of &lt;code&gt;RETURNING&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If &lt;code&gt;RETURNING&lt;/code&gt; is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd82170932e06b9823fd64af1127b85442398023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause can specify &lt;em&gt;storage parameters&lt;/em&gt; for tables, and for indexes associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint. Storage parameters for indexes are documented in &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed with &lt;code&gt;toast.&lt;/code&gt;, which controls the behavior of the table's secondary TOAST table, if any (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information about TOAST). If a table parameter value is set and the equivalent &lt;code&gt;toast.&lt;/code&gt; parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e61d24618bca5f4d5d76d9ae780c2dce93b6f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause is a PostgreSQL extension; storage parameters are not in the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bfddf2848aa0b39782b5bc4bcc89ef2f85698a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\i&lt;/code&gt; command reads in commands from the specified file. &lt;code&gt;psql&lt;/code&gt;'s &lt;code&gt;-s&lt;/code&gt; option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file &lt;code&gt;basics.sql&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d745a90b32000102fbaf10faab8dc20a84ca8bde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\if&lt;/code&gt; and &lt;code&gt;\elif&lt;/code&gt; commands read their argument(s) and evaluate them as a boolean expression. If the expression yields &lt;code&gt;true&lt;/code&gt; then processing continues normally; otherwise, lines are skipped until a matching &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, or &lt;code&gt;\endif&lt;/code&gt; is reached. Once an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; test has succeeded, the arguments of later &lt;code&gt;\elif&lt;/code&gt; commands in the same block are not evaluated but are treated as false. Lines following an &lt;code&gt;\else&lt;/code&gt; are processed only if no earlier matching &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3a007939b7e11bbba46ea6419ffc5cadf17bf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\ir&lt;/code&gt; command is similar to &lt;code&gt;\i&lt;/code&gt;, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, &lt;code&gt;\ir&lt;/code&gt; interprets file names relative to the directory in which the script is located, rather than the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169f5705e6b515a085e5b6da75e17e9f4dc2b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;age&lt;/code&gt; column measures the number of transactions from the cutoff XID to the current transaction's XID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525d0fc7bca054a06817564f9e4e716d7d8750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignment&lt;/code&gt; parameter specifies the storage alignment required for the data type. The allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries. Note that variable-length types must have an alignment of at least 4, since they necessarily contain an &lt;code&gt;int4&lt;/code&gt; as their first component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec02f3867429174e02872bcd9ba803a6ca7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcheck&lt;/code&gt; module provides functions that allow you to verify the logical consistency of the structure of relations. If the structure appears to be valid, no error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aff6c7be2111c7103649cab8f33b7af9c81d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcostestimate&lt;/code&gt; function is given information describing a possible index scan, including lists of WHERE and ORDER BY clauses that have been determined to be usable with the index. It must return estimates of the cost of accessing the index and the selectivity of the WHERE clauses (that is, the fraction of parent-table rows that will be retrieved during the index scan). For simple cases, nearly all the work of the cost estimator can be done by calling standard routines in the optimizer; the point of having an &lt;code&gt;amcostestimate&lt;/code&gt; function is to allow index access methods to provide index-type-specific knowledge, in case it is possible to improve on the standard estimates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6898a2ba9037019e5df24b6e547743d4cc59ddab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgetbitmap&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;bitmap&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgetbitmap&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388cb503bc9fecd1c56c284bf2fd7e41a507c9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function has a &lt;code&gt;direction&lt;/code&gt; argument, which can be either &lt;code&gt;ForwardScanDirection&lt;/code&gt; (the normal case) or &lt;code&gt;BackwardScanDirection&lt;/code&gt;. If the first call after &lt;code&gt;amrescan&lt;/code&gt; specifies &lt;code&gt;BackwardScanDirection&lt;/code&gt;, then the set of matching index entries is to be scanned back-to-front rather than in the normal front-to-back direction, so &lt;code&gt;amgettuple&lt;/code&gt; must return the last matching tuple in the index, rather than the first one as it normally would. (This will only occur for access methods that set &lt;code&gt;amcanorder&lt;/code&gt; to true.) After the first call, &lt;code&gt;amgettuple&lt;/code&gt; must be prepared to advance the scan in either direction from the most recently returned entry. (But if &lt;code&gt;amcanbackward&lt;/code&gt; is false, all subsequent calls will have the same direction as the first one.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f7a76e8330fc4bc94786133307659b91dcdc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;plain&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgettuple&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde20037ee1497cd6ab533acce975df0e8aa1224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ammarkpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;ammarkpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdf26b3604c28eca91ce1c3b3a35a7a58b7e44e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amproperty&lt;/code&gt; method allows index access methods to override the default behavior of &lt;code&gt;pg_index_column_has_property&lt;/code&gt; and related functions. If the access method does not have any special behavior for index property inquiries, the &lt;code&gt;amproperty&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL. Otherwise, the &lt;code&gt;amproperty&lt;/code&gt; method will be called with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; both zero for &lt;code&gt;pg_indexam_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; zero for &lt;code&gt;pg_index_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; greater than zero for &lt;code&gt;pg_index_column_has_property&lt;/code&gt; calls. &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is an enum value identifying the property being tested, while &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; is the original property name string. If the core code does not recognize the property name then &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt;. Access methods can define custom property names by checking &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; for a match (use &lt;code&gt;pg_strcasecmp&lt;/code&gt; to match, for consistency with the core code); for names known to the core code, it's better to inspect &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt;. If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; then it has determined the property test result: it must set &lt;code&gt;*res&lt;/code&gt; to the boolean value to return, or set &lt;code&gt;*isnull&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to return a NULL. (Both of the referenced variables are initialized to &lt;code&gt;false&lt;/code&gt; before the call.) If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; then the core code will proceed with its normal logic for determining the property test result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6ce83ebaf748f648fd0330541075210e5894e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amrestrpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;amrestrpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe809061c1f64f874371a0dcea9b46cff8a18bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application_name&lt;/code&gt; can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). It is typically set by an application upon connection to the server. The name will be displayed in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view and included in CSV log entries. It can also be included in regular log entries via the &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; parameter. Only printable ASCII characters may be used in the &lt;code&gt;application_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810ba7465a70771d2961f660e2ffe00a08ad7b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function works for the types &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;, and &lt;code&gt;path&lt;/code&gt;. The &lt;code&gt;area&lt;/code&gt; function only works on the &lt;code&gt;path&lt;/code&gt; data type if the points in the &lt;code&gt;path&lt;/code&gt; are non-intersecting. For example, the &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; will not work; however, the following visually identical &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; will work. If the concept of an intersecting versus non-intersecting &lt;code&gt;path&lt;/code&gt; is confusing, draw both of the above &lt;code&gt;path&lt;/code&gt;s side by side on a piece of graph paper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f921ad3facaf5178eff030fa07dc7338005685" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;latex&lt;/code&gt;, &lt;code&gt;latex-longtable&lt;/code&gt;, and &lt;code&gt;troff-ms&lt;/code&gt; formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. The &lt;code&gt;latex&lt;/code&gt; format uses LaTeX's &lt;code&gt;tabular&lt;/code&gt; environment. The &lt;code&gt;latex-longtable&lt;/code&gt; format requires the LaTeX &lt;code&gt;longtable&lt;/code&gt; and &lt;code&gt;booktabs&lt;/code&gt; packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35bd0bda526ded9e0b91c584dead64c2d3ef9b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto_explain&lt;/code&gt; module provides a means for logging execution plans of slow statements automatically, without having to run &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; by hand. This is especially helpful for tracking down un-optimized queries in large applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f04194d1f661ec08cbef8138cc1ebad08b480fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bench.pl&lt;/code&gt; script has numerous options, which are displayed when it is run without any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e37968903b5f952d43e00009d52dc6bb5a6d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; file format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5593a80ab4eb5986c84ab5663e69124cb8f2b569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; format option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text and &lt;code&gt;CSV&lt;/code&gt; formats, but a binary-format file is less portable across machine architectures and PostgreSQL versions. Also, the binary format is very data type specific; for example it will not work to output binary data from a &lt;code&gt;smallint&lt;/code&gt; column and read it into an &lt;code&gt;integer&lt;/code&gt; column, even though that would work fine in text format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402f6e7dc47cea56b75bd8100479b08159b6b07c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; data type allows storage of binary strings; see &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;Table 8.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6287927d29cc83d11891a4932630e624e03a0f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; type supports two formats for input and output: &amp;ldquo;hex&amp;rdquo; format and PostgreSQL's historical &amp;ldquo;escape&amp;rdquo; format. Both of these are always accepted on input. The output format depends on the configuration parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt;; the default is hex. (Note that the hex format was introduced in PostgreSQL 9.0; earlier versions and some tools don't understand it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03633603ba240cb14fd9f2ba15fb155d7d2a20f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;preferred&lt;/code&gt; parameters can be used to help control which implicit cast will be applied in ambiguous situations. Each data type belongs to a category named by a single ASCII character, and each type is either &amp;ldquo;preferred&amp;rdquo; or not within its category. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators. For more details see &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;Chapter 10&lt;/a&gt;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the &amp;ldquo;most general&amp;rdquo; types as being preferred within the category. The &lt;code&gt;category&lt;/code&gt; parameter is especially useful when adding a user-defined type to an existing built-in category, such as the numeric or string types. However, it is also possible to create new entirely-user-defined type categories. Select any ASCII character other than an upper-case letter to name such a category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d165445c71930fc47e32f1799f62450eb66b7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_length&lt;/code&gt; function is discussed in &lt;a href=&quot;functions-string&quot;&gt;Section 9.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77163d06028806a119645154241f80d46c25a3ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checksum&lt;/code&gt; field is the checksum stored in the page, which might be incorrect if the page is somehow corrupted. If data checksums are not enabled for this instance, then the value stored is meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82779e6580b956b5bd325b957d4ac6fe2940b5b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;choose&lt;/code&gt; function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21462edf88e71a2a5abedaf79780415d3cc77658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cidr&lt;/code&gt; type holds an IPv4 or IPv6 network specification. Input and output formats follow Classless Internet Domain Routing conventions. The format for specifying networks is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is the network represented as an IPv4 or IPv6 address, and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If &lt;code&gt;y&lt;/code&gt; is omitted, it is calculated using assumptions from the older classful network numbering system, except it will be at least large enough to include all of the octets written in the input. It is an error to specify a network address that has bits set to the right of the specified netmask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313dbc3735e1e6015db884f05770b0b3141b691a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; data type allows you to eliminate calls to &lt;code&gt;lower&lt;/code&gt; in SQL queries, and allows a primary key to be case-insensitive. &lt;code&gt;citext&lt;/code&gt; is locale-aware, just like &lt;code&gt;text&lt;/code&gt;, which means that the matching of upper case and lower case characters is dependent on the rules of the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting. Again, this behavior is identical to the use of &lt;code&gt;lower&lt;/code&gt; in queries. But because it's done transparently by the data type, you don't have to remember to do anything special in your queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd87bdad25baf813522f25a71f5adc18488d42f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; module provides a case-insensitive character string type, &lt;code&gt;citext&lt;/code&gt;. Essentially, it internally calls &lt;code&gt;lower&lt;/code&gt; when comparing values. Otherwise, it behaves almost exactly like &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdaff8a345f235278633882be7cad6ce5741ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clientcert&lt;/code&gt; authentication option is available for all authentication methods, but only in &lt;code&gt;pg_hba.conf&lt;/code&gt; lines specified as &lt;code&gt;hostssl&lt;/code&gt;. When &lt;code&gt;clientcert&lt;/code&gt; is not specified or is set to &lt;code&gt;no-verify&lt;/code&gt;, the server will still verify any presented client certificates against its CA file, if one is configured &amp;mdash; but it will not insist that a client certificate be presented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c87c5b4f9f4b1dd6255f18fc98a9e79dfa277fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;column_expression&lt;/code&gt; for a column is an XPath 1.0 expression that is evaluated for each row, with the current node from the &lt;code&gt;row_expression&lt;/code&gt; result as its context item, to find the value of the column. If no &lt;code&gt;column_expression&lt;/code&gt; is given, then the column name is used as an implicit path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6cd05e41a967e8fffae0ba56f38e3c8841aa41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; function may optionally be specified to allow the aggregate function to support partial aggregation. If provided, the &lt;code&gt;combinefunc&lt;/code&gt; must combine two &lt;code&gt;state_data_type&lt;/code&gt; values, each containing the result of aggregation over some subset of the input values, to produce a new &lt;code&gt;state_data_type&lt;/code&gt; that represents the result of aggregating over both sets of inputs. This function can be thought of as an &lt;code&gt;sfunc&lt;/code&gt;, where instead of acting upon an individual input row and adding it to the running aggregate state, it adds another aggregate state to the running state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47761aa84c1d418aac8f5102d13fb4baaa2c9ec6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; must be declared as taking two arguments of the &lt;code&gt;state_data_type&lt;/code&gt; and returning a value of the &lt;code&gt;state_data_type&lt;/code&gt;. Optionally this function may be &amp;ldquo;strict&amp;rdquo;. In this case the function will not be called when either of the input states are null; the other state will be taken as the correct result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fe595cccceb2fd23743e43b5600a7fb060859e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite_value&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; syntax results in column expansion of this kind when it appears at the top level of a &lt;a href=&quot;queries-select-lists&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; output list&lt;/a&gt;, a &lt;a href=&quot;dml-returning&quot;&gt;&lt;code&gt;RETURNING&lt;/code&gt; list&lt;/a&gt; in &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;, a &lt;a href=&quot;queries-values&quot;&gt;&lt;code&gt;VALUES&lt;/code&gt; clause&lt;/a&gt;, or a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. In all other contexts (including when nested inside one of those constructs), attaching &lt;code&gt;.*&lt;/code&gt; to a composite value does not change the value, since it means &amp;ldquo;all columns&amp;rdquo; and so the same composite value is produced again. For example, if &lt;code&gt;somefunc()&lt;/code&gt; accepts a composite-valued argument, these queries are the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f0da3cbd2adb16157bd1e6643bd7a0df3d22de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;concat_ws&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the &lt;code&gt;VARIADIC&lt;/code&gt; keyword (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;Section 37.5.5&lt;/a&gt;). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, &lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concat_ws&lt;/code&gt; return NULL, but &lt;code&gt;format&lt;/code&gt; treats a NULL as a zero-element array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a299b1850dd68d90e4960be66574857975c076da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da96468cede4a34e23f2e877f5cf905f10ef78c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function produces a display of hierarchical data that is stored in a table. The table must have a key field that uniquely identifies rows, and a parent-key field that references the parent (if any) of each row. &lt;code&gt;connectby&lt;/code&gt; can display the sub-tree descending from any row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d82cc59d92a5d0a18334cf90938c8ed88a3a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contrib&lt;/code&gt; section contains a number of extensions that provide transforms, which can serve as real-world examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffcb414402375d1d42596e7d3c9b1593a173043" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af73b626e7353c20a6881d071978129473a029ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows deleted. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when deletes were suppressed by a &lt;code&gt;BEFORE DELETE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were deleted by the query (this is not considered an error).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429e699d049ecd7be74bd5a583ab136d3d21eca9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows fetched (possibly zero). Note that in psql, the command tag will not actually be displayed, since psql displays the fetched rows instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0d4008484fc3a6fda992772be11542d78e11a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows inserted or updated. &lt;code&gt;oid&lt;/code&gt; is always 0 (it used to be the OID assigned to the inserted row if &lt;code&gt;count&lt;/code&gt; was exactly one and the target table was declared &lt;code&gt;WITH OIDS&lt;/code&gt; and 0 otherwise, but creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59e6fa3805ce82c8f3b0c639019e005fef26c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows that a &lt;code&gt;FETCH&lt;/code&gt; command with the same parameters would have returned (possibly zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffde14c1ea2e01417c3435708517261d052ddb1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when updates were suppressed by a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were updated by the query (this is not considered an error).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd1175f717b500daf5cf94e2ae95b1e5dd562f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8aadf50544262136fa7d8c76d5edc945fb11396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is used to produce &amp;ldquo;pivot&amp;rdquo; displays, wherein data is listed across the page rather than down. For example, we might have data like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc99faab5d994fa37274aca83e33cbe8ab82de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. It fills the output &lt;code&gt;value&lt;/code&gt; columns, left to right, with the &lt;code&gt;value&lt;/code&gt; fields from these rows. If there are fewer rows in a group than there are output &lt;code&gt;value&lt;/code&gt; columns, the extra output columns are filled with nulls; if there are more rows, the extra input rows are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc54c6a3ee9f1815fead23a991ca1a3cbc31deef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. The output &lt;code&gt;row_name&lt;/code&gt; column, plus any &amp;ldquo;extra&amp;rdquo; columns, are copied from the first row of the group. The output &lt;code&gt;value&lt;/code&gt; columns are filled with the &lt;code&gt;value&lt;/code&gt; fields from rows having matching &lt;code&gt;category&lt;/code&gt; values. If a row's &lt;code&gt;category&lt;/code&gt; does not match any output of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query, its &lt;code&gt;value&lt;/code&gt; is ignored. Output columns whose matching category is not present in any input row of the group are filled with nulls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30aa2f376a61f86fd4ea02ce6152e230c73fa37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function takes a text parameter that is a SQL query producing raw data formatted in the first way, and produces a table formatted in the second way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf52a8ddea78696a7f9befff4ffbcb20d2c48c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstabN&lt;/code&gt; functions are examples of how to set up custom wrappers for the general &lt;code&gt;crosstab&lt;/code&gt; function, so that you need not write out column names and types in the calling &lt;code&gt;SELECT&lt;/code&gt; query. The &lt;code&gt;tablefunc&lt;/code&gt; module includes &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt;, whose output row types are defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ac58ac577c46bd040592fa91e1a077c06d943c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cube&lt;/code&gt; module also provides a GiST index operator class for &lt;code&gt;cube&lt;/code&gt; values. A &lt;code&gt;cube&lt;/code&gt; GiST index can be used to search for values using the &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;@&lt;/code&gt; operators in &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f843170ee2f9efd669c186bf546d0e5dd7a1284a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date_part&lt;/code&gt; function is modeled on the traditional Ingres equivalent to the SQL-standard function &lt;code&gt;extract&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c29b4371698f7a456bc5cd073d69c9abf2e592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;earthdistance&lt;/code&gt; module provides two different approaches to calculating great circle distances on the surface of the Earth. The one described first depends on the &lt;code&gt;cube&lt;/code&gt; module (which &lt;em&gt;must&lt;/em&gt; be installed before &lt;code&gt;earthdistance&lt;/code&gt; can be installed). The second one is based on the built-in &lt;code&gt;point&lt;/code&gt; data type, using longitude and latitude for the coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7890123059537fdc57582740cd61da006402b74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expression&lt;/code&gt; argument of an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; command is subject to variable interpolation and backquote expansion, just like any other backslash command argument. After that it is evaluated like the value of an on/off option variable. So a valid value is any unambiguous case-insensitive match for one of: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;. For example, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;tR&lt;/code&gt; will all be considered to be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7490327a2b864afa9b5748785adec8119b5d2704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function is primarily intended for computational processing. For formatting date/time values for display, see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9a9ab120adc12bc2db1bb30c3120ad00c0facd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function retrieves subfields such as year or hour from date/time values. &lt;code&gt;source&lt;/code&gt; must be a value expression of type &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, or &lt;code&gt;interval&lt;/code&gt;. (Expressions of type &lt;code&gt;date&lt;/code&gt; are cast to &lt;code&gt;timestamp&lt;/code&gt; and can therefore be used as well.) &lt;code&gt;field&lt;/code&gt; is an identifier or string that selects what field to extract from the source value. The &lt;code&gt;extract&lt;/code&gt; function returns values of type &lt;code&gt;double precision&lt;/code&gt;. The following are valid field names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a437c414eaca06c0d45719567f040e8a9a62f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;file_fdw&lt;/code&gt;, which can be used to access data files in the server's file system, or to execute programs on the server and read their output. The data file or program output must be in a format that can be read by &lt;code&gt;COPY FROM&lt;/code&gt;; see &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; for details. Access to data files is currently read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc48dad184d44a7c4859e34f48c4985dbe248e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_clause&lt;/code&gt; specifies the set of rows constituting the &lt;em&gt;window frame&lt;/em&gt;, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode; in each case, it runs from the &lt;code&gt;frame_start&lt;/code&gt; to the &lt;code&gt;frame_end&lt;/code&gt;. If &lt;code&gt;frame_end&lt;/code&gt; is omitted, the end defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d31c525333bb24cffbf41e507f2b1076452ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_exclusion&lt;/code&gt; option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; excludes the current row from the frame. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; excludes the current row and its ordering peers from the frame. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; excludes any peers of the current row from the frame, but not the current row itself. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; simply specifies explicitly the default behavior of not excluding the current row or its peers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c90a36b51a75ac7dbb48737a2d7af10a18b852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function_name&lt;/code&gt; function must have been previously defined using &lt;code&gt;CREATE FUNCTION&lt;/code&gt; and must be defined to accept the correct number of arguments (either one or two) of the indicated types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9897a44892259c96709c3ce90278ea27b2732f53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides several functions to determine similarities and distance between strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90731181621f8d5d3209f6554f81fdd98c3fb7ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides two functions for working with Soundex codes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a076afe3d48bfb5bc5090c4b36aa5c47d792bbb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hstore&lt;/code&gt; type, because of its intrinsic liberality, could contain a lot of different keys. Checking for valid keys is the task of the application. The following examples demonstrate several techniques for checking keys and obtaining statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa50c73dc35b9d5466c5f124d66eb983ecec8b30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;idx_tup_read&lt;/code&gt; and &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts can be different even without any use of bitmap scans, because &lt;code&gt;idx_tup_read&lt;/code&gt; counts index entries retrieved from the index while &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts live rows fetched from the table. The latter will be less if any dead or not-yet-committed rows are fetched using the index, or if any heap fetches are avoided by means of an index-only scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105555b766284240eda53764bbf412df3e426218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inet&lt;/code&gt; type holds an IPv4 or IPv6 host address, and optionally its subnet, all in one field. The subnet is represented by the number of network address bits present in the host address (the &amp;ldquo;netmask&amp;rdquo;). If the netmask is 32 and the address is IPv4, then the value does not indicate a subnet, only a single host. In IPv6, the address length is 128 bits, so 128 bits specify a unique host address. Note that if you want to accept only networks, you should use the &lt;code&gt;cidr&lt;/code&gt; type rather than &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1480b7e9f9737ecb46229fdd00be59d12607dc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;initdb&lt;/code&gt; mode creates a new PostgreSQL database cluster, that is, a collection of databases that will be managed by a single server instance. This mode invokes the &lt;code&gt;initdb&lt;/code&gt; command. See &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc5e8a2b17fca84bdc393620a0520a109ffd200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initdb-options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d1ccc7e1029a4cfe055973c1a279885ae0a68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_function&lt;/code&gt; converts the type's external textual representation to the internal representation used by the operators and functions defined for the type. &lt;code&gt;output_function&lt;/code&gt; performs the reverse transformation. The input function can be declared as taking one argument of type &lt;code&gt;cstring&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;cstring&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is the input text as a C string, the second argument is the type's own OID (except for array types, which instead receive their element type's OID), and the third is the &lt;code&gt;typmod&lt;/code&gt; of the destination column, if known (-1 will be passed if not). The input function must return a value of the data type itself. Usually, an input function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain input functions, which might need to reject NULL inputs.) The output function must be declared as taking one argument of the new data type. The output function must return type &lt;code&gt;cstring&lt;/code&gt;. Output functions are not invoked for NULL values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd3f06b986fa431b874d54dd865659b27cfc58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intagg&lt;/code&gt; module provides an integer aggregator and an enumerator. &lt;code&gt;intagg&lt;/code&gt; is now obsolete, because there are built-in functions that provide a superset of its capabilities. However, the module is still provided as a compatibility wrapper around the built-in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f078a6fe0cf9ef6c6e521625243e1894589ca0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intarray&lt;/code&gt; module provides a number of useful functions and operators for manipulating null-free arrays of integers. There is also support for indexed searches using some of the operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e20537f440b22c9608c2d38b191b83f09961384" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; pseudo-type is used to declare functions that are meant only to be called internally by the database system, and not by direct invocation in an SQL query. If a function has at least one &lt;code&gt;internal&lt;/code&gt;-type argument then it cannot be called from SQL. To preserve the type safety of this restriction it is important to follow this coding rule: do not create any function that is declared to return &lt;code&gt;internal&lt;/code&gt; unless it has at least one &lt;code&gt;internal&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ef30a7477168386c4be2c94609fc89528b3dee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interval&lt;/code&gt; type has an additional option, which is to restrict the set of stored fields by writing one of these phrases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae9c44664a456573cddd9031643c02edb22183c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides data types for the following international product numbering standards: EAN13, UPC, ISBN (books), ISMN (music), and ISSN (serials). Numbers are validated on input according to a hard-coded list of prefixes; this list of prefixes is also used to hyphenate numbers on output. Since new prefixes are assigned from time to time, the list of prefixes may be out of date. It is hoped that a future version of this module will obtained the prefix list from one or more tables that can be easily updated by users as needed; however, at present, the list can only be updated by modifying the source code and recompiling. Alternatively, prefix validation and hyphenation support may be dropped from a future version of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9815d1f84bba26cf75ea57db75cbb748c781beb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the following pairs of type casts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d136969e19c7266e1a9a82b8a9977ef2ab272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the standard comparison operators, plus B-tree and hash indexing support for all these data types. In addition there are several specialized functions; shown in &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;Table F.12&lt;/a&gt;. In this table, &lt;code&gt;isn&lt;/code&gt; means any one of the module's data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0300aa881bba7f19acdd017cb9ddd3ccdf7dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; data types accept &lt;em&gt;almost&lt;/em&gt; identical sets of values as input. The major practical difference is one of efficiency. The &lt;code&gt;json&lt;/code&gt; data type stores an exact copy of the input text, which processing functions must reparse on each execution; while &lt;code&gt;jsonb&lt;/code&gt; data is stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. &lt;code&gt;jsonb&lt;/code&gt; also supports indexing, which can be a significant advantage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18a0defa6788cb12c053fbf70d6cdb3c5a6ee90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json_typeof&lt;/code&gt; function's &lt;code&gt;null&lt;/code&gt; return value should not be confused with a SQL NULL. While calling &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;, calling &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; will return a SQL NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168cc05ce6845d58616f3f7646b54fd243f5124d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonb_path_exists&lt;/code&gt;, &lt;code&gt;jsonb_path_match&lt;/code&gt;, &lt;code&gt;jsonb_path_query&lt;/code&gt;, &lt;code&gt;jsonb_path_query_array&lt;/code&gt;, and &lt;code&gt;jsonb_path_query_first&lt;/code&gt; functions have optional &lt;code&gt;vars&lt;/code&gt; and &lt;code&gt;silent&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772704f4d66d5faa09292e5f927a415dbd1364fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonpath&lt;/code&gt; type implements support for the SQL/JSON path language in PostgreSQL to efficiently query JSON data. It provides a binary representation of the parsed SQL/JSON path expression that specifies the items to be retrieved by the path engine from the JSON data for further processing with the SQL/JSON query functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2149f5c0dd4945e41bb0756947056ef98b639170" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like_type&lt;/code&gt; parameter provides an alternative method for specifying the basic representation properties of a data type: copy them from some existing type. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from the named type. (It is possible, though usually undesirable, to override some of these values by specifying them along with the &lt;code&gt;LIKE&lt;/code&gt; clause.) Specifying representation this way is especially useful when the low-level implementation of the new type &amp;ldquo;piggybacks&amp;rdquo; on an existing type in some fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d22eb5dee38146c30421a70885a4db31297786e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module allows fixing this by attaching a trigger to tables that contain LO reference columns. The trigger essentially just does a &lt;code&gt;lo_unlink&lt;/code&gt; whenever you delete or modify a value referencing a large object. When you use this trigger, you are assuming that there is only one database reference to any large object that is referenced in a trigger-controlled column!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e1b86fc89c1b3ca96870ada2d42cd830ee60fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module provides support for managing Large Objects (also called LOs or BLOBs). This includes a data type &lt;code&gt;lo&lt;/code&gt; and a trigger &lt;code&gt;lo_manage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1213fb426cb2334040aa09e1426c55587c855d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no lower bound. Likewise, &lt;code&gt;upper-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no upper bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4962a0009307ba6431284c97bb49876d7ddc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt; functions return null if the range is empty or the requested bound is infinite. The &lt;code&gt;lower_inc&lt;/code&gt;, &lt;code&gt;upper_inc&lt;/code&gt;, &lt;code&gt;lower_inf&lt;/code&gt;, and &lt;code&gt;upper_inf&lt;/code&gt; functions all return false for an empty range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7854ce56999a9ecbf4528c8d9ad238714a056945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ltree&lt;/code&gt; module provides several data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5d05ac37c953266fc286bdc00b9352cf6192f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee970738f8a83aad38467525f7f37d7c159f8d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type stores MAC addresses in EUI-64 format, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). This type can accept both 6 and 8 byte length MAC addresses and stores them in 8 byte length format. MAC addresses given in 6 byte format will be stored in 8 byte length format with the 4th and 5th bytes set to FF and FE, respectively. Note that IPv6 uses a modified EUI-64 format where the 7th bit should be set to one after the conversion from EUI-48. The function &lt;code&gt;macaddr8_set7bit&lt;/code&gt; is provided to make this change. Generally speaking, any input which is comprised of pairs of hex digits (on byte boundaries), optionally separated consistently by one of &lt;code&gt;':'&lt;/code&gt;, &lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'.'&lt;/code&gt;, is accepted. The number of hex digits must be either 16 (8 bytes) or 12 (6 bytes). Leading and trailing whitespace is ignored. The following are examples of input formats that are accepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d79930eaf5f7ce13b46f6856c277aea9ede8da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for lexicographical ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebc662e3381183673c8582b7b95fb9aee6ddcc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type stores MAC addresses, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). Input is accepted in the following formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb88e6f4baf5008ffda8309a1c86c82f34be1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxlen&lt;/code&gt; parameter specifies the maximum number of digits allowed in an integer word. The default value is 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0858eea09f10a0e5d0453c7f76531a7abbd443b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;md5&lt;/code&gt; method cannot be used with the &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace&lt;/a&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b398ca59b1e24ecdf79b1f3151e58ecf006b28e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;avg()&lt;/code&gt; aggregates are computed concurrently over all the input rows, so if any row has &lt;code&gt;employees&lt;/code&gt; equal to zero, the division-by-zero error will occur before there is any opportunity to test the result of &lt;code&gt;min()&lt;/code&gt;. Instead, use a &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; clause to prevent problematic input rows from reaching an aggregate function in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa5889a0b42548324335d58d566964f3bd48031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;money&lt;/code&gt; type stores a currency amount with a fixed fractional precision; see &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;Table 8.3&lt;/a&gt;. The fractional precision is determined by the database's &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; setting. The range shown in the table assumes there are two fractional digits. Input is accepted in a variety of formats, including integer and floating-point literals, as well as typical currency formatting, such as &lt;code&gt;'$1,000.00'&lt;/code&gt;. Output is generally in the latter form but depends on the locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591d71ee5e714d1d5bb09ebf8473fd24333cc869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type is currently implemented as an unsigned four-byte integer. Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dc4927f04eeaf9a8229a0fc622fc80f07cd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type itself has few operations beyond comparison. It can be cast to integer, however, and then manipulated using the standard integer operators. (Beware of possible signed-versus-unsigned confusion if you do this.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90126f847a19f26e444b96e74dbf5fc70037caf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open_&lt;/code&gt;* options also use &lt;code&gt;O_DIRECT&lt;/code&gt; if available. Not all of these choices are available on all platforms. The default is the first method in the above list that is supported by the platform, except that &lt;code&gt;fdatasync&lt;/code&gt; is the default on Linux. The default is not necessarily ideal; it might be necessary to change this setting or other aspects of your system configuration in order to create a crash-safe configuration or achieve optimal performance. These aspects are discussed in &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1deebe3b08e139dca519f072e65bc0913b196cc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e287f99758c3cdb10c1fc61789ee15a8d908a550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pageinspect&lt;/code&gt; module provides functions that allow you to inspect the contents of database pages at a low level, which is useful for debugging purposes. All of these functions may be used only by superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530a467c47cea19dd0c00ec1dbc483debfa27dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partition_bound_spec&lt;/code&gt; must correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form with &lt;code&gt;IN&lt;/code&gt; is used for list partitioning, the form with &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;TO&lt;/code&gt; is used for range partitioning, and the form with &lt;code&gt;WITH&lt;/code&gt; is used for hash partitioning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321cdf6012708ec28d857a16216ddd141b4795b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passwordcheck&lt;/code&gt; module checks users' passwords whenever they are set with &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. If a password is considered too weak, it will be rejected and the command will terminate with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ab56758cab8beb34df6aa406664611103452cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;penalty&lt;/code&gt; function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca57d9a0482509128492e1b7deb298ac5bcf1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view is read only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30cddb8256b97d7a85be6f99c4ef44cdaa252a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view lists the specific extension versions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7d98e76ccc0a3eea34c953f9960047fdf4d011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view is read only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5019d9408165c6f3daf9b540d710ea624fb4f2a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view lists the extensions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23147896a0bb8cdf56e9c2215878569d76558769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_buffercache&lt;/code&gt; module provides a means for examining what's happening in the shared buffer cache in real time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f64b3a0516da571bdaabc8707c7cfc6382a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_constraint&lt;/code&gt; entry associated with the trigger, if any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3b068150ce34aa7d8adbd51da299ff6a0e91b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view displays cursors created by any of these means. Cursors only exist for the duration of the transaction that defines them, unless they have been declared &lt;code&gt;WITH HOLD&lt;/code&gt;. Therefore non-holdable cursors are only present in the view until the end of their creating transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769140bc4ff0be33d8261a2c2495473c9aa06419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view is read only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943080f1bca8bfb0a861af0a7366bc0f87ecea56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view lists the cursors that are currently available. Cursors can be defined in several ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9e99ef77cc93d164810339140c3e9aee6dc96a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_enum&lt;/code&gt; catalog contains entries showing the values and labels for each enum type. The internal representation of a given enum value is actually the OID of its associated row in &lt;code&gt;pg_enum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85db4109eb0a5caec74c9817c0a2aae5033501c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_freespacemap&lt;/code&gt; module provides a means for examining the free space map (FSM). It provides a function called &lt;code&gt;pg_freespace&lt;/code&gt;, or two overloaded functions, to be precise. The functions show the value recorded in the free space map for a given page, or for all pages in the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26269fc6d836fb10263bde9dc1a6bf13ade8034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_hba.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04191b45aa50aed85c91e48e8294ab1b8975519d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ident.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27acedebfd1c20546e890a5790d75026d8a69e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_locks&lt;/code&gt; view displays data from both the regular lock manager and the predicate lock manager, which are separate systems; in addition, the regular lock manager subdivides its locks into regular and &lt;em&gt;fast-path&lt;/em&gt; locks. This data is not guaranteed to be entirely consistent. When the view is queried, data on fast-path locks (with &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;) is gathered from each backend one at a time, without freezing the state of the entire lock manager, so it is possible for locks to be taken or released while information is gathered. Note, however, that these locks are known not to conflict with any other lock currently in place. After all backends have been queried for fast-path locks, the remainder of the regular lock manager is locked as a unit, and a consistent snapshot of all remaining locks is collected as an atomic action. After unlocking the regular lock manager, the predicate lock manager is similarly locked and all predicate locks are collected as an atomic action. Thus, with the exception of fast-path locks, each lock manager will deliver a consistent set of results, but as we do not lock both lock managers simultaneously, it is possible for locks to be taken or released after we interrogate the regular lock manager and before we interrogate the predicate lock manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc09426bbd89792d56d781e38f0585623a0a6b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_lsn&lt;/code&gt; data type can be used to store LSN (Log Sequence Number) data which is a pointer to a location in the WAL. This type is a representation of &lt;code&gt;XLogRecPtr&lt;/code&gt; and an internal system type of PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2453f80583b015c097d94096a21e07fa08a7d653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_mcv_list_items&lt;/code&gt; function can be used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dd30f02c62fffd16e92aa745931812e6881ee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_monitor&lt;/code&gt;, &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; roles are intended to allow administrators to easily configure a role for the purpose of monitoring the database server. They grant a set of common privileges allowing the role to read various useful configuration settings, statistics and other system information normally restricted to superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d719c2beab0d60be72a57746a97a87438b5577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view displays all the prepared statements that are available in the current session. See &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; for more information about prepared statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0733b71ce39a3b0da7d8656a3e5bc9319c9957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view is read only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712cfe11a273eb23a78bfc37d1131dc7151bd1af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prewarm&lt;/code&gt; module provides a convenient way to load relation data into either the operating system buffer cache or the PostgreSQL buffer cache. Prewarming can be performed manually using the &lt;code&gt;pg_prewarm&lt;/code&gt; function, or can be performed automatically by including &lt;code&gt;pg_prewarm&lt;/code&gt; in &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;. In the latter case, the system will run a background worker which periodically records the contents of shared buffers in a file called &lt;code&gt;autoprewarm.blocks&lt;/code&gt; and will, using 2 background workers, reload those same blocks after a restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5fc12234ea79efc44835461370ba2ea861b98c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt; and &lt;code&gt;pg_execute_server_program&lt;/code&gt; roles are intended to allow administrators to have trusted, but non-superuser, roles which are able to access files and run programs on the database server as the user the database runs as. As these roles are able to access any file on the server file system, they bypass all database-level permission checks when accessing files directly and they could be used to gain superuser-level access, therefore great care should be taken when granting these roles to users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f7cb10a03b4cb92179c151a9345f858223dd84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_relation_filepath()&lt;/code&gt; function shows the entire path (relative to &lt;code&gt;PGDATA&lt;/code&gt;) of any relation. It is often useful as a substitute for remembering many of the above rules. But keep in mind that this function just gives the name of the first segment of the main fork of the relation &amp;mdash; you may need to append a segment number and/or &lt;code&gt;_fsm&lt;/code&gt;, &lt;code&gt;_vm&lt;/code&gt;, or &lt;code&gt;_init&lt;/code&gt; to find all the files associated with the relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e84c5eab2e8606b5c93d96958f3280a2a3feb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin&lt;/code&gt; catalog contains all replication origins created. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94519dfaf1a7e0c715cbe6d005de1e67132adafc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin_status&lt;/code&gt; view contains information about how far replay for a certain origin has progressed. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aff87cbf65850e431b7483477c97e1f7e57d54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_slots&lt;/code&gt; view provides a listing of all replication slots that currently exist on the database cluster, along with their current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e21895d1c29cfa7bd5d292f490ca241b01ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_rules&lt;/code&gt; view excludes the &lt;code&gt;ON SELECT&lt;/code&gt; rules of views and materialized views; those can be seen in &lt;code&gt;pg_views&lt;/code&gt; and &lt;code&gt;pg_matviews&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04c9372466f179b32ff250ffc0d648d21a6075f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_settings&lt;/code&gt; view cannot be inserted into or deleted from, but it can be updated. An &lt;code&gt;UPDATE&lt;/code&gt; applied to a row of &lt;code&gt;pg_settings&lt;/code&gt; is equivalent to executing the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command on that named parameter. The change only affects the value used by the current session. If an &lt;code&gt;UPDATE&lt;/code&gt; is issued within a transaction that is later aborted, the effects of the &lt;code&gt;UPDATE&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959ff59e7cb2ea926dc414727d1a287d75002cdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_signal_backend&lt;/code&gt; role is intended to allow administrators to enable trusted, but non-superuser, roles to send signals to other backends. Currently this role enables sending of signals for canceling a query on another backend or terminating its session. A user granted this role cannot however send signals to a backend owned by a superuser. See &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364ec70800885a32c9b384791eb887b060833388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_activity&lt;/code&gt; view will have one row per server process, showing information related to the current activity of that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5cfe66d3c739cee322847b588c9d5b35df5eee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about accesses to that specific index. The &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; and &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4915eaf62d5fac508cd463bbfeb67c5bc9a1f887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about accesses to that specific table. The &lt;code&gt;pg_stat_user_tables&lt;/code&gt; and &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e920a84446b775991fa1eb14f7bc867a07c08969" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_archiver&lt;/code&gt; view will always have a single row, containing data about the archiver process of the cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fdaad38e5659f088cd956997f18528cb8adec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view will always have a single row, containing global data for the cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393da291bc9e23ea3e77a3450fa686048aaf2442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database&lt;/code&gt; view will contain one row for each database in the cluster, plus one for the shared objects, showing database-wide statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c93e50dd3fc817fe9ad114869b45a8e9cc6f37d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; view will contain one row per database, showing database-wide statistics about query cancels occurring due to conflicts with recovery on standby servers. This view will only contain information on standby servers, since conflicts do not occur on master servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca86aca5bdcd3b49612a77c80efa58451d60340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_gssapi&lt;/code&gt; view will contain one row per backend, showing information about GSSAPI usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d861488085903be47118e7cb1eda5ee9716d20c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_replication&lt;/code&gt; view will contain one row per WAL sender process, showing statistics about replication to that sender's connected standby server. Only directly connected standbys are listed; no information is available about downstream standby servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc5431a476a7e29631b45416342385e30449578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_ssl&lt;/code&gt; view will contain one row per backend or WAL sender process, showing statistics about SSL usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf211b37dbd6853dfd5eb7dd10c7c12b2c0042c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; module provides a means for tracking execution statistics of all SQL statements executed by a server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e909d7ac4e2a7927d69b3536cd3fab24324d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; view is defined in terms of a function also named &lt;code&gt;pg_stat_statements&lt;/code&gt;. It is possible for clients to call the &lt;code&gt;pg_stat_statements&lt;/code&gt; function directly, and by specifying &lt;code&gt;showtext := false&lt;/code&gt; have query text be omitted (that is, the &lt;code&gt;OUT&lt;/code&gt; argument that corresponds to the view's &lt;code&gt;query&lt;/code&gt; column will return nulls). This feature is intended to support external tools that might wish to avoid the overhead of repeatedly retrieving query texts of indeterminate length. Such tools can instead cache the first query text observed for each entry themselves, since that is all &lt;code&gt;pg_stat_statements&lt;/code&gt; itself does, and then retrieve query texts only as needed. Since the server stores query texts in a file, this approach may reduce physical I/O for repeated examination of the &lt;code&gt;pg_stat_statements&lt;/code&gt; data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb8ed00a27312be8d978730672b0b28bbcb5469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_subscription&lt;/code&gt; view will contain one row per subscription for main worker (with null PID if the worker is not running), and additional rows for workers handling the initial data copy of the subscribed tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b53f5c8cdaebaaf4ec10ef70cc41030a5f49c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_user_functions&lt;/code&gt; view will contain one row for each tracked function, showing statistics about executions of that function. The &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; parameter controls exactly which functions are tracked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192cc2da4edef74cee3104eea30272179c17353c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; view will contain only one row, showing statistics about the WAL receiver from that receiver's connected server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb7822cb6072c4067c2cc69eddb66f1fcb783d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_&lt;/code&gt; views are primarily useful to determine the effectiveness of the buffer cache. When the number of actual disk reads is much smaller than the number of buffer hits, then the cache is satisfying most read requests without invoking a kernel call. However, these statistics do not give the entire story: due to the way in which PostgreSQL handles disk I/O, data that is not in the PostgreSQL buffer cache might still reside in the kernel's I/O cache, and might therefore still be fetched without requiring a physical read. Users interested in obtaining more detailed information on PostgreSQL I/O behavior are advised to use the PostgreSQL statistics collector in combination with operating system utilities that allow insight into the kernel's handling of I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4275ef4261b6d2382694080172180d4c6bb50fe7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about I/O on that specific index. The &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; and &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633f3d97ee7656ef624fbb5d36d3f8580d36168e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; view will contain one row for each sequence in the current database, showing statistics about I/O on that specific sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f0cb49815d4460862c6bbe716f068280da5e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about I/O on that specific table. The &lt;code&gt;pg_statio_user_tables&lt;/code&gt; and &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e3b64868b02c0a85487789a181915c3308f04e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statistic_ext&lt;/code&gt; entry is filled in completely during &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, but the actual statistical values are not computed then. Subsequent &lt;code&gt;ANALYZE&lt;/code&gt; commands compute the desired values and populate an entry in the &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab16db4ae44ab46362ea23499bbb4d24c58bacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stop_backup&lt;/code&gt; will return one row with three values. The second of these fields should be written to a file named &lt;code&gt;backup_label&lt;/code&gt; in the root directory of the backup. The third field should be written to a file named &lt;code&gt;tablespace_map&lt;/code&gt; unless the field is empty. These files are vital to the backup working, and must be written without modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccb3d590fa85ee9247d7f4bf77a2f3efc4344c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides GiST and GIN index operator classes that allow you to create an index over a text column for the purpose of very fast similarity searches. These index types support the above-described similarity operators, and additionally support trigram-based index searches for &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; queries. (These indexes do not support equality nor simple comparison operators, so you may need a regular B-tree index too.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7db08f494b7bd6b75737a77c0ee6584bbbf782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides functions and operators for determining the similarity of alphanumeric text based on trigram matching, as well as index operator classes that support fast searching for similar strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0591f005154500c944add92ac3b7183691fb1ca4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config&lt;/code&gt; catalog contains entries representing text search configurations. A configuration specifies a particular text search parser and a list of dictionaries to use for each of the parser's output token types. The parser is shown in the &lt;code&gt;pg_ts_config&lt;/code&gt; entry, but the token-to-dictionary mapping is defined by subsidiary entries in &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt;&lt;code&gt;pg_ts_config_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3b9b0c162846ed7796c343a7cd6db3dce66f59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config_map&lt;/code&gt; catalog contains entries showing which text search dictionaries should be consulted, and in what order, for each output token type of each text search configuration's parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1aa79ed96a9f64450a185ab7801c634f26ba881" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_dict&lt;/code&gt; catalog contains entries defining text search dictionaries. A dictionary depends on a text search template, which specifies all the implementation functions needed; the dictionary itself provides values for the user-settable parameters supported by the template. This division of labor allows dictionaries to be created by unprivileged users. The parameters are specified by a text string &lt;code&gt;dictinitoption&lt;/code&gt;, whose format and meaning vary depending on the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214cf3524f01d220fbc4c1ed75c24082b9d19637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_parser&lt;/code&gt; catalog contains entries defining text search parsers. A parser is responsible for splitting input text into lexemes and assigning a token type to each lexeme. Since a parser must be implemented by C-language-level functions, creation of new parsers is restricted to database superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb87e8d8ef4d72f7f47347f20f99911a07cb666c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_template&lt;/code&gt; catalog contains entries defining text search templates. A template is the implementation skeleton for a class of text search dictionaries. Since a template must be implemented by C-language-level functions, creation of new templates is restricted to database superusers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98aec2c9411d89139f2d3f0f94ddaca8b8727976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_visibility&lt;/code&gt; module provides a means for examining the visibility map (VM) and page-level visibility information of a table. It also provides functions to check the integrity of a visibility map and to force it to be rebuilt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebe4e3ccf987f601f3ce63d73da2ecfe326511d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgcrypto&lt;/code&gt; module provides cryptographic functions for PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7582806e57c12c2e0e98376d6a43f53ffd981a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgrowlocks&lt;/code&gt; module provides a function to show row locking information for a specified table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa04313fa7e95bfad5b3c29fac2331cea3b0811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgstattuple&lt;/code&gt; module provides various functions to obtain tuple-level statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3550763c8f87c7c5071a2ae4590cbccf7d821554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; column can be joined to the &lt;code&gt;pid&lt;/code&gt; column of the &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; view to get more information on the session holding or awaiting each lock, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1772c228a2ba486f02c419b09475ac82a8dda4c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type is an example of a PostgreSQL-specific data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d33330f4a5a6a6e60ef800433563c926a762925" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type requires a coordinate pair as input, as shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5140039e3c9f8558e37b9c94c77a69208747ed9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; command can also be called in single-user mode. The primary use for this mode is during bootstrapping by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Sometimes it is used for debugging or disaster recovery; note that running a single-user server is not truly suitable for debugging the server, since no realistic interprocess communication and locking will happen. When invoked in single-user mode from the shell, the user can enter queries and the results will be printed to the screen, but in a form that is more useful for developers than end users. In the single-user mode, the session user will be set to the user with ID 1, and implicit superuser powers are granted to this user. This user does not actually have to exist, so the single-user mode can be used to manually recover from certain kinds of accidental damage to the system catalogs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73edbc735e1da3f91be137ad83f38e16d0101877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; database is also created when a database cluster is initialized. This database is meant as a default database for users and applications to connect to. It is simply a copy of &lt;code&gt;template1&lt;/code&gt; and can be dropped and recreated if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c82b8fca9884597f624dea1153620a237bd20b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; program also takes a number of other command-line options. For more information, see the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page and &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7330a81519eca7bce15eddcdea10af1a633af88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; server uses &lt;code&gt;SIGQUIT&lt;/code&gt; to tell subordinate server processes to terminate without normal cleanup. This signal &lt;em&gt;should not&lt;/em&gt; be used by users. It is also unwise to send &lt;code&gt;SIGKILL&lt;/code&gt; to a server process &amp;mdash; the main &lt;code&gt;postgres&lt;/code&gt; process will interpret this as a crash and will force all the sibling processes to quit as part of its standard crash-recovery procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92653f4d0fd5ea002d544c735e92bfa8e8c8314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;postgres_fdw&lt;/code&gt;, which can be used to access data stored in external PostgreSQL servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e090ec42938a8e07ce95bbef3862c409a5d10ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgresql.conf&lt;/code&gt; file can also contain &lt;code&gt;include_dir&lt;/code&gt; directives, which specify an entire directory of configuration files to include. These look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d5fb19af808b68f842086f75de8bd4758fc142" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;predicate&lt;/code&gt; allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b637034a943affe6ee006c1f9d5b95a5ccbc7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;psql&lt;/code&gt; program has a number of internal commands that are not SQL commands. They begin with the backslash character, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce36c6cfc7d62a93cbf69277d65d4367aa5df13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quad_point_ops&lt;/code&gt;, &lt;code&gt;kd_point_ops&lt;/code&gt; and &lt;code&gt;poly_ops&lt;/code&gt; operator classes support the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ordering operator, which enables the k-nearest neighbor (&lt;code&gt;k-NN&lt;/code&gt;) search over indexed point or polygon data sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603e4354460ff268426362e0c3963c884ac4c1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random()&lt;/code&gt; function uses a simple linear congruential algorithm. It is fast but not suitable for cryptographic applications; see the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module for a more secure alternative. If &lt;code&gt;setseed()&lt;/code&gt; is called, the results of subsequent &lt;code&gt;random()&lt;/code&gt; calls in the current session are repeatable by re-issuing &lt;code&gt;setseed()&lt;/code&gt; with the same argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0231cb3d8ce00a0c5b86b501f35685f87444ba0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random&lt;/code&gt; function generates values using a uniform distribution, that is all the values are drawn within the specified range with equal probability. The &lt;code&gt;random_exponential&lt;/code&gt;, &lt;code&gt;random_gaussian&lt;/code&gt; and &lt;code&gt;random_zipfian&lt;/code&gt; functions require an additional double parameter which determines the precise shape of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c090601f4f464e87f2fbb4f8206fe29858dd81d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_match&lt;/code&gt; function returns a text array of captured substring(s) resulting from the first match of a POSIX regular expression pattern to a string. It has the syntax &lt;code&gt;regexp_match&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match, the result is &lt;code&gt;NULL&lt;/code&gt;. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains no parenthesized subexpressions, then the result is a single-element text array containing the substring matching the whole pattern. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains parenthesized subexpressions, then the result is a text array whose &lt;code&gt;n&lt;/code&gt;'th element is the substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the &lt;code&gt;pattern&lt;/code&gt; (not counting &amp;ldquo;non-capturing&amp;rdquo; parentheses; see below for details). The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Supported flags are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a9d1b88379c50aed0c3fa7f79c63d3f93f4473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_matches&lt;/code&gt; function returns a set of text arrays of captured substring(s) resulting from matching a POSIX regular expression pattern to a string. It has the same syntax as &lt;code&gt;regexp_match&lt;/code&gt;. This function returns no rows if there is no match, one row if there is a match and the &lt;code&gt;g&lt;/code&gt; flag is not given, or &lt;code&gt;N&lt;/code&gt; rows if there are &lt;code&gt;N&lt;/code&gt; matches and the &lt;code&gt;g&lt;/code&gt; flag is given. Each returned row is a text array containing the whole matched substring or the substrings matching parenthesized subexpressions of the &lt;code&gt;pattern&lt;/code&gt;, just as described above for &lt;code&gt;regexp_match&lt;/code&gt;. &lt;code&gt;regexp_matches&lt;/code&gt; accepts all the flags shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;, plus the &lt;code&gt;g&lt;/code&gt; flag which commands it to return all matches, not just the first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d960616f19511c8709605bafb8561fb42fd92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_replace&lt;/code&gt; function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax &lt;code&gt;regexp_replace&lt;/code&gt;(&lt;code&gt;source&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The &lt;code&gt;source&lt;/code&gt; string is returned unchanged if there is no match to the &lt;code&gt;pattern&lt;/code&gt;. If there is a match, the &lt;code&gt;source&lt;/code&gt; string is returned with the &lt;code&gt;replacement&lt;/code&gt; string substituted for the matching substring. The &lt;code&gt;replacement&lt;/code&gt; string can contain &lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is 1 through 9, to indicate that the source substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the pattern should be inserted, and it can contain &lt;code&gt;\&amp;amp;&lt;/code&gt; to indicate that the substring matching the entire pattern should be inserted. Write &lt;code&gt;\\&lt;/code&gt; if you need to put a literal backslash in the replacement text. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag &lt;code&gt;i&lt;/code&gt; specifies case-insensitive matching, while flag &lt;code&gt;g&lt;/code&gt; specifies replacement of each matching substring rather than only the first one. Supported flags (though not &lt;code&gt;g&lt;/code&gt;) are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5dbc2991320b01f06b6978f16f854503224464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_array&lt;/code&gt; function behaves the same as &lt;code&gt;regexp_split_to_table&lt;/code&gt;, except that &lt;code&gt;regexp_split_to_array&lt;/code&gt; returns its result as an array of &lt;code&gt;text&lt;/code&gt;. It has the syntax &lt;code&gt;regexp_split_to_array&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The parameters are the same as for &lt;code&gt;regexp_split_to_table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d6df08eb9f63de1570ffdc8142a19efaaf0c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_table&lt;/code&gt; function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax &lt;code&gt;regexp_split_to_table&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match to the &lt;code&gt;pattern&lt;/code&gt;, the function returns the &lt;code&gt;string&lt;/code&gt;. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. &lt;code&gt;regexp_split_to_table&lt;/code&gt; supports the flags described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8de7218b8205a5ca7a11a8952394be28359d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rejectlong&lt;/code&gt; parameter specifies whether an overlength integer should be truncated or ignored. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), the dictionary returns the first &lt;code&gt;maxlen&lt;/code&gt; digits of the integer. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the dictionary treats an overlength integer as a stop word, so that it will not be indexed. Note that this also means that such an integer cannot be searched for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f7fc02f4398b9958b820fde1c0031fecdf666d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rows&lt;/code&gt; value is a little tricky because it is not the number of rows processed or scanned by the plan node, but rather the number emitted by the node. This is often less than the number scanned, as a result of filtering by any &lt;code&gt;WHERE&lt;/code&gt;-clause conditions that are being applied at the node. Ideally the top-level rows estimate will approximate the number of rows actually returned, updated, or deleted by the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32edd13f077af046b2b71b1ee64a9b61285ac864" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seg&lt;/code&gt; module includes a GiST index operator class for &lt;code&gt;seg&lt;/code&gt; values. The operators supported by the GiST operator class are shown in &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;Table F.28&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060f961f6a4bd265394e2d5e72b7544d4d3d9777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session_user&lt;/code&gt; is normally the user who initiated the current database connection; but superusers can change this setting with &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;. The &lt;code&gt;current_user&lt;/code&gt; is the user identifier that is applicable for permission checking. Normally it is equal to the session user, but it can be changed with &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. It also changes during the execution of functions with the attribute &lt;code&gt;SECURITY DEFINER&lt;/code&gt;. In Unix parlance, the session user is the &amp;ldquo;real user&amp;rdquo; and the current user is the &amp;ldquo;effective user&amp;rdquo;. &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; are synonyms for &lt;code&gt;current_user&lt;/code&gt;. (The SQL standard draws a distinction between &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;current_user&lt;/code&gt;, but PostgreSQL does not, since it unifies users and roles into a single kind of entity.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2300a7ac4740013d2132caac3afdd183cf0cf9ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sestatus&lt;/code&gt; command allows you to check the status of SELinux. A typical display is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1528675485f3ac22728a56ac6684f04d6015ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; setting is useful to have the instance ready at the exact replay point desired. The instance will still be able to replay more WAL records (and in fact will have to replay WAL records since the last checkpoint next time it is started).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfff4474b03b711fe3d607009c52f929707603f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simple&lt;/code&gt; dictionary template operates by converting the input token to lower case and checking it against a file of stop words. If it is found in the file then an empty array is returned, causing the token to be discarded. If not, the lower-cased form of the word is returned as the normalized lexeme. Alternatively, the dictionary can be configured to report non-stop-words as unrecognized, allowing them to be passed on to the next dictionary in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261a0b38493fc85b48b40ee18eb66df54582ef51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;soundex&lt;/code&gt; function converts a string to its Soundex code. The &lt;code&gt;difference&lt;/code&gt; function converts two strings to their Soundex codes and then reports the number of matching code positions. Since Soundex codes have four characters, the result ranges from zero to four, with zero being no match and four being an exact match. (Thus, the function is misnamed &amp;mdash; &lt;code&gt;similarity&lt;/code&gt; would have been a better name.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ea80f1981124188490dc9028b6ab305b1bc451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sql_standard&lt;/code&gt; style produces output that conforms to the SQL standard's specification for interval literal strings, if the interval value meets the standard's restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1517c885d0f9ba998151ca37f036c0bd997847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sslinfo&lt;/code&gt; module provides information about the SSL certificate that the current client provided when connecting to PostgreSQL. The module is useless (most functions will return NULL) if the current connection does not use SSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9a65154d6a387434a029c400053d901ea5349c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;storage&lt;/code&gt; parameter allows selection of storage strategies for variable-length data types. (Only &lt;code&gt;plain&lt;/code&gt; is allowed for fixed-length types.) &lt;code&gt;plain&lt;/code&gt; specifies that data of the type will always be stored in-line and not compressed. &lt;code&gt;extended&lt;/code&gt; specifies that the system will first try to compress a long data value, and will move the value out of the main table row if it's still too long. &lt;code&gt;external&lt;/code&gt; allows the value to be moved out of the main table, but the system will not try to compress it. &lt;code&gt;main&lt;/code&gt; allows compression, but discourages moving the value out of the main table. (Data items with this storage strategy might still be moved out of the main table if there is no other way to make a row fit, but they will be kept in the main table preferentially over &lt;code&gt;extended&lt;/code&gt; and &lt;code&gt;external&lt;/code&gt; items.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d900c212bdba8eb8ed8106792c420e1bbe3e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with three parameters provides extraction of a substring that matches an SQL regular expression pattern. The function can be written according to SQL99 syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c583000c12edad2a23f1677f8c511b9802bf22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with two parameters, &lt;code&gt;substring(string from pattern)&lt;/code&gt;, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6de727710530de8b72a4404a0cd48c771eb547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;synonym&lt;/code&gt; template also has an optional parameter &lt;code&gt;CaseSensitive&lt;/code&gt;, which defaults to &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;CaseSensitive&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, words in the synonym file are folded to lower case, as are input tokens. When it is &lt;code&gt;true&lt;/code&gt;, words and tokens are not folded to lower case, but are compared as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07e672b3264d398cb9ebee058a21feb90ad8f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_len&lt;/code&gt; will always be greater than the sum of the &lt;code&gt;tuple_len&lt;/code&gt;, &lt;code&gt;dead_tuple_len&lt;/code&gt; and &lt;code&gt;free_space&lt;/code&gt;. The difference is accounted for by fixed page overhead, the per-page table of pointers to tuples, and padding to ensure that tuples are correctly aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f00658cdbd1a37668746a630df6795de40f40a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablefunc&lt;/code&gt; module includes various functions that return tables (that is, multiple rows). These functions are useful both in their own right and as examples of how to write C functions that return multiple rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdf44adfa31acc1639b19ed48b2eb69211df790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new materialized view is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ab317f2006a81d25a82a98e87d5a85e8a273f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f686e75d0e393aa19100c981a93d00a43780aed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overrides &lt;code&gt;default_tablespace&lt;/code&gt; as the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4265a037b613093215c3a2b0f1964512919269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tcn&lt;/code&gt; module provides a trigger function that notifies listeners of changes to any table on which it is attached. It must be used as an &lt;code&gt;AFTER&lt;/code&gt; trigger &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aaa8650f37c6cdde06430e667abefb0767b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_char&lt;/code&gt; family of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e895ae79ff8443b98ab632e79a7fde4140eb2a9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_regclass&lt;/code&gt;, &lt;code&gt;to_regproc&lt;/code&gt;, &lt;code&gt;to_regprocedure&lt;/code&gt;, &lt;code&gt;to_regoper&lt;/code&gt;, &lt;code&gt;to_regoperator&lt;/code&gt;, &lt;code&gt;to_regtype&lt;/code&gt;, &lt;code&gt;to_regnamespace&lt;/code&gt;, and &lt;code&gt;to_regrole&lt;/code&gt; functions translate relation, function, operator, type, schema, and role names (given as &lt;code&gt;text&lt;/code&gt;) to objects of type &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, and &lt;code&gt;regrole&lt;/code&gt; respectively. These functions differ from a cast from text in that they don't accept a numeric OID, and that they return null rather than throwing an error if the name is not found (or, for &lt;code&gt;to_regproc&lt;/code&gt; and &lt;code&gt;to_regoper&lt;/code&gt;, if the given name matches multiple objects).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc966f611788c95433ef51cb7b635ecd99368eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_tsvector&lt;/code&gt; function internally calls a parser which breaks the document text into tokens and assigns a type to each token. For each token, a list of dictionaries (&lt;a href=&quot;textsearch-dictionaries&quot;&gt;Section 12.6&lt;/a&gt;) is consulted, where the list can vary depending on the token type. The first dictionary that &lt;em&gt;recognizes&lt;/em&gt; the token emits one or more normalized &lt;em&gt;lexemes&lt;/em&gt; to represent the token. For example, &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt; because one of the dictionaries recognized that the word &lt;code&gt;rats&lt;/code&gt; is a plural form of &lt;code&gt;rat&lt;/code&gt;. Some words are recognized as &lt;em&gt;stop words&lt;/em&gt; (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;), which causes them to be ignored since they occur too frequently to be useful in searching. In our example these are &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;it&lt;/code&gt;. If no dictionary in the list recognizes the token then it is also ignored. In this example that happened to the punctuation sign &lt;code&gt;-&lt;/code&gt; because there are in fact no dictionaries assigned for its token type (&lt;code&gt;Space symbols&lt;/code&gt;), meaning space tokens will never be indexed. The choices of parser, dictionaries and which types of tokens to index are determined by the selected text search configuration (&lt;a href=&quot;textsearch-configuration&quot;&gt;Section 12.7&lt;/a&gt;). It is possible to have many different configurations in the same database, and predefined configurations are available for various languages. In our example we used the default configuration &lt;code&gt;english&lt;/code&gt; for the English language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a8b2b35ba5bb7ac691f2af5d9013c610a29764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function expects a single &lt;em&gt;token&lt;/em&gt;, not text. Here is a case where this can be confusing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414a4e254a9e67a84663f59263f88c95c42cfbfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function facilitates dictionary testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acca59985cbdc80cca43fe97ac114ac2ea61d90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_rewrite&lt;/code&gt; family of functions search a given &lt;code&gt;tsquery&lt;/code&gt; for occurrences of a target subquery, and replace each occurrence with a substitute subquery. In essence this operation is a &lt;code&gt;tsquery&lt;/code&gt;-specific version of substring replacement. A target and substitute combination can be thought of as a &lt;em&gt;query rewrite rule&lt;/em&gt;. A collection of such rewrite rules can be a powerful search aid. For example, you can expand the search using synonyms (e.g., &lt;code&gt;new york&lt;/code&gt;, &lt;code&gt;big apple&lt;/code&gt;, &lt;code&gt;nyc&lt;/code&gt;, &lt;code&gt;gotham&lt;/code&gt;) or narrow the search to direct the user to some hot topic. There is some overlap in functionality between this feature and thesaurus dictionaries (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;). However, you can modify a set of rewrite rules on-the-fly without reindexing, whereas updating a thesaurus requires reindexing to be effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ce57d748f7a336aa1b84fb89aaf298351d6555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_rows&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2660bd7bfa7364869659c121d8520debb99419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_time&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_TIME&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390aa178cbfa17e56fd10d81213ce2e7d202995c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsquery&lt;/code&gt; containment operators consider only the lexemes listed in the two queries, ignoring the combining operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94003b7d5e3893485cdec1b88bc0aea54d3d7f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsvector&lt;/code&gt; concatenation operator returns a vector which combines the lexemes and positional information of the two vectors given as arguments. Positions and weight labels are retained during the concatenation. Positions appearing in the right-hand vector are offset by the largest position mentioned in the left-hand vector, so that the result is nearly equivalent to the result of performing &lt;code&gt;to_tsvector&lt;/code&gt; on the concatenation of the two original document strings. (The equivalence is not exact, because any stop-words removed from the end of the left-hand argument will not affect the result, whereas they would have affected the positions of the lexemes in the right-hand argument if textual concatenation were used.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e34183b8dfafa188cf43b0a5c4b0041a97f2d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unaccent()&lt;/code&gt; function removes accents (diacritic signs) from a given string. Basically, it's a wrapper around &lt;code&gt;unaccent&lt;/code&gt;-type dictionaries, but it can be used outside normal text search contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb54fa28d01791fcb6f7f658cdfdf7f9c3926fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2537a13fb0c8fd0778a9239206e8184aecf1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uuid-ossp&lt;/code&gt; module provides functions to generate universally unique identifiers (UUIDs) using one of several standard algorithms. There are also functions to produce certain special UUID constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33dc4b6b3f3d4e4e7276aab8066c7be89f11d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; must be a number. In general, the higher the number the more borders and lines the tables will have, but details depend on the particular format. In HTML format, this will translate directly into the &lt;code&gt;border=...&lt;/code&gt; attribute. In most other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense, and values above 2 will be treated the same as &lt;code&gt;border = 2&lt;/code&gt;. The &lt;code&gt;latex&lt;/code&gt; and &lt;code&gt;latex-longtable&lt;/code&gt; formats additionally allow a value of 3 to add dividing lines between data rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed006ed7919dad8517461e6b9bbcdfb9261bd7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait_event&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; columns are independent. If a backend is in the &lt;code&gt;active&lt;/code&gt; state, it may or may not be &lt;code&gt;waiting&lt;/code&gt; on some event. If the state is &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;wait_event&lt;/code&gt; is non-null, it means that a query is being executed, but is being blocked somewhere in the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0125e5f4ec341f59b7fbf88d54a9be3ac7c60904" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml2&lt;/code&gt; module provides XPath querying and XSLT functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ee7c238579a8efef3d1bbe76947df3fd98bf79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type can be used to store XML data. Its advantage over storing XML data in a &lt;code&gt;text&lt;/code&gt; field is that it checks the input values for well-formedness, and there are support functions to perform type-safe operations on it; see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.14&lt;/a&gt;. Use of this data type requires the installation to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e872bad693cf86fd556718feb449776c1f39b558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type is unusual in that it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an &lt;code&gt;xml&lt;/code&gt; column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e179d52ab69f7b0f66292f2459b29798716de6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type can store well-formed &amp;ldquo;documents&amp;rdquo;, as defined by the XML standard, as well as &amp;ldquo;content&amp;rdquo; fragments, which are defined by reference to the more permissive &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&amp;ldquo;document node&amp;rdquo;&lt;/a&gt; of the XQuery and XPath data model. Roughly, this means that content fragments can have more than one top-level element or character node. The expression &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; can be used to evaluate whether a particular &lt;code&gt;xml&lt;/code&gt; value is a full document or only a content fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fece117905c5ca56558a0c032db75b892af97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML Schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1deef1e666f438cec77e8c3e2e2981fe717c4002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlelement&lt;/code&gt; expression produces an XML element with the given name, attributes, and content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f2f71a5ec8ec9b6b661345ad1ff563285eb198" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlforest&lt;/code&gt; expression produces an XML forest (sequence) of elements using the given names and content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c704d359323afbae05aea7d4c253db38a9779402" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlpi&lt;/code&gt; expression creates an XML processing instruction. The content, if present, must not contain the character sequence &lt;code&gt;?&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483ff2aaee5c62e793871dd92a52c8a7e7cf4d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlroot&lt;/code&gt; expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node's version declaration; if a standalone setting is specified, it replaces the value in the root node's standalone declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194749c8350686b704674839bea4fca3eca2b901" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmltable&lt;/code&gt; function produces a table based on the given XML value, an XPath filter to extract rows, and a set of column definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241345ed65eaa6c1efb430df3084f0d4151592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xpath_table&lt;/code&gt; function assumes that the results of each XPath query might be multivalued, so the number of rows returned by the function may not be the same as the number of input documents. The first row returned contains the first result from each query, the second row the second result from each query. If one of the queries has fewer values than the others, null values will be returned instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f26d57e1c368d060299c1c81b28042f79fcca60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; operator concatenates the elements at the top level of each of its operands. It does not operate recursively. For example, if both operands are objects with a common key field name, the value of the field in the result will just be the value from the right hand operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25839180048fba8f8f9437939d20a2f9e4fca2ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&amp;gt;&lt;/code&gt; operator can also be used in this way to efficiently retrieve the first few values sorted by a selected coordinate. For example, to get the first few cubes ordered by the first coordinate (lower left corner) ascending one could use the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809dd3cf23829e5aba0aac6f0c8cd829bcb11269" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexCorrelation&lt;/code&gt;&lt;/em&gt; should be set to the correlation (ranging between -1.0 and 1.0) between the index order and the table order. This is used to adjust the estimate for the cost of fetching rows from the parent table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81aee55a8d4dcdc2397573ababbf7924223c018" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexPages&lt;/code&gt;&lt;/em&gt; should be set to the number of leaf pages. This is used to estimate the number of workers for parallel index scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7685e1c43506ada1cffddeedf06115e445c9d085" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; should be set to the estimated fraction of the parent table rows that will be retrieved during the index scan. In the case of a lossy query, this will typically be higher than the fraction of rows that actually pass the given qual conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5c470364e9e087f35c4b0de71e765afe691f23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter lets the user specify the iteration count, for algorithms that have one. The higher the count, the more time it takes to hash the password and therefore the more time to break it. Although with too high a count the time to calculate a hash may be several years &amp;mdash; which is somewhat impractical. If the &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter is omitted, the default iteration count is used. Allowed values for &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; depend on the algorithm and are shown in &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;Table F.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b20f1e5072b09c8c12330c4cbb5380dc3c53e3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048387eb78e0888018ae5bf5cface4e6e6cf82bc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;sql&lt;/code&gt;&lt;/em&gt; parameter is a SQL statement that produces the source set of data. This statement must return one &lt;code&gt;row_name&lt;/code&gt; column, one &lt;code&gt;category&lt;/code&gt; column, and one &lt;code&gt;value&lt;/code&gt; column. &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is an obsolete parameter, ignored if supplied (formerly this had to match the number of output value columns, but now that is determined by the calling query).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a0a84dc580d747afb8a21f647c284a9244868" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; parameter specifies the hashing algorithm. The accepted types are: &lt;code&gt;des&lt;/code&gt;, &lt;code&gt;xdes&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484484b19f7f2f2b36524197848aeb0d9d4987ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Julian Date&lt;/em&gt; system is another type of calendar, unrelated to the Julian calendar though it is confusingly named similarly to that calendar. The Julian Date system was invented by the French scholar Joseph Justus Scaliger (1540-1609) and probably takes its name from Scaliger's father, the Italian scholar Julius Caesar Scaliger (1484-1558). In the Julian Date system, each day has a sequential number, starting from JD 0 (which is sometimes called &lt;em&gt;the&lt;/em&gt; Julian Date). JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or 24 November 4714 BC in the Gregorian calendar. Julian Date counting is most often used by astronomers for labeling their nightly observations, and therefore a date runs from noon UTC to the next noon UTC, rather than from midnight to midnight: JD 0 designates the 24 hours from noon UTC on 24 November 4714 BC to noon UTC on 25 November 4714 BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c767ea884019c639904724de55aaea8a6ef4f2e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Repeatable Read&lt;/em&gt; isolation level only sees data committed before the transaction began; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions. (However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.) This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt; except for serialization anomalies. As mentioned above, this is specifically allowed by the standard, which only describes the &lt;em&gt;minimum&lt;/em&gt; protections each isolation level must provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cbb4655ce1c4dfa140be7dcae24f9bc53c423c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Serializable&lt;/em&gt; isolation level provides the strictest transaction isolation. This level emulates serial transaction execution for all committed transactions; as if transactions had been executed one after another, serially, rather than concurrently. However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures. In fact, this isolation level works exactly the same as Repeatable Read except that it monitors for conditions which could make execution of a concurrent set of serializable transactions behave in a manner inconsistent with all possible serial (one at a time) executions of those transactions. This monitoring does not introduce any blocking beyond that present in repeatable read, but there is some overhead to the monitoring, and detection of the conditions which could cause a &lt;em&gt;serialization anomaly&lt;/em&gt; will trigger a &lt;em&gt;serialization failure&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95abb4a8d7bbdd16928c9f5238fbb89514c9dcf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;collation derivation&lt;/em&gt; of an expression can be implicit or explicit. This distinction affects how collations are combined when multiple different collations appear in an expression. An explicit collation derivation occurs when a &lt;code&gt;COLLATE&lt;/code&gt; clause is used; all other collation derivations are implicit. When multiple collations need to be combined, for example in a function call, the following rules are used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf554eac84360c1dd91eed12720bf8c618bfb93" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cost&lt;/em&gt; variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner's choices. By default, these cost variables are based on the cost of sequential page fetches; that is, &lt;code&gt;seq_page_cost&lt;/code&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdab0ead2317e8987500975ac391b000a895f851" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; takes the plan created by the planner/optimizer and recursively processes it to extract the required set of rows. This is essentially a demand-pull pipeline mechanism. Each time a plan node is called, it must deliver one more row, or report that it is done delivering rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060116e5a7301adb249c93dbfa36c11220a4c9e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;join condition&lt;/em&gt; is specified in the &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause, or implicitly by the word &lt;code&gt;NATURAL&lt;/code&gt;. The join condition determines which rows from the two source tables are considered to &amp;ldquo;match&amp;rdquo;, as explained in detail below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e845d5a4041970d6090d5e417e410e4537e73642" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;lexer&lt;/em&gt; is defined in the file &lt;code&gt;scan.l&lt;/code&gt; and is responsible for recognizing &lt;em&gt;identifiers&lt;/em&gt;, the &lt;em&gt;SQL key words&lt;/em&gt; etc. For every key word or identifier that is found, a &lt;em&gt;token&lt;/em&gt; is generated and handed to the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14305d3078ee82aaf737dbdfa8a94d4d85285ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;minmax&lt;/em&gt; operator classes store the minimum and the maximum values appearing in the indexed column within the range. The &lt;em&gt;inclusion&lt;/em&gt; operator classes store a value which includes the values in the indexed column within the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba1c2981b2fbd2dd1eede149e275316be5425fc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; checks the query transmitted by the application program for correct syntax and creates a &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d38c6ccc62204fc543f643ffbd579a373675e1c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; consists of two parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bfac80be17dbbeff4a6cdab20060a18710ec0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser&lt;/em&gt; defined in &lt;code&gt;gram.y&lt;/code&gt; and &lt;code&gt;scan.l&lt;/code&gt; is built using the Unix tools bison and flex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
