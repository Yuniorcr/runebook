<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="90c655a8d399c68ec546283b401cd86c6d3da561" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command conforms to the SQL standard, except that the &lt;code&gt;OPTIONS&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; 표준 SQL 명령 부합 함을 선언는 점을 제외하고 &lt;code&gt;OPTIONS&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="e2a88d188f36cc114975839b521433281fe355dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN ROLE&lt;/code&gt; clause lists one or more existing roles to which the new role will be immediately added as a new member. (Note that there is no option to add the new role as an administrator; use a separate &lt;code&gt;GRANT&lt;/code&gt; command to do that.)</source>
          <target state="translated">&lt;code&gt;IN ROLE&lt;/code&gt; 절 목록에 하나 이상의 기존 역할이있는 새 역할은 바로 새로운 구성원으로 추가됩니다. (관리자로서 새 역할을 추가 할 수있는 옵션이 없으므로 별도의 &lt;code&gt;GRANT&lt;/code&gt; 명령을 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3b0c6bd082b9438730c44b123984d29738293313" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute governs inheritance of grantable privileges (that is, access privileges for database objects and role memberships). It does not apply to the special role attributes set by &lt;code&gt;CREATE ROLE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt;. For example, being a member of a role with &lt;code&gt;CREATEDB&lt;/code&gt; privilege does not immediately grant the ability to create databases, even if &lt;code&gt;INHERIT&lt;/code&gt; is set; it would be necessary to become that role via &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; before creating a database.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; 의 (이다, 데이터베이스 객체 및 역할 구성원에 대한 액세스 권한) 부여 가능한 권한의 특성을 다스리 상속. &lt;code&gt;CREATE ROLE&lt;/code&gt; 및 &lt;code&gt;ALTER ROLE&lt;/code&gt; 에 의해 설정된 특수 역할 속성에는 적용되지 않습니다 . 예를 들어, &lt;code&gt;CREATEDB&lt;/code&gt; 권한이 있는 역할의 멤버가 되더라도 &lt;code&gt;INHERIT&lt;/code&gt; 이 설정되어 있어도 데이터베이스를 작성하는 기능이 즉시 부여되지는 않습니다 . 데이터베이스를 작성하기 전에 &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 을 통해 해당 역할이되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="11950124f137ab1b3b29d5312c33140b0085fa30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INHERIT&lt;/code&gt; attribute is the default for reasons of backwards compatibility: in prior releases of PostgreSQL, users always had access to all privileges of groups they were members of. However, &lt;code&gt;NOINHERIT&lt;/code&gt; provides a closer match to the semantics specified in the SQL standard.</source>
          <target state="translated">&lt;code&gt;INHERIT&lt;/code&gt; 의 속성은 이전 버전과의 호환성의 이유에 대한 기본값입니다 PostgreSQL을의 이전 릴리스에서, 사용자는 항상이의 일원이었다 그룹의 모든 권한에 접근했다. 그러나 &lt;code&gt;NOINHERIT&lt;/code&gt; 는 SQL 표준에 지정된 의미론과 더 밀접하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d1a4f9690ce7e26c8924892aa7417c3dc21a3ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INSERT&lt;/code&gt; statement is used to populate a table with rows:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 의 문은 행 테이블을 채우는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="bb164c110048f642f9967f6798e5f2daa48843e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; 의 절은이 일반적인 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="b0af4aa2cff56983554b5dfd6aea4022d42a30a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INTERSECT&lt;/code&gt; operator computes the set intersection of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the intersection of two result sets if it appears in both result sets.</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; 의 작업자가 개입하여 리턴 된 행 세트 교차점 계산 &lt;code&gt;SELECT&lt;/code&gt; 문. 두 결과 세트 모두에 표시되는 경우 두 결과 세트의 교차 부분에 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3710966a5964edf86a5e94dad6ccef2f09e50690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ISBN&lt;/code&gt;, &lt;code&gt;ISMN&lt;/code&gt;, and &lt;code&gt;ISSN&lt;/code&gt; types will display the short version of the number (ISxN 10) whenever it's possible, and will show ISxN 13 format for numbers that do not fit in the short version. The &lt;code&gt;EAN13&lt;/code&gt;, &lt;code&gt;ISBN13&lt;/code&gt;, &lt;code&gt;ISMN13&lt;/code&gt; and &lt;code&gt;ISSN13&lt;/code&gt; types will always display the long version of the ISxN (EAN13).</source>
          <target state="translated">&lt;code&gt;ISBN&lt;/code&gt; , &lt;code&gt;ISMN&lt;/code&gt; 및 &lt;code&gt;ISSN&lt;/code&gt; 의 유형은 가능 할 때마다 수 (ISxN 10)의 짧은 버전을 표시하고, 짧은 버전에 맞지 않는 번호를 ISxN (13) 형식으로 표시됩니다. &lt;code&gt;EAN13&lt;/code&gt; , &lt;code&gt;ISBN13&lt;/code&gt; , &lt;code&gt;ISMN13&lt;/code&gt; 및 &lt;code&gt;ISSN13&lt;/code&gt; 유형은 항상 ISxN (EAN13)의 긴 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7b1a2d9b3af27ec14ac83825b4e9390e81b28ab6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IntervalStyle&lt;/code&gt; parameter also affects the interpretation of ambiguous interval input. See &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;Section 8.5.4&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;IntervalStyle&lt;/code&gt; 의 매개 변수는 간격 모호한 입력의 해석에 영향을 미친다. 자세한 정보는 &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-INPUT&quot;&gt;섹션 8.5.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cb07a7b0b456e75c7d7fb8309d5a950ea4dfdb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LATERAL&lt;/code&gt; key word can precede a sub-&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item. This allows the sub-&lt;code&gt;SELECT&lt;/code&gt; to refer to columns of &lt;code&gt;FROM&lt;/code&gt; items that appear before it in the &lt;code&gt;FROM&lt;/code&gt; list. (Without &lt;code&gt;LATERAL&lt;/code&gt;, each sub-&lt;code&gt;SELECT&lt;/code&gt; is evaluated independently and so cannot cross-reference any other &lt;code&gt;FROM&lt;/code&gt; item.)</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; 키워드는이 하위에 선행 할 수 &lt;code&gt;SELECT&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; 항목입니다. 이를 통해 하위 &lt;code&gt;SELECT&lt;/code&gt; 는 &lt;code&gt;FROM&lt;/code&gt; 목록 에서 앞에 나오는 &lt;code&gt;FROM&lt;/code&gt; 항목의 열을 참조 할 수 있습니다 . &lt;code&gt;LATERAL&lt;/code&gt; 이 없으면 각 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 독립적으로 평가되므로 다른 &lt;code&gt;FROM&lt;/code&gt; 항목을 상호 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0a14b782795f85302f04f02639a6c4f62ab4e062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g., &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; from a view) are ignored.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 절은 조회수, 외부 테이블, 또는 복합 형 정의로부터 열을 복사 할 수있다. 적용 할 수없는 옵션 (예 : 뷰에서 &lt;code&gt;INCLUDING INDEXES&lt;/code&gt; )은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="396ab12c5362824aaa283637f9c77c9a00f331f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; clause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 절을 지정 테이블에있는 새 테이블이 자동으로 복사 모든 열 이름에서, 데이터 유형, 그들의하지 null이 제약.</target>
        </trans-unit>
        <trans-unit id="572dfcd3f9f7897b067c547ebc46891efd6417fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; expression returns true if the &lt;code&gt;string&lt;/code&gt; matches the supplied &lt;code&gt;pattern&lt;/code&gt;. (As expected, the &lt;code&gt;NOT LIKE&lt;/code&gt; expression returns false if &lt;code&gt;LIKE&lt;/code&gt; returns true, and vice versa. An equivalent expression is &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 경우 생성 표현식이 true 반환 &lt;code&gt;string&lt;/code&gt; 제공된 일치하는 &lt;code&gt;pattern&lt;/code&gt; . (예상대로 &lt;code&gt;LIKE&lt;/code&gt; 가 true를 리턴 하면 &lt;code&gt;NOT LIKE&lt;/code&gt; 표현식은 false를 리턴하고 그 반대도 마찬가지입니다. 동등한 표현식은 &lt;code&gt;NOT (string LIKE pattern)&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="258e69d1b09cf77569de7c47f8a8dba66e04bb7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIKE&lt;/code&gt; operator does pattern matching and is explained in &lt;a href=&quot;functions-matching&quot;&gt;Section 9.7&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 의 운영자는 패턴 매칭을 수행하고 설명한다 &lt;a href=&quot;functions-matching&quot;&gt;섹션 9.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7480e6b2427d5d0d2afbc0d3981cabf8d8c5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LIMIT&lt;/code&gt; clause consists of two independent sub-clauses:</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 의 절은 두 개의 독립적 인 하위 절로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5092a579b1157c3ece79f6e0b69fb148ae975b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MATERIALIZED&lt;/code&gt; and &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; options of &lt;code&gt;WITH&lt;/code&gt; are extensions of the SQL standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 &lt;code&gt;MATERIALIZED&lt;/code&gt; 및 &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 옵션은 SQL 표준의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="03c245095fff9e37994e71505cc2de7e6fbaeb07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MergeJoin&lt;/code&gt; node similarly demands the first row from its right subplan. Then it compares the two rows to see if they can be joined; if so, it returns a join row to its caller. On the next call, or immediately if it cannot join the current pair of inputs, it advances to the next row of one table or the other (depending on how the comparison came out), and again checks for a match. Eventually, one subplan or the other is exhausted, and the &lt;code&gt;MergeJoin&lt;/code&gt; node returns NULL to indicate that no more join rows can be formed.</source>
          <target state="translated">&lt;code&gt;MergeJoin&lt;/code&gt; 의 노드는 유사하게 오른쪽 하위 계획에서 첫 번째 행을 요구한다. 그런 다음 두 행을 비교하여 이들이 결합 될 수 있는지 확인합니다. 그렇다면, 호출자에게 조인 행을 리턴합니다. 다음 호출에서 또는 현재 입력 쌍을 조인 할 수없는 경우 즉시 한 테이블의 다음 행 또는 다른 행으로 진행하여 (비교 방법에 따라) 일치 여부를 다시 확인합니다. 결국 하나의 하위 계획 또는 다른 하위 계획이 소진되고 &lt;code&gt;MergeJoin&lt;/code&gt; 노드는 NULL을 반환하여 더 이상 조인 행을 만들 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50c96e90dd3ca2b2b4787fd18890dca99f28ab8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NONE&lt;/code&gt; and &lt;code&gt;RESET&lt;/code&gt; forms reset the current user identifier to be the current session user identifier. These forms can be executed by any user.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; 과 &lt;code&gt;RESET&lt;/code&gt; 형태는 현재 세션의 사용자 식별자로 현재의 사용자 식별자를 재설정. 이 양식은 모든 사용자가 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b13dc16a3a4fce3da18ccb704fb39295955bdea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOT NULL&lt;/code&gt; constraint has an inverse: the &lt;code&gt;NULL&lt;/code&gt; constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The &lt;code&gt;NULL&lt;/code&gt; constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to PostgreSQL to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with:</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 의 : 제약은 역이 &lt;code&gt;NULL&lt;/code&gt; 의 제약 조건을. 그렇다고해서 열이 null이어야한다는 의미는 아니며 반드시 쓸모가 없습니다. 대신 이것은 단순히 열이 null 일 수있는 기본 동작을 선택합니다. &lt;code&gt;NULL&lt;/code&gt; 의 제약 조건은 SQL 표준에없는 휴대용 애플리케이션에서 사용할 수 없습니다. (일부 다른 데이터베이스 시스템과 호환되도록 PostgreSQL에만 추가되었습니다.) 그러나 일부 사용자는 스크립트 파일에서 제약 조건을 쉽게 전환 할 수 있기 때문에 좋아합니다. 예를 들어 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea1d2c35460104bbb73410ce7cfdee6383ad73d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOTIFY&lt;/code&gt; command sends a notification event together with an optional &amp;ldquo;payload&amp;rdquo; string to each client application that has previously executed &lt;code&gt;LISTEN channel&lt;/code&gt; for the specified channel name in the current database. Notifications are visible to all users.</source>
          <target state="translated">는 &lt;code&gt;NOTIFY&lt;/code&gt; 명령은 이전에 실행 한 각 클라이언트 응용 프로그램 선택 &quot;페이로드&quot;문자열과 함께 알림 이벤트를 송신 &lt;code&gt;LISTEN channel&lt;/code&gt; 현재 데이터베이스에서 지정된 채널 이름을. 모든 사용자에게 알림이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc1aa8547d4f45a3a74ddce2ee6f66c1ad2e63b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt; keyword is case-insensitive. Double-quote the &lt;code&gt;NULL&lt;/code&gt; to treat it as the ordinary string &amp;ldquo;NULL&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 의 키워드는 대소 문자를 구분합니다. &lt;code&gt;NULL&lt;/code&gt; 을 큰 따옴표로 묶어 일반 문자열&amp;ldquo;NULL&amp;rdquo;로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="962da68b59592e76d7efdc84ac1e5105db667c11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;constraint&amp;rdquo; (actually a non-constraint) is a PostgreSQL extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the &lt;code&gt;NOT NULL&lt;/code&gt; constraint). Since it is the default for any column, its presence is simply noise.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; &quot;제약&quot;(실제로는 비 제약) 다른 데이터베이스 시스템과의 호환성을 위해 포함 (과와 대칭에있는 SQL 표준에 대한 PostgreSQL의 확장입니다 &lt;code&gt;NOT NULL&lt;/code&gt; 제약). 모든 열의 기본값이므로 단순히 노이즈입니다.</target>
        </trans-unit>
        <trans-unit id="f89a70ab2187a4125b8af941eb48d2104a35aae4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLIF&lt;/code&gt; function returns a null value if &lt;code&gt;value1&lt;/code&gt; equals &lt;code&gt;value2&lt;/code&gt;; otherwise it returns &lt;code&gt;value1&lt;/code&gt;. This can be used to perform the inverse operation of the &lt;code&gt;COALESCE&lt;/code&gt; example given above:</source>
          <target state="translated">&lt;code&gt;NULLIF&lt;/code&gt; 의 경우, 함수는 널 (null) 값을 반환 &lt;code&gt;value1&lt;/code&gt; 동일 &lt;code&gt;value2&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;value1&lt;/code&gt; 을 반환합니다 . 이것은 위에서 주어진 &lt;code&gt;COALESCE&lt;/code&gt; 예의 역 연산을 수행하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01fdd1712e7b0454ab7f170cffda1945f0082b71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NULLS FIRST&lt;/code&gt; and &lt;code&gt;NULLS LAST&lt;/code&gt; options can be used to determine whether nulls appear before or after non-null values in the sort ordering. By default, null values sort as if larger than any non-null value; that is, &lt;code&gt;NULLS FIRST&lt;/code&gt; is the default for &lt;code&gt;DESC&lt;/code&gt; order, and &lt;code&gt;NULLS LAST&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;NULLS FIRST&lt;/code&gt; 및 &lt;code&gt;NULLS LAST&lt;/code&gt; 의 옵션은 널 (null) 전이나 정렬 순서에 null이 아닌 값 뒤에 표시 여부를 결정하는 데 사용할 수 있습니다. 기본적으로 널값은 널이 아닌 값보다 큰 것처럼 정렬됩니다. 즉, &lt;code&gt;NULLS FIRST&lt;/code&gt; 는 &lt;code&gt;DESC&lt;/code&gt; 순서 의 기본값 이고 그렇지 않은 경우 &lt;code&gt;NULLS LAST&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db3f6d7975c35350055f22165f8267b483d36caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON COMMIT&lt;/code&gt; clause for temporary tables also resembles the SQL standard, but has some differences. If the &lt;code&gt;ON COMMIT&lt;/code&gt; clause is omitted, SQL specifies that the default behavior is &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt;. However, the default behavior in PostgreSQL is &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt;. The &lt;code&gt;ON COMMIT DROP&lt;/code&gt; option does not exist in SQL.</source>
          <target state="translated">임시 테이블 의 &lt;code&gt;ON COMMIT&lt;/code&gt; 절도 SQL 표준과 비슷하지만 약간의 차이가 있습니다. 는 IF &lt;code&gt;ON COMMIT&lt;/code&gt; 를 절을 생략하면 기본 동작입니다 SQL의 지정 &lt;code&gt;ON COMMIT DELETE ROWS&lt;/code&gt; . 그러나 PostgreSQL의 기본 동작은 &lt;code&gt;ON COMMIT PRESERVE ROWS&lt;/code&gt; 입니다. &lt;code&gt;ON COMMIT DROP&lt;/code&gt; SQL에 존재하지 않는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="472f32dda3820f4f49769a24b22c0964256b23e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ON&lt;/code&gt; clause is the most general kind of join condition: it takes a Boolean value expression of the same kind as is used in a &lt;code&gt;WHERE&lt;/code&gt; clause. A pair of rows from &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; match if the &lt;code&gt;ON&lt;/code&gt; expression evaluates to true.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 의 절은 조인 조건의 가장 일반적인 종류이다 : 그것은에 사용되는 것과 같은 종류의 부울 값 표현합니다 &lt;code&gt;WHERE&lt;/code&gt; 절을. &lt;code&gt;ON&lt;/code&gt; 표현식이 true로 평가 되면 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 의 행 쌍이 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="793025f43fd046d2375fc2d1347d2ad6be35fd9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt; and &lt;code&gt;FUNCTION&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; 및 &lt;code&gt;FUNCTION&lt;/code&gt; 절은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed146b628b9143aa8d465b9f6a969399e0078fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPERATOR&lt;/code&gt;, &lt;code&gt;FUNCTION&lt;/code&gt;, and &lt;code&gt;STORAGE&lt;/code&gt; clauses can appear in any order.</source>
          <target state="translated">&lt;code&gt;OPERATOR&lt;/code&gt; , &lt;code&gt;FUNCTION&lt;/code&gt; , 및 &lt;code&gt;STORAGE&lt;/code&gt; 절은 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7408278e5a49c7a21e1d564882fc738063e8ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 절은 결과 행은 지정된 식 (들)에 따라 정렬됩니다. 가장 왼쪽 표현식에 따라 두 행이 같으면 다음 표현식에 따라 비교됩니다. 지정된 모든 표현식에 따라 같으면 구현 종속 순서로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b02f359cd58f3fe912dce4590fe56eb7fd3fc933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ORDER BY&lt;/code&gt; clause specifies the sort order:</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 절은 정렬 순서를 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="5c192bece45872266b8038f6a0a05d716d357e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="bdc9e5eec52a1ba378bd2fb8274d7c97650e7deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. If specified, this association replaces any previously specified association for the sequence. The specified table must have the same owner and be in the same schema as the sequence. Specifying &lt;code&gt;OWNED BY NONE&lt;/code&gt; removes any existing association, making the sequence &amp;ldquo;free-standing&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 옵션 시퀀스는 해당 열 (또는 전체 테이블)이 삭제 된 경우, 시퀀스는 자동으로 삭제 아니라한다되도록 특정 테이블 컬럼과 연관되게한다. 지정된 경우이 연관은 시퀀스에 대해 이전에 지정된 연관을 대체합니다. 지정된 테이블은 소유자가 동일해야하며 시퀀스와 동일한 스키마에 있어야합니다. &lt;code&gt;OWNED BY NONE&lt;/code&gt; 을 지정 하면 기존 연결이 제거되어 시퀀스가 ​​&quot;독립적&quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="56fdd5a6277f3365172855b96f924d0b384fe495" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OWNED BY&lt;/code&gt; option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well. The specified table must have the same owner and be in the same schema as the sequence. &lt;code&gt;OWNED BY NONE&lt;/code&gt;, the default, specifies that there is no such association.</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; 옵션 시퀀스는 해당 열 (또는 전체 테이블)이 삭제 된 경우, 시퀀스는 자동으로 삭제 아니라한다되도록 특정 테이블 컬럼과 연관되게한다. 지정된 테이블은 소유자가 동일해야하며 시퀀스와 동일한 스키마에 있어야합니다. 기본값 인 &lt;code&gt;OWNED BY NONE&lt;/code&gt; 은 그러한 연관이 없음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6a2d7bf96f2a0b5a81febb7cc2f04c359a2ce962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARSER&lt;/code&gt; and &lt;code&gt;COPY&lt;/code&gt; options are mutually exclusive, because when an existing configuration is copied, its parser selection is copied too.</source>
          <target state="translated">&lt;code&gt;PARSER&lt;/code&gt; 와 &lt;code&gt;COPY&lt;/code&gt; 기존 구성을 복사 할 때, 그 파서 선택이 너무 복사되기 때문에 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="6ad47e1225da856fc1e4e1ae21e6437e7c3be2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause groups the rows of the query into &lt;em&gt;partitions&lt;/em&gt;, which are processed separately by the window function. &lt;code&gt;PARTITION BY&lt;/code&gt; works similarly to a query-level &lt;code&gt;GROUP BY&lt;/code&gt; clause, except that its expressions are always just expressions and cannot be output-column names or numbers. Without &lt;code&gt;PARTITION BY&lt;/code&gt;, all rows produced by the query are treated as a single partition. The &lt;code&gt;ORDER BY&lt;/code&gt; clause determines the order in which the rows of a partition are processed by the window function. It works similarly to a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, but likewise cannot use output-column names or numbers. Without &lt;code&gt;ORDER BY&lt;/code&gt;, rows are processed in an unspecified order.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 에 절 단체 쿼리 행 &lt;em&gt;분할&lt;/em&gt; 윈도우 함수에 의해 개별적으로 처리된다. &lt;code&gt;PARTITION BY&lt;/code&gt; 는 식이 항상 식이며 출력 열 이름 또는 숫자 일 수 없다는 점을 제외하고 쿼리 수준 &lt;code&gt;GROUP BY&lt;/code&gt; 절 과 유사하게 작동 합니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 가 없으면 쿼리로 생성 된 모든 행이 단일 파티션으로 처리됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 절 파티션의 행 윈도우 함수에 의해 처리되는 순서를 결정한다. 쿼리 수준 &lt;code&gt;ORDER BY&lt;/code&gt; 절 과 유사하게 작동 하지만 마찬가지로 출력 열 이름 또는 숫자를 사용할 수 없습니다. &lt;code&gt;ORDER BY&lt;/code&gt; 없이행은 지정되지 않은 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3b20c2706e18115ac776637bd86595bd36306e04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION BY&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="393ad05ac9e0d59452b4a8f8039dc3a261130b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PARTITION OF&lt;/code&gt; clause is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;PARTITION OF&lt;/code&gt; 절은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="0614d6d969b75211746fef3527fa36c2e0bf9b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGDATA&lt;/code&gt; directory contains several subdirectories and control files, as shown in &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;Table 68.1&lt;/a&gt;. In addition to these required items, the cluster configuration files &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, and &lt;code&gt;pg_ident.conf&lt;/code&gt; are traditionally stored in &lt;code&gt;PGDATA&lt;/code&gt;, although it is possible to place them elsewhere.</source>
          <target state="translated">&lt;code&gt;PGDATA&lt;/code&gt; 에 같이 디렉토리, 하위 디렉토리 및 제어 파일 몇 가지를 포함 &lt;a href=&quot;storage-file-layout#PGDATA-CONTENTS-TABLE&quot;&gt;표 68.1&lt;/a&gt; . 이러한 필수 항목 외에도 클러스터 구성 파일 &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; 및 &lt;code&gt;pg_ident.conf&lt;/code&gt; 는 일반적으로 &lt;code&gt;PGDATA&lt;/code&gt; 에 저장 되지만 다른 위치에 배치 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c212a5664d9166a52f4030be9966cfbd740b8e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PGTZ&lt;/code&gt; environment variable is used by libpq clients to send a &lt;code&gt;SET TIME ZONE&lt;/code&gt; command to the server upon connection.</source>
          <target state="translated">&lt;code&gt;PGTZ&lt;/code&gt; 의 환경 변수는 보낼 libpq를 클라이언트에서 사용되는 &lt;code&gt;SET TIME ZONE&lt;/code&gt; 의 연결시 서버에 명령을.</target>
        </trans-unit>
        <trans-unit id="34a48a54277ef76ad5806acc41cf35d3fff139d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 의 테이블의 열 또는 열은 고유의 (비 중복)을 포함 할 수 있다는 제약 조건 지정, 널 (null)이 아닌 값. 열 제한 조건 또는 테이블 제한 조건으로 테이블에 대해 하나의 기본 키만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46186111e10cd3fae630f6ffd1000b220d009aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Planning time&lt;/code&gt; shown by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; is the time it took to generate the query plan from the parsed query and optimize it. It does not include parsing or rewriting.</source>
          <target state="translated">&lt;code&gt;Planning time&lt;/code&gt; 으로 표시 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 이 분석 된 쿼리의 쿼리 계획을 생성하고 최적화하는 데 걸린 시간입니다. 구문 분석 또는 재 작성은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d7e8e781faa2b1b8c5b786d22498b3437e1d217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command does not affect any privileges granted to the &lt;code&gt;old_roles&lt;/code&gt; on objects that are not owned by them. Likewise, it does not affect default privileges created with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;. Use &lt;code&gt;DROP OWNED&lt;/code&gt; to revoke such privileges.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 명령에 부여 된 권한에 영향을주지 않습니다 &lt;code&gt;old_roles&lt;/code&gt; 그들에 의해 소유하지 않은 개체를. 마찬가지로, &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 로 작성된 기본 권한에는 영향을 미치지 않습니다 . 이러한 권한을 취소 하려면 &lt;code&gt;DROP OWNED&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab1105a54870883f7696c90d586d2ea0eba9685c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REASSIGN OWNED&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 명령은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="f532c71d7a7a8a330117caf1f3776cf4f07cbb57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REFERENCING&lt;/code&gt; option enables collection of &lt;em&gt;transition relations&lt;/em&gt;, which are row sets that include all of the rows inserted, deleted, or modified by the current SQL statement. This feature lets the trigger see a global view of what the statement did, not just one row at a time. This option is only allowed for an &lt;code&gt;AFTER&lt;/code&gt; trigger that is not a constraint trigger; also, if the trigger is an &lt;code&gt;UPDATE&lt;/code&gt; trigger, it must not specify a &lt;code&gt;column_name&lt;/code&gt; list. &lt;code&gt;OLD TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;before-images&lt;/em&gt; of all rows updated or deleted by the statement. Similarly, &lt;code&gt;NEW TABLE&lt;/code&gt; may only be specified once, and only for a trigger that can fire on &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;; it creates a transition relation containing the &lt;em&gt;after-images&lt;/em&gt; of all rows updated or inserted by the statement.</source>
          <target state="translated">&lt;code&gt;REFERENCING&lt;/code&gt; 의 옵션을 수집 할 수 &lt;em&gt;전환 관계&lt;/em&gt; , 삽입, 삭제, 또는 현재 SQL 문에 의해 수정 된 모든 행을 포함하는 행 집합입니다. 이 기능을 통해 트리거는 한 번에 한 행이 아니라 명령문이 수행 한 내용을 전체적으로 볼 수 있습니다. 이 옵션은 구속 조건 트리거가 아닌 &lt;code&gt;AFTER&lt;/code&gt; 트리거 에만 허용 됩니다. 또한 트리거가 &lt;code&gt;UPDATE&lt;/code&gt; 트리거 인 경우 &lt;code&gt;column_name&lt;/code&gt; 목록을 지정하지 않아야 합니다. &lt;code&gt;OLD TABLE&lt;/code&gt; 은 한 번만 지정할 수 있으며 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 에서 실행될 수있는 트리거에 대해서만 지정할 수 있습니다 . &lt;em&gt;사전 이미지를&lt;/em&gt; 포함하는 전환 관계를 만듭니다.&lt;em&gt;&lt;/em&gt;문에 의해 업데이트되거나 삭제 된 모든 행 중 마찬가지로 &lt;code&gt;NEW TABLE&lt;/code&gt; 은 한 번만 지정할 수 있으며 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 시 트리거 할 수있는 트리거에 대해서만 지정할 수 있습니다 . 명령문에 의해 갱신되거나 삽입 된 모든 행 의 &lt;em&gt;사후 이미지&lt;/em&gt; 를 포함하는 전이 관계를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="128c0fd3af0b907c660e6b2d23e97c6334b157b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; form changes the name of the index. If the index is associated with a table constraint (either &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt;), the constraint is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 형태는 인덱스의 이름을 변경합니다. 인덱스가 테이블 제한 조건 ( &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;EXCLUDE&lt;/code&gt; ) 과 연관된 경우 제한 조건의 이름도 변경됩니다. 저장된 데이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3e19c1e234f0ed8c9c4710a3c3098a7ed897e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a foreign table or the name of an individual column in a foreign table.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 의 형태는 외부 테이블의 이름 또는 외부 표에서 개별 항목의 이름을 변경.</target>
        </trans-unit>
        <trans-unit id="f1e7a50326fd3c3ba151f96454fa2cb157ff1c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RENAME&lt;/code&gt; forms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 의 형태는 테이블의 이름 변경, 테이블의 개별 열 또는 테이블 제약의 이름의 이름 (또는 지수 시퀀스, 뷰, 뷰 또는 외부 표 구체화). 기본 인덱스가있는 제약 조건의 이름을 바꾸면 인덱스 이름도 변경됩니다. 저장된 데이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9e363fe4d9083d2f665b243a400d5bf63d40f84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RETURNING&lt;/code&gt; clause is also very useful with &lt;code&gt;INSERT ... SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 절은 또한 매우 유용 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622683abc0fee3cca0a4ff24efb6bac3bc69274b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REVOKE&lt;/code&gt; command revokes previously granted privileges from one or more roles. The key word &lt;code&gt;PUBLIC&lt;/code&gt; refers to the implicitly defined group of all roles.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; 의 명령은 이전에 하나 개 이상의 역할에서 권한을 부여 취소합니다. 키워드 &lt;code&gt;PUBLIC&lt;/code&gt; 은 암시 적으로 정의 된 모든 역할 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7eb06850162cc121e0dcb4f71d5d5cc238a6fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROLE&lt;/code&gt; clause lists one or more existing roles which are automatically added as members of the new role. (This in effect makes the new role a &amp;ldquo;group&amp;rdquo;.)</source>
          <target state="translated">&lt;code&gt;ROLE&lt;/code&gt; 절 목록에 하나 더 자동으로 새 역할의 구성원으로 추가하는 역할을 기존의. (이는 사실상 새로운 역할을&amp;ldquo;그룹&amp;rdquo;으로 만듭니다.)</target>
        </trans-unit>
        <trans-unit id="e90b140ccb8d754cc8582d110f40bb1462ca56ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; constructor syntax is usually easier to work with than the composite-literal syntax when writing composite values in SQL commands. In &lt;code&gt;ROW&lt;/code&gt;, individual field values are written the same way they would be written when not members of a composite.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 생성자 구문은 SQL 명령에 복합 값을 기록 할 때 복합 리터럴 구문보다 더와 작업에 일반적으로 쉽습니다. 에서 &lt;code&gt;ROW&lt;/code&gt; , 각각의 필드 값들이 기록 될 것 같은 방법을 쓸 때없는 복합의 구성원.</target>
        </trans-unit>
        <trans-unit id="bc33402fa9910608d16738542893ffc3652dba40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax can also be used to construct composite values. In most cases this is considerably simpler to use than the string-literal syntax since you don't have to worry about multiple layers of quoting. We already used this method above:</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 표현 구문은 합성 값을 구성하는데 사용될 수있다. 대부분의 경우 인용의 여러 계층에 대해 걱정할 필요가 없으므로 문자열 리터럴 구문보다 사용이 훨씬 간단합니다. 우리는 이미 위의 방법을 사용했습니다 :</target>
        </trans-unit>
        <trans-unit id="fec4fc51d12e7ec5b1c6011953c7d9a01518ad18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ROW&lt;/code&gt; expression syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ROW&lt;/code&gt; 표현 구문에 자세히 설명 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;섹션 4.2.13&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66771ec27e64ee38d7a73db993c4f98dda1eefb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SCROLL&lt;/code&gt; option should be specified when defining a cursor that will be used to fetch backwards. This is required by the SQL standard. However, for compatibility with earlier versions, PostgreSQL will allow backward fetches without &lt;code&gt;SCROLL&lt;/code&gt;, if the cursor's query plan is simple enough that no extra overhead is needed to support it. However, application developers are advised not to rely on using backward fetches from a cursor that has not been created with &lt;code&gt;SCROLL&lt;/code&gt;. If &lt;code&gt;NO SCROLL&lt;/code&gt; is specified, then backward fetches are disallowed in any case.</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; 뒤쪽을 가져 오기 위해 사용되는 커서를 정의 할 때 옵션을 지정해야합니다. 이것은 SQL 표준에 필요합니다. 그러나 이전 버전과의 호환성을 위해 커서의 쿼리 계획이 단순하여이를 지원하기 위해 추가 오버 헤드가 필요하지 않은 경우 PostgreSQL은 &lt;code&gt;SCROLL&lt;/code&gt; 없이 역방향 페치를 허용 합니다. 그러나 응용 프로그램 개발자는 &lt;code&gt;SCROLL&lt;/code&gt; 로 작성되지 않은 커서에서 뒤로 가져 오기를 사용하지 않는 것이 좋습니다 . 경우 &lt;code&gt;NO SCROLL&lt;/code&gt; 을 지정하면 후방 페치 어떤 경우에 허용된다.</target>
        </trans-unit>
        <trans-unit id="7724f5cbcba172f246fa8b7c71da000b2776330f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands acquire a lock of this mode on the target table(s) (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other tables that are referenced but not selected &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 와 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 의 명령 (이외에 목표 테이블 (들)이 모드의 잠금을 획득 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 참조하지만, 선택되지 않은 다른 테이블에 잠금 &lt;code&gt;FOR UPDATE/FOR SHARE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e96e7802d4cb7db701f609eba9f870f4c8748bdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; command acquires a lock of this mode on referenced tables. In general, any query that only &lt;em&gt;reads&lt;/em&gt; a table and does not modify it will acquire this lock mode.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 명령은 참조 테이블에이 모드의 잠금을 획득합니다. 일반적으로 테이블을 &lt;em&gt;읽고&lt;/em&gt; 수정하지 않는 쿼리는 이 잠금 모드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="3a31e8d24fd1e02295c813f049f933c4c7dd023e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; list (between the key words &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;FROM&lt;/code&gt;) specifies expressions that form the output rows of the &lt;code&gt;SELECT&lt;/code&gt; statement. The expressions can (and usually do) refer to columns computed in the &lt;code&gt;FROM&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 리스트 (핵심어 사이에는 &lt;code&gt;SELECT&lt;/code&gt; 및 &lt;code&gt;FROM&lt;/code&gt; 의 출력 행 형성 지정 식) &lt;code&gt;SELECT&lt;/code&gt; 문. 표현식은 &lt;code&gt;FROM&lt;/code&gt; 절 에서 계산 된 열을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d3b2383acf67ec80d1e37ede72853554a335de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SELECT&lt;/code&gt; statement will return one tuple, even though the &lt;code&gt;nick&lt;/code&gt; column was set to &lt;code&gt;larry&lt;/code&gt; and the query was for &lt;code&gt;Larry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 의 짝수하지만 문은 하나 개의 튜플을 반환 &lt;code&gt;nick&lt;/code&gt; 열로 설정 &lt;code&gt;larry&lt;/code&gt; 쿼리가되었다 &lt;code&gt;Larry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1ef68b6a727bfef21aefb3a5eb92e57da175a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SERIAL&lt;/code&gt; shorthand is discussed further in &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;Section 8.1.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SERIAL&lt;/code&gt; 의 약칭은 더욱 설명 &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;절 8.1.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a726476c5c9f5995fa747df038eaa20f04dca47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers act the same as for the regular &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;SESSION&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 수식은 일반과 동일한 역할을 &lt;a href=&quot;sql-set&quot;&gt;SET의&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="9f2d0dd2017fb0dc1fe3da723f3e961e02aaf3eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET ROLE&lt;/code&gt; command always allows selecting any role that the original login role is directly or indirectly a member of. Thus, in the above example, it is not necessary to become &lt;code&gt;admin&lt;/code&gt; before becoming &lt;code&gt;wheel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; 명령은 항상 원래 로그인 역할은 직접 또는 간접적으로의 구성원인지 어떤 역할을 선택 할 수 있습니다. 따라서 위의 예에서 &lt;code&gt;wheel&lt;/code&gt; 이 되기 전에 &lt;code&gt;admin&lt;/code&gt; 가 될 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d850a29f519a30a60f848219dab3f598ebc95064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command allows a new transaction to run with the same &lt;em&gt;snapshot&lt;/em&gt; as an existing transaction. The pre-existing transaction must have exported its snapshot with the &lt;code&gt;pg_export_snapshot&lt;/code&gt; function (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;Section 9.26.5&lt;/a&gt;). That function returns a snapshot identifier, which must be given to &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; to specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example &lt;code&gt;'000003A1-1'&lt;/code&gt;. &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; can only be executed at the start of a transaction, before the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of the transaction. Furthermore, the transaction must already be set to &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level (otherwise, the snapshot would be discarded immediately, since &lt;code&gt;READ COMMITTED&lt;/code&gt; mode takes a new snapshot for each command). If the importing transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 명령은 같은 실행하는 새로운 트랜잭션 수 &lt;em&gt;스냅 샷&lt;/em&gt; 기존의 트랜잭션으로한다. 기존 트랜잭션은 &lt;code&gt;pg_export_snapshot&lt;/code&gt; 함수를 사용하여 스냅 샷을 내 보내야 합니다 ( &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION&quot;&gt;9.26.5 절&lt;/a&gt; 참조 ). 이 함수는 가져올 스냅 샷을 지정 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 위해 스냅 샷 식별자를 SET TRANSACTION SNAPSHOT 에 제공해야합니다 . 식별자는이 명령에서 문자열 리터럴로 작성해야합니다 (예 : &lt;code&gt;'000003A1-1'&lt;/code&gt; ) . &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 은 첫 번째 쿼리 또는 데이터 수정 명령문 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; ) 이전에 트랜잭션 시작시에만 실행될 수 있습니다.트랜잭션의 , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 또는 &lt;code&gt;COPY&lt;/code&gt; ) 또한 트랜잭션은 이미 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 또는 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 격리 수준 으로 설정되어 있어야합니다. 그렇지 않으면 &lt;code&gt;READ COMMITTED&lt;/code&gt; 모드가 각 명령에 대해 새 스냅 샷을 생성 하므로 스냅 샷이 즉시 삭제됩니다 . 가져 오기 트랜잭션이 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리 레벨을 사용하는 경우 스냅 샷을 내 보낸 트랜잭션도 해당 격리 레벨을 사용해야합니다. 또한 읽기 전용 직렬화 가능 트랜잭션은 읽기 전용 트랜잭션에서 스냅 샷을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc6c2a89c55f352db834e7ae3a14fa98c839cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET TRANSACTION&lt;/code&gt; command sets the characteristics of the current transaction. It has no effect on any subsequent transactions. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; sets the default transaction characteristics for subsequent transactions of a session. These defaults can be overridden by &lt;code&gt;SET TRANSACTION&lt;/code&gt; for an individual transaction.</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION&lt;/code&gt; 명령은 현재 트랜잭션의 특성을 설정합니다. 후속 트랜잭션에는 영향을 미치지 않습니다. &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; 는 세션의 후속 트랜잭션에 대한 기본 트랜잭션 특성을 설정합니다. 개별 트랜잭션에 대해 &lt;code&gt;SET TRANSACTION&lt;/code&gt; 으로이 기본값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6625f1cde96b5821cc50429e57aa65382ce3cbff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 절 지정된 구성 파라미터 함수가 입력 될 때 지정된 값으로 설정하고 그 이전 값 함수가 종료되면 복원되도록한다. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 이 실행될 때 현재 매개 변수 의 값을 함수가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="40cb501cbc3608b578aae96ed6d694a6c1181e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; clause causes the specified configuration parameter to be set to the specified value when the procedure is entered, and then restored to its prior value when the procedure exits. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 절은 지정된 구성 매개 변수는 프로 시저가 입력 될 때 지정된 값으로 설정 한 다음 그 이전 값 때 절차가 종료로 복원됩니다. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 가 실행될 때 현재 매개 변수 값을 프로 시저가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2d4ac1bc1f3cd753f1587a3604ac6e4583d02fa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SET&lt;/code&gt; command changes run-time configuration parameters. Many of the run-time parameters listed in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; can be changed on-the-fly with &lt;code&gt;SET&lt;/code&gt;. (But some require superuser privileges to change, and others cannot be changed after server or session start.) &lt;code&gt;SET&lt;/code&gt; only affects the value used by the current session.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 명령은 런타임 구성 매개 변수를 변경합니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 나열된 많은 런타임 매개 변수 는 &lt;code&gt;SET&lt;/code&gt; 을 사용 하여 즉석에서 변경할 수 있습니다 . 그러나 일부는 변경하려면 수퍼 유저 권한이 필요하고 다른 일부는 서버 나 세션이 시작된 후에는 변경할 수 없습니다. &lt;code&gt;SET&lt;/code&gt; 는 현재 세션에서 사용 된 값에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="020c7ebd698e864a60548a6b3a70eb85bc868cc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SETOF&lt;/code&gt; modifier indicates that the function will return a set of items, rather than a single item.</source>
          <target state="translated">&lt;code&gt;SETOF&lt;/code&gt; 의 수정은 함수가 아니라 단일 항목보다는 항목 집합을 반환 할 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5fb6cd6b15fe6f84ab20f8db329dfba5800e08d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHOW&lt;/code&gt; command is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;SHOW&lt;/code&gt; 의 명령은 PostgreSQL의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="3bda179acb0a4ef77b97eb421bed8ee9a254cd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGHUP&lt;/code&gt; signal will reload the server configuration files. It is also possible to send &lt;code&gt;SIGHUP&lt;/code&gt; to an individual server process, but that is usually not sensible.</source>
          <target state="translated">&lt;code&gt;SIGHUP&lt;/code&gt; 의 신호는 서버 구성 파일을 다시로드합니다. &lt;code&gt;SIGHUP&lt;/code&gt; 을 개별 서버 프로세스 로 보낼 수도 있지만 일반적으로는 합리적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbdafa6a0951a5a4f8ae3d651aa4483d02aaf656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIMILAR TO&lt;/code&gt; operator returns true or false depending on whether its pattern matches the given string. It is similar to &lt;code&gt;LIKE&lt;/code&gt;, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between &lt;code&gt;LIKE&lt;/code&gt; notation and common regular expression notation.</source>
          <target state="translated">&lt;code&gt;SIMILAR TO&lt;/code&gt; 연산자는 true를 반환 또는 그 패턴이 주어진 문자열과 일치 여부에 따라 거짓. SQL 표준의 정규 표현식 정의를 사용하여 패턴을 해석한다는 점을 제외하면 &lt;code&gt;LIKE&lt;/code&gt; 와 유사합니다 . SQL 정규 표현식은 &lt;code&gt;LIKE&lt;/code&gt; 표기법과 일반적인 정규 표현식 표기법 사이의 흥미로운 교차점 입니다.</target>
        </trans-unit>
        <trans-unit id="0015ba66976ccc10a8545b59f15f445b21a50742" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SQL_ASCII&lt;/code&gt; setting behaves considerably differently from the other settings. When the server character set is &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server interprets byte values 0-127 according to the ASCII standard, while byte values 128-255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is &lt;code&gt;SQL_ASCII&lt;/code&gt;. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the &lt;code&gt;SQL_ASCII&lt;/code&gt; setting because PostgreSQL will be unable to help you by converting or validating non-ASCII characters.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; 다른 설정과 상당히 다르게 동작 설정. 서버 문자 세트가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 인 경우, 서버는 ASCII 표준에 따라 바이트 값 0-127을 해석하는 반면 바이트 값 128-255는 해석되지 않은 문자로 간주됩니다. 설정이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 이면 인코딩 변환이 수행되지 않습니다 . 따라서이 설정은 인코딩에 대한 무지 선언으로서 특정 인코딩이 사용되는 선언이 아닙니다. 대부분의 경우 비 ASCII 데이터로 작업하는 경우 PostgreSQL이 비 ASCII 문자를 변환하거나 유효성 검증하여 도움을 줄 수 없으므로 &lt;code&gt;SQL_ASCII&lt;/code&gt; 설정 을 사용하는 것은 현명하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7d5e46d6c54b21b25eeef48c6ca4551b1f61a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSID&lt;/code&gt; clause is ignored, but is accepted for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;SYSID&lt;/code&gt; 의 절은 무시되지만 이전 버전과의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba9a4c3ee7dd77407d80711565ddf84296946777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to any &lt;code&gt;FROM&lt;/code&gt; item.</source>
          <target state="translated">&lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 절은 현재 일반 테이블 접수 및 뷰를 구체화된다. SQL 표준에 따라 &lt;code&gt;FROM&lt;/code&gt; 항목 에 적용 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3600170fb18cff60f53eb4ba51d9dce974f3e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUSTED&lt;/code&gt; option and the support function name(s) are ignored if the server has an entry for the specified language name in &lt;code&gt;pg_pltemplate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TRUSTED&lt;/code&gt; 서버가 지정된 언어 이름에 대한 항목이있는 경우 옵션과 지원 기능의 이름은 무시됩니다 &lt;code&gt;pg_pltemplate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53faeaca5564f551951f6575a18b776e07cb73f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; clause has this general form:</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 절은이 일반적인 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d37a98042f90333d3d9b66690fc343fe11354a51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNION&lt;/code&gt; operator computes the set union of the rows returned by the involved &lt;code&gt;SELECT&lt;/code&gt; statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two &lt;code&gt;SELECT&lt;/code&gt; statements that represent the direct operands of the &lt;code&gt;UNION&lt;/code&gt; must produce the same number of columns, and corresponding columns must be of compatible data types.</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 운영자는 참여에 의해 반환 된 행 세트 조합 계산 &lt;code&gt;SELECT&lt;/code&gt; 문을. 행이 결과 집합 중 하나 이상에 나타나는 경우 두 결과 집합의 집합 집합에 있습니다. &lt;code&gt;UNION&lt;/code&gt; 의 직접 피연산자를 나타내는 두 개의 &lt;code&gt;SELECT&lt;/code&gt; 문 은 동일한 수의 열을 생성해야하며 해당 열은 호환 가능한 데이터 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="df2f42f8ff2203573828998bc521aa46717845dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNIQUE&lt;/code&gt; constraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns.</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; 의 제약 조건 지정은 테이블의 하나 이상의 열에의 그룹은 고유 한 값을 포함 할 수 있습니다. 고유 테이블 제한 조건의 동작은 열 제한 조건의 동작과 동일하며 여러 열에 걸쳐있는 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="440900ea1c49963507f35e80410def61bdfb2e10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; clause is an obsolete spelling of the &lt;code&gt;ROLE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt; 절은의 오래된 철자 &lt;code&gt;ROLE&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="df5573cea50ffa4699b0e7de14e2efa40e40f614" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; with &lt;code&gt;USING (a, b)&lt;/code&gt; produces the join condition &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절은 당신이 양쪽이 결합 컬럼 (들)에 같은 이름을 사용하는 조인 특정 상황을 활용할 수 속기이다. 쉼표로 구분 된 공유 열 이름 목록을 사용하고 각 항목에 대한 동등 비교를 포함하는 결합 조건을 형성합니다. 예를 들어, &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 를 &lt;code&gt;USING (a, b)&lt;/code&gt; 과 결합하면 결합 조건이 &lt;code&gt;ON T1.a = T2.a AND T1.b = T2.b&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd69a2ff12f6e6b4d3bf9a9a6b47532dc2d1194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 정책에 대한 식입니다. 자세한 내용은 &lt;a href=&quot;sql-createpolicy&quot;&gt;정책 생성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbe3012f251c3e27b73557dcb624091be7838ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USING&lt;/code&gt; option of &lt;code&gt;SET DATA TYPE&lt;/code&gt; can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with the &lt;code&gt;SET DATA TYPE&lt;/code&gt; syntax. Because of this flexibility, the &lt;code&gt;USING&lt;/code&gt; expression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type, &lt;code&gt;SET DATA TYPE&lt;/code&gt; might fail to convert the default even though a &lt;code&gt;USING&lt;/code&gt; clause is supplied. In such cases, drop the default with &lt;code&gt;DROP DEFAULT&lt;/code&gt;, perform the &lt;code&gt;ALTER TYPE&lt;/code&gt;, and then use &lt;code&gt;SET DEFAULT&lt;/code&gt; to add a suitable new default. Similar considerations apply to indexes and constraints involving the column.</source>
          <target state="translated">&lt;code&gt;SET DATA TYPE&lt;/code&gt; 의 &lt;code&gt;USING&lt;/code&gt; 옵션은 실제로 행의 이전 값과 관련된 표현식을 지정할 수 있습니다. 즉, 다른 열과 변환되는 열을 참조 할 수 있습니다. 이를 통해 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 구문을 사용하여 매우 일반적인 변환을 수행 할 수 있습니다 . 이러한 유연성으로 인해 &lt;code&gt;USING&lt;/code&gt; 표현식은 열의 기본값 (있는 경우)에 적용되지 않습니다. 기본값에 필요한 결과는 상수 표현식이 아닐 수 있습니다. 즉, 이전 유형에서 새 유형으로 암시 적 또는 할당 캐스트가 없으면 &lt;code&gt;USING&lt;/code&gt; 절이 제공 되어도 &lt;code&gt;SET DATA TYPE&lt;/code&gt; 이 기본값을 변환하지 못할 수 있습니다 . 이러한 경우 &lt;code&gt;DROP DEFAULT&lt;/code&gt; 를 사용 하여 기본값을 삭제하십시오. &lt;code&gt;ALTER TYPE&lt;/code&gt; 을 수행 한 다음 &lt;code&gt;SET DEFAULT&lt;/code&gt; 를 사용 하여 적절한 새 기본값을 추가하십시오. 열과 관련된 인덱스 및 제약 조건에도 비슷한 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac72d27e393aaa10fa09ec0c99e41bf31ba8f68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause defines an expiration time for a password only, not for the role &lt;em&gt;per se&lt;/em&gt;. In particular, the expiration time is not enforced when logging in using a non-password-based authentication method.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 절은 아닌 역할에 대한 암호를 만료 시간을 정의 &lt;em&gt;그 자체&lt;/em&gt; . 특히 비 암호 기반 인증 방법을 사용하여 로그인 할 때는 만료 시간이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4254f4cbb5558ecbcabbf94985890347bc617c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VALID UNTIL&lt;/code&gt; clause sets a date and time after which the role's password is no longer valid. If this clause is omitted the password will be valid for all time.</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; 절은 역할의 암호가 더 이상 유효 후 날짜와 시간을 설정합니다. 이 절을 생략하면 암호는 항상 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3c44efcbdf803edc09491650dc604f24489fb4e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH CHECK&lt;/code&gt; expression for the policy. See &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; for details.</source>
          <target state="translated">정책 의 &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식입니다. 자세한 내용은 &lt;a href=&quot;sql-createpolicy&quot;&gt;정책 생성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f909d6d352b763da5996539ec5a35b3e1508bd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;DELETE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;DELETE&lt;/code&gt; 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c86cbf90270e40ca5022ce8fed26f2e4b7126438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;INSERT&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;INSERT&lt;/code&gt; 의 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b5376c90f6e32eea66f4e1b2c109c7f56e3b3b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the &lt;code&gt;UPDATE&lt;/code&gt; query. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; and &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 당신이에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다 &lt;code&gt;UPDATE&lt;/code&gt; 쿼리를. 자세한 내용 &lt;a href=&quot;queries-with&quot;&gt;은 7.8 절&lt;/a&gt; 및 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d36279616fce39b7667637feae639cf048d9729b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement. When writing a data-modifying statement (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;) in &lt;code&gt;WITH&lt;/code&gt;, it is usual to include a &lt;code&gt;RETURNING&lt;/code&gt; clause. It is the output of &lt;code&gt;RETURNING&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If &lt;code&gt;RETURNING&lt;/code&gt; is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 기본 쿼리에서 이름으로 참조 할 수있는 하나 개 이상의 하위 쿼리를 지정할 수 있습니다. 서브 쿼리는 효과적으로 기본 쿼리 기간 동안 임시 테이블 또는 뷰 역할을합니다. 각 하위 쿼리는 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;TABLE&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 문일 수 있습니다. &lt;code&gt;WITH&lt;/code&gt; 에 데이터 수정 명령문 ( &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; )을 작성할 때 &lt;code&gt;RETURNING&lt;/code&gt; 절 을 포함하는 것이 일반적 입니다. 그것은의 출력 &lt;code&gt;RETURNING&lt;/code&gt; , &lt;em&gt;하지&lt;/em&gt;&lt;em&gt;&lt;/em&gt;명령문이 수정하는 기본 테이블이며 기본 조회가 읽는 임시 테이블을 형성합니다. 경우 &lt;code&gt;RETURNING&lt;/code&gt; 생략 문은 여전히 실행되지만,이 차의 요청에 의한 테이블로 참조 할 수 없습니다 있도록 출력 기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd82170932e06b9823fd64af1127b85442398023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause can specify &lt;em&gt;storage parameters&lt;/em&gt; for tables, and for indexes associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint. Storage parameters for indexes are documented in &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed with &lt;code&gt;toast.&lt;/code&gt;, which controls the behavior of the table's secondary TOAST table, if any (see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information about TOAST). If a table parameter value is set and the equivalent &lt;code&gt;toast.&lt;/code&gt; parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절을 지정할 수 있습니다 &lt;em&gt;저장 매개 변수를&lt;/em&gt; 테이블 및 인덱스에 대한과 관련된 &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;EXCLUDE&lt;/code&gt; 제약 조건을. 인덱스의 스토리지 매개 변수는 &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX에&lt;/a&gt; 문서화되어 있습니다. 현재 테이블에 사용 가능한 스토리지 매개 변수가 아래에 나열되어 있습니다. 표시된 바와 같이 이러한 많은 매개 변수의 경우 이름 앞에 &lt;code&gt;toast.&lt;/code&gt; 붙은 동일한 추가 매개 변수가 있습니다. , 이것은 테이블의 2 차 TOAST 테이블의 동작을 제어합니다 ( TOAST에 대한 자세한 정보는 &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 참조 ). 테이블 매개 변수 값이 설정되고 해당하는 &lt;code&gt;toast.&lt;/code&gt; 매개 변수가 아닌 경우 TOAST 테이블은 테이블의 매개 변수 값을 사용합니다. 파티션 된 테이블에 이러한 매개 변수를 지정하는 것은 지원되지 않지만 개별 리프 파티션에 대해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e61d24618bca5f4d5d76d9ae780c2dce93b6f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WITH&lt;/code&gt; clause is a PostgreSQL extension; storage parameters are not in the standard.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절은 PostgreSQL의 확장입니다 스토리지 매개 변수가 표준에 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9bfddf2848aa0b39782b5bc4bcc89ef2f85698a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\i&lt;/code&gt; command reads in commands from the specified file. &lt;code&gt;psql&lt;/code&gt;'s &lt;code&gt;-s&lt;/code&gt; option puts you in single step mode which pauses before sending each statement to the server. The commands used in this section are in the file &lt;code&gt;basics.sql&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\i&lt;/code&gt; 명령은 지정된 파일에서 명령을 읽습니다. &lt;code&gt;psql&lt;/code&gt; 의 &lt;code&gt;-s&lt;/code&gt; 옵션은 단일 단계 모드로 전환하여 각 명령문을 서버로 보내기 전에 일시 정지합니다. 이 섹션에서 사용 된 명령은 &lt;code&gt;basics.sql&lt;/code&gt; 파일에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d745a90b32000102fbaf10faab8dc20a84ca8bde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\if&lt;/code&gt; and &lt;code&gt;\elif&lt;/code&gt; commands read their argument(s) and evaluate them as a boolean expression. If the expression yields &lt;code&gt;true&lt;/code&gt; then processing continues normally; otherwise, lines are skipped until a matching &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, or &lt;code&gt;\endif&lt;/code&gt; is reached. Once an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; test has succeeded, the arguments of later &lt;code&gt;\elif&lt;/code&gt; commands in the same block are not evaluated but are treated as false. Lines following an &lt;code&gt;\else&lt;/code&gt; are processed only if no earlier matching &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; succeeded.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; 와 &lt;code&gt;\elif&lt;/code&gt; 명령 자신의 주장 (들)을 읽고 부울 표현으로 그들을 평가합니다. 표현식이 &lt;code&gt;true&lt;/code&gt; 이면 처리는 정상적으로 계속됩니다. 그렇지 않으면 일치하는 &lt;code&gt;\elif&lt;/code&gt; , &lt;code&gt;\else&lt;/code&gt; 또는 &lt;code&gt;\endif&lt;/code&gt; 에 도달 할 때까지 줄을 건너 뜁니다 . 일단 &lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 테스트에 성공, 이후의 인수 &lt;code&gt;\elif&lt;/code&gt; 명령 같은 블록에서 평가되지 않고 허위로 처리됩니다. &lt;code&gt;\else&lt;/code&gt; 다음의 행 은 이전에 일치하는 &lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 가 성공 하지 않은 경우에만 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea3a007939b7e11bbba46ea6419ffc5cadf17bf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\ir&lt;/code&gt; command is similar to &lt;code&gt;\i&lt;/code&gt;, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, &lt;code&gt;\ir&lt;/code&gt; interprets file names relative to the directory in which the script is located, rather than the current working directory.</source>
          <target state="translated">&lt;code&gt;\ir&lt;/code&gt; 명령과 비슷 &lt;code&gt;\i&lt;/code&gt; ,하지만 다르게 결의 상대 파일 이름. 대화식 모드에서 실행할 때 두 명령은 동일하게 작동합니다. 그러나 스크립트에서 호출되면 &lt;code&gt;\ir&lt;/code&gt; 은 현재 작업 디렉토리가 아니라 스크립트가있는 디렉토리를 기준으로 파일 이름을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="169f5705e6b515a085e5b6da75e17e9f4dc2b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;age&lt;/code&gt; column measures the number of transactions from the cutoff XID to the current transaction's XID.</source>
          <target state="translated">&lt;code&gt;age&lt;/code&gt; 열은 현재 트랜잭션의 XID에 차단 XID에서 트랜잭션의 수를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="525d0fc7bca054a06817564f9e4e716d7d8750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignment&lt;/code&gt; parameter specifies the storage alignment required for the data type. The allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries. Note that variable-length types must have an alignment of at least 4, since they necessarily contain an &lt;code&gt;int4&lt;/code&gt; as their first component.</source>
          <target state="translated">&lt;code&gt;alignment&lt;/code&gt; 파라미터는 데이터 유형에 필요한 저장 배열을 지정한다. 허용 된 값은 1, 2, 4 또는 8 바이트 경계에서 정렬하는 것과 같습니다. 가변 길이 유형은 반드시 첫 번째 구성 요소로 &lt;code&gt;int4&lt;/code&gt; 를 포함하므로 최소 4의 정렬을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="66ec02f3867429174e02872bcd9ba803a6ca7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcheck&lt;/code&gt; module provides functions that allow you to verify the logical consistency of the structure of relations. If the structure appears to be valid, no error is raised.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 의 모듈은 관계의 구조의 논리적 일관성을 검증 할 수있는 기능을 제공합니다. 구조가 유효하면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04aff6c7be2111c7103649cab8f33b7af9c81d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amcostestimate&lt;/code&gt; function is given information describing a possible index scan, including lists of WHERE and ORDER BY clauses that have been determined to be usable with the index. It must return estimates of the cost of accessing the index and the selectivity of the WHERE clauses (that is, the fraction of parent-table rows that will be retrieved during the index scan). For simple cases, nearly all the work of the cost estimator can be done by calling standard routines in the optimizer; the point of having an &lt;code&gt;amcostestimate&lt;/code&gt; function is to allow index access methods to provide index-type-specific knowledge, in case it is possible to improve on the standard estimates.</source>
          <target state="translated">&lt;code&gt;amcostestimate&lt;/code&gt; 기능 정보의리스트를 포함하는 검색 가능한 인덱스를 기술 주어진다 순서 인덱스와 사용할 수있는 것으로 판정 된 절 BY. 인덱스 액세스 비용 및 WHERE 절의 선택성 (즉, 인덱스 스캔 중에 검색 될 상위 테이블 행의 비율)에 대한 추정값을 리턴해야합니다. 간단한 경우, 옵티 마이저에서 표준 루틴을 호출하여 비용 견적 도구의 거의 모든 작업을 수행 할 수 있습니다. &lt;code&gt;amcostestimate&lt;/code&gt; 기능 의 요점은 표준 추정치를 개선 할 수있는 경우 인덱스 액세스 방법이 인덱스 유형별 지식을 제공 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6898a2ba9037019e5df24b6e547743d4cc59ddab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgetbitmap&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;bitmap&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgetbitmap&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgetbitmap&lt;/code&gt; 의 기능 요구하는 경우에만 액세스 방법 지지체 &quot;비트 맵&quot;인덱스 스캔을 제공한다. 그렇지 않은 경우, &lt;code&gt;amgetbitmap&lt;/code&gt; 의 그 필드 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 의 구조체는 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="388cb503bc9fecd1c56c284bf2fd7e41a507c9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function has a &lt;code&gt;direction&lt;/code&gt; argument, which can be either &lt;code&gt;ForwardScanDirection&lt;/code&gt; (the normal case) or &lt;code&gt;BackwardScanDirection&lt;/code&gt;. If the first call after &lt;code&gt;amrescan&lt;/code&gt; specifies &lt;code&gt;BackwardScanDirection&lt;/code&gt;, then the set of matching index entries is to be scanned back-to-front rather than in the normal front-to-back direction, so &lt;code&gt;amgettuple&lt;/code&gt; must return the last matching tuple in the index, rather than the first one as it normally would. (This will only occur for access methods that set &lt;code&gt;amcanorder&lt;/code&gt; to true.) After the first call, &lt;code&gt;amgettuple&lt;/code&gt; must be prepared to advance the scan in either direction from the most recently returned entry. (But if &lt;code&gt;amcanbackward&lt;/code&gt; is false, all subsequent calls will have the same direction as the first one.)</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; 의 함수를 갖는 &lt;code&gt;direction&lt;/code&gt; 이 될 수 인수 &lt;code&gt;ForwardScanDirection&lt;/code&gt; (통상의 경우) 또는 &lt;code&gt;BackwardScanDirection&lt;/code&gt; 를 . &lt;code&gt;amrescan&lt;/code&gt; 이후의 첫 번째 호출이 &lt;code&gt;BackwardScanDirection&lt;/code&gt; 을 지정 하면 일치하는 색인 ​​항목 세트가 정상적인 전후 방향이 아닌 연속적으로 스캔되므로 &lt;code&gt;amgettuple&lt;/code&gt; 은 색인에서 마지막으로 일치하는 튜플을 리턴해야합니다. 평소처럼 첫 번째 것보다. (이것은 &lt;code&gt;amcanorder&lt;/code&gt; 를 true로 설정 한 액세스 메소드에서만 발생 합니다.) 첫 번째 호출 후 &lt;code&gt;amgettuple&lt;/code&gt; 가장 최근에 반환 된 항목에서 스캔을 어느 방향 으로든 진행할 수 있도록 준비해야합니다. 그러나 &lt;code&gt;amcanbackward&lt;/code&gt; 가 false이면 모든 후속 통화는 첫 번째와 동일한 방향을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a0f7a76e8330fc4bc94786133307659b91dcdc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amgettuple&lt;/code&gt; function need only be provided if the access method supports &amp;ldquo;plain&amp;rdquo; index scans. If it doesn't, the &lt;code&gt;amgettuple&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct must be set to NULL.</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; 기능 필요가있는 경우에만이 액세스 방법을 지원하는 &quot;일반&quot;인덱스 스캔을 제공한다. 그렇지 않은 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amgettuple&lt;/code&gt; 필드 를 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cde20037ee1497cd6ab533acce975df0e8aa1224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ammarkpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;ammarkpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;ammarkpos&lt;/code&gt; 의 액세스 방법이 지원하는 스캔을 주문한 경우 기능의 필요성은 제공 될 수있다. 그렇지 않으면 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;ammarkpos&lt;/code&gt; 필드 가 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccdf26b3604c28eca91ce1c3b3a35a7a58b7e44e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amproperty&lt;/code&gt; method allows index access methods to override the default behavior of &lt;code&gt;pg_index_column_has_property&lt;/code&gt; and related functions. If the access method does not have any special behavior for index property inquiries, the &lt;code&gt;amproperty&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct can be set to NULL. Otherwise, the &lt;code&gt;amproperty&lt;/code&gt; method will be called with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; both zero for &lt;code&gt;pg_indexam_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; zero for &lt;code&gt;pg_index_has_property&lt;/code&gt; calls, or with &lt;em&gt;&lt;code&gt;index_oid&lt;/code&gt;&lt;/em&gt; valid and &lt;em&gt;&lt;code&gt;attno&lt;/code&gt;&lt;/em&gt; greater than zero for &lt;code&gt;pg_index_column_has_property&lt;/code&gt; calls. &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is an enum value identifying the property being tested, while &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; is the original property name string. If the core code does not recognize the property name then &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt;. Access methods can define custom property names by checking &lt;em&gt;&lt;code&gt;propname&lt;/code&gt;&lt;/em&gt; for a match (use &lt;code&gt;pg_strcasecmp&lt;/code&gt; to match, for consistency with the core code); for names known to the core code, it's better to inspect &lt;em&gt;&lt;code&gt;prop&lt;/code&gt;&lt;/em&gt;. If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; then it has determined the property test result: it must set &lt;code&gt;*res&lt;/code&gt; to the boolean value to return, or set &lt;code&gt;*isnull&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to return a NULL. (Both of the referenced variables are initialized to &lt;code&gt;false&lt;/code&gt; before the call.) If the &lt;code&gt;amproperty&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; then the core code will proceed with its normal logic for determining the property test result.</source>
          <target state="translated">&lt;code&gt;amproperty&lt;/code&gt; 의 방법은 인덱스 접근 방법의 기본 동작을 대체 할 수 있습니다 &lt;code&gt;pg_index_column_has_property&lt;/code&gt; 및 관련 기능. 액세스 메소드에 인덱스 특성 조회에 대한 특수 동작이없는 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amproperty&lt;/code&gt; 필드 를 NULL로 설정할 수 있습니다. 그렇지 않으면, &lt;code&gt;amproperty&lt;/code&gt; 의 방법으로 호출됩니다 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt; 양쪽 모두 0에 대한 &lt;code&gt;pg_indexam_has_property&lt;/code&gt; 의 전화, 또는에 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 유효하고 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt; 제로 &lt;code&gt;pg_index_has_property&lt;/code&gt; 의 전화, 또는에 &lt;em&gt; &lt;code&gt;index_oid&lt;/code&gt; &lt;/em&gt; 유효하고 &lt;em&gt; &lt;code&gt;attno&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;pg_index_column_has_property&lt;/code&gt; 호출의 경우 0보다 큽니다 . &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 은 테스트중인 속성을 식별하는 열거 형 값이며 &lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt; 은 원래 속성 이름 문자열입니다. 코어 코드가 특성 이름을 인식하지 못하면 &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;AMPROP_UNKNOWN&lt;/code&gt; 입니다. 액세스 메소드는 일치에 대한 &lt;em&gt; &lt;code&gt;propname&lt;/code&gt; &lt;/em&gt; 을 검사하여 사용자 정의 특성 이름을 정의 할 수 있습니다 ( 핵심 코드와의 일관성을 위해 일치 하도록 &lt;code&gt;pg_strcasecmp&lt;/code&gt; 사용 ). 핵심 코드에 알려진 이름의 경우 &lt;em&gt; &lt;code&gt;prop&lt;/code&gt; &lt;/em&gt; 검사하는 것이 좋습니다 . 는 IF &lt;code&gt;amproperty&lt;/code&gt; 의 방법은 반환 &lt;code&gt;true&lt;/code&gt; 다음은 특성 시험 결과를 결정했다 : 그것은 설정해야합니다 &lt;code&gt;*res&lt;/code&gt; 부울 값으로 리턴하거나 &lt;code&gt;*isnull&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 NULL을 리턴하십시오. 참조 된 변수는 모두 호출하기 전에 &lt;code&gt;false&lt;/code&gt; 로 초기화됩니다 . &lt;code&gt;amproperty&lt;/code&gt; 메소드가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 코어 코드는 특성 테스트 결과를 판별하기위한 일반 로직으로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="ee6ce83ebaf748f648fd0330541075210e5894e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amrestrpos&lt;/code&gt; function need only be provided if the access method supports ordered scans. If it doesn't, the &lt;code&gt;amrestrpos&lt;/code&gt; field in its &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct may be set to NULL.</source>
          <target state="translated">&lt;code&gt;amrestrpos&lt;/code&gt; 의 액세스 방법이 지원하는 스캔을 주문한 경우 기능은 제공 될 필요가있다. 그렇지 않은 경우 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 구조체 의 &lt;code&gt;amrestrpos&lt;/code&gt; 필드 가 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe809061c1f64f874371a0dcea9b46cff8a18bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application_name&lt;/code&gt; can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). It is typically set by an application upon connection to the server. The name will be displayed in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view and included in CSV log entries. It can also be included in regular log entries via the &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; parameter. Only printable ASCII characters may be used in the &lt;code&gt;application_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;application_name&lt;/code&gt; 이하의 문자열이 될 수 있습니다 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 의 문자 (표준 빌드 64 자). 일반적으로 서버에 연결할 때 응용 프로그램에 의해 설정됩니다. 이름은 &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기에 표시 되고 CSV 로그 항목에 포함됩니다. &lt;a href=&quot;runtime-config-logging#GUC-LOG-LINE-PREFIX&quot;&gt;log_line_prefix&lt;/a&gt; 매개 변수 를 통해 일반 로그 항목에 포함될 수도 있습니다 . &lt;code&gt;application_name&lt;/code&gt; 값 에는 인쇄 가능한 ASCII 문자 만 사용할 수 있습니다 . 다른 문자는 물음표 ( &lt;code&gt;?&lt;/code&gt; ) 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="810ba7465a70771d2961f660e2ffe00a08ad7b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function works for the types &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;, and &lt;code&gt;path&lt;/code&gt;. The &lt;code&gt;area&lt;/code&gt; function only works on the &lt;code&gt;path&lt;/code&gt; data type if the points in the &lt;code&gt;path&lt;/code&gt; are non-intersecting. For example, the &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; will not work; however, the following visually identical &lt;code&gt;path&lt;/code&gt;&lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; will work. If the concept of an intersecting versus non-intersecting &lt;code&gt;path&lt;/code&gt; is confusing, draw both of the above &lt;code&gt;path&lt;/code&gt;s side by side on a piece of graph paper.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 기능은 유형의 작동 &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; 및 &lt;code&gt;path&lt;/code&gt; . &lt;code&gt;area&lt;/code&gt; 기능 만 작동 &lt;code&gt;path&lt;/code&gt; 의 포인트 경우 데이터 유형 &lt;code&gt;path&lt;/code&gt; 교차하지 않는입니다. 예를 들어 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH&lt;/code&gt; 가 작동하지 않습니다. 그러나 다음 시각적으로 동일한 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH&lt;/code&gt; 가 작동합니다. 교차 &lt;code&gt;path&lt;/code&gt; 와 교차하지 않는 경로 의 개념 이 혼동되면 위의 &lt;code&gt;path&lt;/code&gt; 를 그래프 용지에 나란히 그리십시오 .</target>
        </trans-unit>
        <trans-unit id="59f921ad3facaf5178eff030fa07dc7338005685" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asciidoc&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;latex&lt;/code&gt;, &lt;code&gt;latex-longtable&lt;/code&gt;, and &lt;code&gt;troff-ms&lt;/code&gt; formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. The &lt;code&gt;latex&lt;/code&gt; format uses LaTeX's &lt;code&gt;tabular&lt;/code&gt; environment. The &lt;code&gt;latex-longtable&lt;/code&gt; format requires the LaTeX &lt;code&gt;longtable&lt;/code&gt; and &lt;code&gt;booktabs&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;asciidoc&lt;/code&gt; , &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;latex&lt;/code&gt; , &lt;code&gt;latex-longtable&lt;/code&gt; 및 &lt;code&gt;troff-ms&lt;/code&gt; 형식은 각각의 마크 업 언어를 사용하여 문서에 포함된다 테이블을 넣어. 그들은 완전한 문서가 아닙니다! HTML에서는 필요하지 않지만 LaTeX에서는 완전한 문서 래퍼가 있어야합니다. &lt;code&gt;latex&lt;/code&gt; 형식은 유액의 사용 &lt;code&gt;tabular&lt;/code&gt; 환경을. &lt;code&gt;latex-longtable&lt;/code&gt; 형식은 LaTeX의 필요 &lt;code&gt;longtable&lt;/code&gt; 및 &lt;code&gt;booktabs&lt;/code&gt; 패키지를.</target>
        </trans-unit>
        <trans-unit id="f35bd0bda526ded9e0b91c584dead64c2d3ef9b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto_explain&lt;/code&gt; module provides a means for logging execution plans of slow statements automatically, without having to run &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; by hand. This is especially helpful for tracking down un-optimized queries in large applications.</source>
          <target state="translated">&lt;code&gt;auto_explain&lt;/code&gt; 의 모듈은 실행하지 않아도 자동으로 속도가 느린 문장의 실행 계획을 기록하는 수단을 제공 &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; 손으로. 이는 대규모 응용 프로그램에서 최적화되지 않은 쿼리를 추적하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9f04194d1f661ec08cbef8138cc1ebad08b480fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bench.pl&lt;/code&gt; script has numerous options, which are displayed when it is run without any arguments.</source>
          <target state="translated">&lt;code&gt;bench.pl&lt;/code&gt; 의 스크립트는이 인수없이 실행될 때 표시되는 다양한 옵션을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e37968903b5f952d43e00009d52dc6bb5a6d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; file format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 파일 형식은 파일 헤더, 행 데이터를 포함하는 0 개 이상의 튜플 및 파일 트레일러로 구성되어 있습니다. 헤더와 데이터는 네트워크 바이트 순서로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5593a80ab4eb5986c84ab5663e69124cb8f2b569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; format option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text and &lt;code&gt;CSV&lt;/code&gt; formats, but a binary-format file is less portable across machine architectures and PostgreSQL versions. Also, the binary format is very data type specific; for example it will not work to output binary data from a &lt;code&gt;smallint&lt;/code&gt; column and read it into an &lt;code&gt;integer&lt;/code&gt; column, even though that would work fine in text format.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 포맷 옵션은 모든 데이터가 바이너리 형식으로가 아닌 텍스트로 읽기 / 저장됩니다. 텍스트 및 &lt;code&gt;CSV&lt;/code&gt; 형식 보다 다소 빠르지 만 이진 형식 파일은 머신 아키텍처 및 PostgreSQL 버전에서 이식성이 떨어집니다. 또한 이진 형식은 데이터 형식에 따라 다릅니다. 예를 들어 &lt;code&gt;smallint&lt;/code&gt; 열 에서 이진 데이터를 출력 하고 &lt;code&gt;integer&lt;/code&gt; 열로 읽는 것은 작동하지 않지만 텍스트 형식에서는 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="402f6e7dc47cea56b75bd8100479b08159b6b07c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; data type allows storage of binary strings; see &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;Table 8.6&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 데이터 타입은 이진 스트링의 저장을 허용; &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-TABLE&quot;&gt;표 8.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6287927d29cc83d11891a4932630e624e03a0f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytea&lt;/code&gt; type supports two formats for input and output: &amp;ldquo;hex&amp;rdquo; format and PostgreSQL's historical &amp;ldquo;escape&amp;rdquo; format. Both of these are always accepted on input. The output format depends on the configuration parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt;; the default is hex. (Note that the hex format was introduced in PostgreSQL 9.0; earlier versions and some tools don't understand it.)</source>
          <target state="translated">&lt;code&gt;bytea&lt;/code&gt; 와의 종류가 지원하는 입력 및 출력에 대한 두 가지 형식 : &quot;진수&quot;형식과 PostgreSQL의 역사 &quot;탈출&quot;형식입니다. 이 두 가지 모두 입력시 항상 허용됩니다. 출력 형식은 &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;bytea_output&lt;/a&gt; 구성 매개 변수에 따라 다릅니다 . 디폴트는 16 진입니다. 16 진수 형식은 PostgreSQL 9.0에서 도입되었으며 이전 버전 및 일부 도구는이를 이해하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e03633603ba240cb14fd9f2ba15fb155d7d2a20f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;preferred&lt;/code&gt; parameters can be used to help control which implicit cast will be applied in ambiguous situations. Each data type belongs to a category named by a single ASCII character, and each type is either &amp;ldquo;preferred&amp;rdquo; or not within its category. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators. For more details see &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;Chapter 10&lt;/a&gt;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the &amp;ldquo;most general&amp;rdquo; types as being preferred within the category. The &lt;code&gt;category&lt;/code&gt; parameter is especially useful when adding a user-defined type to an existing built-in category, such as the numeric or string types. However, it is also possible to create new entirely-user-defined type categories. Select any ASCII character other than an upper-case letter to name such a category.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 및 &lt;code&gt;preferred&lt;/code&gt; 매개 변수는 암시 적 캐스트가 모호한 상황에서 적용됩니다 도움말 제어 할 수 있습니다. 각 데이터 유형은 단일 ASCII 문자로 명명 된 카테고리에 속하며 각 유형은 &quot;선호&quot;또는 카테고리 내에 있지 않습니다. 이 규칙이 오버로드 된 함수 나 연산자를 해결하는 데 도움이되는 경우 파서는 선호하는 유형 (동일한 범주 내의 다른 유형에서만)으로 캐스팅하는 것을 선호합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/typeconv.html&quot;&gt;10 장을&lt;/a&gt; 참조하십시오. 다른 유형과의 암시 적 캐스트가없는 유형의 경우 이러한 설정을 기본값으로 두는 것으로 충분합니다. 그러나 내재 된 캐스트가있는 관련 유형 그룹의 경우, 모두 유형에 속하는 것으로 표시하고 카테고리 내에서 선호하는 &quot;가장 일반적인&quot;유형 중 하나 또는 두 개를 선택하는 것이 종종 도움이됩니다. &lt;code&gt;category&lt;/code&gt; 사용자 정의 형 파라미터를 추가하는 경우가 특히 유용 기존의 기본 범주, 이러한 숫자 또는 문자열 유형으로. 그러나 완전히 사용자 정의 된 새 유형 범주를 만들 수도 있습니다. 대문자 이외의 ASCII 문자를 선택하여 해당 범주의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8d165445c71930fc47e32f1799f62450eb66b7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_length&lt;/code&gt; function is discussed in &lt;a href=&quot;functions-string&quot;&gt;Section 9.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char_length&lt;/code&gt; 함수로 설명 &lt;a href=&quot;functions-string&quot;&gt;9.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77163d06028806a119645154241f80d46c25a3ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checksum&lt;/code&gt; field is the checksum stored in the page, which might be incorrect if the page is somehow corrupted. If data checksums are not enabled for this instance, then the value stored is meaningless.</source>
          <target state="translated">&lt;code&gt;checksum&lt;/code&gt; 필드는 페이지가 어떻게 든 손상된 경우 올바르지 않을 수 있습니다 페이지에 저장된 체크섬이다. 이 인스턴스에 대해 데이터 체크섬을 사용할 수없는 경우 저장된 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="82779e6580b956b5bd325b957d4ac6fe2940b5b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;choose&lt;/code&gt; function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix.</source>
          <target state="translated">&lt;code&gt;choose&lt;/code&gt; 새 값이 기존의 자식 노드 중 하나와 일치하는지, 또는 새 자식 노드를 추가해야한다는, 또는 새로운 값이를 만들 분할해야 튜플 접두사와 내부 튜플 너무 일치하지 않는 부분 중 하나를 확인할 수 있습니다 기능을 덜 제한적인 접두사.</target>
        </trans-unit>
        <trans-unit id="21462edf88e71a2a5abedaf79780415d3cc77658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cidr&lt;/code&gt; type holds an IPv4 or IPv6 network specification. Input and output formats follow Classless Internet Domain Routing conventions. The format for specifying networks is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is the network represented as an IPv4 or IPv6 address, and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If &lt;code&gt;y&lt;/code&gt; is omitted, it is calculated using assumptions from the older classful network numbering system, except it will be at least large enough to include all of the octets written in the input. It is an error to specify a network address that has bits set to the right of the specified netmask.</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 유형은 IPv4 또는 IPv6 네트워크 사양을 보유하고 있습니다. 입력 및 출력 형식은 클래스리스 인터넷 도메인 라우팅 규칙을 따릅니다. 네트워크를 지정하는 형식은 &lt;code&gt;address/y&lt;/code&gt; 입니다. 여기서 &lt;code&gt;address&lt;/code&gt; 는 IPv4 또는 IPv6 주소로 표시되는 네트워크이고 &lt;code&gt;y&lt;/code&gt; 는 넷 마스크의 비트 수입니다. 경우 &lt;code&gt;y&lt;/code&gt; 생략이 입력에 기록 된 모든 옥텟을 포함하는 적어도 충분한있을 것 이외에는, 또, 기존의 네트워크 클래스 번호 시스템에서 가정을 사용하여 계산된다. 지정된 넷 마스크의 오른쪽에 비트가 설정된 네트워크 주소를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="313dbc3735e1e6015db884f05770b0b3141b691a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; data type allows you to eliminate calls to &lt;code&gt;lower&lt;/code&gt; in SQL queries, and allows a primary key to be case-insensitive. &lt;code&gt;citext&lt;/code&gt; is locale-aware, just like &lt;code&gt;text&lt;/code&gt;, which means that the matching of upper case and lower case characters is dependent on the rules of the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting. Again, this behavior is identical to the use of &lt;code&gt;lower&lt;/code&gt; in queries. But because it's done transparently by the data type, you don't have to remember to do anything special in your queries.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 의 데이터 타입은 당신이 전화 제거 할 수 있습니다 &lt;code&gt;lower&lt;/code&gt; SQL 쿼리에, 그리고 대소 문자를 구별 될 수있는 기본 키를 할 수 있습니다. &lt;code&gt;citext&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 와 마찬가지로 로케일을 인식 하므로 대문자와 소문자의 일치는 데이터베이스의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 규칙에 따라 다릅니다 . 이 동작은 &lt;code&gt;lower&lt;/code&gt; 쿼리를 사용하는 것과 동일 합니다. 그러나 데이터 유형별로 투명하게 수행되므로 쿼리에서 특별한 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd87bdad25baf813522f25a71f5adc18488d42f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;citext&lt;/code&gt; module provides a case-insensitive character string type, &lt;code&gt;citext&lt;/code&gt;. Essentially, it internally calls &lt;code&gt;lower&lt;/code&gt; when comparing values. Otherwise, it behaves almost exactly like &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 의 모듈은 대소 문자를 구분 문자열 유형을 제공 &lt;code&gt;citext&lt;/code&gt; 을 . 본질적으로, 내부적으로 호출 &lt;code&gt;lower&lt;/code&gt; 값을 비교할 때. 그렇지 않으면 &lt;code&gt;text&lt;/code&gt; 와 거의 동일하게 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="bfdaff8a345f235278633882be7cad6ce5741ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clientcert&lt;/code&gt; authentication option is available for all authentication methods, but only in &lt;code&gt;pg_hba.conf&lt;/code&gt; lines specified as &lt;code&gt;hostssl&lt;/code&gt;. When &lt;code&gt;clientcert&lt;/code&gt; is not specified or is set to &lt;code&gt;no-verify&lt;/code&gt;, the server will still verify any presented client certificates against its CA file, if one is configured &amp;mdash; but it will not insist that a client certificate be presented.</source>
          <target state="translated">&lt;code&gt;clientcert&lt;/code&gt; 의 인증 옵션 만에, 모든 인증 방법을 사용할 수 &lt;code&gt;pg_hba.conf&lt;/code&gt; 로 지정된 라인 &lt;code&gt;hostssl&lt;/code&gt; . 때 &lt;code&gt;clientcert&lt;/code&gt; 가 지정되지 않았거나로 설정되어 &lt;code&gt;no-verify&lt;/code&gt; 한 구성되어있는 경우 서버가 계속 그 CA 파일에 대해 어떤되게 클라이언트 인증서를 확인합니다 -하지만 클라이언트 인증서가 제공 될 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c87c5b4f9f4b1dd6255f18fc98a9e79dfa277fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;column_expression&lt;/code&gt; for a column is an XPath 1.0 expression that is evaluated for each row, with the current node from the &lt;code&gt;row_expression&lt;/code&gt; result as its context item, to find the value of the column. If no &lt;code&gt;column_expression&lt;/code&gt; is given, then the column name is used as an implicit path.</source>
          <target state="translated">&lt;code&gt;column_expression&lt;/code&gt; 열의는로부터 현재 노드와, 각 행에 대해 평가하는 XPath 표현 1.0 &lt;code&gt;row_expression&lt;/code&gt; 의 열 값을 찾기 위해, 그 컨텍스트 항목과 결과. &lt;code&gt;column_expression&lt;/code&gt; 이 제공 되지 않으면 열 이름이 암시 적 경로로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6cd05e41a967e8fffae0ba56f38e3c8841aa41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; function may optionally be specified to allow the aggregate function to support partial aggregation. If provided, the &lt;code&gt;combinefunc&lt;/code&gt; must combine two &lt;code&gt;state_data_type&lt;/code&gt; values, each containing the result of aggregation over some subset of the input values, to produce a new &lt;code&gt;state_data_type&lt;/code&gt; that represents the result of aggregating over both sets of inputs. This function can be thought of as an &lt;code&gt;sfunc&lt;/code&gt;, where instead of acting upon an individual input row and adding it to the running aggregate state, it adds another aggregate state to the running state.</source>
          <target state="translated">&lt;code&gt;combinefunc&lt;/code&gt; 의 기능을 선택적으로 집계 기능 부분 집합을 지원하도록 지정 될 수있다. 제공되는 경우 &lt;code&gt;combinefunc&lt;/code&gt; 는 두 입력 집합에 대한 집계 결과를 나타내는 새로운 &lt;code&gt;state_data_type&lt;/code&gt; 을 생성하기 위해 각각 입력 값의 일부 하위 집합에 대한 집계 결과를 포함하는 두 개의 &lt;code&gt;state_data_type&lt;/code&gt; 값을 결합해야합니다 . 이 함수는 개별 입력 행에 작용하여 실행 집계 상태에 추가하는 대신 다른 집계 상태를 실행 상태에 추가 하는 &lt;code&gt;sfunc&lt;/code&gt; 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47761aa84c1d418aac8f5102d13fb4baaa2c9ec6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combinefunc&lt;/code&gt; must be declared as taking two arguments of the &lt;code&gt;state_data_type&lt;/code&gt; and returning a value of the &lt;code&gt;state_data_type&lt;/code&gt;. Optionally this function may be &amp;ldquo;strict&amp;rdquo;. In this case the function will not be called when either of the input states are null; the other state will be taken as the correct result.</source>
          <target state="translated">&lt;code&gt;combinefunc&lt;/code&gt; 이 의 두 개의 인수 복용으로 선언해야 &lt;code&gt;state_data_type&lt;/code&gt; 을 하고 값 반환 &lt;code&gt;state_data_type&lt;/code&gt; 을 . 선택적으로이 기능은&amp;ldquo;엄격&amp;rdquo;할 수 있습니다. 이 경우 입력 상태 중 하나가 null 인 경우 함수가 호출되지 않습니다. 다른 상태는 올바른 결과로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="09fe595cccceb2fd23743e43b5600a7fb060859e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite_value&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; syntax results in column expansion of this kind when it appears at the top level of a &lt;a href=&quot;queries-select-lists&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; output list&lt;/a&gt;, a &lt;a href=&quot;dml-returning&quot;&gt;&lt;code&gt;RETURNING&lt;/code&gt; list&lt;/a&gt; in &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;, a &lt;a href=&quot;queries-values&quot;&gt;&lt;code&gt;VALUES&lt;/code&gt; clause&lt;/a&gt;, or a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. In all other contexts (including when nested inside one of those constructs), attaching &lt;code&gt;.*&lt;/code&gt; to a composite value does not change the value, since it means &amp;ldquo;all columns&amp;rdquo; and so the same composite value is produced again. For example, if &lt;code&gt;somefunc()&lt;/code&gt; accepts a composite-valued argument, these queries are the same:</source>
          <target state="translated">&lt;code&gt;composite_value&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 이러한 종류의 열 팽창 구문 결과 그것의 최상위에 나타나는 &lt;a href=&quot;queries-select-lists&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; 출력리스트&lt;/a&gt; 하는 &lt;a href=&quot;dml-returning&quot;&gt; &lt;code&gt;RETURNING&lt;/code&gt; 리스트&lt;/a&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 하는 &lt;a href=&quot;queries-values&quot;&gt; &lt;code&gt;VALUES&lt;/code&gt; 의 절&lt;/a&gt; 또는 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;연속 생성자&lt;/a&gt; . 다른 모든 컨텍스트 (해당 구문 중 하나에 중첩 된 경우 포함)에서 복합 값에 &lt;code&gt;.*&lt;/code&gt; 를 첨부 해도 값은 변경되지 않습니다. &quot;모든 열&quot;을 의미하므로 동일한 복합 값이 다시 생성됩니다. 예를 들어 &lt;code&gt;somefunc()&lt;/code&gt; 가 복합 값 인수를 허용하면 이러한 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76f0da3cbd2adb16157bd1e6643bd7a0df3d22de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;concat_ws&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the &lt;code&gt;VARIADIC&lt;/code&gt; keyword (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;Section 37.5.5&lt;/a&gt;). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, &lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concat_ws&lt;/code&gt; return NULL, but &lt;code&gt;format&lt;/code&gt; treats a NULL as a zero-element array.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; , &lt;code&gt;concat_ws&lt;/code&gt; 과 &lt;code&gt;format&lt;/code&gt; 이 연접하거나 표시된 어레이로서 포맷되는 값 통과 할 수 있도록 기능이있는 가변 &lt;code&gt;VARIADIC&lt;/code&gt; 의 키워드 (참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS&quot;&gt;섹션을 37.5.5&lt;/a&gt; ). 배열의 요소는 마치 함수에 대한 별도의 일반 인수 인 것처럼 처리됩니다. variadic 배열 인수가 NULL이면 &lt;code&gt;concat&lt;/code&gt; 및 &lt;code&gt;concat_ws&lt;/code&gt; 는 NULL을 반환하지만 &lt;code&gt;format&lt;/code&gt; 은 NULL을 0 요소 배열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a299b1850dd68d90e4960be66574857975c076da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; 의 기능은 복귀 선언 &lt;code&gt;setof record&lt;/code&gt; 출력 컬럼의 실제 이름과 유형이 정의해야합니다, 그래서 &lt;code&gt;FROM&lt;/code&gt; 호출 절 &lt;code&gt;SELECT&lt;/code&gt; 예를 들어, 문 :</target>
        </trans-unit>
        <trans-unit id="2da96468cede4a34e23f2e877f5cf905f10ef78c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connectby&lt;/code&gt; function produces a display of hierarchical data that is stored in a table. The table must have a key field that uniquely identifies rows, and a parent-key field that references the parent (if any) of each row. &lt;code&gt;connectby&lt;/code&gt; can display the sub-tree descending from any row.</source>
          <target state="translated">&lt;code&gt;connectby&lt;/code&gt; 의 함수는 테이블에 저장된 계층 적 데이터의 표시를 생성한다. 테이블에는 행을 고유하게 식별하는 키 필드와 각 행의 상위 (있는 경우)를 참조하는 상위 키 필드가 있어야합니다. &lt;code&gt;connectby&lt;/code&gt; 는 모든 행에서 내림차순으로 하위 트리를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85d82cc59d92a5d0a18334cf90938c8ed88a3a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contrib&lt;/code&gt; section contains a number of extensions that provide transforms, which can serve as real-world examples.</source>
          <target state="translated">&lt;code&gt;contrib&lt;/code&gt; 섹션은 실제 사례 역할을 할 수 변환을 제공하는 확장의 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1ffcb414402375d1d42596e7d3c9b1593a173043" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows copied.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 복사 된 행의 수입니다.</target>
        </trans-unit>
        <trans-unit id="af73b626e7353c20a6881d071978129473a029ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows deleted. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when deletes were suppressed by a &lt;code&gt;BEFORE DELETE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were deleted by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 삭제 된 행의 수입니다. &lt;code&gt;BEFORE DELETE&lt;/code&gt; 트리거에 의해 삭제가 억제 된 경우이 수는 &lt;code&gt;condition&lt;/code&gt; 과 일치하는 행 수보다 적을 수 있습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 0, 행이 (이 오류로 간주되지 않음) 쿼리에 의해 삭제되지 않았다.</target>
        </trans-unit>
        <trans-unit id="429e699d049ecd7be74bd5a583ab136d3d21eca9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows fetched (possibly zero). Note that in psql, the command tag will not actually be displayed, since psql displays the fetched rows instead.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 행의 수 (가능한 제로) 페치된다. psql에서는 페치 된 행을 대신 표시하므로 명령 태그는 실제로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0d4008484fc3a6fda992772be11542d78e11a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows inserted or updated. &lt;code&gt;oid&lt;/code&gt; is always 0 (it used to be the OID assigned to the inserted row if &lt;code&gt;count&lt;/code&gt; was exactly one and the target table was declared &lt;code&gt;WITH OIDS&lt;/code&gt; and 0 otherwise, but creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 삽입되거나 갱신 된 행의 수이다. &lt;code&gt;oid&lt;/code&gt; 는 항상 0입니다. &lt;code&gt;count&lt;/code&gt; 가 정확히 1이고 대상 테이블이 &lt;code&gt;WITH OIDS&lt;/code&gt; 로 선언 된 경우 삽입 된 행에 지정된 OID 였으며 그렇지 않은 경우 0이지만 더 이상 &lt;code&gt;WITH OIDS&lt;/code&gt; 를 갖는 테이블 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d59e6fa3805ce82c8f3b0c639019e005fef26c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows that a &lt;code&gt;FETCH&lt;/code&gt; command with the same parameters would have returned (possibly zero).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; A가 행수 &lt;code&gt;FETCH&lt;/code&gt; 반환 한 것과 동일한 파라미터를 명령 (아마도 제로).</target>
        </trans-unit>
        <trans-unit id="ffde14c1ea2e01417c3435708517261d052ddb1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; is the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched the &lt;code&gt;condition&lt;/code&gt; when updates were suppressed by a &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger. If &lt;code&gt;count&lt;/code&gt; is 0, no rows were updated by the query (this is not considered an error).</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 그 값을 변경하지 않은 유사한 행을 포함하여 갱신 된 행의 수이다. &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 트리거에 의해 업데이트가 억제 될 때이 수 는 &lt;code&gt;condition&lt;/code&gt; 과 일치하는 행 수보다 적을 수 있습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 0, 행이 (이 오류로 간주되지 않음) 쿼리에 의해 업데이트되지 않았다.</target>
        </trans-unit>
        <trans-unit id="1bd1175f717b500daf5cf94e2ae95b1e5dd562f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is declared to return &lt;code&gt;setof record&lt;/code&gt;, so the actual names and types of the output columns must be defined in the &lt;code&gt;FROM&lt;/code&gt; clause of the calling &lt;code&gt;SELECT&lt;/code&gt; statement, for example:</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 기능은 복귀 선언 &lt;code&gt;setof record&lt;/code&gt; 출력 컬럼의 실제 이름과 유형이 정의해야합니다, 그래서 &lt;code&gt;FROM&lt;/code&gt; 호출 절 &lt;code&gt;SELECT&lt;/code&gt; 예를 들어, 문 :</target>
        </trans-unit>
        <trans-unit id="d8aadf50544262136fa7d8c76d5edc945fb11396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function is used to produce &amp;ldquo;pivot&amp;rdquo; displays, wherein data is listed across the page rather than down. For example, we might have data like</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수는 데이터 페이지보다 아래에 나열되는 것을 특징으로하는 &quot;피봇&quot;디스플레이를 생산하는데 사용된다. 예를 들어 다음과 같은 데이터가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc99faab5d994fa37274aca83e33cbe8ab82de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. It fills the output &lt;code&gt;value&lt;/code&gt; columns, left to right, with the &lt;code&gt;value&lt;/code&gt; fields from these rows. If there are fewer rows in a group than there are output &lt;code&gt;value&lt;/code&gt; columns, the extra output columns are filled with nulls; if there are more rows, the extra input rows are skipped.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수와 같은 입력 행들 각각 연속 그룹에 대해 하나의 열 출력을 생성 &lt;code&gt;row_name&lt;/code&gt; 값. 이 행 의 &lt;code&gt;value&lt;/code&gt; 필드로 왼쪽에서 오른쪽으로 출력 &lt;code&gt;value&lt;/code&gt; 열을 채 웁니다 . 그룹에 출력 &lt;code&gt;value&lt;/code&gt; 열 보다 적은 수의 행이 있으면 추가 출력 열은 널로 채워집니다. 더 많은 행이 있으면 추가 입력 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fc54c6a3ee9f1815fead23a991ca1a3cbc31deef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function produces one output row for each consecutive group of input rows with the same &lt;code&gt;row_name&lt;/code&gt; value. The output &lt;code&gt;row_name&lt;/code&gt; column, plus any &amp;ldquo;extra&amp;rdquo; columns, are copied from the first row of the group. The output &lt;code&gt;value&lt;/code&gt; columns are filled with the &lt;code&gt;value&lt;/code&gt; fields from rows having matching &lt;code&gt;category&lt;/code&gt; values. If a row's &lt;code&gt;category&lt;/code&gt; does not match any output of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query, its &lt;code&gt;value&lt;/code&gt; is ignored. Output columns whose matching category is not present in any input row of the group are filled with nulls.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수와 같은 입력 행들 각각 연속 그룹에 대해 하나의 열 출력을 생성 &lt;code&gt;row_name&lt;/code&gt; 값. 출력 &lt;code&gt;row_name&lt;/code&gt; 열과 &quot;추가&quot;열이 그룹의 첫 번째 행에서 복사됩니다. 출력 &lt;code&gt;value&lt;/code&gt; 열은 &lt;code&gt;category&lt;/code&gt; 값 이 일치하는 행 의 &lt;code&gt;value&lt;/code&gt; 필드 로 채워집니다 . 행의 &lt;code&gt;category&lt;/code&gt; 가 &lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt; 쿼리의 출력과 일치하지 않으면 해당 &lt;code&gt;value&lt;/code&gt; 이 무시됩니다. 그룹의 입력 행에 일치하는 카테고리가없는 출력 열은 널로 채워집니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d30aa2f376a61f86fd4ea02ce6152e230c73fa37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstab&lt;/code&gt; function takes a text parameter that is a SQL query producing raw data formatted in the first way, and produces a table formatted in the second way.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 함수는 두 번째 방법으로 포맷 테이블을 제 방식으로 포맷 된 원시 데이터를 생성하는 SQL 쿼리되는 텍스트 매개 변수를 사용하고 생성한다.</target>
        </trans-unit>
        <trans-unit id="cf52a8ddea78696a7f9befff4ffbcb20d2c48c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crosstabN&lt;/code&gt; functions are examples of how to set up custom wrappers for the general &lt;code&gt;crosstab&lt;/code&gt; function, so that you need not write out column names and types in the calling &lt;code&gt;SELECT&lt;/code&gt; query. The &lt;code&gt;tablefunc&lt;/code&gt; module includes &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt;, whose output row types are defined as</source>
          <target state="translated">&lt;code&gt;crosstabN&lt;/code&gt; 의 기능은 일반 사용자 정의 래퍼를 설정하는 방법의 예입니다 &lt;code&gt;crosstab&lt;/code&gt; 이 호출에 열 이름과 유형을 쓸 필요가 그래서, 기능 &lt;code&gt;SELECT&lt;/code&gt; 쿼리. &lt;code&gt;tablefunc&lt;/code&gt; 의 모듈을 포함 &lt;code&gt;crosstab2&lt;/code&gt; , &lt;code&gt;crosstab3&lt;/code&gt; 및 &lt;code&gt;crosstab4&lt;/code&gt; 출력이 행의 형식으로 정의를</target>
        </trans-unit>
        <trans-unit id="54ac58ac577c46bd040592fa91e1a077c06d943c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cube&lt;/code&gt; module also provides a GiST index operator class for &lt;code&gt;cube&lt;/code&gt; values. A &lt;code&gt;cube&lt;/code&gt; GiST index can be used to search for values using the &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;@&lt;/code&gt; operators in &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;cube&lt;/code&gt; 모듈은 요지를위한 지수 연산자 클래스 제공 &lt;code&gt;cube&lt;/code&gt; 값. &lt;code&gt;cube&lt;/code&gt; 요지 인덱스 값을 이용하여 검색 할 수 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;@&lt;/code&gt; 운영자에 &lt;code&gt;WHERE&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="f843170ee2f9efd669c186bf546d0e5dd7a1284a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date_part&lt;/code&gt; function is modeled on the traditional Ingres equivalent to the SQL-standard function &lt;code&gt;extract&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;date_part&lt;/code&gt; 의 기능은 SQL 표준 기능으로 기존의 앵그르 해당하는 모델로되어 &lt;code&gt;extract&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c29b4371698f7a456bc5cd073d69c9abf2e592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;earthdistance&lt;/code&gt; module provides two different approaches to calculating great circle distances on the surface of the Earth. The one described first depends on the &lt;code&gt;cube&lt;/code&gt; module (which &lt;em&gt;must&lt;/em&gt; be installed before &lt;code&gt;earthdistance&lt;/code&gt; can be installed). The second one is based on the built-in &lt;code&gt;point&lt;/code&gt; data type, using longitude and latitude for the coordinates.</source>
          <target state="translated">&lt;code&gt;earthdistance&lt;/code&gt; 의 모듈은 지구 표면에 큰 원형의 거리를 계산하는 두 가지 방법을 제공합니다. 먼저 설명 된 것은 &lt;code&gt;cube&lt;/code&gt; 모듈 ( &lt;code&gt;earthdistance&lt;/code&gt; 설치하기 전에 설치 &lt;em&gt;해야&lt;/em&gt; 함) 에 따라 다릅니다 . 두 번째 는 좌표에 경도와 위도를 사용하여 내장 &lt;code&gt;point&lt;/code&gt; 데이터 유형을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="a7890123059537fdc57582740cd61da006402b74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expression&lt;/code&gt; argument of an &lt;code&gt;\if&lt;/code&gt; or &lt;code&gt;\elif&lt;/code&gt; command is subject to variable interpolation and backquote expansion, just like any other backslash command argument. After that it is evaluated like the value of an on/off option variable. So a valid value is any unambiguous case-insensitive match for one of: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;. For example, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;tR&lt;/code&gt; will all be considered to be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt; 또는 &lt;code&gt;\elif&lt;/code&gt; 명령 의 &lt;code&gt;expression&lt;/code&gt; 인수는 다른 백 슬래시 명령 인수와 마찬가지로 변수 보간 및 역 따옴표 확장의 영향을받습니다. 그 후에는 설정 / 해제 옵션 변수의 값처럼 평가됩니다. 따라서 유효한 값은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;no&lt;/code&gt; 중 하나에 대한 대소 문자를 구분하지 않는 일치입니다 . 예를 들어, &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;tR&lt;/code&gt; 은 모두 &lt;code&gt;true&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="7490327a2b864afa9b5748785adec8119b5d2704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function is primarily intended for computational processing. For formatting date/time values for display, see &lt;a href=&quot;functions-formatting&quot;&gt;Section 9.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 기능은 주로 연산 처리를위한 것이다. 표시 할 날짜 / 시간 값의 형식 &lt;a href=&quot;functions-formatting&quot;&gt;은 9.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a9a9ab120adc12bc2db1bb30c3120ad00c0facd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function retrieves subfields such as year or hour from date/time values. &lt;code&gt;source&lt;/code&gt; must be a value expression of type &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, or &lt;code&gt;interval&lt;/code&gt;. (Expressions of type &lt;code&gt;date&lt;/code&gt; are cast to &lt;code&gt;timestamp&lt;/code&gt; and can therefore be used as well.) &lt;code&gt;field&lt;/code&gt; is an identifier or string that selects what field to extract from the source value. The &lt;code&gt;extract&lt;/code&gt; function returns values of type &lt;code&gt;double precision&lt;/code&gt;. The following are valid field names:</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 등의 날짜 / 시간 값에서 년 또는 시간 등의 기능을 검색하여 서브 필드. &lt;code&gt;source&lt;/code&gt; 는 &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; 또는 &lt;code&gt;interval&lt;/code&gt; 유형의 값 표현식이어야합니다 . &lt;code&gt;date&lt;/code&gt; 유형의 표현은 &lt;code&gt;timestamp&lt;/code&gt; 로 캐스트 되므로 사용할 수도 있습니다. &lt;code&gt;field&lt;/code&gt; 는 소스 값에서 추출 할 필드를 선택하는 식별자 또는 문자열입니다. &lt;code&gt;extract&lt;/code&gt; 기능은 유형의 값 반환 &lt;code&gt;double precision&lt;/code&gt; . 유효한 필드 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1a437c414eaca06c0d45719567f040e8a9a62f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;file_fdw&lt;/code&gt;, which can be used to access data files in the server's file system, or to execute programs on the server and read their output. The data file or program output must be in a format that can be read by &lt;code&gt;COPY FROM&lt;/code&gt;; see &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; for details. Access to data files is currently read-only.</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 의 모듈은 래퍼 외국 데이터 제공 &lt;code&gt;file_fdw&lt;/code&gt; 서버의 파일 시스템에 데이터 파일에 액세스하는 데 사용할 수 있습니다, 또는 서버에 프로그램을 실행하고 자신의 출력을 읽어. 데이터 파일 또는 프로그램 출력은 &lt;code&gt;COPY FROM&lt;/code&gt; 에서 읽을 수있는 형식이어야합니다 . 자세한 내용은 &lt;a href=&quot;sql-copy&quot;&gt;복사&lt;/a&gt; 를 참조하십시오. 데이터 파일에 대한 액세스는 현재 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="dc48dad184d44a7c4859e34f48c4985dbe248e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_clause&lt;/code&gt; specifies the set of rows constituting the &lt;em&gt;window frame&lt;/em&gt;, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode; in each case, it runs from the &lt;code&gt;frame_start&lt;/code&gt; to the &lt;code&gt;frame_end&lt;/code&gt;. If &lt;code&gt;frame_end&lt;/code&gt; is omitted, the end defaults to &lt;code&gt;CURRENT ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame_clause&lt;/code&gt; 는 구성하는 일련의 행을 지정 &lt;em&gt;창틀&lt;/em&gt; 해당 윈도우 함수의 경우, 현재의 파티션들의 서브 세트이며, 대신, 전체 파티션의 프레임에 작용하여. 프레임의 행 세트는 현재 행인 행에 따라 달라질 수 있습니다. 프레임은 &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 모드 에서 지정할 수 있습니다 . 각각의 경우에 &lt;code&gt;frame_start&lt;/code&gt; 에서 &lt;code&gt;frame_end&lt;/code&gt; 까지 실행됩니다 . 경우 &lt;code&gt;frame_end&lt;/code&gt; 생략되고, 최종 기본적으로 &lt;code&gt;CURRENT ROW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71d31c525333bb24cffbf41e507f2b1076452ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame_exclusion&lt;/code&gt; option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; excludes the current row from the frame. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; excludes the current row and its ordering peers from the frame. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; excludes any peers of the current row from the frame, but not the current row itself. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; simply specifies explicitly the default behavior of not excluding the current row or its peers.</source>
          <target state="translated">&lt;code&gt;frame_exclusion&lt;/code&gt; 의 옵션은이 프레임 시작 및 프레임 끝 옵션에 따라 포함 할 경우에도, 현재 행 주위 행이 프레임에서 제외 할 수 있습니다. &lt;code&gt;EXCLUDE CURRENT ROW&lt;/code&gt; 는 프레임에서 현재 행을 제외합니다. &lt;code&gt;EXCLUDE GROUP&lt;/code&gt; 은 현재 행과 순서 피어를 프레임에서 제외합니다. &lt;code&gt;EXCLUDE TIES&lt;/code&gt; 는 현재 행의 모든 ​​피어를 프레임에서 제외하지만 현재 행 자체는 제외하지 않습니다. &lt;code&gt;EXCLUDE NO OTHERS&lt;/code&gt; 는 단순히 현재 행이나 해당 피어를 제외하지 않는 기본 동작을 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="79c90a36b51a75ac7dbb48737a2d7af10a18b852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function_name&lt;/code&gt; function must have been previously defined using &lt;code&gt;CREATE FUNCTION&lt;/code&gt; and must be defined to accept the correct number of arguments (either one or two) of the indicated types.</source>
          <target state="translated">&lt;code&gt;function_name&lt;/code&gt; 기능은 이전에 사용하여 정의되어 있어야 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 하고 올바른 수의 인수 지정된 유형의 (하나 또는 두 개)을 허용하도록 정의되어야한다.</target>
        </trans-unit>
        <trans-unit id="9897a44892259c96709c3ce90278ea27b2732f53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides several functions to determine similarities and distance between strings.</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; 의 모듈은 문자열 사이의 유사점과 거리를 결정하는 여러 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90731181621f8d5d3209f6554f81fdd98c3fb7ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fuzzystrmatch&lt;/code&gt; module provides two functions for working with Soundex codes:</source>
          <target state="translated">&lt;code&gt;fuzzystrmatch&lt;/code&gt; 의 모듈은 Soundex와 코드 작업을위한 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="a076afe3d48bfb5bc5090c4b36aa5c47d792bbb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hstore&lt;/code&gt; type, because of its intrinsic liberality, could contain a lot of different keys. Checking for valid keys is the task of the application. The following examples demonstrate several techniques for checking keys and obtaining statistics.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 의 유형은, 때문에 고유의 관대함의 다른 키를 많이 포함 할 수 있습니다. 유효한 키를 확인하는 것은 응용 프로그램의 작업입니다. 다음 예는 키를 확인하고 통계를 얻는 몇 가지 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aa50c73dc35b9d5466c5f124d66eb983ecec8b30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;idx_tup_read&lt;/code&gt; and &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts can be different even without any use of bitmap scans, because &lt;code&gt;idx_tup_read&lt;/code&gt; counts index entries retrieved from the index while &lt;code&gt;idx_tup_fetch&lt;/code&gt; counts live rows fetched from the table. The latter will be less if any dead or not-yet-committed rows are fetched using the index, or if any heap fetches are avoided by means of an index-only scan.</source>
          <target state="translated">&lt;code&gt;idx_tup_read&lt;/code&gt; 의 값 과 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 때문에 카운트, 심지어 비트 맵 스캔의 사용없이 다를 수 있습니다 &lt;code&gt;idx_tup_read&lt;/code&gt; 의 값 카운트 인덱스 항목이 인덱스 동안에서 검색 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 의 카운트 라이브 행이 테이블에서 가져온. 인덱스를 사용하여 데드 또는 아직 커밋되지 않은 행을 페치하거나 인덱스 전용 스캔을 통해 힙 페치를 피하는 경우 후자는 더 적습니다.</target>
        </trans-unit>
        <trans-unit id="105555b766284240eda53764bbf412df3e426218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inet&lt;/code&gt; type holds an IPv4 or IPv6 host address, and optionally its subnet, all in one field. The subnet is represented by the number of network address bits present in the host address (the &amp;ldquo;netmask&amp;rdquo;). If the netmask is 32 and the address is IPv4, then the value does not indicate a subnet, only a single host. In IPv6, the address length is 128 bits, so 128 bits specify a unique host address. Note that if you want to accept only networks, you should use the &lt;code&gt;cidr&lt;/code&gt; type rather than &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; 형태는 하나 개의 필드에 임의의 서브넷 모두는 IPv4 또는 IPv6 호스트 주소를 보유하고 있으며. 서브넷은 호스트 주소 (&amp;ldquo;넷 마스크&amp;rdquo;)에있는 네트워크 주소 비트 수로 표시됩니다. 넷 마스크가 32이고 주소가 IPv4 인 경우 값은 서브넷을 나타내지 않고 단일 호스트 만 나타냅니다. IPv6에서 주소 길이는 128 비트이므로 128 비트는 고유 한 호스트 주소를 지정합니다. 네트워크 만 허용하려면 &lt;code&gt;inet&lt;/code&gt; 대신 &lt;code&gt;cidr&lt;/code&gt; 유형을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1480b7e9f9737ecb46229fdd00be59d12607dc11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;initdb&lt;/code&gt; mode creates a new PostgreSQL database cluster, that is, a collection of databases that will be managed by a single server instance. This mode invokes the &lt;code&gt;initdb&lt;/code&gt; command. See &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;initdb&lt;/code&gt; 에 모드는 새로운 PostgreSQL 데이터베이스 클러스터, 단일 서버 인스턴스가 관리 할 데이터베이스의 컬렉션을 만듭니다. 이 모드는 &lt;code&gt;initdb&lt;/code&gt; 명령을 호출합니다 . &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecc5e8a2b17fca84bdc393620a0520a109ffd200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initdb-options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;initdb-options&lt;/code&gt; 보통 그룹으로 통과되는 것을 보장하기 위해 단일 또는 쌍 따옴표로 묶어야한다.</target>
        </trans-unit>
        <trans-unit id="16d1ccc7e1029a4cfe055973c1a279885ae0a68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_function&lt;/code&gt; converts the type's external textual representation to the internal representation used by the operators and functions defined for the type. &lt;code&gt;output_function&lt;/code&gt; performs the reverse transformation. The input function can be declared as taking one argument of type &lt;code&gt;cstring&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;cstring&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is the input text as a C string, the second argument is the type's own OID (except for array types, which instead receive their element type's OID), and the third is the &lt;code&gt;typmod&lt;/code&gt; of the destination column, if known (-1 will be passed if not). The input function must return a value of the data type itself. Usually, an input function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain input functions, which might need to reject NULL inputs.) The output function must be declared as taking one argument of the new data type. The output function must return type &lt;code&gt;cstring&lt;/code&gt;. Output functions are not invoked for NULL values.</source>
          <target state="translated">&lt;code&gt;input_function&lt;/code&gt; 는 유형에 대해 정의 된 연산자와 함수가 사용하는 내부 표현 형식의 외부 텍스트 표현을 변환합니다. &lt;code&gt;output_function&lt;/code&gt; 은 역변환을 수행합니다. 입력 함수는 &lt;code&gt;cstring&lt;/code&gt; 유형의 인수 하나를 받거나 &lt;code&gt;cstring&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 유형의 인수를 세 개로 선언 할 수 있습니다 . 첫 번째 인수는 입력 문자열을 C 문자열로, 두 번째 인수는 유형의 자체 OID (배열 유형은 제외하고 대신 요소 유형의 OID를 수신함)이고 세 번째 인수는 &lt;code&gt;typmod&lt;/code&gt; 입니다.알려진 경우 대상 열의 이름입니다 (없는 경우 -1이 전달됨). 입력 함수는 데이터 유형 자체의 값을 리턴해야합니다. 일반적으로 입력 함수는 STRICT로 선언해야합니다. 그렇지 않은 경우 NULL 입력 값을 읽을 때 NULL 첫 번째 매개 변수와 함께 호출됩니다. 이 경우 오류가 발생하지 않는 한 함수는 여전히 NULL을 반환해야합니다. (이 경우는 주로 도메인 입력 함수를 지원하기위한 것으로 NULL 입력을 거부해야 할 수도 있습니다.) 출력 함수는 새 데이터 유형의 인수 하나를 취하는 것으로 선언해야합니다. 출력 함수는 &lt;code&gt;cstring&lt;/code&gt; 유형을 리턴해야합니다 . NULL 값에 대해서는 출력 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dd3f06b986fa431b874d54dd865659b27cfc58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intagg&lt;/code&gt; module provides an integer aggregator and an enumerator. &lt;code&gt;intagg&lt;/code&gt; is now obsolete, because there are built-in functions that provide a superset of its capabilities. However, the module is still provided as a compatibility wrapper around the built-in functions.</source>
          <target state="translated">&lt;code&gt;intagg&lt;/code&gt; 의 모듈은 정수 애그리 게이터 (aggregator) 및 열거를 제공한다. 기능의 상위 세트를 제공하는 내장 함수가 있기 때문에 &lt;code&gt;intagg&lt;/code&gt; 는 이제 더 이상 사용되지 않습니다. 그러나이 모듈은 여전히 ​​내장 함수 주위의 호환성 래퍼로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f078a6fe0cf9ef6c6e521625243e1894589ca0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intarray&lt;/code&gt; module provides a number of useful functions and operators for manipulating null-free arrays of integers. There is also support for indexed searches using some of the operators.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; 모듈은 정수의 널 (null)이없는 배열을 조작하기위한 유용한 함수와 연산자를 제공합니다. 일부 연산자를 사용하여 인덱스 검색을 지원하기도합니다.</target>
        </trans-unit>
        <trans-unit id="5e20537f440b22c9608c2d38b191b83f09961384" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; pseudo-type is used to declare functions that are meant only to be called internally by the database system, and not by direct invocation in an SQL query. If a function has at least one &lt;code&gt;internal&lt;/code&gt;-type argument then it cannot be called from SQL. To preserve the type safety of this restriction it is important to follow this coding rule: do not create any function that is declared to return &lt;code&gt;internal&lt;/code&gt; unless it has at least one &lt;code&gt;internal&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 의사 유형은 SQL 쿼리에서 직접 호출하여 데이터베이스 시스템에 의해 내부적으로 호출 할 경우에만 의미 기능 및하지를 선언하는 데 사용됩니다. 함수에 하나 이상의 &lt;code&gt;internal&lt;/code&gt; 유형 인수 가 있으면 SQL에서 호출 할 수 없습니다. 이 제한의 형식 안전성을 유지하려면이 코딩 규칙을 따르는 것이 중요합니다 . &lt;code&gt;internal&lt;/code&gt; 인수가 하나 이상없는 경우 &lt;code&gt;internal&lt;/code&gt; 를 반환하도록 선언 된 함수를 만들지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="23ef30a7477168386c4be2c94609fc89528b3dee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interval&lt;/code&gt; type has an additional option, which is to restrict the set of stored fields by writing one of these phrases:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 유형은 다음 문구 중 하나를 작성하여 저장된 필드의 집합을 제한 할 수있는 추가 옵션을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1ae9c44664a456573cddd9031643c02edb22183c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides data types for the following international product numbering standards: EAN13, UPC, ISBN (books), ISMN (music), and ISSN (serials). Numbers are validated on input according to a hard-coded list of prefixes; this list of prefixes is also used to hyphenate numbers on output. Since new prefixes are assigned from time to time, the list of prefixes may be out of date. It is hoped that a future version of this module will obtained the prefix list from one or more tables that can be easily updated by users as needed; however, at present, the list can only be updated by modifying the source code and recompiling. Alternatively, prefix validation and hyphenation support may be dropped from a future version of this module.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; EAN13, UPC, ISBN (서적), ISMN (음악) 및 ISSN (시리얼) : 모듈은 다음과 같은 국제 제품 번호 표준 데이터 유형을 제공합니다. 하드 코딩 된 접두사 목록에 따라 입력시 숫자의 유효성이 검사됩니다. 이 접두사 목록은 출력에서 ​​숫자에 하이픈을 넣는 데에도 사용됩니다. 새 접두사가 때때로 할당되기 때문에 접두사 목록이 오래되었을 수 있습니다. 이 모듈의 향후 버전은 필요에 따라 사용자가 쉽게 업데이트 할 수있는 하나 이상의 테이블에서 접두사 목록을 가져 오기를 희망합니다. 그러나 현재 소스 코드를 수정하고 다시 컴파일해야만 목록을 업데이트 할 수 있습니다. 또는이 모듈의 향후 버전에서 접두사 유효성 검사 및 하이픈 지원이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9815d1f84bba26cf75ea57db75cbb748c781beb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the following pairs of type casts:</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; 모듈 형 캐스트의 다음 쌍을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="1f3d136969e19c7266e1a9a82b8a9977ef2ab272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isn&lt;/code&gt; module provides the standard comparison operators, plus B-tree and hash indexing support for all these data types. In addition there are several specialized functions; shown in &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;Table F.12&lt;/a&gt;. In this table, &lt;code&gt;isn&lt;/code&gt; means any one of the module's data types.</source>
          <target state="translated">&lt;code&gt;isn&lt;/code&gt; 모듈은 표준 비교 연산자를 제공, 플러스 B-트리 및 모든 데이터 유형에 대한 해시 색인을 지원합니다. 또한 몇 가지 특수 기능이 있습니다. &lt;a href=&quot;isn#ISN-FUNCTIONS&quot;&gt;표 F.12&lt;/a&gt; 에 나와있다 . 이 표에서, &lt;code&gt;isn&lt;/code&gt; 모듈의 데이터 형식의 수단 중 어느 하나.</target>
        </trans-unit>
        <trans-unit id="ea0300aa881bba7f19acdd017cb9ddd3ccdf7dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; data types accept &lt;em&gt;almost&lt;/em&gt; identical sets of values as input. The major practical difference is one of efficiency. The &lt;code&gt;json&lt;/code&gt; data type stores an exact copy of the input text, which processing functions must reparse on each execution; while &lt;code&gt;jsonb&lt;/code&gt; data is stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. &lt;code&gt;jsonb&lt;/code&gt; also supports indexing, which can be a significant advantage.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;jsonb&lt;/code&gt; 데이터 타입을 수락 &lt;em&gt;거의&lt;/em&gt; 입력으로서 동일한 값을 설정. 주요한 실질적인 차이점은 효율성 중 하나입니다. &lt;code&gt;json&lt;/code&gt; 데이터 유형을 저장 처리 기능을 각각 실행한다 재분석에 입력 된 텍스트의 정확한 사본; 반면 &lt;code&gt;jsonb&lt;/code&gt; 데이터는 어떠한 파싱이 필요하지 않기 때문에, 오버 헤드로 인해 추가 전환 약간 느린 입력을 만들지 만, 훨씬 빠르게 분해 공정에 이진 포맷으로 저장된다. &lt;code&gt;jsonb&lt;/code&gt; 는 인덱싱도 지원하므로 상당한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18a0defa6788cb12c053fbf70d6cdb3c5a6ee90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json_typeof&lt;/code&gt; function's &lt;code&gt;null&lt;/code&gt; return value should not be confused with a SQL NULL. While calling &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;, calling &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; will return a SQL NULL.</source>
          <target state="translated">&lt;code&gt;json_typeof&lt;/code&gt; 의 함수의 &lt;code&gt;null&lt;/code&gt; 반환 값이 SQL NULL의와 혼동해서는 안됩니다. 호출하는 동안 &lt;code&gt;json_typeof('null'::json)&lt;/code&gt; 반환 &lt;code&gt;null&lt;/code&gt; 호출 &lt;code&gt;json_typeof(NULL::json)&lt;/code&gt; 하여 SQL NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="168cc05ce6845d58616f3f7646b54fd243f5124d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonb_path_exists&lt;/code&gt;, &lt;code&gt;jsonb_path_match&lt;/code&gt;, &lt;code&gt;jsonb_path_query&lt;/code&gt;, &lt;code&gt;jsonb_path_query_array&lt;/code&gt;, and &lt;code&gt;jsonb_path_query_first&lt;/code&gt; functions have optional &lt;code&gt;vars&lt;/code&gt; and &lt;code&gt;silent&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;jsonb_path_exists&lt;/code&gt; , &lt;code&gt;jsonb_path_match&lt;/code&gt; , &lt;code&gt;jsonb_path_query&lt;/code&gt; , &lt;code&gt;jsonb_path_query_array&lt;/code&gt; 및 &lt;code&gt;jsonb_path_query_first&lt;/code&gt; 기능은 선택이 &lt;code&gt;vars&lt;/code&gt; 와 &lt;code&gt;silent&lt;/code&gt; 인수를.</target>
        </trans-unit>
        <trans-unit id="772704f4d66d5faa09292e5f927a415dbd1364fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsonpath&lt;/code&gt; type implements support for the SQL/JSON path language in PostgreSQL to efficiently query JSON data. It provides a binary representation of the parsed SQL/JSON path expression that specifies the items to be retrieved by the path engine from the JSON data for further processing with the SQL/JSON query functions.</source>
          <target state="translated">&lt;code&gt;jsonpath&lt;/code&gt; 의 유형 구현을 효율적으로 쿼리 JSON 데이터에 PostgreSQL을에 SQL / JSON 경로 언어에 대한 지원합니다. SQL / JSON 쿼리 함수로 추가 처리 할 수 ​​있도록 JSON 데이터에서 경로 엔진이 검색 할 항목을 지정하는 구문 분석 된 SQL / JSON 경로 표현식의 2 진 표현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2149f5c0dd4945e41bb0756947056ef98b639170" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like_type&lt;/code&gt; parameter provides an alternative method for specifying the basic representation properties of a data type: copy them from some existing type. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from the named type. (It is possible, though usually undesirable, to override some of these values by specifying them along with the &lt;code&gt;LIKE&lt;/code&gt; clause.) Specifying representation this way is especially useful when the low-level implementation of the new type &amp;ldquo;piggybacks&amp;rdquo; on an existing type in some fashion.</source>
          <target state="translated">&lt;code&gt;like_type&lt;/code&gt; 의 파라미터는 데이터 유형의 기본 표현 속성을 지정하기위한 다른 방법을 제공한다 : 기존의 일부 유형에서 복사. &lt;code&gt;internallength&lt;/code&gt; , &lt;code&gt;passedbyvalue&lt;/code&gt; , &lt;code&gt;alignment&lt;/code&gt; 및 &lt;code&gt;storage&lt;/code&gt; 의 값은 명명 된 유형에서 복사됩니다. (일반적으로 바람직하지는 않지만 &lt;code&gt;LIKE&lt;/code&gt; 절 과 함께 이들 값을 지정하여 이러한 값 중 일부를 대체 할 수 있습니다 .)이 방법으로 표현을 지정하면 기존 유형에서 새 유형 &quot;피기 백&quot;의 저수준 구현이 특히 유용합니다. 어떤 패션.</target>
        </trans-unit>
        <trans-unit id="9d22eb5dee38146c30421a70885a4db31297786e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module allows fixing this by attaching a trigger to tables that contain LO reference columns. The trigger essentially just does a &lt;code&gt;lo_unlink&lt;/code&gt; whenever you delete or modify a value referencing a large object. When you use this trigger, you are assuming that there is only one database reference to any large object that is referenced in a trigger-controlled column!</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 모듈 LO 기준 열을 포함하는 테이블에 트리거를 부착하여 고정 할 수 있습니다. 트리거는 기본적 으로 큰 객체를 참조하는 값을 삭제하거나 수정할 때마다 &lt;code&gt;lo_unlink&lt;/code&gt; 를 수행 합니다. 이 트리거를 사용하면 트리거 제어 컬럼에서 참조되는 대형 오브젝트에 대한 데이터베이스 참조가 하나만 있다고 가정합니다!</target>
        </trans-unit>
        <trans-unit id="41e1b86fc89c1b3ca96870ada2d42cd830ee60fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; module provides support for managing Large Objects (also called LOs or BLOBs). This includes a data type &lt;code&gt;lo&lt;/code&gt; and a trigger &lt;code&gt;lo_manage&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 모듈 (또한 LO를 나에 BLOB라고도 함) 대형 오브젝트 관리를위한 지원을 제공합니다. 여기에는 데이터 유형 &lt;code&gt;lo&lt;/code&gt; 및 트리거 &lt;code&gt;lo_manage&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1213fb426cb2334040aa09e1426c55587c855d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no lower bound. Likewise, &lt;code&gt;upper-bound&lt;/code&gt; may be either a string that is valid input for the subtype, or empty to indicate no upper bound.</source>
          <target state="translated">&lt;code&gt;lower-bound&lt;/code&gt; 하위 유형에 대한 유효한 입력입니다 중 문자열, 또는 더 하한 나타 내기 위해 비울 수 있습니다. 마찬가지로 &lt;code&gt;upper-bound&lt;/code&gt; 은 부속 유형에 유효한 입력 문자열이거나 상한이 없음을 표시하기 위해 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4962a0009307ba6431284c97bb49876d7ddc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt; functions return null if the range is empty or the requested bound is infinite. The &lt;code&gt;lower_inc&lt;/code&gt;, &lt;code&gt;upper_inc&lt;/code&gt;, &lt;code&gt;lower_inf&lt;/code&gt;, and &lt;code&gt;upper_inf&lt;/code&gt; functions all return false for an empty range.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; 및 &lt;code&gt;upper&lt;/code&gt; 범위는 비어 있거나 결합 요청이 무한인지 기능 NULL을 반환. &lt;code&gt;lower_inc&lt;/code&gt; , &lt;code&gt;upper_inc&lt;/code&gt; , &lt;code&gt;lower_inf&lt;/code&gt; 및 &lt;code&gt;upper_inf&lt;/code&gt; 빈 범위의 기능을 모두 반환 거짓.</target>
        </trans-unit>
        <trans-unit id="7854ce56999a9ecbf4528c8d9ad238714a056945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ltree&lt;/code&gt; module provides several data types:</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 모듈은 여러 가지 데이터 유형을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4f5d05ac37c953266fc286bdc00b9352cf6192f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; 의 유형은 표준 관계 연산자 (지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , 등) 주문을 위해, 그리고 비트 산술 연산자 ( &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; AND 및 OR, NOT를 들어).</target>
        </trans-unit>
        <trans-unit id="ee970738f8a83aad38467525f7f37d7c159f8d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr8&lt;/code&gt; type stores MAC addresses in EUI-64 format, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). This type can accept both 6 and 8 byte length MAC addresses and stores them in 8 byte length format. MAC addresses given in 6 byte format will be stored in 8 byte length format with the 4th and 5th bytes set to FF and FE, respectively. Note that IPv6 uses a modified EUI-64 format where the 7th bit should be set to one after the conversion from EUI-48. The function &lt;code&gt;macaddr8_set7bit&lt;/code&gt; is provided to make this change. Generally speaking, any input which is comprised of pairs of hex digits (on byte boundaries), optionally separated consistently by one of &lt;code&gt;':'&lt;/code&gt;, &lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'.'&lt;/code&gt;, is accepted. The number of hex digits must be either 16 (8 bytes) or 12 (6 bytes). Leading and trailing whitespace is ignored. The following are examples of input formats that are accepted:</source>
          <target state="translated">&lt;code&gt;macaddr8&lt;/code&gt; 의 이더넷 카드 하드웨어 주소에서 예컨대 EUI-64 공지 된 형식으로 저장 타입 MAC 주소 (MAC 주소가 아니라 다른 목적을 위해 사용 되기는하지만). 이 유형은 6 및 8 바이트 길이의 MAC 주소를 모두 수용하여 8 바이트 길이 형식으로 저장할 수 있습니다. 6 바이트 형식으로 제공된 MAC 주소는 각각 4 번째 및 5 번째 바이트가 FF 및 FE로 설정된 8 바이트 길이 형식으로 저장됩니다. IPv6은 수정 된 EUI-64 형식을 사용하며 EUI-48에서 변환 한 후 7 번째 비트를 1로 설정해야합니다. &lt;code&gt;macaddr8_set7bit&lt;/code&gt; 기능 이이 변경을 위해 제공됩니다. 일반적으로 말하자면 16 진 숫자 쌍 (바이트 경계)으로 구성되며 선택적으로 &lt;code&gt;':'&lt;/code&gt; , &lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'.'&lt;/code&gt; 허용됩니다. 16 진 숫자의 수는 16 (8 바이트) 또는 12 (6 바이트) 여야합니다. 선행 및 후행 공백은 무시됩니다. 다음은 허용되는 입력 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c3d79930eaf5f7ce13b46f6856c277aea9ede8da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type also supports the standard relational operators (&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.) for lexicographical ordering, and the bitwise arithmetic operators (&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) for NOT, AND and OR.</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; 유형은 표준 관계 연산자 (지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 사전 편찬 순서에 대한, 등), 그리고 비트 산술 연산자 ( &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; )하지 않는, AND 및 OR.</target>
        </trans-unit>
        <trans-unit id="6ebc662e3381183673c8582b7b95fb9aee6ddcc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macaddr&lt;/code&gt; type stores MAC addresses, known for example from Ethernet card hardware addresses (although MAC addresses are used for other purposes as well). Input is accepted in the following formats:</source>
          <target state="translated">&lt;code&gt;macaddr&lt;/code&gt; 이더넷 카드 하드웨어 주소의 예를 들어 공지 된 유형의 저장 MAC 주소 (MAC 주소가 아니라 다른 목적을 위해 사용 되기는하지만). 입력은 다음 형식으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="abb88e6f4baf5008ffda8309a1c86c82f34be1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxlen&lt;/code&gt; parameter specifies the maximum number of digits allowed in an integer word. The default value is 6.</source>
          <target state="translated">&lt;code&gt;maxlen&lt;/code&gt; 파라미터는 정수 워드의 최대 자리수를 지정한다. 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="c0858eea09f10a0e5d0453c7f76531a7abbd443b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;md5&lt;/code&gt; method cannot be used with the &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace&lt;/a&gt; feature.</source>
          <target state="translated">&lt;code&gt;md5&lt;/code&gt; 방법은 사용할 수 없습니다 &lt;a href=&quot;runtime-config-connection#GUC-DB-USER-NAMESPACE&quot;&gt;db_user_namespace의&lt;/a&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b398ca59b1e24ecdf79b1f3151e58ecf006b28e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;avg()&lt;/code&gt; aggregates are computed concurrently over all the input rows, so if any row has &lt;code&gt;employees&lt;/code&gt; equal to zero, the division-by-zero error will occur before there is any opportunity to test the result of &lt;code&gt;min()&lt;/code&gt;. Instead, use a &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;FILTER&lt;/code&gt; clause to prevent problematic input rows from reaching an aggregate function in the first place.</source>
          <target state="translated">&lt;code&gt;min()&lt;/code&gt; 와 &lt;code&gt;avg()&lt;/code&gt; 응집체는 임의의 행이 보유 그렇다면, 모든 입력 행 위에 동시에 계산 &lt;code&gt;employees&lt;/code&gt; 의 결과를 테스트하기 위해 모든 기회가 전에 0으로 나누기 오류가 발생 제로인 &lt;code&gt;min()&lt;/code&gt; . 대신 &lt;code&gt;WHERE&lt;/code&gt; 또는 &lt;code&gt;FILTER&lt;/code&gt; 절을 사용하여 문제가있는 입력 행이 처음에 집계 함수에 도달하지 못하게하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5889a0b42548324335d58d566964f3bd48031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;money&lt;/code&gt; type stores a currency amount with a fixed fractional precision; see &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;Table 8.3&lt;/a&gt;. The fractional precision is determined by the database's &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; setting. The range shown in the table assumes there are two fractional digits. Input is accepted in a variety of formats, including integer and floating-point literals, as well as typical currency formatting, such as &lt;code&gt;'$1,000.00'&lt;/code&gt;. Output is generally in the latter form but depends on the locale.</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; 유형은 고정 소수점 정밀도로 통화 금액을 저장; &lt;a href=&quot;datatype-money#DATATYPE-MONEY-TABLE&quot;&gt;표 8.3을&lt;/a&gt; 참조하십시오 . 분수 정밀도는 데이터베이스의 &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; 설정에 의해 결정됩니다 . 표에 표시된 범위는 두 개의 소수 자릿수가 있다고 가정합니다. 입력은 정수 및 부동 소수점 리터럴뿐만 아니라 &lt;code&gt;'$1,000.00'&lt;/code&gt; 과 같은 일반적인 통화 형식을 포함하여 다양한 형식으로 허용됩니다 . 출력은 일반적으로 후자의 형식이지만 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="591d71ee5e714d1d5bb09ebf8473fd24333cc869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type is currently implemented as an unsigned four-byte integer. Therefore, it is not large enough to provide database-wide uniqueness in large databases, or even in large individual tables.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 유형은 현재 부호없는 4 바이트 정수로 구현됩니다. 따라서 큰 데이터베이스 또는 큰 개별 테이블에서 데이터베이스 전체에 고유성을 제공 할만큼 크지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78dc4927f04eeaf9a8229a0fc622fc80f07cd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid&lt;/code&gt; type itself has few operations beyond comparison. It can be cast to integer, however, and then manipulated using the standard integer operators. (Beware of possible signed-versus-unsigned confusion if you do this.)</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; 유형 자체는 비교를 제외하고는 몇가지 연산을. 그러나 정수로 캐스트 한 다음 표준 정수 연산자를 사용하여 조작 할 수 있습니다. 이렇게하면 부호있는 대 부호없는 혼동에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="90126f847a19f26e444b96e74dbf5fc70037caf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open_&lt;/code&gt;* options also use &lt;code&gt;O_DIRECT&lt;/code&gt; if available. Not all of these choices are available on all platforms. The default is the first method in the above list that is supported by the platform, except that &lt;code&gt;fdatasync&lt;/code&gt; is the default on Linux. The default is not necessarily ideal; it might be necessary to change this setting or other aspects of your system configuration in order to create a crash-safe configuration or achieve optimal performance. These aspects are discussed in &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;open_&lt;/code&gt; 는 * 옵션도 사용 &lt;code&gt;O_DIRECT&lt;/code&gt; 를 사용할 수있는 경우. 모든 플랫폼에서 이러한 선택을 모두 사용할 수있는 것은 아닙니다. 기본값은 위의 목록에서 플랫폼이 지원하는 첫 번째 방법입니다 ( Linux에서 &lt;code&gt;fdatasync&lt;/code&gt; 가 기본값 임 ). 기본값이 반드시 이상적인 것은 아닙니다. 충돌 방지 구성을 만들거나 최적의 성능을 얻으려면이 설정 또는 시스템 구성의 다른 측면을 변경해야 할 수도 있습니다. 이러한 측면은 &lt;a href=&quot;wal-reliability&quot;&gt;29.1 절&lt;/a&gt; 에서 논의됩니다 . 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1deebe3b08e139dca519f072e65bc0913b196cc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; should usually be surrounded by single or double quotes to ensure that they are passed through as a group.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 보통 그룹으로 통과되는 것을 보장하기 위해 단일 또는 쌍 따옴표로 묶어야한다.</target>
        </trans-unit>
        <trans-unit id="e287f99758c3cdb10c1fc61789ee15a8d908a550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pageinspect&lt;/code&gt; module provides functions that allow you to inspect the contents of database pages at a low level, which is useful for debugging purposes. All of these functions may be used only by superusers.</source>
          <target state="translated">&lt;code&gt;pageinspect&lt;/code&gt; 의 모듈은 디버깅 목적에 유용 낮은 수준에서 데이터베이스 페이지의 내용을 검사 할 수있는 기능을 제공합니다. 이러한 모든 기능은 수퍼 유저 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530a467c47cea19dd0c00ec1dbc483debfa27dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partition_bound_spec&lt;/code&gt; must correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form with &lt;code&gt;IN&lt;/code&gt; is used for list partitioning, the form with &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;TO&lt;/code&gt; is used for range partitioning, and the form with &lt;code&gt;WITH&lt;/code&gt; is used for hash partitioning.</source>
          <target state="translated">&lt;code&gt;partition_bound_spec&lt;/code&gt; 은 상위 테이블의 분할 방법 및 분할 키에 대응하고, 중첩해야하지 그 부모 기존 파티션한다. 와 형상 &lt;code&gt;IN&lt;/code&gt; 은 함께리스트 파티셔닝 폼을 사용 &lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;TO&lt;/code&gt; 범위 분할 사용되어,와 형태 &lt;code&gt;WITH&lt;/code&gt; 은 해시 분할을 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="321cdf6012708ec28d857a16216ddd141b4795b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passwordcheck&lt;/code&gt; module checks users' passwords whenever they are set with &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. If a password is considered too weak, it will be rejected and the command will terminate with an error.</source>
          <target state="translated">&lt;code&gt;passwordcheck&lt;/code&gt; 의 그들이 설정 될 때마다 모듈 검사 사용자의 암호 &lt;a href=&quot;sql-createrole&quot;&gt;역할 CREATE&lt;/a&gt; 또는 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER 역할&lt;/a&gt; . 암호가 너무 약한 것으로 간주되면 암호가 거부되고 오류와 함께 명령이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86ab56758cab8beb34df6aa406664611103452cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;penalty&lt;/code&gt; function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup.</source>
          <target state="translated">&lt;code&gt;penalty&lt;/code&gt; 기능은 인덱스의 좋은 성능에 매우 중요하다. 삽입 시점에 트리에서 새 항목을 추가 할 위치를 선택할 때 따라야 할 분기를 결정하는 데 사용됩니다. 쿼리시 인덱스의 균형이 좋을수록 조회 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="eca57d9a0482509128492e1b7deb298ac5bcf1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e30cddb8256b97d7a85be6f99c4ef44cdaa252a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extension_versions&lt;/code&gt; view lists the specific extension versions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extension_versions&lt;/code&gt; 은 나열 설치에 사용할 수있는 특정 확장 버전을 볼 수 있습니다. 현재 설치된 확장을 보여주는 &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; 카탈로그 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e7d98e76ccc0a3eea34c953f9960047fdf4d011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5019d9408165c6f3daf9b540d710ea624fb4f2a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_available_extensions&lt;/code&gt; view lists the extensions that are available for installation. See also the &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt; catalog, which shows the extensions currently installed.</source>
          <target state="translated">&lt;code&gt;pg_available_extensions&lt;/code&gt; 은 나열 설치에 사용할 수있는 확장 기능을 볼 수 있습니다. 현재 설치된 확장을 보여주는 &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; 카탈로그 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23147896a0bb8cdf56e9c2215878569d76558769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_buffercache&lt;/code&gt; module provides a means for examining what's happening in the shared buffer cache in real time.</source>
          <target state="translated">&lt;code&gt;pg_buffercache&lt;/code&gt; 의 모듈은 실시간으로 공유 버퍼 캐시에 무슨 일이 일어나고 있는지 검사하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33f64b3a0516da571bdaabc8707c7cfc6382a6fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_constraint&lt;/code&gt; entry associated with the trigger, if any</source>
          <target state="translated">&lt;code&gt;pg_constraint&lt;/code&gt; 의 트리거와 관련된 항목 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="0a3b068150ce34aa7d8adbd51da299ff6a0e91b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view displays cursors created by any of these means. Cursors only exist for the duration of the transaction that defines them, unless they have been declared &lt;code&gt;WITH HOLD&lt;/code&gt;. Therefore non-holdable cursors are only present in the view until the end of their creating transaction.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 는 이러한 방법 중 하나에 의해 생성 된 디스플레이 커서를 볼. &lt;code&gt;WITH HOLD&lt;/code&gt; 로 선언되지 않은 경우 커서는 해당 트랜잭션을 정의하는 트랜잭션 기간 동안 만 존재합니다 . 따라서 보류 불가능한 커서는 트랜잭션 작성이 끝날 때까지만보기에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="769140bc4ff0be33d8261a2c2495473c9aa06419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="943080f1bca8bfb0a861af0a7366bc0f87ecea56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_cursors&lt;/code&gt; view lists the cursors that are currently available. Cursors can be defined in several ways:</source>
          <target state="translated">&lt;code&gt;pg_cursors&lt;/code&gt; 는 목록을 현재 사용할 수있는 커서를 볼 수 있습니다. 커서는 여러 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f9e99ef77cc93d164810339140c3e9aee6dc96a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_enum&lt;/code&gt; catalog contains entries showing the values and labels for each enum type. The internal representation of a given enum value is actually the OID of its associated row in &lt;code&gt;pg_enum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 의 카탈로그는 각 열거 형의 값 및 레이블을 보여주는 항목이 포함되어 있습니다. 주어진 열거 형 값의 내부 표현은 실제로 &lt;code&gt;pg_enum&lt;/code&gt; 에서 연관된 행의 OID입니다 .</target>
        </trans-unit>
        <trans-unit id="85db4109eb0a5caec74c9817c0a2aae5033501c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_freespacemap&lt;/code&gt; module provides a means for examining the free space map (FSM). It provides a function called &lt;code&gt;pg_freespace&lt;/code&gt;, or two overloaded functions, to be precise. The functions show the value recorded in the free space map for a given page, or for all pages in the relation.</source>
          <target state="translated">&lt;code&gt;pg_freespacemap&lt;/code&gt; 의 모듈은 여유 공간 맵 (FSM)을 검사하는 수단을 제공합니다. &lt;code&gt;pg_freespace&lt;/code&gt; 라는 함수 또는 두 개의 오버로드 된 함수를 정확하게 제공합니다. 함수는 주어진 페이지 또는 관계의 모든 페이지에 대한 여유 공간 맵에 기록 된 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d26269fc6d836fb10263bde9dc1a6bf13ade8034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_hba.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 파일은 기동시와 메인 서버 프로세스가 SIGHUP 신호를 수신에서 판독된다. 활성 시스템에서 파일을 편집하는 경우 파일을 &lt;code&gt;pg_ctl reload&lt;/code&gt; &lt;code&gt;pg_reload_conf()&lt;/code&gt; 도록 포스트 마스터에게 신호를 보내야합니다 ( pg_ctl reload 사용 , SQL 함수 pg_reload_conf () 호출 또는 &lt;code&gt;kill -HUP&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="04191b45aa50aed85c91e48e8294ab1b8975519d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ident.conf&lt;/code&gt; file is read on start-up and when the main server process receives a SIGHUP signal. If you edit the file on an active system, you will need to signal the postmaster (using &lt;code&gt;pg_ctl reload&lt;/code&gt;, calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, or using &lt;code&gt;kill -HUP&lt;/code&gt;) to make it re-read the file.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; 의 파일은 기동시와 메인 서버 프로세스가 SIGHUP 신호를 수신에서 판독된다. 활성 시스템에서 파일을 편집하는 경우 파일을 &lt;code&gt;pg_ctl reload&lt;/code&gt; &lt;code&gt;pg_reload_conf()&lt;/code&gt; 도록 포스트 마스터에게 신호를 보내야합니다 ( pg_ctl reload 사용 , SQL 함수 pg_reload_conf () 호출 또는 &lt;code&gt;kill -HUP&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="27acedebfd1c20546e890a5790d75026d8a69e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_locks&lt;/code&gt; view displays data from both the regular lock manager and the predicate lock manager, which are separate systems; in addition, the regular lock manager subdivides its locks into regular and &lt;em&gt;fast-path&lt;/em&gt; locks. This data is not guaranteed to be entirely consistent. When the view is queried, data on fast-path locks (with &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;) is gathered from each backend one at a time, without freezing the state of the entire lock manager, so it is possible for locks to be taken or released while information is gathered. Note, however, that these locks are known not to conflict with any other lock currently in place. After all backends have been queried for fast-path locks, the remainder of the regular lock manager is locked as a unit, and a consistent snapshot of all remaining locks is collected as an atomic action. After unlocking the regular lock manager, the predicate lock manager is similarly locked and all predicate locks are collected as an atomic action. Thus, with the exception of fast-path locks, each lock manager will deliver a consistent set of results, but as we do not lock both lock managers simultaneously, it is possible for locks to be taken or released after we interrogate the regular lock manager and before we interrogate the predicate lock manager.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 는 일반 잠금 관리자와 별도의 시스템이다 술어 잠금 관리자 모두에서 데이터를 표시를 볼 수; 또한 일반 잠금 관리자는 잠금을 일반 및 &lt;em&gt;빠른 경로&lt;/em&gt; 잠금 으로 세분화합니다 . 이 데이터는 완전히 일관성이 보장되지는 않습니다. 보기가 조회 될 때 빠른 경로 잠금의 데이터 ( &lt;code&gt;fastpath&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; ))는 전체 잠금 관리자의 상태를 정지시키지 않고 각 백엔드에서 한 번에 하나씩 수집되므로 정보를 수집하는 동안 잠금을 해제하거나 해제 할 수 있습니다. 그러나 이러한 잠금은 현재 사용중인 다른 잠금과 충돌하지 않는 것으로 알려져 있습니다. 빠른 경로 잠금에 대해 모든 백엔드를 쿼리 한 후, 일반 잠금 관리자의 나머지는 한 단위로 잠기고 나머지 모든 잠금의 일관된 스냅 샷은 원자 적 조치로 수집됩니다. 일반 잠금 관리자를 잠금 해제하면 술어 잠금 관리자가 유사하게 잠기고 모든 술어 잠금이 원자 적 조치로 수집됩니다. 따라서 빠른 경로 잠금을 제외하고 각 잠금 관리자는 일관된 결과 집합을 제공하지만 두 잠금 관리자를 동시에 잠그지 않으므로일반 잠금 관리자를 조사한 후 그리고 술어 잠금 관리자를 조사하기 전에 잠금을 수행하거나 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc09426bbd89792d56d781e38f0585623a0a6b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_lsn&lt;/code&gt; data type can be used to store LSN (Log Sequence Number) data which is a pointer to a location in the WAL. This type is a representation of &lt;code&gt;XLogRecPtr&lt;/code&gt; and an internal system type of PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pg_lsn&lt;/code&gt; 의 데이터 타입은 WAL의 위치에 대한 포인터 LSN (로그 시퀀스 번호)의 데이터를 저장하는데 사용될 수있다. 이 유형은 &lt;code&gt;XLogRecPtr&lt;/code&gt; 및 PostgreSQL의 내부 시스템 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2453f80583b015c097d94096a21e07fa08a7d653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_mcv_list_items&lt;/code&gt; function can be used like this:</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; 의 기능은 다음과 같이 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a0dd30f02c62fffd16e92aa745931812e6881ee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_monitor&lt;/code&gt;, &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; roles are intended to allow administrators to easily configure a role for the purpose of monitoring the database server. They grant a set of common privileges allowing the role to read various useful configuration settings, statistics and other system information normally restricted to superusers.</source>
          <target state="translated">&lt;code&gt;pg_monitor&lt;/code&gt; , &lt;code&gt;pg_read_all_settings&lt;/code&gt; , &lt;code&gt;pg_read_all_stats&lt;/code&gt; 및 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 의 역할은 관리자가 쉽게 데이터베이스 서버를 모니터링의 목적을 위해 역할을 구성 할 수 있도록하기위한 것입니다. 역할은 일반적으로 수퍼 유저로 제한된 다양한 유용한 구성 설정, 통계 및 기타 시스템 정보를 읽을 수있는 공통 권한 세트를 부여합니다.</target>
        </trans-unit>
        <trans-unit id="a9d719c2beab0d60be72a57746a97a87438b5577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view displays all the prepared statements that are available in the current session. See &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; for more information about prepared statements.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; 는 표시를 현재 세션에서 사용할 수있는 모든 준비가 문을 볼 수 있습니다. 준비된 명령문에 대한 자세한 정보는 &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f0733b71ce39a3b0da7d8656a3e5bc9319c9957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prepared_statements&lt;/code&gt; view is read only.</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; 의 뷰는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="712cfe11a273eb23a78bfc37d1131dc7151bd1af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_prewarm&lt;/code&gt; module provides a convenient way to load relation data into either the operating system buffer cache or the PostgreSQL buffer cache. Prewarming can be performed manually using the &lt;code&gt;pg_prewarm&lt;/code&gt; function, or can be performed automatically by including &lt;code&gt;pg_prewarm&lt;/code&gt; in &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;. In the latter case, the system will run a background worker which periodically records the contents of shared buffers in a file called &lt;code&gt;autoprewarm.blocks&lt;/code&gt; and will, using 2 background workers, reload those same blocks after a restart.</source>
          <target state="translated">&lt;code&gt;pg_prewarm&lt;/code&gt; 의 모듈은 운영 시스템의 버퍼 캐시 또는 PostgreSQL의 버퍼 캐시에로드하거나 관계 데이터에 편리한 방법을 제공한다. Prewarming는 사용 수동으로 수행 될 수 &lt;code&gt;pg_prewarm&lt;/code&gt; 의 기능을 포함하여 또는 자동적으로 수행 될 수 &lt;code&gt;pg_prewarm&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries를&lt;/a&gt; . 후자의 경우 시스템은 백그라운드 작업자를 실행하여 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; 라는 파일에 공유 버퍼의 내용을 정기적으로 기록하고 백그라운드 작업자 2 명을 사용하여 재시작 후 동일한 블록을 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="ae5fc12234ea79efc44835461370ba2ea861b98c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_read_server_files&lt;/code&gt;, &lt;code&gt;pg_write_server_files&lt;/code&gt; and &lt;code&gt;pg_execute_server_program&lt;/code&gt; roles are intended to allow administrators to have trusted, but non-superuser, roles which are able to access files and run programs on the database server as the user the database runs as. As these roles are able to access any file on the server file system, they bypass all database-level permission checks when accessing files directly and they could be used to gain superuser-level access, therefore great care should be taken when granting these roles to users.</source>
          <target state="translated">&lt;code&gt;pg_read_server_files&lt;/code&gt; , &lt;code&gt;pg_write_server_files&lt;/code&gt; 및 &lt;code&gt;pg_execute_server_program&lt;/code&gt; 의 역할은 관리자가 신뢰할 수있는 할 수 있도록 구성되지만, 비 슈퍼 유저, 데이터베이스 실행으로 사용자로 데이터베이스 서버에 액세스 파일과 실행 프로그램을 수있는 역할. 이러한 역할은 서버 파일 시스템의 모든 파일에 액세스 할 수 있으므로 파일에 직접 액세스 할 때 모든 데이터베이스 수준 권한 검사를 무시하고 수퍼 유저 수준 액세스를 얻는 데 사용될 수 있으므로 이러한 역할을 부여 할 때는 각별히주의해야합니다. 사용자.</target>
        </trans-unit>
        <trans-unit id="d4f7cb10a03b4cb92179c151a9345f858223dd84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_relation_filepath()&lt;/code&gt; function shows the entire path (relative to &lt;code&gt;PGDATA&lt;/code&gt;) of any relation. It is often useful as a substitute for remembering many of the above rules. But keep in mind that this function just gives the name of the first segment of the main fork of the relation &amp;mdash; you may need to append a segment number and/or &lt;code&gt;_fsm&lt;/code&gt;, &lt;code&gt;_vm&lt;/code&gt;, or &lt;code&gt;_init&lt;/code&gt; to find all the files associated with the relation.</source>
          <target state="translated">&lt;code&gt;pg_relation_filepath()&lt;/code&gt; 함수 쇼 (상대 전체 경로 &lt;code&gt;PGDATA&lt;/code&gt; 어떤 관계). 위의 많은 규칙을 기억하기위한 대체물로 종종 유용합니다. 그러나이 함수는 관계의 주요 포크의 첫 번째 세그먼트 이름 만 제공합니다 . 관계와 관련된 모든 파일을 찾으 &lt;code&gt;_vm&lt;/code&gt; 세그먼트 번호 및 / 또는 &lt;code&gt;_fsm&lt;/code&gt; , _vm 또는 &lt;code&gt;_init&lt;/code&gt; 를 추가해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03e84c5eab2e8606b5c93d96958f3280a2a3feb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin&lt;/code&gt; catalog contains all replication origins created. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin&lt;/code&gt; 의 카탈로그 생성 된 모든 복제 기원을 포함한다. 복제 기점에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94519dfaf1a7e0c715cbe6d005de1e67132adafc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_origin_status&lt;/code&gt; view contains information about how far replay for a certain origin has progressed. For more on replication origins see &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;Chapter 49&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_replication_origin_status&lt;/code&gt; 의 보기는 지금까지 진행 한 특정 기원 재생 방법에 대한 정보가 들어 있습니다. 복제 기점에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/replication-origins.html&quot;&gt;49 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6aff87cbf65850e431b7483477c97e1f7e57d54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_replication_slots&lt;/code&gt; view provides a listing of all replication slots that currently exist on the database cluster, along with their current state.</source>
          <target state="translated">&lt;code&gt;pg_replication_slots&lt;/code&gt; 의 보기는 현재 자신의 현재 상태와 함께 데이터베이스 클러스터에있는 모든 복제 슬롯의 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0e21895d1c29cfa7bd5d292f490ca241b01ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_rules&lt;/code&gt; view excludes the &lt;code&gt;ON SELECT&lt;/code&gt; rules of views and materialized views; those can be seen in &lt;code&gt;pg_views&lt;/code&gt; and &lt;code&gt;pg_matviews&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_rules&lt;/code&gt; 는 제외 볼 &lt;code&gt;ON SELECT&lt;/code&gt; 는 뷰의 규칙과 전망을 구체화; 그것들은에서 볼 수 있습니다 &lt;code&gt;pg_views&lt;/code&gt; 및 &lt;code&gt;pg_matviews&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b04c9372466f179b32ff250ffc0d648d21a6075f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_settings&lt;/code&gt; view cannot be inserted into or deleted from, but it can be updated. An &lt;code&gt;UPDATE&lt;/code&gt; applied to a row of &lt;code&gt;pg_settings&lt;/code&gt; is equivalent to executing the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command on that named parameter. The change only affects the value used by the current session. If an &lt;code&gt;UPDATE&lt;/code&gt; is issued within a transaction that is later aborted, the effects of the &lt;code&gt;UPDATE&lt;/code&gt; command disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_settings&lt;/code&gt; 의 보기에 삽입 또는 삭제하지만, 업데이트 할 수 있습니다 할 수 없습니다. &lt;code&gt;UPDATE&lt;/code&gt; 의 행에 적용 &lt;code&gt;pg_settings&lt;/code&gt; 는 실행중인 동등 &lt;a href=&quot;sql-set&quot;&gt;SET의&lt;/a&gt; 명명 된 파라미터에 명령한다. 변경 사항은 현재 세션에서 사용 된 값에만 영향을줍니다. 는 IF &lt;code&gt;UPDATE&lt;/code&gt; 가 나중에 중단 된 트랜잭션 내에서 발행,의 효과 &lt;code&gt;UPDATE&lt;/code&gt; 의 트랜잭션이 롤백 될 때 명령은 사라집니다. 주변 트랜잭션이 커밋되면 다른 세션에 의해 재정의되지 않는 한 세션이 끝날 때까지 효과가 지속됩니다. &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="959ff59e7cb2ea926dc414727d1a287d75002cdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_signal_backend&lt;/code&gt; role is intended to allow administrators to enable trusted, but non-superuser, roles to send signals to other backends. Currently this role enables sending of signals for canceling a query on another backend or terminating its session. A user granted this role cannot however send signals to a backend owned by a superuser. See &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;Section 9.26.2&lt;/a&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_signal_backend&lt;/code&gt; 의 역할은 관리자가 신뢰 설정할 수있는하도록 구성되어 있지만, 비 슈퍼 유저는 역할이 다른 백엔드에 신호를 보낼 수 있습니다. 현재이 역할을 통해 다른 백엔드에서 쿼리를 취소하거나 세션을 종료하기 위해 신호를 보낼 수 있습니다. 그러나이 역할이 부여 된 사용자는 수퍼 유저가 소유 한 백엔드에 신호를 보낼 수 없습니다. &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-SIGNAL&quot;&gt;9.26.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="364ec70800885a32c9b384791eb887b060833388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_activity&lt;/code&gt; view will have one row per server process, showing information related to the current activity of that process.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_stat_activity&lt;/code&gt; 의 뷰는 서버 프로세스 당 하나의 열, 즉 공정의 현재의 활동에 관한 정보를 나타내는 것이다.</target>
        </trans-unit>
        <trans-unit id="0d5cfe66d3c739cee322847b588c9d5b35df5eee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about accesses to that specific index. The &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; and &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 뷰는 특정 지수에 대한 액세스에 대한 통계를 보여 현재 데이터베이스에 각 인덱스에 대한 하나의 행이 포함됩니다. &lt;code&gt;pg_stat_user_indexes&lt;/code&gt; 및 &lt;code&gt;pg_stat_sys_indexes&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 인덱스로 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="4915eaf62d5fac508cd463bbfeb67c5bc9a1f887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about accesses to that specific table. The &lt;code&gt;pg_stat_user_tables&lt;/code&gt; and &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_stat_all_tables&lt;/code&gt; 의 뷰는 특정 테이블에 대한 액세스에 대한 통계를 보여 (TOAST 테이블 포함) 현재 데이터베이스의 각 테이블에 대해 하나 개의 행이 포함됩니다. &lt;code&gt;pg_stat_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_stat_sys_tables&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 테이블 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="e920a84446b775991fa1eb14f7bc867a07c08969" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_archiver&lt;/code&gt; view will always have a single row, containing data about the archiver process of the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_archiver&lt;/code&gt; 의 보기는 항상 클러스터의 아카이버 프로세스에 대한 데이터를 포함하는 단일 행을해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaad38e5659f088cd956997f18528cb8adec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view will always have a single row, containing global data for the cluster.</source>
          <target state="translated">&lt;code&gt;pg_stat_bgwriter&lt;/code&gt; 의 보기는 항상 클러스터에 대한 글로벌 데이터를 포함, 단일 행을해야합니다.</target>
        </trans-unit>
        <trans-unit id="393da291bc9e23ea3e77a3450fa686048aaf2442" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database&lt;/code&gt; view will contain one row for each database in the cluster, plus one for the shared objects, showing database-wide statistics.</source>
          <target state="translated">&lt;code&gt;pg_stat_database&lt;/code&gt; 의 뷰는 데이터베이스 전체의 통계를 보여주는, 공유 객체에 대한 각 클러스터의 데이터베이스 플러스 하나 하나 개의 행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3c93e50dd3fc817fe9ad114869b45a8e9cc6f37d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; view will contain one row per database, showing database-wide statistics about query cancels occurring due to conflicts with recovery on standby servers. This view will only contain information on standby servers, since conflicts do not occur on master servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; 이 때문에 대기 서버에 복구와의 충돌로 발생하는 취소됩니다 쿼리에 대한 데이터베이스 차원의 통계를 보여주는, 데이터베이스 당 하나의 행이 포함됩니다 볼 수 있습니다. 마스터 서버에서는 충돌이 발생하지 않으므로이보기에는 대기 서버에 대한 정보 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9ca86aca5bdcd3b49612a77c80efa58451d60340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_gssapi&lt;/code&gt; view will contain one row per backend, showing information about GSSAPI usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_gssapi&lt;/code&gt; 의 볼이 연결에 GSSAPI 사용에 대한 정보를 표시, 백엔드 당 하나 개의 행을 포함합니다. &lt;code&gt;pg_stat_activity&lt;/code&gt; 또는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 에 결합 될 수 있습니다 . &lt;code&gt;pid&lt;/code&gt; 열 하여 연결에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d861488085903be47118e7cb1eda5ee9716d20c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_replication&lt;/code&gt; view will contain one row per WAL sender process, showing statistics about replication to that sender's connected standby server. Only directly connected standbys are listed; no information is available about downstream standby servers.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; 보기는 보낸 사람의 연결 대기 서버로 복제에 대한 통계를 보여 WAL 발신자 프로세스 당 하나 개의 행을 포함합니다. 직접 연결된 대기만 나열됩니다. 다운 스트림 대기 서버에 대한 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fc5431a476a7e29631b45416342385e30449578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_ssl&lt;/code&gt; view will contain one row per backend or WAL sender process, showing statistics about SSL usage on this connection. It can be joined to &lt;code&gt;pg_stat_activity&lt;/code&gt; or &lt;code&gt;pg_stat_replication&lt;/code&gt; on the &lt;code&gt;pid&lt;/code&gt; column to get more details about the connection.</source>
          <target state="translated">&lt;code&gt;pg_stat_ssl&lt;/code&gt; 의 볼이 연결에 SSL 사용에 대한 통계를 보여 백엔드 또는 WAL 발신자 프로세스 당 하나 개의 행을 포함합니다. &lt;code&gt;pid&lt;/code&gt; 에서 &lt;code&gt;pg_stat_activity&lt;/code&gt; 또는 &lt;code&gt;pg_stat_replication&lt;/code&gt; 에 결합 할 수 있습니다 열 하여 연결에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf211b37dbd6853dfd5eb7dd10c7c12b2c0042c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; module provides a means for tracking execution statistics of all SQL statements executed by a server.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 모듈은 서버에서 실행되는 모든 SQL 문 실행 통계를 추적하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98e909d7ac4e2a7927d69b3536cd3fab24324d97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_statements&lt;/code&gt; view is defined in terms of a function also named &lt;code&gt;pg_stat_statements&lt;/code&gt;. It is possible for clients to call the &lt;code&gt;pg_stat_statements&lt;/code&gt; function directly, and by specifying &lt;code&gt;showtext := false&lt;/code&gt; have query text be omitted (that is, the &lt;code&gt;OUT&lt;/code&gt; argument that corresponds to the view's &lt;code&gt;query&lt;/code&gt; column will return nulls). This feature is intended to support external tools that might wish to avoid the overhead of repeatedly retrieving query texts of indeterminate length. Such tools can instead cache the first query text observed for each entry themselves, since that is all &lt;code&gt;pg_stat_statements&lt;/code&gt; itself does, and then retrieve query texts only as needed. Since the server stores query texts in a file, this approach may reduce physical I/O for repeated examination of the &lt;code&gt;pg_stat_statements&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements&lt;/code&gt; 의 뷰는 또한 함수라는 관점에서 정의된다 &lt;code&gt;pg_stat_statements&lt;/code&gt; . 클라이언트가 &lt;code&gt;pg_stat_statements&lt;/code&gt; 함수를 직접 호출하고 &lt;code&gt;showtext := false&lt;/code&gt; 를 지정하여 쿼리 텍스트를 생략 할 수 있습니다 (즉 , 뷰의 &lt;code&gt;query&lt;/code&gt; 자체에 해당하는 &lt;code&gt;OUT&lt;/code&gt; 인수는 필요에 따라 쿼리 텍스트를 검색 함). 서버는 쿼리 텍스트를 파일에 저장합니다.이 접근 방식은 &lt;code&gt;pg_stat_statements&lt;/code&gt; 데이터 의 반복 검사를 위해 물리적 I / O를 줄일 수 있습니다 . 열에 널을 리턴 함). 이 기능은 길이가 불확실한 쿼리 텍스트를 반복적으로 검색하는 오버 헤드를 피할 수있는 외부 도구를 지원하기위한 것입니다. 이러한 도구는 각 항목 자체에서 관찰 된 첫 번째 쿼리 텍스트를 대신 캐시 할 수 있습니다. &lt;code&gt;pg_stat_statements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abb8ed00a27312be8d978730672b0b28bbcb5469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_subscription&lt;/code&gt; view will contain one row per subscription for main worker (with null PID if the worker is not running), and additional rows for workers handling the initial data copy of the subscribed tables.</source>
          <target state="translated">&lt;code&gt;pg_stat_subscription&lt;/code&gt; (작업자가 실행되고 있지 않은 경우는 null PID와)보기 주 노동자에 대한 구독 당 하나 개의 행을 포함하고 초기 데이터를 취급 근로자에 대한 추가 행이 가입 된 테이블로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="10b53f5c8cdaebaaf4ec10ef70cc41030a5f49c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_user_functions&lt;/code&gt; view will contain one row for each tracked function, showing statistics about executions of that function. The &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; parameter controls exactly which functions are tracked.</source>
          <target state="translated">&lt;code&gt;pg_stat_user_functions&lt;/code&gt; 의 보기는 그 기능의 실행에 대한 통계를 나타내는 각각의 추적 된 기능에 대한 하나 개의 행을 포함 할 것이다. &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; 제어 매개 변수는 정확하게 기능을 추적한다.</target>
        </trans-unit>
        <trans-unit id="192cc2da4edef74cee3104eea30272179c17353c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; view will contain only one row, showing statistics about the WAL receiver from that receiver's connected server.</source>
          <target state="translated">&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; 의 보기는 수신기의 연결된 서버에서 WAL 수신기에 대한 통계를 보여주는 하나의 행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ccb7822cb6072c4067c2cc69eddb66f1fcb783d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_&lt;/code&gt; views are primarily useful to determine the effectiveness of the buffer cache. When the number of actual disk reads is much smaller than the number of buffer hits, then the cache is satisfying most read requests without invoking a kernel call. However, these statistics do not give the entire story: due to the way in which PostgreSQL handles disk I/O, data that is not in the PostgreSQL buffer cache might still reside in the kernel's I/O cache, and might therefore still be fetched without requiring a physical read. Users interested in obtaining more detailed information on PostgreSQL I/O behavior are advised to use the PostgreSQL statistics collector in combination with operating system utilities that allow insight into the kernel's handling of I/O.</source>
          <target state="translated">&lt;code&gt;pg_statio_&lt;/code&gt; 보기는 버퍼 캐시의 효과를 결정하는 주로 유용합니다. 실제 디스크 읽기 수가 버퍼 적중 횟수보다 훨씬 적은 경우 캐시는 커널 호출을 호출하지 않고 대부분의 읽기 요청을 충족시킵니다. 그러나 이러한 통계는 전체 스토리를 제공하지는 않습니다. PostgreSQL이 디스크 I / O를 처리하는 방식으로 인해 PostgreSQL 버퍼 캐시에없는 데이터는 여전히 커널의 I / O 캐시에있을 수 있으며 여전히 페치 될 수 있습니다 실제 읽기가 필요하지 않습니다. PostgreSQL I / O 동작에 대한 자세한 정보를 얻는 데 관심이있는 사용자는 커널의 I / O 처리에 대한 통찰력을 제공하는 운영 체제 유틸리티와 함께 ​​PostgreSQL 통계 수집기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4275ef4261b6d2382694080172180d4c6bb50fe7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; view will contain one row for each index in the current database, showing statistics about I/O on that specific index. The &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; and &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; views contain the same information, but filtered to only show user and system indexes respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_indexes&lt;/code&gt; 는 I / 특정 지수에 O에 대한 통계를 보여, 현재 데이터베이스에 각 인덱스에 대한 하나의 행이 포함됩니다 볼 수 있습니다. &lt;code&gt;pg_statio_user_indexes&lt;/code&gt; 및 &lt;code&gt;pg_statio_sys_indexes&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 인덱스로 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="633f3d97ee7656ef624fbb5d36d3f8580d36168e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; view will contain one row for each sequence in the current database, showing statistics about I/O on that specific sequence.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_sequences&lt;/code&gt; 는 I / 특정 순서에 O에 대한 통계를 보여 현재 데이터베이스의 각 시퀀스에 대해 하나의 행이 포함됩니다 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3f0cb49815d4460862c6bbe716f068280da5e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statio_all_tables&lt;/code&gt; view will contain one row for each table in the current database (including TOAST tables), showing statistics about I/O on that specific table. The &lt;code&gt;pg_statio_user_tables&lt;/code&gt; and &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; views contain the same information, but filtered to only show user and system tables respectively.</source>
          <target state="translated">&lt;code&gt;pg_statio_all_tables&lt;/code&gt; 는 I / 특정 테이블에 O에 대한 통계를 보여 (TOAST 테이블 포함) 현재 데이터베이스의 각 테이블에 대해 하나의 행이 포함됩니다 볼 수 있습니다. &lt;code&gt;pg_statio_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_statio_sys_tables&lt;/code&gt; 의 뷰와 동일한 정보를 포함하고 있지만, 각각의 표시 대상 사용자와 시스템 테이블 여과 하였다.</target>
        </trans-unit>
        <trans-unit id="57e3b64868b02c0a85487789a181915c3308f04e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_statistic_ext&lt;/code&gt; entry is filled in completely during &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, but the actual statistical values are not computed then. Subsequent &lt;code&gt;ANALYZE&lt;/code&gt; commands compute the desired values and populate an entry in the &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; 의 항목 중에 완전히 채워진다 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 있지만, 실제 통계 값은 다음으로 계산되지 않는다. 후속 &lt;code&gt;ANALYZE&lt;/code&gt; 명령은 원하는 값을 계산하고 &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt; 카탈로그 의 항목을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="4ab16db4ae44ab46362ea23499bbb4d24c58bacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_stop_backup&lt;/code&gt; will return one row with three values. The second of these fields should be written to a file named &lt;code&gt;backup_label&lt;/code&gt; in the root directory of the backup. The third field should be written to a file named &lt;code&gt;tablespace_map&lt;/code&gt; unless the field is empty. These files are vital to the backup working, and must be written without modification.</source>
          <target state="translated">&lt;code&gt;pg_stop_backup&lt;/code&gt; 는 세 개의 값을 하나 개의 행을 반환합니다. 이 필드 중 두 번째 필드는 &lt;code&gt;backup_label&lt;/code&gt; 이라는 파일에 작성해야합니다. 백업의 루트 디렉토리에있는 . 필드가 비어 있지 않으면 세 번째 필드는 &lt;code&gt;tablespace_map&lt;/code&gt; 이라는 파일에 작성해야합니다 . 이 파일들은 백업 작업에 필수적이며 수정없이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccb3d590fa85ee9247d7f4bf77a2f3efc4344c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides GiST and GIN index operator classes that allow you to create an index over a text column for the purpose of very fast similarity searches. These index types support the above-described similarity operators, and additionally support trigram-based index searches for &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; queries. (These indexes do not support equality nor simple comparison operators, so you may need a regular B-tree index too.)</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; 의 모듈은 매우 빠른 유사성 검색을 목적으로 텍스트 컬럼을 통해 인덱스를 만들 수 GIST 및 GIN 인덱스 연산자 클래스를 제공합니다. 이러한 인덱스 유형은 위에서 설명한 유사성 연산자를 지원하고 &lt;code&gt;LIKE&lt;/code&gt; , &lt;code&gt;ILIKE&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 및 trigram 기반 인덱스 검색을 추가로 지원합니다. &lt;code&gt;~*&lt;/code&gt; 쿼리에 합니다. (이 인덱스는 동등성이나 간단한 비교 연산자를 지원하지 않으므로 일반 B- 트리 인덱스도 필요할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fc7db08f494b7bd6b75737a77c0ee6584bbbf782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_trgm&lt;/code&gt; module provides functions and operators for determining the similarity of alphanumeric text based on trigram matching, as well as index operator classes that support fast searching for similar strings.</source>
          <target state="translated">그만큼 &lt;code&gt;pg_trgm&lt;/code&gt; 의 모듈은 트라이 그램 매칭 지원뿐만 아니라 빠른 유사한 문자열을 찾고 그 인덱스 연산자 클래스를 기반 영숫자 문자의 유사성을 결정하기위한 함수와 연산자를 제공한다.</target>
        </trans-unit>
        <trans-unit id="0591f005154500c944add92ac3b7183691fb1ca4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config&lt;/code&gt; catalog contains entries representing text search configurations. A configuration specifies a particular text search parser and a list of dictionaries to use for each of the parser's output token types. The parser is shown in the &lt;code&gt;pg_ts_config&lt;/code&gt; entry, but the token-to-dictionary mapping is defined by subsidiary entries in &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt;&lt;code&gt;pg_ts_config_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ts_config&lt;/code&gt; 의 카탈로그는 텍스트 검색 구성을 나타내는 항목이 포함되어 있습니다. 구성은 특정 텍스트 검색 파서와 각 파서의 출력 토큰 유형에 사용할 사전 목록을 지정합니다. 파서는 &lt;code&gt;pg_ts_config&lt;/code&gt; 항목에 표시되지만 토큰-사전 매핑은 &lt;a href=&quot;catalog-pg-ts-config-map&quot;&gt; &lt;code&gt;pg_ts_config_map&lt;/code&gt; 의&lt;/a&gt; 자회사 항목으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed3b9b0c162846ed7796c343a7cd6db3dce66f59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_config_map&lt;/code&gt; catalog contains entries showing which text search dictionaries should be consulted, and in what order, for each output token type of each text search configuration's parser.</source>
          <target state="translated">&lt;code&gt;pg_ts_config_map&lt;/code&gt; 의 카탈로그 항목이 각 텍스트 검색 구성의 파서의 각 출력 토큰 유형, 텍스트 검색 사전을 상담해야하는 보여주는, 그리고 어떤 순서로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1aa79ed96a9f64450a185ab7801c634f26ba881" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_dict&lt;/code&gt; catalog contains entries defining text search dictionaries. A dictionary depends on a text search template, which specifies all the implementation functions needed; the dictionary itself provides values for the user-settable parameters supported by the template. This division of labor allows dictionaries to be created by unprivileged users. The parameters are specified by a text string &lt;code&gt;dictinitoption&lt;/code&gt;, whose format and meaning vary depending on the template.</source>
          <target state="translated">&lt;code&gt;pg_ts_dict&lt;/code&gt; 의 카탈로그는 텍스트 검색 사전을 정의하는 항목이 포함되어 있습니다. 사전은 필요한 모든 구현 기능을 지정하는 텍스트 검색 템플릿에 따라 다릅니다. 사전 자체는 템플리트가 지원하는 사용자 설정 가능 매개 변수의 값을 제공합니다. 이 분업으로 인해 권한이없는 사용자가 사전을 만들 수 있습니다. 매개 변수는 텍스트 문자열 &lt;code&gt;dictinitoption&lt;/code&gt; 에 의해 지정되며 형식과 의미는 템플리트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="214cf3524f01d220fbc4c1ed75c24082b9d19637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_parser&lt;/code&gt; catalog contains entries defining text search parsers. A parser is responsible for splitting input text into lexemes and assigning a token type to each lexeme. Since a parser must be implemented by C-language-level functions, creation of new parsers is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_parser&lt;/code&gt; 의 카탈로그는 텍스트 검색 파서를 정의하는 항목이 포함되어 있습니다. 파서는 입력 텍스트를 exeme으로 나누고 각 lexeme에 토큰 유형을 할당합니다. 구문 분석기는 C 언어 레벨 함수로 구현해야하므로 새 구문 분석기 작성은 데이터베이스 수퍼 유저로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="cb87e8d8ef4d72f7f47347f20f99911a07cb666c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_ts_template&lt;/code&gt; catalog contains entries defining text search templates. A template is the implementation skeleton for a class of text search dictionaries. Since a template must be implemented by C-language-level functions, creation of new templates is restricted to database superusers.</source>
          <target state="translated">&lt;code&gt;pg_ts_template&lt;/code&gt; 의 카탈로그는 텍스트 검색 템플릿을 정의하는 항목이 포함되어 있습니다. 템플릿은 텍스트 검색 사전 클래스의 구현 골격입니다. C 언어 수준의 기능으로 템플릿을 구현해야하므로 새 템플릿 생성은 데이터베이스 수퍼 유저로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="98aec2c9411d89139f2d3f0f94ddaca8b8727976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pg_visibility&lt;/code&gt; module provides a means for examining the visibility map (VM) and page-level visibility information of a table. It also provides functions to check the integrity of a visibility map and to force it to be rebuilt.</source>
          <target state="translated">&lt;code&gt;pg_visibility&lt;/code&gt; 의 모듈은 시정지도 (VM) 및 테이블의 페이지 수준의 가시성 정보를 검사하는 수단을 제공합니다. 또한 가시성 맵의 무결성을 확인하고 강제로 다시 작성하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aebe4e3ccf987f601f3ce63d73da2ecfe326511d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgcrypto&lt;/code&gt; module provides cryptographic functions for PostgreSQL.</source>
          <target state="translated">&lt;code&gt;pgcrypto&lt;/code&gt; 의 모듈은 PostgreSQL을위한 암호화 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7582806e57c12c2e0e98376d6a43f53ffd981a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgrowlocks&lt;/code&gt; module provides a function to show row locking information for a specified table.</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; 의 모듈은 지정된 테이블 행 잠금 정보를 표시하는 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="0aa04313fa7e95bfad5b3c29fac2331cea3b0811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pgstattuple&lt;/code&gt; module provides various functions to obtain tuple-level statistics.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; 의 모듈 튜플 레벨 통계를 획득하기위한 다양한 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="3550763c8f87c7c5071a2ae4590cbccf7d821554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pid&lt;/code&gt; column can be joined to the &lt;code&gt;pid&lt;/code&gt; column of the &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;&lt;code&gt;pg_stat_activity&lt;/code&gt;&lt;/a&gt; view to get more information on the session holding or awaiting each lock, for example</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 열이 결합 될 수있다 &lt;code&gt;pid&lt;/code&gt; 의 열 &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt; &lt;code&gt;pg_stat_activity&lt;/code&gt; 의&lt;/a&gt; 예를 들어, 세션 유지 또는 각 잠금 대기에 대한 자세한 정보를 얻을보기</target>
        </trans-unit>
        <trans-unit id="1772c228a2ba486f02c419b09475ac82a8dda4c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type is an example of a PostgreSQL-specific data type.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 타입 PostgreSQL의 특정 데이터 유형의 예이다.</target>
        </trans-unit>
        <trans-unit id="6d33330f4a5a6a6e60ef800433563c926a762925" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; type requires a coordinate pair as input, as shown here:</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 유형이 여기 도시 한 바와 같이, 입력으로 쌍 좌표 필요</target>
        </trans-unit>
        <trans-unit id="5140039e3c9f8558e37b9c94c77a69208747ed9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; command can also be called in single-user mode. The primary use for this mode is during bootstrapping by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Sometimes it is used for debugging or disaster recovery; note that running a single-user server is not truly suitable for debugging the server, since no realistic interprocess communication and locking will happen. When invoked in single-user mode from the shell, the user can enter queries and the results will be printed to the screen, but in a form that is more useful for developers than end users. In the single-user mode, the session user will be set to the user with ID 1, and implicit superuser powers are granted to this user. This user does not actually have to exist, so the single-user mode can be used to manually recover from certain kinds of accidental damage to the system catalogs.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 명령은 단일 사용자 모드로 호출 할 수 있습니다. 이 모드의 기본 용도는 &lt;a href=&quot;app-initdb&quot;&gt;initdb로&lt;/a&gt; 부트 스트랩하는 동안입니다.. 때로는 디버깅 또는 재해 복구에 사용되기도합니다. 실제 프로세스 간 통신 및 잠금이 발생하지 않으므로 단일 사용자 서버를 실행하는 것이 서버 디버깅에 실제로 적합하지는 않습니다. 셸에서 단일 사용자 모드로 호출하면 사용자가 쿼리를 입력 할 수 있으며 결과는 화면에 인쇄되지만 최종 사용자보다 개발자에게 더 유용한 형식으로 인쇄됩니다. 단일 사용자 모드에서 세션 사용자는 ID 1의 사용자로 설정되며 암시 적 슈퍼 유저 권한이이 사용자에게 부여됩니다. 이 사용자는 실제로 존재하지 않아도되므로 단일 사용자 모드를 사용하여 시스템 카탈로그에 대한 특정 유형의 우발적 인 손상을 수동으로 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73edbc735e1da3f91be137ad83f38e16d0101877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; database is also created when a database cluster is initialized. This database is meant as a default database for users and applications to connect to. It is simply a copy of &lt;code&gt;template1&lt;/code&gt; and can be dropped and recreated if necessary.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 데이터베이스 클러스터가 초기화 될 때 데이터베이스도 생성됩니다. 이 데이터베이스는 사용자와 응용 프로그램이 연결하는 기본 데이터베이스로 사용됩니다. 이는 단순히 &lt;code&gt;template1&lt;/code&gt; 의 사본이며 필요한 경우 삭제하고 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c82b8fca9884597f624dea1153620a237bd20b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; program also takes a number of other command-line options. For more information, see the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page and &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 프로그램은 또한 다른 명령 줄 옵션을합니다. 자세한 내용은 &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; 참조 페이지와 아래 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7330a81519eca7bce15eddcdea10af1a633af88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres&lt;/code&gt; server uses &lt;code&gt;SIGQUIT&lt;/code&gt; to tell subordinate server processes to terminate without normal cleanup. This signal &lt;em&gt;should not&lt;/em&gt; be used by users. It is also unwise to send &lt;code&gt;SIGKILL&lt;/code&gt; to a server process &amp;mdash; the main &lt;code&gt;postgres&lt;/code&gt; process will interpret this as a crash and will force all the sibling processes to quit as part of its standard crash-recovery procedure.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 서버 사용의 &lt;code&gt;SIGQUIT&lt;/code&gt; 는 정상 정리하지 않고 종료 하위 서버 프로세스를 알 수 있습니다. 이 신호 &lt;em&gt;는&lt;/em&gt; 사용자가 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; . 또한 &lt;code&gt;SIGKILL&lt;/code&gt; 을 서버 프로세스 로 보내는 것은 현명하지 못합니다 . 기본 &lt;code&gt;postgres&lt;/code&gt; 프로세스는이를 크래시로 해석하고 모든 형제 프로세스를 표준 크래시 복구 절차의 일부로 강제 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c92653f4d0fd5ea002d544c735e92bfa8e8c8314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgres_fdw&lt;/code&gt; module provides the foreign-data wrapper &lt;code&gt;postgres_fdw&lt;/code&gt;, which can be used to access data stored in external PostgreSQL servers.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 모듈은 외부 데이터 래퍼 &lt;code&gt;postgres_fdw&lt;/code&gt; 를 제공합니다 . postgres_fdw 는 외부 PostgreSQL 서버에 저장된 데이터에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e090ec42938a8e07ce95bbef3862c409a5d10ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postgresql.conf&lt;/code&gt; file can also contain &lt;code&gt;include_dir&lt;/code&gt; directives, which specify an entire directory of configuration files to include. These look like</source>
          <target state="translated">&lt;code&gt;postgresql.conf&lt;/code&gt; 파일도 포함 할 수 있습니다 &lt;code&gt;include_dir&lt;/code&gt; 구성 파일의 전체 디렉토리를 포함하도록 지정 지침을. 이것들은</target>
        </trans-unit>
        <trans-unit id="b3d5fb19af808b68f842086f75de8bd4758fc142" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;predicate&lt;/code&gt; allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; 당신이 테이블의 부분 집합에 제외 제약 조건을 지정할 수 있습니다; 내부적으로 이것은 부분 인덱스를 만듭니다. 술어 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1b637034a943affe6ee006c1f9d5b95a5ccbc7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;psql&lt;/code&gt; program has a number of internal commands that are not SQL commands. They begin with the backslash character, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; 의의 프로그램은 SQL 명령하지 않은 내부 명령을 가지고 있습니다. 백 슬래시 문자 &quot; &lt;code&gt;\&lt;/code&gt; &quot;로 시작합니다. 예를 들어 다음을 입력하여 다양한 PostgreSQL SQL 명령의 구문에 대한 도움말을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce36c6cfc7d62a93cbf69277d65d4367aa5df13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quad_point_ops&lt;/code&gt;, &lt;code&gt;kd_point_ops&lt;/code&gt; and &lt;code&gt;poly_ops&lt;/code&gt; operator classes support the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ordering operator, which enables the k-nearest neighbor (&lt;code&gt;k-NN&lt;/code&gt;) search over indexed point or polygon data sets.</source>
          <target state="translated">&lt;code&gt;quad_point_ops&lt;/code&gt; , &lt;code&gt;kd_point_ops&lt;/code&gt; 및 &lt;code&gt;poly_ops&lt;/code&gt; 연산자 클래스 지지체 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; K 개의 최근 접 (수 순서 연산자 &lt;code&gt;k-NN&lt;/code&gt; ) 인덱스 점 또는 폴리곤 데이터 세트를 통해 검색한다.</target>
        </trans-unit>
        <trans-unit id="603e4354460ff268426362e0c3963c884ac4c1a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random()&lt;/code&gt; function uses a simple linear congruential algorithm. It is fast but not suitable for cryptographic applications; see the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module for a more secure alternative. If &lt;code&gt;setseed()&lt;/code&gt; is called, the results of subsequent &lt;code&gt;random()&lt;/code&gt; calls in the current session are repeatable by re-issuing &lt;code&gt;setseed()&lt;/code&gt; with the same argument.</source>
          <target state="translated">&lt;code&gt;random()&lt;/code&gt; 함수는 선형 합동 간단한 알고리즘을 사용한다. 빠르지 만 암호화 응용 프로그램에는 적합하지 않습니다. 보다 안전한 대안 은 &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; 모듈을 참조하십시오 . 경우 &lt;code&gt;setseed()&lt;/code&gt; 라고, 이후의 결과 &lt;code&gt;random()&lt;/code&gt; 현재 세션의 호출에 의해 반복되어 재 발급 &lt;code&gt;setseed()&lt;/code&gt; 같은 인수와 함께.</target>
        </trans-unit>
        <trans-unit id="0231cb3d8ce00a0c5b86b501f35685f87444ba0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random&lt;/code&gt; function generates values using a uniform distribution, that is all the values are drawn within the specified range with equal probability. The &lt;code&gt;random_exponential&lt;/code&gt;, &lt;code&gt;random_gaussian&lt;/code&gt; and &lt;code&gt;random_zipfian&lt;/code&gt; functions require an additional double parameter which determines the precise shape of the distribution.</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 함수는 모든 값이 동일한 확률로 지정된 범위 내에 그려진 것이다 균일 분포를 이용하여 값을 생성한다. &lt;code&gt;random_exponential&lt;/code&gt; , &lt;code&gt;random_gaussian&lt;/code&gt; 및 &lt;code&gt;random_zipfian&lt;/code&gt; 함수 분포의 정확한 형상을 결정하는 추가 2 파라미터를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="9c090601f4f464e87f2fbb4f8206fe29858dd81d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_match&lt;/code&gt; function returns a text array of captured substring(s) resulting from the first match of a POSIX regular expression pattern to a string. It has the syntax &lt;code&gt;regexp_match&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match, the result is &lt;code&gt;NULL&lt;/code&gt;. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains no parenthesized subexpressions, then the result is a single-element text array containing the substring matching the whole pattern. If a match is found, and the &lt;code&gt;pattern&lt;/code&gt; contains parenthesized subexpressions, then the result is a text array whose &lt;code&gt;n&lt;/code&gt;'th element is the substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the &lt;code&gt;pattern&lt;/code&gt; (not counting &amp;ldquo;non-capturing&amp;rdquo; parentheses; see below for details). The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Supported flags are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_match&lt;/code&gt; 의 기능 문자열로 POSIX 정규식 패턴의 제 매치의 결과 (S)의 촬상 서브 스트링 텍스트 배열을 반환한다. &lt;code&gt;regexp_match&lt;/code&gt; 구문 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. 일치하는 것이 없으면 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다. 일치하는 항목이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이 없으면 결과는 전체 패턴과 일치하는 하위 문자열을 포함하는 단일 요소 텍스트 배열입니다. 일치하는 것이 있고 &lt;code&gt;pattern&lt;/code&gt; 에 괄호로 묶인 하위 표현식이 포함 된 경우 결과는 &lt;code&gt;n&lt;/code&gt; 번째 요소가 &lt;code&gt;n&lt;/code&gt; 과 일치하는 하위 문자열 인 텍스트 배열입니다. &lt;code&gt;pattern&lt;/code&gt; 의 괄호로 묶인 하위 표현 ( &quot;캡처하지 않는&quot;괄호를 세지 않음; 자세한 내용은 아래 참조) &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 지원되는 플래그는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a9d1b88379c50aed0c3fa7f79c63d3f93f4473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_matches&lt;/code&gt; function returns a set of text arrays of captured substring(s) resulting from matching a POSIX regular expression pattern to a string. It has the same syntax as &lt;code&gt;regexp_match&lt;/code&gt;. This function returns no rows if there is no match, one row if there is a match and the &lt;code&gt;g&lt;/code&gt; flag is not given, or &lt;code&gt;N&lt;/code&gt; rows if there are &lt;code&gt;N&lt;/code&gt; matches and the &lt;code&gt;g&lt;/code&gt; flag is given. Each returned row is a text array containing the whole matched substring or the substrings matching parenthesized subexpressions of the &lt;code&gt;pattern&lt;/code&gt;, just as described above for &lt;code&gt;regexp_match&lt;/code&gt;. &lt;code&gt;regexp_matches&lt;/code&gt; accepts all the flags shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;, plus the &lt;code&gt;g&lt;/code&gt; flag which commands it to return all matches, not just the first one.</source>
          <target state="translated">&lt;code&gt;regexp_matches&lt;/code&gt; 는 복귀에게 문자열에 POSIX 정규식 패턴 매칭에 의한 촬상 스트링 (들)의 텍스트 배열 세트 기능한다. &lt;code&gt;regexp_match&lt;/code&gt; 와 동일한 구문을 갖습니다 . 이 일치하고있는 경우 일치하는, 하나 개의 행이없는 경우이 함수는 행을 반환하지 않습니다 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정되지 않았거나 &lt;code&gt;N&lt;/code&gt; 의 가있는 경우 행이 &lt;code&gt;N&lt;/code&gt; 의 일치와 &lt;code&gt;g&lt;/code&gt; 의 플래그가 지정됩니다. 반환 된 각 행은 위에서 설명한 &lt;code&gt;regexp_match&lt;/code&gt; 표현식 하위 문자열 또는 &lt;code&gt;pattern&lt;/code&gt; 의 괄호로 묶인 하위 표현식과 일치하는 하위 문자열을 포함하는 텍스트 배열 입니다. &lt;code&gt;regexp_matches&lt;/code&gt; 는 다음에 표시된 모든 플래그를 허용합니다.&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt; 과 &lt;code&gt;g&lt;/code&gt; 플래그는 첫 번째 항목뿐만 아니라 모든 일치 항목을 반환하도록 명령합니다.</target>
        </trans-unit>
        <trans-unit id="a1d960616f19511c8709605bafb8561fb42fd92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_replace&lt;/code&gt; function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax &lt;code&gt;regexp_replace&lt;/code&gt;(&lt;code&gt;source&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The &lt;code&gt;source&lt;/code&gt; string is returned unchanged if there is no match to the &lt;code&gt;pattern&lt;/code&gt;. If there is a match, the &lt;code&gt;source&lt;/code&gt; string is returned with the &lt;code&gt;replacement&lt;/code&gt; string substituted for the matching substring. The &lt;code&gt;replacement&lt;/code&gt; string can contain &lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is 1 through 9, to indicate that the source substring matching the &lt;code&gt;n&lt;/code&gt;'th parenthesized subexpression of the pattern should be inserted, and it can contain &lt;code&gt;\&amp;amp;&lt;/code&gt; to indicate that the substring matching the entire pattern should be inserted. Write &lt;code&gt;\\&lt;/code&gt; if you need to put a literal backslash in the replacement text. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag &lt;code&gt;i&lt;/code&gt; specifies case-insensitive matching, while flag &lt;code&gt;g&lt;/code&gt; specifies replacement of each matching substring rather than only the first one. Supported flags (though not &lt;code&gt;g&lt;/code&gt;) are described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_replace&lt;/code&gt; 함수는 POSIX 정규식 패턴과 일치 하는 서브 스트링의 새 텍스트 대체를 제공합니다. &lt;code&gt;regexp_replace&lt;/code&gt; 구문 ( &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; , &lt;code&gt;replacement&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. &lt;code&gt;source&lt;/code&gt; 받는 일치가없는 경우 문자열은 변경되지 반환 &lt;code&gt;pattern&lt;/code&gt; . 일치하는 것이 있으면 일치하는 하위 문자열을 &lt;code&gt;replacement&lt;/code&gt; 문자열로 대체 하여 &lt;code&gt;source&lt;/code&gt; 문자열을 반환합니다 . &lt;code&gt;replacement&lt;/code&gt; 문자열을 포함 할 수 있습니다 &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 여기서 &lt;code&gt;n&lt;/code&gt; 은패턴 의 &lt;code&gt;n&lt;/code&gt; 번째 괄호로 묶인 하위 표현식과 일치하는 소스 하위 문자열을 삽입해야 함 을 나타내려면 1에서 9까지이며 전체 패턴과 일치하는 하위 문자열을 삽입해야 함을 표시하기 위해 &lt;code&gt;\&amp;amp;&lt;/code&gt; 를 포함 할 수 있습니다 . 대체 텍스트에 리터럴 백 슬래시를 넣어야하는 경우 &lt;code&gt;\\&lt;/code&gt; 를 쓰십시오 . &lt;code&gt;flags&lt;/code&gt; 매개 변수는 함수의 동작을 변경 0 개 이상의 단일 문자 플래그를 포함한 옵션 텍스트 문자열입니다. 플래그 &lt;code&gt;i&lt;/code&gt; 는 대소 문자를 구분하지 않는 일치를 지정 하고 플래그 &lt;code&gt;g&lt;/code&gt; 는 첫 번째 문자열이 아닌 일치하는 각 하위 문자열의 대체를 지정합니다. 지원되는 플래그 ( &lt;code&gt;g&lt;/code&gt; 는 아님 )는 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5dbc2991320b01f06b6978f16f854503224464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_array&lt;/code&gt; function behaves the same as &lt;code&gt;regexp_split_to_table&lt;/code&gt;, except that &lt;code&gt;regexp_split_to_array&lt;/code&gt; returns its result as an array of &lt;code&gt;text&lt;/code&gt;. It has the syntax &lt;code&gt;regexp_split_to_array&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). The parameters are the same as for &lt;code&gt;regexp_split_to_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_array&lt;/code&gt; 기능과 같은 동작 &lt;code&gt;regexp_split_to_table&lt;/code&gt; 것을 제외 &lt;code&gt;regexp_split_to_array&lt;/code&gt; 는 배열로 그 결과를 돌려 &lt;code&gt;text&lt;/code&gt; . &lt;code&gt;regexp_split_to_array&lt;/code&gt; 구문 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ])이 있습니다. 매개 변수는 &lt;code&gt;regexp_split_to_table&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8a5d6df08eb9f63de1570ffdc8142a19efaaf0c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp_split_to_table&lt;/code&gt; function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax &lt;code&gt;regexp_split_to_table&lt;/code&gt;(&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). If there is no match to the &lt;code&gt;pattern&lt;/code&gt;, the function returns the &lt;code&gt;string&lt;/code&gt;. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The &lt;code&gt;flags&lt;/code&gt; parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. &lt;code&gt;regexp_split_to_table&lt;/code&gt; supports the flags described in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;regexp_split_to_table&lt;/code&gt; 함수는 구분 기호로 POSIX 정규 표현식 패턴을 사용하여 문자열을 분할합니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; 구문이 있습니다 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;pattern&lt;/code&gt; [, &lt;code&gt;flags&lt;/code&gt; ]). &lt;code&gt;pattern&lt;/code&gt; 과 일치하지 않으면이 함수는 &lt;code&gt;string&lt;/code&gt; 반환 합니다 . 일치하는 항목이 하나 이상있는 경우 각 일치 할 때마다 마지막 일치의 끝 (또는 문자열의 시작)부터 일치의 시작까지 텍스트를 반환합니다. 더 이상 일치하는 항목이 없으면 마지막 일치의 끝에서 문자열의 끝까지 텍스트를 반환합니다. &lt;code&gt;flags&lt;/code&gt; parameter는 함수의 동작을 변경하는 0 개 이상의 단일 문자 플래그를 포함하는 선택적 텍스트 문자열입니다. &lt;code&gt;regexp_split_to_table&lt;/code&gt; 은 &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;표 9.23에&lt;/a&gt; 설명 된 플래그를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9e8de7218b8205a5ca7a11a8952394be28359d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rejectlong&lt;/code&gt; parameter specifies whether an overlength integer should be truncated or ignored. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), the dictionary returns the first &lt;code&gt;maxlen&lt;/code&gt; digits of the integer. If &lt;code&gt;rejectlong&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the dictionary treats an overlength integer as a stop word, so that it will not be indexed. Note that this also means that such an integer cannot be searched for.</source>
          <target state="translated">&lt;code&gt;rejectlong&lt;/code&gt; 매개 변수 는 길이 가 긴 정수의 잘림 또는 무시 여부를 지정합니다. 경우 &lt;code&gt;rejectlong&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; (기본), 사전 반환 처음 &lt;code&gt;maxlen&lt;/code&gt; 을 정수의 숫자. 경우 &lt;code&gt;rejectlong&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 사전 치료가 인덱싱되지 않도록하는 중지 단어로 과도 길이의 정수. 이것은 또한 그러한 정수를 검색 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5f7fc02f4398b9958b820fde1c0031fecdf666d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rows&lt;/code&gt; value is a little tricky because it is not the number of rows processed or scanned by the plan node, but rather the number emitted by the node. This is often less than the number scanned, as a result of filtering by any &lt;code&gt;WHERE&lt;/code&gt;-clause conditions that are being applied at the node. Ideally the top-level rows estimate will approximate the number of rows actually returned, updated, or deleted by the query.</source>
          <target state="translated">&lt;code&gt;rows&lt;/code&gt; 가 계획 노드에 의해 처리되거나 스캐닝 행 수 있지만, 오히려 노드 방출 수가 없기 때문에 값이 조금 까다 롭다. 이는 노드에서 적용되는 &lt;code&gt;WHERE&lt;/code&gt; 절 조건에 의해 필터링 된 결과 스캔되는 수보다 적은 경우가 많습니다 . 이상적으로 최상위 행 추정치는 쿼리에 의해 실제로 반환, 업데이트 또는 삭제 된 행 수에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="32edd13f077af046b2b71b1ee64a9b61285ac864" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seg&lt;/code&gt; module includes a GiST index operator class for &lt;code&gt;seg&lt;/code&gt; values. The operators supported by the GiST operator class are shown in &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;Table F.28&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;seg&lt;/code&gt; 모듈 용 요지 지수 연산자 클래스 포함 &lt;code&gt;seg&lt;/code&gt; 값. GiST 연산자 클래스가 지원하는 연산자는 &lt;a href=&quot;seg#SEG-GIST-OPERATORS&quot;&gt;표 F.28&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="060f961f6a4bd265394e2d5e72b7544d4d3d9777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session_user&lt;/code&gt; is normally the user who initiated the current database connection; but superusers can change this setting with &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;. The &lt;code&gt;current_user&lt;/code&gt; is the user identifier that is applicable for permission checking. Normally it is equal to the session user, but it can be changed with &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. It also changes during the execution of functions with the attribute &lt;code&gt;SECURITY DEFINER&lt;/code&gt;. In Unix parlance, the session user is the &amp;ldquo;real user&amp;rdquo; and the current user is the &amp;ldquo;effective user&amp;rdquo;. &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; are synonyms for &lt;code&gt;current_user&lt;/code&gt;. (The SQL standard draws a distinction between &lt;code&gt;current_role&lt;/code&gt; and &lt;code&gt;current_user&lt;/code&gt;, but PostgreSQL does not, since it unifies users and roles into a single kind of entity.)</source>
          <target state="translated">&lt;code&gt;session_user&lt;/code&gt; 일반적으로 현재 데이터베이스 연결을 시작한 사용자입니다; 그러나 수퍼 유저는 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; 으로이 설정을 변경할 수 있습니다 . &lt;code&gt;current_user&lt;/code&gt; 권한 검사에 적용되는 사용자 식별자입니다. 일반적으로 세션 사용자와 동일하지만 &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 로 변경할 수 있습니다 . &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 속성을 가진 함수 실행 중에도 변경됩니다 . 유닉스 용어에서 세션 사용자는 &quot;실제 사용자&quot;이고 현재 사용자는 &quot;유효 사용자&quot;입니다. &lt;code&gt;current_role&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; 동의어입니다 &lt;code&gt;current_user&lt;/code&gt; . (SQL 표준은 &lt;code&gt;current_role&lt;/code&gt; 을 구별합니다.및 &lt;code&gt;current_user&lt;/code&gt; 는 기업의 하나의 종류로 사용자 및 역할을 통합하기 때문에,하지만, PostgreSQL는하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="2300a7ac4740013d2132caac3afdd183cf0cf9ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sestatus&lt;/code&gt; command allows you to check the status of SELinux. A typical display is:</source>
          <target state="translated">&lt;code&gt;sestatus&lt;/code&gt; 의 명령은 SELinux에의 상태를 확인할 수 있습니다. 일반적인 디스플레이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c1528675485f3ac22728a56ac6684f04d6015ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; setting is useful to have the instance ready at the exact replay point desired. The instance will still be able to replay more WAL records (and in fact will have to replay WAL records since the last checkpoint next time it is started).</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 설정은 원하는 정확한 재생 시점에서 인스턴스를 준비하는 데 유용합니다. 인스턴스는 여전히 더 많은 WAL 레코드를 재생할 수 있습니다 (실제로 다음에 시작될 때 체크 포인트 이후 WAL 레코드를 재생해야 함).</target>
        </trans-unit>
        <trans-unit id="0dfff4474b03b711fe3d607009c52f929707603f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simple&lt;/code&gt; dictionary template operates by converting the input token to lower case and checking it against a file of stop words. If it is found in the file then an empty array is returned, causing the token to be discarded. If not, the lower-cased form of the word is returned as the normalized lexeme. Alternatively, the dictionary can be configured to report non-stop-words as unrecognized, allowing them to be passed on to the next dictionary in the list.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; 사전 템플릿 소문자로 입력 토큰 변환 중지 워드의 파일에 대해이를 확인하여 동작한다. 파일에서 발견되면 빈 배열이 반환되어 토큰이 삭제됩니다. 그렇지 않은 경우, 소문자 형태의 단어가 정규화 된 exeme으로 리턴됩니다. 또는 사전이 아닌 단어를 인식 할 수없는 것으로보고하여 사전을 목록의 다음 사전으로 전달하도록 사전을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261a0b38493fc85b48b40ee18eb66df54582ef51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;soundex&lt;/code&gt; function converts a string to its Soundex code. The &lt;code&gt;difference&lt;/code&gt; function converts two strings to their Soundex codes and then reports the number of matching code positions. Since Soundex codes have four characters, the result ranges from zero to four, with zero being no match and four being an exact match. (Thus, the function is misnamed &amp;mdash; &lt;code&gt;similarity&lt;/code&gt; would have been a better name.)</source>
          <target state="translated">&lt;code&gt;soundex&lt;/code&gt; 함수는 Soundex와 코드를 문자열로 변환합니다. &lt;code&gt;difference&lt;/code&gt; 함수 변환 한 다음 그 두 Soundex와 코드와 문자열과 코드 위치 일치의 수를보고한다. Soundex 코드에는 4 개의 문자가 있으므로 결과 범위는 0에서 4까지이며 0은 일치하지 않으며 4는 정확히 일치합니다. (따라서 기능의 이름이 잘못 되었습니다. &lt;code&gt;similarity&lt;/code&gt; 이 더 나은 이름이었을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="09ea80f1981124188490dc9028b6ab305b1bc451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sql_standard&lt;/code&gt; style produces output that conforms to the SQL standard's specification for interval literal strings, if the interval value meets the standard's restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.</source>
          <target state="translated">&lt;code&gt;sql_standard&lt;/code&gt; 스타일은 출력을 생성하는 간격 리터럴 문자열에 대한 SQL 표준의 사양을 준수, 간격 값이 (긍정적이고 부정적인 요소없이 혼합하여 하나 만 년 - 월 또는 일 - 시간 만) 표준의 제한을 충족하는 경우. 그렇지 않으면 출력은 표준 년 월 리터럴 문자열 다음에 주간 리터럴 문자열이 표시되며 혼합 부호 간격을 명확하게하기 위해 명시 적 부호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1517c885d0f9ba998151ca37f036c0bd997847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sslinfo&lt;/code&gt; module provides information about the SSL certificate that the current client provided when connecting to PostgreSQL. The module is useless (most functions will return NULL) if the current connection does not use SSL.</source>
          <target state="translated">&lt;code&gt;sslinfo&lt;/code&gt; 의 모듈은 PostgreSQL을 연결할 때 현재의 클라이언트가 제공하는 SSL 인증서에 대한 정보를 제공합니다. 현재 연결에서 SSL을 사용하지 않으면 모듈이 쓸모가 없습니다 (대부분의 함수는 NULL을 반환 함).</target>
        </trans-unit>
        <trans-unit id="0d9a65154d6a387434a029c400053d901ea5349c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;storage&lt;/code&gt; parameter allows selection of storage strategies for variable-length data types. (Only &lt;code&gt;plain&lt;/code&gt; is allowed for fixed-length types.) &lt;code&gt;plain&lt;/code&gt; specifies that data of the type will always be stored in-line and not compressed. &lt;code&gt;extended&lt;/code&gt; specifies that the system will first try to compress a long data value, and will move the value out of the main table row if it's still too long. &lt;code&gt;external&lt;/code&gt; allows the value to be moved out of the main table, but the system will not try to compress it. &lt;code&gt;main&lt;/code&gt; allows compression, but discourages moving the value out of the main table. (Data items with this storage strategy might still be moved out of the main table if there is no other way to make a row fit, but they will be kept in the main table preferentially over &lt;code&gt;extended&lt;/code&gt; and &lt;code&gt;external&lt;/code&gt; items.)</source>
          <target state="translated">&lt;code&gt;storage&lt;/code&gt; 파라미터는 가변 길이 데이터 유형 스토리지 전략을 선택할 수있다. 고정 길이 유형에는 &lt;code&gt;plain&lt;/code&gt; 만 허용됩니다. &lt;code&gt;plain&lt;/code&gt; 은 유형의 데이터가 항상 인라인으로 저장되고 압축되지 않도록 지정합니다. &lt;code&gt;extended&lt;/code&gt; 는 시스템이 먼저 긴 데이터 값을 압축하려고 시도하고 여전히 너무 긴 경우 기본 테이블 행 밖으로 값을 이동하도록 지정합니다. &lt;code&gt;external&lt;/code&gt; 을 사용하면 값을 기본 테이블 밖으로 이동할 수 있지만 시스템은 압축을 시도하지 않습니다. &lt;code&gt;main&lt;/code&gt; 압축을 허용하지만 주 테이블에서 값을 이동하지 않는 것이 좋습니다. (이 스토리지 전략을 사용하는 데이터 항목은 행을 맞추는 다른 방법이없는 경우 여전히 기본 테이블에서 이동 될 수 있지만 &lt;code&gt;extended&lt;/code&gt; 및 &lt;code&gt;external&lt;/code&gt; 항목 보다 우선적으로 기본 테이블에 유지 됩니다.)</target>
        </trans-unit>
        <trans-unit id="17d900c212bdba8eb8ed8106792c420e1bbe3e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with three parameters provides extraction of a substring that matches an SQL regular expression pattern. The function can be written according to SQL99 syntax:</source>
          <target state="translated">세 개의 매개 변수가 있는 &lt;code&gt;substring&lt;/code&gt; 함수는 SQL 정규식 패턴과 일치하는 서브 스트링 추출을 제공합니다. SQL99 구문에 따라 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c583000c12edad2a23f1677f8c511b9802bf22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;substring&lt;/code&gt; function with two parameters, &lt;code&gt;substring(string from pattern)&lt;/code&gt;, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below.</source>
          <target state="translated">&lt;code&gt;substring(string from pattern)&lt;/code&gt; 이라는 두 개의 매개 변수가 있는 &lt;code&gt;substring&lt;/code&gt; 함수 는 POSIX 정규식 패턴과 일치하는 부분 문자열의 추출을 제공합니다. 일치하지 않으면 null을 반환하고 그렇지 않으면 패턴과 일치하는 텍스트 부분을 반환합니다. 그러나 패턴에 괄호가 포함되어 있으면 첫 번째 괄호로 묶인 하위 표현식 (왼쪽 괄호가 먼저 오는 부분)과 일치하는 텍스트 부분이 반환됩니다. 이 예외를 유발하지 않고 괄호를 사용하려면 전체 표현식을 괄호로 묶을 수 있습니다. 추출하려는 하위 표현식 이전에 패턴에 괄호가 필요한 경우 아래에 설명 된 비 캡처 괄호를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6de727710530de8b72a4404a0cd48c771eb547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;synonym&lt;/code&gt; template also has an optional parameter &lt;code&gt;CaseSensitive&lt;/code&gt;, which defaults to &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;CaseSensitive&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, words in the synonym file are folded to lower case, as are input tokens. When it is &lt;code&gt;true&lt;/code&gt;, words and tokens are not folded to lower case, but are compared as-is.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; 템플릿은 또한 선택적 매개 변수가 &lt;code&gt;CaseSensitive&lt;/code&gt; , 기본값은 &lt;code&gt;false&lt;/code&gt; . 경우 &lt;code&gt;CaseSensitive&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; , 동의어 파일 단어로서 입력 토큰이고, 소문자로 절첩되어있다. 이 경우 &lt;code&gt;true&lt;/code&gt; 단어와 토큰은 소문자로 절첩되지 않고 그대로 비교된다.</target>
        </trans-unit>
        <trans-unit id="c07e672b3264d398cb9ebee058a21feb90ad8f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_len&lt;/code&gt; will always be greater than the sum of the &lt;code&gt;tuple_len&lt;/code&gt;, &lt;code&gt;dead_tuple_len&lt;/code&gt; and &lt;code&gt;free_space&lt;/code&gt;. The difference is accounted for by fixed page overhead, the per-page table of pointers to tuples, and padding to ensure that tuples are correctly aligned.</source>
          <target state="translated">&lt;code&gt;table_len&lt;/code&gt; 는 항상의 합보다 클 것이다 &lt;code&gt;tuple_len&lt;/code&gt; , &lt;code&gt;dead_tuple_len&lt;/code&gt; 및 &lt;code&gt;free_space&lt;/code&gt; . 차이점은 고정 페이지 오버 헤드, 튜플에 대한 페이지 당 포인터 테이블 및 튜플이 올바르게 정렬되도록 패딩으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f00658cdbd1a37668746a630df6795de40f40a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablefunc&lt;/code&gt; module includes various functions that return tables (that is, multiple rows). These functions are useful both in their own right and as examples of how to write C functions that return multiple rows.</source>
          <target state="translated">&lt;code&gt;tablefunc&lt;/code&gt; 의 모듈은 다양한 기능이 반송 테이블 (인 여러 행)를 포함한다. 이러한 함수는 자체적으로 유용하며 여러 행을 반환하는 C 함수를 작성하는 방법의 예로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf44adfa31acc1639b19ed48b2eb69211df790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new materialized view is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 구체화 된 뷰가 작성 될 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ab317f2006a81d25a82a98e87d5a85e8a273f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 테이블이 작성되는 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 를 참조하거나 테이블이 임시 인 경우 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f686e75d0e393aa19100c981a93d00a43780aed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tablespace_name&lt;/code&gt; is the name of the tablespace in which the new table is to be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overrides &lt;code&gt;default_tablespace&lt;/code&gt; as the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.</source>
          <target state="translated">&lt;code&gt;tablespace_name&lt;/code&gt; 새로운 테이블이 작성되는 테이블 스페이스의 이름입니다. 지정하지 않으면 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 를 참조하거나 테이블이 임시 인 경우 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces를&lt;/a&gt; 참조 하십시오. 파티션 된 테이블의 경우 테이블 자체에 스토리지가 필요하지 않기 때문에 지정된 테이블 스페이스는 &lt;code&gt;default_tablespace&lt;/code&gt; 를 다른 테이블 스페이스가 명시 적으로 지정되지 않은 경우 새로 작성된 파티션에 사용할 기본 테이블 스페이스로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="0b4265a037b613093215c3a2b0f1964512919269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tcn&lt;/code&gt; module provides a trigger function that notifies listeners of changes to any table on which it is attached. It must be used as an &lt;code&gt;AFTER&lt;/code&gt; trigger &lt;code&gt;FOR EACH ROW&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tcn&lt;/code&gt; 모듈은 트리거 기능을 제공가 장착되어있는 모든 테이블의 변경 통지 리스너있다. &lt;code&gt;FOR EACH ROW&lt;/code&gt; &lt;code&gt;AFTER&lt;/code&gt; 트리거 로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17aaa8650f37c6cdde06430e667abefb0767b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_char&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;to_char&lt;/code&gt; 기능의 가족</target>
        </trans-unit>
        <trans-unit id="e895ae79ff8443b98ab632e79a7fde4140eb2a9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_regclass&lt;/code&gt;, &lt;code&gt;to_regproc&lt;/code&gt;, &lt;code&gt;to_regprocedure&lt;/code&gt;, &lt;code&gt;to_regoper&lt;/code&gt;, &lt;code&gt;to_regoperator&lt;/code&gt;, &lt;code&gt;to_regtype&lt;/code&gt;, &lt;code&gt;to_regnamespace&lt;/code&gt;, and &lt;code&gt;to_regrole&lt;/code&gt; functions translate relation, function, operator, type, schema, and role names (given as &lt;code&gt;text&lt;/code&gt;) to objects of type &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, and &lt;code&gt;regrole&lt;/code&gt; respectively. These functions differ from a cast from text in that they don't accept a numeric OID, and that they return null rather than throwing an error if the name is not found (or, for &lt;code&gt;to_regproc&lt;/code&gt; and &lt;code&gt;to_regoper&lt;/code&gt;, if the given name matches multiple objects).</source>
          <target state="translated">&lt;code&gt;to_regclass&lt;/code&gt; , &lt;code&gt;to_regproc&lt;/code&gt; , &lt;code&gt;to_regprocedure&lt;/code&gt; , &lt;code&gt;to_regoper&lt;/code&gt; , &lt;code&gt;to_regoperator&lt;/code&gt; , &lt;code&gt;to_regtype&lt;/code&gt; , &lt;code&gt;to_regnamespace&lt;/code&gt; 및 &lt;code&gt;to_regrole&lt;/code&gt; 함수 (같이 주어진 관계 함수 운영자 입력, 스키마 및 역할 이름 번역 &lt;code&gt;text&lt;/code&gt; 형식의 개체) &lt;code&gt;regclass&lt;/code&gt; 형 , &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; 을 , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regnamespace&lt;/code&gt; 및 &lt;code&gt;regrole&lt;/code&gt; 각기. 이러한 함수는 숫자 OID를 허용하지 않으며 이름을 찾을 수없는 경우 (또는 주어진 이름이 여러 객체와 일치하는 경우 &lt;code&gt;to_regproc&lt;/code&gt; 및 &lt;code&gt;to_regoper&lt;/code&gt; 의 경우) 오류를 발생시키지 않고 null을 반환한다는 점에서 텍스트 캐스트 와 다릅니다 . ).</target>
        </trans-unit>
        <trans-unit id="9bc966f611788c95433ef51cb7b635ecd99368eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_tsvector&lt;/code&gt; function internally calls a parser which breaks the document text into tokens and assigns a type to each token. For each token, a list of dictionaries (&lt;a href=&quot;textsearch-dictionaries&quot;&gt;Section 12.6&lt;/a&gt;) is consulted, where the list can vary depending on the token type. The first dictionary that &lt;em&gt;recognizes&lt;/em&gt; the token emits one or more normalized &lt;em&gt;lexemes&lt;/em&gt; to represent the token. For example, &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt; because one of the dictionaries recognized that the word &lt;code&gt;rats&lt;/code&gt; is a plural form of &lt;code&gt;rat&lt;/code&gt;. Some words are recognized as &lt;em&gt;stop words&lt;/em&gt; (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;), which causes them to be ignored since they occur too frequently to be useful in searching. In our example these are &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;it&lt;/code&gt;. If no dictionary in the list recognizes the token then it is also ignored. In this example that happened to the punctuation sign &lt;code&gt;-&lt;/code&gt; because there are in fact no dictionaries assigned for its token type (&lt;code&gt;Space symbols&lt;/code&gt;), meaning space tokens will never be indexed. The choices of parser, dictionaries and which types of tokens to index are determined by the selected text search configuration (&lt;a href=&quot;textsearch-configuration&quot;&gt;Section 12.7&lt;/a&gt;). It is possible to have many different configurations in the same database, and predefined configurations are available for various languages. In our example we used the default configuration &lt;code&gt;english&lt;/code&gt; for the English language.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 의 기능은 내부적으로 토큰으로 문서 텍스트를 중단하고 각 토큰 유형을 할당하는 파서를 호출합니다. 각 토큰에 대해 사전 목록 ( &lt;a href=&quot;textsearch-dictionaries&quot;&gt;12.6 절&lt;/a&gt; )을 참조하면 토큰 유형에 따라 목록이 다를 수 있습니다. 토큰 을 &lt;em&gt;인식&lt;/em&gt; 하는 첫 번째 사전 은 토큰 을 나타 내기 위해 하나 이상의 정규화 된 &lt;em&gt;렉스&lt;/em&gt; 를 방출 합니다. 예를 들어, &lt;code&gt;rats&lt;/code&gt; 가되었다 &lt;code&gt;rat&lt;/code&gt; 사전의 중 하나가 단어 것으로 인식하기 때문에 &lt;code&gt;rats&lt;/code&gt; 의 복수 형태이다 &lt;code&gt;rat&lt;/code&gt; . 일부 단어는 &lt;em&gt;중지&lt;/em&gt; 단어로 인식됩니다 ( &lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;12.6.1 단원)&lt;/a&gt;)가 너무 자주 발생하여 검색에 유용하지 않으므로 무시됩니다. 이 예에서 이들은 , &lt;code&gt;on&lt;/code&gt; , 그리고 &lt;code&gt;it&lt;/code&gt; . 목록에서 사전을 인식하지 못하면 토큰도 무시됩니다. 구두점 기호에게 무슨 일이 예에서 &lt;code&gt;-&lt;/code&gt; 그 토큰 유형에 할당 된 사전 (사실이 없기 때문에 &lt;code&gt;Space symbols&lt;/code&gt; ), 즉 공간 토큰은 인덱싱되지 않습니다. 파서, 사전 및 색인을 생성 할 토큰의 선택은 선택한 텍스트 검색 구성에 따라 결정됩니다 ( &lt;a href=&quot;textsearch-configuration&quot;&gt;섹션 12.7)&lt;/a&gt; &lt;code&gt;a&lt;/code&gt; ). 동일한 데이터베이스에서 다양한 구성을 수행 할 수 있으며 다양한 언어에 대해 사전 정의 된 구성을 사용할 수 있습니다. 이 예에서는 &lt;code&gt;english&lt;/code&gt; 에 기본 구성 영어 를 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="25a8b2b35ba5bb7ac691f2af5d9013c610a29764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function expects a single &lt;em&gt;token&lt;/em&gt;, not text. Here is a case where this can be confusing:</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; 의 기능은 하나의 기대 &lt;em&gt;토큰&lt;/em&gt; , 텍스트가 아닌. 혼동 될 수있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="414a4e254a9e67a84663f59263f88c95c42cfbfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_lexize&lt;/code&gt; function facilitates dictionary testing.</source>
          <target state="translated">&lt;code&gt;ts_lexize&lt;/code&gt; 의 기능은 사전 테스트를 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="4acca59985cbdc80cca43fe97ac114ac2ea61d90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ts_rewrite&lt;/code&gt; family of functions search a given &lt;code&gt;tsquery&lt;/code&gt; for occurrences of a target subquery, and replace each occurrence with a substitute subquery. In essence this operation is a &lt;code&gt;tsquery&lt;/code&gt;-specific version of substring replacement. A target and substitute combination can be thought of as a &lt;em&gt;query rewrite rule&lt;/em&gt;. A collection of such rewrite rules can be a powerful search aid. For example, you can expand the search using synonyms (e.g., &lt;code&gt;new york&lt;/code&gt;, &lt;code&gt;big apple&lt;/code&gt;, &lt;code&gt;nyc&lt;/code&gt;, &lt;code&gt;gotham&lt;/code&gt;) or narrow the search to direct the user to some hot topic. There is some overlap in functionality between this feature and thesaurus dictionaries (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;). However, you can modify a set of rewrite rules on-the-fly without reindexing, whereas updating a thesaurus requires reindexing to be effective.</source>
          <target state="translated">&lt;code&gt;ts_rewrite&lt;/code&gt; 의 계열의 함수는 주어진 검색 &lt;code&gt;tsquery&lt;/code&gt; 타겟 부질의 발생을위한, 그리고 대체 부질 각 항목을 바꾸. 본질적으로이 작업은 &lt;code&gt;tsquery&lt;/code&gt; 특정 버전의 부분 문자열 대체입니다. 대상 및 대체 조합은 &lt;em&gt;쿼리 다시 쓰기 규칙&lt;/em&gt; 으로 생각할 수 있습니다 . 이러한 재 작성 규칙 모음은 강력한 검색 지원이 될 수 있습니다. 예를 들어 동의어 (예 : &lt;code&gt;new york&lt;/code&gt; , &lt;code&gt;big apple&lt;/code&gt; , &lt;code&gt;nyc&lt;/code&gt; , &lt;code&gt;gotham&lt;/code&gt; )를 사용하여 검색을 확장하거나 검색 범위를 좁혀서 사용자를 인기 주제로 안내 할 수 있습니다. 이 기능과 동의어 사전 사전간에 기능이 일부 겹칩니다 (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;섹션 12.6.4&lt;/a&gt; ). 그러나 재 인덱싱 없이도 즉시 재 작성 규칙 세트를 수정할 수 있지만 동의어 사전을 업데이트하려면 재 인덱싱이 효과적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5ce57d748f7a336aa1b84fb89aaf298351d6555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_rows&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_ROWS&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_rows&lt;/code&gt; 용 모듈에있어서 샘플링 테이블 제공 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 에서 사용될 수 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 (A)의 절 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="ec2660bd7bfa7364869659c121d8520debb99419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsm_system_time&lt;/code&gt; module provides the table sampling method &lt;code&gt;SYSTEM_TIME&lt;/code&gt;, which can be used in the &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause of a &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;tsm_system_time&lt;/code&gt; 의 모듈은 테이블 추출법에 제공 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; 에서 사용될 수 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 의 (A)의 절 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="390aa178cbfa17e56fd10d81213ce2e7d202995c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsquery&lt;/code&gt; containment operators consider only the lexemes listed in the two queries, ignoring the combining operators.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 의 포함 연산자는 결합 연산자를 무시하고 두 개의 쿼리에 나열에만 어휘를 고려한다.</target>
        </trans-unit>
        <trans-unit id="d94003b7d5e3893485cdec1b88bc0aea54d3d7f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsvector&lt;/code&gt; concatenation operator returns a vector which combines the lexemes and positional information of the two vectors given as arguments. Positions and weight labels are retained during the concatenation. Positions appearing in the right-hand vector are offset by the largest position mentioned in the left-hand vector, so that the result is nearly equivalent to the result of performing &lt;code&gt;to_tsvector&lt;/code&gt; on the concatenation of the two original document strings. (The equivalence is not exact, because any stop-words removed from the end of the left-hand argument will not affect the result, whereas they would have affected the positions of the lexemes in the right-hand argument if textual concatenation were used.)</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 의 연결 연산자는 어휘 및 인수로 주어진 두 벡터의 위치 정보를 결합한 벡터를 리턴한다. 연결하는 동안 위치 및 무게 레이블이 유지됩니다. 오른쪽 벡터에 나타나는 위치는 왼쪽 벡터에 언급 된 가장 큰 위치로 오프셋되므로 결과는 두 원본 문서 문자열의 연결에서 &lt;code&gt;to_tsvector&lt;/code&gt; 를 수행 한 결과와 거의 같습니다 . (왼쪽 인수의 끝에서 제거 된 모든 단어는 결과에 영향을 미치지 않지만 텍스트 연결이 사용 된 경우 오른쪽 인수의 렉 세스 위치에 영향을 주었으므로 동등성은 정확하지 않습니다. )</target>
        </trans-unit>
        <trans-unit id="64e34183b8dfafa188cf43b0a5c4b0041a97f2d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unaccent()&lt;/code&gt; function removes accents (diacritic signs) from a given string. Basically, it's a wrapper around &lt;code&gt;unaccent&lt;/code&gt;-type dictionaries, but it can be used outside normal text search contexts.</source>
          <target state="translated">&lt;code&gt;unaccent()&lt;/code&gt; 함수는 주어진 문자열에서 액센트 (분음 부호)를 제거합니다. 기본적으로 이것은 &lt;code&gt;unaccent&lt;/code&gt; 유형 사전 의 래퍼 이지만 일반 텍스트 검색 컨텍스트 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb54fa28d01791fcb6f7f658cdfdf7f9c3926fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;, and &lt;code&gt;initcap&lt;/code&gt; functions</source>
          <target state="translated">은 &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , 및 &lt;code&gt;initcap&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="dae2537a13fb0c8fd0778a9239206e8184aecf1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uuid-ossp&lt;/code&gt; module provides functions to generate universally unique identifiers (UUIDs) using one of several standard algorithms. There are also functions to produce certain special UUID constants.</source>
          <target state="translated">&lt;code&gt;uuid-ossp&lt;/code&gt; 모듈은 여러 표준 알고리즘 중 하나를 사용하여 범용 고유 식별자 (UUID를)를 생성하는 기능을 제공한다. 특정 특수 UUID 상수를 생성하는 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33dc4b6b3f3d4e4e7276aab8066c7be89f11d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; must be a number. In general, the higher the number the more borders and lines the tables will have, but details depend on the particular format. In HTML format, this will translate directly into the &lt;code&gt;border=...&lt;/code&gt; attribute. In most other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense, and values above 2 will be treated the same as &lt;code&gt;border = 2&lt;/code&gt;. The &lt;code&gt;latex&lt;/code&gt; and &lt;code&gt;latex-longtable&lt;/code&gt; formats additionally allow a value of 3 to add dividing lines between data rows.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 숫자 여야합니다. 일반적으로 숫자가 많을수록 테이블의 테두리와 선이 많아 지지만 세부 사항은 특정 형식에 따라 다릅니다. HTML 형식에서는 &lt;code&gt;border=...&lt;/code&gt; 속성 으로 직접 변환됩니다 . 대부분의 다른 형식에서는 값 0 (경계선 없음), 1 (내부 분할 선) 및 2 (테이블 프레임) 만 의미가 있으며 2보다 큰 값은 &lt;code&gt;border = 2&lt;/code&gt; 와 동일하게 취급됩니다 . &lt;code&gt;latex&lt;/code&gt; 및 &lt;code&gt;latex-longtable&lt;/code&gt; 형식 별도로 3의 값이 데이터 행 사이의 구분선에 추가 할 수있다.</target>
        </trans-unit>
        <trans-unit id="2ed006ed7919dad8517461e6b9bbcdfb9261bd7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait_event&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; columns are independent. If a backend is in the &lt;code&gt;active&lt;/code&gt; state, it may or may not be &lt;code&gt;waiting&lt;/code&gt; on some event. If the state is &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;wait_event&lt;/code&gt; is non-null, it means that a query is being executed, but is being blocked somewhere in the system.</source>
          <target state="translated">&lt;code&gt;wait_event&lt;/code&gt; 및 &lt;code&gt;state&lt;/code&gt; 열은 독립적이다. 백엔드가 &lt;code&gt;active&lt;/code&gt; 상태 인 경우 일부 이벤트를 &lt;code&gt;waiting&lt;/code&gt; 거나 대기 하지 않을 수 있습니다 . 상태가 &lt;code&gt;active&lt;/code&gt; 이고 &lt;code&gt;wait_event&lt;/code&gt; 가 널이 아닌 경우, 쿼리가 실행되고 있지만 시스템 어딘가에서 차단되고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0125e5f4ec341f59b7fbf88d54a9be3ac7c60904" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml2&lt;/code&gt; module provides XPath querying and XSLT functionality.</source>
          <target state="translated">&lt;code&gt;xml2&lt;/code&gt; 의 모듈의 XPath 쿼리 및 XSLT 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8ee7c238579a8efef3d1bbe76947df3fd98bf79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type can be used to store XML data. Its advantage over storing XML data in a &lt;code&gt;text&lt;/code&gt; field is that it checks the input values for well-formedness, and there are support functions to perform type-safe operations on it; see &lt;a href=&quot;functions-xml&quot;&gt;Section 9.14&lt;/a&gt;. Use of this data type requires the installation to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식은 XML 데이터를 저장하는 데 사용할 수 있습니다. &lt;code&gt;text&lt;/code&gt; 필드 에 XML 데이터를 저장하는 것의 장점 은 입력 값의 형식이 올바른지 확인하고 형식 안전 연산을 수행하는 지원 기능이 있다는 것입니다. &lt;a href=&quot;functions-xml&quot;&gt;섹션 9.14&lt;/a&gt; 참조 . 이 데이터 유형을 사용하려면 &lt;code&gt;configure --with-libxml&lt;/code&gt; 로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e872bad693cf86fd556718feb449776c1f39b558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; data type is unusual in that it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an &lt;code&gt;xml&lt;/code&gt; column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 데이터 형식은 어떤 비교 연산자를 제공하지 않는다는 점에서 특별하다. XML 데이터에 대해 잘 정의되고 보편적으로 유용한 비교 알고리즘이 없기 때문입니다. 그 결과 &lt;code&gt;xml&lt;/code&gt; 열을 검색 값 과 비교하여 행을 검색 할 수 없습니다 . 따라서 XML 값에는 일반적으로 ID와 같은 별도의 키 필드가 수반되어야합니다. XML 값을 비교하는 대체 솔루션은 먼저 값을 문자열로 변환하는 것이지만 문자열 비교는 유용한 XML 비교 방법과 관련이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="59e179d52ab69f7b0f66292f2459b29798716de6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type can store well-formed &amp;ldquo;documents&amp;rdquo;, as defined by the XML standard, as well as &amp;ldquo;content&amp;rdquo; fragments, which are defined by reference to the more permissive &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&amp;ldquo;document node&amp;rdquo;&lt;/a&gt; of the XQuery and XPath data model. Roughly, this means that content fragments can have more than one top-level element or character node. The expression &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; can be used to evaluate whether a particular &lt;code&gt;xml&lt;/code&gt; value is a full document or only a content fragment.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 더 관대 참조하여 정의 된 XML 표준뿐만 아니라, &quot;콘텐츠&quot;단편으로 정의 된 타입은, &quot;문서&quot;잘 형성된 저장할 수있는 &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode&quot;&gt;&quot;문서 노드&quot;&lt;/a&gt; XQuery에 및 XPath는 데이터 모델. 대략 이것은 콘텐츠 조각에 둘 이상의 최상위 요소 또는 문자 노드가있을 수 있음을 의미합니다. &lt;code&gt;xmlvalue IS DOCUMENT&lt;/code&gt; 표현식을 사용하여 특정 &lt;code&gt;xml&lt;/code&gt; 값이 전체 문서인지 컨텐츠 조각 인지를 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70fece117905c5ca56558a0c032db75b892af97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xml&lt;/code&gt; type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML Schema.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 유형은 입력 값이 DTD를 지정 되더라도, 문서 형 선언 (DTD)에 대한 검증되지 입력 값을한다. 또한 현재 XML 스키마와 같은 다른 XML 스키마 언어에 대한 유효성 검사를위한 기본 지원 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1deef1e666f438cec77e8c3e2e2981fe717c4002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlelement&lt;/code&gt; expression produces an XML element with the given name, attributes, and content.</source>
          <target state="translated">&lt;code&gt;xmlelement&lt;/code&gt; 표현은 지정된 이름, 특성, 및 콘텐츠와 XML 요소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="69f2f71a5ec8ec9b6b661345ad1ff563285eb198" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlforest&lt;/code&gt; expression produces an XML forest (sequence) of elements using the given names and content.</source>
          <target state="translated">&lt;code&gt;xmlforest&lt;/code&gt; 표현은 주어진 이름과 내용을 사용하여 요소의 XML 숲 (순서)를 생성한다.</target>
        </trans-unit>
        <trans-unit id="c704d359323afbae05aea7d4c253db38a9779402" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlpi&lt;/code&gt; expression creates an XML processing instruction. The content, if present, must not contain the character sequence &lt;code&gt;?&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xmlpi&lt;/code&gt; 의 발현은 XML 처리 명령을 생성한다. 컨텐츠는 존재하는 경우 문자 시퀀스 &lt;code&gt;?&amp;gt;&lt;/code&gt; 를 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="483ff2aaee5c62e793871dd92a52c8a7e7cf4d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmlroot&lt;/code&gt; expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node's version declaration; if a standalone setting is specified, it replaces the value in the root node's standalone declaration.</source>
          <target state="translated">&lt;code&gt;xmlroot&lt;/code&gt; 의 표현 달라져있는 XML 값의 루트 노드의 속성. 버전이 지정되면 루트 노드 버전 선언의 값을 대체합니다. 독립형 설정을 지정하면 루트 노드의 독립형 선언 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="194749c8350686b704674839bea4fca3eca2b901" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xmltable&lt;/code&gt; function produces a table based on the given XML value, an XPath filter to extract rows, and a set of column definitions.</source>
          <target state="translated">&lt;code&gt;xmltable&lt;/code&gt; 함수는 주어진 XML 값 추출 된 행에 대한 XPath는 필터 및 열 정의 세트에 기초하여 테이블을 생성한다.</target>
        </trans-unit>
        <trans-unit id="241345ed65eaa6c1efb430df3084f0d4151592bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xpath_table&lt;/code&gt; function assumes that the results of each XPath query might be multivalued, so the number of rows returned by the function may not be the same as the number of input documents. The first row returned contains the first result from each query, the second row the second result from each query. If one of the queries has fewer values than the others, null values will be returned instead.</source>
          <target state="translated">&lt;code&gt;xpath_table&lt;/code&gt; 함수는 함수에 의해 반환되는 행의 수를 입력 문서의 수와 동일하지 않을 수 있도록 각 XPath 쿼리의 결과, 여러 값을 가질 수 있다고 가정합니다. 반환 된 첫 번째 행에는 각 쿼리의 첫 번째 결과가, 두 번째 행에는 각 쿼리의 두 번째 결과가 포함됩니다. 쿼리 중 하나가 다른 것보다 적은 값을 갖는 경우 대신 널값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8f26d57e1c368d060299c1c81b28042f79fcca60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; operator concatenates the elements at the top level of each of its operands. It does not operate recursively. For example, if both operands are objects with a common key field name, the value of the field in the result will just be the value from the right hand operand.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 연산자는 각 피연산자의 최상위 레벨에서 요소를 연결합니다. 재귀 적으로 작동하지 않습니다. 예를 들어 두 피연산자가 모두 공통 키 필드 이름을 가진 객체 인 경우 결과의 필드 값은 오른쪽 피연산자의 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="25839180048fba8f8f9437939d20a2f9e4fca2ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&amp;gt;&lt;/code&gt; operator can also be used in this way to efficiently retrieve the first few values sorted by a selected coordinate. For example, to get the first few cubes ordered by the first coordinate (lower left corner) ascending one could use the following query:</source>
          <target state="translated">이 방법으로 &lt;code&gt;~&amp;gt;&lt;/code&gt; 연산자를 사용하여 선택한 좌표로 정렬 된 처음 몇 개의 값을 효율적으로 검색 할 수 있습니다. 예를 들어, 첫 번째 좌표 (왼쪽 아래) 오름차순으로 정렬 된 처음 몇 개의 큐브를 가져 오려면 다음 쿼리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="809dd3cf23829e5aba0aac6f0c8cd829bcb11269" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexCorrelation&lt;/code&gt;&lt;/em&gt; should be set to the correlation (ranging between -1.0 and 1.0) between the index order and the table order. This is used to adjust the estimate for the cost of fetching rows from the parent table.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexCorrelation&lt;/code&gt; 는&lt;/em&gt; 상관 설정되어야 번호순 테이블 간의 순서 (범위 -1.0 내지 1.0). 부모 테이블에서 행을 가져 오는 비용에 대한 추정치를 조정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d81aee55a8d4dcdc2397573ababbf7924223c018" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexPages&lt;/code&gt;&lt;/em&gt; should be set to the number of leaf pages. This is used to estimate the number of workers for parallel index scan.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexPages&lt;/code&gt; 은&lt;/em&gt; 리프 페이지의 수를 설정해야합니다. 병렬 인덱스 스캔 작업자 수를 추정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7685e1c43506ada1cffddeedf06115e445c9d085" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;indexSelectivity&lt;/code&gt;&lt;/em&gt; should be set to the estimated fraction of the parent table rows that will be retrieved during the index scan. In the case of a lossy query, this will typically be higher than the fraction of rows that actually pass the given qual conditions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;indexSelectivity&lt;/code&gt; 는&lt;/em&gt; 인덱스 스캔 중에 취득되는 상위 테이블 행의 예상 비율을 설정한다. 손실 쿼리의 경우 일반적으로 주어진 규정 조건을 실제로 통과하는 행의 비율보다 높습니다.</target>
        </trans-unit>
        <trans-unit id="ae5c470364e9e087f35c4b0de71e765afe691f23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter lets the user specify the iteration count, for algorithms that have one. The higher the count, the more time it takes to hash the password and therefore the more time to break it. Although with too high a count the time to calculate a hash may be several years &amp;mdash; which is somewhat impractical. If the &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; parameter is omitted, the default iteration count is used. Allowed values for &lt;em&gt;&lt;code&gt;iter_count&lt;/code&gt;&lt;/em&gt; depend on the algorithm and are shown in &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;Table F.17&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 매개 변수는 사용자가 하나가 알고리즘, 반복 횟수를 지정할 수 있습니다. 카운트가 높을수록 암호를 해시하는 데 더 많은 시간이 걸리므로 암호를 해독하는 데 더 많은 시간이 걸립니다. 카운트가 너무 많으면 해시를 계산하는 데 몇 년이 걸릴 수 있습니다. 이는 다소 비현실적입니다. 경우 &lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 매개 변수를 생략, 기본 반복 횟수가 사용됩니다. &lt;em&gt; &lt;code&gt;iter_count&lt;/code&gt; &lt;/em&gt; 에 허용되는 값 은 알고리즘에 따라 다르며 &lt;a href=&quot;pgcrypto#PGCRYPTO-ICFC-TABLE&quot;&gt;표 F.17&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b20f1e5072b09c8c12330c4cbb5380dc3c53e3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;options&lt;/code&gt;&lt;/em&gt; parameter can contain option settings, as described below.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;options&lt;/code&gt; &lt;/em&gt; 아래와 같이 매개 변수는 옵션 설정을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="048387eb78e0888018ae5bf5cface4e6e6cf82bc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;sql&lt;/code&gt;&lt;/em&gt; parameter is a SQL statement that produces the source set of data. This statement must return one &lt;code&gt;row_name&lt;/code&gt; column, one &lt;code&gt;category&lt;/code&gt; column, and one &lt;code&gt;value&lt;/code&gt; column. &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is an obsolete parameter, ignored if supplied (formerly this had to match the number of output value columns, but now that is determined by the calling query).</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;sql&lt;/code&gt; &lt;/em&gt; 매개 변수는 데이터의 소스 세트를 생성하는 SQL 문입니다. 이 명령문은 하나의 &lt;code&gt;row_name&lt;/code&gt; 컬럼, 하나의 &lt;code&gt;category&lt;/code&gt; 컬럼 및 하나의 &lt;code&gt;value&lt;/code&gt; 컬럼을 리턴해야합니다 . &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 사용되지 않는 매개 변수이며, 제공되는 경우 무시됩니다 (이전의 출력 값 열 수와 일치해야하지만 이제는 호출 쿼리에 의해 결정됨).</target>
        </trans-unit>
        <trans-unit id="a58a0a84dc580d747afb8a21f647c284a9244868" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; parameter specifies the hashing algorithm. The accepted types are: &lt;code&gt;des&lt;/code&gt;, &lt;code&gt;xdes&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 파라미터는 해시 알고리즘을 지정한다. 허용되는 유형은 &lt;code&gt;des&lt;/code&gt; , &lt;code&gt;xdes&lt;/code&gt; , &lt;code&gt;md5&lt;/code&gt; 및 &lt;code&gt;bf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="484484b19f7f2f2b36524197848aeb0d9d4987ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Julian Date&lt;/em&gt; system is another type of calendar, unrelated to the Julian calendar though it is confusingly named similarly to that calendar. The Julian Date system was invented by the French scholar Joseph Justus Scaliger (1540-1609) and probably takes its name from Scaliger's father, the Italian scholar Julius Caesar Scaliger (1484-1558). In the Julian Date system, each day has a sequential number, starting from JD 0 (which is sometimes called &lt;em&gt;the&lt;/em&gt; Julian Date). JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or 24 November 4714 BC in the Gregorian calendar. Julian Date counting is most often used by astronomers for labeling their nightly observations, and therefore a date runs from noon UTC to the next noon UTC, rather than from midnight to midnight: JD 0 designates the 24 hours from noon UTC on 24 November 4714 BC to noon UTC on 25 November 4714 BC.</source>
          <target state="translated">&lt;em&gt;율리우스 날짜&lt;/em&gt; 시스템은이 혼동이 일정 유사 이름 불구하고 율리우스 력과 관련이없는 달력의 또 다른 유형이다. Julian Date 시스템은 프랑스 학자 Joseph Justus Scaliger (1540-1609)가 발명했으며 아마도 Scaliger의 아버지 인 이탈리아 학자 Julius Caesar Scaliger (1484-1558)의 이름을 따를 것입니다. 율리우스 날짜 시스템에서, 매일이라고도한다 JD 0 (부터 순차적으로 번호가&lt;em&gt;&lt;/em&gt;율리우스 날짜). JD 0은 율리우스 력으로 BC 4713 년 1 월 1 일 또는 그레고리력으로 4714 년 11 월 24 일 BC에 해당합니다. 율리우스 날짜 계산은 천문학자가 야간 관측에 레이블을 지정하는 데 가장 자주 사용되므로 날짜는 자정에서 자정이 아닌 정오 UTC에서 다음 정오 UTC로 실행됩니다. 4714 년 11 월 25 일 UTC 정오까지.</target>
        </trans-unit>
        <trans-unit id="c767ea884019c639904724de55aaea8a6ef4f2e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Repeatable Read&lt;/em&gt; isolation level only sees data committed before the transaction began; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions. (However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.) This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt; except for serialization anomalies. As mentioned above, this is specifically allowed by the standard, which only describes the &lt;em&gt;minimum&lt;/em&gt; protections each isolation level must provide.</source>
          <target state="translated">&lt;em&gt;반복 읽기의&lt;/em&gt; 분리 레벨은 트랜잭션이 시작되기 전에 최선을 다하고 데이터를보고, 커밋되지 않은 데이터 나 동시 트랜잭션이 트랜잭션을 실행하는 동안 커밋 된 변경 내용은 절대 볼 수 없습니다. 그러나 쿼리는 아직 커밋되지 않았더라도 자체 트랜잭션 내에서 실행 된 이전 업데이트의 영향을 확인합니다. 이는이 격리 수준에 대해 SQL 표준에서 요구하는 것보다 더 강력한 보장이며 모든 현상을 방지합니다. 직렬화 이상을 제외하고 &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;표 13.1에&lt;/a&gt; 설명되어 있습니다. 위에서 언급했듯이, 이는 표준에 의해 특별히 허용되며, 각 격리 수준이 제공해야하는 &lt;em&gt;최소&lt;/em&gt; 보호 만 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cbb4655ce1c4dfa140be7dcae24f9bc53c423c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Serializable&lt;/em&gt; isolation level provides the strictest transaction isolation. This level emulates serial transaction execution for all committed transactions; as if transactions had been executed one after another, serially, rather than concurrently. However, like the Repeatable Read level, applications using this level must be prepared to retry transactions due to serialization failures. In fact, this isolation level works exactly the same as Repeatable Read except that it monitors for conditions which could make execution of a concurrent set of serializable transactions behave in a manner inconsistent with all possible serial (one at a time) executions of those transactions. This monitoring does not introduce any blocking beyond that present in repeatable read, but there is some overhead to the monitoring, and detection of the conditions which could cause a &lt;em&gt;serialization anomaly&lt;/em&gt; will trigger a &lt;em&gt;serialization failure&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;직렬화&lt;/em&gt;격리 수준은 가장 엄격한 트랜잭션 격리를 제공합니다. 이 레벨은 커밋 된 모든 트랜잭션에 대한 직렬 트랜잭션 실행을 에뮬레이트합니다. 마치 트랜잭션이 순차적이 아니라 순차적으로 실행 된 것처럼. 그러나 반복 가능한 읽기 수준과 같이이 수준을 사용하는 응용 프로그램은 직렬화 오류로 인해 트랜잭션을 다시 시도하도록 준비해야합니다. 실제로,이 분리 레벨은 반복 가능한 읽기와 정확히 동일하게 작동합니다. 직렬화 가능한 동시 트랜잭션 세트의 실행이 해당 트랜잭션의 모든 가능한 직렬 (한 번에) 실행과 일치하지 않는 방식으로 작동 할 수있는 조건을 모니터한다는 점을 제외하면. 이 모니터링은 반복 가능한 읽기에 존재하는 것 이상의 차단을 일으키지 않지만 모니터링에 약간의 오버 헤드가 있으며&lt;em&gt;직렬화 이상&lt;/em&gt; 은 &lt;em&gt;직렬화 실패&lt;/em&gt; 를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="f95abb4a8d7bbdd16928c9f5238fbb89514c9dcf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;collation derivation&lt;/em&gt; of an expression can be implicit or explicit. This distinction affects how collations are combined when multiple different collations appear in an expression. An explicit collation derivation occurs when a &lt;code&gt;COLLATE&lt;/code&gt; clause is used; all other collation derivations are implicit. When multiple collations need to be combined, for example in a function call, the following rules are used:</source>
          <target state="translated">식의 &lt;em&gt;데이터 정렬 파생&lt;/em&gt; 은 암시 적이거나 명시적일 수 있습니다. 이 차이는 식에 여러 개의 다른 데이터 정렬이 나타날 때 데이터 정렬이 결합되는 방식에 영향을줍니다. &lt;code&gt;COLLATE&lt;/code&gt; 절이 사용될 때 명시 적 데이터 정렬 파생이 발생합니다 . 다른 모든 데이터 정렬 파생은 암시 적입니다. 예를 들어 함수 호출에서 여러 데이터 정렬을 결합해야하는 경우 다음 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cf554eac84360c1dd91eed12720bf8c618bfb93" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cost&lt;/em&gt; variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner's choices. By default, these cost variables are based on the cost of sequential page fetches; that is, &lt;code&gt;seq_page_cost&lt;/code&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</source>
          <target state="translated">&lt;em&gt;비용&lt;/em&gt; 이 섹션에서 설명 변수는 임의의 크기를 측정한다. 상대적인 값만 중요하므로 같은 요인으로 모두 확대 또는 축소하면 플래너의 선택에 아무런 변화가 없습니다. 기본적으로 이러한 비용 변수는 순차적 페이지 페치 비용을 기반으로합니다. 즉, &lt;code&gt;seq_page_cost&lt;/code&gt; 는 일반적으로 &lt;code&gt;1.0&lt;/code&gt; 으로 설정되고 다른 비용 변수는이를 참조하여 설정됩니다. 그러나 특정 머신에서 실제 실행 시간 (밀리 초)과 같이 원하는 경우 다른 스케일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdab0ead2317e8987500975ac391b000a895f851" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; takes the plan created by the planner/optimizer and recursively processes it to extract the required set of rows. This is essentially a demand-pull pipeline mechanism. Each time a plan node is called, it must deliver one more row, or report that it is done delivering rows.</source>
          <target state="translated">&lt;em&gt;실행기는&lt;/em&gt; 플래너 / 최적화에 의해 생성 된 평면을 얻어 재귀 행의 필요한 집합을 추출하기 위해 그것을 처리한다. 이것은 본질적으로 수요 풀 파이프 라인 메커니즘입니다. 계획 노드가 호출 될 때마다 하나 이상의 행을 전달하거나 행 전달을 완료했다고보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="060116e5a7301adb249c93dbfa36c11220a4c9e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;join condition&lt;/em&gt; is specified in the &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;USING&lt;/code&gt; clause, or implicitly by the word &lt;code&gt;NATURAL&lt;/code&gt;. The join condition determines which rows from the two source tables are considered to &amp;ldquo;match&amp;rdquo;, as explained in detail below.</source>
          <target state="translated">&lt;em&gt;가입 조건&lt;/em&gt; 에 지정된되어 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;USING&lt;/code&gt; 단어에 의해 암시 적 절을, 또는 &lt;code&gt;NATURAL&lt;/code&gt; . 결합 조건은 아래에 자세히 설명 된 것처럼 두 소스 테이블에서 &quot;일치&quot;하는 것으로 간주되는 행을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e845d5a4041970d6090d5e417e410e4537e73642" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;lexer&lt;/em&gt; is defined in the file &lt;code&gt;scan.l&lt;/code&gt; and is responsible for recognizing &lt;em&gt;identifiers&lt;/em&gt;, the &lt;em&gt;SQL key words&lt;/em&gt; etc. For every key word or identifier that is found, a &lt;em&gt;token&lt;/em&gt; is generated and handed to the parser.</source>
          <target state="translated">&lt;em&gt;렉서는&lt;/em&gt; 파일에 정의되어 &lt;code&gt;scan.l&lt;/code&gt; 및 인식에 대한 책임이 &lt;em&gt;식별자&lt;/em&gt; 는 &lt;em&gt;SQL 키 워드&lt;/em&gt; 를 찾을 때마다 핵심 단어 나 식별자 등을하는 &lt;em&gt;토큰이&lt;/em&gt; 생성되고 파서에 넘겨진다.</target>
        </trans-unit>
        <trans-unit id="b14305d3078ee82aaf737dbdfa8a94d4d85285ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;minmax&lt;/em&gt; operator classes store the minimum and the maximum values appearing in the indexed column within the range. The &lt;em&gt;inclusion&lt;/em&gt; operator classes store a value which includes the values in the indexed column within the range.</source>
          <target state="translated">&lt;em&gt;MINMAX&lt;/em&gt; 연산자 클래스는 최소 범위 내에서 인덱싱 된 컬럼에 나타나는 최대 값을 저장한다. &lt;em&gt;내포&lt;/em&gt; 연산자 클래스 범위 내의 인덱싱 된 열 값을 포함하는 값을 저장한다.</target>
        </trans-unit>
        <trans-unit id="4ba1c2981b2fbd2dd1eede149e275316be5425fc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; checks the query transmitted by the application program for correct syntax and creates a &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;파서 스테이지&lt;/em&gt; 쿼리 정확한 구문은 응용 프로그램에 의해 전송 및 확인이 생성 &lt;em&gt;쿼리 트리&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d38c6ccc62204fc543f643ffbd579a373675e1c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser stage&lt;/em&gt; consists of two parts:</source>
          <target state="translated">&lt;em&gt;파서 단계는&lt;/em&gt; 두 부분으로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c5bfac80be17dbbeff4a6cdab20060a18710ec0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parser&lt;/em&gt; defined in &lt;code&gt;gram.y&lt;/code&gt; and &lt;code&gt;scan.l&lt;/code&gt; is built using the Unix tools bison and flex.</source>
          <target state="translated">&lt;em&gt;파서&lt;/em&gt; 에 정의 &lt;code&gt;gram.y&lt;/code&gt; 및 &lt;code&gt;scan.l&lt;/code&gt; 는 들소와 플렉스 유닉스 도구를 사용하여 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="99c46fa0bf1c41a332643fa4668a817dafffd6e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;planner/optimizer&lt;/em&gt; takes the (rewritten) query tree and creates a &lt;em&gt;query plan&lt;/em&gt; that will be the input to the &lt;em&gt;executor&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;플래너 / 최적화&lt;/em&gt; (재) 쿼리 트리를 취하고 생성 &lt;em&gt;쿼리 계획&lt;/em&gt; 받는 입력됩니다 &lt;em&gt;집행을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0bfc85eac5f506c4396fe64f83cd201f163702b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rewrite system&lt;/em&gt; takes the query tree created by the parser stage and looks for any &lt;em&gt;rules&lt;/em&gt; (stored in the &lt;em&gt;system catalogs&lt;/em&gt;) to apply to the query tree. It performs the transformations given in the &lt;em&gt;rule bodies&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;재 작성 시스템은&lt;/em&gt; 어떤을위한 파서 무대와 모양에 의해 생성 된 쿼리 트리 소요 &lt;em&gt;규칙&lt;/em&gt; 합니다 (저장 &lt;em&gt;시스템 카탈로그를&lt;/em&gt; 쿼리 트리에 적용). &lt;em&gt;규칙 본문에&lt;/em&gt; 지정된 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="daa9a547059ab18709c7d9a8b34e0eb273fde26d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transformation process&lt;/em&gt; does modifications and augmentations to the data structures returned by the parser.</source>
          <target state="translated">&lt;em&gt;변환 과정은&lt;/em&gt; 파서에 의해 반환 된 데이터 구조에 대한 변형 및 보강을한다.</target>
        </trans-unit>
        <trans-unit id="6005c8d6a8d942aa977decf6b60a95978aaf5aab" translate="yes" xml:space="preserve">
          <source>The API for constructing generic WAL records is defined in &lt;code&gt;access/generic_xlog.h&lt;/code&gt; and implemented in &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt;.</source>
          <target state="translated">일반 WAL 레코드를 구성하기위한 API는 &lt;code&gt;access/generic_xlog.h&lt;/code&gt; 에 정의되어 있으며 &lt;code&gt;access/transam/generic_xlog.c&lt;/code&gt; 에 구현되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaa78d1712bc527d8b8229b7cb39f829dcef0b7a" translate="yes" xml:space="preserve">
          <source>The B-tree operator family this entry sorts according to, if an ordering operator; zero if a search operator</source>
          <target state="translated">B- 트리 연산자 패밀리는 순서 연산자 인 경우에 따라이 항목을 정렬합니다. 검색 연산자 인 경우 0</target>
        </trans-unit>
        <trans-unit id="4717590c35f3a3113f7d473dbe7410d944c8d2f4" translate="yes" xml:space="preserve">
          <source>The BRIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The BRIN layer itself takes care of concurrency, logging and searching the index structure.</source>
          <target state="translated">BRIN 인터페이스는 추상화 수준이 높으므로 액세스되는 데이터 유형의 의미를 구현하기 위해서만 액세스 메소드 구현자가 필요합니다. BRIN 계층 자체는 동시성, 로그 구조 및 색인 구조 검색을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="12f1f91360cdc7254651ab3db114c105bbc973aa" translate="yes" xml:space="preserve">
          <source>The BRIN operator classes included in the standard distribution are documented in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;. For more information see &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;Chapter 67&lt;/a&gt;.</source>
          <target state="translated">표준 분배에 포함 된 BRIN 연산자 클래스는 &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 67.1에&lt;/a&gt; 문서화되어 있습니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/brin.html&quot;&gt;67 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05d73c5606dbc5d228281af7029fd60e51759995" translate="yes" xml:space="preserve">
          <source>The Double Metaphone system computes two &amp;ldquo;sounds like&amp;rdquo; strings for a given input string &amp;mdash; a &amp;ldquo;primary&amp;rdquo; and an &amp;ldquo;alternate&amp;rdquo;. In most cases they are the same, but for non-English names especially they can be a bit different, depending on pronunciation. These functions compute the primary and alternate codes:</source>
          <target state="translated">Double Metaphone 시스템은 주어진 입력 문자열에 대해 &quot;기본&quot;과 &quot;대체&quot;라는 두 가지 &quot;사운드 같은&quot;문자열을 계산합니다. 대부분의 경우, 그들은 동일하지만 영어가 아닌 이름의 경우 특히 발음에 따라 약간 다를 수 있습니다. 이 함수는 기본 및 대체 코드를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c8af7d6c825c894dd0eb03ecb26fae46fecd94c6" translate="yes" xml:space="preserve">
          <source>The Free Space Map is organized as a tree of FSM pages. The bottom level FSM pages store the free space available on each heap (or index) page, using one byte to represent each such page. The upper levels aggregate information from the lower levels.</source>
          <target state="translated">여유 공간 맵은 FSM 페이지 트리로 구성됩니다. 최하위 레벨의 FSM 페이지는 각 힙 (또는 인덱스) 페이지에서 사용 가능한 여유 공간을 1 바이트를 사용하여 각 페이지를 나타냅니다. 상위 레벨은 하위 레벨에서 정보를 집계합니다.</target>
        </trans-unit>
        <trans-unit id="30fb294fef92ba7b2398333f6fd38e60940f0136" translate="yes" xml:space="preserve">
          <source>The GEQO module allows the PostgreSQL query optimizer to support large join queries effectively through non-exhaustive search.</source>
          <target state="translated">GEQO 모듈을 사용하면 PostgreSQL 쿼리 최적화 프로그램이 철저하지 않은 검색을 통해 대규모 조인 쿼리를 효과적으로 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9943a2120bd9e8c3e6721e67541600ca21fe96fa" translate="yes" xml:space="preserve">
          <source>The GEQO module approaches the query optimization problem as though it were the well-known traveling salesman problem (TSP). Possible query plans are encoded as integer strings. Each string represents the join order from one relation of the query to the next. For example, the join tree</source>
          <target state="translated">GEQO 모듈은 잘 알려진 이동 판매원 문제 (TSP) 인 것처럼 쿼리 최적화 문제에 접근합니다. 가능한 쿼리 계획은 정수 문자열로 인코딩됩니다. 각 문자열은 쿼리의 한 관계에서 다음 관계로의 조인 순서를 나타냅니다. 예를 들어, 조인 트리</target>
        </trans-unit>
        <trans-unit id="a13542c5aa9b5acc83ba91d19d31a9262ad99881" translate="yes" xml:space="preserve">
          <source>The GEQO planning process uses the standard planner code to generate plans for scans of individual relations. Then join plans are developed using the genetic approach. As shown above, each candidate join plan is represented by a sequence in which to join the base relations. In the initial stage, the GEQO code simply generates some possible join sequences at random. For each join sequence considered, the standard planner code is invoked to estimate the cost of performing the query using that join sequence. (For each step of the join sequence, all three possible join strategies are considered; and all the initially-determined relation scan plans are available. The estimated cost is the cheapest of these possibilities.) Join sequences with lower estimated cost are considered &amp;ldquo;more fit&amp;rdquo; than those with higher cost. The genetic algorithm discards the least fit candidates. Then new candidates are generated by combining genes of more-fit candidates &amp;mdash; that is, by using randomly-chosen portions of known low-cost join sequences to create new sequences for consideration. This process is repeated until a preset number of join sequences have been considered; then the best one found at any time during the search is used to generate the finished plan.</source>
          <target state="translated">GEQO 계획 프로세스는 표준 플래너 코드를 사용하여 개별 관계 스캔 계획을 생성합니다. 그런 다음 유전자 접근 방식을 사용하여 결합 계획을 개발합니다. 위에 나타낸 바와 같이, 각 후보 조인 계획은 기본 관계에 합류하는 순서로 표현된다. 초기 단계에서 GEQO 코드는 가능한 일부 조인 시퀀스를 임의로 생성합니다. 고려 된 각 조인 시퀀스에 대해 표준 플래너 코드가 호출되어 해당 조인 시퀀스를 사용하여 쿼리 수행 비용을 추정합니다. (조인 순서의 각 단계마다 세 가지 가능한 조인 전략이 모두 고려되며 초기에 결정된 모든 관계 스캔 계획을 사용할 수 있습니다. 예상 비용은 이러한 가능성 중에서 가장 저렴합니다.) 예상 비용이 더 낮은 조인 순서는 &quot;더보기 더 높은 비용의 사람들보다 적합합니다.유전자 알고리즘은 가장 적합한 후보를 버립니다. 그런 다음보다 적합한 후보 유전자를 결합하여, 즉 알려진 저비용 결합 서열의 무작위로 선택된 부분을 사용하여 새로운 후보를 생성하여 새로운 후보를 생성합니다. 이 과정은 미리 설정된 수의 결합 시퀀스가 ​​고려 될 때까지 반복됩니다. 검색 중 언제라도 발견 된 최상의 계획은 완성 된 계획을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="12d46a50018559dae87055222c8f226b8336aa38" translate="yes" xml:space="preserve">
          <source>The GIN implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov. There is more information about GIN on their &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL의 GIN 구현은 주로 Teodor Sigaev와 Oleg Bartunov에 의해 유지됩니다. 그들의 &lt;a href=&quot;http://www.sai.msu.su/~megera/wiki/Gin&quot;&gt;웹 사이트&lt;/a&gt; 에 GIN에 관한 더 많은 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2e1dce9027c2870a4be78df483750ab0dd368b7" translate="yes" xml:space="preserve">
          <source>The GIN interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GIN layer itself takes care of concurrency, logging and searching the tree structure.</source>
          <target state="translated">GIN 인터페이스는 추상화 수준이 높으므로 액세스 방법 구현자는 액세스되는 데이터 유형의 의미를 구현하기 만하면됩니다. GIN 계층 자체는 동시성을 관리하고 트리 구조를 로깅 및 검색합니다.</target>
        </trans-unit>
        <trans-unit id="47e8892c842e09af9d1e34fe3c02e2f04b0f5d8f" translate="yes" xml:space="preserve">
          <source>The GNU Privacy Handbook.</source>
          <target state="translated">GNU 프라이버시 핸드북.</target>
        </trans-unit>
        <trans-unit id="3d32f64c87806d58fdb89cae3ce39c10adecb6af" translate="yes" xml:space="preserve">
          <source>The High Precision Event Timer (HPET) is the preferred timer on systems where it's available and TSC is not accurate. The timer chip itself is programmable to allow up to 100 nanosecond resolution, but you may not see that much accuracy in your system clock.</source>
          <target state="translated">HPET (고정밀 이벤트 타이머)는 사용 가능하고 TSC가 정확하지 않은 시스템에서 선호되는 타이머입니다. 타이머 칩 자체는 최대 100 나노초 분해능을 허용하도록 프로그래밍 가능하지만 시스템 클럭에서 그다지 정확성을 보지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db1ae3a20afea53927e5a775df1db6e7daba0537" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week-numbering year that the date falls in (not applicable to intervals)</source>
          <target state="translated">날짜가 속하는 ISO 8601 주 번호 연도 (간격에는 해당되지 않음)</target>
        </trans-unit>
        <trans-unit id="a2f552c0c2f33843207363b12ed183813abd32ee" translate="yes" xml:space="preserve">
          <source>The Identification Protocol is not intended as an authorization or access control protocol.</source>
          <target state="translated">식별 프로토콜은 인증 또는 액세스 제어 프로토콜이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="34d3089a14d3fce4ff8f4421c9f8177fa0b6d74c" translate="yes" xml:space="preserve">
          <source>The Institute of Automatic Control at the University of Mining and Technology, in Freiberg, Germany, encountered some problems when it wanted to use PostgreSQL as the backend for a decision support knowledge based system for the maintenance of an electrical power grid. The DBMS needed to handle large join queries for the inference machine of the knowledge based system. The number of joins in these queries made using the normal query optimizer infeasible.</source>
          <target state="translated">독일 프라이 베르크에있는 광업 기술 대학의 자동 제어 연구소는 PostgreSQL을 전력망 유지 관리를위한 의사 결정 지원 지식 기반 시스템의 백엔드로 사용하려고 할 때 몇 가지 문제를 겪었습니다. DBMS는 지식 기반 시스템의 추론 시스템에 대한 대규모 조인 쿼리를 처리해야했습니다. 일반 쿼리 최적화 프로그램을 사용하여 수행 한 이러한 쿼리의 조인 수는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="aa9845a0dd3274b254c00b6f19f94269db7f2403" translate="yes" xml:space="preserve">
          <source>The Ispell dictionary template supports &lt;em&gt;morphological dictionaries&lt;/em&gt;, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term &lt;code&gt;bank&lt;/code&gt;, e.g., &lt;code&gt;banking&lt;/code&gt;, &lt;code&gt;banked&lt;/code&gt;, &lt;code&gt;banks&lt;/code&gt;, &lt;code&gt;banks'&lt;/code&gt;, and &lt;code&gt;bank's&lt;/code&gt;.</source>
          <target state="translated">Ispell 사전 템플릿은 &lt;em&gt;형태 학적 사전을&lt;/em&gt; 지원 하는데, 이는 여러 다른 언어 적 형태의 단어를 동일한 어휘로 정규화 할 수 있습니다. 예를 들어, 영어 Ispell 사전은 검색어 &lt;code&gt;bank&lt;/code&gt; (예 : &lt;code&gt;banking&lt;/code&gt; , &lt;code&gt;banked&lt;/code&gt; , &lt;code&gt;banks&lt;/code&gt; , &lt;code&gt;banks'&lt;/code&gt; 및 &lt;code&gt;bank's&lt;/code&gt; 모든 기울기 및 활용과 일치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="282b226a01a92e56fbbd4540780287fee9277216" translate="yes" xml:space="preserve">
          <source>The Julian calendar was introduced by Julius Caesar in 45 BC. It was in common use in the Western world until the year 1582, when countries started changing to the Gregorian calendar. In the Julian calendar, the tropical year is approximated as 365 1/4 days = 365.25 days. This gives an error of about 1 day in 128 years.</source>
          <target state="translated">줄리안 달력은 기원전 45 년 Julius Caesar에 의해 소개되었습니다. 국가들이 그레고리력으로 바뀌기 시작한 1582 년까지 서구에서는 일반적으로 사용되었다. 율리우스 력에서 열대 년은 대략 365 1/4 일 = 365.25 일입니다. 128 년 동안 약 1 일의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3cde8e59b22c9d6c409e59a264cd6d5133433aa8" translate="yes" xml:space="preserve">
          <source>The Locking Clause</source>
          <target state="translated">잠금 조항</target>
        </trans-unit>
        <trans-unit id="3aaa9a5d10023ba2866dd37afda193155af0f247" translate="yes" xml:space="preserve">
          <source>The MCV list gives the planner more detailed information about the specific values that commonly appear in the table, as well as an upper bound on the selectivities of combinations of values that do not appear in the table, allowing it to generate better estimates in both cases.</source>
          <target state="translated">MCV 목록은 계획자에게 표에 일반적으로 나타나는 특정 값에 대한 자세한 정보와 표에 나타나지 않는 값 조합의 선택에 대한 상한을 제공하여 두 경우 모두 더 나은 추정치를 생성 할 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="55e485d087fdc5b4b841601869e3bb93e6bf3639" translate="yes" xml:space="preserve">
          <source>The MD5 Message-Digest Algorithm.</source>
          <target state="translated">MD5 메시지 다이제스트 알고리즘.</target>
        </trans-unit>
        <trans-unit id="2127ad6c429aa49a235fd761eacdf2db8d6f6769" translate="yes" xml:space="preserve">
          <source>The Nagios plugin check_pgsql will work, because the simple information it checks for exists. The check_postgres monitoring script will also work, though some reported values could give different or confusing results. For example, last vacuum time will not be maintained, since no vacuum occurs on the standby. Vacuums running on the primary do still send their changes to the standby.</source>
          <target state="translated">Nagios 플러그인 check_pgsql은 검사하는 간단한 정보가 존재하기 때문에 작동합니다. check_postgres 모니터링 스크립트도 작동하지만 일부보고 된 값은 다르거 나 혼동되는 결과를 제공 할 수 있습니다. 예를 들어 대기 시간에 진공이 발생하지 않기 때문에 마지막 진공 시간이 유지되지 않습니다. 기본에서 실행중인 진공은 여전히 ​​변경 사항을 대기로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5e71865447d6bc9ea383afd7d76b7761f19aa1b6" translate="yes" xml:space="preserve">
          <source>The OID alias types do not completely follow transaction isolation rules. The planner also treats them as simple constants, which may result in sub-optimal planning.</source>
          <target state="translated">OID 별명 유형은 트랜잭션 분리 규칙을 완전히 따르지 않습니다. 또한 플래너는이를 단순한 상수로 취급하므로 최적이 아닌 계획이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31161126282561c5d74d32ce529fddd65e0a76bd" translate="yes" xml:space="preserve">
          <source>The OID alias types have no operations of their own except for specialized input and output routines. These routines are able to accept and display symbolic names for system objects, rather than the raw numeric value that type &lt;code&gt;oid&lt;/code&gt; would use. The alias types allow simplified lookup of OID values for objects. For example, to examine the &lt;code&gt;pg_attribute&lt;/code&gt; rows related to a table &lt;code&gt;mytable&lt;/code&gt;, one could write:</source>
          <target state="translated">OID 별명 유형에는 특수 입력 및 출력 루틴을 제외하고는 자체 조작이 없습니다. 이 루틴은 &lt;code&gt;oid&lt;/code&gt; 유형 이 사용 하는 원시 숫자 값 대신 시스템 오브젝트의 기호 이름을 승인하고 표시 할 수 있습니다. 별칭 유형을 사용하면 객체에 대한 OID 값을 간단하게 조회 할 수 있습니다. 예를 들어, &lt;code&gt;mytable&lt;/code&gt; 테이블과 관련된 &lt;code&gt;pg_attribute&lt;/code&gt; 행 을 검사하려면 다음 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f728998e1513edf5bb0f58e995427e26f8967db" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the default partition of this partitioned table, or zero if this partitioned table does not have a default partition.</source>
          <target state="translated">이 파티션 된 테이블의 기본 파티션에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목 의 OID 또는이 파티션 된 테이블에 기본 파티션이없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="0e41c17d955ca3267fc3e0f5f9ba923e41ea0513" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for the table this index is for</source>
          <target state="translated">이 인덱스가있는 테이블 에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="071dd0d457f9f27d9bee0d2e3ff6291a6f564862" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this index</source>
          <target state="translated">이 인덱스 에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="f5a48c524de61d425315c3640ed2f8c5273484e3" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this partitioned table</source>
          <target state="translated">이 파티션 된 테이블에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="eda438d49a92e642ba61a005c3405da4f9f1c62a" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this sequence</source>
          <target state="translated">이 순서 에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="303197c3c31b1c60eee9019793731af72e0dc006" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_ts_config&lt;/code&gt; entry owning this map entry</source>
          <target state="translated">이 맵 항목을 소유 한 &lt;code&gt;pg_ts_config&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="f8bdb5895be29901070dfef3e22b4e60f7c2d267" translate="yes" xml:space="preserve">
          <source>The OID of the &lt;code&gt;pg_type&lt;/code&gt; entry owning this enum value</source>
          <target state="translated">이 열거 형 값을 소유 하는 &lt;code&gt;pg_type&lt;/code&gt; 항목 의 OID</target>
        </trans-unit>
        <trans-unit id="a977c33ead1b2b309c764b95248966dbf41f0217" translate="yes" xml:space="preserve">
          <source>The OID of the child table</source>
          <target state="translated">자식 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="5ebd50be09b18866cd4d57833179194c831f037b" translate="yes" xml:space="preserve">
          <source>The OID of the data type that corresponds to this table's row type, if any (zero for indexes, which have no &lt;code&gt;pg_type&lt;/code&gt; entry)</source>
          <target state="translated">이 테이블의 행 유형에 해당하는 데이터 유형의 OID (있는 경우) ( &lt;code&gt;pg_type&lt;/code&gt; 항목 이없는 인덱스의 경우 0 )</target>
        </trans-unit>
        <trans-unit id="b8b4662cb4e6288ca284849c4be148da66825b82" translate="yes" xml:space="preserve">
          <source>The OID of the database the dependent object is in, or zero for a shared object</source>
          <target state="translated">종속 오브젝트가있는 데이터베이스의 OID 또는 공유 오브젝트의 경우 0</target>
        </trans-unit>
        <trans-unit id="898b60ec7f694b0fc006eda8e50f6b63d49620a6" translate="yes" xml:space="preserve">
          <source>The OID of the database the setting is applicable to, or zero if not database-specific</source>
          <target state="translated">설정이 적용 가능한 데이터베이스의 OID 또는 데이터베이스에 맞지 않으면 0</target>
        </trans-unit>
        <trans-unit id="61af788beaa116f1b955c318390c380729eb624f" translate="yes" xml:space="preserve">
          <source>The OID of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">이 슬롯이 연결된 데이터베이스의 OID 또는 null입니다. 논리 슬롯 만 연관된 데이터베이스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="dffe34cbcb64c59bdcb3677d3a1fd7a1a7165871" translate="yes" xml:space="preserve">
          <source>The OID of the foreign server that contains this mapping</source>
          <target state="translated">이 맵핑을 포함하는 외부 서버의 OID</target>
        </trans-unit>
        <trans-unit id="5048d68506cd122e63f767db512f5ebd84d67ed5" translate="yes" xml:space="preserve">
          <source>The OID of the function to use to perform this cast. Zero is stored if the cast method doesn't require a function.</source>
          <target state="translated">이 캐스트를 수행하는 데 사용할 함수의 OID입니다. 캐스트 메소드에 함수가 필요하지 않으면 0이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="59c37f70d3d21e1cf2530f6e69c1cd78c664862f" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting output from the procedural language (e.g., return values) to the data type. Zero is stored if this operation is not supported.</source>
          <target state="translated">절차 언어의 출력 (예 : 반환 값)을 데이터 유형으로 변환 할 때 사용할 함수의 OID입니다. 이 작업이 지원되지 않으면 0이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b438ec49041a86ff7da5085d6d696fab9858a564" translate="yes" xml:space="preserve">
          <source>The OID of the function to use when converting the data type for input to the procedural language (e.g., function parameters). Zero is stored if this operation is not supported.</source>
          <target state="translated">입력을 위해 데이터 유형을 절차 언어로 변환 할 때 사용할 함수의 OID (예 : 함수 매개 변수). 이 작업이 지원되지 않으면 0이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8427c56037bb672e3eaf5c784fadd5373d00c50d" translate="yes" xml:space="preserve">
          <source>The OID of the large object.</source>
          <target state="translated">큰 개체의 OID</target>
        </trans-unit>
        <trans-unit id="aa257a5cc909f035b6b365a8de79171496abef73" translate="yes" xml:space="preserve">
          <source>The OID of the namespace associated with this entry, or 0 if none</source>
          <target state="translated">이 항목과 관련된 네임 스페이스의 OID.없는 경우 0</target>
        </trans-unit>
        <trans-unit id="3c9f55892a56c80828f11ba8da0cec8b6667ea0f" translate="yes" xml:space="preserve">
          <source>The OID of the namespace for this object, if applicable; otherwise NULL.</source>
          <target state="translated">해당되는 경우이 객체에 대한 네임 스페이스의 OID입니다. 그렇지 않으면 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="6544239c27c8b98d678c4d86cd8cf2fb4a45d909" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this collation</source>
          <target state="translated">이 데이터 정렬이 포함 된 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="67632f7b86c5d28c986c07563f79e9f57ab7488a" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this configuration</source>
          <target state="translated">이 구성을 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="f78b68f0e0d540debab34518ee53138dd78afc9d" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this constraint</source>
          <target state="translated">이 제약 조건이 포함 된 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="26651bac2ebe9b8df63182bb4f09e8b29d4375b5" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this conversion</source>
          <target state="translated">이 변환이 포함 된 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="58fcc7c98890e8c2834e53212732cd77ac260148" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this dictionary</source>
          <target state="translated">이 사전을 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="0ffa036dc5da9392b5ff92b8de19382988ae095b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this function</source>
          <target state="translated">이 함수를 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="4836cfb15733aecb9038935daa22b144847fa0b0" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this operator</source>
          <target state="translated">이 연산자를 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="bd2956b2c54813a0f702f1bbd1860a3130d1cd13" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this parser</source>
          <target state="translated">이 파서를 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="4fa4ff9a62cc6b391718b0f0a2fcbd7ba489a8a1" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this relation</source>
          <target state="translated">이 관계를 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="f3b00f8f6b6908679ca83ef8448db4669f9c3f2b" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this statistics object</source>
          <target state="translated">이 통계 개체를 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="0eccd6202b6e25a82e3cb731c01941486b802fde" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this template</source>
          <target state="translated">이 템플릿을 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="2ad5e85b9c67d0c9e6855e2f98983c857e3e9cc9" translate="yes" xml:space="preserve">
          <source>The OID of the namespace that contains this type</source>
          <target state="translated">이 유형을 포함하는 네임 스페이스의 OID</target>
        </trans-unit>
        <trans-unit id="4da576b45acb3f961f666fac031b8e0b7887d94a" translate="yes" xml:space="preserve">
          <source>The OID of the object this description pertains to</source>
          <target state="translated">이 설명과 관련된 객체의 OID</target>
        </trans-unit>
        <trans-unit id="92fb8b43568522d54e99e8435ff353f995d4d31c" translate="yes" xml:space="preserve">
          <source>The OID of the object this security label pertains to</source>
          <target state="translated">이 보안 레이블과 관련된 개체의 OID</target>
        </trans-unit>
        <trans-unit id="0002c6e72af222de4cb8c506a6f1bc7c20ab1dc4" translate="yes" xml:space="preserve">
          <source>The OID of the parent table</source>
          <target state="translated">부모 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="d5ffd02286699ef3905e8a972c66ee4bb2835bfc" translate="yes" xml:space="preserve">
          <source>The OID of the role associated with this entry</source>
          <target state="translated">이 항목과 관련된 역할의 OID</target>
        </trans-unit>
        <trans-unit id="c0915654e58b310d5210b25d19abfd7806a843de" translate="yes" xml:space="preserve">
          <source>The OID of the role the setting is applicable to, or zero if not role-specific</source>
          <target state="translated">설정을 적용 할 수있는 역할의 OID 또는 역할 별이 아닌 경우 0</target>
        </trans-unit>
        <trans-unit id="c9f3ec9e29e6e5e35e198f85cfeb26802f0a6d99" translate="yes" xml:space="preserve">
          <source>The OID of the specific dependent object</source>
          <target state="translated">특정 종속 개체의 OID</target>
        </trans-unit>
        <trans-unit id="b9087659abb5a8df685a282e464694231a05c905" translate="yes" xml:space="preserve">
          <source>The OID of the specific object</source>
          <target state="translated">특정 객체의 OID</target>
        </trans-unit>
        <trans-unit id="9442b82a85ff19f9d0307346795cdb1c1390d555" translate="yes" xml:space="preserve">
          <source>The OID of the specific referenced object</source>
          <target state="translated">특정 참조 객체의 OID</target>
        </trans-unit>
        <trans-unit id="3b6fda1c623aa2d59a074893167f643c66f63048" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the dependent object is in</source>
          <target state="translated">종속 오브젝트가있는 시스템 카탈로그의 OID</target>
        </trans-unit>
        <trans-unit id="45c628ea8dfbe9deffe2a6beca65b182150c549a" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the object is in</source>
          <target state="translated">오브젝트가있는 시스템 카탈로그의 OID</target>
        </trans-unit>
        <trans-unit id="651df0c1a82da14b1a69c5c748c986ddebc8aa71" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in</source>
          <target state="translated">참조 된 오브젝트가있는 시스템 카탈로그의 OID</target>
        </trans-unit>
        <trans-unit id="b623975e8da0f35427faa44f2916bd8169911114" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog the referenced object is in (must be a shared catalog)</source>
          <target state="translated">참조 된 오브젝트가있는 시스템 카탈로그의 OID (공유 카탈로그 여야 함)</target>
        </trans-unit>
        <trans-unit id="d29abf904f17279c11d42dc4f5568269360fdcb9" translate="yes" xml:space="preserve">
          <source>The OID of the system catalog this object appears in</source>
          <target state="translated">이 객체가 나타나는 시스템 카탈로그의 OID</target>
        </trans-unit>
        <trans-unit id="067e884e18cd2aa571279cd559f882f0cf4ff2a1" translate="yes" xml:space="preserve">
          <source>The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt;), since without it, it's difficult to tell which individual table a row came from. The &lt;code&gt;tableoid&lt;/code&gt; can be joined against the &lt;code&gt;oid&lt;/code&gt; column of &lt;code&gt;pg_class&lt;/code&gt; to obtain the table name.</source>
          <target state="translated">이 행을 포함하는 테이블의 OID 이 열은 상속 계층에서 선택하는 쿼리에 특히 유용합니다 ( &lt;a href=&quot;ddl-inherit&quot;&gt;섹션 5.10&lt;/a&gt; 참조 ). 열이 없으면 행이 어느 개별 테이블에서 왔는지 알기가 어렵 기 때문입니다. &lt;code&gt;tableoid&lt;/code&gt; 는 대해 결합 될 수 &lt;code&gt;oid&lt;/code&gt; 의 열 &lt;code&gt;pg_class&lt;/code&gt; 테이블 이름을 얻었다.</target>
        </trans-unit>
        <trans-unit id="6a0b9e6d63b6cf8a833e5a7e3f6047bb0a93a945" translate="yes" xml:space="preserve">
          <source>The OID of the text search dictionary to consult</source>
          <target state="translated">참조 할 텍스트 검색 사전의 OID</target>
        </trans-unit>
        <trans-unit id="b6ba84785ad334e01b83ec445d3dda1ac4ac96bb" translate="yes" xml:space="preserve">
          <source>The OID of the text search parser for this configuration</source>
          <target state="translated">이 구성에 대한 텍스트 검색 파서의 OID</target>
        </trans-unit>
        <trans-unit id="a117213bd13a98b62f97b549d2037dd5baede006" translate="yes" xml:space="preserve">
          <source>The OID of the text search template for this dictionary</source>
          <target state="translated">이 사전에 대한 텍스트 검색 템플릿의 OID</target>
        </trans-unit>
        <trans-unit id="58df61b40061f6a6618e8266483da7f989d95f26" translate="yes" xml:space="preserve">
          <source>The OIDs for &lt;code&gt;pg_enum&lt;/code&gt; rows follow a special rule: even-numbered OIDs are guaranteed to be ordered in the same way as the sort ordering of their enum type. That is, if two even OIDs belong to the same enum type, the smaller OID must have the smaller &lt;code&gt;enumsortorder&lt;/code&gt; value. Odd-numbered OID values need bear no relationship to the sort order. This rule allows the enum comparison routines to avoid catalog lookups in many common cases. The routines that create and alter enum types attempt to assign even OIDs to enum values whenever possible.</source>
          <target state="translated">&lt;code&gt;pg_enum&lt;/code&gt; 행 의 OID 는 특별한 규칙을 따릅니다. 짝수 OID는 열거 형의 정렬 순서와 동일한 방식으로 정렬됩니다. 즉, 두 개의 짝수 OID가 동일한 열거 형에 속하면 작은 OID는 더 작은 열거 형 값을 &lt;code&gt;enumsortorder&lt;/code&gt; 합니다. 홀수 OID 값은 정렬 순서와 관계가 없습니다. 이 규칙은 열거 비교 루틴이 많은 경우에 카탈로그 조회를 피할 수 있도록합니다. 열거 형 유형을 만들고 변경하는 루틴은 가능할 때마다 열거 형 값에 짝수 OID를 할당하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="362f3646de7e2bebf05ad74a6325f7165ac1988c" translate="yes" xml:space="preserve">
          <source>The OpenSSL default order for &lt;code&gt;HIGH&lt;/code&gt; is problematic because it orders 3DES higher than AES128. This is wrong because 3DES offers less security than AES128, and it is also much slower. &lt;code&gt;+3DES&lt;/code&gt; reorders it after all other &lt;code&gt;HIGH&lt;/code&gt; and &lt;code&gt;MEDIUM&lt;/code&gt; ciphers.</source>
          <target state="translated">&lt;code&gt;HIGH&lt;/code&gt; 의 OpenSSL 기본 순서 는 AES128보다 3DES가 ​​높기 때문에 문제가됩니다. 이는 3DES가 ​​AES128보다 보안 수준이 낮고 속도도 훨씬 느리기 때문에 잘못되었습니다. &lt;code&gt;+3DES&lt;/code&gt; 는 다른 모든 &lt;code&gt;HIGH&lt;/code&gt; 및 &lt;code&gt;MEDIUM&lt;/code&gt; 암호 뒤에 순서를 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="b73c1bd60aad8104323371d01b1ec1a8338ede73" translate="yes" xml:space="preserve">
          <source>The Oversized-Attribute Storage Technique</source>
          <target state="translated">특 대형 스토리지 기술</target>
        </trans-unit>
        <trans-unit id="e0b1bfcde4d47951e13640eda18c565a127fb8e6" translate="yes" xml:space="preserve">
          <source>The POSIX pattern language is described in much greater detail below.</source>
          <target state="translated">POSIX 패턴 언어는 아래에 훨씬 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="153ece47c4d9b24a5da118c8706404d098e93a76" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;xml&lt;/code&gt; data type can only hold a value in &lt;code&gt;DOCUMENT&lt;/code&gt; or &lt;code&gt;CONTENT&lt;/code&gt; form. An XQuery/XPath expression context item must be a single XML node or atomic value, but XPath 1.0 further restricts it to be only an XML node, and has no node type allowing &lt;code&gt;CONTENT&lt;/code&gt;. The upshot is that a well-formed &lt;code&gt;DOCUMENT&lt;/code&gt; is the only form of XML value that PostgreSQL can supply as an XPath context item.</source>
          <target state="translated">PostgreSQL &lt;code&gt;xml&lt;/code&gt; 데이터 형식은 &lt;code&gt;DOCUMENT&lt;/code&gt; 또는 &lt;code&gt;CONTENT&lt;/code&gt; 형식 의 값만 보유 할 수 있습니다 . XQuery / XPath 표현식 컨텍스트 항목은 단일 XML 노드 또는 원자 값이어야하지만 XPath 1.0은 추가로 XML 노드로 제한하며 &lt;code&gt;CONTENT&lt;/code&gt; 를 허용하는 노드 유형이 없습니다 . 결론은 제대로 구성된 &lt;code&gt;DOCUMENT&lt;/code&gt; 가 PostgreSQL이 XPath 컨텍스트 항목으로 제공 할 수있는 유일한 XML 값 형식이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8019e62373b33be0ae1394da9ad186299d75d149" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clause &lt;code&gt;TABLESPACE&lt;/code&gt; is an extension.</source>
          <target state="translated">테이블 스페이스의 PostgreSQL 개념은 표준의 일부가 아닙니다. 따라서 &lt;code&gt;TABLESPACE&lt;/code&gt; 절 은 확장입니다.</target>
        </trans-unit>
        <trans-unit id="36ca8d540410a034c5a8f32708649004d256e17f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL concept of tablespaces is not part of the standard. Hence, the clauses &lt;code&gt;TABLESPACE&lt;/code&gt; and &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; are extensions.</source>
          <target state="translated">테이블 스페이스의 PostgreSQL 개념은 표준의 일부가 아닙니다. 따라서 &lt;code&gt;TABLESPACE&lt;/code&gt; 및 &lt;code&gt;USING INDEX TABLESPACE&lt;/code&gt; 절 은 확장입니다.</target>
        </trans-unit>
        <trans-unit id="74677c1410d0f3c49eba1a7361732a37abea01cf" translate="yes" xml:space="preserve">
          <source>The PostgreSQL formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;Table 9.24&lt;/a&gt; lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</source>
          <target state="translated">PostgreSQL 형식화 기능은 다양한 데이터 유형 (날짜 / 시간, 정수, 부동 소수점, 숫자)을 형식화 된 문자열로 변환하고 형식화 된 문자열에서 특정 데이터 형식으로 변환하기위한 강력한 도구 세트를 제공합니다. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-TABLE&quot;&gt;표 9.24에&lt;/a&gt; 이들이 나와 있습니다. 이러한 함수는 모두 공통 호출 규칙을 따릅니다. 첫 번째 인수는 형식화 할 값이고 두 번째 인수는 출력 또는 입력 형식을 정의하는 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="477d95f901512677a235f7ee46a8f81ecd4001b6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the infix operator &lt;code&gt;&amp;lt;@&lt;/code&gt;, but the only two that could possibly accept an integer array on the left-hand side are array inclusion (&lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyarray&lt;/code&gt;) and range inclusion (&lt;code&gt;anyelement&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;anyrange&lt;/code&gt;). Since none of these polymorphic pseudo-types (see &lt;a href=&quot;datatype-pseudo&quot;&gt;Section 8.21&lt;/a&gt;) are considered preferred, the parser cannot resolve the ambiguity on that basis. However, &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;Step 3.f&lt;/a&gt; tells it to assume that the unknown-type literal is of the same type as the other input, that is, integer array. Now only one of the two operators can match, so array inclusion is selected. (Had range inclusion been selected, we would have gotten an error, because the string does not have the right format to be a range literal.)</source>
          <target state="translated">PostgreSQL 연산자 카탈로그에는 접두사 연산자 &lt;code&gt;&amp;lt;@&lt;/code&gt; 에 대한 여러 항목이 있지만 왼쪽에 정수 배열을 허용 할 수있는 유일한 것은 배열 포함 ( &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyarray&lt;/code&gt; ) 및 범위 포함 ( &lt;code&gt;anyelement&lt;/code&gt; &lt;code&gt;&amp;lt;@&lt;/code&gt; &lt;code&gt;anyrange&lt;/code&gt; )입니다. 이러한 다형성 의사 유형 ( &lt;a href=&quot;datatype-pseudo&quot;&gt;섹션 8.21&lt;/a&gt; 참조 ) 중 어느 것도 선호되는 것으로 간주되지 않기 때문에 구문 분석기는 이러한 기준으로 모호성을 해결할 수 없습니다. 그러나 &lt;a href=&quot;typeconv-oper#OP-RESOL-LAST-UNKNOWN&quot;&gt;3.f 단계&lt;/a&gt;알 수없는 유형 리터럴이 다른 입력과 동일한 유형, 즉 정수 배열이라고 가정하도록 지시합니다. 이제 두 연산자 중 하나만 일치 할 수 있으므로 배열 포함이 선택됩니다. (범위 포함을 선택했으면 문자열에 범위 리터럴에 적합한 형식이 없기 때문에 오류가 발생했을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="7623f7756c9bed57d74564163e6b686074d22548" translate="yes" xml:space="preserve">
          <source>The PostgreSQL operator catalog has several entries for the prefix operator &lt;code&gt;@&lt;/code&gt;, all of which implement absolute-value operations for various numeric data types. One of these entries is for type &lt;code&gt;float8&lt;/code&gt;, which is the preferred type in the numeric category. Therefore, PostgreSQL will use that entry when faced with an &lt;code&gt;unknown&lt;/code&gt; input:</source>
          <target state="translated">PostgreSQL 연산자 카탈로그에는 접두사 연산자 &lt;code&gt;@&lt;/code&gt; 에 대한 여러 항목이 있으며 , 모두 다양한 숫자 데이터 유형에 대한 절대 값 연산을 구현합니다. 이러한 항목 중 하나는 &lt;code&gt;float8&lt;/code&gt; 유형에 대한 것이며, 이는 숫자 카테고리에서 선호되는 유형입니다. 따라서 PostgreSQL은 &lt;code&gt;unknown&lt;/code&gt; 입력에 직면했을 때 해당 항목을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0de6cec8150a5ca1beb884d1dae8f1be83758f61" translate="yes" xml:space="preserve">
          <source>The PostgreSQL query planner relies on statistical information about the contents of tables in order to generate good plans for queries. These statistics are gathered by the &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; command, which can be invoked by itself or as an optional step in &lt;code&gt;VACUUM&lt;/code&gt;. It is important to have reasonably accurate statistics, otherwise poor choices of plans might degrade database performance.</source>
          <target state="translated">PostgreSQL 쿼리 플래너는 쿼리에 대한 좋은 계획을 생성하기 위해 테이블 ​​내용에 대한 통계 정보를 사용합니다. 이러한 통계는 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령 으로 수집되며 ,이 명령은 자체적으로 또는 &lt;code&gt;VACUUM&lt;/code&gt; 의 선택적 단계로 호출 할 수 있습니다 . 합리적으로 정확한 통계를 확보하는 것이 중요합니다. 그렇지 않으면 계획을 잘못 선택하면 데이터베이스 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091f965ebb32941711ea5df90e349daf215494b9" translate="yes" xml:space="preserve">
          <source>The PostgreSQL rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed. Alternatively, an &lt;code&gt;INSTEAD&lt;/code&gt; rule can replace a given command by another, or cause a command not to be executed at all. Rules are used to implement SQL views as well. It is important to realize that a rule is really a command transformation mechanism, or command macro. The transformation happens before the execution of the command starts. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule. More information about the rules system is in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 규칙 시스템을 사용하면 데이터베이스 테이블에서 삽입, 업데이트 또는 삭제시 수행 할 대체 작업을 정의 할 수 있습니다. 대략적으로 말하면, 규칙은 주어진 테이블에서 주어진 명령이 실행될 때 추가 명령이 실행되도록합니다. 또는 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙은 지정된 명령을 다른 명령으로 대체하거나 명령이 전혀 실행되지 않도록 할 수 있습니다. 규칙은 SQL 뷰도 구현하는 데 사용됩니다. 규칙이 실제로 명령 변환 메커니즘 또는 명령 매크로라는 것을 인식하는 것이 중요합니다. 명령 실행이 시작되기 전에 변환이 수행됩니다. 실제로 각 물리적 행에 대해 독립적으로 실행되는 작업을 원한다면 규칙이 아닌 트리거를 사용하고 싶을 것입니다. 규칙 시스템에 대한 자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;40 장에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="10a690ef1ea7666469e6c355dbc334d6d1d70eb6" translate="yes" xml:space="preserve">
          <source>The PostgreSQL scanner/parser divides lexical elements into five fundamental categories: integers, non-integer numbers, strings, identifiers, and key words. Constants of most non-numeric types are first classified as strings. The SQL language definition allows specifying type names with strings, and this mechanism can be used in PostgreSQL to start the parser down the correct path. For example, the query:</source>
          <target state="translated">PostgreSQL 스캐너 / 파서는 어휘 요소를 정수, 정수가 아닌 숫자, 문자열, 식별자 및 키워드의 5 가지 기본 범주로 나눕니다. 숫자가 아닌 유형의 상수는 먼저 문자열로 분류됩니다. SQL 언어 정의를 사용하면 문자열로 유형 이름을 지정할 수 있으며 PostgreSQL에서이 메커니즘을 사용하여 올바른 경로에서 파서를 시작할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6aed6106f2d7424b2bbb821dba77f382392bc5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (&amp;ldquo;forks&amp;rdquo;) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original &lt;code&gt;postgres&lt;/code&gt; process. Thus, the master server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)</source>
          <target state="translated">PostgreSQL 서버는 클라이언트의 여러 동시 연결을 처리 할 수 ​​있습니다. 이를 위해 각 연결마다 새로운 프로세스가 시작됩니다 (&amp;ldquo;포크&amp;rdquo;). 이때부터 클라이언트와 새 서버 프로세스는 원래 &lt;code&gt;postgres&lt;/code&gt; 프로세스의 개입없이 통신 합니다. 따라서 마스터 서버 프로세스는 항상 실행 중이며 클라이언트 연결을 기다리는 반면 클라이언트 및 관련 서버 프로세스는왔다 갔다합니다. (이 모든 것은 물론 사용자에게는 보이지 않습니다. 여기서는 완전성을 위해 여기에서만 언급합니다.)</target>
        </trans-unit>
        <trans-unit id="7af0f9ca01829c95b3c4cfa20671b04ccaa7a1b4" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server uses one process per connection so you should provide for at least as many processes as allowed connections, in addition to what you need for the rest of your system. This is usually not a problem but if you run several servers on one machine things might get tight.</source>
          <target state="translated">PostgreSQL 서버는 연결 당 하나의 프로세스를 사용하므로 나머지 시스템에 필요한 것 외에도 허용되는 연결 수만큼 프로세스를 제공해야합니다. 이것은 일반적으로 문제가되지 않지만 한 시스템에서 여러 서버를 실행하면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="929274b54effcc47ded1784455530166b7871347" translate="yes" xml:space="preserve">
          <source>The PostgreSQL server will listen for both normal and GSSAPI-encrypted connections on the same TCP port, and will negotiate with any connecting client on whether to use GSSAPI for encryption (and for authentication). By default, this decision is up to the client (which means it can be downgraded by an attacker); see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt; about setting up the server to require the use of GSSAPI for some or all connections.</source>
          <target state="translated">PostgreSQL 서버는 동일한 TCP 포트에서 일반 및 GSSAPI 암호화 연결을 수신하고 암호화 및 인증에 GSSAPI를 사용할지 여부에 대해 연결 클라이언트와 협상합니다. 기본적으로이 결정은 클라이언트에 달려 있습니다 (즉, 공격자가 다운 그레이드 할 수 있음). 일부 또는 모든 연결에 GSSAPI를 사용하도록 서버를 설정하는 방법은 &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;20.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4cf80f6b7604fb8b47859e4bbfb35130b5f3d5d" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt;). The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GiST operator classes:</source>
          <target state="translated">PostgreSQL 소스 배포에는 GiST를 사용하여 구현 된 몇 가지 인덱스 메소드 예제가 포함되어 있습니다. 핵심 시스템은 현재 텍스트 검색 지원 ( &lt;code&gt;tsvector&lt;/code&gt; 및 &lt;code&gt;tsquery&lt;/code&gt; 에 대한 색인 작성 )과 내장 된 일부 기하 데이터 유형에 대한 R-Tree 동등한 기능을 제공합니다 ( &lt;code&gt;src/backend/access/gist/gistproc.c&lt;/code&gt; 참조 ). 다음 &lt;code&gt;contrib&lt;/code&gt; 모듈에는 GiST 연산자 클래스도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0456fd311416d751f4442303736e9783a5f29ea" translate="yes" xml:space="preserve">
          <source>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;. Look into &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; and &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; to see the code.</source>
          <target state="translated">PostgreSQL 소스 배포에는 &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 65.1에&lt;/a&gt; 설명 된 것처럼 SP-GiST에 대한 여러 인덱스 연산자 클래스 예제가 포함되어 있습니다 . 조사 &lt;code&gt;src/backend/access/spgist/&lt;/code&gt; 및 &lt;code&gt;src/backend/utils/adt/&lt;/code&gt; 코드를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da6bb87f4fbef7ca2cd7285a5ff15baca5680b91" translate="yes" xml:space="preserve">
          <source>The PostgreSQL type system contains a number of special-purpose entries that are collectively called &lt;em&gt;pseudo-types&lt;/em&gt;. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type. Each of the available pseudo-types is useful in situations where a function's behavior does not correspond to simply taking or returning a value of a specific SQL data type. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; lists the existing pseudo-types.</source>
          <target state="translated">PostgreSQL 유형 시스템에는 &lt;em&gt;의사 유형&lt;/em&gt; 이라고하는 여러 특수 목적 항목이 포함되어 &lt;em&gt;있습니다&lt;/em&gt; . 의사 유형은 열 데이터 유형으로 사용할 수 없지만 함수의 인수 또는 결과 유형을 선언하는 데 사용할 수 있습니다. 사용 가능한 각 의사 유형은 함수의 동작이 단순히 특정 SQL 데이터 유형의 값을 가져 오거나 반환하는 것과 일치하지 않는 상황에서 유용합니다. &lt;a href=&quot;datatype-pseudo#DATATYPE-PSEUDOTYPES-TABLE&quot;&gt;Table 8.27&lt;/a&gt; 에는 기존 의사 유형이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="3627ccc448cafae762325bbb25d1d00e8338b2f1" translate="yes" xml:space="preserve">
          <source>The PostgreSQL-specific functions &lt;code&gt;xpath()&lt;/code&gt; and &lt;code&gt;xpath_exists()&lt;/code&gt; query XML documents using the XPath language. PostgreSQL also provides XPath-only variants of the standard functions &lt;code&gt;XMLEXISTS&lt;/code&gt; and &lt;code&gt;XMLTABLE&lt;/code&gt;, which officially use the XQuery language. For all of these functions, PostgreSQL relies on the libxml2 library, which provides only XPath 1.0.</source>
          <target state="translated">PostgreSQL 관련 함수 &lt;code&gt;xpath()&lt;/code&gt; 및 &lt;code&gt;xpath_exists()&lt;/code&gt; 는 XPath 언어를 사용하여 XML 문서를 쿼리합니다. PostgreSQL은 공식적으로 XQuery 언어를 사용하는 표준 함수 &lt;code&gt;XMLEXISTS&lt;/code&gt; 및 &lt;code&gt;XMLTABLE&lt;/code&gt; 의 XPath 전용 변형도 제공합니다 . 이러한 모든 기능에 대해 PostgreSQL은 XPath 1.0 만 제공하는 libxml2 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="efd965ec5103a44f1272738f66a9e9d5dd0aabd5" translate="yes" xml:space="preserve">
          <source>The ROW keyword is actually optional as long as you have more than one field in the expression, so these can be simplified to:</source>
          <target state="translated">ROW 키워드는 표현식에 필드가 두 개 이상있는 한 실제로 선택 사항이므로 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091f62aabb99c30a476910bd3ba420fa9f860db6" translate="yes" xml:space="preserve">
          <source>The Repeatable Read mode provides a rigorous guarantee that each transaction sees a completely stable view of the database. However, this view will not necessarily always be consistent with some serial (one at a time) execution of concurrent transactions of the same level. For example, even a read only transaction at this level may see a control record updated to show that a batch has been completed but &lt;em&gt;not&lt;/em&gt; see one of the detail records which is logically part of the batch because it read an earlier revision of the control record. Attempts to enforce business rules by transactions running at this isolation level are not likely to work correctly without careful use of explicit locks to block conflicting transactions.</source>
          <target state="translated">반복 가능한 읽기 모드는 각 트랜잭션이 데이터베이스를 완전히 안정적으로 볼 수 있도록 보장합니다. 그러나이 관점이 반드시 동일한 레벨의 동시 트랜잭션의 일부 (한 번에 하나씩) 실행과 항상 일치하는 것은 아닙니다. 예를 들어,이 레벨의 읽기 전용 트랜잭션조차도 배치가 완료되었음을 표시하기 위해 제어 레코드가 업데이트되었지만 제어 레코드의 이전 개정을 읽었으므로 배치의 논리적 부분 인 세부 레코드 중 하나를 볼 수 &lt;em&gt;없습니다.&lt;/em&gt; . 이 격리 수준에서 실행되는 트랜잭션으로 비즈니스 규칙을 적용하려는 시도는 충돌하는 트랜잭션을 차단하기 위해 명시 적 잠금을주의해서 사용하지 않으면 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebce75022660ba392e40784c2cdda41c615a64f" translate="yes" xml:space="preserve">
          <source>The SCRAM specification dictates that the password is also in UTF-8, and is processed with the &lt;em&gt;SASLprep&lt;/em&gt; algorithm. PostgreSQL, however, does not require UTF-8 to be used for the password. When a user's password is set, it is processed with SASLprep as if it was in UTF-8, regardless of the actual encoding used. However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences that are prohibited by the SASLprep algorithm, the raw password will be used without SASLprep processing, instead of throwing an error. This allows the password to be normalized when it is in UTF-8, but still allows a non-UTF-8 password to be used, and doesn't require the system to know which encoding the password is in.</source>
          <target state="translated">SCRAM 사양에서는 암호도 UTF-8로되어 있으며 &lt;em&gt;SASLprep&lt;/em&gt; 알고리즘으로 처리됩니다 . 그러나 PostgreSQL에서는 비밀번호로 UTF-8을 사용할 필요가 없습니다. 사용자 비밀번호가 설정되면 사용 된 실제 인코딩에 관계없이 마치 UTF-8 인 것처럼 SASLprep로 처리됩니다. 그러나 유효한 UTF-8 바이트 시퀀스가 ​​아니거나 SASLprep 알고리즘에 의해 금지 된 UTF-8 바이트 시퀀스를 포함하는 경우 원시 비밀번호는 오류를 발생시키는 대신 SASLprep 처리없이 사용됩니다. 이를 통해 UTF-8 인 경우 비밀번호를 정규화 할 수 있지만 UTF-8 이외의 비밀번호를 계속 사용할 수 있으며 시스템에서 비밀번호가 어떤 인코딩인지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e7a1522eba0328b9be11871eb393a000b642ba7" translate="yes" xml:space="preserve">
          <source>The SP-GiST core can override the results of the operator class's &lt;code&gt;picksplit&lt;/code&gt; function when &lt;code&gt;picksplit&lt;/code&gt; fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that &lt;code&gt;picksplit&lt;/code&gt; gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The &lt;code&gt;allTheSame&lt;/code&gt; flag is set on the inner tuple to warn the &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions that the tuple does not have the node set that they might otherwise expect.</source>
          <target state="translated">&lt;code&gt;picksplit&lt;/code&gt; 이 제공된 리프 값을 둘 이상의 노드 범주로 나누지 못하면 SP-GiST 코어가 운영자 클래스의 &lt;code&gt;picksplit&lt;/code&gt; 함수 결과를 무시할 수 있습니다 . 이 경우, 새로운 내부 튜플은 &lt;code&gt;picksplit&lt;/code&gt; 이 사용한 하나의 노드에 부여한 동일한 레이블 (있는 경우)을 가진 여러 노드로 각각 생성되며 리프 값은 이러한 동등한 노드 사이에서 무작위로 나뉩니다. &lt;code&gt;allTheSame&lt;/code&gt; 의 플래그는 경고 내부 튜플에 설정 &lt;code&gt;choose&lt;/code&gt; 하고 &lt;code&gt;inner_consistent&lt;/code&gt; 튜플들이 그렇지 예상 할 수있는 노드가 설정되어 있지 않는 기능.</target>
        </trans-unit>
        <trans-unit id="d1b14a46877d8df03142e17f562b21c36e25830b" translate="yes" xml:space="preserve">
          <source>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</source>
          <target state="translated">SP-GiST 코어 코드는 널 항목을 처리합니다. SP-GiST 인덱스는 인덱스 열에 Null에 대한 항목을 저장하지만 인덱스 연산자 클래스 코드에서 숨겨집니다. Null 인덱스 항목 또는 검색 조건이 연산자 클래스 메서드에 전달되지 않습니다. (SP-GiST 연산자는 엄격하므로 널값에 대해서는 성공할 수 없습니다.) 따라서 널값에 대해서는 더 이상 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe87973f3ef5a0d6b6662bce168960f63417cd65" translate="yes" xml:space="preserve">
          <source>The SQL &lt;code&gt;CASE&lt;/code&gt; expression is a generic conditional expression, similar to if/else statements in other programming languages:</source>
          <target state="translated">SQL &lt;code&gt;CASE&lt;/code&gt; 표현식은 다른 프로그래밍 언어의 if / else 문과 유사한 일반 조건식입니다.</target>
        </trans-unit>
        <trans-unit id="d48ab325670cd3e1aa8741d57a661891b103e0ac" translate="yes" xml:space="preserve">
          <source>The SQL command &lt;code&gt;SET TIME ZONE&lt;/code&gt; sets the time zone for the session. This is an alternative spelling of &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; with a more SQL-spec-compatible syntax.</source>
          <target state="translated">SQL 명령 &lt;code&gt;SET TIME ZONE&lt;/code&gt; 은 세션의 시간대를 설정합니다. 이는 더 SQL 사양 호환 구문을 사용하는 &lt;code&gt;SET TIMEZONE TO&lt;/code&gt; 의 다른 철자입니다 .</target>
        </trans-unit>
        <trans-unit id="64de07c340bdb76d49ccd2451af6603ff373cc2b" translate="yes" xml:space="preserve">
          <source>The SQL declaration of the function must look like this:</source>
          <target state="translated">함수의 SQL 선언은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d7b4645499046b1f0731ca7d87e83bccfa0f031d" translate="yes" xml:space="preserve">
          <source>The SQL script will be written to the standard output. Use the &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--file&lt;/code&gt; option or shell operators to redirect it into a file.</source>
          <target state="translated">SQL 스크립트가 표준 출력에 작성됩니다. 사용 &lt;code&gt;-f&lt;/code&gt; / &lt;code&gt;--file&lt;/code&gt; 옵션을하거나 파일로 리디렉션 연산자를 쉘.</target>
        </trans-unit>
        <trans-unit id="e638b08fc8b7ed4b2fdc056d0b48506d414e8ee3" translate="yes" xml:space="preserve">
          <source>The SQL specification requires row-wise comparison to return NULL if the result depends on comparing two NULL values or a NULL and a non-NULL. PostgreSQL does this only when comparing the results of two row constructors (as in &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;) or comparing a row constructor to the output of a subquery (as in &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;). In other contexts where two composite-type values are compared, two NULL field values are considered equal, and a NULL is considered larger than a non-NULL. This is necessary in order to have consistent sorting and indexing behavior for composite types.</source>
          <target state="translated">결과가 두 개의 NULL 값 또는 NULL과 NULL이 아닌 값을 비교하는 데 의존하는 경우 SQL 스펙은 행 단위 비교를 통해 NULL을 리턴해야합니다. PostgreSQL은 ( &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5&lt;/a&gt; 에서와 같이) 두 개의 행 생성자의 결과를 비교하거나 ( &lt;a href=&quot;functions-subquery&quot;&gt;9.22&lt;/a&gt; 에서와 같이) 하위 생성자의 출력과 행 생성자를 비교할 때만이 를 수행합니다 . 두 개의 복합 유형 값이 비교되는 다른 컨텍스트에서는 두 개의 NULL 필드 값이 동일한 것으로 간주되고 NULL은 NULL이 아닌 값보다 큰 것으로 간주됩니다. 복합 유형에 대해 일관된 정렬 및 인덱싱 동작을 갖기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="22ab3c86af000737aa210aeaf592af19c218233b" translate="yes" xml:space="preserve">
          <source>The SQL standard (not XQuery itself) attempts to cater for more variants of &amp;ldquo;newline&amp;rdquo; than POSIX does. The newline-sensitive matching options described above consider only ASCII NL (&lt;code&gt;\n&lt;/code&gt;) to be a newline, but SQL would have us treat CR (&lt;code&gt;\r&lt;/code&gt;), CRLF (&lt;code&gt;\r\n&lt;/code&gt;) (a Windows-style newline), and some Unicode-only characters like LINE SEPARATOR (U+2028) as newlines as well. Notably, &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; should count &lt;code&gt;\r\n&lt;/code&gt; as one character not two according to SQL.</source>
          <target state="translated">SQL 표준 (XQuery 자체가 아님)은 POSIX보다 더 많은 &quot;줄 바꿈&quot;변형을 제공하려고합니다. 위에서 설명한 개행 구분 일치 옵션은 ASCII NL ( &lt;code&gt;\n&lt;/code&gt; ) 만 개행으로 간주 하지만 SQL은 CR ( &lt;code&gt;\r&lt;/code&gt; ), CRLF ( &lt;code&gt;\r\n&lt;/code&gt; ) (Windows 스타일 개행) 및 일부를 처리해야합니다. LINE SEPARATOR (U + 2028)와 같은 유니 코드 전용 문자도 줄 바꿈입니다. 특히 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;\s&lt;/code&gt; 계산한다 &lt;code&gt;\r\n&lt;/code&gt; 한 문자로 SQL에 따른 두하지.</target>
        </trans-unit>
        <trans-unit id="3ca979281ade8cf94abb51fcd1544322941db9bd" translate="yes" xml:space="preserve">
          <source>The SQL standard allows a &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; clause in &lt;code&gt;CREATE SCHEMA&lt;/code&gt;, as well as more subcommand types than are presently accepted by PostgreSQL.</source>
          <target state="translated">SQL 표준은 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 의 &lt;code&gt;DEFAULT CHARACTER SET&lt;/code&gt; 절 과 현재 PostgreSQL에서 허용되는 것보다 많은 하위 명령 유형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a28253dba0b95d8667501243721aade5c4069637" translate="yes" xml:space="preserve">
          <source>The SQL standard allows cursors only in embedded SQL and in modules. PostgreSQL permits cursors to be used interactively.</source>
          <target state="translated">SQL 표준은 내장 SQL 및 모듈에서만 커서를 허용합니다. PostgreSQL에서는 커서를 대화식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7005659d6b42749138703e7ef74f259a352e97f5" translate="yes" xml:space="preserve">
          <source>The SQL standard allows only &lt;code&gt;FROM&lt;/code&gt; preceding the cursor name; the option to use &lt;code&gt;IN&lt;/code&gt;, or to leave them out altogether, is an extension.</source>
          <target state="translated">SQL 표준에서는 커서 이름 앞에 &lt;code&gt;FROM&lt;/code&gt; 만 허용합니다 . &lt;code&gt;IN&lt;/code&gt; 을 사용 하거나 모두 생략 하는 옵션 은 확장입니다.</target>
        </trans-unit>
        <trans-unit id="69a8fc7cc008eb25ed064f0d1fdca190a5bf8644" translate="yes" xml:space="preserve">
          <source>The SQL standard allows some other expressions to appear in place of the literal &lt;code&gt;user_name&lt;/code&gt;, but these options are not important in practice. PostgreSQL allows identifier syntax (&lt;code&gt;&quot;username&quot;&lt;/code&gt;), which SQL does not. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">SQL 표준에서는 리터럴 &lt;code&gt;user_name&lt;/code&gt; 대신 다른 표현식을 표시 할 수 있지만 실제로는 이러한 옵션이 중요하지 않습니다. PostgreSQL은 식별자 구문 ( &lt;code&gt;&quot;username&quot;&lt;/code&gt; )을 허용하지만 SQL은 그렇지 않습니다. SQL은 트랜잭션 중에이 명령을 허용하지 않습니다. 이유가 없기 때문에 PostgreSQL은 이러한 제한을 두지 않습니다. &lt;code&gt;SESSION&lt;/code&gt; 및 &lt;code&gt;LOCAL&lt;/code&gt; 개질제로하고, PostgreSQL의 확장이다 &lt;code&gt;RESET&lt;/code&gt; 의 구문.</target>
        </trans-unit>
        <trans-unit id="b623e7f141c55510760b9b77e9eb99f9e4321e9e" translate="yes" xml:space="preserve">
          <source>The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. Since PostgreSQL does not support SQL modules, this distinction is not relevant in PostgreSQL.</source>
          <target state="translated">SQL 표준은 또한 전역 임시 테이블과 로컬 임시 테이블을 구별합니다. 여기서 로컬 임시 테이블은 각 세션 내의 각 SQL 모듈에 대해 별도의 컨텐츠 세트를 갖지만 정의는 세션간에 공유됩니다. PostgreSQL은 SQL 모듈을 지원하지 않기 때문에이 차이점은 PostgreSQL과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f9fa0f99df0f3d6e4d172f087bbf08f499d13c0" translate="yes" xml:space="preserve">
          <source>The SQL standard and PostgreSQL-implemented transaction isolation levels are described in &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;Table 13.1&lt;/a&gt;.</source>
          <target state="translated">SQL 표준 및 PostgreSQL 구현 트랜잭션 격리 수준은 &lt;a href=&quot;transaction-iso#MVCC-ISOLEVEL-TABLE&quot;&gt;표 13.1에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49f9cf60061c8b5fe47367c7175f7b9d12754fa" translate="yes" xml:space="preserve">
          <source>The SQL standard calls databases &amp;ldquo;catalogs&amp;rdquo;, but there is no difference in practice.</source>
          <target state="translated">SQL 표준은 데이터베이스를 &quot;카탈로그&quot;라고하지만 실제로는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6b9dd41b616b1103c4995e9bab7f0a1474529d1" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;DROP ROLE&lt;/code&gt;, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than PostgreSQL uses.</source>
          <target state="translated">SQL 표준은 &lt;code&gt;DROP ROLE&lt;/code&gt; 을 정의 하지만 한 번에 하나의 역할 만 삭제할 수 있으며 PostgreSQL이 사용하는 것과 다른 권한 요구 사항을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="89dd410d4b1dc70cede977d3716ec82a83bd84ad" translate="yes" xml:space="preserve">
          <source>The SQL standard defines &lt;code&gt;FETCH&lt;/code&gt; for use in embedded SQL only. The variant of &lt;code&gt;FETCH&lt;/code&gt; described here returns the data as if it were a &lt;code&gt;SELECT&lt;/code&gt; result rather than placing it in host variables. Other than this point, &lt;code&gt;FETCH&lt;/code&gt; is fully upward-compatible with the SQL standard.</source>
          <target state="translated">SQL 표준은 Embedded SQL에서만 사용하기 위해 &lt;code&gt;FETCH&lt;/code&gt; 를 정의 합니다. 여기에 설명 된 &lt;code&gt;FETCH&lt;/code&gt; 의 변형은 데이터를 호스트 변수에 배치하지 않고 &lt;code&gt;SELECT&lt;/code&gt; 결과 인 것처럼 데이터를 리턴합니다 . 이 시점을 제외하고 &lt;code&gt;FETCH&lt;/code&gt; 는 SQL 표준과 완전히 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0433545c375e6f7a87b9a6951397354ec73ee790" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a &lt;code&gt;RESPECT NULLS&lt;/code&gt; or &lt;code&gt;IGNORE NULLS&lt;/code&gt; option for &lt;code&gt;lead&lt;/code&gt;, &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt;. This is not implemented in PostgreSQL: the behavior is always the same as the standard's default, namely &lt;code&gt;RESPECT NULLS&lt;/code&gt;. Likewise, the standard's &lt;code&gt;FROM FIRST&lt;/code&gt; or &lt;code&gt;FROM LAST&lt;/code&gt; option for &lt;code&gt;nth_value&lt;/code&gt; is not implemented: only the default &lt;code&gt;FROM FIRST&lt;/code&gt; behavior is supported. (You can achieve the result of &lt;code&gt;FROM LAST&lt;/code&gt; by reversing the &lt;code&gt;ORDER BY&lt;/code&gt; ordering.)</source>
          <target state="translated">SQL 표준은 &lt;code&gt;lead&lt;/code&gt; , &lt;code&gt;lag&lt;/code&gt; , &lt;code&gt;first_value&lt;/code&gt; , &lt;code&gt;last_value&lt;/code&gt; 및 &lt;code&gt;nth_value&lt;/code&gt; 에 대한 &lt;code&gt;RESPECT NULLS&lt;/code&gt; 또는 &lt;code&gt;IGNORE NULLS&lt;/code&gt; 옵션을 정의합니다 . 이것은 PostgreSQL에서 구현되지 않습니다. 동작은 항상 표준의 기본값, 즉 &lt;code&gt;RESPECT NULLS&lt;/code&gt; 와 동일합니다 . 마찬가지로, &lt;code&gt;nth_value&lt;/code&gt; 에 대한 표준의 &lt;code&gt;FROM FIRST&lt;/code&gt; 또는 &lt;code&gt;FROM LAST&lt;/code&gt; 옵션 은 구현되지 않습니다. 기본 &lt;code&gt;FROM FIRST&lt;/code&gt; 동작 만 지원됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 순서를 반대로하면 &lt;code&gt;FROM LAST&lt;/code&gt; 의 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa458ed41634d193bea2fac0154b209dd0cf765a" translate="yes" xml:space="preserve">
          <source>The SQL standard defines a different binary string type, called &lt;code&gt;BLOB&lt;/code&gt; or &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt;. The input format is different from &lt;code&gt;bytea&lt;/code&gt;, but the provided functions and operators are mostly the same.</source>
          <target state="translated">SQL 표준은 &lt;code&gt;BLOB&lt;/code&gt; 또는 &lt;code&gt;BINARY LARGE OBJECT&lt;/code&gt; 라는 다른 이진 문자열 유형을 정의합니다 . 입력 형식은 &lt;code&gt;bytea&lt;/code&gt; 와 다르지만 제공된 기능과 연산자는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a6502238836b3c1e6ea2cb2c05c9c3eff6b47428" translate="yes" xml:space="preserve">
          <source>The SQL standard defines four levels of transaction isolation. The most strict is Serializable, which is defined by the standard in a paragraph which says that any concurrent execution of a set of Serializable transactions is guaranteed to produce the same effect as running them one at a time in some order. The other three levels are defined in terms of phenomena, resulting from interaction between concurrent transactions, which must not occur at each level. The standard notes that due to the definition of Serializable, none of these phenomena are possible at that level. (This is hardly surprising -- if the effect of the transactions must be consistent with having been run one at a time, how could you see any phenomena caused by interactions?)</source>
          <target state="translated">SQL 표준은 4 가지 수준의 트랜잭션 격리를 정의합니다. 가장 엄격한 것은 Serializable입니다. Serializable은 일련의 Serializable 트랜잭션을 동시에 실행하면 순서대로 한 번에 하나씩 실행하는 것과 동일한 효과를 보장한다는 단락의 표준에 정의되어 있습니다. 다른 3 가지 레벨은 동시 트랜잭션 간의 상호 작용으로 인해 발생하는 현상으로 정의되며 각 레벨에서 발생해서는 안됩니다. 표준에 따르면 Serializable의 정의로 인해 해당 수준에서 이러한 현상이 발생하지 않습니다. (이것은 거의 놀라운 일이 아닙니다. 트랜잭션의 효과가 한 번에 하나씩 실행 된 것과 일치해야하는 경우 상호 작용으로 인한 현상을 어떻게 알 수 있습니까?)</target>
        </trans-unit>
        <trans-unit id="e0bda65f48165dca64ab0bb74baf32b2635a1f88" translate="yes" xml:space="preserve">
          <source>The SQL standard defines one additional level, &lt;code&gt;READ UNCOMMITTED&lt;/code&gt;. In PostgreSQL &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; is treated as &lt;code&gt;READ COMMITTED&lt;/code&gt;.</source>
          <target state="translated">SQL 표준은 하나의 추가 레벨 인 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; 를 정의합니다 . PostgreSQL에서 &lt;code&gt;READ UNCOMMITTED&lt;/code&gt; 는 &lt;code&gt;READ COMMITTED&lt;/code&gt; 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="4646156599f749581333cb75ad841c671d1c0b23" translate="yes" xml:space="preserve">
          <source>The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. In PostgreSQL we have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.</source>
          <target state="translated">SQL 표준은 사용자와 역할의 개념을 정의하지만이를 개별 개념으로 간주하고 사용자를 정의하는 모든 명령을 각 데이터베이스 구현에서 지정하도록합니다. PostgreSQL에서는 사용자와 역할을 단일 유형의 엔티티로 통합하기로했습니다. 따라서 역할에는 표준보다 많은 선택적 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0663b6424dd2f8b2135d82962a5208510f77e258" translate="yes" xml:space="preserve">
          <source>The SQL standard defines two &lt;em&gt;passing mechanisms&lt;/em&gt; that apply when passing an XML argument from SQL to an XML function or receiving a result: &lt;code&gt;BY REF&lt;/code&gt;, in which a particular XML value retains its node identity, and &lt;code&gt;BY VALUE&lt;/code&gt;, in which the content of the XML is passed but node identity is not preserved. A mechanism can be specified before a list of parameters, as the default mechanism for all of them, or after any parameter, to override the default.</source>
          <target state="translated">SQL 표준은 XML에서 XML 인수를 XML 함수로 전달하거나 결과를 수신 할 때 적용되는 두 가지 &lt;em&gt;전달 메커니즘&lt;/em&gt; 을 정의합니다 . 특정 XML 값이 노드 ID를 보유하는 &lt;code&gt;BY REF&lt;/code&gt; 및 XML의 컨텐츠를 갖는 &lt;code&gt;BY VALUE&lt;/code&gt; 전달되지만 노드 ID는 유지되지 않습니다. 매개 변수 목록 앞에, 모든 매개 변수에 대한 기본 메커니즘으로 또는 매개 변수 뒤에 메커니즘을 지정하여 기본값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be5477647682fea4652e9633a7fdf7ae02cb95d" translate="yes" xml:space="preserve">
          <source>The SQL standard differentiates &lt;code&gt;timestamp without time zone&lt;/code&gt; and &lt;code&gt;timestamp with time zone&lt;/code&gt; literals by the presence of a &amp;ldquo;+&amp;rdquo; or &amp;ldquo;-&amp;rdquo; symbol and time zone offset after the time. Hence, according to the standard,</source>
          <target state="translated">표준은 SQL 구별은 &lt;code&gt;timestamp without time zone&lt;/code&gt; 및 &lt;code&gt;timestamp with time zone&lt;/code&gt; 는 &quot;+&quot;또는 존재함으로써 리터럴 &quot;-&quot;기호 및 시간대 시간 후에 오프셋. 따라서 표준에 따르면</target>
        </trans-unit>
        <trans-unit id="e664f1068d4185a0e2c4e6676631526d39744df1" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;DEALLOCATE&lt;/code&gt; statement, but it is only for use in embedded SQL.</source>
          <target state="translated">SQL 표준에는 &lt;code&gt;DEALLOCATE&lt;/code&gt; 문이 포함되어 있지만 Embedded SQL에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c90f74b3a15257d28d6e4bb3296f2c0e98aadae3" translate="yes" xml:space="preserve">
          <source>The SQL standard includes a &lt;code&gt;PREPARE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;PREPARE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL 표준에는 &lt;code&gt;PREPARE&lt;/code&gt; 문이 포함 되지만 Embedded SQL에서만 사용됩니다. 이 버전의 &lt;code&gt;PREPARE&lt;/code&gt; 문도 약간 다른 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe224ee017c2bd35d24d44088347efdd2b498c3d" translate="yes" xml:space="preserve">
          <source>The SQL standard includes an &lt;code&gt;EXECUTE&lt;/code&gt; statement, but it is only for use in embedded SQL. This version of the &lt;code&gt;EXECUTE&lt;/code&gt; statement also uses a somewhat different syntax.</source>
          <target state="translated">SQL 표준에는 &lt;code&gt;EXECUTE&lt;/code&gt; 문이 포함되어 있지만 Embedded SQL에서만 사용됩니다. 이 버전의 &lt;code&gt;EXECUTE&lt;/code&gt; 문도 약간 다른 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3efa28b82e46f4409adc369dc8a870c8a673cbae" translate="yes" xml:space="preserve">
          <source>The SQL standard only makes provisions for cursors in embedded SQL. The PostgreSQL server does not implement an &lt;code&gt;OPEN&lt;/code&gt; statement for cursors; a cursor is considered to be open when it is declared. However, ECPG, the embedded SQL preprocessor for PostgreSQL, supports the standard SQL cursor conventions, including those involving &lt;code&gt;DECLARE&lt;/code&gt; and &lt;code&gt;OPEN&lt;/code&gt; statements.</source>
          <target state="translated">SQL 표준은 Embedded SQL에서 커서를 제공합니다. PostgreSQL 서버는 커서에 대한 &lt;code&gt;OPEN&lt;/code&gt; 문을 구현하지 않습니다 . 커서는 선언 될 때 열린 것으로 간주됩니다. 그러나 PostgreSQL 용 내장 SQL 전처리 기인 ECPG는 &lt;code&gt;DECLARE&lt;/code&gt; 및 &lt;code&gt;OPEN&lt;/code&gt; 문을 포함하는 표준 SQL 커서 규칙을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="27a77950710338562f963e53983e9db24c286f83" translate="yes" xml:space="preserve">
          <source>The SQL standard provides for a &lt;code&gt;USAGE&lt;/code&gt; privilege on other kinds of objects: character sets, collations, translations.</source>
          <target state="translated">SQL 표준은 문자 집합, 데이터 정렬, 번역 등 다른 종류의 개체에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="eee762b9a6787226a912a1d85c8be87d3dbf797a" translate="yes" xml:space="preserve">
          <source>The SQL standard requires commas between successive &lt;code&gt;transaction_modes&lt;/code&gt;, but for historical reasons PostgreSQL allows the commas to be omitted.</source>
          <target state="translated">SQL 표준에는 연속 &lt;code&gt;transaction_modes&lt;/code&gt; 사이에 쉼표가 필요 하지만 역사적 이유로 PostgreSQL에서는 쉼표를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cdcd239c4d51fe5d06e09469371cb72d1e4c5cc" translate="yes" xml:space="preserve">
          <source>The SQL standard requires parentheses around the table name when writing &lt;code&gt;ONLY&lt;/code&gt;, for example &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt;. PostgreSQL considers these parentheses to be optional.</source>
          <target state="translated">표준 SQL 작성시 테이블 이름을 괄호 필요 &lt;code&gt;ONLY&lt;/code&gt; , 예를 들어 &lt;code&gt;SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...&lt;/code&gt; . PostgreSQL은 이러한 괄호를 선택 사항으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="9c327a647bb63bff5c4e11d3c2640afdd42ebe7e" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that writing just &lt;code&gt;timestamp&lt;/code&gt; be equivalent to &lt;code&gt;timestamp without time zone&lt;/code&gt;, and PostgreSQL honors that behavior. &lt;code&gt;timestamptz&lt;/code&gt; is accepted as an abbreviation for &lt;code&gt;timestamp with time zone&lt;/code&gt;; this is a PostgreSQL extension.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;timestamp&lt;/code&gt; 만 작성 하는 &lt;code&gt;timestamp without time zone&lt;/code&gt; 와 동일해야 하며 PostgreSQL은 해당 동작을 존중합니다. &lt;code&gt;timestamptz&lt;/code&gt; 는 &lt;code&gt;timestamp with time zone&lt;/code&gt; 의 약어로 허용됩니다 . 이것은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="b32d323a75124833c9180676bb48b77e9c8490b4" translate="yes" xml:space="preserve">
          <source>The SQL standard says that &lt;code&gt;CHECK&lt;/code&gt; column constraints can only refer to the column they apply to; only &lt;code&gt;CHECK&lt;/code&gt; table constraints can refer to multiple columns. PostgreSQL does not enforce this restriction; it treats column and table check constraints alike.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;CHECK&lt;/code&gt; 열 제약 조건은 적용되는 열만 참조 할 수 있습니다. &lt;code&gt;CHECK&lt;/code&gt; 테이블 제약 조건 만 여러 열을 참조 할 수 있습니다. PostgreSQL은이 제한을 시행하지 않습니다. 열 및 테이블 검사 제한 조건을 동일하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="17cd16f5bf5a8ca370f92a98424035c167fcaa79" translate="yes" xml:space="preserve">
          <source>The SQL standard says that it is implementation-dependent whether cursors are sensitive to concurrent updates of the underlying data by default. In PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying &lt;code&gt;FOR UPDATE&lt;/code&gt;. Other products may work differently.</source>
          <target state="translated">SQL 표준에 따르면 기본적으로 커서가 기본 데이터의 동시 업데이트에 민감한 지 여부는 구현에 따라 다릅니다. PostgreSQL에서 커서는 기본적으로 민감하지 않으며 &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 지정하여 민감하게 만들 수 있습니다 . 다른 제품은 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0e6c19202fe94a3734c19398394df433a6c622" translate="yes" xml:space="preserve">
          <source>The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain. PostgreSQL is laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (&lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.</source>
          <target state="translated">SQL 표준에 따르면 테이블 및 도메인 제약 조건에는 테이블 또는 도메인을 포함하는 스키마에서 고유 한 이름이 있어야합니다. PostgreSQL은 laxer입니다. 특정 테이블이나 도메인에 연결된 제약 조건에서 제약 조건 이름 만 고유하면됩니다. 그러나 연관된 인덱스의 이름이 제한 조건과 동일하고 인덱스 이름이 동일한 스키마 내의 모든 관계에서 고유해야하기 때문에 인덱스 기반 제한 조건 ( &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;PRIMARY KEY&lt;/code&gt; 및 &lt;code&gt;EXCLUDE&lt;/code&gt; 제한 조건) 에는이 추가 자유가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5a79884799ecc17f7b669e9ed40107182ffe5aca" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; can only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.</source>
          <target state="translated">SQL 표준 은 생성되는 식별 컬럼이 항상 존재하는 경우에만 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 를 지정할 수 있도록 지정합니다. PostgreSQL은 어떤 경우에도 조항을 허용하고 적용 할 수없는 경우 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5b1e1c604541e0514a1f4ecda3cb5b97bda57985" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL and Oracle allow it to be omitted. SQL allows only &lt;code&gt;WORK&lt;/code&gt;, not &lt;code&gt;TRANSACTION&lt;/code&gt;, as a noise word after &lt;code&gt;ROLLBACK&lt;/code&gt;. Also, SQL has an optional clause &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; which is not currently supported by PostgreSQL. Otherwise, this command conforms to the SQL standard.</source>
          <target state="translated">SQL 표준은 키워드 &lt;code&gt;SAVEPOINT&lt;/code&gt; 가 필수 임을 지정 하지만 PostgreSQL 및 Oracle에서는이를 생략 할 수 있습니다. SQL은 &lt;code&gt;ROLLBACK&lt;/code&gt; 이후에 &lt;code&gt;TRANSACTION&lt;/code&gt; 이 아닌 &lt;code&gt;WORK&lt;/code&gt; 만 노이즈 단어로 허용합니다 . 또한 SQL에는 선택적 절 &lt;code&gt;AND [ NO ] CHAIN&lt;/code&gt; 이 있으며 현재 PostgreSQL에서 지원하지 않습니다. 그렇지 않으면이 명령은 SQL 표준을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4ef02d5b8713fad53d23c6b10f7669991c2a9427" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that the subcommands in &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can appear in any order. The present PostgreSQL implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references.</source>
          <target state="translated">SQL 표준은 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 의 부속 명령 이 임의의 순서로 나타날 수 있도록 지정합니다. 현재 PostgreSQL 구현은 하위 명령에서 모든 순방향 참조 사례를 처리하지 않습니다. 정방향 참조를 피하기 위해 하위 명령을 다시 정렬해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4258f023ecf83c293dc59266efcd9181140a14" translate="yes" xml:space="preserve">
          <source>The SQL standard states that &amp;ldquo;Within the definition of a &amp;lsquo;datetime literal&amp;rsquo;, the &amp;lsquo;datetime values&amp;rsquo; are constrained by the natural rules for dates and times according to the Gregorian calendar&amp;rdquo;. PostgreSQL follows the SQL standard's lead by counting dates exclusively in the Gregorian calendar, even for years before that calendar was in use. This rule is known as the &lt;em&gt;proleptic Gregorian calendar&lt;/em&gt;.</source>
          <target state="translated">SQL 표준은 &quot; '날짜 시간 리터럴'의 정의 내에서 '날짜 시간 값'은 그레고리력에 따른 날짜 및 시간의 기본 규칙에 의해 제한됩니다.&quot; PostgreSQL은 그 달력이 사용되기 몇 년 전이라도 그레고리력으로 만 날짜를 계산하여 SQL 표준의 리드를 따릅니다. 이 규칙은 &lt;em&gt;다발성 그레고리력으로&lt;/em&gt; 알려져 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d19cb60e6641fce6ca2d40fc0e7200daf402177c" translate="yes" xml:space="preserve">
          <source>The SQL standard uses &lt;code&gt;SELECT INTO&lt;/code&gt; to represent selecting values into scalar variables of a host program, rather than creating a new table. This indeed is the usage found in ECPG (see &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;Chapter 35&lt;/a&gt;) and PL/pgSQL (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;Chapter 42&lt;/a&gt;). The PostgreSQL usage of &lt;code&gt;SELECT INTO&lt;/code&gt; to represent table creation is historical. It is best to use &lt;code&gt;CREATE TABLE AS&lt;/code&gt; for this purpose in new code.</source>
          <target state="translated">SQL 표준은 &lt;code&gt;SELECT INTO&lt;/code&gt; 를 사용 하여 새 테이블을 작성하지 않고 호스트 프로그램의 스칼라 변수로 값을 선택하는 것을 나타냅니다. ECPG ( &lt;a href=&quot;https://www.postgresql.org/docs/12/ecpg.html&quot;&gt;35 장&lt;/a&gt; 참조 )와 PL / pgSQL ( &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql.html&quot;&gt;42 장&lt;/a&gt; 참조) 에서 사용 된 사용법 입니다. 테이블 생성을 나타 내기 위해 &lt;code&gt;SELECT INTO&lt;/code&gt; 의 PostgreSQL 사용법 은 역사적입니다. 이 목적으로 새 코드에서 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7f96ecc2fb3538c905f725be2098ce0d65cd6679" translate="yes" xml:space="preserve">
          <source>The SQL syntax is not very consistent regarding what tokens identify commands and which are operands or parameters. The first few tokens are generally the command name, so in the above example we would usually speak of a &amp;ldquo;SELECT&amp;rdquo;, an &amp;ldquo;UPDATE&amp;rdquo;, and an &amp;ldquo;INSERT&amp;rdquo; command. But for instance the &lt;code&gt;UPDATE&lt;/code&gt; command always requires a &lt;code&gt;SET&lt;/code&gt; token to appear in a certain position, and this particular variation of &lt;code&gt;INSERT&lt;/code&gt; also requires a &lt;code&gt;VALUES&lt;/code&gt; in order to be complete. The precise syntax rules for each command are described in &lt;a href=&quot;index&quot;&gt;Part VI&lt;/a&gt;.</source>
          <target state="translated">SQL 구문은 어떤 토큰이 명령을 식별하고 어떤 피연산자 또는 매개 변수인지에 대해서는 일관성이 없습니다. 처음 몇 개의 토큰은 일반적으로 명령 이름이므로 위의 예에서는 일반적으로&amp;ldquo;SELECT&amp;rdquo;,&amp;ldquo;UPDATE&amp;rdquo;및&amp;ldquo;INSERT&amp;rdquo;명령에 대해 설명합니다. 그러나 예를 들어 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 항상 특정 위치에 &lt;code&gt;SET&lt;/code&gt; 토큰이 나타나도록 요구하며 ,이 특정 &lt;code&gt;INSERT&lt;/code&gt; 변형은 완료되기 위해 &lt;code&gt;VALUES&lt;/code&gt; 도 필요합니다 . 각 명령에 대한 정확한 구문 규칙은 &lt;a href=&quot;index&quot;&gt;Part VI에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb05fc557b9719130cdacd9aa3c915a94bbdf061" translate="yes" xml:space="preserve">
          <source>The SQL/JSON standard borrows its definition for regular expressions from the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the &lt;code&gt;LIKE_REGEX&lt;/code&gt; operator. Therefore, the &lt;code&gt;like_regex&lt;/code&gt; filter is implemented using the POSIX regular expression engine described in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;Section 9.7.3.8&lt;/a&gt;. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</source>
          <target state="translated">SQL / JSON 표준은 XQuery 표준을 사용하는 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 연산자 에서 정규식에 대한 정의를 차용합니다 . PostgreSQL은 현재 &lt;code&gt;LIKE_REGEX&lt;/code&gt; 연산자를 지원하지 않습니다 . 따라서 &lt;code&gt;like_regex&lt;/code&gt; 필터는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절에&lt;/a&gt; 설명 된 POSIX 정규식 엔진을 사용하여 구현됩니다 . 이로 인해 표준 SQL / JSON 동작과는 약간의 불일치가 발생하며 &lt;a href=&quot;functions-matching#POSIX-VS-XQUERY&quot;&gt;섹션 9.7.3.8에&lt;/a&gt; 카탈로그 화되어 있습니다. 그러나 여기에 설명 된 플래그 문자 비 호환성은 POSIX 엔진이 예상하는 것과 일치하도록 XQuery 플래그 문자를 변환하므로 SQL / JSON에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c1fd14d6c7b89183a3f90fd72282a55b3166126" translate="yes" xml:space="preserve">
          <source>The SQL:2008 standard includes a &lt;code&gt;TRUNCATE&lt;/code&gt; command with the syntax &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt;. The clauses &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt;/&lt;code&gt;RESTART IDENTITY&lt;/code&gt; also appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.</source>
          <target state="translated">SQL : 2008 표준에는 &lt;code&gt;TRUNCATE TABLE tablename&lt;/code&gt; 구문과 함께 &lt;code&gt;TRUNCATE&lt;/code&gt; 명령이 포함되어 있습니다. &lt;code&gt;CONTINUE IDENTITY&lt;/code&gt; / &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 절도 해당 표준에 나타나지만 관련 의미는 약간 다릅니다. 이 명령의 일부 동시성 동작은 표준에 의해 구현 정의되어 있으므로 위의 참고 사항을 고려하여 필요한 경우 다른 구현과 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="106deb17fc13475a8af50970b808cc1e2661d130" translate="yes" xml:space="preserve">
          <source>The Serializable transaction isolation level is not yet available in hot standby. (See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; and &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;Section 13.4.1&lt;/a&gt; for details.) An attempt to set a transaction to the serializable isolation level in hot standby mode will generate an error.</source>
          <target state="translated">직렬화 가능 트랜잭션 분리 레벨은 아직 핫 스탠바이에서 사용할 수 없습니다. (자세한 내용 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;은 13.2.3 절&lt;/a&gt; 및 &lt;a href=&quot;applevel-consistency#SERIALIZABLE-CONSISTENCY&quot;&gt;13.4.1 절&lt;/a&gt; 을 참조하십시오.) 핫 스탠바이 모드에서 트랜잭션을 직렬화 가능한 격리 수준으로 설정하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66e4ba5dbccb413a9c06a219a5d2e98558807585" translate="yes" xml:space="preserve">
          <source>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter's stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball site&lt;/a&gt; for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a &lt;code&gt;language&lt;/code&gt; parameter to identify which stemmer to use, and optionally can specify a &lt;code&gt;stopword&lt;/code&gt; file name that gives a list of words to eliminate. (PostgreSQL's standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</source>
          <target state="translated">Snowball 사전 템플릿은 인기있는 Porter의 영어 형태소 분석 알고리즘을 발명 한 Martin Porter의 프로젝트를 기반으로합니다. Snowball은 이제 여러 언어에 대한 형태소 분석 알고리즘을 제공합니다 (자세한 내용은 &lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball 사이트&lt;/a&gt; 참조 ). 각 알고리즘은 일반적인 변형 형태의 단어를 해당 언어 내에서 기본 또는 철자법으로 줄이는 방법을 이해합니다. Snowball 사전에는 사용할 형태소 분석기를 식별 하는 &lt;code&gt;language&lt;/code&gt; 매개 변수가 필요 하며 선택적 으로 제거 할 단어 목록을 제공하는 &lt;code&gt;stopword&lt;/code&gt; 파일 이름을 지정할 수 있습니다 . (PostgreSQL의 표준 중지 어 목록은 Snowball 프로젝트에서도 제공됩니다.) 예를 들어, 내장 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13e42c2d23de5bce64e42840619341e599527d06" translate="yes" xml:space="preserve">
          <source>The Sort node shows the sort method used (in particular, whether the sort was in-memory or on-disk) and the amount of memory or disk space needed. The Hash node shows the number of hash buckets and batches as well as the peak amount of memory used for the hash table. (If the number of batches exceeds one, there will also be disk space usage involved, but that is not shown.)</source>
          <target state="translated">정렬 노드는 사용 된 정렬 방법 (특히 정렬이 메모리에 있는지 디스크에 있는지)과 필요한 메모리 또는 디스크 공간을 보여줍니다. 해시 노드에는 해시 버킷 및 배치 수와 해시 테이블에 사용 된 최대 메모리 양이 표시됩니다. (배치 수가 1을 초과하면 디스크 공간 사용량도 있지만 표시되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="ffcd4e9238fc5943a8a630abc801447e679c88d8" translate="yes" xml:space="preserve">
          <source>The Soundex system is a method of matching similar-sounding names by converting them to the same code. It was initially used by the United States Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-English names.</source>
          <target state="translated">Soundex 시스템은 유사한 발음 이름을 동일한 코드로 변환하여 일치시키는 방법입니다. 그것은 1880 년, 1900 년, 1910 년에 미국 인구 조사에 의해 처음 사용되었습니다. Soundex는 영어가 아닌 이름에는 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30ad8964ef3e16d1b565ba3b7fd4ae7ed8f17e69" translate="yes" xml:space="preserve">
          <source>The TCP port the server listens on; 5432 by default. Note that the same port number is used for all IP addresses the server listens on. This parameter can only be set at server start.</source>
          <target state="translated">서버가 청취하는 TCP 포트. 기본적으로 5432입니다. 서버가 청취하는 모든 IP 주소에 동일한 포트 번호가 사용됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a5c86c75e37eef9f48a99edd2521f09dbad0224" translate="yes" xml:space="preserve">
          <source>The TOAST management code is triggered only when a row value to be stored in a table is wider than &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; bytes (normally 2 kB). The TOAST code will compress and/or move field values out-of-line until the row value is shorter than &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; bytes (also normally 2 kB, adjustable) or no more gains can be had. During an UPDATE operation, values of unchanged fields are normally preserved as-is; so an UPDATE of a row with out-of-line values incurs no TOAST costs if none of the out-of-line values change.</source>
          <target state="translated">TOAST 관리 코드는 테이블에 저장 될 행 값이 &lt;code&gt;TOAST_TUPLE_THRESHOLD&lt;/code&gt; 바이트 (보통 2 kB) 보다 넓은 경우에만 트리거됩니다 . TOAST 코드는 행 값이 &lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; 바이트 보다 짧거나 (일반적으로 2kB 조정 가능) 더 이상 이득을 얻을 수 없을 때까지 필드 값을 압축 및 / 또는 행 밖으로 이동합니다 . UPDATE 조작 중에 변경되지 않은 필드의 값은 일반적으로 그대로 유지됩니다. 따라서 라인 외부 값이있는 행을 갱신하면 라인 외부 값이 변경되지 않으면 TOAST 비용이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2962f8d4658219a67247690e9e9ec2e5d8ddb34b" translate="yes" xml:space="preserve">
          <source>The TOAST management code recognizes four different strategies for storing TOAST-able columns on disk:</source>
          <target state="translated">TOAST 관리 코드는 디스크에 TOAST 가능 열을 저장하기위한 4 가지 전략을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a81c03b713c7e31311d0848c27a627beb8a79d13" translate="yes" xml:space="preserve">
          <source>The Time Stamp Counter (TSC) clock source is the most accurate one available on current generation CPUs. It's the preferred way to track the system time when it's supported by the operating system and the TSC clock is reliable. There are several ways that TSC can fail to provide an accurate timing source, making it unreliable. Older systems can have a TSC clock that varies based on the CPU temperature, making it unusable for timing. Trying to use TSC on some older multicore CPUs can give a reported time that's inconsistent among multiple cores. This can result in the time going backwards, a problem this program checks for. And even the newest systems can fail to provide accurate TSC timing with very aggressive power saving configurations.</source>
          <target state="translated">TSC (Time Stamp Counter) 클럭 소스는 현재 세대 CPU에서 사용 가능한 가장 정확한 것입니다. 운영 체제에서 지원하고 TSC 시계가 안정적 일 때 시스템 시간을 추적하는 데 선호되는 방법입니다. TSC가 정확한 타이밍 소스를 제공하지 못해 신뢰할 수없는 방법에는 여러 가지가 있습니다. 구형 시스템에는 CPU 온도에 따라 달라지는 TSC 클럭이있을 수 있으므로 타이밍에 사용할 수 없습니다. 일부 구형 멀티 코어 CPU에서 TSC를 사용하려고하면 여러 코어에서 일치하지 않는보고 된 시간이 제공 될 수 있습니다. 이로 인해 시간이 뒤로 갈 수 있으며이 프로그램에서 확인하는 문제가 발생할 수 있습니다. 최신 시스템조차도 매우 적극적인 절전 구성으로 정확한 TSC 타이밍을 제공하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e64c3210927fbc153414d6d364fd7a502138f4" translate="yes" xml:space="preserve">
          <source>The URL scheme &lt;code&gt;ldaps&lt;/code&gt; chooses the LDAPS method for making LDAP connections over SSL, equivalent to using &lt;code&gt;ldapscheme=ldaps&lt;/code&gt;. To use encrypted LDAP connections using the &lt;code&gt;StartTLS&lt;/code&gt; operation, use the normal URL scheme &lt;code&gt;ldap&lt;/code&gt; and specify the &lt;code&gt;ldaptls&lt;/code&gt; option in addition to &lt;code&gt;ldapurl&lt;/code&gt;.</source>
          <target state="translated">URL 체계 &lt;code&gt;ldaps&lt;/code&gt; 는 SSL을 통한 LDAP 연결을위한 LDAPS 방법을 선택합니다 ( &lt;code&gt;ldapscheme=ldaps&lt;/code&gt; 사용) . &lt;code&gt;StartTLS&lt;/code&gt; 조작을 사용 하여 암호화 된 LDAP 연결을 사용하려면 일반 URL 스킴 &lt;code&gt;ldap&lt;/code&gt; 을 사용하고 &lt;code&gt;ldapurl&lt;/code&gt; 외에도 &lt;code&gt;ldaptls&lt;/code&gt; 옵션을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c6010c68a5af10d545c5e024dfa86cf3e81ff1d" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works fully only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\u007F&lt;/code&gt;) can be specified. Both the 4-digit and the 8-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 8-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">유니 코드 이스케이프 구문은 서버 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 인 경우에만 완벽하게 작동 합니다 . 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 &lt;code&gt;\u007F&lt;/code&gt; )의 코드 포인트 만 지정할 수 있습니다. 4 자리 및 8 자리 형식 모두 UTF-16 대리 쌍을 지정하여 U + FFFF보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용할 수 있지만 기술적으로 8 자리 형식을 사용할 수 있으면 불필요합니다. (서버 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 일 때 서로 게이트 쌍을 사용하면 먼저 단일 코드 포인트로 결합 된 다음 UTF-8로 인코딩됩니다.)</target>
        </trans-unit>
        <trans-unit id="9d177c404952bede8f8a850e0e6bf27fc770e815" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (Surrogate pairs are not stored directly, but combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">유니 코드 이스케이프 구문은 서버 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 인 경우에만 작동 합니다 . 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 &lt;code&gt;\007F&lt;/code&gt; )의 코드 포인트 만 지정할 수 있습니다. 4 자리 및 6 자리 형식 모두 UTF-16 대리 쌍을 지정하여 U + FFFF보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용할 수 있지만 6 자리 형식의 가용성은 기술적으로이를 불필요하게 만듭니다. 대리 쌍은 직접 저장되지 않고 단일 코드 포인트로 결합 된 다음 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7a66f8e165736e1d6137c7cb68f9f8d177bec3f5" translate="yes" xml:space="preserve">
          <source>The Unicode escape syntax works only when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;. When other server encodings are used, only code points in the ASCII range (up to &lt;code&gt;\007F&lt;/code&gt;) can be specified. Both the 4-digit and the 6-digit form can be used to specify UTF-16 surrogate pairs to compose characters with code points larger than U+FFFF, although the availability of the 6-digit form technically makes this unnecessary. (When surrogate pairs are used when the server encoding is &lt;code&gt;UTF8&lt;/code&gt;, they are first combined into a single code point that is then encoded in UTF-8.)</source>
          <target state="translated">유니 코드 이스케이프 구문은 서버 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 인 경우에만 작동 합니다 . 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 &lt;code&gt;\007F&lt;/code&gt; )의 코드 포인트 만 지정할 수 있습니다. 4 자리 및 6 자리 형식 모두 UTF-16 대리 쌍을 지정하여 U + FFFF보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용할 수 있지만 6 자리 형식의 가용성은 기술적으로이를 불필요하게 만듭니다. (서버 인코딩이 &lt;code&gt;UTF8&lt;/code&gt; 일 때 서로 게이트 쌍을 사용하면 먼저 단일 코드 포인트로 결합 된 다음 UTF-8로 인코딩됩니다.)</target>
        </trans-unit>
        <trans-unit id="9ece699458bd7501153fdfb1c5912141f3441417" translate="yes" xml:space="preserve">
          <source>The XPath-based functions support passing one parameter to serve as the XPath expression's context item, but do not support passing additional values to be available to the expression as named parameters.</source>
          <target state="translated">XPath 기반 함수는 XPath 표현식의 컨텍스트 항목으로 사용할 하나의 매개 변수 전달을 지원하지만 이름 지정된 매개 변수로 표현식에 사용할 수있는 추가 값 전달은 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68d2d71e2fc0b0be97c31a2b21762a50375e3cf0" translate="yes" xml:space="preserve">
          <source>The ability of pg_dump and psql to write to or read from pipes makes it possible to dump a database directly from one server to another, for example:</source>
          <target state="translated">파이프에 쓰거나 읽을 수있는 pg_dump 및 psql의 기능을 통해 한 서버에서 다른 서버로 데이터베이스를 직접 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa4fd86ff72f122e1d8e3fdfa6f01d6588a00c68" translate="yes" xml:space="preserve">
          <source>The ability to create a composite type with zero attributes is a PostgreSQL-specific deviation from the standard (analogous to the same case in &lt;code&gt;CREATE TABLE&lt;/code&gt;).</source>
          <target state="translated">속성이 0 인 복합 유형을 생성하는 기능은 표준과 PostgreSQL에 특정한 편차입니다 ( &lt;code&gt;CREATE TABLE&lt;/code&gt; 과 같은 경우와 유사 ).</target>
        </trans-unit>
        <trans-unit id="adfc2f9948045f7d285be1359a7594bd62946d41" translate="yes" xml:space="preserve">
          <source>The ability to create like-named objects in different schemas complicates writing a query that references precisely the same objects every time. It also opens up the potential for users to change the behavior of other users' queries, maliciously or accidentally. Due to the prevalence of unqualified names in queries and their use in PostgreSQL internals, adding a schema to &lt;code&gt;search_path&lt;/code&gt; effectively trusts all users having &lt;code&gt;CREATE&lt;/code&gt; privilege on that schema. When you run an ordinary query, a malicious user able to create objects in a schema of your search path can take control and execute arbitrary SQL functions as though you executed them.</source>
          <target state="translated">다른 스키마에서 유사한 이름의 객체를 생성하는 기능은 매번 정확히 동일한 객체를 참조하는 쿼리 작성을 복잡하게합니다. 또한 사용자가 다른 사용자의 쿼리 동작을 악의적으로 또는 실수로 변경할 수있는 가능성을 열어줍니다. 쿼리에서 규정되지 않은 이름이 널리 사용되고 PostgreSQL 내부에서 사용되기 때문에 &lt;code&gt;search_path&lt;/code&gt; 에 스키마를 추가하면 해당 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이있는 모든 사용자를 효과적으로 신뢰합니다 . 일반 쿼리를 실행하면 검색 경로의 스키마에서 개체를 만들 수있는 악의적 인 사용자가 마치 마치 실행하는 것처럼 임의의 SQL 함수를 제어하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ae0fec1e129dc1403f8e4a1f54de4512e5b908" translate="yes" xml:space="preserve">
          <source>The ability to fire triggers for &lt;code&gt;TRUNCATE&lt;/code&gt; is a PostgreSQL extension of the SQL standard, as is the ability to define statement-level triggers on views.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 에 대해 트리거를 발생시키는 기능 은 SQL 표준의 PostgreSQL 확장이며 뷰에서 명령문 레벨 트리거를 정의하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b3edb8c451c19be6c183faaf56035a29e2c4b780" translate="yes" xml:space="preserve">
          <source>The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In &lt;em&gt;this&lt;/em&gt; history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history.</source>
          <target state="translated">데이터베이스를 이전 시점으로 복원하는 기능은 시간 여행 및 평행 우주에 대한 공상 과학 소설과 유사한 몇 가지 복잡성을 만듭니다. 예를 들어, 데이터베이스의 원래 히스토리에서 화요일 저녁 5시 15 분에 위험 테이블을 삭제했지만 수요일 정오까지 실수를 인식하지 못했다고 가정하십시오. 모호하지 않게, 백업을 받고 화요일 저녁 5:14 PM으로 복원하여 시작 및 실행합니다. 에서 &lt;em&gt;이&lt;/em&gt;데이터베이스 유니버스의 기록에서 테이블을 삭제하지 않았습니다. 그러나 나중에 이것이 그다지 좋은 아이디어가 아니라는 것을 깨달았고 원래 역사에서 수요일 아침 언젠가로 돌아가고 싶다고 가정 해보십시오. 데이터베이스가 시작 및 실행되는 동안 WAL 세그먼트 파일 중 일부를 덮어 써서 원하는 시간으로 돌아갈 수는 없습니다. 따라서이를 방지하려면 특정 시점 복구를 수행 한 후 생성 된 일련의 WAL 레코드와 원본 데이터베이스 기록에서 생성 된 WAL 레코드를 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="e29767e86a52c901615b571a0d1b5b49dcfd5235" translate="yes" xml:space="preserve">
          <source>The ability to specify argument modes and names</source>
          <target state="translated">인수 모드 및 이름을 지정하는 기능</target>
        </trans-unit>
        <trans-unit id="f83cfa93265ba6bdf2c4af4154ac85132df7584f" translate="yes" xml:space="preserve">
          <source>The ability to specify both &lt;code&gt;DISTINCT&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; in an aggregate function is a PostgreSQL extension.</source>
          <target state="translated">집계 함수에서 &lt;code&gt;DISTINCT&lt;/code&gt; 와 &lt;code&gt;ORDER BY&lt;/code&gt; 를 모두 지정할 수있는 기능은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="36892c35402a71971c62f926cf33611f0095f448" translate="yes" xml:space="preserve">
          <source>The ability to specify multiple actions for a single trigger using &lt;code&gt;OR&lt;/code&gt; is a PostgreSQL extension of the SQL standard.</source>
          <target state="translated">&lt;code&gt;OR&lt;/code&gt; 을 사용하여 단일 트리거에 대해 여러 작업을 지정하는 기능 은 SQL 표준의 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="12f8b21071990877da6aa1b7a33a6ab04258d42b" translate="yes" xml:space="preserve">
          <source>The ability to temporarily enable or disable a trigger is provided by &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, not by &lt;code&gt;ALTER TRIGGER&lt;/code&gt;, because &lt;code&gt;ALTER TRIGGER&lt;/code&gt; has no convenient way to express the option of enabling or disabling all of a table's triggers at once.</source>
          <target state="translated">&lt;code&gt;ALTER TRIGGER&lt;/code&gt; 는 한 번에 모든 테이블 트리거를 활성화 또는 비활성화하는 옵션을 표현할 수있는 편리한 방법이 없기 때문에 트리거를 일시적으로 활성화 또는 비활성화하는 기능은 &lt;code&gt;ALTER TRIGGER&lt;/code&gt; 가 아닌 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="181b9f5d513d598d56342cbdee6549b14a30572c" translate="yes" xml:space="preserve">
          <source>The ability to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; 절 과 함께 인덱스를 사용하는 기능</target>
        </trans-unit>
        <trans-unit id="cf1bad54aa29381ffc99e0cd6534801214045eea" translate="yes" xml:space="preserve">
          <source>The above are all simple text search examples. As mentioned before, full text search functionality includes the ability to do many more things: skip indexing certain words (stop words), process synonyms, and use sophisticated parsing, e.g., parse based on more than just white space. This functionality is controlled by &lt;em&gt;text search configurations&lt;/em&gt;. PostgreSQL comes with predefined configurations for many languages, and you can easily create your own configurations. (psql's &lt;code&gt;\dF&lt;/code&gt; command shows all available configurations.)</source>
          <target state="translated">위의 모든 간단한 텍스트 검색 예입니다. 이전에 언급했듯이 전체 텍스트 검색 기능에는 더 많은 작업을 수행 할 수있는 기능이 포함되어 있습니다. 특정 단어의 색인 생성 (중지 단어) 건너 뛰기, 동의어 처리 및 공백보다 더 큰 기반 구문 분석과 같은 정교한 구문 분석 사용. 이 기능은 &lt;em&gt;텍스트 검색 구성으로&lt;/em&gt; 제어됩니다 . PostgreSQL에는 여러 언어에 대한 사전 정의 된 구성이 포함되어 있으며 자신 만의 구성을 쉽게 만들 수 있습니다. (psql의 &lt;code&gt;\dF&lt;/code&gt; 명령은 사용 가능한 모든 구성을 보여줍니다.)</target>
        </trans-unit>
        <trans-unit id="2c3e1167e52b923579b2a7fc4d461580b2f1f1dc" translate="yes" xml:space="preserve">
          <source>The above operations should be performed by an administrative user.</source>
          <target state="translated">위의 작업은 관리자가 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d28ebaf3e9bc7217eabce77d41a45e775db518" translate="yes" xml:space="preserve">
          <source>The above query only shows the rows from the inner query having &lt;code&gt;rank&lt;/code&gt; less than 3.</source>
          <target state="translated">위 쿼리는 내부 쿼리의 &lt;code&gt;rank&lt;/code&gt; 가 3보다 작은 행만 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5129e9bc20e65e89b0d436aa6187d7cf918d1aeb" translate="yes" xml:space="preserve">
          <source>The above query using &lt;code&gt;int_array_enum&lt;/code&gt; produces the same results as</source>
          <target state="translated">&lt;code&gt;int_array_enum&lt;/code&gt; 을 사용하는 위의 쿼리 는</target>
        </trans-unit>
        <trans-unit id="8107fdc88da76184415ef69e2ecad722706ac13d" translate="yes" xml:space="preserve">
          <source>The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring &lt;em&gt;as a whole&lt;/em&gt;. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later.</source>
          <target state="translated">위의 규칙은 탐욕 특성을 개별 정량 원자뿐만 아니라 정량 원자를 포함하는 가지 및 전체 RE와 관련시킵니다. 의미하는 것은 분기 또는 전체 RE가 가능한 가장 긴 또는 가장 짧은 부분 문자열 &lt;em&gt;과&lt;/em&gt; 일치하는 방식으로 일치가 수행된다는 &lt;em&gt;것&lt;/em&gt; 입니다. 전체 일치의 길이가 결정되면 특정 하위 표현식과 일치하는 부분이 해당 하위 표현식의 욕심 ​​속성을 기반으로 결정되며, 하위 표현식이 RE에서 일찍 시작하여 나중에 시작하는 것보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="fe4e00a739ad370965c561bc4d7c298f0756e50c" translate="yes" xml:space="preserve">
          <source>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</source>
          <target state="translated">위의 골격은 감압이 필요하지 않은 경우에 적합합니다. (물론 방법을 완전히 생략하는 것이 훨씬 쉬우므로 그러한 경우에 권장됩니다.)</target>
        </trans-unit>
        <trans-unit id="6987a09f0b14c398190d54898784ad9944a48328" translate="yes" xml:space="preserve">
          <source>The above syntax has the drawback that you need to know the order of the columns in the table. To avoid this you can also list the columns explicitly. For example, both of the following commands have the same effect as the one above:</source>
          <target state="translated">위의 구문에는 테이블의 열 순서를 알아야하는 단점이 있습니다. 이를 피하기 위해 열을 명시 적으로 나열 할 수도 있습니다. 예를 들어, 다음 명령 모두 위의 명령과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d92b695ce2e1fc99e7debc111a49b6a3b4275271" translate="yes" xml:space="preserve">
          <source>The above transaction will insert both 3 and 4.</source>
          <target state="translated">위의 거래는 3과 4를 모두 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="d3ded6bad4b3e8cb90f32aef7f2e2ce8e740539c" translate="yes" xml:space="preserve">
          <source>The above transaction will insert the values 1 and 3, but not 2.</source>
          <target state="translated">위의 트랜잭션은 값 1과 3을 삽입하지만 2는 삽입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dec9b433ac3e4e8910b0ae4310ac815b98eb482c" translate="yes" xml:space="preserve">
          <source>The above will start the replication process, which synchronizes the initial table contents of the tables &lt;code&gt;users&lt;/code&gt; and &lt;code&gt;departments&lt;/code&gt; and then starts replicating incremental changes to those tables.</source>
          <target state="translated">위의 과정은 복제 프로세스를 시작하여 테이블 &lt;code&gt;users&lt;/code&gt; 와 &lt;code&gt;departments&lt;/code&gt; 의 초기 테이블 내용을 동기화 한 다음 해당 테이블에 증분 변경 사항을 복제하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4792ca68861299622c8a8489cae6e3ff6fc1e734" translate="yes" xml:space="preserve">
          <source>The access costs should include all disk and CPU costs associated with scanning the index itself, but &lt;em&gt;not&lt;/em&gt; the costs of retrieving or processing the parent-table rows that are identified by the index.</source>
          <target state="translated">액세스 비용에는 인덱스 자체 스캔과 관련된 모든 디스크 및 CPU 비용이 포함되어야하지만 인덱스 로 식별되는 상위 테이블 행을 검색하거나 처리하는 비용은 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="07883ad5be74942310a3c715c9a683e447816066" translate="yes" xml:space="preserve">
          <source>The access method can report that the index is &lt;em&gt;lossy&lt;/em&gt;, or requires rechecks, for a particular query. This implies that the index scan will return all the entries that pass the scan key, plus possibly additional entries that do not. The core system's index-scan machinery will then apply the index conditions again to the heap tuple to verify whether or not it really should be selected. If the recheck option is not specified, the index scan must return exactly the set of matching entries.</source>
          <target state="translated">액세스 방법은 특정 쿼리에 대해 인덱스가 &lt;em&gt;손실&lt;/em&gt; 되었거나 재검사가 필요 하다고보고 할 수 있습니다. 이는 인덱스 스캔이 스캔 키를 통과 한 모든 항목과 가능하지 않은 추가 항목을 리턴 함을 의미합니다. 코어 시스템의 인덱스 스캔 기계는 인덱스 조건을 힙 튜플에 다시 적용하여 실제로 선택해야하는지 여부를 확인합니다. 재확인 옵션을 지정하지 않으면 인덱스 스캔은 정확히 일치하는 항목 세트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="7463ace40ac0727457d3fd85331890fec1e03b44" translate="yes" xml:space="preserve">
          <source>The access method must identify any rows which might violate the unique constraint, but it is not an error for it to report false positives. This allows the check to be done without waiting for other transactions to finish; conflicts reported here are not treated as errors and will be rechecked later, by which time they may no longer be conflicts.</source>
          <target state="translated">액세스 방법은 고유 제한 조건을 위반할 수있는 행을 식별해야하지만 오 탐지를보고하는 것은 오류가 아닙니다. 이를 통해 다른 트랜잭션이 완료되기를 기다리지 않고 점검을 수행 할 수 있습니다. 여기에보고 된 충돌은 오류로 취급되지 않으며 나중에 다시 검사하여 더 이상 충돌하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b57f7233950ac2f66da1f759e801ef6dd2f3764" translate="yes" xml:space="preserve">
          <source>The access method must support &lt;code&gt;amgettuple&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;); at present this means GIN cannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always be GiST or SP-GiST.</source>
          <target state="translated">액세스 방법은 &lt;code&gt;amgettuple&lt;/code&gt; 을 지원해야합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;61 장&lt;/a&gt; 참조 ). 현재 이것은 GIN을 사용할 수 없음을 의미합니다. 허용되지만 제외 제약 조건과 함께 B- 트리 또는 해시 인덱스를 사용하는 데는 별다른 의미가 없습니다. 이는 일반적인 고유 제약 조건이 더 나은 방법이 아니기 때문입니다. 실제로 액세스 방법은 항상 GiST 또는 SP-GiST입니다.</target>
        </trans-unit>
        <trans-unit id="925d234c42527636b378041891a37fa8bc13f69a" translate="yes" xml:space="preserve">
          <source>The access method name must be unique within the database.</source>
          <target state="translated">액세스 방법 이름은 데이터베이스 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="269e5a0688390217e0c08f2b5f501b6e542e7ab1" translate="yes" xml:space="preserve">
          <source>The accumulated cost that will cause the vacuuming process to sleep. The default value is 200.</source>
          <target state="translated">진공 처리 프로세스가 절전 상태가되는 누적 비용. 기본값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="1dfce3d6c647c6b7a46c7536dcf8246e840a748e" translate="yes" xml:space="preserve">
          <source>The accumulating calendar error prompted Pope Gregory XIII to reform the calendar in accordance with instructions from the Council of Trent. In the Gregorian calendar, the tropical year is approximated as 365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300 years for the tropical year to shift one day with respect to the Gregorian calendar.</source>
          <target state="translated">교황 그레고리 13 세는 누적 달력 오류로 트렌트 공의회의 지시에 따라 달력을 개혁했다. 그레고리력에서 열대 년은 대략 365 + 97 / 400 일 = 365.2425 일로 추정됩니다. 따라서 열대 년이 그레고리력과 관련하여 하루가 바뀌는 데 약 3300 년이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="6e5a51f4541a92f0a7b8eafcdaec433dbe4bd0a9" translate="yes" xml:space="preserve">
          <source>The actions for identity columns (&lt;code&gt;ADD GENERATED&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; etc., &lt;code&gt;DROP IDENTITY&lt;/code&gt;), as well as the actions &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;OWNER&lt;/code&gt;, and &lt;code&gt;TABLESPACE&lt;/code&gt; never recurse to descendant tables; that is, they always act as though &lt;code&gt;ONLY&lt;/code&gt; were specified. Adding a constraint recurses only for &lt;code&gt;CHECK&lt;/code&gt; constraints that are not marked &lt;code&gt;NO INHERIT&lt;/code&gt;.</source>
          <target state="translated">ID 열 ( &lt;code&gt;ADD GENERATED&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 등, &lt;code&gt;DROP IDENTITY&lt;/code&gt; )에 대한 조치뿐만 아니라 &lt;code&gt;TRIGGER&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;OWNER&lt;/code&gt; 및 &lt;code&gt;TABLESPACE&lt;/code&gt; 조치 는 하위 테이블에 반복되지 않습니다. 즉, 항상 지정된 &lt;code&gt;ONLY&lt;/code&gt; 작동 합니다. &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시되지 않은 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건에 대해서만 제약 조건을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="909f7edd282ab8c888fdf2ed34039a5329b6ad7a" translate="yes" xml:space="preserve">
          <source>The actual choice here is mostly a matter of taste, constrained only by possible restrictions in client applications. Both methods support all possible values, although the hex encoding will be somewhat larger than the base64 encoding.</source>
          <target state="translated">여기서 실제 선택은 대부분 클라이언트 응용 프로그램의 가능한 제한에 의해서만 제한되는 맛의 문제입니다. 16 진 인코딩이 base64 인코딩보다 약간 클지라도 두 방법 모두 가능한 모든 값을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="486a25c1f79db6232bfe3c602e8f3539de88dd46" translate="yes" xml:space="preserve">
          <source>The actual data types of the various &lt;code&gt;Datum&lt;/code&gt; values mentioned above vary depending on the operator class. The item values passed to &lt;code&gt;extractValue&lt;/code&gt; are always of the operator class's input type, and all key values must be of the class's &lt;code&gt;STORAGE&lt;/code&gt; type. The type of the &lt;code&gt;query&lt;/code&gt; argument passed to &lt;code&gt;extractQuery&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;triConsistent&lt;/code&gt; is whatever is the right-hand input type of the class member operator identified by the strategy number. This need not be the same as the indexed type, so long as key values of the correct type can be extracted from it. However, it is recommended that the SQL declarations of these three support functions use the opclass's indexed data type for the &lt;code&gt;query&lt;/code&gt; argument, even though the actual type might be something else depending on the operator.</source>
          <target state="translated">위에서 언급 한 다양한 &lt;code&gt;Datum&lt;/code&gt; 값 의 실제 데이터 유형은 연산자 클래스에 따라 다릅니다. &lt;code&gt;extractValue&lt;/code&gt; 에 전달 된 항목 값 은 항상 연산자 클래스의 입력 유형이며 모든 키 값은 클래스의 &lt;code&gt;STORAGE&lt;/code&gt; 유형 이어야합니다 . &lt;code&gt;extractQuery&lt;/code&gt; 에 전달 된 &lt;code&gt;query&lt;/code&gt; 인수 의 유형 , &lt;code&gt;consistent&lt;/code&gt; 및 &lt;code&gt;triConsistent&lt;/code&gt; 전략 번호로 식별되는 클래스 멤버 연산자의 오른쪽 입력 유형이 무엇이든됩니다. 올바른 유형의 키 값을 추출 할 수 있으면 색인 유형과 같을 필요는 없습니다. 그러나이 세 가지 지원 함수의 SQL 선언은 실제 유형이 연산자에 따라 다른 경우에도 &lt;code&gt;query&lt;/code&gt; 인수에 opclass의 색인화 된 데이터 유형을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="941436b14f077228160b589974e7f72ed527cb34" translate="yes" xml:space="preserve">
          <source>The actual items themselves.</source>
          <target state="translated">실제 상품 자체입니다.</target>
        </trans-unit>
        <trans-unit id="fffe8ba3b231865545aa8ca6fdb204ce35d44eac" translate="yes" xml:space="preserve">
          <source>The actual number of rows this query would select is 7000, but the &lt;code&gt;rows&lt;/code&gt; estimate is only approximate. If you try to duplicate this experiment, you will probably get a slightly different estimate; moreover, it can change after each &lt;code&gt;ANALYZE&lt;/code&gt; command, because the statistics produced by &lt;code&gt;ANALYZE&lt;/code&gt; are taken from a randomized sample of the table.</source>
          <target state="translated">이 쿼리에서 선택하는 실제 행 수는 7000이지만 &lt;code&gt;rows&lt;/code&gt; 추정치는 대략적인 것입니다. 이 실험을 복제하려고하면 추정치가 약간 다를 수 있습니다. 또한, 각각의 이후에 변경할 수 &lt;code&gt;ANALYZE&lt;/code&gt; 의해 생성 된 통계 때문에, 명령 &lt;code&gt;ANALYZE&lt;/code&gt; 이 테이블의 무작위 샘플에서 촬영된다.</target>
        </trans-unit>
        <trans-unit id="6d27af95eda9a00aefcefbbb3f7c08b95ed3e6d3" translate="yes" xml:space="preserve">
          <source>The actual output rows are computed using the &lt;code&gt;SELECT&lt;/code&gt; output expressions for each selected row or row group. (See &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; below.)</source>
          <target state="translated">실제 출력 행은 선택된 각 행 또는 행 그룹에 대한 &lt;code&gt;SELECT&lt;/code&gt; 출력 표현식을 사용하여 계산됩니다 . (아래 &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; 목록을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="747c207c89333b66eb66b4cfc2d12a9cf95c6535" translate="yes" xml:space="preserve">
          <source>The actual value of a parameter to the prepared statement. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created.</source>
          <target state="translated">준비된 명령문에 대한 매개 변수의 실제 값 이는 준비된 명령문이 작성 될 때 판별 된대로이 매개 변수의 데이터 유형과 호환되는 값을 생성하는 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac7f1235d4be6ac9ddfc264172bcdc008188f6f4" translate="yes" xml:space="preserve">
          <source>The added condition &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; reduces the output row count estimate, but not the cost because we still have to visit the same set of rows. Notice that the &lt;code&gt;stringu1&lt;/code&gt; clause cannot be applied as an index condition, since this index is only on the &lt;code&gt;unique1&lt;/code&gt; column. Instead it is applied as a filter on the rows retrieved by the index. Thus the cost has actually gone up slightly to reflect this extra checking.</source>
          <target state="translated">추가 된 조건 &lt;code&gt;stringu1 = 'xxx'&lt;/code&gt; 는 출력 행 수 추정치를 줄이지 만 여전히 동일한 행 세트를 방문해야하기 때문에 비용은 아닙니다. 것을 알 수 &lt;code&gt;stringu1&lt;/code&gt; 의 이 인덱스 만에 있기 때문에 절은 인덱스 조건으로 적용 할 수 없습니다 &lt;code&gt;unique1&lt;/code&gt; 열입니다. 대신 인덱스에서 검색 한 행에 필터로 적용됩니다. 따라서이 추가 검사를 반영하기 위해 실제로 비용이 약간 상승했습니다.</target>
        </trans-unit>
        <trans-unit id="0d6d3b7f07c64185ea468d2b62ff4270f9a83a5e" translate="yes" xml:space="preserve">
          <source>The additional &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; phase adds significant overhead: verification will typically take several times longer. However, there is no change to the relation-level locks acquired when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed.</source>
          <target state="translated">추가적인 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 단계는 상당한 오버 헤드를 추가합니다. 검증은 일반적으로 몇 배 더 오래 걸립니다. 그러나 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 검증을 수행 할 때 획득 한 관계 레벨 잠금에는 변경 사항이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1ce4777382e2000ea7e60f8a7131343e38753550" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) of oldest WAL which still might be required by the consumer of this slot and thus won't be automatically removed during checkpoints. &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;LSN&lt;/code&gt; of this slot has never been reserved.</source>
          <target state="translated">이 슬롯의 소비자가 여전히 요구할 수있는 가장 오래된 WAL 의 주소 ( &lt;code&gt;LSN&lt;/code&gt; )는 검사 점 중에 자동으로 제거되지 않습니다. 이 슬롯 의 &lt;code&gt;LSN&lt;/code&gt; 이 예약되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="034439fc21dbd36a2802df824278cae81f75f88d" translate="yes" xml:space="preserve">
          <source>The address (&lt;code&gt;LSN&lt;/code&gt;) up to which the logical slot's consumer has confirmed receiving data. Data older than this is not available anymore. &lt;code&gt;NULL&lt;/code&gt; for physical slots.</source>
          <target state="translated">논리 슬롯 소비자가 데이터 수신을 확인한 주소 ( &lt;code&gt;LSN&lt;/code&gt; )입니다. 이보다 오래된 데이터는 더 이상 사용할 수 없습니다. 물리적 슬롯의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a0ec05d31abc58e50953bffde428d1c139a9fa7" translate="yes" xml:space="preserve">
          <source>The aggregate functions &lt;code&gt;array_agg&lt;/code&gt;, &lt;code&gt;json_agg&lt;/code&gt;, &lt;code&gt;jsonb_agg&lt;/code&gt;, &lt;code&gt;json_object_agg&lt;/code&gt;, &lt;code&gt;jsonb_object_agg&lt;/code&gt;, &lt;code&gt;string_agg&lt;/code&gt;, and &lt;code&gt;xmlagg&lt;/code&gt;, as well as similar user-defined aggregate functions, produce meaningfully different result values depending on the order of the input values. This ordering is unspecified by default, but can be controlled by writing an &lt;code&gt;ORDER BY&lt;/code&gt; clause within the aggregate call, as shown in &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt;. Alternatively, supplying the input values from a sorted subquery will usually work. For example:</source>
          <target state="translated">집계 함수 &lt;code&gt;array_agg&lt;/code&gt; , &lt;code&gt;json_agg&lt;/code&gt; , &lt;code&gt;jsonb_agg&lt;/code&gt; , &lt;code&gt;json_object_agg&lt;/code&gt; , &lt;code&gt;jsonb_object_agg&lt;/code&gt; , &lt;code&gt;string_agg&lt;/code&gt; , &lt;code&gt;xmlagg&lt;/code&gt; 및 유사한 사용자 정의 집계 함수는 입력 값의 순서에 따라 의미가 다른 결과 값을 생성합니다. 이 순서는 기본적으로 지정되어 있지 않지만 &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;4.2.7 절에&lt;/a&gt; 표시된 것처럼 집계 호출 내에 &lt;code&gt;ORDER BY&lt;/code&gt; 절 을 작성하여 제어 할 수 있습니다 . 또는 정렬 된 하위 쿼리에서 입력 값을 제공하면 일반적으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25a2a3e2d738bffa30059bdc53d46f7e3eca9a3f" translate="yes" xml:space="preserve">
          <source>The aggregator is an aggregate function &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; that produces an integer array containing exactly the integers it is fed. This is a wrapper around &lt;code&gt;array_agg&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">애그리 게이터는 정확히 제공된 정수를 포함하는 정수 배열을 생성 하는 집계 함수 &lt;code&gt;int_array_aggregate(integer)&lt;/code&gt; 입니다. 이것은 &lt;code&gt;array_agg&lt;/code&gt; 주위의 래퍼 이며 모든 배열 유형에 대해 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="424703d8d222e3285ae8821252bab5f244b1d269" translate="yes" xml:space="preserve">
          <source>The aim of WAL is to ensure that the log is written before database records are altered, but this can be subverted by disk drives that falsely report a successful write to the kernel, when in fact they have only cached the data and not yet stored it on the disk. A power failure in such a situation might lead to irrecoverable data corruption. Administrators should try to ensure that disks holding PostgreSQL's WAL log files do not make such false reports. (See &lt;a href=&quot;wal-reliability&quot;&gt;Section 29.1&lt;/a&gt;.)</source>
          <target state="translated">WAL의 목표는 데이터베이스 레코드가 변경되기 전에 로그가 기록되도록하는 것이지만 실제로는 데이터를 캐시 만하고 아직 저장하지 않은 경우 커널에 대한 성공적인 쓰기를 잘못보고하는 디스크 드라이브에 의해 무시 될 수 있습니다. 디스크에. 이러한 상황에서 정전이 발생하면 복구 할 수없는 데이터 손상이 발생할 수 있습니다. 관리자는 PostgreSQL의 WAL 로그 파일을 보유한 디스크가 그러한 잘못된보고를하지 않도록해야합니다. ( &lt;a href=&quot;wal-reliability&quot;&gt;섹션 29.1&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f9e7ab5030dfc9ff217b5be87f2efd2576b52bbd" translate="yes" xml:space="preserve">
          <source>The algorithms in &lt;code&gt;crypt()&lt;/code&gt; differ from the usual MD5 or SHA1 hashing algorithms in the following respects:</source>
          <target state="translated">알고리즘에 &lt;code&gt;crypt()&lt;/code&gt; 다음의 측면에서 통상의 MD5 또는 SHA1 해시 알고리즘은 다르다 :</target>
        </trans-unit>
        <trans-unit id="bb6ddacff228befd7481577e88b1910758787a46" translate="yes" xml:space="preserve">
          <source>The alias becomes the new name of the table reference so far as the current query is concerned &amp;mdash; it is not allowed to refer to the table by the original name elsewhere in the query. Thus, this is not valid:</source>
          <target state="translated">별칭은 현재 쿼리와 관련하여 테이블 참조의 새 이름이됩니다. 쿼리의 다른 곳에서는 원래 이름으로 테이블을 참조 할 수 없습니다. 따라서 이것은 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="5c707c122664d3415484ea0149341fcdfab44cfa" translate="yes" xml:space="preserve">
          <source>The allowed contents of a &lt;code&gt;RETURNING&lt;/code&gt; clause are the same as a &lt;code&gt;SELECT&lt;/code&gt; command's output list (see &lt;a href=&quot;queries-select-lists&quot;&gt;Section 7.3&lt;/a&gt;). It can contain column names of the command's target table, or value expressions using those columns. A common shorthand is &lt;code&gt;RETURNING *&lt;/code&gt;, which selects all columns of the target table in order.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 절의 허용 된 내용은 &lt;code&gt;SELECT&lt;/code&gt; 명령의 출력 목록 과 동일 합니다 ( &lt;a href=&quot;queries-select-lists&quot;&gt;섹션 7.3&lt;/a&gt; 참조 ). 명령 대상 테이블의 열 이름 또는 해당 열을 사용하는 값 ​​표현식을 포함 할 수 있습니다. 일반적인 축약 형은 &lt;code&gt;RETURNING *&lt;/code&gt; 이며 대상 테이블의 모든 열을 순서대로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6fc27c228553cd704a3ef6963db1526d2404113f" translate="yes" xml:space="preserve">
          <source>The alternative archive file formats must be used with &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; to rebuild the database. They allow pg_restore to be selective about what is restored, or even to reorder the items prior to being restored. The archive file formats are designed to be portable across architectures.</source>
          <target state="translated">데이터베이스를 재 빌드 하려면 대체 아카이브 파일 형식을 &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; 와 함께 사용해야 합니다. 그것들은 pg_restore가 복원 된 것을 선택적으로하거나 심지어 복원되기 전에 항목을 재정렬 할 수있게합니다. 아카이브 파일 형식은 여러 아키텍처에서 이식 가능하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="30b730b12e2a6a8e73614c8aa5e3a5771cc3031c" translate="yes" xml:space="preserve">
          <source>The amount of information stored in &lt;code&gt;pg_statistic&lt;/code&gt; by &lt;code&gt;ANALYZE&lt;/code&gt;, in particular the maximum number of entries in the &lt;code&gt;most_common_vals&lt;/code&gt; and &lt;code&gt;histogram_bounds&lt;/code&gt; arrays for each column, can be set on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable. The default limit is presently 100 entries. Raising the limit might allow more accurate planner estimates to be made, particularly for columns with irregular data distributions, at the price of consuming more space in &lt;code&gt;pg_statistic&lt;/code&gt; and slightly more time to compute the estimates. Conversely, a lower limit might be sufficient for columns with simple data distributions.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 에 의해 &lt;code&gt;pg_statistic&lt;/code&gt; 에 저장된 정보의 양 , 특히 각 열에 대한 &lt;code&gt;most_common_vals&lt;/code&gt; 및 &lt;code&gt;histogram_bounds&lt;/code&gt; 배열 의 최대 항목 수는 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; 명령을 사용하여 열별로 또는 전체적으로 설정 하여 열별로 설정할 수 있습니다 &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target의&lt;/a&gt; 구성 변수. 기본 제한은 현재 100 개 항목입니다. 한계를 높이면 &lt;code&gt;pg_statistic&lt;/code&gt; 에서 더 많은 공간을 소비하는 가격으로 특히 데이터가 불규칙한 열에 대해보다 정확한 플래너 추정이 이루어질 수 있습니다.추정치를 계산하는 데 약간의 시간이 더 걸립니다. 반대로, 간단한 데이터 분포를 가진 열에는 하한이 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0881173259f19f591f19be0dcc933c7ede671117" translate="yes" xml:space="preserve">
          <source>The amount of shared memory used for WAL data that has not yet been written to disk. The default setting of -1 selects a size equal to 1/32nd (about 3%) of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but not less than &lt;code&gt;64kB&lt;/code&gt; nor more than the size of one WAL segment, typically &lt;code&gt;16MB&lt;/code&gt;. This value can be set manually if the automatic choice is too large or too small, but any positive value less than &lt;code&gt;32kB&lt;/code&gt; will be treated as &lt;code&gt;32kB&lt;/code&gt;. If this value is specified without units, it is taken as WAL blocks, that is &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; bytes, typically 8kB. This parameter can only be set at server start.</source>
          <target state="translated">아직 디스크에 기록되지 않은 WAL 데이터에 사용 된 공유 메모리의 양입니다. -1의 기본 설정은 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 의 1/32 (약 3 %)와 같지만 &lt;code&gt;64kB&lt;/code&gt; 이상 또는 하나의 WAL 세그먼트의 크기 (일반적으로 &lt;code&gt;16MB&lt;/code&gt; ) 보다 작은 크기를 선택 합니다. 자동 선택이 너무 크거나 너무 작은 경우이 값을 수동으로 설정할 수 있지만보다 양의 값 &lt;code&gt;32kB&lt;/code&gt; 으로 처리됩니다 &lt;code&gt;32kB&lt;/code&gt; . 이 값을 단위없이 지정하면 WAL 블록, 즉 &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; 바이트 (일반적으로 8kB)로 사용됩니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb3e8e0a1884bdfed25b92caf4ca9464cbb400f7" translate="yes" xml:space="preserve">
          <source>The amount of time that the process will sleep when the cost limit has been exceeded. If this value is specified without units, it is taken as milliseconds. The default value is zero, which disables the cost-based vacuum delay feature. Positive values enable cost-based vacuuming.</source>
          <target state="translated">비용 한도를 초과했을 때 프로세스가 절전 모드로 전환되는 시간입니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 기본값은 0이며 비용 기반 진공 지연 기능을 비활성화합니다. 양수 값을 사용하면 비용 기반 진공 청소가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="398a780c0d81cf69e4ef47e3ad5d58413fde5194" translate="yes" xml:space="preserve">
          <source>The amount of time to delay just after a new server process is forked, before it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger to trace down misbehavior in authentication. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">새 서버 프로세스가 분기 된 직후 인증 절차를 수행하기 전에 지연되는 시간입니다. 이는 개발자에게 인증시 오작동을 추적하기 위해 디버거를 사용하여 서버 프로세스에 연결할 수있는 기회를 제공하기위한 것입니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 값이 0 (기본값)이면 지연이 비활성화됩니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa9e04a9a492e3d82c3eee69d98abd9fe97d974" translate="yes" xml:space="preserve">
          <source>The amount of time to delay when a new server process is started, after it conducts the authentication procedure. This is intended to give developers an opportunity to attach to the server process with a debugger. If this value is specified without units, it is taken as seconds. A value of zero (the default) disables the delay. This parameter cannot be changed after session start.</source>
          <target state="translated">인증 절차를 수행 한 후 새 서버 프로세스가 시작될 때 지연되는 시간입니다. 개발자에게 디버거를 사용하여 서버 프로세스에 연결할 수있는 기회를 제공하기위한 것입니다. 이 값을 단위없이 지정하면 초 단위로 사용됩니다. 값이 0 (기본값)이면 지연이 비활성화됩니다. 세션 시작 후에는이 매개 변수를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eb708237d12cba546c559b2942241cf8b7e257d" translate="yes" xml:space="preserve">
          <source>The apply process on the subscriber database always runs with &lt;code&gt;session_replication_role&lt;/code&gt; set to &lt;code&gt;replica&lt;/code&gt;, which produces the usual effects on triggers and constraints.</source>
          <target state="translated">구독자 데이터베이스의 적용 프로세스는 항상 &lt;code&gt;session_replication_role&lt;/code&gt; 을 &lt;code&gt;replica&lt;/code&gt; 로 설정하여 실행되며 , 이는 트리거 및 제한 조건에 대한 일반적인 영향을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7cc0c47ee6bb287c95c39ac65d501649b42f2391" translate="yes" xml:space="preserve">
          <source>The approach of lower-casing strings for comparison does not handle some Unicode special cases correctly, for example when one upper-case letter has two lower-case letter equivalents. Unicode distinguishes between &lt;em&gt;case mapping&lt;/em&gt; and &lt;em&gt;case folding&lt;/em&gt; for this reason. Use nondeterministic collations instead of &lt;code&gt;citext&lt;/code&gt; to handle that correctly.</source>
          <target state="translated">비교를위한 소문자 문자열의 접근 방식은 일부 유니 코드 특수 사례를 올바르게 처리하지 못합니다 (예 : 하나의 대문자에 두 개의 소문자 등가가있는 경우). 이러한 이유로 유니 코드는 대 / &lt;em&gt;소문자&lt;/em&gt; 구분 과 대 / &lt;em&gt;소문자&lt;/em&gt; 구분을 구분 합니다. &lt;code&gt;citext&lt;/code&gt; 대신 비 결정적 데이터 정렬을 사용하여 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="6080666b4ca02e10aa81255d6daacddec5bda53b" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value, when using moving-aggregate mode. This works the same as &lt;code&gt;state_data_size&lt;/code&gt;.</source>
          <target state="translated">이동 집계 모드를 사용할 때 집계 상태 값의 대략적인 평균 크기 (바이트)입니다. 이것은 &lt;code&gt;state_data_size&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cd3a8a8bd1d1979e55b0fa66bfe45e8f15c71463" translate="yes" xml:space="preserve">
          <source>The approximate average size (in bytes) of the aggregate's state value. If this parameter is omitted or is zero, a default estimate is used based on the &lt;code&gt;state_data_type&lt;/code&gt;. The planner uses this value to estimate the memory required for a grouped aggregate query. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;; therefore, large values of this parameter discourage use of hash aggregation.</source>
          <target state="translated">집계 상태 값의 대략적인 평균 크기 (바이트)입니다. 이 매개 변수가 생략되거나 0이면 &lt;code&gt;state_data_type&lt;/code&gt; 에 따라 기본 추정값이 사용됩니다 . 플래너는이 값을 사용하여 그룹화 된 집계 쿼리에 필요한 메모리를 추정합니다. 플래너는 해시 테이블이 &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt; 에 맞는 것으로 추정되는 경우에만 이러한 쿼리에 해시 집계 사용을 고려합니다 . 따라서이 매개 변수의 큰 값은 해시 집계 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bc1a8ecb6b5b4b69664dd591c46774534fc3e77" translate="yes" xml:space="preserve">
          <source>The approximation 365+97/400 is achieved by having 97 leap years every 400 years, using the following rules:</source>
          <target state="translated">근사치 365 + 97 / 400은 다음 규칙을 사용하여 400 년마다 97 윤년을 가짐으로써 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="31a6736bfcac19a9525dbc2f1d3d326327c448b4" translate="yes" xml:space="preserve">
          <source>The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short &lt;code&gt;archive_timeout&lt;/code&gt; &amp;mdash; it will bloat your archive storage. &lt;code&gt;archive_timeout&lt;/code&gt; settings of a minute or so are usually reasonable.</source>
          <target state="translated">아카이브 명령은 완료된 WAL 세그먼트에서만 호출됩니다. 따라서 서버에서 적은 양의 WAL 트래픽 만 생성하는 경우 (또는 느슨한 기간이있는 경우) 트랜잭션 완료와 보관 저장소의 안전한 기록 사이에 시간이 오래 걸릴 수 있습니다. 보관되지 않은 오래된 데이터의 수를 제한하기 위해 &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; 을 설정 하여 서버가 최소한 자주 새 WAL 세그먼트 파일로 전환하도록 할 수 있습니다 . 강제 스위치로 인해 조기에 아카이브 된 아카이브 파일은 여전히 ​​전체 파일과 길이가 같습니다. 따라서 매우 짧은 &lt;code&gt;archive_timeout&lt;/code&gt; 을 설정하는 것은 현명하지 않습니다. 이는 아카이브 스토리지를 과도하게 증가시킵니다. 일반적으로 1 분 정도의 &lt;code&gt;archive_timeout&lt;/code&gt; 설정이 적당합니다.</target>
        </trans-unit>
        <trans-unit id="4b5c4c289983b255b0c54296b2920b77c593a40a" translate="yes" xml:space="preserve">
          <source>The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory).</source>
          <target state="translated">archive 명령은 일반적으로 기존 아카이브 파일을 덮어 쓰지 않도록 설계되어야합니다. 이것은 관리자 오류 (예 : 서로 다른 두 서버의 출력을 동일한 아카이브 디렉토리로 보내는 경우)의 아카이브 무결성을 유지하기위한 중요한 안전 기능입니다.</target>
        </trans-unit>
        <trans-unit id="cf0db639e47353fbf356cd38ab714bab5a462b99" translate="yes" xml:space="preserve">
          <source>The archive command will be executed under the ownership of the same user that the PostgreSQL server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access.</source>
          <target state="translated">아카이브 명령은 PostgreSQL 서버가 실행중인 동일한 사용자의 소유권으로 실행됩니다. 보관중인 일련의 WAL 파일에는 데이터베이스의 모든 항목이 효과적으로 포함되므로 보관 된 데이터가 눈에 띄지 않도록 보호해야합니다. 예를 들어, 그룹 또는 월드 읽기 권한이없는 디렉토리에 아카이브하십시오.</target>
        </trans-unit>
        <trans-unit id="c8f2b342beee7c3f52ad6834dd7e62ec7b49990d" translate="yes" xml:space="preserve">
          <source>The archive is a &lt;code&gt;tar&lt;/code&gt; archive.</source>
          <target state="translated">아카이브는 &lt;code&gt;tar&lt;/code&gt; 아카이브입니다.</target>
        </trans-unit>
        <trans-unit id="d5dd8d384e2ea3f19ced747049fc2fc3701b0b55" translate="yes" xml:space="preserve">
          <source>The archive is a directory archive.</source>
          <target state="translated">아카이브는 디렉토리 아카이브입니다.</target>
        </trans-unit>
        <trans-unit id="055700e9693e4de21f0986775e962d50e33c74ee" translate="yes" xml:space="preserve">
          <source>The archive is in the custom format of pg_dump.</source>
          <target state="translated">아카이브는 pg_dump의 사용자 정의 형식입니다.</target>
        </trans-unit>
        <trans-unit id="eadab5c3d582261bf3c9c742fde723a5f27a622f" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to a &lt;code&gt;GISTENTRY&lt;/code&gt; struct. On entry, its &lt;code&gt;key&lt;/code&gt; field contains a non-NULL leaf datum in compressed form. The return value is another &lt;code&gt;GISTENTRY&lt;/code&gt; struct, whose &lt;code&gt;key&lt;/code&gt; field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the &lt;code&gt;fetch&lt;/code&gt; method can return the argument as-is. Or, if the opclass does not have a compress function, the &lt;code&gt;fetch&lt;/code&gt; method can be omitted as well, since it would necessarily be a no-op.</source>
          <target state="translated">인수는 &lt;code&gt;GISTENTRY&lt;/code&gt; 구조체에 대한 포인터 입니다. 시작시 &lt;code&gt;key&lt;/code&gt; 필드에는 압축 양식의 NULL이 아닌 리프 데이텀이 포함됩니다. 반환 값은 &lt;code&gt;key&lt;/code&gt; 필드에 압축되지 않은 원래 형식의 동일한 데이텀이 포함 된 또 다른 &lt;code&gt;GISTENTRY&lt;/code&gt; 구조체 입니다. opclass의 compress 함수가 리프 항목에 대해 아무 것도 수행하지 않으면 &lt;code&gt;fetch&lt;/code&gt; 메소드는 인수를있는 그대로 리턴 할 수 있습니다. 또는 opclass에 압축 함수가없는 경우, &lt;code&gt;fetch&lt;/code&gt; 메소드도 반드시 no-op이므로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac840b1ef4656a9069d124658163a0da1612eba" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;EXISTS&lt;/code&gt; is an arbitrary &lt;code&gt;SELECT&lt;/code&gt; statement, or &lt;em&gt;subquery&lt;/em&gt;. The subquery is evaluated to determine whether it returns any rows. If it returns at least one row, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;true&amp;rdquo;; if the subquery returns no rows, the result of &lt;code&gt;EXISTS&lt;/code&gt; is &amp;ldquo;false&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; 의 인수 는 임의의 &lt;code&gt;SELECT&lt;/code&gt; 문 또는 &lt;em&gt;subquery&lt;/em&gt; 입니다. 부속 조회는 행을 리턴하는지 판별하기 위해 평가됩니다. 하나 이상의 행을 반환하면 &lt;code&gt;EXISTS&lt;/code&gt; 의 결과 는 &quot;true&quot;입니다. 하위 쿼리가 행을 반환하지 않으면 &lt;code&gt;EXISTS&lt;/code&gt; 의 결과 는 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d6ba5cebe3465380bdcbb01333aff93c94b4f911" translate="yes" xml:space="preserve">
          <source>The arguments can appear in any order, not only the one shown above.</source>
          <target state="translated">인수는 위에 표시된 것뿐만 아니라 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e994da275c22b1ba01eba6c807a42b44a7a8c8c1" translate="yes" xml:space="preserve">
          <source>The arguments can optionally have names attached. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for details.</source>
          <target state="translated">인수는 선택적으로 이름을 첨부 할 수 있습니다. 자세한 내용 &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;은 4.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdbe896c9bc5e0129d6c42af254aeecec20136cc" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;\set&lt;/code&gt; are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as &lt;code&gt;\set :foo 'something'&lt;/code&gt; and get &amp;ldquo;soft links&amp;rdquo; or &amp;ldquo;variable variables&amp;rdquo; of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, &lt;code&gt;\set bar :foo&lt;/code&gt; is a perfectly valid way to copy a variable.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; 의 인수는 다른 명령과 동일한 대체 규칙을 따릅니다. 따라서 &lt;code&gt;\set :foo 'something'&lt;/code&gt; 과 같은 흥미로운 참조를 구성 하고 각각 Perl 또는 PHP 명성의 &quot;소프트 링크&quot;또는 &quot;변수 변수&quot;를 얻을 수 있습니다. 불행히도 (또는 운 좋게도?), 이러한 구조로 유용한 것을 할 수있는 방법이 없습니다. 반면, &lt;code&gt;\set bar :foo&lt;/code&gt; 는 변수를 복사하는 데 유효한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2a1116027fc276cc8421c002135dbd224494828a" translate="yes" xml:space="preserve">
          <source>The arguments to the &lt;code&gt;distance&lt;/code&gt; function are identical to the arguments of the &lt;code&gt;consistent&lt;/code&gt; function.</source>
          <target state="translated">받는 인수 &lt;code&gt;distance&lt;/code&gt; 함수의 인수 동일한 &lt;code&gt;consistent&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="7770d5c449c9e31af54123c29733b7fdcc835b68" translate="yes" xml:space="preserve">
          <source>The arithmetic, bitwise, comparison and logical operators listed in &lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;Table 258&lt;/a&gt; are built into pgbench and may be used in expressions appearing in &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt;&lt;code&gt;\set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pgbench#PGBENCH-OPERATORS&quot;&gt;표 258에&lt;/a&gt; 나열된 산술, 비트, 비교 및 ​​논리 연산자 는 pgbench에 내장되어 있으며 &lt;a href=&quot;pgbench#PGBENCH-METACOMMAND-SET&quot;&gt; &lt;code&gt;\set&lt;/code&gt; &lt;/a&gt; 나타나는 표현식에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f99ae22a382dffdb58abe986f81d4d8fc31ff15a" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them are interesting. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes ordering operators (if any) in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;traversalMemoryContext&lt;/code&gt; is the memory context in which to store output traverse values (see below). &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked &amp;ldquo;all-the-same&amp;rdquo;; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if the nodes do not have labels.</source>
          <target state="translated">길이 &lt;code&gt;nkeys&lt;/code&gt; 의 배열 &lt;code&gt;scankeys&lt;/code&gt; 는 인덱스 검색 조건을 설명합니다. 이러한 조건은 AND와 결합되며 모든 조건을 만족하는 인덱스 항목 만 흥미 롭습니다. ( &lt;code&gt;nkeys&lt;/code&gt; = 0은 모든 인덱스 항목이 쿼리를 만족한다는 것을 의미합니다.) 일관된 함수는 일반적 으로 각 배열 항목 의 &lt;code&gt;sk_strategy&lt;/code&gt; 및 &lt;code&gt;sk_argument&lt;/code&gt; 필드 에만 관심을 가지 므로 각각 인덱스 가능한 연산자 및 비교 값을 제공합니다. SP-GiST 코어 코드가 이러한 조건을 필터링하므로 비교 값이 NULL인지 확인하기 위해 &lt;code&gt;sk_flags&lt;/code&gt; 를 검사 할 필요는 없습니다 . 어레이 &lt;code&gt;orderbys&lt;/code&gt; 길이의 &lt;code&gt;norderbys&lt;/code&gt; 는 동일한 방식으로 순서 연산자 (있는 경우)를 설명합니다. &lt;code&gt;reconstructedValue&lt;/code&gt; 는 부모 튜플에 대해 재구성 된 값입니다. 그것은이다 &lt;code&gt;(Datum) 0&lt;/code&gt; 경우 루트 수준에서 또는 &lt;code&gt;inner_consistent&lt;/code&gt; 기능은 상위 레벨의 값을 제공하지 않았다. &lt;code&gt;reconstructedValue&lt;/code&gt; 는 항상 &lt;code&gt;spgConfigOut&lt;/code&gt; 입니다. &lt;code&gt;leafType&lt;/code&gt; 타입. &lt;code&gt;traversalValue&lt;/code&gt; 는 부모 인덱스 튜플에서 &lt;code&gt;inner_consistent&lt;/code&gt; 의 이전 호출에서 전달 된 트래버스 데이터에 대한 포인터 이거나 루트 수준에서 NULL입니다. &lt;code&gt;traversalMemoryContext&lt;/code&gt; 는 출력 트래버스 값을 저장하는 메모리 컨텍스트입니다 (아래 참조). &lt;code&gt;level&lt;/code&gt; 루트 레벨의 경우 0부터 시작하여 현재 내부 튜플의 레벨입니다. 이 쿼리에 재구성 된 데이터가 필요한 경우 &lt;code&gt;returnData&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 입니다 . 이것은 &lt;code&gt;config&lt;/code&gt; 함수가 &lt;code&gt;canReturnData&lt;/code&gt; 를 선언 한 경우에만 해당됩니다 . 현재 내부 튜플이 &quot;동일한&quot;것으로 표시된 경우 &lt;code&gt;allTheSame&lt;/code&gt; 은 true입니다. 이 경우 모든 노드는 동일한 레이블 (있는 경우)을 가지므로 모든 노드가 쿼리와 일치합니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3&lt;/a&gt; 참조 ). &lt;code&gt;hasPrefix&lt;/code&gt; 는 현재 내부 튜플에 접두사가 포함되어 있으면 true입니다. 그렇다면 &lt;code&gt;prefixDatum&lt;/code&gt; 이 그 값입니다. &lt;code&gt;nNodes&lt;/code&gt; 는 내부 튜플에 포함 된 자식 노드의 수이며 &lt;code&gt;nodeLabels&lt;/code&gt; 레이블 값의 배열이거나 노드에 레이블이없는 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="b4cb45da91499c64a7e30418524dae4c6bc491fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;scankeys&lt;/code&gt;, of length &lt;code&gt;nkeys&lt;/code&gt;, describes the index search condition(s). These conditions are combined with AND &amp;mdash; only index entries that satisfy all of them satisfy the query. (Note that &lt;code&gt;nkeys&lt;/code&gt; = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the &lt;code&gt;sk_strategy&lt;/code&gt; and &lt;code&gt;sk_argument&lt;/code&gt; fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check &lt;code&gt;sk_flags&lt;/code&gt; to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array &lt;code&gt;orderbys&lt;/code&gt;, of length &lt;code&gt;norderbys&lt;/code&gt;, describes the ordering operators in the same manner. &lt;code&gt;reconstructedValue&lt;/code&gt; is the value reconstructed for the parent tuple; it is &lt;code&gt;(Datum) 0&lt;/code&gt; at the root level or if the &lt;code&gt;inner_consistent&lt;/code&gt; function did not provide a value at the parent level. &lt;code&gt;reconstructedValue&lt;/code&gt; is always of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;traversalValue&lt;/code&gt; is a pointer to any traverse data passed down from the previous call of &lt;code&gt;inner_consistent&lt;/code&gt; on the parent index tuple, or NULL at the root level. &lt;code&gt;level&lt;/code&gt; is the current leaf tuple's level, starting at zero for the root level. &lt;code&gt;returnData&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if reconstructed data is required for this query; this will only be so if the &lt;code&gt;config&lt;/code&gt; function asserted &lt;code&gt;canReturnData&lt;/code&gt;. &lt;code&gt;leafDatum&lt;/code&gt; is the key value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; stored in the current leaf tuple.</source>
          <target state="translated">길이 &lt;code&gt;nkeys&lt;/code&gt; 의 배열 &lt;code&gt;scankeys&lt;/code&gt; 는 인덱스 검색 조건을 설명합니다. 이러한 조건은 AND와 결합되며 모든 조건을 만족하는 인덱스 항목 만 쿼리를 만족시킵니다. ( &lt;code&gt;nkeys&lt;/code&gt; = 0은 모든 인덱스 항목이 쿼리를 만족한다는 것을 의미합니다.) 일관된 함수는 일반적 으로 각 배열 항목 의 &lt;code&gt;sk_strategy&lt;/code&gt; 및 &lt;code&gt;sk_argument&lt;/code&gt; 필드 에만 관심을 가지 므로 각각 인덱스 가능한 연산자 및 비교 값을 제공합니다. SP-GiST 코어 코드가 이러한 조건을 필터링하므로 비교 값이 NULL인지 확인하기 위해 &lt;code&gt;sk_flags&lt;/code&gt; 를 검사 할 필요는 없습니다 . 어레이 &lt;code&gt;orderbys&lt;/code&gt; 길이의 &lt;code&gt;norderbys&lt;/code&gt; 는 동일한 방식으로 순서 연산자를 설명합니다. &lt;code&gt;reconstructedValue&lt;/code&gt; 는 부모 튜플에 대해 재구성 된 값입니다. 그것은이다 &lt;code&gt;(Datum) 0&lt;/code&gt; 경우 루트 수준에서 또는 &lt;code&gt;inner_consistent&lt;/code&gt; 기능은 상위 레벨의 값을 제공하지 않았다. &lt;code&gt;reconstructedValue&lt;/code&gt; 는 항상 &lt;code&gt;spgConfigOut&lt;/code&gt; 입니다. &lt;code&gt;leafType&lt;/code&gt; 타입. &lt;code&gt;traversalValue&lt;/code&gt; 는 부모 인덱스 튜플에서 &lt;code&gt;inner_consistent&lt;/code&gt; 의 이전 호출에서 전달 된 트래버스 데이터에 대한 포인터 이거나 루트 수준에서 NULL입니다. &lt;code&gt;level&lt;/code&gt; 은 현재 리프 튜플의 레벨이며 루트 레벨의 경우 0부터 시작합니다. &lt;code&gt;returnData&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이 쿼리에 재구성 된 데이터가 필요한 경우 이것은 &lt;code&gt;config&lt;/code&gt; 함수가 &lt;code&gt;canReturnData&lt;/code&gt; 를 선언 한 경우에만 해당됩니다 . &lt;code&gt;leafDatum&lt;/code&gt; 의 키 값 &lt;code&gt;spgConfigOut&lt;/code&gt; . 현재 리프 튜플에 저장된 &lt;code&gt;leafType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e26f508cb31ef1599228fd2a799f7ebeb7c2026b" translate="yes" xml:space="preserve">
          <source>The array containment operators (&lt;code&gt;&amp;lt;@&lt;/code&gt; and &lt;code&gt;@&amp;gt;&lt;/code&gt;) consider one array to be contained in another one if each of its elements appears in the other one. Duplicates are not treated specially, thus &lt;code&gt;ARRAY[1]&lt;/code&gt; and &lt;code&gt;ARRAY[1,1]&lt;/code&gt; are each considered to contain the other.</source>
          <target state="translated">배열 포함 연산자 ( &lt;code&gt;&amp;lt;@&lt;/code&gt; 및 &lt;code&gt;@&amp;gt;&lt;/code&gt; )는 각 요소가 다른 요소에 나타나는 경우 한 배열이 다른 배열에 포함되는 것으로 간주합니다. 복제물은 특별하게 취급되지 않으므로 &lt;code&gt;ARRAY[1]&lt;/code&gt; 및 &lt;code&gt;ARRAY[1,1]&lt;/code&gt; 은 서로를 포함하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ac56c0bce21554d688d27823930a835d434c12" translate="yes" xml:space="preserve">
          <source>The array ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) compare the array contents element-by-element, using the default B-tree comparison function for the element data type, and sort based on the first difference. In multidimensional arrays the elements are visited in row-major order (last subscript varies most rapidly). If the contents of two arrays are equal but the dimensionality is different, the first difference in the dimensionality information determines the sort order. (This is a change from versions of PostgreSQL prior to 8.2: older versions would claim that two arrays with the same contents were equal, even if the number of dimensions or subscript ranges were different.)</source>
          <target state="translated">배열 순서 연산자 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 등)는 요소 데이터 유형에 대한 기본 B- 트리 비교 함수를 사용하여 배열 내용을 요소별로 비교하고 첫 번째 차이를 기준으로 정렬합니다. 다차원 배열에서 요소는 주요 행 순서로 방문합니다 (마지막 아래 첨자가 가장 빠르게 변함). 두 배열의 내용이 동일하지만 차원이 다른 경우 차원 정보의 첫 번째 차이점이 정렬 순서를 결정합니다. (이것은 8.2 이전의 PostgreSQL 버전에서 변경된 것입니다. 구 버전은 차원 또는 첨자 범위의 수가 다르더라도 내용이 동일한 두 배열이 동일하다고 주장합니다.)</target>
        </trans-unit>
        <trans-unit id="46741e31bee949b907d3858dce5eac23fd4bcbdf" translate="yes" xml:space="preserve">
          <source>The array output routine will include explicit dimensions in its result only when there are one or more lower bounds different from one.</source>
          <target state="translated">배열 출력 루틴은 하나 이상의 하한이 다른 경우에만 결과에 명시적인 차원을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="145d4d2c0c7cafb8b7bd9116657b494c47b146d7" translate="yes" xml:space="preserve">
          <source>The array output routine will put double quotes around element values if they are empty strings, contain curly braces, delimiter characters, double quotes, backslashes, or white space, or match the word &lt;code&gt;NULL&lt;/code&gt;. Double quotes and backslashes embedded in element values will be backslash-escaped. For numeric data types it is safe to assume that double quotes will never appear, but for textual data types one should be prepared to cope with either the presence or absence of quotes.</source>
          <target state="translated">배열 출력 루틴은 요소 값이 빈 문자열이거나 중괄호, 구분 기호 문자, 큰 따옴표, 백 슬래시 또는 공백을 포함하거나 &lt;code&gt;NULL&lt;/code&gt; 단어와 일치하는 경우 요소 값을 큰 따옴표로 묶습니다 . 요소 값에 포함 된 큰 따옴표와 백 슬래시는 백 슬래시 이스케이프됩니다. 숫자 데이터 유형의 경우 큰 따옴표가 나타나지 않는다고 가정하는 것이 안전하지만 텍스트 데이터 유형의 경우 따옴표의 유무에 대처할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="103411c7faff9f23f3f96fc9d71ef919bccd0156" translate="yes" xml:space="preserve">
          <source>The array subscript numbers are written within square brackets. By default PostgreSQL uses a one-based numbering convention for arrays, that is, an array of &lt;code&gt;n&lt;/code&gt; elements starts with &lt;code&gt;array[1]&lt;/code&gt; and ends with &lt;code&gt;array[n]&lt;/code&gt;.</source>
          <target state="translated">배열 첨자 번호는 대괄호 안에 표시됩니다. 기본적으로 PostgreSQL은 배열에 대해 1 기반의 번호 지정 규칙을 사용합니다. 즉, &lt;code&gt;n&lt;/code&gt; 요소 의 배열은 &lt;code&gt;array[1]&lt;/code&gt; 로 시작하고 &lt;code&gt;array[n]&lt;/code&gt; 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="d22d8bf767f7e2f65ff41f5dea0e4f13bccb5b56" translate="yes" xml:space="preserve">
          <source>The associated sort operator for a &lt;code&gt;MIN&lt;/code&gt;- or &lt;code&gt;MAX&lt;/code&gt;-like aggregate. This is just an operator name (possibly schema-qualified). The operator is assumed to have the same input data types as the aggregate (which must be a single-argument normal aggregate).</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; 또는 &lt;code&gt;MAX&lt;/code&gt; 와 같은 집계에 대한 관련 정렬 연산자입니다 . 이것은 운영자 이름 일뿐입니다 (스키마로 한정 될 수 있음). 연산자는 집계와 동일한 입력 데이터 유형을 갖는 것으로 가정합니다 (단일 인수 일반 집계 여야 함).</target>
        </trans-unit>
        <trans-unit id="daf89077b4ae20ed63b034eee053148490bd888b" translate="yes" xml:space="preserve">
          <source>The asterisk (&lt;code&gt;*&lt;/code&gt;) is used in some contexts to denote all the fields of a table row or composite value. It also has a special meaning when used as the argument of an aggregate function, namely that the aggregate does not require any explicit parameter.</source>
          <target state="translated">별표 ( &lt;code&gt;*&lt;/code&gt; )는 일부 컨텍스트에서 테이블 행의 모든 ​​필드 또는 복합 값을 나타내는 데 사용됩니다. 또한 집계 함수의 인수로 사용될 때 특별한 의미를 갖습니다. 즉 집계에는 명시적인 매개 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8f1751d17a34d74d41affe83afc62bf9926cd57" translate="yes" xml:space="preserve">
          <source>The autocommit-on mode is PostgreSQL's traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide &lt;code&gt;psqlrc&lt;/code&gt; file or your &lt;code&gt;~/.psqlrc&lt;/code&gt; file.</source>
          <target state="translated">자동 커밋 온 모드는 PostgreSQL의 일반적인 동작이지만 자동 커밋 오프는 SQL 사양에 더 가깝습니다. 자동 &lt;code&gt;psqlrc&lt;/code&gt; 오프를 선호하는 경우 시스템 전체 psqlrc 파일 또는 &lt;code&gt;~/.psqlrc&lt;/code&gt; .psqlrc 파일 에서이를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a786e81687748275f55ad70f3f5bbc00d402d949" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon does not issue &lt;code&gt;ANALYZE&lt;/code&gt; commands for foreign tables, since it has no means of determining how often that might be useful. If your queries require statistics on foreign tables for proper planning, it's a good idea to run manually-managed &lt;code&gt;ANALYZE&lt;/code&gt; commands on those tables on a suitable schedule.</source>
          <target state="translated">autovacuum 데몬은 외부 테이블에 대해 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 발행하지 않습니다.이 테이블은 유용한 빈도를 판별 할 수단이 없기 때문입니다. 쿼리에 적절한 계획을 위해 외래 테이블에 대한 통계가 필요한 경우 적절한 일정에 따라 해당 테이블에서 수동으로 관리되는 &lt;code&gt;ANALYZE&lt;/code&gt; 명령 을 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c3fb21098ee7138941d3ecbb7f53e34e6b514d65" translate="yes" xml:space="preserve">
          <source>The autovacuum daemon, if enabled, will automatically issue &lt;code&gt;ANALYZE&lt;/code&gt; commands whenever the content of a table has changed sufficiently. However, administrators might prefer to rely on manually-scheduled &lt;code&gt;ANALYZE&lt;/code&gt; operations, particularly if it is known that update activity on a table will not affect the statistics of &amp;ldquo;interesting&amp;rdquo; columns. The daemon schedules &lt;code&gt;ANALYZE&lt;/code&gt; strictly as a function of the number of rows inserted or updated; it has no knowledge of whether that will lead to meaningful statistical changes.</source>
          <target state="translated">autovacuum 데몬 (활성화 된 경우) 은 테이블의 내용이 충분히 변경 될 때마다 &lt;code&gt;ANALYZE&lt;/code&gt; 명령 을 자동으로 실행 합니다. 그러나 관리자는 특히 테이블의 업데이트 활동이 &quot;관심있는&quot;열의 통계에 영향을주지 않는 것으로 알려진 경우 수동으로 예약 된 &lt;code&gt;ANALYZE&lt;/code&gt; 작업 에 의존하는 것을 선호 할 수 있습니다. 데몬은 &lt;code&gt;ANALYZE&lt;/code&gt; 를 삽입 또는 업데이트 된 행 수의 함수로 엄격하게 예약합니다 . 의미있는 통계적 변화를 가져올 지 여부는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="252860c5ed0258d1ec21ceb8459b34f92032e663" translate="yes" xml:space="preserve">
          <source>The availability of the different password-based authentication methods depends on how a user's password on the server is encrypted (or hashed, more accurately). This is controlled by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; at the time the password is set. If a password was encrypted using the &lt;code&gt;scram-sha-256&lt;/code&gt; setting, then it can be used for the authentication methods &lt;code&gt;scram-sha-256&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; (but password transmission will be in plain text in the latter case). The authentication method specification &lt;code&gt;md5&lt;/code&gt; will automatically switch to using the &lt;code&gt;scram-sha-256&lt;/code&gt; method in this case, as explained above, so it will also work. If a password was encrypted using the &lt;code&gt;md5&lt;/code&gt; setting, then it can be used only for the &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; authentication method specifications (again, with the password transmitted in plain text in the latter case). (Previous PostgreSQL releases supported storing the password on the server in plain text. This is no longer possible.) To check the currently stored password hashes, see the system catalog &lt;code&gt;pg_authid&lt;/code&gt;.</source>
          <target state="translated">다른 비밀번호 기반 인증 방법의 가용성은 서버의 사용자 비밀번호가 암호화되는 방식 (보다 정확하게 해시되는 방식)에 따라 다릅니다. 이는 비밀번호가 설정 될 때 구성 매개 변수 &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt; 에 의해 제어됩니다 . 비밀번호가 &lt;code&gt;scram-sha-256&lt;/code&gt; 설정을 사용하여 암호화 된 경우 &lt;code&gt;scram-sha-256&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 인증 방법에 사용할 수 있습니다 (단, 비밀번호 전송은 후자의 경우 일반 텍스트로 표시됨). 이 경우 인증 방법 사양 &lt;code&gt;md5&lt;/code&gt; 는 &lt;code&gt;scram-sha-256&lt;/code&gt; 방법 을 사용하여 자동으로 전환 되므로 작동합니다. &lt;code&gt;md5&lt;/code&gt; 를 사용하여 비밀번호를 암호화 한 경우이 설정은 &lt;code&gt;md5&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 인증 방법 사양 (후자의 경우 일반 텍스트로 비밀번호가 전송 됨) 에만 사용할 수 있습니다 . (이전 PostgreSQL 릴리스는 서버에 비밀번호를 일반 텍스트로 저장하는 것을 지원했습니다. 더 이상 가능하지 않습니다.) 현재 저장된 비밀번호 해시를 확인하려면 시스템 카탈로그 &lt;code&gt;pg_authid&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be4db45cb9d664398bfb8a833d78745c5f0e03cb" translate="yes" xml:space="preserve">
          <source>The available commands are:</source>
          <target state="translated">사용 가능한 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8b4cfaf9660d8b419b38ef501d2e57aeb699d73" translate="yes" xml:space="preserve">
          <source>The available functions are shown in &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;Table F.14&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 기능은 &lt;a href=&quot;ltree#LTREE-FUNC-TABLE&quot;&gt;표 F.14&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf27edb4ec77236cfb1d7851c53ced1470b1ae0" translate="yes" xml:space="preserve">
          <source>The available privileges are:</source>
          <target state="translated">사용 가능한 권한은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b24cdea942d5e58d37185d11c8d0001459291bc6" translate="yes" xml:space="preserve">
          <source>The available sequence functions are:</source>
          <target state="translated">사용 가능한 시퀀스 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f54359e34884f0f14a7082c4b037dceb1040a71" translate="yes" xml:space="preserve">
          <source>The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.</source>
          <target state="translated">사용 가능한 트랜잭션 특성은 트랜잭션 격리 수준, 트랜잭션 액세스 모드 (읽기 / 쓰기 또는 읽기 전용) 및 연기 가능한 모드입니다. 또한 세션 기본값이 아닌 현재 트랜잭션에 대해서만 스냅 샷을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="690838e9cb021af0a2b1acec6c3a93a7e08f1bb6" translate="yes" xml:space="preserve">
          <source>The average stored width, in bytes, of nonnull entries</source>
          <target state="translated">널이 아닌 항목의 평균 저장된 너비 (바이트)</target>
        </trans-unit>
        <trans-unit id="fde6e34822920c61d23e994603a609b1307667e3" translate="yes" xml:space="preserve">
          <source>The background writer is active during recovery and will perform restartpoints (similar to checkpoints on the primary) and normal block cleaning activities. This can include updates of the hint bit information stored on the standby server. The &lt;code&gt;CHECKPOINT&lt;/code&gt; command is accepted during recovery, though it performs a restartpoint rather than a new checkpoint.</source>
          <target state="translated">백그라운드 기록기는 복구 중에 활성화되며 기본 (점검의 체크 포인트와 유사한) 재시작 지점과 일반 블록 정리 작업을 수행합니다. 여기에는 대기 서버에 저장된 힌트 비트 정보의 업데이트가 포함될 수 있습니다. &lt;code&gt;CHECKPOINT&lt;/code&gt; 그것이 restartpoint보다는 새로운 체크 포인트를 수행하지만 명령은 복구 중에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4770c7c3de3b5a6b683a55e8771f9ee1778b13" translate="yes" xml:space="preserve">
          <source>The backup history file is just a small text file. It contains the label string you gave to &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</source>
          <target state="translated">백업 기록 파일은 작은 텍스트 파일입니다. 여기에는 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup에&lt;/a&gt; 제공 한 레이블 문자열 과 백업의 시작 및 종료 시간 및 WAL 세그먼트가 포함됩니다. 레이블을 사용하여 연관된 덤프 파일을 식별 한 경우 아카이브 된 히스토리 파일은 복원 할 덤프 파일을 알려주기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c801dce038f073674a8ac5aca2db97b365640813" translate="yes" xml:space="preserve">
          <source>The backup history file is not created in the database cluster backed up.</source>
          <target state="translated">백업 히스토리 파일은 백업 된 데이터베이스 클러스터에 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be7e03b230f28bb65cecb0388bcfd3f69ad98241" translate="yes" xml:space="preserve">
          <source>The backup is made over a regular PostgreSQL connection, and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must explicitly permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the backup and one for WAL streaming (if used).</source>
          <target state="translated">백업은 일반적인 PostgreSQL 연결을 통해 이루어지며 복제 프로토콜을 사용합니다. 수퍼 유저 또는 &lt;code&gt;REPLICATION&lt;/code&gt; 권한이 있는 사용자 ( &lt;a href=&quot;role-attributes&quot;&gt;21.2 절&lt;/a&gt; 참조 )를 사용하여 연결해야 하며 &lt;code&gt;pg_hba.conf&lt;/code&gt; 는 명시 적으로 복제 연결을 허용해야합니다. 또한 백업에 사용할 수있는 하나 이상의 세션과 WAL 스트리밍에 사용되는 하나 이상의 세션 (사용 된 경우)을 남겨 둘 수 있도록 &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; 를 높게 설정 하여 서버를 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eee28f79bda7267e3e26bc973ac8a0442a749a1b" translate="yes" xml:space="preserve">
          <source>The backup label file includes the label string you gave to &lt;code&gt;pg_start_backup&lt;/code&gt;, as well as the time at which &lt;code&gt;pg_start_backup&lt;/code&gt; was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory &lt;code&gt;pg_tblspc/&lt;/code&gt; and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process.</source>
          <target state="translated">백업 레이블 파일에는 &lt;code&gt;pg_start_backup&lt;/code&gt; 이 실행 된 시간 과 시작 WAL 파일의 이름 뿐만 아니라 &lt;code&gt;pg_start_backup&lt;/code&gt; 에 제공 한 레이블 문자열이 포함 됩니다. 혼란 스러울 경우 백업 파일 내부를 살펴보고 덤프 파일이 어느 백업 세션에서 왔는지 정확하게 판단 할 수 있습니다. 테이블 스페이스 맵 파일에는 &lt;code&gt;pg_tblspc/&lt;/code&gt; 디렉토리에있는 심볼릭 링크 이름과 각 심볼릭 링크의 전체 경로가 포함됩니다. 이 파일들은 단지 귀하의 정보를위한 것이 아닙니다. 이들의 존재와 내용은 시스템 복구 프로세스의 올바른 작동에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ec28fc3545975c7f203eb96bb815ab982f3d0305" translate="yes" xml:space="preserve">
          <source>The backup will include all files in the data directory and tablespaces, including the configuration files and any additional files placed in the directory by third parties, except certain temporary files managed by PostgreSQL. But only regular files and directories are copied, except that symbolic links used for tablespaces are preserved. Symbolic links pointing to certain directories known to PostgreSQL are copied as empty directories. Other symbolic links and special device files are skipped. See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt; for the precise details.</source>
          <target state="translated">백업에는 구성 파일 및 PostgreSQL에서 관리하는 특정 임시 파일을 제외하고 타사에서 디렉토리에 배치 한 추가 파일을 포함하여 데이터 디렉토리 및 테이블 스페이스의 모든 파일이 포함됩니다. 그러나 테이블 공간에 사용되는 기호 링크가 유지되는 것을 제외하고는 일반 파일과 디렉토리 만 복사됩니다. PostgreSQL로 알려진 특정 디렉토리를 가리키는 심볼릭 링크는 빈 디렉토리로 복사됩니다. 다른 기호 링크 및 특수 장치 파일은 건너 뜁니다. 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;은 52.4 절을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5658ad1f6ce193a23633c994bf8ae4b8bb4bf57e" translate="yes" xml:space="preserve">
          <source>The base name of the shared object containing the output plugin this logical slot is using, or null for physical slots.</source>
          <target state="translated">이 논리적 슬롯이 사용하는 출력 플러그인을 포함하는 공유 객체의 기본 이름이거나 물리적 슬롯의 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="01f76877be594c383342f8dd0d2d641fff88c4a5" translate="yes" xml:space="preserve">
          <source>The basic idea is to copy all file system-level changes from the source cluster to the target cluster:</source>
          <target state="translated">기본 아이디어는 모든 파일 시스템 레벨 변경 사항을 소스 클러스터에서 대상 클러스터로 복사하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="19e50f37cd3ac57ef618ac5cb372c8487c7f1bd1" translate="yes" xml:space="preserve">
          <source>The basic value of &lt;code&gt;SELECT&lt;/code&gt; in &lt;code&gt;WITH&lt;/code&gt; is to break down complicated queries into simpler parts. An example is:</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 에서 &lt;code&gt;SELECT&lt;/code&gt; 의 기본 값은 복잡한 쿼리를 더 간단한 부분으로 나누는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2b5aa5c42d40515ef87930aadc0b43fe175a670" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;%&lt;/code&gt; is a bit complicated. It tries to match words rather than the entire label. For example &lt;code&gt;foo_bar%&lt;/code&gt; matches &lt;code&gt;foo_bar_baz&lt;/code&gt; but not &lt;code&gt;foo_barbaz&lt;/code&gt;. If combined with &lt;code&gt;*&lt;/code&gt;, prefix matching applies to each word separately, for example &lt;code&gt;foo_bar%*&lt;/code&gt; matches &lt;code&gt;foo1_bar2_baz&lt;/code&gt; but not &lt;code&gt;foo1_br2_baz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 의 동작은 약간 복잡합니다. 전체 레이블이 아닌 단어와 일치 시키려고합니다. 예를 들어 &lt;code&gt;foo_bar%&lt;/code&gt; 는 &lt;code&gt;foo_bar_baz&lt;/code&gt; 와는 일치 하지만 &lt;code&gt;foo_barbaz&lt;/code&gt; 일치 하지 않습니다 . &lt;code&gt;*&lt;/code&gt; 와 결합하면 접두사 일치가 각 단어에 개별적으로 적용됩니다. 예를 들어 &lt;code&gt;foo_bar%*&lt;/code&gt; 는 &lt;code&gt;foo1_bar2_baz&lt;/code&gt; 와 일치 하지만 &lt;code&gt;foo1_br2_baz&lt;/code&gt; 와는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8f85d7de8ab2c8253e41f10bbddbd7196e58ed" translate="yes" xml:space="preserve">
          <source>The behavior of a custom text search configuration can easily become confusing. The functions described in this section are useful for testing text search objects. You can test a complete configuration, or test parsers and dictionaries separately.</source>
          <target state="translated">사용자 정의 텍스트 검색 구성의 동작은 쉽게 혼동 될 수 있습니다. 이 섹션에서 설명하는 기능은 텍스트 검색 개체를 테스트하는 데 유용합니다. 전체 구성을 테스트하거나 파서 및 사전을 개별적으로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b27c83984e819ed5cc108965dd1a811c9d23e12" translate="yes" xml:space="preserve">
          <source>The behavior of foreign keys can be finely tuned to your application. We will not go beyond this simple example in this tutorial, but just refer you to &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; for more information. Making correct use of foreign keys will definitely improve the quality of your database applications, so you are strongly encouraged to learn about them.</source>
          <target state="translated">외래 키의 동작은 응용 프로그램에 맞게 미세 조정할 수 있습니다. 이 자습서에서는이 간단한 예제를 넘어서는 것이 아니라 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;5 장&lt;/a&gt; 을 참조하십시오. 외래 키를 올바르게 사용하면 데이터베이스 응용 프로그램의 품질이 확실히 향상되므로 이에 대해 배우는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="296b0cebbabc7c8e4b2d8335b6fb9121ab843326" translate="yes" xml:space="preserve">
          <source>The behavior of temporary tables at the end of a transaction block can be controlled using &lt;code&gt;ON COMMIT&lt;/code&gt;. The three options are:</source>
          <target state="translated">트랜잭션 블록 끝에서 임시 테이블의 동작은 &lt;code&gt;ON COMMIT&lt;/code&gt; 를 사용하여 제어 할 수 있습니다 . 세 가지 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80731f14bda7a7a22a0a9014398f2bbf94eee233" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;-t&lt;/code&gt; switch is not entirely upward compatible with pre-8.2 PostgreSQL versions. Formerly, writing &lt;code&gt;-t tab&lt;/code&gt; would dump all tables named &lt;code&gt;tab&lt;/code&gt;, but now it just dumps whichever one is visible in your default search path. To get the old behavior you can write &lt;code&gt;-t '*.tab'&lt;/code&gt;. Also, you must write something like &lt;code&gt;-t sch.tab&lt;/code&gt; to select a table in a particular schema, rather than the old locution of &lt;code&gt;-n sch -t tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 스위치 의 동작은 8.2 이전 PostgreSQL 버전과 완전히 호환되지는 않습니다. 이전, 쓰기 &lt;code&gt;-t tab&lt;/code&gt; 이름 모든 테이블을 덤프 할 &lt;code&gt;tab&lt;/code&gt; , 그러나 지금은 하나의 기본 검색 경로에 표시 중 덤프합니다. 이전 동작을 얻으려면 &lt;code&gt;-t '*.tab'&lt;/code&gt; 을 쓸 수 있습니다 . 또한 &lt;code&gt;-n sch -t tab&lt;/code&gt; 의 이전 실행이 아닌 특정 스키마에서 테이블을 선택하려면 &lt;code&gt;-t sch.tab&lt;/code&gt; 과 같은 것을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6bad8faf22e7898fa3d14beb6bbfad8894c7e5cb" translate="yes" xml:space="preserve">
          <source>The behavior specified by the SQL standard is most closely approximated by giving users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, while roles are given the &lt;code&gt;INHERIT&lt;/code&gt; attribute.</source>
          <target state="translated">SQL 표준에 의해 지정된 동작은 사용자에게 &lt;code&gt;NOINHERIT&lt;/code&gt; 속성을 제공하고 역할에 &lt;code&gt;INHERIT&lt;/code&gt; 속성을 부여 함으로써 가장 가깝습니다 .</target>
        </trans-unit>
        <trans-unit id="999fc3c54ee5c4c5f6f59e07c2e8f063ee92343a" translate="yes" xml:space="preserve">
          <source>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</source>
          <target state="translated">이점은 일반적으로 테이블이 매우 큰 경우에만 가치가 있습니다. 일반적으로 테이블 크기가 데이터베이스 서버의 실제 메모리를 초과해야한다는 점에서 테이블이 파티셔닝의 이점을 얻는 정확한 지점은 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7e72906a1cbbbaa7de5bc80e5365aa82f11074fd" translate="yes" xml:space="preserve">
          <source>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</source>
          <target state="translated">교착 상태에 대한 최선의 방어는 일반적으로 데이터베이스를 사용하는 모든 응용 프로그램이 일관된 순서로 여러 객체에 대한 잠금을 획득하도록하여이를 방지하는 것입니다. 위의 예에서 두 트랜잭션이 동일한 순서로 행을 업데이트 한 경우 교착 상태가 발생하지 않았습니다. 또한 트랜잭션에서 객체에 대해 획득 한 첫 번째 잠금이 해당 객체에 필요한 가장 제한적인 모드인지 확인해야합니다. 이를 사전에 검증 할 수없는 경우 교착 상태로 인해 중단 된 트랜잭션을 재 시도하여 교착 상태를 즉시 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d85f73754546926f4e2d17ccb6f522601d212cb5" translate="yes" xml:space="preserve">
          <source>The best solution for high availability is to ensure you keep as many synchronous standbys as requested. This can be achieved by naming multiple potential synchronous standbys using &lt;code&gt;synchronous_standby_names&lt;/code&gt;.</source>
          <target state="translated">고 가용성을위한 최상의 솔루션은 요청한만큼의 동기 대기를 유지하는 것입니다. 이는 사용 전위 여러 동기 대기 상태 이름에 의해 달성 될 수 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e9ecf6d09480763021769b90c87994739dc69c88" translate="yes" xml:space="preserve">
          <source>The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types &lt;code&gt;bit&lt;/code&gt; and &lt;code&gt;bit varying&lt;/code&gt;, as shown in &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;Table 9.14&lt;/a&gt;.</source>
          <target state="translated">비트 연산자는 정수 데이터 형식에서만 작동하는 반면 다른 연산자는 모든 숫자 데이터 형식에 사용할 수 있습니다. 비트 연산자는 &lt;a href=&quot;functions-bitstring#FUNCTIONS-BIT-STRING-OP-TABLE&quot;&gt;표 9.14에&lt;/a&gt; 표시된 것처럼 비트 문자열 유형의 &lt;code&gt;bit&lt;/code&gt; 및 &lt;code&gt;bit varying&lt;/code&gt; 대해서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bb544aef82eb5e331a1c83d14ba3f14981e458a" translate="yes" xml:space="preserve">
          <source>The built-in parser is named &lt;code&gt;pg_catalog.default&lt;/code&gt;. It recognizes 23 token types, shown in &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;Table 12.1&lt;/a&gt;.</source>
          <target state="translated">내장 파서의 이름은 &lt;code&gt;pg_catalog.default&lt;/code&gt; 입니다. &lt;a href=&quot;textsearch-parsers#TEXTSEARCH-DEFAULT-PARSER&quot;&gt;표 12.1에&lt;/a&gt; 표시된 23 개의 토큰 유형을 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="0849997236dc34c615a4c13089f2ec08456d374b" translate="yes" xml:space="preserve">
          <source>The built-in range types &lt;code&gt;int4range&lt;/code&gt;, &lt;code&gt;int8range&lt;/code&gt;, and &lt;code&gt;daterange&lt;/code&gt; all use a canonical form that includes the lower bound and excludes the upper bound; that is, &lt;code&gt;[)&lt;/code&gt;. User-defined range types can use other conventions, however.</source>
          <target state="translated">내장 범위 유형 &lt;code&gt;int4range&lt;/code&gt; , &lt;code&gt;int8range&lt;/code&gt; 및 &lt;code&gt;daterange&lt;/code&gt; 는 모두 하한을 포함하고 상한을 제외하는 표준 형식을 사용합니다. 즉, &lt;code&gt;[)&lt;/code&gt; 입니다. 그러나 사용자 정의 범위 유형은 다른 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a312305dbd3d6563e32a6d1866cf9d94a8d3583" translate="yes" xml:space="preserve">
          <source>The built-in window functions are described in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Other window functions can be added by the user. Also, any built-in or user-defined general-purpose or statistical aggregate can be used as a window function. (Ordered-set and hypothetical-set aggregates cannot presently be used as window functions.)</source>
          <target state="translated">내장 창 기능은 &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;표 9.60에&lt;/a&gt; 설명되어 있습니다. 다른 창 기능은 사용자가 추가 할 수 있습니다. 또한 모든 내장 또는 사용자 정의 범용 또는 통계 집계를 창 함수로 사용할 수 있습니다. (오더 세트 및 가설 세트 집계는 현재 창 함수로 사용할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="1eb1519109d2d92138e97ee3336017e3e8180e57" translate="yes" xml:space="preserve">
          <source>The built-in window functions are listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt;. Note that these functions &lt;em&gt;must&lt;/em&gt; be invoked using window function syntax, i.e., an &lt;code&gt;OVER&lt;/code&gt; clause is required.</source>
          <target state="translated">내장 창 기능은 &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;표 9.60에&lt;/a&gt; 나열되어 있습니다. 이러한 함수 &lt;em&gt;는&lt;/em&gt; 윈도우 함수 구문을 사용하여 호출 &lt;em&gt;해야&lt;/em&gt; 합니다. 즉, &lt;code&gt;OVER&lt;/code&gt; 절이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0a15741ae39e976d65eb76bd158e7ef106ba0c6d" translate="yes" xml:space="preserve">
          <source>The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in &lt;code&gt;pg_pltemplate&lt;/code&gt;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database. (This might result in &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; failing, if the shared library that implements the language is not available in the installation.)</source>
          <target state="translated">서버에 &lt;code&gt;pg_pltemplate&lt;/code&gt; 의 언어에 대한 항목이없는 경우 호출 핸들러 함수, 인라인 핸들러 함수 (있는 경우) 및 유효성 검증기 함수 (있는 경우)가 이미 존재해야합니다 . 그러나 항목이있을 때는 기능이 이미 존재할 필요는 없습니다. 데이터베이스에없는 경우 자동으로 정의됩니다. 설치시 언어를 구현하는 공유 라이브러리를 사용할 수없는 경우 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 가 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a84995528c0ec41b02f477f2f19723fd9aad88c" translate="yes" xml:space="preserve">
          <source>The calling &lt;code&gt;SELECT&lt;/code&gt; statement doesn't necessarily have to be just &lt;code&gt;SELECT *&lt;/code&gt; &amp;mdash; it can reference the output columns by name or join them to other tables. The function produces a virtual table with which you can perform any operation you wish (e.g. aggregation, joining, sorting etc). So we could also have:</source>
          <target state="translated">호출하는 &lt;code&gt;SELECT&lt;/code&gt; 문은 반드시 &lt;code&gt;SELECT *&lt;/code&gt; 일 필요는 없습니다. 이름으로 출력 열을 참조하거나 다른 테이블에 조인 할 수 있습니다. 이 함수는 원하는 모든 작업 (예 : 집계, 조인, 정렬 등)을 수행 할 수있는 가상 테이블을 생성합니다. 그래서 우리는 또한 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="35f5d39131b77dc8ba4b8e8bbcf6ab1ac892db18" translate="yes" xml:space="preserve">
          <source>The capabilities available for administrators to monitor and control the server often change and improve in each major release.</source>
          <target state="translated">관리자가 서버를 모니터링하고 제어 할 수있는 기능은 각 주요 릴리스에서 종종 변경 및 개선됩니다.</target>
        </trans-unit>
        <trans-unit id="dcba21726e373c0ef3c1310c54912c4461e260b5" translate="yes" xml:space="preserve">
          <source>The cascading replication feature allows a standby server to accept replication connections and stream WAL records to other standbys, acting as a relay. This can be used to reduce the number of direct connections to the master and also to minimize inter-site bandwidth overheads.</source>
          <target state="translated">계단식 복제 기능을 통해 대기 서버는 복제 연결을 수락하고 WAL 레코드를 다른 대기로 스트리밍하여 릴레이 역할을합니다. 이를 통해 마스터에 대한 직접 연결 수를 줄이고 사이트 간 대역폭 오버 헤드를 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2414745d3bf9d469e38eb6deaa116aeca4c295eb" translate="yes" xml:space="preserve">
          <source>The cast functions listed in &lt;code&gt;pg_cast&lt;/code&gt; must always take the cast source type as their first argument type, and return the cast destination type as their result type. A cast function can have up to three arguments. The second argument, if present, must be type &lt;code&gt;integer&lt;/code&gt;; it receives the type modifier associated with the destination type, or -1 if there is none. The third argument, if present, must be type &lt;code&gt;boolean&lt;/code&gt;; it receives &lt;code&gt;true&lt;/code&gt; if the cast is an explicit cast, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; 에 나열된 캐스트 함수 는 항상 캐스트 소스 유형을 첫 번째 인수 유형으로 취하고 캐스트 대상 유형을 결과 유형으로 리턴해야합니다. 캐스트 함수는 최대 3 개의 인수를 가질 수 있습니다. 두 번째 인수는 &lt;code&gt;integer&lt;/code&gt; 이어야합니다 . 대상 유형과 관련된 유형 수정자를 받거나없는 경우 -1을받습니다. 존재하는 경우 세 번째 인수는 &lt;code&gt;boolean&lt;/code&gt; 유형이어야합니다 . 그것은 수신 &lt;code&gt;true&lt;/code&gt; 캐스트가 명시 적 캐스트 인 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="fc5f1d64f67b0574d5ae7974d9bf0296a9ac950c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_aggregate&lt;/code&gt; stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. Each entry in &lt;code&gt;pg_aggregate&lt;/code&gt; is an extension of an entry in &lt;code&gt;pg_proc&lt;/code&gt;. The &lt;code&gt;pg_proc&lt;/code&gt; entry carries the aggregate's name, input and output data types, and other information that is similar to ordinary functions.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_aggregate&lt;/code&gt; 는 집계 함수에 대한 정보를 저장합니다. 집계 함수는 값 집합 (일반적으로 쿼리 조건과 일치하는 각 행의 하나의 열)에서 작동하고 이러한 모든 값에서 계산 된 단일 값을 반환하는 함수입니다. 일반적인 집계 함수는 &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 입니다. &lt;code&gt;pg_aggregate&lt;/code&gt; 의 각 항목은 &lt;code&gt;pg_proc&lt;/code&gt; 의 항목 확장입니다 . &lt;code&gt;pg_proc&lt;/code&gt; 의 항목은 집계의 일반 기능과 유사 이름, 입력 및 출력 데이터 유형 및 기타 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a29845311714d7d30ac211e7ed8230388dda9146" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_am&lt;/code&gt; stores information about relation access methods. There is one row for each access method supported by the system. Currently, only tables and indexes have access methods. The requirements for table and index access methods are discussed in detail in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt; respectively.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_am&lt;/code&gt; 은 관계 액세스 방법에 대한 정보를 저장합니다. 시스템이 지원하는 각 액세스 방법마다 하나의 행이 있습니다. 현재 테이블과 인덱스에만 액세스 방법이 있습니다. 테이블 및 인덱스 액세스 방법에 대한 요구 사항은 각각 &lt;a href=&quot;tableam&quot;&gt;60 &lt;/a&gt;&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;장&lt;/a&gt; 및 61 장 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bec1e44f2188ec347a755f0e3375dfd03dbafab" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amop&lt;/code&gt; stores information about operators associated with access method operator families. There is one row for each operator that is a member of an operator family. A family member can be either a &lt;em&gt;search&lt;/em&gt; operator or an &lt;em&gt;ordering&lt;/em&gt; operator. An operator can appear in more than one family, but cannot appear in more than one search position nor more than one ordering position within a family. (It is allowed, though unlikely, for an operator to be used for both search and ordering purposes.)</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_amop&lt;/code&gt; 은 액세스 방법 연산자 제품군과 관련된 연산자에 대한 정보를 저장합니다. 운영자 제품군의 구성원 인 각 운영자마다 하나의 행이 있습니다. 가족 구성원은 &lt;em&gt;검색&lt;/em&gt; 연산자 또는 &lt;em&gt;주문&lt;/em&gt; 연산자 일 수 있습니다. 운영자는 둘 이상의 패밀리에 나타날 수 있지만 패밀리에서 둘 이상의 검색 위치 나 둘 이상의 주문 위치에 나타날 수 없습니다. (아마도 연산자가 검색 및 주문 목적으로 사용될 수는 없습니다.)</target>
        </trans-unit>
        <trans-unit id="7b26f7790ff6d1feb6dfed34e5224303ebaba082" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_amproc&lt;/code&gt; stores information about support functions associated with access method operator families. There is one row for each support function belonging to an operator family.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_amproc&lt;/code&gt; 에는 액세스 방법 연산자 제품군과 관련된 지원 기능에 대한 정보가 저장됩니다. 운영자 제품군에 속하는 각 지원 기능마다 하나의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c43da8c1bc3b1aedcc6d0b4907170e6e551dad" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attrdef&lt;/code&gt; stores column default values. The main information about columns is stored in &lt;a href=&quot;catalog-pg-attribute&quot;&gt;&lt;code&gt;pg_attribute&lt;/code&gt;&lt;/a&gt;. Only columns for which a default value has been explicitly set will have an entry here.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_attrdef&lt;/code&gt; 는 열 기본값을 저장합니다. 열에 대한 주요 정보는 &lt;a href=&quot;catalog-pg-attribute&quot;&gt; &lt;code&gt;pg_attribute&lt;/code&gt; 에&lt;/a&gt; 저장됩니다 . 기본값이 명시 적으로 설정된 열만 여기에 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="418f63e0244ab894621f6561175c2bc70b572229" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_attribute&lt;/code&gt; stores information about table columns. There will be exactly one &lt;code&gt;pg_attribute&lt;/code&gt; row for every column in every table in the database. (There will also be attribute entries for indexes, and indeed all objects that have &lt;code&gt;pg_class&lt;/code&gt; entries.)</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_attribute&lt;/code&gt; 는 테이블 열에 대한 정보를 저장합니다. 데이터베이스의 모든 테이블에있는 모든 열에 &lt;code&gt;pg_attribute&lt;/code&gt; 정확히 하나의 pg_attribute 행이 있습니다. (색인에 대한 속성 항목과 실제로 &lt;code&gt;pg_class&lt;/code&gt; 항목 이있는 모든 객체도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="85bbce99b3a9fdd7e277ae10030b9970f56238bf" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_auth_members&lt;/code&gt; shows the membership relations between roles. Any non-circular set of relationships is allowed.</source>
          <target state="translated">&lt;code&gt;pg_auth_members&lt;/code&gt; 카탈로그 는 역할 간의 구성원 관계를 보여줍니다. 비 원형 관계 집합이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8154dc7e56592f09e48c6280c85b2550f6de4fa" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_authid&lt;/code&gt; contains information about database authorization identifiers (roles). A role subsumes the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo;. A user is essentially just a role with the &lt;code&gt;rolcanlogin&lt;/code&gt; flag set. Any role (with or without &lt;code&gt;rolcanlogin&lt;/code&gt;) can have other roles as members; see &lt;a href=&quot;catalog-pg-auth-members&quot;&gt;&lt;code&gt;pg_auth_members&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_authid&lt;/code&gt; 카탈로그 에는 데이터베이스 권한 부여 식별자 (역할)에 대한 정보가 포함되어 있습니다. 역할은 &quot;사용자&quot;및 &quot;그룹&quot;의 개념을 가정합니다. 사용자는 본질적으로 &lt;code&gt;rolcanlogin&lt;/code&gt; 플래그가 설정된 역할입니다 . &lt;code&gt;rolcanlogin&lt;/code&gt; 의 유무에 관계 없이 모든 역할은 회원으로서 다른 역할을 할 수 있습니다. &lt;a href=&quot;catalog-pg-auth-members&quot;&gt; &lt;code&gt;pg_auth_members&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec983a869f6c2ea34ce8826bbeff462247f967af" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_cast&lt;/code&gt; stores data type conversion paths, both built-in and user-defined.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_cast&lt;/code&gt; 는 내장 및 사용자 정의 데이터 유형 변환 경로를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9d04631bf68325b8525e49c943e731abe3613af7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_class&lt;/code&gt; catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (but see also &lt;code&gt;pg_index&lt;/code&gt;), sequences (but see also &lt;code&gt;pg_sequence&lt;/code&gt;), views, materialized views, composite types, and TOAST tables; see &lt;code&gt;relkind&lt;/code&gt;. Below, when we mean all of these kinds of objects we speak of &amp;ldquo;relations&amp;rdquo;. Not all columns are meaningful for all relation types.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_class&lt;/code&gt; 는 테이블과 열이 있거나 테이블과 유사한 대부분의 테이블을 카탈로그합니다. 여기에는 인덱스 ( &lt;code&gt;pg_index&lt;/code&gt; 참조 ), 시퀀스 ( &lt;code&gt;pg_sequence&lt;/code&gt; 참조 ), 뷰, 구체화 된 뷰, 복합 유형 및 TOAST 테이블이 포함됩니다. &lt;code&gt;relkind&lt;/code&gt; 참조하십시오 . 아래에서 이러한 모든 종류의 대상을 의미 할 때&amp;ldquo;관계&amp;rdquo;라고 말합니다. 모든 열이 모든 관계 유형에 의미있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ce60dbecc80ee8b02722d2865bea98e5166433a6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_collation&lt;/code&gt; describes the available collations, which are essentially mappings from an SQL name to operating system locale categories. See &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_collation&lt;/code&gt; 은 사용 가능한 데이터 정렬을 설명하며, 기본적으로 SQL 이름에서 운영 체제 로캘 범주로 매핑됩니다. 자세한 내용 &lt;a href=&quot;collation&quot;&gt;은 23.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b24facc60ba613b096ec1ffd9828eff85b641f58" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_constraint&lt;/code&gt; stores check, primary key, unique, foreign key, and exclusion constraints on tables. (Column constraints are not treated specially. Every column constraint is equivalent to some table constraint.) Not-null constraints are represented in the &lt;code&gt;pg_attribute&lt;/code&gt; catalog, not here.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_constraint&lt;/code&gt; 는 검사, 기본 키, 고유, 외래 키 및 제외 제약 조건을 테이블에 저장합니다. (컬럼 제약 조건은 특별히 처리되지 않습니다. 모든 컬럼 제약 조건은 일부 테이블 제약 조건과 동일합니다.) null이 아닌 제약 조건은 여기가 아닌 &lt;code&gt;pg_attribute&lt;/code&gt; 카탈로그에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1be34b922edf24e062d7f1ae068ab828f281a75" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_conversion&lt;/code&gt; describes encoding conversion functions. See &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_conversion&lt;/code&gt; 카탈로그 는 인코딩 변환 함수를 설명합니다. 자세한 내용은 &lt;a href=&quot;sql-createconversion&quot;&gt;CREATE CONVERSION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fa266de7304c33b5491fba7214040981ff64d51" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_database&lt;/code&gt; stores information about the available databases. Databases are created with the &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for details about the meaning of some of the parameters.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_database&lt;/code&gt; 는 사용 가능한 데이터베이스에 대한 정보를 저장합니다. 데이터베이스는 &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; 명령 으로 작성됩니다 . 일부 매개 변수의 의미에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;22 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eca146c013dcb962be7fbc89316ecc63d19d2b8" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_db_role_setting&lt;/code&gt; records the default values that have been set for run-time configuration variables, for each role and database combination.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_db_role_setting&lt;/code&gt; 은 각 역할 및 데이터베이스 조합에 대해 런타임 구성 변수에 설정된 기본값을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e6bd2b6528e4d970391e533c9ea2086c3fe18fc0" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_default_acl&lt;/code&gt; stores initial privileges to be assigned to newly created objects.</source>
          <target state="translated">&lt;code&gt;pg_default_acl&lt;/code&gt; 카탈로그 는 새로 생성 된 객체에 할당 할 초기 권한을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="fa08d6f7153471b38ae0793d338ba6ab5b3ad0bd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_depend&lt;/code&gt; records the dependency relationships between database objects. This information allows &lt;code&gt;DROP&lt;/code&gt; commands to find which other objects must be dropped by &lt;code&gt;DROP CASCADE&lt;/code&gt; or prevent dropping in the &lt;code&gt;DROP RESTRICT&lt;/code&gt; case.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_depend&lt;/code&gt; 는 데이터베이스 객체 간의 종속성 관계를 기록합니다. 이 정보를 통해 &lt;code&gt;DROP&lt;/code&gt; 명령은 &lt;code&gt;DROP CASCADE&lt;/code&gt; 로 삭제해야하는 다른 오브젝트를 찾 거나 &lt;code&gt;DROP RESTRICT&lt;/code&gt; 케이스 에서 삭제를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef59984dd4696772f2e8a7bbf2dcc9de1f2f041a" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_description&lt;/code&gt; stores optional descriptions (comments) for each database object. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands. Descriptions of many built-in system objects are provided in the initial contents of &lt;code&gt;pg_description&lt;/code&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_description&lt;/code&gt; 은 각 데이터베이스 객체에 대한 선택적 설명 (설명)을 저장합니다. 설명은 &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; 명령 으로 조작하고 psql의 &lt;code&gt;\d&lt;/code&gt; 명령으로 볼 수 있습니다 . 많은 내장 시스템 객체에 대한 설명은 &lt;code&gt;pg_description&lt;/code&gt; 의 초기 내용에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f9198ecc665eb9bf0a1925898c8388b6df71db7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_event_trigger&lt;/code&gt; stores event triggers. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;Chapter 39&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_event_trigger&lt;/code&gt; 는 이벤트 트리거를 저장합니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/event-triggers.html&quot;&gt;39 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08e240a6b04efec03e383c5c2cbf6a0f5343f115" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_extension&lt;/code&gt; stores information about the installed extensions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for details about extensions.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_extension&lt;/code&gt; 은 설치된 확장에 대한 정보를 저장합니다. 확장에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;섹션 37.17&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60ec179e1854cef6ef5b48336a3d0be1aebd94a3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; stores foreign-data wrapper definitions. A foreign-data wrapper is the mechanism by which external data, residing on foreign servers, is accessed.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_foreign_data_wrapper&lt;/code&gt; 는 외부 데이터 래퍼 정의를 저장합니다. 외부 데이터 래퍼는 외부 서버에있는 외부 데이터에 액세스하는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="14e59b5f4fd68c0de1f4d9757cb9140d56e66bca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_server&lt;/code&gt; stores foreign server definitions. A foreign server describes a source of external data, such as a remote server. Foreign servers are accessed via foreign-data wrappers.</source>
          <target state="translated">&lt;code&gt;pg_foreign_server&lt;/code&gt; 카탈로그 는 외부 서버 정의를 저장합니다. 외부 서버는 원격 서버와 같은 외부 데이터 소스를 설명합니다. 외부 서버는 외부 데이터 랩퍼를 통해 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="51d82ed7d4c3db5d6e6e20d733bd83d0fb2db31f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_foreign_table&lt;/code&gt; contains auxiliary information about foreign tables. A foreign table is primarily represented by a &lt;code&gt;pg_class&lt;/code&gt; entry, just like a regular table. Its &lt;code&gt;pg_foreign_table&lt;/code&gt; entry contains the information that is pertinent only to foreign tables and not any other kind of relation.</source>
          <target state="translated">&lt;code&gt;pg_foreign_table&lt;/code&gt; 카탈로그 에는 외부 테이블에 대한 보조 정보가 포함되어 있습니다. 외래 테이블은 주로 일반 테이블과 마찬가지로 &lt;code&gt;pg_class&lt;/code&gt; 항목 으로 표시됩니다 . 그 &lt;code&gt;pg_foreign_table&lt;/code&gt; 항목은 관계의 다른 종류의 외국 테이블이 아닌 타당한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="775fb259c9b9e32be3ed5d81afd596a58bfd39dd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_index&lt;/code&gt; contains part of the information about indexes. The rest is mostly in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_index&lt;/code&gt; 카탈로그 에는 인덱스 정보의 일부가 포함되어 있습니다. 나머지는 대부분 &lt;code&gt;pg_class&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a623a0b18b2ebaf8e83d5ac1d0d6cf3474af033" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_inherits&lt;/code&gt; records information about table inheritance hierarchies. There is one entry for each direct parent-child table relationship in the database. (Indirect inheritance can be determined by following chains of entries.)</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_inherits&lt;/code&gt; 는 테이블 상속 계층에 대한 정보를 기록합니다. 데이터베이스에는 직계 상위-하위 테이블 관계마다 하나의 항목이 있습니다. (간접 상속은 다음 항목 체인에 의해 결정될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3ef3657b35ed0b4f238ec5987d2edc24285c1ce6" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_init_privs&lt;/code&gt; records information about the initial privileges of objects in the system. There is one entry for each object in the database which has a non-default (non-NULL) initial set of privileges.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_init_privs&lt;/code&gt; 는 시스템에서 객체의 초기 권한에 대한 정보를 기록합니다. 기본이 아닌 (NULL이 아닌) 초기 권한 세트를 갖는 데이터베이스의 각 오브젝트에 대해 하나의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aed131707c511022c9597a108a69123aaaa06b71" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_language&lt;/code&gt; registers languages in which you can write functions or stored procedures. See &lt;a href=&quot;sql-createlanguage&quot;&gt;CREATE LANGUAGE&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;Chapter 41&lt;/a&gt; for more information about language handlers.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_language&lt;/code&gt; 는 함수 나 저장 프로 시저를 작성할 수있는 언어를 등록합니다. 참조 &lt;a href=&quot;sql-createlanguage&quot;&gt;언어 CREATE&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xplang.html&quot;&gt;제 41&lt;/a&gt; 언어 처리기에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="bc853ae6dcab566bb8d51b6c3df6a48ca149be41" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject&lt;/code&gt; holds the data making up &amp;ldquo;large objects&amp;rdquo;. A large object is identified by an OID assigned when it is created. Each large object is broken into segments or &amp;ldquo;pages&amp;rdquo; small enough to be conveniently stored as rows in &lt;code&gt;pg_largeobject&lt;/code&gt;. The amount of data per page is defined to be &lt;code&gt;LOBLKSIZE&lt;/code&gt; (which is currently &lt;code&gt;BLCKSZ/4&lt;/code&gt;, or typically 2 kB).</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_largeobject&lt;/code&gt; 는&amp;ldquo;큰 객체&amp;rdquo;를 구성하는 데이터를 보유합니다. 큰 객체는 생성 될 때 할당 된 OID로 식별됩니다. 각각의 큰 객체는 &lt;code&gt;pg_largeobject&lt;/code&gt; 에 행으로 편리하게 저장 될 수있을 정도로 작은 세그먼트 또는 &quot;페이지&quot;로 나뉩니다 . 페이지 당 데이터 양은 &lt;code&gt;LOBLKSIZE&lt;/code&gt; (현재 &lt;code&gt;BLCKSZ/4&lt;/code&gt; 또는 일반적으로 2kB )로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="637a0fff02f805fcd7f6572b41b759dc3d88c524" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; holds metadata associated with large objects. The actual large object data is stored in &lt;a href=&quot;catalog-pg-largeobject&quot;&gt;&lt;code&gt;pg_largeobject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; 는 큰 객체와 관련된 메타 데이터를 보유합니다. 실제 큰 객체 데이터는 &lt;a href=&quot;catalog-pg-largeobject&quot;&gt; &lt;code&gt;pg_largeobject&lt;/code&gt; 에&lt;/a&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1da9fb341c1eb2b89353bf65057bd43bdb97a022" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_namespace&lt;/code&gt; stores namespaces. A namespace is the structure underlying SQL schemas: each namespace can have a separate collection of relations, types, etc. without name conflicts.</source>
          <target state="translated">&lt;code&gt;pg_namespace&lt;/code&gt; 카탈로그 는 네임 스페이스를 저장합니다. 네임 스페이스는 SQL 스키마의 기본 구조입니다. 각 네임 스페이스는 이름 충돌없이 별도의 관계, 유형 등을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e7a372d092106d4f08f9fcd3ea02828fcaa191" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opclass&lt;/code&gt; defines index access method operator classes. Each operator class defines semantics for index columns of a particular data type and a particular index access method. An operator class essentially specifies that a particular operator family is applicable to a particular indexable column data type. The set of operators from the family that are actually usable with the indexed column are whichever ones accept the column's data type as their left-hand input.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_opclass&lt;/code&gt; 는 인덱스 액세스 메소드 연산자 클래스를 정의합니다. 각 연산자 클래스는 특정 데이터 유형의 인덱스 열 및 특정 인덱스 액세스 방법에 대한 의미를 정의합니다. 연산자 클래스는 기본적으로 특정 연산자 제품군이 특정 색인 가능한 열 데이터 유형에 적용 가능하도록 지정합니다. 인덱싱 된 열과 실제로 사용할 수있는 제품군의 연산자 집합은 열의 데이터 형식을 왼쪽 입력으로 받아들이는 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="c87fca68633fb63db57e86d79fac7ce1b22101ea" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_operator&lt;/code&gt; stores information about operators. See &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_operator&lt;/code&gt; 는 연산자에 대한 정보를 저장합니다. 자세한 정보는 &lt;a href=&quot;sql-createoperator&quot;&gt;CREATE OPERATOR&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;섹션 37.14&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3fdeed75aa3ce97ce3c38ef12f91f3c508c158" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_opfamily&lt;/code&gt; defines operator families. Each operator family is a collection of operators and associated support routines that implement the semantics specified for a particular index access method. Furthermore, the operators in a family are all &amp;ldquo;compatible&amp;rdquo;, in a way that is specified by the access method. The operator family concept allows cross-data-type operators to be used with indexes and to be reasoned about using knowledge of access method semantics.</source>
          <target state="translated">&lt;code&gt;pg_opfamily&lt;/code&gt; 카탈로그 는 운영자 제품군을 정의합니다. 각 운영자 제품군은 특정 색인 액세스 방법에 지정된 의미론을 구현하는 운영자 및 관련 지원 루틴의 모음입니다. 또한, 패밀리의 운영자는 액세스 방법으로 지정된 방식으로 모두 &quot;호환&quot;됩니다. 연산자 계열 개념을 사용하면 교차 데이터 유형 연산자를 색인과 함께 사용하고 액세스 방법 시맨틱 지식을 사용하는 것에 대해 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f9d81d5db57fdf3722685cee5c72c0b7b266b01" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_partitioned_table&lt;/code&gt; stores information about how tables are partitioned.</source>
          <target state="translated">&lt;code&gt;pg_partitioned_table&lt;/code&gt; 카탈로그 는 테이블이 분할되는 방법에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="c4598dc8a02ea46018473ad3a155097abd3c7904" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_pltemplate&lt;/code&gt; stores &amp;ldquo;template&amp;rdquo; information for procedural languages. A template for a language allows the language to be created in a particular database by a simple &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command, with no need to specify implementation details.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; 카탈로그 는 절차 언어에 대한 &quot;템플릿&quot;정보를 저장합니다. 언어 템플릿을 사용하면 구현 세부 정보를 지정할 필요없이 간단한 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; 명령 으로 특정 데이터베이스에서 언어를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38521eab8f4daa25e1c972502335611e746aa47f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_policy&lt;/code&gt; stores row level security policies for tables. A policy includes the kind of command that it applies to (possibly all commands), the roles that it applies to, the expression to be added as a security-barrier qualification to queries that include the table, and the expression to be added as a &lt;code&gt;WITH CHECK&lt;/code&gt; option for queries that attempt to add new records to the table.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_policy&lt;/code&gt; 는 테이블에 대한 행 레벨 보안 정책을 저장합니다. 정책에는 적용되는 명령 종류 (아마도 모든 명령), 적용되는 역할, 테이블을 포함하는 쿼리에 보안 장벽 자격으로 추가 될 식 및 테이블에 새 레코드를 추가하려는 쿼리의 경우 &lt;code&gt;WITH CHECK&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="077da08d3639d4de1fea458f7cc6d9c77756beb9" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_proc&lt;/code&gt; stores information about functions, procedures, aggregate functions, and window functions (collectively also known as routines). See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;, &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_proc&lt;/code&gt; 는 함수, 프로 시저, 집계 함수 및 창 함수 (통칭 적으로 루틴이라고도 함)에 대한 정보를 저장합니다. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; , &lt;a href=&quot;sql-createprocedure&quot;&gt;CREATE PROCEDURE&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;37.3 단원&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bfdad63a7f3f3f55487cbe48d50b5126f2fe14c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication&lt;/code&gt; contains all publications created in the database. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_publication&lt;/code&gt; 카탈로그 에는 데이터베이스에서 작성된 모든 발행물이 포함됩니다. 출판물에 대한 자세한 내용 &lt;a href=&quot;logical-replication-publication&quot;&gt;은 30.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="221d9ab9d81b22114af5be8f658f635812a98821" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_publication_rel&lt;/code&gt; contains the mapping between relations and publications in the database. This is a many-to-many mapping. See also &lt;a href=&quot;view-pg-publication-tables&quot;&gt;Section 51.79&lt;/a&gt; for a more user-friendly view of this information.</source>
          <target state="translated">&lt;code&gt;pg_publication_rel&lt;/code&gt; 카탈로그 에는 데이터베이스의 관계와 발행물 간의 맵핑이 포함됩니다. 이것은 다 대다 매핑입니다. 이 정보에 대한보다 사용자 친화적 인 정보 는 &lt;a href=&quot;view-pg-publication-tables&quot;&gt;섹션 51.79&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52875f38f647bef6fb760c4d6882bec8ce49439c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_range&lt;/code&gt; stores information about range types. This is in addition to the types' entries in &lt;a href=&quot;catalog-pg-type&quot;&gt;&lt;code&gt;pg_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_range&lt;/code&gt; 는 범위 유형에 대한 정보를 저장합니다. 이것은 &lt;a href=&quot;catalog-pg-type&quot;&gt; &lt;code&gt;pg_type&lt;/code&gt; &lt;/a&gt; 의 유형 항목에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc31d507f60721e880a15f8324203d061317541c" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_rewrite&lt;/code&gt; stores rewrite rules for tables and views.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_rewrite&lt;/code&gt; 는 테이블 및 뷰에 대한 다시 쓰기 규칙을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="743cf387d8af7cd433c0ab8fa075de457723d7d5" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_seclabel&lt;/code&gt; stores security labels on database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_seclabel&lt;/code&gt; 은 데이터베이스 오브젝트에 보안 레이블을 저장합니다. &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; 명령으로 보안 레이블을 조작 할 수 있습니다 . 보안 레이블을보다 쉽게 ​​볼 수있는 방법은 &lt;a href=&quot;view-pg-seclabels&quot;&gt;섹션 51.84를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06336f290aa5f875fbaac3ca8b83cb8674898645" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_sequence&lt;/code&gt; contains information about sequences. Some of the information about sequences, such as the name and the schema, is in &lt;code&gt;pg_class&lt;/code&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_sequence&lt;/code&gt; 는 시퀀스에 대한 정보를 포함합니다. 이름 및 스키마와 같은 시퀀스에 대한 일부 정보는 &lt;code&gt;pg_class&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="98aafe9d92bd83fff00a553e40adb49ebd9fb0ff" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdepend&lt;/code&gt; records the dependency relationships between database objects and shared objects, such as roles. This information allows PostgreSQL to ensure that those objects are unreferenced before attempting to delete them.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_shdepend&lt;/code&gt; 는 데이터베이스 객체와 역할과 같은 공유 객체 간의 종속성 관계를 기록합니다. 이 정보를 통해 PostgreSQL은 해당 객체를 삭제하기 전에 해당 객체가 참조 해제되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="707a904a0a65e47118a70277c90bf66e00682ea7" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shdescription&lt;/code&gt; stores optional descriptions (comments) for shared database objects. Descriptions can be manipulated with the &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; command and viewed with psql's &lt;code&gt;\d&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;pg_shdescription&lt;/code&gt; 카탈로그 는 공유 데이터베이스 객체에 대한 선택적 설명 (설명)을 저장합니다. 설명은 &lt;a href=&quot;sql-comment&quot;&gt;COMMENT&lt;/a&gt; 명령 으로 조작하고 psql의 &lt;code&gt;\d&lt;/code&gt; 명령으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1cad576af7b20a74691e7e84a0abf3918f82ca" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_shseclabel&lt;/code&gt; stores security labels on shared database objects. Security labels can be manipulated with the &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; command. For an easier way to view security labels, see &lt;a href=&quot;view-pg-seclabels&quot;&gt;Section 51.84&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shseclabel&lt;/code&gt; 카탈로그 는 공유 데이터베이스 오브젝트에 보안 레이블을 저장합니다. &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; 명령으로 보안 레이블을 조작 할 수 있습니다 . 보안 레이블을보다 쉽게 ​​볼 수있는 방법은 &lt;a href=&quot;view-pg-seclabels&quot;&gt;섹션 51.84를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d95048be51e3aac388b17358a36c3017066f7afd" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic&lt;/code&gt; stores statistical data about the contents of the database. Entries are created by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; and subsequently used by the query planner. Note that all the statistical data is inherently approximate, even assuming that it is up-to-date.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_statistic&lt;/code&gt; 은 데이터베이스 내용에 대한 통계 데이터를 저장합니다. &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE에&lt;/a&gt; 의해 항목이 작성되고 이후에 쿼리 플래너가 사용합니다. 모든 통계 데이터는 최신이라고 가정하더라도 본질적으로 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="1a788b199242747f1e3ab3d464f7f212c88021b3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext&lt;/code&gt; holds definitions of extended planner statistics. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic_ext&lt;/code&gt; 카탈로그 는 확장 플래너 통계의 정의를 보유합니다. 이 카탈로그의 각 행은 &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS로&lt;/a&gt; 작성된 &lt;em&gt;통계 오브젝트에&lt;/em&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="efd7c967165399ed5a01a4ab9407cb379c75802f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; holds data for extended planner statistics defined in &lt;code&gt;pg_statistic_ext&lt;/code&gt;. Each row in this catalog corresponds to a &lt;em&gt;statistics object&lt;/em&gt; created with &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS&lt;/a&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; 는 에 정의 된 확장 계획 통계에 대한 데이터를 보유하고 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 를 . 이 카탈로그의 각 행은 &lt;a href=&quot;sql-createstatistics&quot;&gt;CREATE STATISTICS로&lt;/a&gt; 작성된 &lt;em&gt;통계 오브젝트에&lt;/em&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c35fed25fc50b397d0a14fb9dcbeb17e75e6fe0f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription&lt;/code&gt; contains all existing logical replication subscriptions. For more information about logical replication see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_subscription&lt;/code&gt; 에는 기존의 모든 논리적 복제 구독이 포함됩니다. 논리적 복제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cdf4cde86fcb864fb5af90b023119fc34f2142d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_subscription_rel&lt;/code&gt; contains the state for each replicated relation in each subscription. This is a many-to-many mapping.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_subscription_rel&lt;/code&gt; 에는 각 구독에서 복제 된 각 관계의 상태가 포함됩니다. 이것은 다 대다 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="c447f5488ab316d33bbd3ebcf5f5d8b7c31ae85d" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_tablespace&lt;/code&gt; stores information about the available tablespaces. Tables can be placed in particular tablespaces to aid administration of disk layout.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_tablespace&lt;/code&gt; 는 사용 가능한 테이블 스페이스에 대한 정보를 저장합니다. 디스크 레이아웃 관리를 돕기 위해 테이블을 특정 테이블 스페이스에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd8fed96cb099d0e2d39d4d04e6e7c47d74045e" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_transform&lt;/code&gt; stores information about transforms, which are a mechanism to adapt data types to procedural languages. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_transform&lt;/code&gt; 은 변환에 대한 정보를 저장하는데, 이는 데이터 유형을 절차 언어에 적응시키는 메커니즘입니다. 자세한 정보는 &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75ce3dfcf04f9d1f1bc6bfe6a8a43c82175b0a72" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_trigger&lt;/code&gt; stores triggers on tables and views. See &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; for more information.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_trigger&lt;/code&gt; 는 테이블 및 뷰에 트리거를 저장합니다. 자세한 내용은 &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="392fc6d5e6430c985734db6f435318b9f05a7dd3" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_type&lt;/code&gt; stores information about data types. Base types and enum types (scalar types) are created with &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;, and domains with &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. A composite type is automatically created for each table in the database, to represent the row structure of the table. It is also possible to create composite types with &lt;code&gt;CREATE TYPE AS&lt;/code&gt;.</source>
          <target state="translated">카탈로그 &lt;code&gt;pg_type&lt;/code&gt; 은 데이터 유형에 대한 정보를 저장합니다. 기본 유형 및 열거 형 유형 (스칼라 유형)은 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 으로 작성 되고 도메인은 &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN으로 작성&lt;/a&gt; 됩니다. 데이터베이스의 각 테이블에 대해 복합 유형이 자동으로 작성되어 테이블의 행 구조를 나타냅니다. &lt;code&gt;CREATE TYPE AS&lt;/code&gt; 를 사용하여 복합 유형을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bc1e303fc4f7bb28411737b0ff9561def41771f" translate="yes" xml:space="preserve">
          <source>The catalog &lt;code&gt;pg_user_mapping&lt;/code&gt; stores the mappings from local user to remote. Access to this catalog is restricted from normal users, use the view &lt;a href=&quot;view-pg-user-mappings&quot;&gt;&lt;code&gt;pg_user_mappings&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;pg_user_mapping&lt;/code&gt; 카탈로그 는 로컬 사용자에서 원격으로의 맵핑을 저장합니다. 이 카탈로그에 대한 액세스는 일반 사용자로부터 제한 됩니다. 대신 &lt;a href=&quot;view-pg-user-mappings&quot;&gt; &lt;code&gt;pg_user_mappings&lt;/code&gt; &lt;/a&gt; 보기를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60a544b25f1cc2eef0830902b29eb1826d7423c5" translate="yes" xml:space="preserve">
          <source>The category code (a single ASCII character) for this type. The default is &lt;code&gt;'U'&lt;/code&gt; for &amp;ldquo;user-defined type&amp;rdquo;. Other standard category codes can be found in &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;. You may also choose other ASCII characters in order to create custom categories.</source>
          <target state="translated">이 유형의 카테고리 코드 (단일 ASCII 문자)입니다. &quot;사용자 정의 유형&quot; 의 기본값은 &lt;code&gt;'U'&lt;/code&gt; 입니다. 다른 표준 범주 코드는 &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;표 51.64&lt;/a&gt; 에 나와 있습니다 . 사용자 정의 범주를 만들기 위해 다른 ASCII 문자를 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0699308172a4d35d3852cf096bcc7cdc0d6fc5" translate="yes" xml:space="preserve">
          <source>The category names translate into names of &lt;code&gt;initdb&lt;/code&gt; options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt;.</source>
          <target state="translated">카테고리 이름 은 특정 카테고리에 대한 로케일 선택을 대체하기 위해 &lt;code&gt;initdb&lt;/code&gt; 옵션 의 이름으로 변환됩니다 . 예를 들어, 로케일을 프랑스어로 설정하고 통화 형식화에 미국 규칙을 사용하려면 &lt;code&gt;initdb --locale=fr_CA --lc-monetary=en_US&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90aadd1f991be6c6a59649f2cf2279a49d630988" translate="yes" xml:space="preserve">
          <source>The century</source>
          <target state="translated">세기</target>
        </trans-unit>
        <trans-unit id="64714127e62379960f8b9dabad3b7dd16b967248" translate="yes" xml:space="preserve">
          <source>The character set encoding specified for the new database must be compatible with the chosen locale settings (&lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;). If the locale is &lt;code&gt;C&lt;/code&gt; (or equivalently &lt;code&gt;POSIX&lt;/code&gt;), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; will allow superusers to specify &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.</source>
          <target state="translated">새 데이터베이스에 지정된 문자 세트 인코딩은 선택한 로케일 설정 ( &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; ) 과 호환되어야합니다 . 로케일이 &lt;code&gt;C&lt;/code&gt; (또는 동등하게 &lt;code&gt;POSIX&lt;/code&gt; )이면 모든 인코딩이 허용되지만 다른 로케일 설정의 경우 제대로 작동하는 인코딩이 하나만 있습니다. (그러나 Windows에서는 UTF-8 인코딩을 모든 로케일과 함께 사용할 수 있습니다.) &lt;code&gt;CREATE DATABASE&lt;/code&gt; 를 사용 하면 로케일 설정에 관계없이 수퍼 유저가 &lt;code&gt;SQL_ASCII&lt;/code&gt; 인코딩 을 지정할 수 있지만이 선택은 더 이상 사용되지 않으며 데이터의 경우 문자열 기능의 오작동을 초래할 수 있습니다 로케일과 인코딩 호환되지 않는 데이터베이스에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="89d6fa6368565c20d96f1143f8a41b5bdded6f20" translate="yes" xml:space="preserve">
          <source>The character set support in PostgreSQL allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as EUC (Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your PostgreSQL database cluster using &lt;code&gt;initdb&lt;/code&gt;. It can be overridden when you create a database, so you can have multiple databases each with a different character set.</source>
          <target state="translated">PostgreSQL의 문자 세트 지원을 통해 ISO 8859 시리즈와 같은 1 바이트 문자 세트와 EUC (Extended Unix Code)와 같은 다중 바이트 문자 세트를 포함하여 다양한 문자 세트 (인코딩이라고도 함)에 텍스트를 저장할 수 있습니다. UTF-8 및 Mule 내부 코드 지원되는 모든 문자 세트는 클라이언트가 투명하게 사용할 수 있지만 일부는 서버 내에서 (서버 측 인코딩으로) 사용할 수 없습니다. 기본 문자 세트는 &lt;code&gt;initdb&lt;/code&gt; 를 사용하여 PostgreSQL 데이터베이스 클러스터를 초기화하는 동안 선택 됩니다 . 데이터베이스를 작성할 때이를 대체 할 수 있으므로 각각 다른 문자 세트를 가진 여러 데이터베이스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97fdcbffdcc8da09aa147a46393111714ca188e7" translate="yes" xml:space="preserve">
          <source>The character with the code zero cannot be in a string constant.</source>
          <target state="translated">코드가 0 인 문자는 문자열 상수에있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c743222d29807902173d80c9ab0c69944ad07be" translate="yes" xml:space="preserve">
          <source>The character with the indicated octal code is substituted.</source>
          <target state="translated">표시된 8 진수 코드가있는 문자가 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9883df04aca064376efa049e7f1ac203fe46e46b" translate="yes" xml:space="preserve">
          <source>The character-entry escapes are always taken as ordinary characters. For example, &lt;code&gt;\135&lt;/code&gt; is &lt;code&gt;]&lt;/code&gt; in ASCII, but &lt;code&gt;\135&lt;/code&gt; does not terminate a bracket expression.</source>
          <target state="translated">문자 입력 이스케이프는 항상 일반 문자로 간주됩니다. 예를 들어, &lt;code&gt;\135&lt;/code&gt; 는 ASCII 로 &lt;code&gt;]&lt;/code&gt; 이지만 &lt;code&gt;\135&lt;/code&gt; 는 대괄호 표현식을 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef0e78b53fce5d8f9142725e8e0f3c5fa09a015f" translate="yes" xml:space="preserve">
          <source>The checkpoint requirement of flushing all dirty data pages to disk can cause a significant I/O load. For this reason, checkpoint activity is throttled so that I/O begins at checkpoint start and completes before the next checkpoint is due to start; this minimizes performance degradation during checkpoints.</source>
          <target state="translated">모든 더티 데이터 페이지를 디스크로 플러시해야하는 검사 점 요구 사항으로 인해 상당한 I / O로드가 발생할 수 있습니다. 이러한 이유로, 체크 포인트 활동은 스로틀되어 I / O는 체크 포인트 시작에서 시작하여 다음 체크 포인트가 시작되기 전에 완료됩니다. 이것은 체크 포인트 동안 성능 저하를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="aea1ec4dfdbf684f4c49444bdb751e65ee9f5e89" translate="yes" xml:space="preserve">
          <source>The checksum computed with this function can be compared with the &lt;code&gt;checksum&lt;/code&gt; result field of the function &lt;code&gt;page_header&lt;/code&gt;. If data checksums are enabled for this instance, then the two values should be equal.</source>
          <target state="translated">이 함수로 계산 된 체크섬을 &lt;code&gt;page_header&lt;/code&gt; 함수 의 &lt;code&gt;checksum&lt;/code&gt; 결과 필드 와 비교할 수 있습니다 . 이 인스턴스에 대해 데이터 체크섬이 활성화 된 경우 두 값이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="12cbfddc1d2244a2eb37d3e1009dc9d4f7140abc" translate="yes" xml:space="preserve">
          <source>The choice between GiST and GIN indexing depends on the relative performance characteristics of GiST and GIN, which are discussed elsewhere.</source>
          <target state="translated">GiST와 GIN 색인 사이의 선택은 다른 곳에서 논의되는 GiST와 GIN의 상대적인 성능 특성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3567ccb40f1481d219e5951c92fe9f650cc7303e" translate="yes" xml:space="preserve">
          <source>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the &lt;code&gt;cursor_to_xml&lt;/code&gt; function if the result values are to be reassembled into one document later on. The functions for producing XML content discussed above, in particular &lt;code&gt;xmlelement&lt;/code&gt;, can be used to alter the results to taste.</source>
          <target state="translated">이 형식 중에서 선택하는 것은 사용자의 책임입니다. 첫 번째 형식은 적절한 XML 문서이며 많은 응용 프로그램에서 중요합니다. 결과 값을 나중에 하나의 문서로 다시 어셈블 할 경우 &lt;code&gt;cursor_to_xml&lt;/code&gt; 함수 에서 두 번째 형식이 더 유용합니다 . 위에서 논의한 XML 컨텐츠, 특히 &lt;code&gt;xmlelement&lt;/code&gt; 를 생성하는 함수를 사용하여 결과를 맛볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fcd6e12232fcafb17e4f9eed475f29ab9c942d0" translate="yes" xml:space="preserve">
          <source>The choice of how to partition a table should be made carefully as the performance of query planning and execution can be negatively affected by poor design.</source>
          <target state="translated">쿼리 계획 및 실행 성능이 열악한 디자인으로 인해 부정적인 영향을받을 수 있으므로 테이블을 분할하는 방법을 신중하게 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="eba68582494f00f7d7461ffee77aebc9a862ba45" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;CACHE cache&lt;/code&gt; enables sequence numbers to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache). If unspecified, the old cache value will be maintained.</source>
          <target state="translated">&lt;code&gt;CACHE cache&lt;/code&gt; 절을 사용하면 시퀀스 번호를 미리 할당하고 메모리에 저장하여 더 빠르게 액세스 할 수 있습니다. 최소값은 1입니다 (한 번에 하나의 값만 생성 할 수 있습니다 (즉, 캐시 없음)). 지정하지 않으면 이전 캐시 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="75a69760c05706a624428c520aa62a2819be2cc8" translate="yes" xml:space="preserve">
          <source>The clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; is optional. A positive value will make an ascending sequence, a negative one a descending sequence. If unspecified, the old increment value will be maintained.</source>
          <target state="translated">&lt;code&gt;INCREMENT BY increment&lt;/code&gt; 절 은 선택 사항입니다. 양수 값은 오름차순, 음수는 내림차순을 만듭니다. 지정하지 않으면 이전 증분 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="867e5349b79e57e50c69654c14c2d9c684ca93bc" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;ALWAYS&lt;/code&gt; and &lt;code&gt;BY DEFAULT&lt;/code&gt; determine how the sequence value is given precedence over a user-specified value in an &lt;code&gt;INSERT&lt;/code&gt; statement. If &lt;code&gt;ALWAYS&lt;/code&gt; is specified, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is specified, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">&lt;code&gt;ALWAYS&lt;/code&gt; 및 &lt;code&gt;BY DEFAULT&lt;/code&gt; 절 은 &lt;code&gt;INSERT&lt;/code&gt; 문 에서 시퀀스 값이 사용자 지정 값보다 우선 순위를 지정하는 방법을 결정합니다 . 경우 &lt;code&gt;ALWAYS&lt;/code&gt; 지정된 경우, 사용자가 지정한 값은 허용됩니다 &lt;code&gt;INSERT&lt;/code&gt; 의 문 지정이 &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; . 경우 &lt;code&gt;BY DEFAULT&lt;/code&gt; 지정하면 사용자가 지정한 값이 우선합니다. 자세한 내용은 &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; 를 참조하십시오. (에서 &lt;code&gt;COPY&lt;/code&gt; 명령을 사용자가 지정한 값에 관계없이 항상이 설정에 사용된다.)</target>
        </trans-unit>
        <trans-unit id="234bcc40e3c1c6669b66cf6ee7882220428cd61f" translate="yes" xml:space="preserve">
          <source>The clauses &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL-specific syntax, also used by MySQL. The SQL:2008 standard has introduced the clauses &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; for the same functionality, as shown above in &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;. This syntax is also used by IBM DB2. (Applications written for Oracle frequently use a workaround involving the automatically generated &lt;code&gt;rownum&lt;/code&gt; column, which is not available in PostgreSQL, to implement the effects of these clauses.)</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 및 &lt;code&gt;OFFSET&lt;/code&gt; 절 은 PostgreSQL 관련 구문이며 MySQL에서도 사용됩니다. SQL : 2008 표준에서는 위의 &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; &lt;/a&gt; 절에 표시된 것과 동일한 기능에 대해 &lt;code&gt;OFFSET ... FETCH {FIRST|NEXT} ...&lt;/code&gt; 절을 도입했습니다 . 이 구문은 IBM DB2에서도 사용됩니다. (오라클 용으로 작성된 응용 프로그램은 자주 자동으로 생성과 관련된 해결 방법 사용 &lt;code&gt;rownum&lt;/code&gt; PostgreSQL의에서 사용할 수 없습니다 열,이 조항의 효과를 구현할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="54380a0f1c98e1a0a687fefef82dc949bcffc323" translate="yes" xml:space="preserve">
          <source>The client must be allowed to access all referenced tables and columns, even if they originated from views which were then expanded, so that we apply consistent access control rules independent of the manner in which the table contents are referenced.</source>
          <target state="translated">클라이언트는 참조 된 모든 테이블 및 컬럼이 확장 된 뷰에서 시작된 경우에도 테이블 컨텐츠가 참조되는 방식에 관계없이 일관된 액세스 제어 규칙을 적용 할 수 있도록 모든 참조 된 테이블 및 컬럼에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="05fdc0ebe765756a24f5709f3f5f878e85b6fb9a" translate="yes" xml:space="preserve">
          <source>The client process can be any program that understands the PostgreSQL protocol described in &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt;. Many clients are based on the C-language library libpq, but several independent implementations of the protocol exist, such as the Java JDBC driver.</source>
          <target state="translated">클라이언트 프로세스는 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;52 장에&lt;/a&gt; 설명 된 PostgreSQL 프로토콜을 이해하는 모든 프로그램이 될 수 있습니다 . 많은 클라이언트가 C 언어 라이브러리 libpq를 기반으로하지만 Java JDBC 드라이버와 같은 프로토콜의 독립적 인 여러 구현이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="14c663b89bef91d752e19ecca16e81b132b43904" translate="yes" xml:space="preserve">
          <source>The client responds by sending a SASLInitialResponse message, which indicates the chosen mechanism, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; or &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. (A client is free to choose either mechanism, but for better security it should choose the channel-binding variant if it can support it.) In the Initial Client response field, the message contains the SCRAM &lt;code&gt;client-first-message&lt;/code&gt;. The &lt;code&gt;client-first-message&lt;/code&gt; also contains the channel binding type chosen by the client.</source>
          <target state="translated">클라이언트는 선택한 메커니즘 인 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 또는 &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; 를 나타내는 SASLInitialResponse 메시지를 보내 응답합니다 . (클라이언트는 두 가지 메커니즘 중 하나를 자유롭게 선택할 수 있지만 더 나은 보안을 위해 지원할 수있는 경우 채널 바인딩 변형을 선택해야합니다.) 초기 클라이언트 응답 필드에서 메시지에는 SCRAM &lt;code&gt;client-first-message&lt;/code&gt; 가 포함되어 있습니다 . &lt;code&gt;client-first-message&lt;/code&gt; 또한 클라이언트가 선택한 채널의 결합 형태를 포함한다.</target>
        </trans-unit>
        <trans-unit id="28e4175f56ce1936736eeadfb881155016ea4fed" translate="yes" xml:space="preserve">
          <source>The client selects one of the supported mechanisms from the list, and sends a SASLInitialResponse message to the server. The message includes the name of the selected mechanism, and an optional Initial Client Response, if the selected mechanism uses that.</source>
          <target state="translated">클라이언트는 지원되는 메커니즘 중 하나를 목록에서 선택하고 SASLInitialResponse 메시지를 서버로 보냅니다. 메시지에는 선택한 메커니즘의 이름과 선택한 메커니즘이 사용하는 경우 선택적 초기 클라이언트 응답이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="229cec88eb4f3eac7279336f40b13a71ae9b84dd" translate="yes" xml:space="preserve">
          <source>The client sends an Execute message with a non-zero fetch count. See the discussion of the &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;extended query protocol&lt;/a&gt;. Since &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq&lt;/a&gt; currently provides no way to send such a message, this can only occur when using a client that does not rely on libpq. If this is a frequent occurrence, it may be a good idea to set &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; to zero in sessions where it is likely, so as to avoid generating query plans that may be suboptimal when run serially.</source>
          <target state="translated">클라이언트는 0이 아닌 페치 수로 Execute 메시지를 보냅니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY&quot;&gt;확장 쿼리 프로토콜에&lt;/a&gt; 대한 설명을 참조하십시오 . 이후 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq.html&quot;&gt;libpq를가&lt;/a&gt; 현재와 같은 메시지를 보낼 수있는 방법을 제공하지 않습니다 libpq를에 의존하지 않는 클라이언트를 사용하는 경우, 이것은 단지 발생할 수 있습니다. 이것이 자주 발생하는 경우 연속적으로 실행될 때 차선책 일 수있는 쿼리 계획을 생성하지 않도록 가능한 세션에서 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt; 를 0 으로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2c8bc9da59ada6925c6ca4e1408b3caa10a534cd" translate="yes" xml:space="preserve">
          <source>The code block is treated as though it were the body of a function with no parameters, returning &lt;code&gt;void&lt;/code&gt;. It is parsed and executed a single time.</source>
          <target state="translated">코드 블록은 매개 변수가없는 함수 본문 인 것처럼 처리되어 &lt;code&gt;void&lt;/code&gt; 를 반환 합니다. 한 번만 구문 분석되고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="312278044badf1f81c35c2b663c752edaa662f24" translate="yes" xml:space="preserve">
          <source>The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in</source>
          <target state="translated">함수 또는 연산자가 조합 가능한 데이터 유형의 결과를 제공하는 경우 함수 또는 연산자의 결합 된 입력 표현식에 지정된 데이터 정렬은 함수 또는 연산자의 결과에도 적용되는 것으로 간주됩니다. 그래서</target>
        </trans-unit>
        <trans-unit id="07ad042e8eb9598587dcbb36503b3ffb45fa7270" translate="yes" xml:space="preserve">
          <source>The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings of a database cannot be changed after its creation.</source>
          <target state="translated">데이터 정렬 기능을 사용하면 열별 또는 작업 별 데이터의 정렬 순서 및 문자 분류 동작을 지정할 수 있습니다. 이는 데이터베이스 작성 후 &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정을 변경할 수 없다는 제한 사항을 완화합니다 .</target>
        </trans-unit>
        <trans-unit id="6968224c63a84f2b924666a708e6eefcbe1a5fe3" translate="yes" xml:space="preserve">
          <source>The collation of an expression can be the &amp;ldquo;default&amp;rdquo; collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail.</source>
          <target state="translated">식의 데이터 정렬은&amp;ldquo;기본&amp;rdquo;데이터 정렬이 될 수 있으며 이는 데이터베이스에 대해 정의 된 로캘 설정을 의미합니다. 식의 데이터 정렬이 불확실 할 수도 있습니다. 이러한 경우 정렬 작업을 알아야하는 주문 작업 및 기타 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8cbb0497a2d0489a87ba349c1f09ee8dec4f3fd5" translate="yes" xml:space="preserve">
          <source>The collation used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot for a collatable column would show the collation that defines the sort order of the data. Zero for noncollatable data.</source>
          <target state="translated">데이터 정렬은 &lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 저장된 통계를 도출하는 데 사용됩니다 . 예를 들어, 정렬 가능한 열의 히스토그램 슬롯에는 데이터 정렬 순서를 정의하는 데이터 정렬이 표시됩니다. 비교할 수없는 데이터의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="b4385bb7e15544b6f2f8d39c7296d888e4a8a5d9" translate="yes" xml:space="preserve">
          <source>The colon (&lt;code&gt;:&lt;/code&gt;) is used to select &amp;ldquo;slices&amp;rdquo; from arrays. (See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.) In certain SQL dialects (such as Embedded SQL), the colon is used to prefix variable names.</source>
          <target state="translated">콜론 ( &lt;code&gt;:&lt;/code&gt; ) 배열에서 &quot;슬라이스&quot;를 선택하는 데 사용됩니다. ( &lt;a href=&quot;arrays&quot;&gt;8.15 절&lt;/a&gt; 참조 ) 특정 SQL 언어 (예 : Embedded SQL)에서 콜론은 변수 이름 앞에 접두사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b41c26c54c1ac62b21f77b8fd62d5d3012b96e24" translate="yes" xml:space="preserve">
          <source>The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable's value as an SQL literal or identifier is a psql extension.</source>
          <target state="translated">변수의 콜론 구문은 ECPG와 같은 임베디드 쿼리 언어의 표준 SQL입니다. 배열 슬라이스 및 유형 캐스트에 대한 콜론 구문은 PostgreSQL 확장이며, 때로는 표준 사용법과 충돌 할 수 있습니다. 변수의 값을 SQL 리터럴 또는 식별자로 이스케이프하기위한 콜론 인용 구문은 psql 확장입니다.</target>
        </trans-unit>
        <trans-unit id="d094304df5c5c2f3f002a3a5f2b5b0282e855c32" translate="yes" xml:space="preserve">
          <source>The column data type that this operator class is for.</source>
          <target state="translated">이 연산자 클래스의 열 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5a6fb4ccabc2a7663f993c4ebb4c744ff2affbac" translate="yes" xml:space="preserve">
          <source>The column default value, in &lt;code&gt;nodeToString()&lt;/code&gt; representation. Use &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; to convert it to an SQL expression.</source>
          <target state="translated">&lt;code&gt;nodeToString()&lt;/code&gt; 표현 의 열 기본값 입니다. &lt;code&gt;pg_get_expr(adbin, adrelid)&lt;/code&gt; 을 사용 하여 SQL 표현식으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="08368fd428556014aaea42a5338ea6c2743ad445" translate="yes" xml:space="preserve">
          <source>The column is allowed to contain null values. This is the default.</source>
          <target state="translated">열은 널값을 포함 할 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5bb55967abb94c1ccc24a2441d33dbf806399e61" translate="yes" xml:space="preserve">
          <source>The column is not allowed to contain null values.</source>
          <target state="translated">열에 널값을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="d9ec3849dbdc73ff83e6e2b53f90a20a6fb0948f" translate="yes" xml:space="preserve">
          <source>The column source table(s) must be &lt;code&gt;INNER&lt;/code&gt; or &lt;code&gt;LEFT&lt;/code&gt; joined to the &lt;code&gt;LATERAL&lt;/code&gt; item, else there would not be a well-defined set of rows from which to compute each set of rows for the &lt;code&gt;LATERAL&lt;/code&gt; item. Thus, although a construct such as &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; is syntactically valid, it is not actually allowed for &lt;code&gt;Y&lt;/code&gt; to reference &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">열 소스 테이블 은 &lt;code&gt;LATERAL&lt;/code&gt; 항목에 결합 된 &lt;code&gt;INNER&lt;/code&gt; 또는 &lt;code&gt;LEFT&lt;/code&gt; 여야합니다 . 그렇지 않으면 &lt;code&gt;LATERAL&lt;/code&gt; 항목에 대한 각 행 세트를 계산할 잘 정의 된 행 세트가 없습니다 . 따라서 &lt;code&gt;X RIGHT JOIN LATERAL Y&lt;/code&gt; 와 같은 구문은 구문 상 유효하지만 실제로 &lt;code&gt;Y&lt;/code&gt; 가 &lt;code&gt;X&lt;/code&gt; 를 참조하는 것은 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e991f9b83115d7ba9de797ba7c6fd7f9b86d5e91" translate="yes" xml:space="preserve">
          <source>The columns names &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; are either the actual names of the columns of tables referenced in the &lt;code&gt;FROM&lt;/code&gt; clause, or the aliases given to them as explained in &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;. The name space available in the select list is the same as in the &lt;code&gt;WHERE&lt;/code&gt; clause, unless grouping is used, in which case it is the same as in the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">열 이름 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 는 &lt;code&gt;FROM&lt;/code&gt; 절 에서 참조 된 테이블 열의 실제 이름 이거나 &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;7.2.1.2 절에&lt;/a&gt; 설명 된대로 해당 별칭 입니다. 선택 목록에서 사용 가능한 네임 스페이스는 그룹화를 사용하지 않는 한 &lt;code&gt;WHERE&lt;/code&gt; 절에서와 동일하며,이 경우 &lt;code&gt;HAVING&lt;/code&gt; 절 에서와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4599d6eec1312706887ef09d2464d5545c627474" translate="yes" xml:space="preserve">
          <source>The combination of the return value of this function with the certificate serial number uniquely identifies the certificate.</source>
          <target state="translated">이 함수의 반환 값과 인증서 일련 번호의 조합은 인증서를 고유하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="062e4ea98a9662fe6dca5fb34a40a037aa606eb5" translate="yes" xml:space="preserve">
          <source>The command</source>
          <target state="translated">명령</target>
        </trans-unit>
        <trans-unit id="fd4ecf316bcb95382c9ca99fb6834b4e0a4db40c" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications, create compatibility names, or use an ICU-provided collation under a more readable name. For example:</source>
          <target state="translated">&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; 명령을 사용하여 기존 데이터 정렬에서 새 데이터 정렬을 만들 수도 있습니다. 이 명령 은 응용 프로그램에서 운영 체제 독립적 인 데이터 정렬 이름을 사용하거나 호환성 이름을 만들거나 ICU에서 제공 한 데이터 정렬을 사용하여 유용합니다. 더 읽기 쉬운 이름. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d977c35dcae77bd0de806a55a77621ba14612b62" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ALTER PUBLICATION&lt;/code&gt; can change the attributes of a publication.</source>
          <target state="translated">&lt;code&gt;ALTER PUBLICATION&lt;/code&gt; 명령은 발행물 의 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="969778663757608a9ceb272b57ae37cfa06e3dd9" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;COMMIT&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;COMMIT&lt;/code&gt; 명령 은 SQL 표준을 준수합니다. &lt;code&gt;COMMIT TRANSACTION&lt;/code&gt; 형식 은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="dbf0fa331f942a39e4739f4ed15c74b619e12d1b" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;CREATE DOMAIN&lt;/code&gt; conforms to the SQL standard.</source>
          <target state="translated">&lt;code&gt;CREATE DOMAIN&lt;/code&gt; 명령 은 SQL 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="c0e7572b18c65a9a6261e55f6991fd2f67f9ff3c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; is equivalent to &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt;. The tables are locked one-by-one in the order specified in the &lt;code&gt;LOCK TABLE&lt;/code&gt; command.</source>
          <target state="translated">명령 &lt;code&gt;LOCK TABLE a, b;&lt;/code&gt; &lt;code&gt;LOCK TABLE a; LOCK TABLE b;&lt;/code&gt; 와 같습니다 . 잠금 테이블 b; . &lt;code&gt;LOCK TABLE&lt;/code&gt; 명령에 지정된 순서대로 테이블이 하나씩 잠 깁니다 .</target>
        </trans-unit>
        <trans-unit id="bd29caedfd38b09e6ed21c78963ca39d6d0fdf15" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;ROLLBACK&lt;/code&gt; conforms to the SQL standard. The form &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;ROLLBACK&lt;/code&gt; 명령 은 SQL 표준을 준수합니다. &lt;code&gt;ROLLBACK TRANSACTION&lt;/code&gt; 양식 은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="14f45c2838c91f3d088f1dbeb531759099cc9619" translate="yes" xml:space="preserve">
          <source>The command does not actually have to prompt the user for a passphrase. It can read it from a file, obtain it from a keychain facility, or similar. It is up to the user to make sure the chosen mechanism is adequately secure.</source>
          <target state="translated">이 명령은 실제로 사용자에게 암호 문구를 묻지 않아도됩니다. 파일에서 파일을 읽거나 키 체인 시설 등에서 얻을 수 있습니다. 선택한 메커니즘이 적절하게 보안을 유지하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="125f23e3bb7186ab7a646a52cf5bf9eca19bcc45" translate="yes" xml:space="preserve">
          <source>The command form &lt;code&gt;\d+&lt;/code&gt; is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;replica identity&lt;/a&gt; setting.</source>
          <target state="translated">&lt;code&gt;\d+&lt;/code&gt; 명령 형식 은 추가 정보가 표시된다는 점을 제외하고 동일합니다. 테이블에 OID가 존재하는 것과 같이 테이블의 열과 관련된 주석이 표시됩니다. 관계가 뷰인 경우 뷰 정의입니다. 기본 &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;복제본 ID&lt;/a&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="0916bd8daa5b51f8834876be91b7f972c2fe0c9c" translate="yes" xml:space="preserve">
          <source>The command identifier (starting at zero) within the inserting transaction.</source>
          <target state="translated">삽입 트랜잭션 내에서 명령 식별자 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="d1364d07c5f1725771640b150e94c42c6a8b2515" translate="yes" xml:space="preserve">
          <source>The command identifier within the deleting transaction, or zero.</source>
          <target state="translated">삭제 트랜잭션 내의 명령 식별자 또는 0입니다.</target>
        </trans-unit>
        <trans-unit id="4d0382226380f9ead190eb302a73c778dbdd6e8d" translate="yes" xml:space="preserve">
          <source>The command is currently rebuilding an index.</source>
          <target state="translated">명령이 현재 색인을 재 빌드하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf18e6a22964c8d441f27d38a4a845cd36e9d7a8" translate="yes" xml:space="preserve">
          <source>The command is currently scanning the table using a sequential scan.</source>
          <target state="translated">명령이 현재 순차 스캔을 사용하여 테이블을 스캔하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d997222e2d809bc7ed01be5d82f30faa7501100" translate="yes" xml:space="preserve">
          <source>The command is currently swapping newly-built files into place.</source>
          <target state="translated">이 명령은 현재 새로 작성된 파일을 제자리로 바꾸고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d36048945358a61f078040109a39866ba3017fd5" translate="yes" xml:space="preserve">
          <source>The command is performing final cleanup. When this phase is completed, &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; will end.</source>
          <target state="translated">명령이 최종 정리를 수행하고 있습니다. 이 단계가 완료되면 &lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b779f0c2e033575cc8fc0dc14c755c01561f9ff6" translate="yes" xml:space="preserve">
          <source>The command is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">명령이 힙 스캔을 시작할 준비를하고 있습니다. 이 단계는 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="00faacb1d010fe63608a96c43ef3a7084a48b136" translate="yes" xml:space="preserve">
          <source>The command must print the passphrase to the standard output and exit with code 0. In the parameter value, &lt;code&gt;%p&lt;/code&gt; is replaced by a prompt string. (Write &lt;code&gt;%%&lt;/code&gt; for a literal &lt;code&gt;%&lt;/code&gt;.) Note that the prompt string will probably contain whitespace, so be sure to quote adequately. A single newline is stripped from the end of the output if present.</source>
          <target state="translated">명령은 암호를 표준 출력으로 인쇄하고 코드 0으로 종료해야합니다. 매개 변수 값에서 &lt;code&gt;%p&lt;/code&gt; 는 프롬프트 문자열로 대체됩니다. ( 리터럴 &lt;code&gt;%&lt;/code&gt; 의 경우 &lt;code&gt;%%&lt;/code&gt; 를 씁니다 .) 프롬프트 문자열에 공백이 포함되어있을 수 있으므로 적절하게 인용하십시오. 단일 줄 바꿈이 있으면 출력 끝에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c98b53eebf8fcd4fa5340e65c4d477e99fd91e81" translate="yes" xml:space="preserve">
          <source>The command or commands that make up the rule action. Valid commands are &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;.</source>
          <target state="translated">규칙 동작을 구성하는 명령입니다. 유효한 명령은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;NOTIFY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f5e5a53841d0cfd1aacf0accff8cefa2f5212ac" translate="yes" xml:space="preserve">
          <source>The command tag returned by &lt;code&gt;EXECUTE&lt;/code&gt; is that of the prepared statement, and not &lt;code&gt;EXECUTE&lt;/code&gt;.</source>
          <target state="translated">에 의해 반환 명령 태그 &lt;code&gt;EXECUTE&lt;/code&gt; 는 준비된 명령문의, 그리고 있다는 점이다 &lt;code&gt;EXECUTE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ac6ad09ab58057a9fed1f64a26a788f3d3e326" translate="yes" xml:space="preserve">
          <source>The command that is running. Either &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">실행중인 명령입니다. &lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="a9850fa889a0eec791cad23100b9e331cd2aa4fc" translate="yes" xml:space="preserve">
          <source>The command that is running: &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, or &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">실행 명령 : &lt;code&gt;CREATE INDEX&lt;/code&gt; , &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="559d421f3432d35c3d9a8fb5131571d6eb8752e8" translate="yes" xml:space="preserve">
          <source>The command to which the policy applies. Valid options are &lt;code&gt;ALL&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. &lt;code&gt;ALL&lt;/code&gt; is the default. See below for specifics regarding how these are applied.</source>
          <target state="translated">정책이 적용되는 명령입니다. 유효한 옵션은 &lt;code&gt;ALL&lt;/code&gt; , &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 입니다. &lt;code&gt;ALL&lt;/code&gt; 이 기본값입니다. 적용 방법에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7852202b8a6003f108d83f18dfb4650d44b65813" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied</source>
          <target state="translated">정책이 적용되는 명령 유형</target>
        </trans-unit>
        <trans-unit id="6c49af8969ccfcd1693376760717e08595698aa9" translate="yes" xml:space="preserve">
          <source>The command type to which the policy is applied: &lt;code&gt;r&lt;/code&gt; for &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; for &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; for all</source>
          <target state="translated">정책이 적용되는 명령 유형 : &lt;code&gt;r&lt;/code&gt; 에 대한 &lt;code&gt;SELECT&lt;/code&gt; , 대한 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 위한 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; 에 대한 &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; 모든 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31a55b9a99200f37a1fc91d5f4fc188806cc57ad" translate="yes" xml:space="preserve">
          <source>The command's result is a textual description of the plan selected for the &lt;code&gt;statement&lt;/code&gt;, optionally annotated with execution statistics. &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt; describes the information provided.</source>
          <target state="translated">명령의 결과는 &lt;code&gt;statement&lt;/code&gt; 대해 선택된 계획에 대한 텍스트 설명이며 선택적으로 실행 통계로 주석이 달립니다. &lt;a href=&quot;using-explain&quot;&gt;14.1 절에&lt;/a&gt; 제공된 정보가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e0a2632f98d43624e2ba898ef7cc5bdd1cf8c1" translate="yes" xml:space="preserve">
          <source>The command-line history is stored in the file &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows.</source>
          <target state="translated">명령 행 기록은 &lt;code&gt;~/.psql_history&lt;/code&gt; 파일 또는 Windows의 &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; 파일에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9e42c3efb15d8e677dc2308149404249d782207" translate="yes" xml:space="preserve">
          <source>The command-line-style arguments specified in &lt;code&gt;extra-options&lt;/code&gt; are passed to all server processes started by this &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;extra-options&lt;/code&gt; 에 지정된 명령 줄 스타일 인수 는이 &lt;code&gt;postgres&lt;/code&gt; 프로세스에 의해 시작된 모든 서버 프로세스로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="360d0f8394d720d22156d27a3f3ab0d50f8729e3" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;INSERT&lt;/code&gt; acquire this lock mode on the target table (in addition to &lt;code&gt;ACCESS SHARE&lt;/code&gt; locks on any other referenced tables). In general, this lock mode will be acquired by any command that &lt;em&gt;modifies data&lt;/em&gt; in a table.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; 명령 은 다른 참조 테이블의 &lt;code&gt;ACCESS SHARE&lt;/code&gt; 잠금 외에도 대상 테이블에서이 잠금 모드를 얻습니다 . 일반적으로이 잠금 모드는 테이블의 &lt;em&gt;데이터&lt;/em&gt; 를 &lt;em&gt;수정&lt;/em&gt; 하는 모든 명령에 의해 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="b120614b8a1edecdcf4c676c85b59acab98338cc" translate="yes" xml:space="preserve">
          <source>The commutator of this operator.</source>
          <target state="translated">이 연산자의 정류자입니다.</target>
        </trans-unit>
        <trans-unit id="f6803da73417ed20d6aa993c5529f00237b3f6a3" translate="yes" xml:space="preserve">
          <source>The compatibility notes of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command apply analogously to &lt;code&gt;REVOKE&lt;/code&gt;. The keyword &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required according to the standard, but PostgreSQL assumes &lt;code&gt;RESTRICT&lt;/code&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 명령 의 호환성 정보는 &lt;code&gt;REVOKE&lt;/code&gt; 와 유사하게 적용됩니다 . 표준에 따라 키워드 &lt;code&gt;RESTRICT&lt;/code&gt; 또는 &lt;code&gt;CASCADE&lt;/code&gt; 가 필요하지만 PostgreSQL은 기본적으로 &lt;code&gt;RESTRICT&lt;/code&gt; 를 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="40702de9ee6c2366268d72254909613dec0511c4" translate="yes" xml:space="preserve">
          <source>The complete lack of these facilities is usually manifested by an &amp;ldquo;Illegal system call&amp;rdquo; error upon server start. In that case there is no alternative but to reconfigure your kernel. PostgreSQL won't work without them. This situation is rare, however, among modern operating systems.</source>
          <target state="translated">이러한 기능의 완전한 부족은 일반적으로 서버 시작시 &quot;잘못된 시스템 호출&quot;오류로 나타납니다. 이 경우 커널을 재구성하는 것 외에 다른 대안은 없습니다. PostgreSQL이 없으면 작동하지 않습니다. 그러나 최신 운영 체제에서는 이러한 상황이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="8728921721ecf34d843d2d7d08bdc9c0ecc2f84b" translate="yes" xml:space="preserve">
          <source>The composite output routine will put double quotes around field values if they are empty strings or contain parentheses, commas, double quotes, backslashes, or white space. (Doing so for white space is not essential, but aids legibility.) Double quotes and backslashes embedded in field values will be doubled.</source>
          <target state="translated">복합 출력 루틴은 빈 문자열이거나 괄호, 쉼표, 큰 따옴표, 백 슬래시 또는 공백을 포함하는 경우 필드 값을 큰 따옴표로 묶습니다. (공백을 위해 그렇게하는 것은 필수는 아니지만 가독성을 지원합니다.) 필드 값에 포함 된 큰 따옴표와 백 슬래시는 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5e42f8ee02c00c89066a781bb2783e80203625" translate="yes" xml:space="preserve">
          <source>The compression technique used for either in-line or out-of-line compressed data is a fairly simple and very fast member of the LZ family of compression techniques. See &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; for the details.</source>
          <target state="translated">인라인 또는 라인 외부 압축 데이터에 사용되는 압축 기술은 LZ 압축 기술 제품군의 상당히 단순하고 빠른 멤버입니다. 자세한 내용은 &lt;code&gt;src/common/pg_lzcompress.c&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74936e59660e5e1e74d04f83302b0b914fcee784" translate="yes" xml:space="preserve">
          <source>The concatenation operator allows a single element to be pushed onto the beginning or end of a one-dimensional array. It also accepts two &lt;code&gt;N&lt;/code&gt;-dimensional arrays, or an &lt;code&gt;N&lt;/code&gt;-dimensional and an &lt;code&gt;N+1&lt;/code&gt;-dimensional array.</source>
          <target state="translated">연결 연산자를 사용하면 단일 요소를 1 차원 배열의 시작 또는 끝으로 푸시 할 수 있습니다. 또한 두 개의 &lt;code&gt;N&lt;/code&gt; 차원 배열 또는 &lt;code&gt;N&lt;/code&gt; 차원과 &lt;code&gt;N+1&lt;/code&gt; 차원 배열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5239ff4b58c91e7e13723e3163e22ecae35f6c6f" translate="yes" xml:space="preserve">
          <source>The condition &lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; can't be tested in the &lt;code&gt;tenk2_unique2&lt;/code&gt; index, so it's applied at the join node. This reduces the estimated output row count of the join node, but does not change either input scan.</source>
          <target state="translated">&lt;code&gt;t1.hundred &amp;lt; t2.hundred&lt;/code&gt; 조건 은 &lt;code&gt;tenk2_unique2&lt;/code&gt; 인덱스 에서 테스트 할 수 없으므로 조인 노드에 적용됩니다. 이는 결합 노드의 예상 출력 행 수를 줄이지 만 입력 스캔을 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c068c3abe0f845f75d348f1e71b7501c9e85d719" translate="yes" xml:space="preserve">
          <source>The configuration file is reread whenever the main server process receives a SIGHUP signal; this signal is most easily sent by running &lt;code&gt;pg_ctl reload&lt;/code&gt; from the command line or by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;. The main server process also propagates this signal to all currently running server processes, so that existing sessions also adopt the new values (this will happen after they complete any currently-executing client command). Alternatively, you can send the signal to a single server process directly. Some parameters can only be set at server start; any changes to their entries in the configuration file will be ignored until the server is restarted. Invalid parameter settings in the configuration file are likewise ignored (but logged) during SIGHUP processing.</source>
          <target state="translated">기본 서버 프로세스가 SIGHUP 신호를 수신 할 때마다 구성 파일을 다시 읽습니다. 이 신호는 명령 행에서 &lt;code&gt;pg_ctl reload&lt;/code&gt; 를 실행 하거나 SQL 함수 &lt;code&gt;pg_reload_conf()&lt;/code&gt; 호출하여 가장 쉽게 송신됩니다 . 기본 서버 프로세스는이 신호를 현재 실행중인 모든 서버 프로세스에 전파하므로 기존 세션도 새 값을 채택합니다 (현재 실행중인 클라이언트 명령을 완료 한 후에 발생 함). 또는 신호를 단일 서버 프로세스로 직접 보낼 수 있습니다. 일부 매개 변수는 서버 시작시에만 설정할 수 있습니다. 서버가 다시 시작될 때까지 구성 파일의 항목에 대한 변경 사항은 무시됩니다. SIGHUP 처리 중에 구성 파일의 유효하지 않은 매개 변수 설정도 무시됩니다 (그러나 로그됩니다).</target>
        </trans-unit>
        <trans-unit id="b9dccd142849bf4c5f5639f61a51dab8e56e5d09" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; determines whether JIT compilation is enabled or disabled. If it is enabled, the configuration variables &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;, and &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; determine whether JIT compilation is performed for a query, and how much effort is spent doing so.</source>
          <target state="translated">구성 변수 &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; 는 JIT 컴파일 사용 가능 여부를 결정합니다. 사용 가능한 경우 구성 변수 &lt;a href=&quot;runtime-config-query#GUC-JIT-ABOVE-COST&quot;&gt;jit_above_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; 는 조회에 대해 JIT 컴파일이 수행되는지 여부 와 이를 위해 얼마나 많은 노력을 기울이는 지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="19797f9713f4025f6738d996f66f2f16f1bb3ee3" translate="yes" xml:space="preserve">
          <source>The connection must be to the same database used to create the slot.</source>
          <target state="translated">슬롯을 작성하는 데 사용 된 동일한 데이터베이스에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbc80489eb4bf174c233f6bbbaa42452b7d3d86f" translate="yes" xml:space="preserve">
          <source>The connection string should specify the host name (or address) of the sending server, as well as the port number if it is not the same as the standby server's default. Also specify a user name corresponding to a suitably-privileged role on the sending server (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;Section 26.2.5.1&lt;/a&gt;). A password needs to be provided too, if the sender demands password authentication. It can be provided in the &lt;code&gt;primary_conninfo&lt;/code&gt; string, or in a separate &lt;code&gt;~/.pgpass&lt;/code&gt; file on the standby server (use &lt;code&gt;replication&lt;/code&gt; as the database name). Do not specify a database name in the &lt;code&gt;primary_conninfo&lt;/code&gt; string.</source>
          <target state="translated">연결 문자열은 전송 서버의 호스트 이름 (또는 주소)과 대기 서버의 기본값과 동일하지 않은 경우 포트 번호를 지정해야합니다. 송신 서버에서 적절한 권한을 가진 역할에 해당하는 사용자 이름도 지정하십시오 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-AUTHENTICATION&quot;&gt;26.2.5.1 절&lt;/a&gt; 참조 ). 발신자가 암호 인증을 요구하는 경우 암호도 제공해야합니다. &lt;code&gt;primary_conninfo&lt;/code&gt; 문자열 또는 대기 서버 의 별도 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일에 제공 할 수 있습니다 ( 데이터베이스 이름으로 &lt;code&gt;replication&lt;/code&gt; 사용 ). &lt;code&gt;primary_conninfo&lt;/code&gt; 문자열 에 데이터베이스 이름을 지정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="31fcb6829f600da0b565f01362ffaf255feb5d94" translate="yes" xml:space="preserve">
          <source>The connection string to the publisher. For details see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt;.</source>
          <target state="translated">게시자와의 연결 문자열입니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;33.1.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="164c7293cd6f4e265338f6fb352f7b98d06266a8" translate="yes" xml:space="preserve">
          <source>The constraint expression for a partial index.</source>
          <target state="translated">부분 인덱스에 대한 제약 조건 식입니다.</target>
        </trans-unit>
        <trans-unit id="0a023003d324d129028d83c645a2d4429045b67a" translate="yes" xml:space="preserve">
          <source>The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added.</source>
          <target state="translated">제한 조건이 즉시 점검되므로 테이블 데이터를 추가하기 전에 제한 조건을 충족시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="f753df8000fdee9203aa2be3a2862eb377d770ad" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;(a, b)&lt;/code&gt; is normally recognized in expressions as a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt;. Within the &lt;code&gt;GROUP BY&lt;/code&gt; clause, this does not apply at the top levels of expressions, and &lt;code&gt;(a, b)&lt;/code&gt; is parsed as a list of expressions as described above. If for some reason you &lt;em&gt;need&lt;/em&gt; a row constructor in a grouping expression, use &lt;code&gt;ROW(a, b)&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;(a, b)&lt;/code&gt; 는 일반적으로 표현식에서 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;행 생성자&lt;/a&gt; 로 인식됩니다 . &lt;code&gt;GROUP BY&lt;/code&gt; 절 내에서는 최상위 수준의 식에 적용되지 않으며 &lt;code&gt;(a, b)&lt;/code&gt; 는 위에서 설명한 식 목록으로 구문 분석됩니다. 어떤 이유로 그룹화 표현식에 행 생성자 &lt;em&gt;가 필요한&lt;/em&gt; 경우 &lt;code&gt;ROW(a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdace32fdb5c0027816e247b4bd1b7fb7ff95259" translate="yes" xml:space="preserve">
          <source>The contents of tables and indexes are discussed further in &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;.</source>
          <target state="translated">테이블과 인덱스의 내용은 &lt;a href=&quot;storage-page-layout&quot;&gt;68.6 절&lt;/a&gt; 에서 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="38f47269fb5aeb6c838c026cdcf1f0ae2ecfc4fc" translate="yes" xml:space="preserve">
          <source>The contents of the WAL buffers are written out to disk at every transaction commit, so extremely large values are unlikely to provide a significant benefit. However, setting this value to at least a few megabytes can improve write performance on a busy server where many clients are committing at once. The auto-tuning selected by the default setting of -1 should give reasonable results in most cases.</source>
          <target state="translated">WAL 버퍼의 내용은 모든 트랜잭션 커밋마다 디스크에 기록되므로 매우 큰 값은 큰 이점을 제공하지 않습니다. 그러나이 값을 최소한 몇 메가 바이트로 설정하면 많은 클라이언트가 한 번에 커밋하는 사용량이 많은 서버에서 쓰기 성능을 향상시킬 수 있습니다. 기본 설정 인 -1로 선택한 자동 조정은 대부분의 경우 합리적인 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1c6502d2f4ffe992973e02c33536a28b4746870" translate="yes" xml:space="preserve">
          <source>The contents of the directories &lt;code&gt;pg_dynshmem/&lt;/code&gt;, &lt;code&gt;pg_notify/&lt;/code&gt;, &lt;code&gt;pg_serial/&lt;/code&gt;, &lt;code&gt;pg_snapshots/&lt;/code&gt;, &lt;code&gt;pg_stat_tmp/&lt;/code&gt;, and &lt;code&gt;pg_subtrans/&lt;/code&gt; (but not the directories themselves) can be omitted from the backup as they will be initialized on postmaster startup. If &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; is set and is under the data directory then the contents of that directory can also be omitted.</source>
          <target state="translated">디렉토리의 내용은 &lt;code&gt;pg_dynshmem/&lt;/code&gt; , &lt;code&gt;pg_notify/&lt;/code&gt; , &lt;code&gt;pg_serial/&lt;/code&gt; , &lt;code&gt;pg_snapshots/&lt;/code&gt; , &lt;code&gt;pg_stat_tmp/&lt;/code&gt; 및 &lt;code&gt;pg_subtrans/&lt;/code&gt; 가 전자 메일 관리자 시작시 초기화 될 것이다 (그러나 디렉토리 자체는) 백업에서 생략 할 수 있습니다. &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; 가 설정되어 있고 데이터 디렉토리 아래에 있으면 해당 디렉토리의 내용도 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e0411ab62d3d86cfefc61b32fd0a5818262ee5" translate="yes" xml:space="preserve">
          <source>The conversion rules presented here are not exactly those of the SQL standard, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;Section D.3.1.3&lt;/a&gt;.</source>
          <target state="translated">여기에 제시된 변환 규칙은 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-CASTS&quot;&gt;섹션 D.3.1.3&lt;/a&gt; 에서 논의 된 바와 같이 SQL 표준의 규칙이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="93003637d33db2eb4895822b5caba9508ac9a024" translate="yes" xml:space="preserve">
          <source>The coordinates of an individual in the search space are represented by &lt;em&gt;chromosomes&lt;/em&gt;, in essence a set of character strings. A &lt;em&gt;gene&lt;/em&gt; is a subsection of a chromosome which encodes the value of a single parameter being optimized. Typical encodings for a gene could be &lt;em&gt;binary&lt;/em&gt; or &lt;em&gt;integer&lt;/em&gt;.</source>
          <target state="translated">검색 공간에서 개인의 좌표는 &lt;em&gt;염색체&lt;/em&gt; 로 표시됩니다 . 본질적으로 문자열 세트입니다. &lt;em&gt;유전자&lt;/em&gt; 최적화되는 단일 파라미터의 값을 암호화하는 염색체의 항이다. 유전자의 일반적인 인코딩은 &lt;em&gt;이진&lt;/em&gt; 또는 &lt;em&gt;정수일&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="862293286080d0a9f0113978ebf74556e90249fd" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the BRIN operator classes shown in &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 67.1&lt;/a&gt;.</source>
          <target state="translated">핵심 PostgreSQL 배포에는 &lt;a href=&quot;brin-builtin-opclasses#BRIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 67.1에&lt;/a&gt; 표시된 BRIN 연산자 클래스가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="7243c976dc744d56b010e5d36a8288b88892f5dc" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes previously shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. The following &lt;code&gt;contrib&lt;/code&gt; modules also contain GIN operator classes:</source>
          <target state="translated">핵심 PostgreSQL 배포에는 이전에 &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 66.1&lt;/a&gt; 에 표시된 GIN 연산자 클래스가 포함됩니다 . 다음 &lt;code&gt;contrib&lt;/code&gt; 모듈에는 GIN 연산자 클래스도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fbf40f11cf35a0a12e58dfa2d5f0d5377fea85" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GIN operator classes shown in &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 66.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GIN operator classes.)</source>
          <target state="translated">핵심 PostgreSQL 배포에는 &lt;a href=&quot;gin-builtin-opclasses#GIN-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 66.1에&lt;/a&gt; 나와있는 GIN 연산자 클래스가 포함됩니다 . ( &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;부록 F에&lt;/a&gt; 설명 된 옵션 모듈 중 일부는 추가 GIN 연산자 클래스를 제공합니다.)</target>
        </trans-unit>
        <trans-unit id="3d8a9d6f1f395ae01d0f93e48fe3bca4cc653cd4" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the GiST operator classes shown in &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;. (Some of the optional modules described in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Appendix F&lt;/a&gt; provide additional GiST operator classes.)</source>
          <target state="translated">핵심 PostgreSQL 배포에는 &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 64.1에&lt;/a&gt; 표시된 GiST 연산자 클래스가 포함됩니다 . ( &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;부록 F에&lt;/a&gt; 설명 된 옵션 모듈 중 일부는 추가적인 GiST 연산자 클래스를 제공합니다.)</target>
        </trans-unit>
        <trans-unit id="3d4f128e5e4ead669ae57136a3aca466199dcb9f" translate="yes" xml:space="preserve">
          <source>The core PostgreSQL distribution includes the SP-GiST operator classes shown in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">핵심 PostgreSQL 배포에는 &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 65.1에&lt;/a&gt; 표시된 SP-GiST 연산자 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a856912c9ac553c9e328fb462dc4a3dc3f226a" translate="yes" xml:space="preserve">
          <source>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support functions' source code.</source>
          <target state="translated">핵심 배포에는 minmax와 포함의 두 가지 유형의 연산자 클래스에 대한 지원이 포함됩니다. 이를 사용하는 연산자 클래스 정의는 적절한 코어 내 데이터 유형으로 제공됩니다. 소스 코드를 작성할 필요없이 동등한 정의를 사용하여 다른 데이터 유형에 대해 사용자가 추가 연산자 클래스를 정의 할 수 있습니다. 적절한 카탈로그 항목을 선언하는 것으로 충분합니다. 운영자 전략의 의미에 대한 가정은 지원 기능의 소스 코드에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6af74783e2e512b02fff35f8b9b1611ba92c8bc" translate="yes" xml:space="preserve">
          <source>The corresponding column will be filled with its default value.</source>
          <target state="translated">해당 열이 기본값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="39b1b5853e1b21f147904a21bac6120e0399eff4" translate="yes" xml:space="preserve">
          <source>The corresponding constraint in the parent partitioned table, if this is a constraint in a partition; else 0</source>
          <target state="translated">파티션의 제한 조건 인 경우 상위 파티션 된 테이블의 해당 제한 조건. 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="e50bc6dd81573c8b84e401b93b09d0320c5165e6" translate="yes" xml:space="preserve">
          <source>The costs are measured in arbitrary units determined by the planner's cost parameters (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). Traditional practice is to measure the costs in units of disk page fetches; that is, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; is conventionally set to &lt;code&gt;1.0&lt;/code&gt; and the other cost parameters are set relative to that. The examples in this section are run with the default cost parameters.</source>
          <target state="translated">비용은 플래너의 비용 매개 변수에 의해 결정된 임의의 단위로 측정됩니다 ( &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;섹션 19.7.2&lt;/a&gt; 참조 ). 전통적인 관행은 디스크 페이지 페치 단위로 비용을 측정하는 것입니다. 즉, &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; 는 일반적으로 &lt;code&gt;1.0&lt;/code&gt; 으로 설정되고 다른 비용 매개 변수는 이와 관련하여 설정됩니다. 이 섹션의 예제는 기본 비용 매개 변수로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="40a2e5c659fc82ea65929c45fcbdccd61dafc250" translate="yes" xml:space="preserve">
          <source>The creation of a publication does not start replication. It only defines a grouping and filtering logic for future subscribers.</source>
          <target state="translated">게시를 만들면 복제가 시작되지 않습니다. 향후 가입자를위한 그룹화 및 필터링 논리 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3e98adbd0156fb7d426b89504f191dda4a555319" translate="yes" xml:space="preserve">
          <source>The creation of databases is a restricted operation. See &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt; for how to grant permission.</source>
          <target state="translated">데이터베이스 작성은 제한된 조작입니다. 권한 부여 방법 &lt;a href=&quot;role-attributes&quot;&gt;은 21.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1880291804157d355a896d197b0a52d8a09b04b7" translate="yes" xml:space="preserve">
          <source>The cube a contains the cube b.</source>
          <target state="translated">큐브 a는 큐브 b를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="375266423676b7d7beda6d0e513197403bfef8c1" translate="yes" xml:space="preserve">
          <source>The cube a is contained in the cube b.</source>
          <target state="translated">큐브 a는 큐브 b에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b588f40bf468c3153645f14f27d51be8b21426c9" translate="yes" xml:space="preserve">
          <source>The cube a is greater than or equal to the cube b.</source>
          <target state="translated">큐브 a가 큐브 b보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f01cfa360b4f7c3692487eca6dd5b417fc389b3" translate="yes" xml:space="preserve">
          <source>The cube a is greater than the cube b.</source>
          <target state="translated">큐브 a가 큐브 b보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="0e6cf54be6b186407704fdff88fc957131d4ed9b" translate="yes" xml:space="preserve">
          <source>The cube a is less than or equal to the cube b.</source>
          <target state="translated">큐브 a는 큐브 b보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2d342ff49043cacce0129a759922d79461a11fa" translate="yes" xml:space="preserve">
          <source>The cube a is less than the cube b.</source>
          <target state="translated">큐브 a가 큐브 b보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="4634367f6224780d287c24528a5fced1237e5fa1" translate="yes" xml:space="preserve">
          <source>The cube a is not equal to the cube b.</source>
          <target state="translated">큐브 a가 큐브 b와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45987f656860bb4eb975fa1cd72ba43bc699f956" translate="yes" xml:space="preserve">
          <source>The cubes a and b are identical.</source>
          <target state="translated">큐브 a와 b는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9213cf52b8d8a10f6b7daa93550fc8c65e89e83d" translate="yes" xml:space="preserve">
          <source>The cubes a and b overlap.</source>
          <target state="translated">큐브 a와 b가 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="1a1e2040f8ce058f3c38c6e6d3751c0a69992146" translate="yes" xml:space="preserve">
          <source>The current backend's &lt;code&gt;xmin&lt;/code&gt; horizon.</source>
          <target state="translated">현재 백엔드의 &lt;code&gt;xmin&lt;/code&gt; 지평선</target>
        </trans-unit>
        <trans-unit id="71bea49a2448467c39ae3d46b44b8328244be40c" translate="yes" xml:space="preserve">
          <source>The current client character set encoding. This is set every time you connect to a database (including program start-up), and when you change the encoding with &lt;code&gt;\encoding&lt;/code&gt;, but it can be changed or unset.</source>
          <target state="translated">현재 클라이언트 문자 세트 인코딩 이것은 데이터베이스에 연결할 때마다 (프로그램 시작 포함) &lt;code&gt;\encoding&lt;/code&gt; 인코딩을 변경할 때 설정되지만 변경하거나 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0deea51724bf6c34acfe1425e13fc10373b6c41e" translate="yes" xml:space="preserve">
          <source>The current dimensions of any array value can be retrieved with the &lt;code&gt;array_dims&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;array_dims&lt;/code&gt; 함수를 사용하여 모든 배열 값의 현재 크기를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c3a8302b74a0c1c2418c7953403859316142fae" translate="yes" xml:space="preserve">
          <source>The current effective value of the search path can be examined via the SQL function &lt;code&gt;current_schemas&lt;/code&gt; (see &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt;). This is not quite the same as examining the value of &lt;code&gt;search_path&lt;/code&gt;, since &lt;code&gt;current_schemas&lt;/code&gt; shows how the items appearing in &lt;code&gt;search_path&lt;/code&gt; were resolved.</source>
          <target state="translated">검색 경로의 현재 유효 값은 SQL 함수 &lt;code&gt;current_schemas&lt;/code&gt; 를 통해 검사 할 수 있습니다 ( &lt;a href=&quot;functions-info&quot;&gt;섹션 9.25&lt;/a&gt; 참조 ). &lt;code&gt;current_schemas&lt;/code&gt; 는 &lt;code&gt;search_path&lt;/code&gt; 에 나타나는 항목이 어떻게 해결 되었는지를 보여주기 때문에 &lt;code&gt;search_path&lt;/code&gt; 값을 검사하는 것과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="588306ac744664bcce2285f16a927597e5d43ed4" translate="yes" xml:space="preserve">
          <source>The current implementation does not enforce the declared number of dimensions either. Arrays of a particular element type are all considered to be of the same type, regardless of size or number of dimensions. So, declaring the array size or number of dimensions in &lt;code&gt;CREATE TABLE&lt;/code&gt; is simply documentation; it does not affect run-time behavior.</source>
          <target state="translated">현재 구현에서는 선언 된 차원 수를 강제하지 않습니다. 특정 요소 유형의 배열은 크기 또는 차원 수에 관계없이 모두 동일한 유형으로 간주됩니다. 따라서 &lt;code&gt;CREATE TABLE&lt;/code&gt; 에서 배열 크기 또는 차원 수를 선언하는 것은 단순한 문서입니다. 런타임 동작에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03a220364aef06c1bbc7f574a82ccaeced5bea27" translate="yes" xml:space="preserve">
          <source>The current implementation has significant limitations, and does not enforce mandatory access control for all actions. See &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;Section F.35.7&lt;/a&gt;.</source>
          <target state="translated">현재 구현에는 중요한 제한 사항이 있으며 모든 작업에 대해 강제 액세스 제어를 시행하지는 않습니다. &lt;a href=&quot;sepgsql#SEPGSQL-LIMITATIONS&quot;&gt;섹션 F.35.7&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="25210d55190c9236b389899a74a7b5704fff78d4" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;unaccent&lt;/code&gt; cannot be used as a normalizing dictionary for the &lt;code&gt;thesaurus&lt;/code&gt; dictionary.</source>
          <target state="translated">현재 &lt;code&gt;unaccent&lt;/code&gt; 구현을 &lt;code&gt;thesaurus&lt;/code&gt; 사전 의 정규화 사전으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ed96c59248b01f330729c6c44b2035a2f3097a16" translate="yes" xml:space="preserve">
          <source>The current limitations of PostgreSQL's text search features are:</source>
          <target state="translated">PostgreSQL의 텍스트 검색 기능의 현재 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11ad6de9ae99189b133ed48695fe71e760901959" translate="yes" xml:space="preserve">
          <source>The cursor should be declared with the &lt;code&gt;SCROLL&lt;/code&gt; option if one intends to use any variants of &lt;code&gt;FETCH&lt;/code&gt; other than &lt;code&gt;FETCH NEXT&lt;/code&gt; or &lt;code&gt;FETCH FORWARD&lt;/code&gt; with a positive count. For simple queries PostgreSQL will allow backwards fetch from cursors not declared with &lt;code&gt;SCROLL&lt;/code&gt;, but this behavior is best not relied on. If the cursor is declared with &lt;code&gt;NO SCROLL&lt;/code&gt;, no backward fetches are allowed.</source>
          <target state="translated">&lt;code&gt;FETCH NEXT&lt;/code&gt; 또는 &lt;code&gt;FETCH FORWARD&lt;/code&gt; 이외 의 &lt;code&gt;FETCH&lt;/code&gt; 변형을 양수 로 사용하려는 경우 커서를 &lt;code&gt;SCROLL&lt;/code&gt; 옵션 으로 선언해야합니다 . 간단한 쿼리의 경우 PostgreSQL은 &lt;code&gt;SCROLL&lt;/code&gt; 로 선언되지 않은 커서에서 뒤로 가져 오기를 허용 하지만이 동작은 의존하지 않는 것이 가장 좋습니다. 커서가 &lt;code&gt;NO SCROLL&lt;/code&gt; 로 선언되면 역방향 페치가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f29dd59131cbd500833c5a80fec96f77393e7a4" translate="yes" xml:space="preserve">
          <source>The data distribution is very simple; there are only 100 distinct values in each column, uniformly distributed.</source>
          <target state="translated">데이터 배포는 매우 간단합니다. 각 열에는 100 개의 고유 한 값이 있으며 균일하게 분포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf388f98f91dd65f88f15e7c3f1b408fc205654b" translate="yes" xml:space="preserve">
          <source>The data is prefixed with a block of random bytes. This is equivalent to using a random IV.</source>
          <target state="translated">데이터 앞에 임의의 바이트 블록이 붙습니다. 이것은 무작위 IV를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d53ba1352e33254f15d2784088350652d0fec89f" translate="yes" xml:space="preserve">
          <source>The data on the standby takes some time to arrive from the primary server so there will be a measurable delay between primary and standby. Running the same query nearly simultaneously on both primary and standby might therefore return differing results. We say that data on the standby is &lt;em&gt;eventually consistent&lt;/em&gt; with the primary. Once the commit record for a transaction is replayed on the standby, the changes made by that transaction will be visible to any new snapshots taken on the standby. Snapshots may be taken at the start of each query or at the start of each transaction, depending on the current transaction isolation level. For more details, see &lt;a href=&quot;transaction-iso&quot;&gt;Section 13.2&lt;/a&gt;.</source>
          <target state="translated">대기의 데이터는 기본 서버에서 도착하는 데 약간의 시간이 걸리므로 기본 및 대기간에 측정 가능한 지연이 있습니다. 따라서 기본 쿼리와 대기 모드에서 거의 동시에 동일한 쿼리를 실행하면 다른 결과가 반환 될 수 있습니다. 대기의 데이터는 &lt;em&gt;결국&lt;/em&gt; 기본 데이터 와 &lt;em&gt;일치&lt;/em&gt; 한다고 말합니다 . 트랜잭션에 대한 커밋 레코드가 대기에서 재생되면 해당 트랜잭션의 변경 사항이 대기에서 작성된 새 스냅 샷에 표시됩니다. 현재 트랜잭션 격리 수준에 따라 각 쿼리의 시작 또는 각 트랜잭션의 시작시 스냅 샷이 생성 될 수 있습니다. 자세한 내용 &lt;a href=&quot;transaction-iso&quot;&gt;은 13.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b4139483f5abc1e06390b32222b164b98282561" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data as well as large-object definitions. Post-data items consist of definitions of indexes, triggers, rules and constraints other than validated check constraints. Pre-data items consist of all other data definition items.</source>
          <target state="translated">데이터 섹션에는 실제 테이블 데이터와 대형 객체 정의가 포함됩니다. 사후 데이터 항목은 유효성 검사 확인 제약 조건 이외의 인덱스, 트리거, 규칙 및 제약 조건의 정의로 구성됩니다. 사전 데이터 항목은 다른 모든 데이터 정의 항목으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ca4b823a5f4163ec85e2bd3fdf29af04d8b385" translate="yes" xml:space="preserve">
          <source>The data section contains actual table data, large-object contents, and sequence values. Post-data items include definitions of indexes, triggers, rules, and constraints other than validated check constraints. Pre-data items include all other data definition items.</source>
          <target state="translated">데이터 섹션에는 실제 테이블 데이터, 큰 객체 내용 및 시퀀스 값이 포함됩니다. 사후 데이터 항목에는 검증 된 점검 제한 조건 이외의 색인, 트리거, 규칙 및 제한 조건의 정의가 포함됩니다. 사전 데이터 항목에는 다른 모든 데이터 정의 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b17b79d26641dd87ba0c23b6c9bc174faa3a8b61" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;uuid&lt;/code&gt; stores Universally Unique Identifiers (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some systems refer to this data type as a globally unique identifier, or GUID, instead.) This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database.</source>
          <target state="translated">데이터 유형 &lt;code&gt;uuid&lt;/code&gt; 는 RFC 4122, ISO / IEC 9834-8 : 2005 및 관련 표준에 정의 된 UUID (Universally Unique Identifier)를 저장합니다. (일부 시스템에서는이 데이터 유형을 전역 고유 식별자 또는 GUID라고합니다.)이 식별자는 128 비트 수량으로, 다른 사람이 동일한 식별자를 생성 할 가능성이 거의 없도록 선택한 알고리즘에 의해 생성됩니다. 알려진 알고리즘에서 동일한 알고리즘을 사용합니다. 따라서 분산 시스템의 경우 이러한 식별자는 단일 데이터베이스 내에서만 고유 한 시퀀스 생성기보다 우수한 고유성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="9a349537e0ccabe90f0be4224865fb39a87fb38c" translate="yes" xml:space="preserve">
          <source>The data type actually stored in the index. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different. The &lt;code&gt;STORAGE&lt;/code&gt; clause must be omitted unless the index method allows a different type to be used. If the column &lt;code&gt;data_type&lt;/code&gt; is specified as &lt;code&gt;anyarray&lt;/code&gt;, the &lt;code&gt;storage_type&lt;/code&gt; can be declared as &lt;code&gt;anyelement&lt;/code&gt; to indicate that the index entries are members of the element type belonging to the actual array type that each particular index is created for.</source>
          <target state="translated">실제로 색인에 저장된 데이터 유형입니다. 일반적으로 이것은 열 데이터 유형과 동일하지만 일부 색인 방법 (현재 GiST, GIN 및 BRIN)에서는이를 다르게 할 수 있습니다. &lt;code&gt;STORAGE&lt;/code&gt; 인덱스 방법은 다른 유형을 사용할 수 있습니다하지 않는 한 절은 생략해야합니다. 컬럼 경우 &lt;code&gt;data_type&lt;/code&gt; 로 지정된 &lt;code&gt;anyarray&lt;/code&gt; 상기 &lt;code&gt;storage_type&lt;/code&gt; 선언 될 수 &lt;code&gt;anyelement&lt;/code&gt; 인덱스 엔트리는 각각의 특정 인덱스에 대해 생성되는 실제의 어레이 형에 속하는 요소 타입의 멤버임을 표시하기.</target>
        </trans-unit>
        <trans-unit id="b3cf16533d2c33c2548b22d8bef5b9f8bd26fb43" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value, when using moving-aggregate mode.</source>
          <target state="translated">이동 집계 모드를 사용할 때 집계의 상태 값에 대한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="450e47ffde369f976b7ab98b3a6e066768317211" translate="yes" xml:space="preserve">
          <source>The data type for the aggregate's state value.</source>
          <target state="translated">집계 상태 값의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a84accdb873accb8d045ec8f5d98450a1c8038e0" translate="yes" xml:space="preserve">
          <source>The data type of a function, procedure, or aggregate argument.</source>
          <target state="translated">함수, 프로 시저 또는 집계 인수의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7678a7f2db2f20f82bdcd718575a886bbedb555c" translate="yes" xml:space="preserve">
          <source>The data type of a parameter to the prepared statement. If the data type of a particular parameter is unspecified or is specified as &lt;code&gt;unknown&lt;/code&gt;, it will be inferred from the context in which the parameter is first referenced. To refer to the parameters in the prepared statement itself, use &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.</source>
          <target state="translated">준비된 명령문에 대한 매개 변수의 데이터 유형입니다. 특정 매개 변수의 데이터 유형이 지정되지 않았거나 &lt;code&gt;unknown&lt;/code&gt; 으로 지정된 경우 , 매개 변수가 처음 참조되는 컨텍스트에서 추론됩니다. 준비된 명령문 자체의 매개 변수를 참조하려면 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97e7b1042480837c18e5146ff95fc1e9e9d4ce38" translate="yes" xml:space="preserve">
          <source>The data type of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 구문 에서 출력 열의 데이터 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1f4da46a2e46ee99f93db576da8c6c70a740dbca" translate="yes" xml:space="preserve">
          <source>The data type of the attribute to add, or the new type of the attribute to alter.</source>
          <target state="translated">추가 할 속성의 데이터 유형 또는 변경할 속성의 새 유형입니다.</target>
        </trans-unit>
        <trans-unit id="643babd5ccd3dbc1eadd607ad51f52e3099e9220" translate="yes" xml:space="preserve">
          <source>The data type of the column. This can include array specifiers. For more information on the data types supported by PostgreSQL, refer to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;.</source>
          <target state="translated">열의 데이터 유형입니다. 여기에는 배열 지정자가 포함될 수 있습니다. PostgreSQL에서 지원하는 데이터 유형에 대한 자세한 내용은 &lt;a href=&quot;datatype&quot;&gt;8 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00e2be0bf08b0f249705f534c771af62f659c534" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand, if any. This option would be omitted for a left-unary operator.</source>
          <target state="translated">연산자 왼쪽 피연산자의 데이터 유형입니다 (있는 경우). 이 옵션은 왼쪽 단항 연산자에서는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="3851b291352047da5cb8dab5436b1049af2b810b" translate="yes" xml:space="preserve">
          <source>The data type of the operator's left operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no left operand.</source>
          <target state="translated">연산자 왼쪽 피연산자의 데이터 유형입니다. 연산자에 왼쪽 피연산자가 없으면 &lt;code&gt;NONE&lt;/code&gt; 을 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="ccbd8cc94b9c8b592bbe8864eb6cc7e34df08235" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand, if any. This option would be omitted for a right-unary operator.</source>
          <target state="translated">연산자 오른쪽 피연산자의 데이터 유형입니다 (있는 경우). 우항 연산자의 경우이 옵션을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="977b80839dcec0a264635f6fae2341cd4abe466d" translate="yes" xml:space="preserve">
          <source>The data type of the operator's right operand; write &lt;code&gt;NONE&lt;/code&gt; if the operator has no right operand.</source>
          <target state="translated">연산자 오른쪽 피연산자의 데이터 유형입니다. 연산자에 올바른 피연산자가 없으면 &lt;code&gt;NONE&lt;/code&gt; 을 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="d1e6d9a6627f0f8541d4b2888407afff0ea3591c" translate="yes" xml:space="preserve">
          <source>The data type of this column</source>
          <target state="translated">이 열의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="536b65adfc0c23a20e0043a6c217a813568358a2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">함수 인수의 데이터 유형 (선택적으로 스키마 규정) (있는 경우).</target>
        </trans-unit>
        <trans-unit id="c1899d531f40a6d2bc934ee7a1bdb436b5b33cc2" translate="yes" xml:space="preserve">
          <source>The data type(s) of the function's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">함수 인수의 데이터 유형 (선택적으로 스키마 규정) (있는 경우). 인수 유형은 기본, 복합 또는 도메인 유형이거나 테이블 열의 유형을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa26cbbebcfa5ffa72e0fb66013b91729e1dbea" translate="yes" xml:space="preserve">
          <source>The data type(s) of the operator's arguments (optionally schema-qualified). Write &lt;code&gt;NONE&lt;/code&gt; for the missing argument of a prefix or postfix operator.</source>
          <target state="translated">연산자 인수의 데이터 유형 (선택적으로 스키마 규정). 접두사 또는 접미사 연산자의 누락 된 인수에 대해서는 &lt;code&gt;NONE&lt;/code&gt; 을 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="f78d5722d424ec9c1eb5a72c627a144311353db1" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any.</source>
          <target state="translated">프로 시저 인수의 데이터 유형 (선택적으로 스키마 규정) (있는 경우).</target>
        </trans-unit>
        <trans-unit id="cc4ed7c8f0edb91ee3802c9f1cbfdfe5d88cd95f" translate="yes" xml:space="preserve">
          <source>The data type(s) of the procedure's arguments (optionally schema-qualified), if any. The argument types can be base, composite, or domain types, or can reference the type of a table column.</source>
          <target state="translated">프로 시저 인수의 데이터 유형 (선택적으로 스키마 규정) (있는 경우). 인수 유형은 기본, 복합 또는 도메인 유형이거나 테이블 열의 유형을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13b1cfa55ac5025cb1667821c336a02f9958dc9" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; 및 &lt;code&gt;double precision&lt;/code&gt; 데이터 형식 은 정확하지 않은 가변 정밀도 숫자 형식입니다. 현재 지원되는 모든 플랫폼에서이 유형은 기본 프로세서, 운영 체제 및 컴파일러가 지원하는 정도까지 이진 부동 소수점 산술을위한 IEEE 표준 754 (각각 단정도 및 배정도)의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="95cc47952f3a5e2e5bea18ece63744adf6f3d52b" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are not true types, but merely a notational convenience for creating unique identifier columns (similar to the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; property supported by some other databases). In the current implementation, specifying:</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;serial&lt;/code&gt; 및 &lt;code&gt;bigserial&lt;/code&gt; 데이터 형식 은 실제 형식이 아니라 고유 식별자 열을 만드는 데있어 표기법의 편의성입니다 ( 다른 데이터베이스에서 지원 하는 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 속성 과 유사 ). 현재 구현에서 다음을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d4cee11581ccf46822d30574cc04ac170d447c" translate="yes" xml:space="preserve">
          <source>The data types of all the &lt;code&gt;result&lt;/code&gt; expressions must be convertible to a single output type. See &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt; for more details.</source>
          <target state="translated">모든 &lt;code&gt;result&lt;/code&gt; 표현식 의 데이터 유형은 단일 출력 유형으로 변환 가능해야합니다. 자세한 내용 &lt;a href=&quot;typeconv-union-case&quot;&gt;은 10.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="833950eaad4f091a792f16ed765cff996e89f49e" translate="yes" xml:space="preserve">
          <source>The data values are listed in the order in which the columns appear in the table, separated by commas. Usually, the data values will be literals (constants), but scalar expressions are also allowed.</source>
          <target state="translated">데이터 값은 열이 표에 나타나는 순서대로 쉼표로 구분되어 나열됩니다. 일반적으로 데이터 값은 리터럴 (상수)이지만 스칼라 식도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="511f74682fefbedf40676929009d5d52bb81a56d" translate="yes" xml:space="preserve">
          <source>The data values are mapped in the same way as described for the function &lt;code&gt;xmlelement&lt;/code&gt; above.</source>
          <target state="translated">데이터 값은 위의 &lt;code&gt;xmlelement&lt;/code&gt; 함수에 대해 설명한 것과 동일한 방식으로 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3854c2d1d8f8304933b603d0d2fef62ed88a35f" translate="yes" xml:space="preserve">
          <source>The database activity of pg_dump is normally collected by the statistics collector. If this is undesirable, you can set parameter &lt;code&gt;track_counts&lt;/code&gt; to false via &lt;code&gt;PGOPTIONS&lt;/code&gt; or the &lt;code&gt;ALTER USER&lt;/code&gt; command.</source>
          <target state="translated">pg_dump의 데이터베이스 활동은 일반적으로 통계 수집기에 의해 수집됩니다. 이것이 바람직하지 않은 경우 &lt;code&gt;PGOPTIONS&lt;/code&gt; 또는 &lt;code&gt;ALTER USER&lt;/code&gt; 명령을 통해 &lt;code&gt;track_counts&lt;/code&gt; 매개 변수 를 false로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e78726feeb2c4690a432f23c59d13fb4ceea2509" translate="yes" xml:space="preserve">
          <source>The database named in the &lt;code&gt;-d&lt;/code&gt; switch can be any database existing in the cluster; pg_restore only uses it to issue the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command for &lt;code&gt;mydb&lt;/code&gt;. With &lt;code&gt;-C&lt;/code&gt;, data is always restored into the database name that appears in the dump file.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 스위치에 이름이 지정된 데이터베이스는 클러스터에 존재하는 모든 데이터베이스 일 수 있습니다. pg_restore는이를 사용 하여 &lt;code&gt;mydb&lt;/code&gt; 에 대한 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령 을 발행합니다 . &lt;code&gt;-C&lt;/code&gt; 를 사용하면 데이터는 항상 덤프 파일에 나타나는 데이터베이스 이름으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a7217998725cfcd7339a40affa714dc41a9f7779" translate="yes" xml:space="preserve">
          <source>The database schema and DDL commands are not replicated. The initial schema can be copied by hand using &lt;code&gt;pg_dump --schema-only&lt;/code&gt;. Subsequent schema changes would need to be kept in sync manually. (Note, however, that there is no need for the schemas to be absolutely the same on both sides.) Logical replication is robust when schema definitions change in a live database: When the schema is changed on the publisher and replicated data starts arriving at the subscriber but does not fit into the table schema, replication will error until the schema is updated. In many cases, intermittent errors can be avoided by applying additive schema changes to the subscriber first.</source>
          <target state="translated">데이터베이스 스키마 및 DDL 명령은 복제되지 않습니다. &lt;code&gt;pg_dump --schema-only&lt;/code&gt; 를 사용하여 초기 스키마를 직접 복사 할 수 있습니다 . 후속 스키마 변경은 수동으로 동기화 상태를 유지해야합니다. 그러나 스키마가 양쪽에서 완전히 동일 할 필요는 없습니다. 라이브 데이터베이스에서 스키마 정의가 변경 될 때 논리적 복제가 강력합니다. 게시자에서 스키마가 변경되고 복제 된 데이터가 도착하기 시작하면 구독자이지만 테이블 스키마에 맞지 않으면 스키마가 업데이트 될 때까지 복제 오류가 발생합니다. 대부분의 경우 가입자에게 추가 스키마 변경 사항을 먼저 적용하여 간헐적 인 오류를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7126248724d0590ca70b478abc60308b632b1141" translate="yes" xml:space="preserve">
          <source>The database server &lt;em&gt;must&lt;/em&gt; be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will &lt;em&gt;not&lt;/em&gt; work (in part because &lt;code&gt;tar&lt;/code&gt; and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in &lt;a href=&quot;server-shutdown&quot;&gt;Section 18.5&lt;/a&gt;. Needless to say, you also need to shut down the server before restoring the data.</source>
          <target state="translated">사용 가능한 백업을 얻으려면 데이터베이스 서버 &lt;em&gt;를&lt;/em&gt; 종료 &lt;em&gt;해야합니다&lt;/em&gt; . 모든 연결을 허용하지 않는 등의 중간 조치는 작동 &lt;em&gt;하지 않습니다&lt;/em&gt; (일부 &lt;code&gt;tar&lt;/code&gt; 및 유사한 도구는 파일 시스템 상태의 원자 적 스냅 샷을 작성하지 않고 서버 내의 내부 버퍼링으로 인해). 서버 중지에 대한 정보는 &lt;a href=&quot;server-shutdown&quot;&gt;18.5 절&lt;/a&gt; 에서 찾을 수 있습니다 . 말할 것도없이, 데이터를 복원하기 전에 서버를 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8210278fffa651db73498b44685083caea4837b" translate="yes" xml:space="preserve">
          <source>The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">현재 연결된 데이터베이스 서버 호스트 데이터베이스 (프로그램 시작 포함)에 연결할 때마다 설정되지만 변경하거나 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4225ad89a733947e3891f6391650e080a1af4ac1" translate="yes" xml:space="preserve">
          <source>The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">현재 연결된 데이터베이스 서버 포트 데이터베이스 (프로그램 시작 포함)에 연결할 때마다 설정되지만 변경하거나 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0f8108abc644f84f0071b412b2512b78ad2132" translate="yes" xml:space="preserve">
          <source>The database server's host name</source>
          <target state="translated">데이터베이스 서버의 호스트 이름</target>
        </trans-unit>
        <trans-unit id="a4b3d744975ee6b60121119bc335e231f7de4513" translate="yes" xml:space="preserve">
          <source>The database server's port number</source>
          <target state="translated">데이터베이스 서버의 포트 번호</target>
        </trans-unit>
        <trans-unit id="cfe5c0809041f0c5dee1fdfbdf2f909905d7bde5" translate="yes" xml:space="preserve">
          <source>The database session user name. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">데이터베이스 세션 사용자 이름 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 명령의 결과로 데이터베이스 세션 중에이 값의 확장이 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8854074f0a9f2884a73fba5bef5522aadc8c6fe8" translate="yes" xml:space="preserve">
          <source>The database to connect to. See the description of the actions for what this means in detail. This can be a libpq connection string; see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information. Defaults to user name.</source>
          <target state="translated">연결할 데이터베이스입니다. 이것이 의미하는 바에 대한 조치 설명을 참조하십시오. 이것은 libpq 연결 문자열 일 수 있습니다. 참조 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;섹션 33.1.1을&lt;/a&gt; 자세한 내용은. 기본값은 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8142c603a5c381a14fdd730098342401f6c26eea" translate="yes" xml:space="preserve">
          <source>The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">현재 연결된 데이터베이스 사용자입니다. 데이터베이스 (프로그램 시작 포함)에 연결할 때마다 설정되지만 변경하거나 설정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b630a685a9f1e8cf73c559db8e767d96cc4b9662" translate="yes" xml:space="preserve">
          <source>The database you are trying to connect to does not exist. Note that if you do not specify a database name, it defaults to the database user name, which might or might not be the right thing.</source>
          <target state="translated">연결하려는 데이터베이스가 없습니다. 데이터베이스 이름을 지정하지 않으면 데이터베이스 사용자 이름이 기본값이되며 이는 올바른 것이거나 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee1a6c055e42f40e71b91d8726649529647f66d" translate="yes" xml:space="preserve">
          <source>The datatype input function for type &lt;code&gt;boolean&lt;/code&gt; accepts these string representations for the &amp;ldquo;true&amp;rdquo; state:</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형의 데이터 유형 입력 함수 는 &quot;true&quot;상태에 대해 다음 문자열 표시를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ae4a7ff4b226f1bae5a99aaa421f3e1ec4a71979" translate="yes" xml:space="preserve">
          <source>The datatype output function for type &lt;code&gt;boolean&lt;/code&gt; always emits either &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt;, as shown in &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;Example 8.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 유형에 대한 데이터 유형 출력 함수 는 &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-EXAMPLE&quot;&gt;예 8.2에&lt;/a&gt; 표시된 것처럼 항상 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="7cfcef52fd742ca2a7d47081e6367dac502e36ab" translate="yes" xml:space="preserve">
          <source>The date/time style can be selected by the user using the &lt;code&gt;SET datestyle&lt;/code&gt; command, the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter in the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, or the &lt;code&gt;PGDATESTYLE&lt;/code&gt; environment variable on the server or client.</source>
          <target state="translated">날짜 / 시간 스타일은 &lt;code&gt;SET datestyle&lt;/code&gt; 명령, &lt;code&gt;postgresql.conf&lt;/code&gt; 구성 파일 의 &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; 매개 변수 또는 서버 또는 클라이언트 의 &lt;code&gt;PGDATESTYLE&lt;/code&gt; 환경 변수를 사용하여 사용자가 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d764ba10f260d8d4e8bfcd3a741fca678bd1d96" translate="yes" xml:space="preserve">
          <source>The day of the week as Monday (&lt;code&gt;1&lt;/code&gt;) to Sunday (&lt;code&gt;7&lt;/code&gt;)</source>
          <target state="translated">월요일 ( &lt;code&gt;1&lt;/code&gt; ) ~ 일요일 ( &lt;code&gt;7&lt;/code&gt; )의 요일</target>
        </trans-unit>
        <trans-unit id="a891efc073ada13a5907f18625fe5fde82907c09" translate="yes" xml:space="preserve">
          <source>The day of the week as Sunday (&lt;code&gt;0&lt;/code&gt;) to Saturday (&lt;code&gt;6&lt;/code&gt;)</source>
          <target state="translated">일요일 ( &lt;code&gt;0&lt;/code&gt; )부터 토요일 ( &lt;code&gt;6&lt;/code&gt; ) 의 요일</target>
        </trans-unit>
        <trans-unit id="9ca4eefed78bdde53eebbe05d44c2b02c01e2924" translate="yes" xml:space="preserve">
          <source>The day of the year (1 - 365/366)</source>
          <target state="translated">요일 (1-365/366)</target>
        </trans-unit>
        <trans-unit id="d4a9223278a724eaae749c9ac28592e80acca20f" translate="yes" xml:space="preserve">
          <source>The decrypted data and the decryption key are present on the server for a brief time while it is being decrypted and communicated between the client and server. This presents a brief moment where the data and keys can be intercepted by someone with complete access to the database server, such as the system administrator.</source>
          <target state="translated">암호 해독 된 데이터와 암호 해독 키는 클라이언트와 서버간에 해독되고 통신되는 동안 잠시 동안 서버에 존재합니다. 이것은 시스템 관리자와 같은 데이터베이스 서버에 대한 완전한 액세스 권한을 가진 사람이 데이터와 키를 가로 챌 수있는 순간입니다.</target>
        </trans-unit>
        <trans-unit id="164046e431b6ca84db93b57b79867c4791c090cf" translate="yes" xml:space="preserve">
          <source>The default (and recommended) setting of &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion&lt;/a&gt; is neither &lt;code&gt;on&lt;/code&gt; nor &lt;code&gt;off&lt;/code&gt;, but an intermediate setting called &lt;code&gt;partition&lt;/code&gt;, which causes the technique to be applied only to queries that are likely to be working on inheritance partitioned tables. The &lt;code&gt;on&lt;/code&gt; setting causes the planner to examine &lt;code&gt;CHECK&lt;/code&gt; constraints in all queries, even simple ones that are unlikely to benefit.</source>
          <target state="translated">의 기본 설정 (권장) &lt;a href=&quot;runtime-config-query#GUC-CONSTRAINT-EXCLUSION&quot;&gt;constraint_exclusion는&lt;/a&gt; 어느 쪽도 없습니다 &lt;code&gt;on&lt;/code&gt; 나 &lt;code&gt;off&lt;/code&gt; 있지만라는 중간 설정 &lt;code&gt;partition&lt;/code&gt; 기술을 야기 만 상속 테이블을 분할 작업을 할 가능성이 쿼리에 적용 할 수 있습니다. &lt;code&gt;on&lt;/code&gt; 설정을 검토 할 계획됩니다 &lt;code&gt;CHECK&lt;/code&gt; 의 모든 쿼리 제약 조건, 혜택 않을 경우에도 간단한 것들.</target>
        </trans-unit>
        <trans-unit id="1787e7e5cf03a442dbbaaa1d6af68edf6096b6e2" translate="yes" xml:space="preserve">
          <source>The default GIN operator class for &lt;code&gt;jsonb&lt;/code&gt; supports queries with top-level key-exists operators &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators and path/value-exists operator &lt;code&gt;@&amp;gt;&lt;/code&gt;. (For details of the semantics that these operators implement, see &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;Table 9.45&lt;/a&gt;.) An example of creating an index with this operator class is:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; 의 기본 GIN 연산자 클래스는 최상위 키가 존재하는 연산자 &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;?&amp;amp;&lt;/code&gt; 및 &lt;code&gt;?|&lt;/code&gt; 연산자 및 경로 / 값이 존재합니다. 연산자 &lt;code&gt;@&amp;gt;&lt;/code&gt; . 이러한 연산자가 구현하는 의미에 대한 자세한 내용은 &lt;a href=&quot;functions-json#FUNCTIONS-JSONB-OP-TABLE&quot;&gt;표 9.45를&lt;/a&gt; 참조하십시오 .이 연산자 클래스를 사용하여 인덱스를 작성하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2eb60f012e323a27dd228ff40f13cdf0f9d72cff" translate="yes" xml:space="preserve">
          <source>The default IPC settings can be changed using the &lt;code&gt;sysctl&lt;/code&gt; or &lt;code&gt;loader&lt;/code&gt; interfaces. The following parameters can be set using &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">기본 IPC 설정은 &lt;code&gt;sysctl&lt;/code&gt; 또는 &lt;code&gt;loader&lt;/code&gt; 인터페이스를 사용하여 변경할 수 있습니다 . &lt;code&gt;sysctl&lt;/code&gt; 을 사용하여 다음 매개 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0939858e47c24e25aea8221bd11aa7efd06e7d2d" translate="yes" xml:space="preserve">
          <source>The default TPC-B-like transaction test requires specific tables to be set up beforehand. pgbench should be invoked with the &lt;code&gt;-i&lt;/code&gt; (initialize) option to create and populate these tables. (When you are testing a custom script, you don't need this step, but will instead need to do whatever setup your test needs.) Initialization looks like:</source>
          <target state="translated">기본 TPC-B와 유사한 트랜잭션 테스트를 위해서는 특정 테이블을 미리 설정해야합니다. 이 테이블을 작성하고 채우려면 &lt;code&gt;-i&lt;/code&gt; (초기화) 옵션으로 pgbench를 호출해야합니다 . 사용자 지정 스크립트를 테스트 할 때는이 단계가 필요하지 않지만 테스트에 필요한 설정을 수행해야합니다. 초기화는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cd3fc8c960efc439298488cea62fca507ea8c64" translate="yes" xml:space="preserve">
          <source>The default behavior for huge pages in PostgreSQL is to use them when possible and to fall back to normal pages when failing. To enforce the use of huge pages, you can set &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; to &lt;code&gt;on&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. Note that with this setting PostgreSQL will fail to start if not enough huge pages are available.</source>
          <target state="translated">PostgreSQL에서 거대한 페이지의 기본 동작은 가능한 경우 해당 페이지를 사용하고 실패하면 일반 페이지로 폴백하는 것입니다. 거대한 페이지를 사용 하기 위해 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;a href=&quot;runtime-config-resource#GUC-HUGE-PAGES&quot;&gt;huge_pages&lt;/a&gt; 를 &lt;code&gt;on&lt;/code&gt; 으로 설정할 수 있습니다 . 이 설정을 사용하면 충분한 양의 페이지가 충분하지 않으면 PostgreSQL이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaa5ded69b6418f38f6ec7a4670e3b4d29f7971b" translate="yes" xml:space="preserve">
          <source>The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt;. You cannot recover into timelines that branched off earlier than the base backup.</source>
          <target state="translated">복구의 기본 동작은 기본 백업을 수행 할 당시와 동일한 타임 라인을 따라 복구하는 것입니다. 당신이 (즉, 당신이 자체 복구 시도 후 생성 된 어떤 상태로 돌아가려면) 어떤 자식 타임 라인에 복구하려는 경우에 대상 타임 라인 ID를 지정해야 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-TIMELINE&quot;&gt;recovery_target_timeline&lt;/a&gt; . 기본 백업보다 먼저 분기 된 타임 라인으로 복구 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a7ad1055953cf587ab781a3bc1fc4c9129cc265" translate="yes" xml:space="preserve">
          <source>The default built-in transaction script (also invoked with &lt;code&gt;-b tpcb-like&lt;/code&gt;) issues seven commands per transaction over randomly chosen &lt;code&gt;aid&lt;/code&gt;, &lt;code&gt;tid&lt;/code&gt;, &lt;code&gt;bid&lt;/code&gt; and &lt;code&gt;delta&lt;/code&gt;. The scenario is inspired by the TPC-B benchmark, but is not actually TPC-B, hence the name.</source>
          <target state="translated">기본 내장 트랜잭션 스크립트 ( &lt;code&gt;-b tpcb-like&lt;/code&gt; 로도 호출 됨 )는 임의로 선택된 &lt;code&gt;aid&lt;/code&gt; , &lt;code&gt;tid&lt;/code&gt; , &lt;code&gt;bid&lt;/code&gt; 및 &lt;code&gt;delta&lt;/code&gt; 보다 트랜잭션 당 7 개의 명령을 발행합니다 . 이 시나리오는 TPC-B 벤치 마크에서 영감을 얻었지만 실제로는 TPC-B가 아니므로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="23125fde28fb9f59764dcf1b23a280a89053eb88" translate="yes" xml:space="preserve">
          <source>The default database privilege system allows database superusers to modify system catalogs using DML commands, and reference or modify toast tables. These operations are prohibited when &lt;code&gt;sepgsql&lt;/code&gt; is enabled.</source>
          <target state="translated">기본 데이터베이스 권한 시스템을 통해 데이터베이스 수퍼 유저는 DML 명령을 사용하여 시스템 카탈로그를 수정하고 토스트 테이블을 참조하거나 수정할 수 있습니다. &lt;code&gt;sepgsql&lt;/code&gt; 이 활성화 되면 이러한 작업이 금지됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc78e0117d012c08a955c11c85e0b86286d746a5" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If a default value is defined for a particular column, it overrides any default associated with the domain. In turn, the domain default overrides any default value associated with the underlying data type.</source>
          <target state="translated">기본 표현식은 열 값을 지정하지 않은 모든 삽입 조작에 사용됩니다. 특정 열에 기본값이 정의되어 있으면 도메인과 관련된 모든 기본값이 무시됩니다. 또한 도메인 기본값은 기본 데이터 형식과 관련된 모든 기본값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="e924dec24aeaf46efa87502acfc94f6cc77685ce" translate="yes" xml:space="preserve">
          <source>The default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.</source>
          <target state="translated">기본 표현식은 열 값을 지정하지 않은 모든 삽입 조작에 사용됩니다. 열에 대한 기본값이 없으면 기본값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="5c475e2d48f46531de3913f26ad3045b4e6daa74" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;. With &lt;code&gt;ORDER BY&lt;/code&gt;, this sets the frame to be all rows from the partition start up through the current row's last &lt;code&gt;ORDER BY&lt;/code&gt; peer. Without &lt;code&gt;ORDER BY&lt;/code&gt;, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</source>
          <target state="translated">기본 프레이밍 옵션은 &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; 입니다 . 이는 &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; 와 동일 합니다. &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하면 파티션 시작부터 현재 행의 마지막 &lt;code&gt;ORDER BY&lt;/code&gt; 피어 까지의 모든 행이되도록 프레임이 설정 됩니다. &lt;code&gt;ORDER BY&lt;/code&gt; 가 없으면 모든 행이 현재 행의 피어가되기 때문에 파티션의 모든 행이 창 프레임에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9ba2008544bbedbbd493b6d70ae946d72bc7ec" translate="yes" xml:space="preserve">
          <source>The default framing option is &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt;, which is the same as &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt;; it sets the frame to be all rows from the partition start up through the current row's last &lt;em&gt;peer&lt;/em&gt; (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause considers equivalent to the current row; all rows are peers if there is no &lt;code&gt;ORDER BY&lt;/code&gt;). In general, &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition, regardless of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; means that the frame starts or ends with the current row; but in &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode it means that the frame starts or ends with the current row's first or last peer in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. The &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; options vary in meaning depending on the frame mode. In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many rows before or after the current row. In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a &lt;em&gt;peer group&lt;/em&gt; is a group of rows that are equivalent according to the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause. In &lt;code&gt;RANGE&lt;/code&gt; mode, use of an &lt;code&gt;offset&lt;/code&gt; option requires that there be exactly one &lt;code&gt;ORDER BY&lt;/code&gt; column in the window definition. Then the frame contains those rows whose ordering column value is no more than &lt;code&gt;offset&lt;/code&gt; less than (for &lt;code&gt;PRECEDING&lt;/code&gt;) or more than (for &lt;code&gt;FOLLOWING&lt;/code&gt;) the current row's ordering column value. In these cases the data type of the &lt;code&gt;offset&lt;/code&gt; expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. In all these cases, the value of the &lt;code&gt;offset&lt;/code&gt; must be non-null and non-negative. Also, while the &lt;code&gt;offset&lt;/code&gt; does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.</source>
          <target state="translated">기본 프레이밍 옵션은 &lt;code&gt;RANGE UNBOUNDED PRECEDING&lt;/code&gt; 입니다 . 이는 &lt;code&gt;RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/code&gt; 와 같습니다 . 프레임을 파티션의 모든 행이 현재 행의 마지막 &lt;em&gt;피어&lt;/em&gt; (창의 &lt;code&gt;ORDER BY&lt;/code&gt; 절이 현재 행과 동등한 것으로 간주하는 행 )로 설정합니다. &lt;code&gt;ORDER BY&lt;/code&gt; 가 없으면 모든 행은 피어 입니다. 일반적으로 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 수단 프레임들은 파티션의 첫 번째 행과 마찬가지로 시작한다는 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; 의 수단에 관계없이, 파티션의 마지막 행과 프레임 단부 &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 양식. 에서는 &lt;code&gt;ROWS&lt;/code&gt; 모드 &lt;code&gt;CURRENT ROW&lt;/code&gt; 프레임이 시작되거나, 현재 행이 끝나는 수단; 그러나 &lt;code&gt;RANGE&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; 모드에서는 &lt;code&gt;ORDER BY&lt;/code&gt; 순서 에서 프레임이 현재 행의 첫 번째 또는 마지막 피어로 시작하거나 끝나는 것을 의미합니다 . &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; 옵션은 프레임 모드에 따라 의미가 달라집니다. 에서는 &lt;code&gt;ROWS&lt;/code&gt; 모드에서는 &lt;code&gt;offset&lt;/code&gt; 나타내는 정수이고 그 프레임 시작하거나 끝나는 이전 또는 현재 행 이후 많은 행. 에서 &lt;code&gt;GROUPS&lt;/code&gt; 모드에서, &lt;code&gt;offset&lt;/code&gt; 는 현재 행의 피어 그룹 전후에 많은 피어 그룹이 프레임을 시작 또는 종료 함을 나타내는 정수입니다. 여기서 &lt;em&gt;피어 그룹&lt;/em&gt; 은 창의 &lt;code&gt;ORDER BY&lt;/code&gt; 절 에 따라 동등한 행 그룹입니다 . 에서 &lt;code&gt;RANGE&lt;/code&gt; 의 모드, 사용 &lt;code&gt;offset&lt;/code&gt; 옵션은 정확히 하나가 될 것을 요구 &lt;code&gt;ORDER BY&lt;/code&gt; 창 정의에 열입니다. 그런 다음 그 프레임 순서 열 값 이하이다 행만 포함 &lt;code&gt;offset&lt;/code&gt; 이하 (보다 &lt;code&gt;PRECEDING&lt;/code&gt; ) 이상 (보다 &lt;code&gt;FOLLOWING&lt;/code&gt; 현재 행의 순서 열 값). 이 경우 &lt;code&gt;offset&lt;/code&gt; 의 데이터 유형식은 순서 열의 데이터 유형에 따라 다릅니다. 숫자 순서 열의 경우 일반적으로 순서 열과 동일한 유형이지만 날짜 시간 순서 열의 경우 &lt;code&gt;interval&lt;/code&gt; 입니다. 이 모든 경우에, &lt;code&gt;offset&lt;/code&gt; 의 값은 널이 아니고 음이 아니어야합니다. 또한 &lt;code&gt;offset&lt;/code&gt; 은 단순한 상수 일 필요는 없지만 변수, 집계 함수 또는 창 함수를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="585bb809ddf49c27ccd679a2aefbbe26ae6b7fc7" translate="yes" xml:space="preserve">
          <source>The default is 1 on supported systems, otherwise 0. This value can be overridden for tables in a particular tablespace by setting the tablespace parameter of the same name (see &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt;).</source>
          <target state="translated">지원되는 시스템에서 기본값은 1이고, 그렇지 않으면 0입니다.이 이름은 동일한 이름의 tablespace 매개 변수를 설정하여 특정 테이블 스페이스의 테이블에 대해 대체 될 수 있습니다 ( &lt;a href=&quot;sql-altertablespace&quot;&gt;ALTER TABLESPACE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e91abeb434a6ce9f069e1f28ad61aa04fc26c2bb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;+&lt;/code&gt; on Unix systems (corresponding to the default editor &lt;code&gt;vi&lt;/code&gt;, and useful for many other common editors); but there is no default on Windows systems.</source>
          <target state="translated">기본값은 Unix 시스템에서 &lt;code&gt;+&lt;/code&gt; 입니다 (기본 편집기 &lt;code&gt;vi&lt;/code&gt; 에 해당하며 다른 많은 일반 편집기에 유용합니다). 그러나 Windows 시스템에는 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="20bd35f00ae043441f0cf7d67ea091592c87a851" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;CONTENT&lt;/code&gt;, so all forms of XML data are allowed.</source>
          <target state="translated">기본값은 &lt;code&gt;CONTENT&lt;/code&gt; 이므로 모든 형식의 XML 데이터가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="520d36bf5a7163373f8a236d77b263a2c0a04d44" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;TLSv1&lt;/code&gt;, mainly to support older versions of the OpenSSL library. You might want to set this to a higher value if all software components can support the newer protocol versions.</source>
          <target state="translated">기본값은 &lt;code&gt;TLSv1&lt;/code&gt; 이며 주로 이전 버전의 OpenSSL 라이브러리를 지원합니다. 모든 소프트웨어 구성 요소가 최신 프로토콜 버전을 지원할 수있는 경우이 값을 더 높은 값으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="231c42f70ffe5e8ab4244e5bdc8f6dbabaa3b107" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;none&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">기본값은 &lt;code&gt;none&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd107bd07370addfaeb12f86e3bf6c56137f5dc1" translate="yes" xml:space="preserve">
          <source>The default is simple query protocol. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;Chapter 52&lt;/a&gt; for more information.)</source>
          <target state="translated">기본은 단순 쿼리 프로토콜입니다. (자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol.html&quot;&gt;52 장&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="c6f72dd6acfbb83ab51b40e408e5dc009e36a5da" translate="yes" xml:space="preserve">
          <source>The default maximum segment size is 32 MB, and the default maximum total size is 2097152 pages. A page is almost always 4096 bytes except in unusual kernel configurations with &amp;ldquo;huge pages&amp;rdquo; (use &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; to verify).</source>
          <target state="translated">기본 최대 세그먼트 크기는 32MB이고 기본 최대 총 크기는 2097152 페이지입니다. &quot;거대한 페이지&quot;가있는 비정상적인 커널 구성을 제외하고 페이지는 거의 항상 4096 바이트입니다 ( &lt;code&gt;getconf PAGE_SIZE&lt;/code&gt; 를 사용 하여 확인).</target>
        </trans-unit>
        <trans-unit id="d525664dcf3bd05b109fdf34118093a16b891bcb" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0600&lt;/code&gt;, meaning only the server owner can read or write the log files. The other commonly useful setting is &lt;code&gt;0640&lt;/code&gt;, allowing members of the owner's group to read the files. Note however that to make use of such a setting, you'll need to alter &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; to store the files somewhere outside the cluster data directory. In any case, it's unwise to make the log files world-readable, since they might contain sensitive data.</source>
          <target state="translated">기본 권한은 &lt;code&gt;0600&lt;/code&gt; 이므로 서버 소유자 만 로그 파일을 읽거나 쓸 수 있습니다. 일반적으로 유용한 다른 설정은 &lt;code&gt;0640&lt;/code&gt; 이므로 소유자 그룹의 구성원이 파일을 읽을 수 있습니다. 그러나 이러한 설정을 사용하려면 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; 를 변경 하여 파일을 클러스터 데이터 디렉토리 외부에 저장해야합니다. 어쨌든 로그 파일은 민감한 데이터를 포함 할 수 있으므로 세계적으로 읽을 수 있도록 만드는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2132a47fb8ed97625d8e6972b86c9c464704580" translate="yes" xml:space="preserve">
          <source>The default permissions are &lt;code&gt;0777&lt;/code&gt;, meaning anyone can connect. Reasonable alternatives are &lt;code&gt;0770&lt;/code&gt; (only user and group, see also &lt;code&gt;unix_socket_group&lt;/code&gt;) and &lt;code&gt;0700&lt;/code&gt; (only user). (Note that for a Unix-domain socket, only write permission matters, so there is no point in setting or revoking read or execute permissions.)</source>
          <target state="translated">기본 권한은 &lt;code&gt;0777&lt;/code&gt; 이므로 누구나 연결할 수 있습니다. 합리적인 대안은 &lt;code&gt;0770&lt;/code&gt; (사용자 및 그룹 만, &lt;code&gt;unix_socket_group&lt;/code&gt; 참조 ) 및 &lt;code&gt;0700&lt;/code&gt; (사용자 만)입니다. (유닉스 도메인 소켓의 경우 쓰기 권한 만 중요하므로 읽기 또는 실행 권한을 설정하거나 취소 할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="68b85b4979bd5c75a82926a217579dec94acad6f" translate="yes" xml:space="preserve">
          <source>The default roles are described in &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;Table 21.1&lt;/a&gt;. Note that the specific permissions for each of the default roles may change in the future as additional capabilities are added. Administrators should monitor the release notes for changes.</source>
          <target state="translated">기본 역할은 &lt;a href=&quot;default-roles#DEFAULT-ROLES-TABLE&quot;&gt;표 21.1에&lt;/a&gt; 설명되어 있습니다. 추가 기능이 추가되면 각 기본 역할에 대한 특정 권한이 향후 변경 될 수 있습니다. 관리자는 변경 사항에 대해 릴리스 정보를 모니터링해야합니다.</target>
        </trans-unit>
        <trans-unit id="252df4a98d09d9259c2e1911dffde240009cf803" translate="yes" xml:space="preserve">
          <source>The default set of collations provided by &lt;code&gt;libc&lt;/code&gt; map directly to the locales installed in the operating system, which can be listed using the command &lt;code&gt;locale -a&lt;/code&gt;. In case a &lt;code&gt;libc&lt;/code&gt; collation is needed that has different values for &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, or if new locales are installed in the operating system after the database system was initialized, then a new collation may be created using the &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; command. New operating system locales can also be imported en masse using the &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt;&lt;code&gt;pg_import_system_collations()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 가 제공하는 기본 데이터 정렬 세트는 운영 체제에 설치된 로케일에 직접 매핑되며 &lt;code&gt;locale -a&lt;/code&gt; 명령을 사용하여 나열 할 수 있습니다 . &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 에 대해 다른 값을 갖는 &lt;code&gt;libc&lt;/code&gt; 데이터 정렬이 필요한 경우 또는 데이터베이스 시스템이 초기화 된 후 운영 체제에 새 로케일이 설치된 경우 &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt; 명령을 사용하여 새 데이터 정렬이 작성 될 수 있습니다 . &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-COLLATION&quot;&gt; &lt;code&gt;pg_import_system_collations()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 새로운 운영 체제 로케일을 일괄 적으로 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fa3c32f18b7a363e1e30df22bf5f90a31fa97a8" translate="yes" xml:space="preserve">
          <source>The default settings tend to suffice for normal installations. On HP-UX 10, the factory default for &lt;code&gt;SEMMNS&lt;/code&gt; is 128, which might be too low for larger database sites.</source>
          <target state="translated">기본 설치는 일반 설치에 충분합니다. HP-UX 10에서 &lt;code&gt;SEMMNS&lt;/code&gt; 의 출하시 기본값 은 128이며 더 큰 데이터베이스 사이트에는 너무 낮을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44e22ca1caa169ea01c4c21799c6c36ccb13234f" translate="yes" xml:space="preserve">
          <source>The default tablespace for the database. Within this database, all tables for which &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltablespace&lt;/code&gt; is zero will be stored in this tablespace; in particular, all the non-shared system catalogs will be there.</source>
          <target state="translated">데이터베이스의 기본 테이블 스페이스입니다. 이 데이터베이스 내에서 &lt;code&gt;pg_class&lt;/code&gt; 의 모든 테이블 . &lt;code&gt;reltablespace&lt;/code&gt; 가 0 이면 이 테이블 스페이스에 저장됩니다. 특히 모든 비공유 시스템 카탈로그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="80289ade38539d0a5fbe52bfa6a8f6f1dac442e4" translate="yes" xml:space="preserve">
          <source>The default test scenario is also quite sensitive to how long it's been since the tables were initialized: accumulation of dead rows and dead space in the tables changes the results. To understand the results you must keep track of the total number of updates and when vacuuming happens. If autovacuum is enabled it can result in unpredictable changes in measured performance.</source>
          <target state="translated">기본 테스트 시나리오는 또한 테이블이 초기화 된 이후의 시간에 매우 민감합니다. 테이블에 데드 행과 데드 스페이스가 누적되면 결과가 변경됩니다. 결과를 이해하려면 총 업데이트 수와 진공 청소기 청소시기를 추적해야합니다. 자동 진공 기능이 활성화되면 측정 된 성능에 예기치 않은 변화가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9132263848d1108e0d8602af59d87e147d73248d" translate="yes" xml:space="preserve">
          <source>The default thresholds and scale factors are taken from &lt;code&gt;postgresql.conf&lt;/code&gt;, but it is possible to override them (and many other autovacuum control parameters) on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. If a setting has been changed via a table's storage parameters, that value is used when processing that table; otherwise the global settings are used. See &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;Section 19.10&lt;/a&gt; for more details on the global settings.</source>
          <target state="translated">기본 임계 값 및 스케일 팩터는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 가져 오지만 테이블별로이를 무시할 수 있습니다 (및 다른 많은 자동 진공 제어 파라미터). 자세한 내용은 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;스토리지 매개 변수&lt;/a&gt; 를 참조하십시오. 테이블의 스토리지 매개 변수를 통해 설정이 변경된 경우 해당 테이블을 처리 할 때 해당 값이 사용됩니다. 그렇지 않으면 전역 설정이 사용됩니다. 글로벌 설정에 대한 자세한 내용 &lt;a href=&quot;runtime-config-autovacuum&quot;&gt;은 19.10 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0424e3dc5096d9c8dbd34cb8d06e5315c54e045d" translate="yes" xml:space="preserve">
          <source>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</source>
          <target state="translated">기본 시간대는 UTC로부터 상수 숫자 오프셋으로 지정됩니다. 따라서 DST 경계에서 날짜 / 시간 산술을 수행 할 때는 일광 절약 시간에 적응할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfbfb39fe00c30f34ca2449d77325fd4667682f6" translate="yes" xml:space="preserve">
          <source>The default timing of the trigger. See the &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation for details of these constraint options. This can only be specified for constraint triggers.</source>
          <target state="translated">트리거의 기본 타이밍. 이러한 제약 조건 옵션에 대한 자세한 내용은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 설명서를 참조하십시오. 구속 조건 트리거에 대해서만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7cc14aa1c7871e1d91e9c6189dd189cdc4b1317" translate="yes" xml:space="preserve">
          <source>The default value can be an expression, which will be evaluated whenever the default value is inserted (&lt;em&gt;not&lt;/em&gt; when the table is created). A common example is for a &lt;code&gt;timestamp&lt;/code&gt; column to have a default of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, so that it gets set to the time of row insertion. Another common example is generating a &amp;ldquo;serial number&amp;rdquo; for each row. In PostgreSQL this is typically done by something like:</source>
          <target state="translated">기본값은 표현식 일 수 있으며 , 테이블을 작성할 때가 &lt;em&gt;아니라&lt;/em&gt; 기본값을 삽입 할 때마다 평가됩니다 . 일반적인 예는 &lt;code&gt;timestamp&lt;/code&gt; 열의 기본값이 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 이므로 행 삽입 시간으로 설정됩니다. 또 다른 일반적인 예는 각 행에 대해 &quot;일련 번호&quot;를 생성하는 것입니다. PostgreSQL에서는 일반적으로 다음과 같은 방법으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b0db30e831b0c9d520dd21139ba84ee034c9c6b" translate="yes" xml:space="preserve">
          <source>The default value for the data type. If this is omitted, the default is null.</source>
          <target state="translated">데이터 유형의 기본값입니다. 생략하면 기본값은 null입니다.</target>
        </trans-unit>
        <trans-unit id="ee14fce3a3ca851f605a2ff7d5b6a51a01fb240b" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt;. This setting supports shared use of a database (where no users have private schemas, and all share use of &lt;code&gt;public&lt;/code&gt;), private per-user schemas, and combinations of these. Other effects can be obtained by altering the default search path setting, either globally or per-user.</source>
          <target state="translated">이 매개 변수의 기본값은 &lt;code&gt;&quot;$user&quot;, public&lt;/code&gt; 입니다. 이 설정은 데이터베이스의 공유 사용 (개인 스키마가없는 사용자 및 모든 &lt;code&gt;public&lt;/code&gt; 공유 사용 ), 개인별 사용자 스키마 및 이들의 조합을 지원합니다. 기본 검색 경로 설정을 전체 또는 사용자별로 변경하여 다른 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85d16eca710f45efd17caf29c22cdac95ac6757a" translate="yes" xml:space="preserve">
          <source>The default value for this parameter is &lt;code&gt;'$libdir'&lt;/code&gt;. If the value is set to an empty string, the automatic path search is turned off.</source>
          <target state="translated">이 매개 변수의 기본값은 &lt;code&gt;'$libdir'&lt;/code&gt; 입니다. 값이 빈 문자열로 설정되면 자동 경로 검색이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="71d008eed3fec13080aed7c6d124a51c1f2df8b8" translate="yes" xml:space="preserve">
          <source>The default value is 2.</source>
          <target state="translated">기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="d8e9c33db68a29a970a8558f211b5f4b07ef1edd" translate="yes" xml:space="preserve">
          <source>The default value is 4.</source>
          <target state="translated">기본값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="ca161bfe7f68575f9b78d9b22cc20c4f61990ca6" translate="yes" xml:space="preserve">
          <source>The default value is an empty string, which results in all temporary objects being created in the default tablespace of the current database.</source>
          <target state="translated">기본값은 빈 문자열이므로 현재 데이터베이스의 기본 테이블 스페이스에 모든 임시 오브젝트가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2dbc96deb9627171cbe40ca7523d55ca78505616" translate="yes" xml:space="preserve">
          <source>The default value is defined as the value that the parameter would have had, if no &lt;code&gt;SET&lt;/code&gt; had ever been issued for it in the current session. The actual source of this value might be a compiled-in default, the configuration file, command-line options, or per-database or per-user default settings. This is subtly different from defining it as &amp;ldquo;the value that the parameter had at session start&amp;rdquo;, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">기본값 은 현재 세션에서 &lt;code&gt;SET&lt;/code&gt; 이 발행 되지 않은 경우 매개 변수가 가진 값으로 정의됩니다 . 이 값의 실제 소스는 컴파일 된 기본값, 구성 파일, 명령 행 옵션 또는 데이터베이스 또는 사용자 별 기본 설정일 수 있습니다. 이 값은&amp;ldquo;세션 시작시 매개 변수가 가진 값&amp;rdquo;으로 정의하는 것과 미묘하게 다릅니다. 값이 구성 파일에서 온 경우 구성 파일에서 지정한 값으로 재설정되기 때문입니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7169dc9a643791bfe51c929b266f11a33c289429" translate="yes" xml:space="preserve">
          <source>The default value is three connections. The value must be less than &lt;code&gt;max_connections&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">기본값은 3 개의 연결입니다. 값은 &lt;code&gt;max_connections&lt;/code&gt; 보다 작아야합니다 . 이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72f22d9e98b0402b3ffa342734437db31335a193" translate="yes" xml:space="preserve">
          <source>The default value of this setting is the empty string, which disables the feature. It can be set to &lt;code&gt;all&lt;/code&gt; to check all records, or to a comma-separated list of resource managers to check only records originating from those resource managers. Currently, the supported resource managers are &lt;code&gt;heap&lt;/code&gt;, &lt;code&gt;heap2&lt;/code&gt;, &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;sequence&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;brin&lt;/code&gt;, and &lt;code&gt;generic&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">이 설정의 기본값은 빈 문자열이며 기능을 비활성화합니다. 모든 레코드를 확인하거나 쉼표로 구분 된 자원 관리자 목록 으로 &lt;code&gt;all&lt;/code&gt; 설정하여 해당 자원 관리자에서 발생하는 레코드 만 점검 하도록 설정할 수 있습니다 . 현재 지원되는 자원 관리자는 &lt;code&gt;heap&lt;/code&gt; , &lt;code&gt;heap2&lt;/code&gt; , &lt;code&gt;btree&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;gin&lt;/code&gt; , &lt;code&gt;gist&lt;/code&gt; , &lt;code&gt;sequence&lt;/code&gt; , &lt;code&gt;spgist&lt;/code&gt; , &lt;code&gt;brin&lt;/code&gt; 및 &lt;code&gt;generic&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9068090248fdb711a8f2a412ca5077ebbda170" translate="yes" xml:space="preserve">
          <source>The defined collation of the column, or zero if the column is not of a collatable data type.</source>
          <target state="translated">열의 정의 된 데이터 정렬 또는 열이 데이터 가능한 데이터 형식이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="b0e121be440089b477e6ea25c5d7cb8d2a246664" translate="yes" xml:space="preserve">
          <source>The definitions of the columns exposed by the view are shown in &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;Table F.15&lt;/a&gt;.</source>
          <target state="translated">뷰에 의해 노출 된 컬럼의 정의는 &lt;a href=&quot;pgbuffercache#PGBUFFERCACHE-COLUMNS&quot;&gt;표 F.15에&lt;/a&gt; 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0177656a1475222b9e9f01f048f945368cb6d" translate="yes" xml:space="preserve">
          <source>The delay occurs once the database in recovery has reached a consistent state, until the standby is promoted or triggered. After that the standby will end recovery without further waiting.</source>
          <target state="translated">대기가 승격 또는 트리거 될 때까지 복구중인 데이터베이스가 일관된 상태에 도달하면 지연이 발생합니다. 그 후 대기는 더 이상 기다리지 않고 복구를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="37c54600b84522926deb2fb64ab7c8c51ddae0fc" translate="yes" xml:space="preserve">
          <source>The delay occurs only on WAL records for transaction commits. Other records are replayed as quickly as possible, which is not a problem because MVCC visibility rules ensure their effects are not visible until the corresponding commit record is applied.</source>
          <target state="translated">트랜잭션 커밋에 대한 WAL 레코드에서만 지연이 발생합니다. 다른 레코드는 가능한 빨리 재생되는데, 이는 MVCC 가시성 규칙이 해당 커밋 레코드가 적용될 때까지 그 효과가 보이지 않도록하기 때문에 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="790720978a39aefa71d264470fa610449c099e01" translate="yes" xml:space="preserve">
          <source>The delimiter character to be used between values in arrays made of this type.</source>
          <target state="translated">이 유형으로 구성된 배열의 값 사이에 사용되는 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e3f72476c5f4c3f27d14849d70a712b70cac2da9" translate="yes" xml:space="preserve">
          <source>The dependent object can be dropped separately from the referenced object, and should be automatically dropped (regardless of &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; mode) if the referenced object is dropped. Example: a named constraint on a table is made auto-dependent on the table, so that it will go away if the table is dropped.</source>
          <target state="translated">종속 오브젝트는 참조 된 오브젝트와 별도로 삭제 될 수 있으며 참조 된 오브젝트가 삭제 된 경우 &lt;code&gt;RESTRICT&lt;/code&gt; 또는 &lt;code&gt;CASCADE&lt;/code&gt; 모드에 관계없이 자동으로 삭제되어야합니다 . 예 : 테이블의 명명 된 제약 조건은 테이블에 자동으로 종속되므로 테이블을 삭제하면 사라집니다.</target>
        </trans-unit>
        <trans-unit id="42b52b99ac2341cf62bd00d9b5e1bc3f8c4f0ef2" translate="yes" xml:space="preserve">
          <source>The dependent object is a member of the &lt;em&gt;extension&lt;/em&gt; that is the referenced object (see &lt;a href=&quot;catalog-pg-extension&quot;&gt;&lt;code&gt;pg_extension&lt;/code&gt;&lt;/a&gt;). The dependent object can be dropped only via &lt;code&gt;DROP EXTENSION&lt;/code&gt; on the referenced object. Functionally this dependency type acts the same as an &lt;code&gt;INTERNAL&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">종속 객체는 참조 객체 인 &lt;em&gt;확장&lt;/em&gt; 의 멤버입니다 ( &lt;a href=&quot;catalog-pg-extension&quot;&gt; &lt;code&gt;pg_extension&lt;/code&gt; &lt;/a&gt; 참조 ). 종속 개체는 참조 된 개체에서 &lt;code&gt;DROP EXTENSION&lt;/code&gt; 을 통해서만 삭제할 수 있습니다 . 기능적으로이 종속성 유형은 &lt;code&gt;INTERNAL&lt;/code&gt; 종속성 과 동일하게 작동 하지만 명확성을 위해 pg_dump를 단순화하기 위해 별도로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf57c8a0f5e570bb9686592bde8b3b28f101a435" translate="yes" xml:space="preserve">
          <source>The dependent object is not a member of the extension that is the referenced object (and so it should not be ignored by pg_dump), but it cannot function without the extension and should be auto-dropped if the extension is. The dependent object may be dropped on its own as well. Functionally this dependency type acts the same as an &lt;code&gt;AUTO&lt;/code&gt; dependency, but it's kept separate for clarity and to simplify pg_dump.</source>
          <target state="translated">종속 객체는 참조 객체 인 확장의 멤버가 아니므로 pg_dump에 의해 무시되어서는 안됩니다. 그러나 확장 없이는 기능을 수행 할 수 없으며 확장이 있으면 자동 드롭되어야합니다. 종속 오브젝트도 자체적으로 삭제 될 수 있습니다. 기능적으로이 종속성 유형은 &lt;code&gt;AUTO&lt;/code&gt; 종속성 과 동일하게 작동 하지만 명확성을 위해 pg_dump를 단순화하기 위해 별도로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="39aa74188fe1f062ac474926c65191d5babb5508" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation. A direct &lt;code&gt;DROP&lt;/code&gt; of the dependent object will be disallowed outright (we'll tell the user to issue a &lt;code&gt;DROP&lt;/code&gt; against the referenced object, instead). A &lt;code&gt;DROP&lt;/code&gt; of the referenced object will result in automatically dropping the dependent object whether &lt;code&gt;CASCADE&lt;/code&gt; is specified or not. If the dependent object has to be dropped due to a dependency on some other object being removed, its drop is converted to a drop of the referenced object, so that &lt;code&gt;NORMAL&lt;/code&gt; and &lt;code&gt;AUTO&lt;/code&gt; dependencies of the dependent object behave much like they were dependencies of the referenced object. Example: a view's &lt;code&gt;ON SELECT&lt;/code&gt; rule is made internally dependent on the view, preventing it from being dropped while the view remains. Dependencies of the rule (such as tables it refers to) act as if they were dependencies of the view.</source>
          <target state="translated">종속 오브젝트는 참조 된 오브젝트 작성의 일부로 작성되었으며 실제로 내부 구현의 일부일뿐입니다. 종속 객체 의 직접 &lt;code&gt;DROP&lt;/code&gt; 는 완전히 허용되지 않습니다 ( 대신 사용자에게 참조 된 객체에 대해 &lt;code&gt;DROP&lt;/code&gt; 을 발행하도록 지시 합니다). 참조 된 오브젝트 의 &lt;code&gt;DROP&lt;/code&gt; 은 &lt;code&gt;CASCADE&lt;/code&gt; 의 지정 여부에 관계없이 종속 오브젝트를 자동으로 삭제합니다 . 제거되는 다른 오브젝트에 대한 종속성으로 인해 종속 오브젝트를 삭제해야하는 경우 해당 삭제는 참조 된 오브젝트의 드롭으로 변환되므로 &lt;code&gt;NORMAL&lt;/code&gt; 및 &lt;code&gt;AUTO&lt;/code&gt; 종속 개체의 종속성은 참조 된 개체의 종속성처럼 작동합니다. 예 : 뷰의 &lt;code&gt;ON SELECT&lt;/code&gt; 규칙은 뷰에 내부적으로 종속되므로 뷰가 유지되는 동안 뷰가 삭제되지 않습니다. 규칙의 종속성 (예 : 참조하는 테이블)은 마치 뷰의 종속성 인 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f08ad4e0433fd5acac3297aba03b2acf8ab1183" translate="yes" xml:space="preserve">
          <source>The dependent object was created as part of creation of the referenced object, and is really just a part of its internal implementation; however, unlike &lt;code&gt;INTERNAL&lt;/code&gt;, there is more than one such referenced object. The dependent object must not be dropped unless at least one of these referenced objects is dropped; if any one is, the dependent object should be dropped whether or not &lt;code&gt;CASCADE&lt;/code&gt; is specified. Also unlike &lt;code&gt;INTERNAL&lt;/code&gt;, a drop of some other object that the dependent object depends on does not result in automatic deletion of any partition-referenced object. Hence, if the drop does not cascade to at least one of these objects via some other path, it will be refused. (In most cases, the dependent object shares all its non-partition dependencies with at least one partition-referenced object, so that this restriction does not result in blocking any cascaded delete.) Primary and secondary partition dependencies behave identically except that the primary dependency is preferred for use in error messages; hence, a partition-dependent object should have one primary partition dependency and one or more secondary partition dependencies. Note that partition dependencies are made in addition to, not instead of, any dependencies the object would normally have. This simplifies &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; operations: the partition dependencies need only be added or removed. Example: a child partitioned index is made partition-dependent on both the partition table it is on and the parent partitioned index, so that it goes away if either of those is dropped, but not otherwise. The dependency on the parent index is primary, so that if the user tries to drop the child partitioned index, the error message will suggest dropping the parent index instead (not the table).</source>
          <target state="translated">종속 오브젝트는 참조 된 오브젝트 작성의 일부로 작성되었으며 실제로는 내부 구현의 일부일뿐입니다. 그러나 &lt;code&gt;INTERNAL&lt;/code&gt; 과는 달리 이러한 참조 된 오브젝트가 둘 이상 있습니다. 이러한 참조 된 객체 중 하나 이상을 삭제하지 않으면 종속 객체를 삭제해서는 안됩니다. 하나라도 있으면 &lt;code&gt;CASCADE&lt;/code&gt; 의 지정 여부에 관계없이 종속 오브젝트를 삭제해야 합니다. &lt;code&gt;INTERNAL&lt;/code&gt; 와 달리종속 개체가 의존하는 다른 개체를 삭제해도 파티션 참조 개체가 자동으로 삭제되지는 않습니다. 따라서 낙하가 다른 경로를 통해 이러한 물체 중 적어도 하나에 계단식으로 배열되지 않으면 거부됩니다. (대부분의 경우 종속 오브젝트는 파티션이 아닌 모든 종속성을 하나 이상의 파티션 참조 오브젝트와 공유하므로이 제한으로 인해 계단식 삭제가 차단되지 않습니다.) 기본 및 보조 파티션 종속성은 기본 종속성을 제외하고 동일하게 작동합니다. 오류 메시지에 사용하는 것이 좋습니다. 따라서 파티션 종속 오브젝트에는 하나의 1 차 파티션 종속성과 하나 이상의 2 차 파티션 종속성이 있어야합니다. 객체가 일반적으로 가질 수있는 종속성 대신에 아니라 파티션 종속성이 만들어 짐에 유의하십시오.이것은 단순화 &lt;code&gt;ATTACH/DETACH PARTITION&lt;/code&gt; 작업 : 파티션 종속성은 추가 또는 제거 만하면됩니다. 예 : 하위 파티션 된 인덱스는 파티션 테이블에있는 파티션 테이블과 부모 파티션 된 인덱스 모두에서 파티션에 따라 달라 지므로 둘 중 하나가 삭제되면 사라지지만 그렇지 않은 경우에는 사라집니다. 부모 인덱스에 대한 종속성은 기본이므로 사용자가 자식 파티션 된 인덱스를 삭제하려고하면 오류 메시지가 대신 테이블이 아닌 부모 인덱스를 삭제하도록 제안합니다.</target>
        </trans-unit>
        <trans-unit id="7ba979debfd87ef975dc568dd7e8792b4269670b" translate="yes" xml:space="preserve">
          <source>The desired new version of the extension. This can be written as either an identifier or a string literal. If not specified, &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; attempts to update to whatever is shown as the default version in the extension's control file.</source>
          <target state="translated">확장의 원하는 새 버전입니다. 이것은 식별자 또는 문자열 리터럴로 작성 될 수 있습니다. 지정하지 않으면 &lt;code&gt;ALTER EXTENSION UPDATE&lt;/code&gt; 는 확장 프로그램의 제어 파일에 기본 버전으로 표시되는 내용으로 업데이트를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fbd0e34ca3a19b97d0aeb9f0e2c89bbf73246c51" translate="yes" xml:space="preserve">
          <source>The destination encoding name.</source>
          <target state="translated">대상 인코딩 이름입니다.</target>
        </trans-unit>
        <trans-unit id="acbe64874af1481c3f0cac1a6029d7f03fb77273" translate="yes" xml:space="preserve">
          <source>The details of these commands are not important here; the important point is that there are several separate updates involved to accomplish this rather simple operation. Our bank's officers will want to be assured that either all these updates happen, or none of them happen. It would certainly not do for a system failure to result in Bob receiving $100.00 that was not debited from Alice. Nor would Alice long remain a happy customer if she was debited without Bob being credited. We need a guarantee that if something goes wrong partway through the operation, none of the steps executed so far will take effect. Grouping the updates into a &lt;em&gt;transaction&lt;/em&gt; gives us this guarantee. A transaction is said to be &lt;em&gt;atomic&lt;/em&gt;: from the point of view of other transactions, it either happens completely or not at all.</source>
          <target state="translated">이 명령의 세부 사항은 여기서 중요하지 않습니다. 중요한 점은이 간단한 조작을 수행하기 위해 여러 개의 개별 업데이트가 관련되어 있다는 것입니다. 우리 은행의 임원들은 이러한 모든 업데이트가 발생하거나 전혀 발생하지 않도록 보장하고자합니다. Bob이 Alice로부터 인출되지 않은 $ 100.00를 받도록하는 것은 시스템 장애에 대해서는 확실하지 않습니다. 앨리스가 밥에게 크레딧을받지 않고 돈을 인출하면 오랫동안 행복한 고객으로 남아 있지 않을 것입니다. 작업 도중에 문제가 발생하면 지금까지 실행 된 단계 중 어느 것도 적용되지 않는다는 보장이 필요합니다. 업데이트를 &lt;em&gt;트랜잭션&lt;/em&gt; 으로 그룹화하면 이러한 보장이 제공됩니다. 거래는 &lt;em&gt;원 자성&lt;/em&gt; 이라고합니다&lt;em&gt;&lt;/em&gt;: 다른 거래의 관점에서 볼 때, 그것은 완전히 또는 전혀 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e98ae374f333e238cb54e40ccd57bf293c2950f" translate="yes" xml:space="preserve">
          <source>The dictionary accepts two options:</source>
          <target state="translated">사전에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a19f3de80263e9a6413003bf67d42fb29a4dfff8" translate="yes" xml:space="preserve">
          <source>The difference between enabling &lt;code&gt;log_duration&lt;/code&gt; and setting &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt; to zero is that exceeding &lt;code&gt;log_min_duration_statement&lt;/code&gt; forces the text of the query to be logged, but this option doesn't. Thus, if &lt;code&gt;log_duration&lt;/code&gt; is &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;log_min_duration_statement&lt;/code&gt; has a positive value, all durations are logged but the query text is included only for statements exceeding the threshold. This behavior can be useful for gathering statistics in high-load installations.</source>
          <target state="translated">가능의 차이 &lt;code&gt;log_duration&lt;/code&gt; 을 하고 설정 &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement을&lt;/a&gt; 제로로는 초과 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 의 쿼리의 텍스트를 기록 할 힘하지만,이 옵션을하지 않습니다. 따라서 &lt;code&gt;log_duration&lt;/code&gt; 이 &lt;code&gt;on&lt;/code&gt; 있고 &lt;code&gt;log_min_duration_statement&lt;/code&gt; 에 양수 값이 있으면 모든 기간이 기록되지만 임계 값을 초과하는 명령문에 대해서만 조회 텍스트가 포함됩니다. 이 동작은 고부하 설치에서 통계를 수집하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d6a3829cada6f81d9cef342af0288f96d331f4" translate="yes" xml:space="preserve">
          <source>The difference is that the query against the summary table has to get only one row from the table, whereas the direct query against &lt;code&gt;one_to_many&lt;/code&gt; must index scan and fetch a row for each entry.</source>
          <target state="translated">차이점은 요약 테이블에 대한 쿼리는 테이블에서 하나의 행만 가져와야하는 반면 &lt;code&gt;one_to_many&lt;/code&gt; 에 대한 직접 쿼리는 스캔을 인덱싱하고 각 항목에 대한 행을 가져와야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="638327d505052c3c14e5ba331469e70ba93f8131" translate="yes" xml:space="preserve">
          <source>The differences highlighted here are not all of them. In XQuery and the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility mode, and the W3C lists of &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;function library changes&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;language changes&lt;/a&gt; applied in that mode offer a more complete (but still not exhaustive) account of the differences. The compatibility mode cannot make the later languages exactly equivalent to XPath 1.0.</source>
          <target state="translated">여기에 강조된 차이점이 전부는 아닙니다. XQuery 및 2.0 이상 버전의 XPath에는 XPath 1.0 호환 모드가 있으며 해당 모드에서 적용된 &lt;a href=&quot;https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility&quot;&gt;함수 라이브러리 변경&lt;/a&gt; 및 &lt;a href=&quot;https://www.w3.org/TR/xpath20/#id-backwards-compatibility&quot;&gt;언어 변경&lt;/a&gt; 목록의 W3C 목록은 보다 완전한 (그러나 완전한 것은 아님) 차이점을 설명합니다. 호환성 모드는 이후 언어를 XPath 1.0과 정확히 동일하게 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e588858632409434bd776e63f92b5761c3db20c" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; contains symbolic links that point to each of the non-built-in tablespaces defined in the cluster. Although not recommended, it is possible to adjust the tablespace layout by hand by redefining these links. Under no circumstances perform this operation while the server is running. Note that in PostgreSQL 9.1 and earlier you will also need to update the &lt;code&gt;pg_tablespace&lt;/code&gt; catalog with the new locations. (If you do not, &lt;code&gt;pg_dump&lt;/code&gt; will continue to output the old tablespace locations.)</source>
          <target state="translated">&lt;code&gt;$PGDATA/pg_tblspc&lt;/code&gt; 디렉토리 에는 클러스터에 정의 된 각각의 내장되지 않은 테이블 스페이스를 가리키는 기호 링크가 있습니다. 권장되지는 않지만 이러한 링크를 재정 의하여 테이블 스페이스 레이아웃을 수동으로 조정할 수 있습니다. 서버가 실행되는 동안 어떠한 상황에서도이 작업을 수행하지 마십시오. PostgreSQL 9.1 및 이전 버전에서는 &lt;code&gt;pg_tablespace&lt;/code&gt; 카탈로그를 새 위치 로 업데이트해야합니다 . 그렇지 않으면 &lt;code&gt;pg_dump&lt;/code&gt; 는 이전 테이블 스페이스 위치를 계속 출력합니다.</target>
        </trans-unit>
        <trans-unit id="48e3d4bb3b396fb8ccb3377c9877d054f3fd3eaa" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;src/test/locale&lt;/code&gt; in the source distribution contains a test suite for PostgreSQL's locale support.</source>
          <target state="translated">소스 배포판의 &lt;code&gt;src/test/locale&lt;/code&gt; 디렉토리 에는 PostgreSQL의 로케일 지원을위한 테스트 스위트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f609b85a02a4ded47fa5c57a791418dd0d72112" translate="yes" xml:space="preserve">
          <source>The directory that will be used for the tablespace. The directory must exist (&lt;code&gt;CREATE TABLESPACE&lt;/code&gt; will not create it), should be empty, and must be owned by the PostgreSQL system user. The directory must be specified by an absolute path name.</source>
          <target state="translated">테이블 스페이스에 사용될 디렉토리입니다. 디렉토리가 존재해야하며 ( &lt;code&gt;CREATE TABLESPACE&lt;/code&gt; 는 디렉토리를 작성하지 않음) 비어 있어야하며 PostgreSQL 시스템 사용자가 소유해야합니다. 디렉토리는 절대 경로 이름으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9ae3d8cb40fd37366fec2ea07a50700e4c2316" translate="yes" xml:space="preserve">
          <source>The domain this constraint is on; 0 if not a domain constraint</source>
          <target state="translated">이 제약 조건이있는 도메인. 도메인 제약 조건이 아닌 경우 0</target>
        </trans-unit>
        <trans-unit id="66141cd3e18bcdc88d4a038dfc634ffad3fa560d" translate="yes" xml:space="preserve">
          <source>The drawback of this procedure is that it depends on the integrity of the client: if the client machine is untrusted or compromised, an attacker could run just about any program on port 113 and return any user name they choose. This authentication method is therefore only appropriate for closed networks where each client machine is under tight control and where the database and system administrators operate in close contact. In other words, you must trust the machine running the ident server. Heed the warning:</source>
          <target state="translated">이 절차의 단점은 클라이언트의 무결성에 따라 달라진다는 것입니다. 클라이언트 시스템이 신뢰할 수 없거나 손상된 경우 공격자는 포트 113에서 거의 모든 프로그램을 실행하고 선택한 사용자 이름을 반환 할 수 있습니다. 따라서이 인증 방법은 각 클라이언트 시스템이 엄격하게 제어되고 데이터베이스 및 시스템 관리자가 밀접하게 작동하는 폐쇄 형 네트워크에만 적합합니다. 즉, ID 서버를 실행하는 시스템을 신뢰해야합니다. 경고에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="13aa020c26befcd9c06640c85756679a7699e20c" translate="yes" xml:space="preserve">
          <source>The drawback of using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; in PostgreSQL is its performance impact. It slows character handling and prevents ordinary indexes from being used by &lt;code&gt;LIKE&lt;/code&gt;. For this reason use locales only if you actually need them.</source>
          <target state="translated">PostgreSQL에서 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 이외의 로케일 사용의 단점은 성능 영향입니다. 문자 처리 속도를 늦추고 &lt;code&gt;LIKE&lt;/code&gt; 에서 일반 색인을 사용하지 못하게 합니다. 이러한 이유로 로케일은 실제로 필요한 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ff3e6b54f5a69b71d88bd211c608fb1a58dc225c" translate="yes" xml:space="preserve">
          <source>The dump file produced by pg_dump does not contain the statistics used by the optimizer to make query planning decisions. Therefore, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; after restoring from a dump file to ensure optimal performance; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프 파일에는 쿼리 계획 결정을 내리기 위해 옵티마이 저가 사용하는 통계가 포함되어 있지 않습니다. 따라서 최적의 성능을 보장하기 위해 덤프 파일에서 복원 한 후 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 것이 좋습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="7b92c28f4a6038b16d370463cb2b0c497c1536e4" translate="yes" xml:space="preserve">
          <source>The dump script should not be expected to run completely without errors. In particular, because the script will issue &lt;code&gt;CREATE ROLE&lt;/code&gt; for every role existing in the source cluster, it is certain to get a &amp;ldquo;role already exists&amp;rdquo; error for the bootstrap superuser, unless the destination cluster was initialized with a different bootstrap superuser name. This error is harmless and should be ignored. Use of the &lt;code&gt;--clean&lt;/code&gt; option is likely to produce additional harmless error messages about non-existent objects, although you can minimize those by adding &lt;code&gt;--if-exists&lt;/code&gt;.</source>
          <target state="translated">덤프 스크립트가 오류없이 완전히 실행되지 않아야합니다. 특히 스크립트는 소스 클러스터에 존재하는 모든 역할에 대해 &lt;code&gt;CREATE ROLE&lt;/code&gt; 을 발행 하므로 대상 클러스터가 다른 부트 스트랩 수퍼 유저 이름으로 초기화되지 않은 경우 부트 스트랩 수퍼 유저에 대한 &quot;역할이 이미 존재&quot;오류가 발생합니다. 이 오류는 무해하며 무시해야합니다. &lt;code&gt;--clean&lt;/code&gt; 옵션을 사용하면 존재하지 않는 객체에 대해 무해한 오류 메시지가 추가로 생성 될 수 있지만 &lt;code&gt;--if-exists&lt;/code&gt; 를 추가하여이를 최소화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f3181a66ca9fbe6427fab730ca21eb224bb5bb9" translate="yes" xml:space="preserve">
          <source>The dumps produced by pg_dump are relative to &lt;code&gt;template0&lt;/code&gt;. This means that any languages, procedures, etc. added via &lt;code&gt;template1&lt;/code&gt; will also be dumped by pg_dump. As a result, when restoring, if you are using a customized &lt;code&gt;template1&lt;/code&gt;, you must create the empty database from &lt;code&gt;template0&lt;/code&gt;, as in the example above.</source>
          <target state="translated">pg_dump에 의해 생성 된 덤프는 &lt;code&gt;template0&lt;/code&gt; 에 상대적 입니다. 즉, &lt;code&gt;template1&lt;/code&gt; 을 통해 추가 된 모든 언어, 프로 시저 등도 pg_dump에 의해 덤프됩니다. 결과적으로, 복원 할 때 사용자 정의 된 &lt;code&gt;template1&lt;/code&gt; 을 사용하는 경우 위 예제와 같이 &lt;code&gt;template0&lt;/code&gt; 에서 빈 데이터베이스를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7817fb8368f1c7b07f344d07c4746bc348201b26" translate="yes" xml:space="preserve">
          <source>The easiest way to perform a base backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; can provide is required, you can also make a base backup using the low level API (see &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;).</source>
          <target state="translated">기본 백업을 수행하는 가장 쉬운 방법은 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; 도구 를 사용하는 것 입니다. 기본 파일을 일반 파일 또는 tar 아카이브로 작성할 수 있습니다. &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; 이 제공 할 수있는 것보다 더 많은 유연성 이 필요한 경우, 낮은 수준의 API를 사용하여 기본 백업을 만들 수도 있습니다 ( &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;25.3.3 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="29f1de90d9c685081e50b22b770744253403d7c5" translate="yes" xml:space="preserve">
          <source>The effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data, and the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it to &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; so that it is also fired on replicas.</source>
          <target state="translated">이 메커니즘의 효과는 기본 구성에서 트리거가 복제본에서 실행되지 않는 것입니다. 트리거가 원본에서 테이블간에 데이터를 전파하는 데 사용되는 경우 복제 시스템은 전파 된 데이터도 복제하므로 복제본에서 트리거가 두 번 실행되지 않아야합니다. 이는 복제로 이어질 수 있기 때문입니다. 그러나 외부 경보 작성과 같은 다른 목적으로 트리거를 사용하는 경우 복제본에서도 트리거되도록 &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; 으로 설정하는 것이 적절할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f70bcfbdc794c385378840673cf0a249c54a0a" translate="yes" xml:space="preserve">
          <source>The effective maximum for &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; is 0.95 * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;; a setting higher than that will be capped to the maximum. A value higher than &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; wouldn't make sense because an anti-wraparound autovacuum would be triggered at that point anyway, and the 0.95 multiplier leaves some breathing room to run a manual &lt;code&gt;VACUUM&lt;/code&gt; before that happens. As a rule of thumb, &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; should be set to a value somewhat below &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, leaving enough gap so that a regularly scheduled &lt;code&gt;VACUUM&lt;/code&gt; or an autovacuum triggered by normal delete and update activity is run in that window. Setting it too close could lead to anti-wraparound autovacuums, even though the table was recently vacuumed to reclaim space, whereas lower values lead to more frequent aggressive vacuuming.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 의 유효 최대 값 은 0.95입니다. * &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; ; 그보다 높은 설정은 최대 값으로 제한됩니다. &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 보다 높은 값 은 그 시점에서 랩 어라운드 autovacuum이 트리거되기 때문에 의미가 없으며 0.95 곱셈기 는 발생하기 전에 일부 호흡 공간을 수동 &lt;code&gt;VACUUM&lt;/code&gt; 으로 실행 합니다. 일반적으로 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 는 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 보다 약간 낮은 값으로 설정해야하며 정기적으로 예약 된 &lt;code&gt;VACUUM&lt;/code&gt; 이 되도록 충분한 간격을 유지해야합니다.또는 정상적인 삭제 및 업데이트 활동에 의해 트리거 된 자동 진공이 해당 창에서 실행됩니다. 테이블을 최근에 공간을 확보하기 위해 진공 청소기로 청소 했음에도 불구하고 너무 가까이 배치하면 랩 어라운드 방지 자동 진공이 발생할 수 있지만 값이 낮을수록 진공 청소기가 더 빈번해집니다.</target>
        </trans-unit>
        <trans-unit id="6acae8d5fe7431e883721a35bb83f27f6d33e399" translate="yes" xml:space="preserve">
          <source>The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, &lt;code&gt;pg_sleep_until&lt;/code&gt; is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier.</source>
          <target state="translated">수면 간격의 효과적인 해결 방법은 플랫폼마다 다릅니다. 0.01 초가 일반적인 값입니다. 수면 지연은 지정된 시간 이상 지속됩니다. 서버로드와 같은 요인에 따라 더 길어질 수 있습니다. 특히, &lt;code&gt;pg_sleep_until&lt;/code&gt; 은 지정된 시간에 정확하게 깨어날 것을 보장하지는 않지만 더 일찍 깨어나지 는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca3e0b7947e98767e7bc3c70b05110c06d007fc6" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET LOCAL&lt;/code&gt; last only till the end of the current transaction, whether committed or not. A special case is &lt;code&gt;SET&lt;/code&gt; followed by &lt;code&gt;SET LOCAL&lt;/code&gt; within a single transaction: the &lt;code&gt;SET LOCAL&lt;/code&gt; value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the &lt;code&gt;SET&lt;/code&gt; value will take effect.</source>
          <target state="translated">&lt;code&gt;SET LOCAL&lt;/code&gt; 의 효과는 커밋 여부에 관계없이 현재 트랜잭션이 끝날 때까지만 지속됩니다. 특별한 경우이다 &lt;code&gt;SET&lt;/code&gt; 다음에 &lt;code&gt;SET LOCAL&lt;/code&gt; 하나의 트랜잭션 내에서 다음 &lt;code&gt;SET LOCAL&lt;/code&gt; 값 (트랜잭션이 커밋 된 경우) 나중에 트랜잭션이 끝날 때까지 볼됩니다 만, &lt;code&gt;SET&lt;/code&gt; 의 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1963e14d77518dfe80e47bfcd05e2429f11a8bde" translate="yes" xml:space="preserve">
          <source>The effects of &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SET LOCAL&lt;/code&gt; are also canceled by rolling back to a savepoint that is earlier than the command.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 또는 &lt;code&gt;SET LOCAL&lt;/code&gt; 의 효과 는 명령 이전의 저장 점으로 롤백하여 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="005a74c57d93879fd436d69f089f03e96ff53b14" translate="yes" xml:space="preserve">
          <source>The elements of the &lt;code&gt;PARTITION BY&lt;/code&gt; list are interpreted in much the same fashion as elements of a &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt;, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular &lt;code&gt;GROUP BY&lt;/code&gt; clause. They are allowed here because windowing occurs after grouping and aggregation.</source>
          <target state="translated">의 요소 &lt;code&gt;PARTITION BY&lt;/code&gt; 목록은 요소와 거의 같은 방식으로 해석됩니다 &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 절&lt;/a&gt; 그들은 항상 간단한 표현과 결코 이름 또는 출력 열 수있는 것을 제외하고. 또 다른 차이점은 이러한 표현식에는 일반 &lt;code&gt;GROUP BY&lt;/code&gt; 절 에서 허용되지 않는 집계 함수 호출이 포함될 수 있다는 것 입니다. 그룹화 및 집계 후에 윈도우 화가 발생하므로 여기에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd51d8414173fa812e307883cf9daca455add1a4" translate="yes" xml:space="preserve">
          <source>The empty scalar sub-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed.</source>
          <target state="translated">빈 스칼라 sub-SELECT는 도메인 유형으로 간주되는 널값을 생성하므로 더 이상의 제한 조건 점검이 적용되지 않으며 삽입이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="750129d09bd31bb5985c26e665018fb53719c8d3" translate="yes" xml:space="preserve">
          <source>The encoding and locale settings must match those of the template database, except when &lt;code&gt;template0&lt;/code&gt; is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;. Copying such data would result in a database that is corrupt according to the new settings. &lt;code&gt;template0&lt;/code&gt;, however, is known to not contain any data or indexes that would be affected.</source>
          <target state="translated">&lt;code&gt;template0&lt;/code&gt; 을 template 로 사용하는 경우를 제외하고 인코딩 및 로캘 설정은 템플릿 데이터베이스의 설정과 로캘과 일치해야합니다 . 다른 데이터베이스에 지정된 인코딩과 일치하지 않는 데이터가 포함되어 있거나 정렬 순서가 &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 의 영향을받는 인덱스를 포함 할 수 있기 때문 입니다. 이러한 데이터를 복사하면 새 설정에 따라 데이터베이스가 손상됩니다. 그러나 &lt;code&gt;template0&lt;/code&gt; 은 영향을받는 데이터 나 인덱스를 포함하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ebfe8f29152790c8c19069e09027b276e20d6f" translate="yes" xml:space="preserve">
          <source>The encoding for a database is stored in the system catalog &lt;code&gt;pg_database&lt;/code&gt;. You can see it by using the &lt;code&gt;psql&lt;/code&gt;&lt;code&gt;-l&lt;/code&gt; option or the &lt;code&gt;\l&lt;/code&gt; command.</source>
          <target state="translated">데이터베이스 인코딩은 &lt;code&gt;pg_database&lt;/code&gt; 시스템 카탈로그에 저장됩니다 . &lt;code&gt;psql&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; 옵션 또는 &lt;code&gt;\l&lt;/code&gt; 명령 을 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b548a79db3b694cdb5c78e7ae46892fe80152d6" translate="yes" xml:space="preserve">
          <source>The encryption vector used will only be cryptographically strong if PostgreSQL is built with support for OpenSSL. In other cases, the transmission to the RADIUS server should only be considered obfuscated, not secured, and external security measures should be applied if necessary.</source>
          <target state="translated">사용 된 암호화 벡터는 PostgreSQL이 OpenSSL을 지원하도록 구축 된 경우에만 암호화 적으로 강력합니다. 다른 경우, RADIUS 서버로의 전송은 난독 처리되고 보안되지 않은 것으로 간주되어야하며 필요한 경우 외부 보안 조치를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="807f48853a85df34d9a80e7027652fd76ea8d1d2" translate="yes" xml:space="preserve">
          <source>The entries in the select list can be assigned names for subsequent processing, such as for use in an &lt;code&gt;ORDER BY&lt;/code&gt; clause or for display by the client application. For example:</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 절에서 사용하거나 클라이언트 응용 프로그램에서 표시하기 위해 선택 목록의 항목에 후속 처리를 위해 이름을 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ed44cca4375f0386d06f29a5cb471a7a637f589" translate="yes" xml:space="preserve">
          <source>The enumerator is a function &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; that returns &lt;code&gt;setof integer&lt;/code&gt;. It is essentially the reverse operation of the aggregator: given an array of integers, expand it into a set of rows. This is a wrapper around &lt;code&gt;unnest&lt;/code&gt;, which does the same thing for any array type.</source>
          <target state="translated">열거자는 &lt;code&gt;int_array_enum(integer[])&lt;/code&gt; 함수로 정수 &lt;code&gt;setof integer&lt;/code&gt; 을 반환 합니다 . 그것은 본질적으로 애그리 게이터의 역 동작입니다. 정수 배열이 주어지면 행 집합으로 확장하십시오. 이것은 &lt;code&gt;unnest&lt;/code&gt; 주위의 래퍼 이며 모든 배열 유형에 대해 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d14b9d4e54d6bcfb1eb32844ae2033e082cd8255" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PG_COLOR&lt;/code&gt; specifies whether to use color in diagnostics messages. Possible values are &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;PG_COLOR&lt;/code&gt; 는 진단 메시지에 색상을 사용할지 여부를 지정합니다. 가능한 값은 없습니다 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0960a83450dbd1eaf41a4a82cb1e20f4eb07da46" translate="yes" xml:space="preserve">
          <source>The error code (see &lt;a href=&quot;errcodes-appendix&quot;&gt;Appendix A&lt;/a&gt;) associated with the last SQL query's failure, or &lt;code&gt;00000&lt;/code&gt; if it succeeded.</source>
          <target state="translated">마지막 SQL 쿼리 실패와 관련된 오류 코드 ( &lt;a href=&quot;errcodes-appendix&quot;&gt;부록 A&lt;/a&gt; 참조 ) 또는 성공한 경우 &lt;code&gt;00000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18033404335da13276f24e2efbba0cea44bc2fa8" translate="yes" xml:space="preserve">
          <source>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run:</source>
          <target state="translated">오류 메시지에는 유용한 힌트가 있습니다. 모든 종속 객체를 개별적으로 삭제하지 않으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="57829bc22f9a034fee876abab6cb834a1c2e8f4d" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character.</source>
          <target state="translated">이스케이프 문자는 16 진수, 더하기 부호, 작은 따옴표, 큰 따옴표 또는 공백 문자 이외의 단일 문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558d22a4e0d0e48723c35f2a0cfc8e75bf258ba8" translate="yes" xml:space="preserve">
          <source>The escape character can be any single character other than a hexadecimal digit, the plus sign, a single quote, a double quote, or a whitespace character. Note that the escape character is written in single quotes, not double quotes.</source>
          <target state="translated">이스케이프 문자는 16 진수, 더하기 부호, 작은 따옴표, 큰 따옴표 또는 공백 문자 이외의 단일 문자 일 수 있습니다. 이스케이프 문자는 큰 따옴표가 아닌 작은 따옴표로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c319bbe8d3e052f0e1ded51a38eee81a844539cf" translate="yes" xml:space="preserve">
          <source>The escape-double-quote separators actually divide &lt;code&gt;substring&lt;/code&gt;'s pattern into three independent regular expressions; for example, a vertical bar (&lt;code&gt;|&lt;/code&gt;) in any of the three sections affects only that section. Also, the first and third of these regular expressions are defined to match the smallest possible amount of text, not the largest, when there is any ambiguity about how much of the data string matches which pattern. (In POSIX parlance, the first and third regular expressions are forced to be non-greedy.)</source>
          <target state="translated">이스케이프-큰 따옴표 구분 기호는 실제로 &lt;code&gt;substring&lt;/code&gt; 패턴을 세 개의 독립적 인 정규 표현식으로 나눕니다 . 예를 들어 세 섹션 중 하나의 세로 막대 ( &lt;code&gt;|&lt;/code&gt; )는 해당 섹션에만 영향을줍니다. 또한 이러한 정규 표현식의 첫 번째와 세 번째는 데이터 문자열 중 어느 패턴이 어떤 패턴과 일치하는지에 대한 모호성이있을 때 가장 큰 텍스트가 아닌 가능한 가장 작은 텍스트와 일치하도록 정의됩니다. POSIX 용어에서 첫 번째와 세 번째 정규 표현식은 욕심이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b9ec713fc7d733ff3cae68659b4d4e80a25bebd" translate="yes" xml:space="preserve">
          <source>The essential difference between &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt; data types is that &lt;code&gt;inet&lt;/code&gt; accepts values with nonzero bits to the right of the netmask, whereas &lt;code&gt;cidr&lt;/code&gt; does not. For example, &lt;code&gt;192.168.0.1/24&lt;/code&gt; is valid for &lt;code&gt;inet&lt;/code&gt; but not for &lt;code&gt;cidr&lt;/code&gt;.</source>
          <target state="translated">사이의 본질적인 차이 &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;cidr&lt;/code&gt; 데이터 형식이다 &lt;code&gt;inet&lt;/code&gt; 반면, 넷 마스크의 오른쪽에 제로 비트 값을 허용 &lt;code&gt;cidr&lt;/code&gt; 하지 않는다. 예를 들어, &lt;code&gt;192.168.0.1/24&lt;/code&gt; 는 &lt;code&gt;inet&lt;/code&gt; 에는 유효 하지만 &lt;code&gt;cidr&lt;/code&gt; 에는 유효 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df18f95e8b31c041dbe1102915fb4ff49c1585b3" translate="yes" xml:space="preserve">
          <source>The essential semantics of an &lt;code&gt;in_range&lt;/code&gt; function depend on the two Boolean flag parameters. It should add or subtract &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;, then compare &lt;code&gt;val&lt;/code&gt; to the result, as follows:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 함수 의 필수 의미 는 두 개의 부울 플래그 매개 변수에 따라 다릅니다. &lt;code&gt;base&lt;/code&gt; 와 &lt;code&gt;offset&lt;/code&gt; 을 더하거나 빼고 다음과 같이 &lt;code&gt;val&lt;/code&gt; 과 결과 를 비교 해야합니다.</target>
        </trans-unit>
        <trans-unit id="e84d23798c1117bda45a63153c240c91e5736421" translate="yes" xml:space="preserve">
          <source>The estimate is as accurate as with the functional dependencies, mostly thanks to the table being fairly small and having a simple distribution with a low number of distinct values. Before looking at the second query, which was not handled by functional dependencies particularly well, let's inspect the MCV list a bit.</source>
          <target state="translated">추정값은 기능 의존성만큼이나 정확합니다. 대부분 테이블이 상당히 작고 별개의 값이 적은 간단한 분포를 가지고 있기 때문입니다. 특히 기능적 종속성에 의해 처리되지 않은 두 번째 쿼리를 살펴보기 전에 MCV 목록을 조금 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e69083f44a757893f1ada1ae6b8cb9bd97b58e99" translate="yes" xml:space="preserve">
          <source>The estimated cost charged when vacuum modifies a block that was previously clean. It represents the extra I/O required to flush the dirty block out to disk again. The default value is 20.</source>
          <target state="translated">진공 상태가 이전에 깨끗했던 블록을 수정할 때 청구되는 예상 비용입니다. 더티 블록을 디스크로 다시 플러시하는 데 필요한 추가 I / O를 나타냅니다. 기본값은 20입니다.</target>
        </trans-unit>
        <trans-unit id="ee2db52b19d2bfa03dc1ab623c01a2a1907e2459" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer found in the shared buffer cache. It represents the cost to lock the buffer pool, lookup the shared hash table and scan the content of the page. The default value is one.</source>
          <target state="translated">공유 버퍼 캐시에서 발견 된 버퍼를 진공 청소기로 청소하기위한 예상 비용. 버퍼 풀을 잠그고 공유 해시 테이블을 조회하며 페이지의 컨텐츠를 스캔하는 비용을 나타냅니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="83ce27e1c08fee6790695cac6b8c3ef5bff725b5" translate="yes" xml:space="preserve">
          <source>The estimated cost for vacuuming a buffer that has to be read from disk. This represents the effort to lock the buffer pool, lookup the shared hash table, read the desired block in from the disk and scan its content. The default value is 10.</source>
          <target state="translated">디스크에서 읽어야하는 버퍼를 진공 청소기로 청소하기위한 예상 비용입니다. 이는 버퍼 풀을 잠그고 공유 해시 테이블을 조회하며 디스크에서 원하는 블록을 읽고 내용을 스캔하려는 노력을 나타냅니다. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="a717571e9b46bfa71ced49ce7ab5ad2053e90b7b" translate="yes" xml:space="preserve">
          <source>The event is one of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Note that an &lt;code&gt;INSERT&lt;/code&gt; containing an &lt;code&gt;ON CONFLICT&lt;/code&gt; clause cannot be used on tables that have either &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; rules. Consider using an updatable view instead.</source>
          <target state="translated">이벤트는 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 중 하나입니다 . &lt;code&gt;ON CONFLICT&lt;/code&gt; 절이 포함 된 &lt;code&gt;INSERT&lt;/code&gt; 는 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 규칙 이있는 테이블에서 사용할 수 없습니다 . 대신 업데이트 가능한보기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="227dafe90d62bc0d6660bf9b763aa381e9cc9dfe" translate="yes" xml:space="preserve">
          <source>The exact values that are acceptable for the &lt;code&gt;locale&lt;/code&gt; clause in this command depend on the operating system. On Unix-like systems, the command &lt;code&gt;locale -a&lt;/code&gt; will show a list.</source>
          <target state="translated">이 명령에서 &lt;code&gt;locale&lt;/code&gt; 절에 허용되는 정확한 값 은 운영 체제에 따라 다릅니다. 유닉스 계열 시스템에서 &lt;code&gt;locale -a&lt;/code&gt; 명령 은 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1583bbd20b51e7ac63ce0bb194332cc2a7d7d470" translate="yes" xml:space="preserve">
          <source>The example above can be written using the simple &lt;code&gt;CASE&lt;/code&gt; syntax:</source>
          <target state="translated">위의 예는 간단한 &lt;code&gt;CASE&lt;/code&gt; 구문을 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af8e2a351cf21a24426f9811e0f9ff471eeba69b" translate="yes" xml:space="preserve">
          <source>The example below shows a DTrace script for analyzing transaction counts in the system, as an alternative to snapshotting &lt;code&gt;pg_stat_database&lt;/code&gt; before and after a performance test:</source>
          <target state="translated">아래 예 는 성능 테스트 전후에 &lt;code&gt;pg_stat_database&lt;/code&gt; 를 스냅 샷하는 대신 시스템에서 트랜잭션 수를 분석하기위한 DTrace 스크립트를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f0d6977a3eaffb08d482eddd947f053b0bf9bd5c" translate="yes" xml:space="preserve">
          <source>The examples above only show &lt;code&gt;WITH&lt;/code&gt; being used with &lt;code&gt;SELECT&lt;/code&gt;, but it can be attached in the same way to &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. In each case it effectively provides temporary table(s) that can be referred to in the main command.</source>
          <target state="translated">위의 예 는 &lt;code&gt;SELECT&lt;/code&gt; 와 함께 사용되는 &lt;code&gt;WITH&lt;/code&gt; 만 표시 하지만 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 와 같은 방식으로 첨부 할 수 있습니다 . 각각의 경우 주 명령에서 참조 할 수있는 임시 테이블을 효과적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="380cc7f137a8c15a1ad87e0fd8242117724c9f5a" translate="yes" xml:space="preserve">
          <source>The examples in the previous section illustrated full text matching using simple constant strings. This section shows how to search table data, optionally using indexes.</source>
          <target state="translated">이전 섹션의 예제는 간단한 상수 문자열을 사용한 전체 텍스트 일치를 보여줍니다. 이 섹션에서는 선택적으로 인덱스를 사용하여 테이블 데이터를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b9b0afad9f26eddf93a4253af463b944d4205ce4" translate="yes" xml:space="preserve">
          <source>The examples shown below use tables in the PostgreSQL regression test database. The outputs shown are taken from version 8.3. The behavior of earlier (or later) versions might vary. Note also that since &lt;code&gt;ANALYZE&lt;/code&gt; uses random sampling while producing statistics, the results will change slightly after any new &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">아래에 표시된 예제는 PostgreSQL 회귀 테스트 데이터베이스의 테이블을 사용합니다. 표시된 출력은 버전 8.3에서 가져 왔습니다. 이전 (또는 이후) 버전의 동작은 다를 수 있습니다. 또한 &lt;code&gt;ANALYZE&lt;/code&gt; 는 통계를 생성하는 동안 랜덤 샘플링을 사용하므로 결과는 새로운 &lt;code&gt;ANALYZE&lt;/code&gt; 후에 약간 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2367138a166c600af3d676a2ed6d45de33c069c" translate="yes" xml:space="preserve">
          <source>The examples use &lt;code&gt;EXPLAIN&lt;/code&gt;'s default &amp;ldquo;text&amp;rdquo; output format, which is compact and convenient for humans to read. If you want to feed &lt;code&gt;EXPLAIN&lt;/code&gt;'s output to a program for further analysis, you should use one of its machine-readable output formats (XML, JSON, or YAML) instead.</source>
          <target state="translated">이 예제는 &lt;code&gt;EXPLAIN&lt;/code&gt; 의 기본 &quot;텍스트&quot;출력 형식을 사용합니다.이 형식은 사람이 읽기 쉽고 편리합니다. 추가 분석을 위해 &lt;code&gt;EXPLAIN&lt;/code&gt; 의 출력을 프로그램에 공급 하려면 기계가 읽을 수있는 출력 형식 (XML, JSON 또는 YAML) 중 하나를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d75f123f158a40ce2bca3268003c1deb66947f66" translate="yes" xml:space="preserve">
          <source>The exclusive backup method is deprecated and should be avoided. Prior to PostgreSQL 9.6, this was the only low-level method available, but it is now recommended that all users upgrade their scripts to use non-exclusive backups.</source>
          <target state="translated">독점적 인 백업 방법은 더 이상 사용되지 않으므로 피해야합니다. PostgreSQL 9.6 이전에는이 ​​방법이 사용 가능한 유일한 저수준 방법 이었지만 이제는 모든 사용자가 비 독점 백업을 사용하도록 스크립트를 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bb6f1793100519508110d4857d8c27514367d631" translate="yes" xml:space="preserve">
          <source>The executor mechanism is used to evaluate all four basic SQL query types: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. For &lt;code&gt;SELECT&lt;/code&gt;, the top-level executor code only needs to send each row returned by the query plan tree off to the client. For &lt;code&gt;INSERT&lt;/code&gt;, each returned row is inserted into the target table specified for the &lt;code&gt;INSERT&lt;/code&gt;. This is done in a special top-level plan node called &lt;code&gt;ModifyTable&lt;/code&gt;. (A simple &lt;code&gt;INSERT ... VALUES&lt;/code&gt; command creates a trivial plan tree consisting of a single &lt;code&gt;Result&lt;/code&gt; node, which computes just one result row, and &lt;code&gt;ModifyTable&lt;/code&gt; above it to perform the insertion. But &lt;code&gt;INSERT ... SELECT&lt;/code&gt; can demand the full power of the executor mechanism.) For &lt;code&gt;UPDATE&lt;/code&gt;, the planner arranges that each computed row includes all the updated column values, plus the &lt;em&gt;TID&lt;/em&gt; (tuple ID, or row ID) of the original target row; this data is fed into a &lt;code&gt;ModifyTable&lt;/code&gt; node, which uses the information to create a new updated row and mark the old row deleted. For &lt;code&gt;DELETE&lt;/code&gt;, the only column that is actually returned by the plan is the TID, and the &lt;code&gt;ModifyTable&lt;/code&gt; node simply uses the TID to visit each target row and mark it deleted.</source>
          <target state="translated">실행기 메커니즘은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 의 네 가지 기본 SQL 쿼리 유형을 모두 평가하는 데 사용됩니다 . 들어 &lt;code&gt;SELECT&lt;/code&gt; , 최상위 실행 프로그램 코드는 클라이언트에 떨어져 쿼리 계획 트리에 의해 반환 된 각 행을 보낼 필요가있다. 들면 &lt;code&gt;INSERT&lt;/code&gt; , 각 행은 리턴 지정된 목표 테이블에 삽입 &lt;code&gt;INSERT&lt;/code&gt; . 이것은 &lt;code&gt;ModifyTable&lt;/code&gt; 이라는 특수한 최상위 계획 노드에서 수행됩니다 . (간단한 &lt;code&gt;INSERT ... VALUES&lt;/code&gt; 명령은 하나의 결과 행을 계산 하는 단일 &lt;code&gt;Result&lt;/code&gt; 노드와 &lt;code&gt;ModifyTable&lt;/code&gt; 로 구성된 간단한 계획 트리를 작성합니다.그 위에 삽입을 수행하십시오. 그러나 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; 는 실행기 메커니즘의 모든 기능을 요구할 수 있습니다.) &lt;code&gt;UPDATE&lt;/code&gt; 의 경우 계획자는 각 계산 된 행에 모든 업데이트 된 열 값과 원래 대상 행 의 &lt;em&gt;TID&lt;/em&gt; (튜플 ID 또는 행 ID)가 포함되도록 정렬합니다. ; 이 데이터는 &lt;code&gt;ModifyTable&lt;/code&gt; 노드에 제공 되며이 정보는 정보를 사용하여 업데이트 된 새 행을 작성하고 이전 행을 삭제 된 것으로 표시합니다. 들어 &lt;code&gt;DELETE&lt;/code&gt; , 실제로 계획에 의해 반환되는 유일한 열은 TID, 그리고 &lt;code&gt;ModifyTable&lt;/code&gt; 노드는 단순히 각각의 목표 행을 방문하고 삭제 표시하는 TID를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4ce520996e20d2c06a7766155c3058caa75b4272" translate="yes" xml:space="preserve">
          <source>The executor recursively steps through the &lt;em&gt;plan tree&lt;/em&gt; and retrieves rows in the way represented by the plan. The executor makes use of the &lt;em&gt;storage system&lt;/em&gt; while scanning relations, performs &lt;em&gt;sorts&lt;/em&gt; and &lt;em&gt;joins&lt;/em&gt;, evaluates &lt;em&gt;qualifications&lt;/em&gt; and finally hands back the rows derived.</source>
          <target state="translated">실행 프로그램은 &lt;em&gt;계획 트리&lt;/em&gt; 를 반복적으로 단계별로 진행하고 &lt;em&gt;계획이&lt;/em&gt; 나타내는 방식으로 행을 검색합니다. 실행자는 관계를 스캔하고 &lt;em&gt;정렬&lt;/em&gt; 및 &lt;em&gt;조인을&lt;/em&gt; 수행하며 &lt;em&gt;자격을&lt;/em&gt; 평가 하고 최종적으로 파생 된 행을 전달 하는 동안 &lt;em&gt;스토리지 시스템&lt;/em&gt; 을 사용 합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf8658aa7a1382f233186544e10108cceaf18988" translate="yes" xml:space="preserve">
          <source>The existence of functional dependencies directly affects the accuracy of estimates in certain queries. If a query contains conditions on both the independent and the dependent column(s), the conditions on the dependent columns do not further reduce the result size; but without knowledge of the functional dependency, the query planner will assume that the conditions are independent, resulting in underestimating the result size.</source>
          <target state="translated">기능적 종속성의 존재는 특정 쿼리의 추정 ​​정확도에 직접적인 영향을 미칩니다. 쿼리에 독립 열과 종속 열 모두에 대한 조건이 포함되어 있으면 종속 열의 조건으로 인해 결과 크기가 더 줄어들지 않습니다. 그러나 기능 종속성에 대한 지식이 없으면 쿼리 플래너는 조건이 독립적이라고 가정하여 결과 크기를 과소 평가합니다.</target>
        </trans-unit>
        <trans-unit id="278c43dc066d35135921d352f59558e56072aaf4" translate="yes" xml:space="preserve">
          <source>The existing enum value that should be renamed. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">이름을 바꿔야하는 기존 열거 형 값입니다. 모든 열거 형 리터럴과 마찬가지로 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec72bab01087d3968b75adfc77dfce97e7c1c187" translate="yes" xml:space="preserve">
          <source>The existing enum value that the new value should be added immediately before or after in the enum type's sort ordering. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">열거 형의 정렬 순서에서 직전 또는 직후에 새 값을 추가해야하는 기존 열거 형 값입니다. 모든 열거 형 리터럴과 마찬가지로 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="288730aef18ef4aa044e0dc2a74d3a67ae251dbc" translate="yes" xml:space="preserve">
          <source>The expected parameter types for the prepared statement in the form of an array of &lt;code&gt;regtype&lt;/code&gt;. The OID corresponding to an element of this array can be obtained by casting the &lt;code&gt;regtype&lt;/code&gt; value to &lt;code&gt;oid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regtype&lt;/code&gt; 배열 형식으로 준비된 명령문의 예상 매개 변수 유형입니다 . 이 배열의 요소에 해당하는 OID는 &lt;code&gt;regtype&lt;/code&gt; 값을 &lt;code&gt;oid&lt;/code&gt; 로 캐스팅하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d73c415087d49efbf447ec5f41bf9143b5e43b5" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS DOCUMENT&lt;/code&gt; returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null. See &lt;a href=&quot;datatype-xml&quot;&gt;Section 8.13&lt;/a&gt; about the difference between documents and content fragments.</source>
          <target state="translated">인수 XML 값이 올바른 XML 문서 인 경우 &lt;code&gt;IS DOCUMENT&lt;/code&gt; 표현식 은 true를 리턴하고 그렇지 않은 경우 (즉, 컨텐츠 단편 인 경우) false 또는 인수가 널인 경우 널을 리턴합니다. 문서와 내용 조각의 차이점에 대해서는 &lt;a href=&quot;datatype-xml&quot;&gt;8.13 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3f0f5215911482c31ec80c4c63789e99b22d5c9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; returns false if the argument XML value is a proper XML document, true if it is not (that is, it is a content fragment), or null if the argument is null.</source>
          <target state="translated">인수 XML 값이 올바른 XML 문서 인 경우 &lt;code&gt;IS NOT DOCUMENT&lt;/code&gt; 표현식 은 false를 리턴하고, 그렇지 않은 경우 (즉, 컨텐츠 단편 인 경우) true 또는 인수가 널인 경우 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2fefc72765ee0edb8389edc8b54df23ebd5b6c13" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;collation for&lt;/code&gt; returns the collation of the value that is passed to it. Example:</source>
          <target state="translated">식 &lt;code&gt;collation for&lt;/code&gt; 은 전달 된 값의 데이터 정렬을 반환합니다. 예:</target>
        </trans-unit>
        <trans-unit id="9cec711d90ae7214afb1e767819f2c01ba82f2bc" translate="yes" xml:space="preserve">
          <source>The expression added to the WITH CHECK qualifications for queries that attempt to add rows to this table</source>
          <target state="translated">이 테이블에 행을 추가하려는 쿼리에 대한 WITH CHECK 규정에 추가 된 표현식</target>
        </trans-unit>
        <trans-unit id="fa02a0029d6349d8e6423a393d9fb0288905f902" translate="yes" xml:space="preserve">
          <source>The expression added to the security barrier qualifications for queries that this policy applies to</source>
          <target state="translated">이 정책이 적용되는 쿼리에 대한 보안 장벽 자격 조건에 추가 된 표현식</target>
        </trans-unit>
        <trans-unit id="239121cdfc5b45b387f1658717f60a67584813d6" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the WITH CHECK qualifications for queries that attempt to add rows to the table</source>
          <target state="translated">테이블에 행을 추가하려는 쿼리의 WITH CHECK 규정에 추가 될 표현식 트리</target>
        </trans-unit>
        <trans-unit id="710b7212dd7cdac519a9932cd2101a57cc49631a" translate="yes" xml:space="preserve">
          <source>The expression tree to be added to the security barrier qualifications for queries that use the table</source>
          <target state="translated">테이블을 사용하는 쿼리에 대한 보안 장벽 자격 조건에 추가 할 식 트리</target>
        </trans-unit>
        <trans-unit id="d2c435961e2d1a2d5fc091620a3b53aedf1bc369" translate="yes" xml:space="preserve">
          <source>The expression used in the &lt;code&gt;WHERE&lt;/code&gt; clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden in &lt;code&gt;WHERE&lt;/code&gt;. The same restrictions apply to index fields that are expressions.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절에 사용 된 표현식 은 기본 테이블의 컬럼 만 참조 할 수 있지만 색인화되는 컬럼뿐만 아니라 모든 컬럼을 사용할 수 있습니다. 현재 하위 쿼리 및 집계 식도 &lt;code&gt;WHERE&lt;/code&gt; 에서 금지되어 있습니다. 표현식 인 색인 필드에도 동일한 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e44d27b215403bd620571252d0254bbcc4cec3b6" translate="yes" xml:space="preserve">
          <source>The expressions described in this section check properties of &lt;code&gt;xml&lt;/code&gt; values.</source>
          <target state="translated">이 섹션에서 설명하는 표현식은 &lt;code&gt;xml&lt;/code&gt; 값의 속성을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="56934ce6588045922ec59583c810f1cb0acd84a1" translate="yes" xml:space="preserve">
          <source>The extensions currently available for loading can be identified from the &lt;a href=&quot;view-pg-available-extensions&quot;&gt;&lt;code&gt;pg_available_extensions&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt;&lt;code&gt;pg_available_extension_versions&lt;/code&gt;&lt;/a&gt; system views.</source>
          <target state="translated">현재로드 할 수있는 확장은 &lt;a href=&quot;view-pg-available-extensions&quot;&gt; &lt;code&gt;pg_available_extensions&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;view-pg-available-extension-versions&quot;&gt; &lt;code&gt;pg_available_extension_versions&lt;/code&gt; &lt;/a&gt; 시스템 뷰 에서 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8afec2ee5b2d1b2e4a42a77922b5f5aca2fe0a53" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Perl are called &lt;code&gt;jsonb_plperl&lt;/code&gt; and &lt;code&gt;jsonb_plperlu&lt;/code&gt;. If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Perl arrays, hashes, and scalars, as appropriate.</source>
          <target state="translated">PL / Perl의 확장을 &lt;code&gt;jsonb_plperl&lt;/code&gt; 및 &lt;code&gt;jsonb_plperlu&lt;/code&gt; 라고 합니다. 이를 사용하면 &lt;code&gt;jsonb&lt;/code&gt; 값이 적절하게 Perl 배열, 해시 및 스칼라에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="19e8b6e34d048aaf0ad16665bbe37cdf1acb53f4" translate="yes" xml:space="preserve">
          <source>The extensions for PL/Python are called &lt;code&gt;jsonb_plpythonu&lt;/code&gt;, &lt;code&gt;jsonb_plpython2u&lt;/code&gt;, and &lt;code&gt;jsonb_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;jsonb&lt;/code&gt; values are mapped to Python dictionaries, lists, and scalars, as appropriate.</source>
          <target state="translated">PL / Python의 확장을 &lt;code&gt;jsonb_plpythonu&lt;/code&gt; , &lt;code&gt;jsonb_plpython2u&lt;/code&gt; 및 &lt;code&gt;jsonb_plpython3u&lt;/code&gt; 라고 합니다 (PL / Python 이름 지정 규칙 &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;은 45.1 절&lt;/a&gt; 참조 ). 이 값을 사용하면 &lt;code&gt;jsonb&lt;/code&gt; 값이 적절하게 Python 사전, 목록 및 스칼라에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="75cf68d4493c1ff227589e69d7f36aa6187d6f32" translate="yes" xml:space="preserve">
          <source>The extent of analysis can be controlled by adjusting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration variable, or on a column-by-column basis by setting the per-column statistics target with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;). The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for &lt;code&gt;ANALYZE&lt;/code&gt; and the amount of space occupied in &lt;code&gt;pg_statistic&lt;/code&gt;. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;ORDER BY&lt;/code&gt; clauses of queries, since the planner will have no use for statistics on such columns.</source>
          <target state="translated">분석 범위는 &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; 구성 변수 를 조정 하거나 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET STATISTICS&lt;/code&gt; ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 )를 사용 하여 열별 통계 대상을 설정하여 열 단위 로 제어 할 수 있습니다 . 목표 값은 가장 일반적인 값 목록의 최대 항목 수와 히스토그램의 최대 구간 수를 설정합니다. 기본 목표 값은 100이지만 &lt;code&gt;ANALYZE&lt;/code&gt; 에 소요되는 시간 과 &lt;code&gt;pg_statistic&lt;/code&gt; 에서 차지하는 공간의 양에 대한 플래너 추정의 정확성을 절충하기 위해 위 또는 아래로 조정할 수 있습니다.. 특히 통계 대상을 0으로 설정하면 해당 열에 대한 통계 수집이 비활성화됩니다. 플래너가 해당 열에 대한 통계를 사용하지 않으므로 쿼리 의 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 절의 일부로 사용되지 않은 열에 대해서는이를 수행하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a1085020ce268691ef6285fd13220f59746e5a1" translate="yes" xml:space="preserve">
          <source>The external representation of an interval is formed using one or two floating-point numbers joined by the range operator (&lt;code&gt;..&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt; gives an overview of allowed representations; &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;Table F.27&lt;/a&gt; shows some examples.</source>
          <target state="translated">구간의 외부 표현은 범위 연산자 ( &lt;code&gt;..&lt;/code&gt; 또는 &lt;code&gt;...&lt;/code&gt; )로 연결된 하나 또는 두 개의 부동 소수점 숫자를 사용하여 형성됩니다 . 또는 중심점 플러스 또는 마이너스 편차로 지정할 수 있습니다. 선택적 확실성 표시기 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; )도 저장할 수 있습니다. 그러나 모든 내장 연산자는 인증 표시기를 무시합니다. &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;표 F.26&lt;/a&gt; 에서는 허용되는 표현에 대한 개요를 제공합니다. &lt;a href=&quot;seg#SEG-INPUT-EXAMPLES&quot;&gt;표 F.27&lt;/a&gt; 은 몇 가지 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ae94f4d8ec241ec4efa4661c23c0573db1da2b96" translate="yes" xml:space="preserve">
          <source>The external text representation of a composite value consists of items that are interpreted according to the I/O conversion rules for the individual field types, plus decoration that indicates the composite structure. The decoration consists of parentheses (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;) around the whole value, plus commas (&lt;code&gt;,&lt;/code&gt;) between adjacent items. Whitespace outside the parentheses is ignored, but within the parentheses it is considered part of the field value, and might or might not be significant depending on the input conversion rules for the field data type. For example, in:</source>
          <target state="translated">복합 값의 외부 텍스트 표현은 개별 필드 유형에 대한 I / O 변환 규칙에 따라 해석되는 항목과 복합 구조를 나타내는 장식으로 구성됩니다. 장식은 전체 값 주위 의 괄호 ( &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; ) 와 인접한 항목 사이의 쉼표 ( &lt;code&gt;,&lt;/code&gt; ) 로 구성 됩니다. 괄호 외부의 공백은 무시되지만 괄호 내에서는 필드 값의 일부로 간주되며 필드 데이터 유형의 입력 변환 규칙에 따라 중요하거나 중요하지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="165e79d513851869bfa7df4f3e60a06eff8eadcf" translate="yes" xml:space="preserve">
          <source>The external text representation of an array value consists of items that are interpreted according to the I/O conversion rules for the array's element type, plus decoration that indicates the array structure. The decoration consists of curly braces (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) around the array value plus delimiter characters between adjacent items. The delimiter character is usually a comma (&lt;code&gt;,&lt;/code&gt;) but can be something else: it is determined by the &lt;code&gt;typdelim&lt;/code&gt; setting for the array's element type. Among the standard data types provided in the PostgreSQL distribution, all use a comma, except for type &lt;code&gt;box&lt;/code&gt;, which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). In a multidimensional array, each dimension (row, plane, cube, etc.) gets its own level of curly braces, and delimiters must be written between adjacent curly-braced entities of the same level.</source>
          <target state="translated">배열 값의 외부 텍스트 표현은 배열의 요소 유형에 대한 I / O 변환 규칙에 따라 해석되는 항목과 배열 구조를 나타내는 장식으로 구성됩니다. 장식은 배열 값 주위에 중괄호 ( &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; ) 와 인접한 항목 사이의 구분 문자로 구성됩니다. 구분 문자는 일반적으로 쉼표 ( &lt;code&gt;,&lt;/code&gt; )이지만 다른 요소가 될 수 있습니다 . 배열의 요소 유형에 대한 &lt;code&gt;typdelim&lt;/code&gt; 설정에 의해 결정됩니다 . PostgreSQL의 분포 모두 사용 쉼표에 제공된 표준 데이터 형식 중 형을 제외한 &lt;code&gt;box&lt;/code&gt; 세미콜론 (사용 &lt;code&gt;;&lt;/code&gt; ). 다차원 배열에서 각 차원 (행, 평면, 큐브 등)은 고유 한 중괄호 수준을 가져오고 동일한 수준의 인접 중괄호 엔티티 사이에 구분 기호를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b72823d964b50e21e643394f5a86559900b575c" translate="yes" xml:space="preserve">
          <source>The external, user defined, name of a replication origin.</source>
          <target state="translated">복제 사용자의 외부 사용자 정의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="23e10c575081917649336c89f16d01777906e835" translate="yes" xml:space="preserve">
          <source>The fact that constraint exclusion uses &lt;code&gt;CHECK&lt;/code&gt; constraints, which makes it slow compared to partition pruning, can sometimes be used as an advantage: because constraints can be defined even on declaratively-partitioned tables, in addition to their internal partition bounds, constraint exclusion may be able to elide additional partitions from the query plan.</source>
          <target state="translated">제약 조건 제외가 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 사용 하여 파티션 정리와 비교할 때 속도가 느려지는 경우가 종종 장점으로 사용될 수 있습니다. 제약 조건은 내부 파티션 경계 외에도 선언적으로 파티션 된 테이블에서도 정의 할 수 있기 때문에 제약 조건 제외가 발생할 수 있습니다. 쿼리 계획에서 추가 파티션을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19233032264a45feb14fbaa7d90f7412bf00d3b4" translate="yes" xml:space="preserve">
          <source>The factory default limit on open files is often set to &amp;ldquo;socially friendly&amp;rdquo; values that allow many users to coexist on a machine without using an inappropriate fraction of the system resources. If you run many servers on a machine this is perhaps what you want, but on dedicated servers you might want to raise this limit.</source>
          <target state="translated">열린 파일에 대한 공장 기본 제한은 종종 &quot;사회 친화적&quot;값으로 설정되어 많은 사용자가 시스템 리소스를 부적절하게 사용하지 않고도 컴퓨터에 공존 할 수 있습니다. 머신에서 많은 서버를 실행하는 경우 이것은 원하는 것이지만 전용 서버에서는이 한계를 높이고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb210aea67c31ef1dbed7fd3eae3f43ab6220c6" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; is only honored in macOS 10.3.9 and later. If you are running a previous 10.3.x release, you must edit the file &lt;code&gt;/etc/rc&lt;/code&gt; and change the values in the following commands:</source>
          <target state="translated">&lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 파일 은 macOS 10.3.9 이상에서만 사용됩니다. 이전 10.3.x 릴리스를 실행중인 경우 &lt;code&gt;/etc/rc&lt;/code&gt; 파일을 편집 하고 다음 명령에서 값을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="84e9c854c59c60e0df39d55604e40742c14a3b04" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;scan.l&lt;/code&gt; is transformed to the C source file &lt;code&gt;scan.c&lt;/code&gt; using the program flex and &lt;code&gt;gram.y&lt;/code&gt; is transformed to &lt;code&gt;gram.c&lt;/code&gt; using bison. After these transformations have taken place a normal C compiler can be used to create the parser. Never make any changes to the generated C files as they will be overwritten the next time flex or bison is called.</source>
          <target state="translated">파일 &lt;code&gt;scan.l&lt;/code&gt; 는 C 소스 파일로 변환 &lt;code&gt;scan.c&lt;/code&gt; 와 프로그램 플렉스를 사용 &lt;code&gt;gram.y&lt;/code&gt; 는 로 변환 &lt;code&gt;gram.c&lt;/code&gt; 들소 사용. 이러한 변환이 수행 된 후 일반 C 컴파일러를 사용하여 구문 분석기를 작성할 수 있습니다. 다음에 flex 또는 bison이 호출 될 때 덮어 쓰기되므로 생성 된 C 파일을 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="45d0800a2dc4458be5cbd179d0ad2c43301c7d89" translate="yes" xml:space="preserve">
          <source>The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:</source>
          <target state="translated">파일 헤더는 15 바이트의 고정 필드와 가변 길이 헤더 확장 영역으로 구성됩니다. 고정 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08e8ce7451fee51ac789a7527b77201e50285954" translate="yes" xml:space="preserve">
          <source>The file name that will be used to store the history list. If unset, the file name is taken from the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable. If that is not set either, the default is &lt;code&gt;~/.psql_history&lt;/code&gt;, or &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; on Windows. For example, putting:</source>
          <target state="translated">히스토리 목록을 저장하는 데 사용될 파일 이름입니다. 설정되지 않은 경우 파일 이름은 &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 환경 변수 에서 가져옵니다 . 설정되지 않은 경우 기본값은 &lt;code&gt;~/.psql_history&lt;/code&gt; 또는 Windows의 &lt;code&gt;%APPDATA%\postgresql\psql_history&lt;/code&gt; 입니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="349919ea5386038c9255234a7dc46c1f159466f8" translate="yes" xml:space="preserve">
          <source>The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.</source>
          <target state="translated">파일 트레일러는 -1을 포함하는 16 비트 정수 단어로 구성됩니다. 이것은 튜플의 필드 카운트 단어와 쉽게 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="80e18aa528aa991bd67d4fb018eb762c1dfd60ad" translate="yes" xml:space="preserve">
          <source>The fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified, &lt;code&gt;INSERT&lt;/code&gt; operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This gives &lt;code&gt;UPDATE&lt;/code&gt; a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">테이블의 채우기 비율은 10에서 100 사이의 백분율입니다. 100 (완전 포장)이 기본값입니다. 더 작은 fillfactor가 지정되면 &lt;code&gt;INSERT&lt;/code&gt; 조작 은 표 페이지 만 표시된 백분율로 묶습니다. 각 페이지의 나머지 공간은 해당 페이지의 행을 업데이트하기 위해 예약되어 있습니다. 이렇게하면 &lt;code&gt;UPDATE&lt;/code&gt; 에서 업데이트 된 행 사본을 원본과 동일한 페이지에 배치 할 수 있으므로 다른 페이지에 배치하는 것보다 효율적입니다. 항목이 업데이트되지 않은 테이블의 경우 완전한 패킹이 최선의 선택이지만 크게 업데이트 된 테이블에서는 작은 채우기 비율이 적합합니다. TOAST 테이블에는이 매개 변수를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a018942b6effccffd16cfc6cd2d9f3b5906ea0a" translate="yes" xml:space="preserve">
          <source>The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to gradual degradation in the index's efficiency. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected. If the table is static then fillfactor 100 is best to minimize the index's physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.</source>
          <target state="translated">인덱스의 채우기 비율은 인덱스 방법이 인덱스 페이지를 압축하려고 시도하는 정도를 결정하는 백분율입니다. B- 트리의 경우, 리프 페이지는 초기 인덱스 빌드 중 및 오른쪽에서 인덱스를 확장 할 때 (새로운 가장 큰 키 값 추가)이 백분율로 채워집니다. 이후에 페이지가 완전히 가득 차면 분할되어 인덱스 효율성이 점차 저하됩니다. B- 트리는 기본 채우기 비율 90을 사용하지만 10에서 100 사이의 정수 값을 선택할 수 있습니다. 테이블이 정적 인 경우 fillfactor 100은 인덱스의 실제 크기를 최소화하는 것이 가장 좋지만, 많이 업데이트 된 테이블의 경우 더 작은 fillfactor가 페이지 분할의 필요성을 최소화하는 것이 좋습니다. 다른 인덱스 메소드는 fillfactor를 사용하지만 거의 비슷한 방식으로 사용합니다. 기본 fillfactor는 메소드마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5c29e42edd123c00869988ea11e4589bccf58ecb" translate="yes" xml:space="preserve">
          <source>The final section is the &amp;ldquo;special section&amp;rdquo; which can contain anything the access method wishes to store. For example, b-tree indexes store links to the page's left and right siblings, as well as some other data relevant to the index structure. Ordinary tables do not use a special section at all (indicated by setting &lt;code&gt;pd_special&lt;/code&gt; to equal the page size).</source>
          <target state="translated">마지막 섹션은&amp;ldquo;특별 섹션&amp;rdquo;이며 액세스 방법에 저장하고자하는 모든 것을 포함 할 수 있습니다. 예를 들어, b-tree 인덱스는 페이지의 왼쪽 및 오른쪽 형제에 대한 링크와 인덱스 구조와 관련된 다른 데이터를 저장합니다. 일반 테이블은 특수 섹션을 전혀 사용하지 않습니다 ( &lt;code&gt;pd_special&lt;/code&gt; 을 페이지 크기와 동일하게 설정하여 표시됨 ).</target>
        </trans-unit>
        <trans-unit id="02efe302dcd79b9e88f3a8473b49b8f9d4ac5123" translate="yes" xml:space="preserve">
          <source>The finished plan tree consists of sequential or index scans of the base relations, plus nested-loop, merge, or hash join nodes as needed, plus any auxiliary steps needed, such as sort nodes or aggregate-function calculation nodes. Most of these plan node types have the additional ability to do &lt;em&gt;selection&lt;/em&gt; (discarding rows that do not meet a specified Boolean condition) and &lt;em&gt;projection&lt;/em&gt; (computation of a derived column set based on given column values, that is, evaluation of scalar expressions where needed). One of the responsibilities of the planner is to attach selection conditions from the &lt;code&gt;WHERE&lt;/code&gt; clause and computation of required output expressions to the most appropriate nodes of the plan tree.</source>
          <target state="translated">완성 된 계획 트리는 기본 관계의 순차적 또는 인덱스 스캔, 필요에 따라 중첩 루프, 병합 또는 해시 조인 노드와 정렬 노드 또는 집계 함수 계산 노드와 같은 필요한 보조 단계로 구성됩니다. 이러한 계획 노드 유형의 대부분에는 &lt;em&gt;선택&lt;/em&gt; (지정된 부울 조건을 충족하지 않는 행 삭제) 및 &lt;em&gt;프로젝션&lt;/em&gt; (주어진 열 값을 기반으로하는 파생 열 세트의 계산, 즉 필요한 경우 스칼라 표현식의 평가)을 수행하는 추가 기능이 있습니다. . 플래너의 책임 중 하나는 &lt;code&gt;WHERE&lt;/code&gt; 절의 선택 조건 과 필요한 출력 표현식 계산을 계획 트리의 가장 적절한 노드에 첨부 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f91a1368250aec82fa6c3ae45da03e945de99bb" translate="yes" xml:space="preserve">
          <source>The firing of triggers that are declared as &amp;ldquo;constraint triggers&amp;rdquo; is also controlled by this setting &amp;mdash; they fire at the same time that the associated constraint should be checked.</source>
          <target state="translated">&quot;제약 트리거&quot;로 선언 된 트리거의 발생도이 설정에 의해 제어됩니다. 또한 관련 구속 조건을 확인해야하는 동시에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88e7caa4743ed2b44e88bb8540b5ed22e8f063f5" translate="yes" xml:space="preserve">
          <source>The first 24 bytes of each page consists of a page header (&lt;code&gt;PageHeaderData&lt;/code&gt;). Its format is detailed in &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;Table 68.3&lt;/a&gt;. The first field tracks the most recent WAL entry related to this page. The second field contains the page checksum if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled. Next is a 2-byte field containing flag bits. This is followed by three 2-byte integer fields (&lt;code&gt;pd_lower&lt;/code&gt;, &lt;code&gt;pd_upper&lt;/code&gt;, and &lt;code&gt;pd_special&lt;/code&gt;). These contain byte offsets from the page start to the start of unallocated space, to the end of unallocated space, and to the start of the special space. The next 2 bytes of the page header, &lt;code&gt;pd_pagesize_version&lt;/code&gt;, store both the page size and a version indicator. Beginning with PostgreSQL 8.3 the version number is 4; PostgreSQL 8.1 and 8.2 used version number 3; PostgreSQL 8.0 used version number 2; PostgreSQL 7.3 and 7.4 used version number 1; prior releases used version number 0. (The basic page layout and header format has not changed in most of these versions, but the layout of heap row headers has.) The page size is basically only present as a cross-check; there is no support for having more than one page size in an installation. The last field is a hint that shows whether pruning the page is likely to be profitable: it tracks the oldest un-pruned XMAX on the page.</source>
          <target state="translated">각 페이지의 처음 24 바이트는 페이지 헤더 ( &lt;code&gt;PageHeaderData&lt;/code&gt; ) 로 구성됩니다 . 형식은 &lt;a href=&quot;storage-page-layout#PAGEHEADERDATA-TABLE&quot;&gt;표 68.3에&lt;/a&gt; 자세히 나와 있습니다. 첫 번째 필드는이 페이지와 관련된 최신 WAL 항목을 추적합니다. 두 번째 필드에는 &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;데이터 체크섬&lt;/a&gt; 이 활성화 된 경우 페이지 체크섬이 포함됩니다 . 다음은 플래그 비트를 포함하는 2 바이트 필드입니다. 그 뒤에 세 개의 2 바이트 정수 필드 ( &lt;code&gt;pd_lower&lt;/code&gt; , &lt;code&gt;pd_upper&lt;/code&gt; 및 &lt;code&gt;pd_special&lt;/code&gt; )가 옵니다 . 여기에는 페이지 시작에서 할당되지 않은 공간의 시작, 할당되지 않은 공간의 끝 및 특수 공간의 시작까지의 바이트 오프셋이 포함됩니다. 페이지 헤더의 다음 2 바이트, &lt;code&gt;pd_pagesize_version&lt;/code&gt; 페이지 크기와 버전 표시기를 모두 저장하십시오. PostgreSQL 8.3부터 버전 번호는 4입니다. PostgreSQL 8.1 및 8.2는 버전 번호 3을 사용했습니다. PostgreSQL 8.0은 버전 번호 2를 사용했습니다. PostgreSQL 7.3 및 7.4는 버전 번호 1을 사용했습니다. 이전 릴리스에서는 버전 번호 0을 사용했습니다. (기본 페이지 레이아웃 및 헤더 형식은 대부분의 버전에서 변경되지 않았지만 힙 행 헤더의 레이아웃은 변경되었습니다.) 페이지 크기는 기본적으로 교차 확인으로 만 표시됩니다. 설치시 둘 이상의 페이지 크기를 지원하지 않습니다. 마지막 필드는 페이지 정리가 수익성이 있는지 여부를 나타내는 힌트입니다. 페이지에서 정리되지 않은 가장 오래된 XMAX를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="146b5ed003ceae9188015f907676c66e37810a01" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;UPDATE&lt;/code&gt; statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second &lt;code&gt;UPDATE&lt;/code&gt; statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:</source>
          <target state="translated">첫 번째 &lt;code&gt;UPDATE&lt;/code&gt; 문은 지정된 행에서 행 레벨 잠금을 획득하므로 해당 행을 업데이트하는 데 성공합니다. 그러나 두 번째 &lt;code&gt;UPDATE&lt;/code&gt; 문은 업데이트하려는 행이 이미 잠겨 있음을 확인하여 잠금을 획득 한 트랜잭션이 완료 될 때까지 기다립니다. 트랜잭션 2는 실행을 계속하기 전에 트랜잭션 1이 완료되기를 기다리고 있습니다. 이제 트랜잭션 1이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5efcfda2d8c77b88473ca9337c42439a024d54ff" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;expression&lt;/code&gt; is computed, then compared to each of the &lt;code&gt;value&lt;/code&gt; expressions in the &lt;code&gt;WHEN&lt;/code&gt; clauses until one is found that is equal to it. If no match is found, the &lt;code&gt;result&lt;/code&gt; of the &lt;code&gt;ELSE&lt;/code&gt; clause (or a null value) is returned. This is similar to the &lt;code&gt;switch&lt;/code&gt; statement in C.</source>
          <target state="translated">첫 번째 &lt;code&gt;expression&lt;/code&gt; 이 계산 된 후 &lt;code&gt;WHEN&lt;/code&gt; 절의 각 &lt;code&gt;value&lt;/code&gt; 표현식 과 동일한 표현식 이 발견 될 때까지 비교됩니다. 일치하는 항목이없는 경우, &lt;code&gt;result&lt;/code&gt; 의 &lt;code&gt;ELSE&lt;/code&gt; 절 (또는 널 (null) 값)가 리턴됩니다. 이것은 C 의 &lt;code&gt;switch&lt;/code&gt; 문과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="db81095a43bec432038707d12a55f4ea232797fc" translate="yes" xml:space="preserve">
          <source>The first approach makes use of the &lt;code&gt;cert&lt;/code&gt; authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries in &lt;code&gt;pg_hba.conf&lt;/code&gt;, such that the certificate itself is used for authentication while also providing ssl connection security. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details. (It is not necessary to specify any &lt;code&gt;clientcert&lt;/code&gt; options explicitly when using the &lt;code&gt;cert&lt;/code&gt; authentication method.) In this case, the &lt;code&gt;cn&lt;/code&gt; (Common Name) provided in the certificate is checked against the user name or an applicable mapping.</source>
          <target state="translated">첫 번째 방법은 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 &lt;code&gt;hostssl&lt;/code&gt; 항목에 대한 &lt;code&gt;cert&lt;/code&gt; 인증 방법을 사용하여 인증서 자체가 인증에 사용되는 동시에 SSL 연결 보안을 제공하는 것입니다. 자세한 내용 &lt;a href=&quot;auth-cert&quot;&gt;은 20.12 절&lt;/a&gt; 을 참조하십시오. ( &lt;code&gt;cert&lt;/code&gt; 인증 방법을 사용할 때 &lt;code&gt;clientcert&lt;/code&gt; 옵션을 명시 적으로 지정할 필요는 없습니다 .)이 경우 인증서에 제공된 &lt;code&gt;cn&lt;/code&gt; (공통 이름)이 사용자 이름 또는 해당 매핑과 비교하여 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="44f0ace0e5a351af8867382fc6a4698f25099edc" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgChooseIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgChooseOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">첫 번째 인수는 함수에 대한 입력 데이터가 포함 된 &lt;code&gt;spgChooseIn&lt;/code&gt; C 구조체에 대한 포인터 입니다. 두 번째 인수는 &lt;code&gt;spgChooseOut&lt;/code&gt; C 구조체에 대한 포인터이며 함수는 결과 데이터로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="73a46dbd547b3476953fd0d40d226d75ab67a447" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgConfigIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgConfigOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">첫 번째 인수는 함수에 대한 입력 데이터를 포함 하는 &lt;code&gt;spgConfigIn&lt;/code&gt; C 구조체에 대한 포인터 입니다. 두 번째 인수는 &lt;code&gt;spgConfigOut&lt;/code&gt; C 구조체에 대한 포인터이며 함수는 결과 데이터로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="b3d25ba584bb4c4acb9f3461e219135398ddc741" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">첫 번째 인수는 함수에 대한 입력 데이터를 포함 하는 &lt;code&gt;spgInnerConsistentIn&lt;/code&gt; C 구조체에 대한 포인터 입니다. 두 번째 인수는 &lt;code&gt;spgInnerConsistentOut&lt;/code&gt; C 구조체에 대한 포인터이며 함수는 결과 데이터로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="4b95190547cc0ff307d0a7948518c66223c69217" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">첫 번째 인수는 함수에 대한 입력 데이터를 포함 하는 &lt;code&gt;spgLeafConsistentIn&lt;/code&gt; C 구조체에 대한 포인터 입니다. 두 번째 인수는 &lt;code&gt;spgLeafConsistentOut&lt;/code&gt; C 구조체에 대한 포인터이며 함수는 결과 데이터로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="ca5853d09340bad3adb00c3e57ccca9e872f72bb" translate="yes" xml:space="preserve">
          <source>The first argument is a pointer to a &lt;code&gt;spgPickSplitIn&lt;/code&gt; C struct, containing input data for the function. The second argument is a pointer to a &lt;code&gt;spgPickSplitOut&lt;/code&gt; C struct, which the function must fill with result data.</source>
          <target state="translated">첫 번째 인수는 함수에 대한 입력 데이터를 포함 하는 &lt;code&gt;spgPickSplitIn&lt;/code&gt; C 구조체에 대한 포인터 입니다. 두 번째 인수는 &lt;code&gt;spgPickSplitOut&lt;/code&gt; C 구조체에 대한 포인터이며 함수는 결과 데이터로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="1f369dd1771752484284223f6c8b61724d963075" translate="yes" xml:space="preserve">
          <source>The first argument is the relation to be prewarmed. The second argument is the prewarming method to be used, as further discussed below; the third is the relation fork to be prewarmed, usually &lt;code&gt;main&lt;/code&gt;. The fourth argument is the first block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; is accepted as a synonym for zero). The fifth argument is the last block number to prewarm (&lt;code&gt;NULL&lt;/code&gt; means prewarm through the last block in the relation). The return value is the number of blocks prewarmed.</source>
          <target state="translated">첫 번째 주장은 예열되어야 할 관계입니다. 두 번째 주장은 아래에서 더 논의되는 것처럼 사용될 사전 예열 방법이다. 세 번째는 일반적으로 &lt;code&gt;main&lt;/code&gt; 이라는 미리 준비된 관계 포크 입니다. 네 번째 인수는 사전 예열 할 첫 번째 블록 번호입니다 ( &lt;code&gt;NULL&lt;/code&gt; 은 0의 동의어로 허용됨). 다섯 번째 인수는 사전 예열 할 마지막 블록 번호입니다 ( &lt;code&gt;NULL&lt;/code&gt; 은 관계의 마지막 블록을 통한 예열을 의미 함). 리턴 값은 사전 예열 된 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="cd29c1ca625357cd146a327c957cb4b92e5a317e" translate="yes" xml:space="preserve">
          <source>The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican.</source>
          <target state="translated">1 세기는 0001-01-01 00:00:00 AD에서 시작하지만 당시에는 몰랐습니다. 이 정의는 모든 그레고리력 국가에 적용됩니다. 세기 숫자 0이 없습니다, 당신은 -1 세기에서 1 세기로갑니다. 이에 동의하지 않으면, 바티칸 로마 성 베드로 성당 교황에게 불만을 적어주십시오.</target>
        </trans-unit>
        <trans-unit id="256263538ce2e1f28734e2b2ed2dbaa9ee5222c8" translate="yes" xml:space="preserve">
          <source>The first certificate in &lt;code&gt;server.crt&lt;/code&gt; must be the server's certificate because it must match the server's private key. The certificates of &amp;ldquo;intermediate&amp;rdquo; certificate authorities can also be appended to the file. Doing this avoids the necessity of storing intermediate certificates on clients, assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions. This allows easier expiration of intermediate certificates.</source>
          <target state="translated">&lt;code&gt;server.crt&lt;/code&gt; 의 첫 번째 인증서 는 서버의 개인 키와 일치해야하므로 서버의 인증서 여야합니다. &amp;ldquo;중간&amp;rdquo;인증 기관의 인증서를 파일에 추가 할 수도 있습니다. 이렇게하면 루트 및 중간 인증서가 &lt;code&gt;v3_ca&lt;/code&gt; 확장명 으로 생성되었다고 가정 할 때 클라이언트에 중간 인증서를 저장하지 않아도 됩니다. 이를 통해 중간 인증서를보다 쉽게 ​​만료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f3996eda734e252b355fcb3237a8e729927963" translate="yes" xml:space="preserve">
          <source>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already.</source>
          <target state="translated">첫 번째 요소는 현재 사용자와 이름이 같은 스키마를 검색하도록 지정합니다. 이러한 스키마가 없으면 항목이 무시됩니다. 두 번째 요소는 이미 본 공개 스키마를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5dd1c81747f7da19e4955a86256d7b17a34ec6f9" translate="yes" xml:space="preserve">
          <source>The first example adds a time zone to a value that lacks it, and displays the value using the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The second example shifts the time stamp with time zone value to the specified time zone, and returns the value without a time zone. This allows storage and display of values different from the current &lt;code&gt;TimeZone&lt;/code&gt; setting. The third example converts Tokyo time to Chicago time. Converting &lt;em&gt;time&lt;/em&gt; values to other time zones uses the currently active time zone rules since no date is supplied.</source>
          <target state="translated">첫 번째 예에서는 표준 시간대가없는 값에 표준 시간대를 추가하고 현재 &lt;code&gt;TimeZone&lt;/code&gt; 설정을 사용하여 값을 표시 합니다. 두 번째 예에서는 시간대 값이있는 타임 스탬프를 지정된 시간대로 이동하고 시간대가없는 값을 반환합니다. 이를 통해 현재 &lt;code&gt;TimeZone&lt;/code&gt; 설정 과 다른 값을 저장하고 표시 할 수 있습니다 . 세 번째 예는 도쿄 시간을 시카고 시간으로 변환합니다. &lt;em&gt;시간&lt;/em&gt; 값을 다른 시간대로 변환 하면 날짜가 제공되지 않으므로 현재 활성 시간대 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dd4f388d81712247b36f96199e31fe01ab0dcd8a" translate="yes" xml:space="preserve">
          <source>The first example omits &lt;code&gt;ROW&lt;/code&gt;, the second uses it; we could have done it either way.</source>
          <target state="translated">첫 번째 예제는 &lt;code&gt;ROW&lt;/code&gt; 를 생략 하고 두 번째 예제는 ROW 를 생략 합니다. 우리는 어느 쪽이든 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="612c7d9435df3c5121ea73e09ab866021bad4c1b" translate="yes" xml:space="preserve">
          <source>The first example selects the ICU locale using a &amp;ldquo;language tag&amp;rdquo; per BCP 47. The second example uses the traditional ICU-specific locale syntax. The first style is preferred going forward, but it is not supported by older ICU versions.</source>
          <target state="translated">첫 번째 예는 BCP 47에 따라 &quot;language tag&quot;를 사용하여 ICU 로캘을 선택합니다. 두 번째 예는 전통적인 ICU 특정 로캘 구문을 사용합니다. 첫 번째 스타일은 선호되지만 이전 ICU 버전에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1d60b8c5a21ae5115bceb8211e299ddf895cf0f" translate="yes" xml:space="preserve">
          <source>The first example shows how to spread a command over several lines of input. Notice the changing prompt:</source>
          <target state="translated">첫 번째 예는 여러 줄의 입력으로 명령을 분산시키는 방법을 보여줍니다. 변경 프롬프트를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e43256b97dc53da480190315bac59bb3f0cada5f" translate="yes" xml:space="preserve">
          <source>The first form changes certain per-database settings. (See below for details.) Only the database owner or a superuser can change these settings.</source>
          <target state="translated">첫 번째 양식은 특정 데이터베이스 별 설정을 변경합니다. (자세한 내용은 아래를 참조하십시오.) 데이터베이스 소유자 또는 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da17ae59b4b9d415d049588fbe4c802a8a77a808" translate="yes" xml:space="preserve">
          <source>The first form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a composite type. The composite type is specified by a list of attribute names and data types. An attribute's collation can be specified too, if its data type is collatable. A composite type is essentially the same as the row type of a table, but using &lt;code&gt;CREATE TYPE&lt;/code&gt; avoids the need to create an actual table when all that is wanted is to define a type. A stand-alone composite type is useful, for example, as the argument or return type of a function.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; 의 첫 번째 양식은 복합 유형을 작성합니다. 복합 유형은 속성 이름 및 데이터 유형 목록으로 지정됩니다. 데이터 유형이 데이터 정렬 가능한 경우 속성 데이터 정렬도 지정할 수 있습니다. 복합 유형은 본질적으로 테이블의 행 유형과 동일하지만 &lt;code&gt;CREATE TYPE&lt;/code&gt; 을 사용하면 원하는 유형이 모두 정의 될 때 실제 테이블을 작성할 필요가 없습니다. 독립형 복합 유형은 예를 들어 함수의 인수 또는 반환 유형으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a9da06ff6dbdef653da94da0ffaf44a0aef0024f" translate="yes" xml:space="preserve">
          <source>The first form of aggregate expression invokes the aggregate once for each input row. The second form is the same as the first, since &lt;code&gt;ALL&lt;/code&gt; is the default. The third form invokes the aggregate once for each distinct value of the expression (or distinct set of values, for multiple expressions) found in the input rows. The fourth form invokes the aggregate once for each input row; since no particular input value is specified, it is generally only useful for the &lt;code&gt;count(*)&lt;/code&gt; aggregate function. The last form is used with &lt;em&gt;ordered-set&lt;/em&gt; aggregate functions, which are described below.</source>
          <target state="translated">집계 식의 첫 번째 형식은 각 입력 행에 대해 집계를 한 번 호출합니다. &lt;code&gt;ALL&lt;/code&gt; 이 기본값 이므로 두 번째 양식은 첫 번째 양식과 동일 합니다. 세 번째 양식은 입력 행에서 찾은 각 고유 한 표현식 값 (또는 여러 표현식의 경우 고유 한 값 세트)에 대해 집계를 한 번 호출합니다. 네 번째 양식은 각 입력 행에 대해 집계를 한 번 호출합니다. 특정 입력 값이 지정되지 않았으므로 일반적으로 &lt;code&gt;count(*)&lt;/code&gt; 집계 함수 에만 유용 합니다. 마지막 양식은 아래에 설명 된 &lt;em&gt;순서대로 설정된&lt;/em&gt; 집계 함수 와 함께 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c37d2c4cb9171a6fcf0c1214edbc6145fc4b4d" translate="yes" xml:space="preserve">
          <source>The first form of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command, which creates a composite type, conforms to the SQL standard. The other forms are PostgreSQL extensions. The &lt;code&gt;CREATE TYPE&lt;/code&gt; statement in the SQL standard also defines other forms that are not implemented in PostgreSQL.</source>
          <target state="translated">복합 유형을 작성하는 &lt;code&gt;CREATE TYPE&lt;/code&gt; 명령 의 첫 번째 양식은 SQL 표준을 준수합니다. 다른 형식은 PostgreSQL 확장입니다. SQL 표준 의 &lt;code&gt;CREATE TYPE&lt;/code&gt; 문은 PostgreSQL에서 구현되지 않은 다른 양식도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c38ff028812a13bb491adf5222d97dc3de42b820" translate="yes" xml:space="preserve">
          <source>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</source>
          <target state="translated">접두어 클래스의 첫 번째 줄은 헤더입니다. 접두어 규칙 필드는 헤더 다음에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="8e805cf56cf5d6631bb0160a0e06bad5df15b037" translate="yes" xml:space="preserve">
          <source>The first number in the &lt;code&gt;-L&lt;/code&gt; argument, 63333, is the port number of your end of the tunnel; it can be any unused port. (IANA reserves ports 49152 through 65535 for private use.) The second number, 5432, is the remote end of the tunnel: the port number your server is using. The name or IP address between the port numbers is the host with the database server you are going to connect to, as seen from the host you are logging in to, which is &lt;code&gt;foo.com&lt;/code&gt; in this example. In order to connect to the database server using this tunnel, you connect to port 63333 on the local machine:</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 인수 의 첫 번째 숫자 인 63333은 터널 끝의 포트 번호입니다. 사용하지 않는 포트 일 수 있습니다. (IANA는 개인용으로 포트 49152-65535를 예약합니다.) 두 번째 번호 5432는 터널의 원격 끝입니다. 서버가 사용중인 포트 번호입니다. 포트 번호 사이의 이름 또는 IP 주소는 로그인하려는 호스트에서 볼 때 연결하려는 데이터베이스 서버가있는 호스트 입니다 (이 예 에서는 &lt;code&gt;foo.com&lt;/code&gt; ) . 이 터널을 사용하여 데이터베이스 서버에 연결하려면 로컬 시스템의 포트 63333에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="3f99873fa941c47208f84d01e9069ef478e98de2" translate="yes" xml:space="preserve">
          <source>The first one worked using &lt;em&gt;row level&lt;/em&gt; processing and was implemented deep in the &lt;em&gt;executor&lt;/em&gt;. The rule system was called whenever an individual row had been accessed. This implementation was removed in 1995 when the last official release of the Berkeley Postgres project was transformed into Postgres95.</source>
          <target state="translated">첫 번째는 &lt;em&gt;행 수준&lt;/em&gt; 처리를 사용 하여 &lt;em&gt;실행&lt;/em&gt; 되었으며 &lt;em&gt;executor&lt;/em&gt; 에서 깊이 구현되었습니다 . 개별 행에 액세스 할 때마다 규칙 시스템이 호출되었습니다. 이 구현은 Berkeley Postgres 프로젝트의 마지막 공식 릴리스가 Postgres95로 변환 된 1995 년에 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="0fa18c39fe287e28bd5e7314fe8af5727d16d727" translate="yes" xml:space="preserve">
          <source>The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema.</source>
          <target state="translated">존재하는 검색 경로의 첫 번째 스키마는 새 객체를 만들기위한 기본 위치입니다. 이것이 기본적으로 개체가 공개 스키마에 생성되는 이유입니다. 스키마 한정 (테이블 수정, 데이터 수정 또는 쿼리 명령)없이 다른 컨텍스트에서 객체를 참조하면 일치하는 객체를 찾을 때까지 검색 경로가 순회됩니다. 따라서 기본 구성에서 규정되지 않은 액세스는 다시 공용 스키마 만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3413da7a0291a52f1a7dcc2b820079440b3c54" translate="yes" xml:space="preserve">
          <source>The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the &lt;code&gt;CREATE TABLE&lt;/code&gt; command does not specify a schema name.</source>
          <target state="translated">검색 경로에 이름이 지정된 첫 번째 스키마를 현재 스키마라고합니다. &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령이 스키마 이름을 지정하지 않은 경우 첫 번째 스키마 검색 외에도 새 테이블이 작성되는 스키마이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="9d12bc7a9f0942909d34ace4bd41d7e184667d01" translate="yes" xml:space="preserve">
          <source>The first six lines report some of the most important parameter settings. The next line reports the number of transactions completed and intended (the latter being just the product of number of clients and number of transactions per client); these will be equal unless the run failed before completion. (In &lt;code&gt;-T&lt;/code&gt; mode, only the actual number of transactions is printed.) The last two lines report the number of transactions per second, figured with and without counting the time to start database sessions.</source>
          <target state="translated">처음 6 줄은 가장 중요한 매개 변수 설정 중 일부를보고합니다. 다음 행은 완료되고 의도 된 트랜잭션 수를보고합니다 (후자는 클라이언트 수와 클라이언트 당 트랜잭션 수의 결과 임). 완료 전에 실행이 실패하지 않으면 동일합니다. ( &lt;code&gt;-T&lt;/code&gt; 모드에서는 실제 트랜잭션 수만 인쇄됩니다.) 마지막 두 줄은 데이터베이스 세션 시작 시간을 계산하거나 계산하지 않고 계산 된 초당 트랜잭션 수를보고합니다.</target>
        </trans-unit>
        <trans-unit id="46861698534eb993d5363434e9d5cb2bd00b93d2" translate="yes" xml:space="preserve">
          <source>The first step is to generate an auxiliary table containing all the unique words in the documents:</source>
          <target state="translated">첫 번째 단계는 문서의 모든 고유 단어를 포함하는 보조 테이블을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d440c66135f418ef7372813549a4be5ffe416b8b" translate="yes" xml:space="preserve">
          <source>The first test to see whether you can access the database server is to try to create a database. A running PostgreSQL server can manage many databases. Typically, a separate database is used for each project or for each user.</source>
          <target state="translated">데이터베이스 서버에 액세스 할 수 있는지 여부를 확인하는 첫 번째 테스트는 데이터베이스를 작성하는 것입니다. 실행중인 PostgreSQL 서버는 많은 데이터베이스를 관리 할 수 ​​있습니다. 일반적으로 각 프로젝트 또는 사용자마다 별도의 데이터베이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c00d09908f3f4ddbf657d8ad0f17eabf84136b00" translate="yes" xml:space="preserve">
          <source>The first three output columns come directly from the table &lt;code&gt;empsalary&lt;/code&gt;, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same &lt;code&gt;depname&lt;/code&gt; value as the current row. (This actually is the same function as the non-window &lt;code&gt;avg&lt;/code&gt; aggregate, but the &lt;code&gt;OVER&lt;/code&gt; clause causes it to be treated as a window function and computed across the window frame.)</source>
          <target state="translated">처음 세 개의 출력 열은 테이블 &lt;code&gt;empsalary&lt;/code&gt; 에서 직접 가져 오며 테이블의 각 행마다 하나의 출력 행이 있습니다. 네 번째 열은 현재 행과 동일한 &lt;code&gt;depname&lt;/code&gt; 값 을 가진 모든 테이블 행에서 취한 평균을 나타냅니다 . (이것은 실제로는 비-창 &lt;code&gt;avg&lt;/code&gt; 집계 와 동일한 기능 이지만, &lt;code&gt;OVER&lt;/code&gt; 절은이를 창 함수로 취급하고 창 프레임에서 계산합니다.)</target>
        </trans-unit>
        <trans-unit id="c0413166d43e378dc8855747d05360346ec4b249" translate="yes" xml:space="preserve">
          <source>The first three parameters are inputs:</source>
          <target state="translated">처음 세 매개 변수는 입력입니다.</target>
        </trans-unit>
        <trans-unit id="54956845c90a8b39103dc2ab8d6e4402b710d114" translate="yes" xml:space="preserve">
          <source>The first three variants change which tables are part of the publication. The &lt;code&gt;SET TABLE&lt;/code&gt; clause will replace the list of tables in the publication with the specified one. The &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; clauses will add and remove one or more tables from the publication. Note that adding tables to a publication that is already subscribed to will require a &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; action on the subscribing side in order to become effective.</source>
          <target state="translated">처음 세 변형은 게시의 일부 테이블을 변경합니다. &lt;code&gt;SET TABLE&lt;/code&gt; 절은 지정된 하나 게시에 테이블 목록을 대체합니다. &lt;code&gt;ADD TABLE&lt;/code&gt; 및 &lt;code&gt;DROP TABLE&lt;/code&gt; 조항 추가 및 게시에서 하나 개 이상의 테이블을 제거합니다. 이미 구독 된 발행물에 테이블을 추가하려면 유효하게하려면 구독 측에서 &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; 조치 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="70d5b4450dbfd9e788e4338d7701eefa6a67f05f" translate="yes" xml:space="preserve">
          <source>The first trigger argument must be the name of the &lt;code&gt;tsvector&lt;/code&gt; column to be updated. The second argument specifies the text search configuration to be used to perform the conversion. For &lt;code&gt;tsvector_update_trigger&lt;/code&gt;, the configuration name is simply given as the second trigger argument. It must be schema-qualified as shown above, so that the trigger behavior will not change with changes in &lt;code&gt;search_path&lt;/code&gt;. For &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt;, the second trigger argument is the name of another table column, which must be of type &lt;code&gt;regconfig&lt;/code&gt;. This allows a per-row selection of configuration to be made. The remaining argument(s) are the names of textual columns (of type &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;). These will be included in the document in the order given. NULL values will be skipped (but the other columns will still be indexed).</source>
          <target state="translated">첫 번째 트리거 인수는 업데이트 할 &lt;code&gt;tsvector&lt;/code&gt; 열의 이름이어야합니다 . 두 번째 인수는 변환을 수행하는 데 사용할 텍스트 검색 구성을 지정합니다. 들어 &lt;code&gt;tsvector_update_trigger&lt;/code&gt; , 구성 이름은 단순히 두 번째 트리거 인수로 제공됩니다. &lt;code&gt;search_path&lt;/code&gt; 의 변경으로 트리거 동작이 변경되지 않도록 위에 표시된대로 스키마로 규정되어야합니다 . 들면 &lt;code&gt;tsvector_update_trigger_column&lt;/code&gt; 번째 트리거 인자 타입이어야 다른 테이블 칼럼의 이름 &lt;code&gt;regconfig&lt;/code&gt; 이 . 이를 통해 행별로 구성을 선택할 수 있습니다. 나머지 인수는 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; 유형의 텍스트 열 이름입니다.또는 &lt;code&gt;char&lt;/code&gt; ). 이들은 주어진 순서대로 문서에 포함됩니다. NULL 값은 건너 뛰지 만 다른 열은 여전히 ​​인덱싱됩니다.</target>
        </trans-unit>
        <trans-unit id="01ce9912b77202e1b48ed397f2bfc3b3783947c2" translate="yes" xml:space="preserve">
          <source>The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.</source>
          <target state="translated">처음 두 제약 조건은 익숙해 보일 것입니다. 세 번째는 새로운 구문을 사용합니다. 특정 열에 첨부되지 않고 쉼표로 구분 된 열 목록에서 별도의 항목으로 나타납니다. 열 정의와 이러한 제약 조건 정의는 혼합 된 순서로 나열 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2927557f90bef3d374c5198102a6e3ea28461171" translate="yes" xml:space="preserve">
          <source>The first two of these we saw already. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt;. The form &lt;code&gt;text&lt;/code&gt;&lt;code&gt;@@&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; is equivalent to &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt;.</source>
          <target state="translated">이 중 처음 두 개는 이미 보았습니다. 양식 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; 는 &lt;code&gt;to_tsvector(x) @@ y&lt;/code&gt; . 양식 &lt;code&gt;text&lt;/code&gt; &lt;code&gt;@@&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 는 &lt;code&gt;to_tsvector(x) @@ plainto_tsquery(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdaab7b9b529bcc8f6406321204002fe17ed4b88" translate="yes" xml:space="preserve">
          <source>The first two output columns are used for the current row's key and its parent row's key; they must match the type of the table's key field. The third output column is the depth in the tree and must be of type &lt;code&gt;integer&lt;/code&gt;. If a &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; parameter was given, the next output column is the branch display and must be of type &lt;code&gt;text&lt;/code&gt;. Finally, if an &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter was given, the last output column is a serial number, and must be of type &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">처음 두 개의 출력 열은 현재 행의 키와 상위 행의 키에 사용됩니다. 테이블의 키 필드 유형과 일치해야합니다. 세 번째 출력 열은 트리의 깊이이며 &lt;code&gt;integer&lt;/code&gt; 유형이어야합니다 . 경우 &lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt; 매개 변수가 제공 한 다음 출력 열은 분기 표시이며, 형식이어야합니다 &lt;code&gt;text&lt;/code&gt; . 마지막으로 &lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt; 매개 변수가 제공된 경우 마지막 출력 열은 일련 번호이며 &lt;code&gt;integer&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf7215eea980a2a0bf86f75a412a5f3cd60fbcd5" translate="yes" xml:space="preserve">
          <source>The first two variants add users to a group or remove them from a group. (Any role can play the part of either a &amp;ldquo;user&amp;rdquo; or a &amp;ldquo;group&amp;rdquo; for this purpose.) These variants are effectively equivalent to granting or revoking membership in the role named as the &amp;ldquo;group&amp;rdquo;; so the preferred way to do this is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">처음 두 변형은 사용자를 그룹에 추가하거나 그룹에서 제거합니다. (모든 역할은이 목적을 위해 &quot;사용자&quot;또는 &quot;그룹&quot;의 일부를 담당 할 수 있습니다.) 이러한 변형은 &quot;그룹&quot;이라는 역할의 멤버 자격을 부여하거나 취소하는 것과 사실상 동일합니다. 이를 위해 선호되는 방법은 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 또는 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0b5e370e58213823b4126e17f4b6e7ad4cef2b17" translate="yes" xml:space="preserve">
          <source>The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; for that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can change any of these settings, but only for non-superuser and non-replication roles. Ordinary roles can only change their own password.</source>
          <target state="translated">개요에 나열된이 명령의 첫 번째 변형은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 에서 지정할 수있는 많은 역할 속성을 변경할 수 있습니다 . (멤버십 추가 또는 제거에 대한 옵션이 없다는 점을 제외하고 가능한 모든 속성이 적용됩니다. &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 및 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 를 사용하십시오 .) 명령에 언급되지 않은 속성은 이전 설정을 유지합니다. 데이터베이스 수퍼 유저는 모든 역할에 대해 이러한 설정을 변경할 수 있습니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이있는 역할 은 이러한 설정 중 하나를 변경할 수 있지만 수퍼 유저가 아닌 복제 이외의 역할에 대해서만 가능합니다. 일반 역할은 자신의 암호 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ae6ee44a0f0d836e1704c794f00aceb8d356c4" translate="yes" xml:space="preserve">
          <source>The five mandatory user-defined methods are:</source>
          <target state="translated">5 가지 필수 사용자 정의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72ce333d0c25ef1597b4fa8ad61ed91fb435220e" translate="yes" xml:space="preserve">
          <source>The following &amp;ldquo;parameters&amp;rdquo; are read-only, and are determined when PostgreSQL is compiled or when it is installed. As such, they have been excluded from the sample &lt;code&gt;postgresql.conf&lt;/code&gt; file. These options report various aspects of PostgreSQL behavior that might be of interest to certain applications, particularly administrative front-ends.</source>
          <target state="translated">다음 &quot;매개 변수&quot;는 읽기 전용이며 PostgreSQL이 컴파일되거나 설치 될 때 결정됩니다. 따라서 샘플 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 에서 제외되었습니다 . 이 옵션은 특정 응용 프로그램, 특히 관리 프런트 엔드에 관심이있을 수있는 PostgreSQL 동작의 다양한 측면을보고합니다.</target>
        </trans-unit>
        <trans-unit id="f94e73cd2b87aba8e9913a22c540c941db79c62c" translate="yes" xml:space="preserve">
          <source>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: &lt;code&gt;CURRENT_DATE&lt;/code&gt;, &lt;code&gt;CURRENT_TIME&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, &lt;code&gt;LOCALTIME&lt;/code&gt;, &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;. The latter four accept an optional subsecond precision specification. (See &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;Section 9.9.4&lt;/a&gt;.) Note that these are SQL functions and are &lt;em&gt;not&lt;/em&gt; recognized in data input strings.</source>
          <target state="translated">&lt;code&gt;CURRENT_DATE&lt;/code&gt; , &lt;code&gt;CURRENT_TIME&lt;/code&gt; , &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; , &lt;code&gt;LOCALTIME&lt;/code&gt; , &lt;code&gt;LOCALTIMESTAMP&lt;/code&gt; 와 같은 SQL 호환 함수를 사용하여 해당 데이터 유형의 현재 시간 값을 얻을 수도 있습니다 . 후자는 4 초 이하의 선택적 정밀도를 수용합니다. ( &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-CURRENT&quot;&gt;9.9.4 절을&lt;/a&gt; 참조하십시오 .) 이것들은 SQL 함수이며 데이터 입력 문자열에서 인식 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7345097a3373ddd38c8dbf7f484bcb7a83adcfc5" translate="yes" xml:space="preserve">
          <source>The following SQL-standard functions work on bit strings as well as character strings: &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;bit_length&lt;/code&gt;, &lt;code&gt;octet_length&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;.</source>
          <target state="translated">다음 SQL 표준 기능뿐만 아니라 문자열로 비트 스트링 작업 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;bit_length&lt;/code&gt; , &lt;code&gt;octet_length&lt;/code&gt; , &lt;code&gt;position&lt;/code&gt; , &lt;code&gt;substring&lt;/code&gt; , &lt;code&gt;overlay&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
