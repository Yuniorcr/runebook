<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="5653840df3e08aca29c7e9d9cb68d9fb889238fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LISTEN&lt;/code&gt; registers the current session as a listener on the notification channel named &lt;code&gt;channel&lt;/code&gt;. If the current session is already registered as a listener for this notification channel, nothing is done.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 레지스터에게 알림 채널 이름에 리스너로서 현재 세션 &lt;code&gt;channel&lt;/code&gt; . 현재 세션이이 알림 채널의 리스너로 이미 등록 된 경우 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b3e41f03caa3e2785ea13c4276b7e47ceea7176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LISTEN&lt;/code&gt; takes effect at transaction commit. If &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; is executed within a transaction that later rolls back, the set of notification channels being listened to is unchanged.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 은 트랜잭션 커밋시 적용됩니다. 나중에 롤백하는 트랜잭션 내에서 &lt;code&gt;LISTEN&lt;/code&gt; 또는 &lt;code&gt;UNLISTEN&lt;/code&gt; 이 실행 되면 수신되는 알림 채널 세트는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b73971cfc9fdce528271a3555597a1c8aee4b13d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;NOTIFY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; , &lt;code&gt;NOTIFY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcf215a5c675dbca4b38c90d0445dfbad1bd3dec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOAD&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;LOAD&lt;/code&gt; 는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="95f8c9bfb521ec22f3709c6bc0365ceb73829943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCAL&lt;/code&gt;&lt;code&gt;DEFAULT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LOCAL&lt;/code&gt;&lt;code&gt;DEFAULT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7784cf855669dd06dec63b60ed8f584df4f5370a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK TABLE ... IN ACCESS SHARE MODE&lt;/code&gt; requires &lt;code&gt;SELECT&lt;/code&gt; privileges on the target table. &lt;code&gt;LOCK TABLE ... IN ROW EXCLUSIVE MODE&lt;/code&gt; requires &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt; privileges on the target table. All other forms of &lt;code&gt;LOCK&lt;/code&gt; require table-level &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt; privileges.</source>
          <target state="translated">&lt;code&gt;LOCK TABLE ... IN ACCESS SHARE MODE&lt;/code&gt; 에는 대상 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 특권이 필요 합니다. &lt;code&gt;LOCK TABLE ... IN ROW EXCLUSIVE MODE&lt;/code&gt; 필요 &lt;code&gt;INSERT&lt;/code&gt; 가 , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;TRUNCATE&lt;/code&gt; 의 대상 테이블에 권한. 다른 모든 형태의 &lt;code&gt;LOCK&lt;/code&gt; 에는 테이블 레벨 &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;TRUNCATE&lt;/code&gt; 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e59eee6ed4889200aad2e11105878561b951d5b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK TABLE&lt;/code&gt; is useless outside a transaction block: the lock would remain held only to the completion of the statement. Therefore PostgreSQL reports an error if &lt;code&gt;LOCK&lt;/code&gt; is used outside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;) to define a transaction block.</source>
          <target state="translated">&lt;code&gt;LOCK TABLE&lt;/code&gt; 은 트랜잭션 블록 외부에서는 쓸모가 없습니다. 잠금은 명령문 완료시에만 유지됩니다. 따라서 PostgreSQL 은 &lt;code&gt;LOCK&lt;/code&gt; 이 트랜잭션 블록 외부에서 사용되는 경우 오류를보고합니다 . 사용은 &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; 및 &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (또는 &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; 트랜잭션 블록을 정의하기 위해).</target>
        </trans-unit>
        <trans-unit id="67988adabe3d16617a2a92328ddfb21d35b21654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK TABLE&lt;/code&gt; obtains a table-level lock, waiting if necessary for any conflicting locks to be released. If &lt;code&gt;NOWAIT&lt;/code&gt; is specified, &lt;code&gt;LOCK TABLE&lt;/code&gt; does not wait to acquire the desired lock: if it cannot be acquired immediately, the command is aborted and an error is emitted. Once obtained, the lock is held for the remainder of the current transaction. (There is no &lt;code&gt;UNLOCK TABLE&lt;/code&gt; command; locks are always released at transaction end.)</source>
          <target state="translated">&lt;code&gt;LOCK TABLE&lt;/code&gt; 은 충돌하는 잠금이 해제 될 때까지 대기하면서 테이블 수준 잠금을 얻습니다. 경우 &lt;code&gt;NOWAIT&lt;/code&gt; 가 지정되어, &lt;code&gt;LOCK TABLE&lt;/code&gt; 이 원하는 잠금을 획득하기 위해 대기하지 않습니다이 바로 취득 할 수없는 경우, 명령이 중단되고 오류가 방출된다. 일단 획득되면, 현재 트랜잭션의 나머지 부분에 대해 잠금이 유지됩니다. ( &lt;code&gt;UNLOCK TABLE&lt;/code&gt; 명령 은 없으며 트랜잭션 종료시 항상 잠금이 해제됩니다.)</target>
        </trans-unit>
        <trans-unit id="44348119132a0eaff71eedd1b2e642b04395ddaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK TABLE&lt;/code&gt; only deals with table-level locks, and so the mode names involving &lt;code&gt;ROW&lt;/code&gt; are all misnomers. These mode names should generally be read as indicating the intention of the user to acquire row-level locks within the locked table. Also, &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode is a shareable table lock. Keep in mind that all the lock modes have identical semantics so far as &lt;code&gt;LOCK TABLE&lt;/code&gt; is concerned, differing only in the rules about which modes conflict with which. For information on how to acquire an actual row-level lock, see &lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;Section 13.3.2&lt;/a&gt; and the &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;The Locking Clause&lt;/a&gt; in the &lt;code&gt;SELECT&lt;/code&gt; reference documentation.</source>
          <target state="translated">&lt;code&gt;LOCK TABLE&lt;/code&gt; 은 테이블 수준 잠금 만 처리하므로 &lt;code&gt;ROW&lt;/code&gt; 와 관련된 모드 이름 은 모두 잘못입니다. 이 모드 이름은 일반적으로 사용자가 잠긴 테이블 내에서 행 레벨 잠금을 획득하려는 의도를 나타내는 것으로 읽혀 져야합니다. 또한 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드는 공유 가능한 테이블 잠금입니다. &lt;code&gt;LOCK TABLE&lt;/code&gt; 에 관한 한 모든 잠금 모드는 동일한 의미를 가지며 , 어떤 모드가 어떤 모드와 충돌하는지에 대한 규칙 만 다릅니다. 실제 행 수준 잠금을 얻는 방법에 대한 자세한 내용 은 &lt;code&gt;SELECT&lt;/code&gt; 참조 설명서 &lt;a href=&quot;sql-select#SQL-FOR-UPDATE-SHARE&quot;&gt;의 &lt;/a&gt;&lt;a href=&quot;explicit-locking#LOCKING-ROWS&quot;&gt;13.3.2 절&lt;/a&gt; 및 잠금 절 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="271b89db6d1df5fe7ad7c2f69c3f488757e1789c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK TABLE&lt;/code&gt;, though only when explicitly in one of these modes: &lt;code&gt;ACCESS SHARE&lt;/code&gt;, &lt;code&gt;ROW SHARE&lt;/code&gt; or &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LOCK TABLE&lt;/code&gt; &lt;code&gt;ACCESS SHARE&lt;/code&gt; , &lt;code&gt;ROW SHARE&lt;/code&gt; 또는 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; 모드 중 하나 인 경우에만 LOCK TABLE .</target>
        </trans-unit>
        <trans-unit id="3a6fa77630e27d5e136b368719ad4a97c24a0aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK&lt;/code&gt; in short default form, since it requests &lt;code&gt;ACCESS EXCLUSIVE MODE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LOCK&lt;/code&gt; &lt;code&gt;ACCESS EXCLUSIVE MODE&lt;/code&gt; 를 요청하기 때문에 짧은 기본 형식의 LOCK .</target>
        </trans-unit>
        <trans-unit id="b12da6e18c4438ad3cf3b90952a1a063e11c2f0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK&lt;/code&gt; that explicitly requests a mode higher than &lt;code&gt;ROW EXCLUSIVE MODE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LOCK&lt;/code&gt; 명시 적으로보다 높은 모드를 요청 &lt;code&gt;ROW EXCLUSIVE MODE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d5f4f8a945f3f652e213d2b0a1d6ccce46b5d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOGIN&lt;/code&gt;&lt;code&gt;NOLOGIN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LOGIN&lt;/code&gt;&lt;code&gt;NOLOGIN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a868a86f042401112e26244bdd2bc6d78c935532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LWLock&lt;/code&gt;: The backend is waiting for a lightweight lock. Each such lock protects a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.)</source>
          <target state="translated">&lt;code&gt;LWLock&lt;/code&gt; : 백엔드가 가벼운 잠금을 기다리고 있습니다. 이러한 각 잠금은 공유 메모리의 특정 데이터 구조를 보호합니다. &lt;code&gt;wait_event&lt;/code&gt; 는 경량 잠금의 목적을 식별하는 이름을 포함합니다. (일부 자물쇠에는 특정 이름이 있으며, 다른 자물쇠는 비슷한 목적을 가진 자물쇠 그룹의 일부입니다.)</target>
        </trans-unit>
        <trans-unit id="0492febdcb827207e643811ca8e724dbf73dc994" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lock&lt;/code&gt;: The backend is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited.</source>
          <target state="translated">&lt;code&gt;Lock&lt;/code&gt; : 백엔드가 헤비급 잠금을 기다리고 있습니다. 잠금 관리자 잠금 또는 단순 잠금이라고도하는 헤비급 잠금은 주로 테이블과 같은 SQL 표시 가능 개체를 보호합니다. 그러나 관계 확장과 같은 특정 내부 작업에 대한 상호 배제를 보장하는 데에도 사용됩니다. &lt;code&gt;wait_event&lt;/code&gt; 는 대기중인 잠금 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="d8a9ecde56af9755a6e3404e9c865e72e701d1d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MAIN&lt;/code&gt; allows compression but not out-of-line storage. (Actually, out-of-line storage will still be performed for such columns, but only as a last resort when there is no other way to make the row small enough to fit on a page.)</source>
          <target state="translated">&lt;code&gt;MAIN&lt;/code&gt; 은 압축을 허용하지만 외부 저장 공간은 허용하지 않습니다. 실제로 실제로 해당 열에 대해 오프라인 저장은 계속 수행되지만 행을 페이지에 맞게 충분히 작게 만들 수있는 다른 방법이없는 경우에만 최후의 수단으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c54870a445476d2913d5fff25558004972dfa82b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; = { &lt;code&gt;READ_ONLY&lt;/code&gt; | &lt;code&gt;SHAREABLE&lt;/code&gt; | &lt;code&gt;READ_WRITE&lt;/code&gt; }</source>
          <target state="translated">&lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; = { &lt;code&gt;READ_ONLY&lt;/code&gt; | &lt;code&gt;SHAREABLE&lt;/code&gt; | &lt;code&gt;READ_WRITE&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="67f2bab3a6bf26553fc3545698e8e2961547f815" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MOVE&lt;/code&gt; repositions a cursor without retrieving any data. &lt;code&gt;MOVE&lt;/code&gt; works exactly like the &lt;code&gt;FETCH&lt;/code&gt; command, except it only positions the cursor and does not return rows.</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 는 데이터를 검색하지 않고 커서의 위치를 ​​변경합니다. &lt;code&gt;MOVE&lt;/code&gt; 는 커서 위치 만 지정하고 행을 리턴하지 않는다는 점을 제외하고 &lt;code&gt;FETCH&lt;/code&gt; 명령과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f78b256c5af9095b0d4371034706363582d5aa96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MaxFragments&lt;/code&gt;: maximum number of text excerpts or fragments to display. The default value of zero selects a non-fragment-oriented headline generation method. A value greater than zero selects fragment-based headline generation. This method finds text fragments with as many query words as possible and stretches those fragments around the query words. As a result query words are close to the middle of each fragment and have words on each side. Each fragment will be of at most &lt;code&gt;MaxWords&lt;/code&gt; and words of length &lt;code&gt;ShortWord&lt;/code&gt; or less are dropped at the start and end of each fragment. If not all query words are found in the document, then a single fragment of the first &lt;code&gt;MinWords&lt;/code&gt; in the document will be displayed.</source>
          <target state="translated">&lt;code&gt;MaxFragments&lt;/code&gt; : 표시 할 최대 텍스트 발췌 또는 조각 수입니다. 기본값 0은 조각이 아닌 헤드 라인 생성 방법을 선택합니다. 0보다 큰 값은 조각 기반 헤드 라인 생성을 선택합니다. 이 방법은 가능한 많은 쿼리 단어가있는 텍스트 조각을 찾아서 해당 단어 조각을 쿼리 단어 주위로 확장합니다. 결과적으로 쿼리 단어는 각 조각의 중간에 가까우며 각면에 단어가 있습니다. 각 조각은 최대 &lt;code&gt;MaxWords&lt;/code&gt; 이고 &lt;code&gt;ShortWord&lt;/code&gt; 이하의 단어 는 각 조각의 시작과 끝에서 삭제됩니다. 문서에서 모든 검색어가 발견되지 않으면 문서에서 첫 번째 &lt;code&gt;MinWords&lt;/code&gt; 의 단일 조각 이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5e795dc21061d089a5b9d07c8a9ce8bd9648ac77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MaxWords&lt;/code&gt;, &lt;code&gt;MinWords&lt;/code&gt;: these numbers determine the longest and shortest headlines to output.</source>
          <target state="translated">&lt;code&gt;MaxWords&lt;/code&gt; , &lt;code&gt;MinWords&lt;/code&gt; :이 숫자는 출력 할 가장 길고 짧은 헤드 라인을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3009e34324e4a38b476bd1daf6b48200f3145c1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mskanji&lt;/code&gt;, &lt;code&gt;ShiftJIS&lt;/code&gt;, &lt;code&gt;WIN932&lt;/code&gt;, &lt;code&gt;Windows932&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mskanji&lt;/code&gt; , &lt;code&gt;ShiftJIS&lt;/code&gt; , &lt;code&gt;WIN932&lt;/code&gt; , &lt;code&gt;Windows932&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9370e5f4d22e4eed05dc04dfb243a53418c988b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NATURAL&lt;/code&gt; is shorthand for a &lt;code&gt;USING&lt;/code&gt; list that mentions all columns in the two tables that have matching names. If there are no common column names, &lt;code&gt;NATURAL&lt;/code&gt; is equivalent to &lt;code&gt;ON TRUE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NATURAL&lt;/code&gt; 은 이름이 일치하는 두 테이블의 모든 열을 언급 하는 &lt;code&gt;USING&lt;/code&gt; 목록의 약어입니다 . 공통 열 이름이 없으면 &lt;code&gt;NATURAL&lt;/code&gt; 은 &lt;code&gt;ON TRUE&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e93a9a24e229d544603d17ff0c5351a79433efcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NO FORCE&lt;/code&gt;/&lt;code&gt;FORCE ROW LEVEL SECURITY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NO FORCE&lt;/code&gt; / &lt;code&gt;FORCE ROW LEVEL SECURITY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32fd6a9477e7a7e6cb857114e30a423299622ab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOT IN&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;&amp;gt; ALL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NOT IN&lt;/code&gt; 은 &lt;code&gt;&amp;lt;&amp;gt; ALL&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1788846d913b947add44c8d1a3963e2b175502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOTIFY&lt;/code&gt; interacts with SQL transactions in some important ways. Firstly, if a &lt;code&gt;NOTIFY&lt;/code&gt; is executed inside a transaction, the notify events are not delivered until and unless the transaction is committed. This is appropriate, since if the transaction is aborted, all the commands within it have had no effect, including &lt;code&gt;NOTIFY&lt;/code&gt;. But it can be disconcerting if one is expecting the notification events to be delivered immediately. Secondly, if a listening session receives a notification signal while it is within a transaction, the notification event will not be delivered to its connected client until just after the transaction is completed (either committed or aborted). Again, the reasoning is that if a notification were delivered within a transaction that was later aborted, one would want the notification to be undone somehow &amp;mdash; but the server cannot &amp;ldquo;take back&amp;rdquo; a notification once it has sent it to the client. So notification events are only delivered between transactions. The upshot of this is that applications using &lt;code&gt;NOTIFY&lt;/code&gt; for real-time signaling should try to keep their transactions short.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 는 몇 가지 중요한 방식으로 SQL 트랜잭션과 상호 작용합니다. 먼저, 트랜잭션 내 에서 &lt;code&gt;NOTIFY&lt;/code&gt; 가 실행되면 트랜잭션이 커밋 될 때까지 통지 이벤트가 전달되지 않습니다. 트랜잭션이 중단되면 &lt;code&gt;NOTIFY&lt;/code&gt; 를 포함하여 트랜잭션 내의 모든 명령이 영향을 미치지 않기 때문에 이것은 적절합니다.. 그러나 알림 이벤트가 즉시 전달 될 것으로 예상되면 당황 스러울 수 있습니다. 두 번째로, 수신 세션이 트랜잭션 내에있는 동안 알림 신호를 수신하면 트랜잭션이 완료된 (커밋되거나 중단 된) 직후까지 알림 이벤트가 연결된 클라이언트에 전달되지 않습니다. 다시 말하지만, 나중에 중단 된 트랜잭션 내에서 알림이 전달 된 경우 알림이 어떻게 든 취소되기를 원하지만 서버가 알림을 클라이언트에 보낸 후에는 알림을 &quot;복구&quot;할 수 없기 때문입니다. 따라서 알림 이벤트는 트랜잭션간에 만 전달됩니다. 이것의 결과는 실시간 시그널링을 위해 &lt;code&gt;NOTIFY&lt;/code&gt; 를 사용하는 응용 프로그램 은 트랜잭션을 짧게 유지해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cbaf3c1ca99c24bf63e2672ca59412ae8fc12b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOTIFY&lt;/code&gt; provides a simple interprocess communication mechanism for a collection of processes accessing the same PostgreSQL database. A payload string can be sent along with the notification, and higher-level mechanisms for passing structured data can be built by using tables in the database to pass additional data from notifier to listener(s).</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 는 동일한 PostgreSQL 데이터베이스에 액세스하는 프로세스 모음에 간단한 프로세스 간 통신 메커니즘을 제공합니다. 페이로드 문자열은 알림과 함께 전송 될 수 있으며, 데이터베이스의 테이블을 사용하여 알리미에서 리스너로 추가 데이터를 전달하여 구조화 된 데이터를 전달하는 고급 메커니즘을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aba8c8edc2d0f2d0ad11078655d95868154c2aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NULL&lt;/code&gt; if the dictionary does not recognize the input token</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 사전이 입력 토큰을 인식하지 못하면 NULL</target>
        </trans-unit>
        <trans-unit id="19a6f2a1d22051c0a250853fb044bf96aedbb98f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;Constraint&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt;&amp;ldquo;Constraint&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d6d9c7a7f4e8e1b9914476ca0ee065e50dc90564" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;infinity&lt;/code&gt; values are disallowed</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;infinity&lt;/code&gt; 값이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="605823b1cabd1d3a2197a74c4fb48f4c3979851a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OFFSET&lt;/code&gt; says to skip that many rows before beginning to return rows. &lt;code&gt;OFFSET 0&lt;/code&gt; is the same as omitting the &lt;code&gt;OFFSET&lt;/code&gt; clause, as is &lt;code&gt;OFFSET&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 은 행을 반환하기 전에 많은 행을 건너 뛰라고 말합니다. &lt;code&gt;OFFSET 0&lt;/code&gt; 은 NULL 인수가있는 &lt;code&gt;OFFSET&lt;/code&gt; 과 마찬가지로 &lt;code&gt;OFFSET&lt;/code&gt; 절 을 생략하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7543c87ea4fe740ad57d6fed403dcce9f896e9fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OLD TABLE&lt;/code&gt;&lt;code&gt;NEW TABLE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OLD TABLE&lt;/code&gt; &lt;code&gt;NEW TABLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c8f1f4c65d8e665d726555aea5b23961ff948b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; guarantees an atomic &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; outcome; provided there is no independent error, one of those two outcomes is guaranteed, even under high concurrency. This is also known as &lt;em&gt;UPSERT&lt;/em&gt; &amp;mdash; &amp;ldquo;UPDATE or INSERT&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 는 원 자성 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 결과를 보장합니다 . 독립적 인 오류가없는 경우 높은 동시성에서도이 두 결과 중 하나가 보장됩니다. 이것은 &lt;em&gt;UPSERT&lt;/em&gt; &amp;ndash;&amp;ldquo;UPDATE 또는 INSERT&amp;rdquo; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="9a4d7f68a04d7fcdb48f243ec84442880f017a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON CONFLICT&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;ON CONFLICT&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="ef76fa96381ebd2acd25f709a599c55ff018fdf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON CONFLICT&lt;/code&gt; can be used to specify an alternative action to raising a unique constraint or exclusion constraint violation error. (See &lt;a href=&quot;sql-insert#SQL-ON-CONFLICT&quot;&gt;&lt;code&gt;ON CONFLICT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;ON CONFLICT&lt;/code&gt; 를 사용하여 고유 제한 조건 또는 제외 제한 조건 위반 오류를 발생시키는 대체 조치를 지정할 수 있습니다. ( 아래의 &lt;a href=&quot;sql-insert#SQL-ON-CONFLICT&quot;&gt; &lt;code&gt;ON CONFLICT&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6d77e4fc09afe503fd786ece7b83490977ecb4ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ONLY&lt;/code&gt; and Inheritance</source>
          <target state="translated">&lt;code&gt;ONLY&lt;/code&gt; 상속</target>
        </trans-unit>
        <trans-unit id="7d11c16e8bb5dd8377b87005906dd21239cb8693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OR&lt;/code&gt;: logical or will be converted to the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;OR&lt;/code&gt; : 논리 또는 &lt;code&gt;|&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="5a08a15fefe6814ee4836089daeaadc9bea71c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ORDER BY&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 조항 별 주문</target>
        </trans-unit>
        <trans-unit id="decc2351a4d24a206b8d252f8b536b950fa219b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ORDER BY&lt;/code&gt; can be applied to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; combination, but in this case it is only permitted to sort by output column names or numbers, not by expressions.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; 는 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; 조합 의 결과에 적용 할 수 있지만이 경우 표현식이 아닌 출력 열 이름 또는 숫자로만 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e6c94741e9b92007ccc5e07afc52fa40d3ea40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OWNED BY&lt;/code&gt;&lt;code&gt;table_name&lt;/code&gt;.&lt;code&gt;column_name&lt;/code&gt;&lt;code&gt;OWNED BY NONE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OWNED BY&lt;/code&gt; &lt;code&gt;table_name&lt;/code&gt; . &lt;code&gt;column_name&lt;/code&gt; &lt;code&gt;OWNED BY NONE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0aaff0614ae677ff8f32da11c66acd27aa2c600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PARALLEL =&lt;/code&gt; { &lt;code&gt;SAFE&lt;/code&gt; | &lt;code&gt;RESTRICTED&lt;/code&gt; | &lt;code&gt;UNSAFE&lt;/code&gt; }</source>
          <target state="translated">&lt;code&gt;PARALLEL =&lt;/code&gt; { &lt;code&gt;SAFE&lt;/code&gt; | &lt;code&gt;RESTRICTED&lt;/code&gt; | &lt;code&gt;UNSAFE&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="49e11464e2f6110892981a1e4a2dca1e7913dd0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; indicates that the function can't be executed in parallel mode and the presence of such a function in an SQL statement forces a serial execution plan. This is the default. &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; indicates that the function can be executed in parallel mode, but the execution is restricted to parallel group leader. &lt;code&gt;PARALLEL SAFE&lt;/code&gt; indicates that the function is safe to run in parallel mode without restriction.</source>
          <target state="translated">&lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; 는 함수를 병렬 모드에서 실행할 수 없으며 SQL 문에 이러한 함수가 있으면 직렬 실행 계획이 적용됨을 나타냅니다. 이것이 기본값입니다. &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 는 기능이 병렬 모드에서 실행될 수 있지만 실행이 병렬 그룹 리더로 제한됨을 나타냅니다. &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 는 기능이 제한없이 병렬 모드에서 실행해도 안전함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6bc66003abf587dbc8d04656be6765ab0e76f616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PARTITION BY&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;PARTITION BY&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="04e25f76bbf998a06e376a90b8bbeb0dc8315fb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PARTITION OF&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;PARTITION OF&lt;/code&gt; 조항 의 분할</target>
        </trans-unit>
        <trans-unit id="653b2979e39f83acdda4e50dee7f4bbfe663603d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PGDATABASE&lt;/code&gt;&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGOPTIONS&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PGDATABASE&lt;/code&gt;&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGOPTIONS&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b7ad296a7f545cbc4bc4dd898b136d61d8fb60e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PGDATABASE&lt;/code&gt;&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PGDATABASE&lt;/code&gt;&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15db4b5363639dce5a2b6763039bc784f48a6d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGOPTIONS&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGOPTIONS&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c59a91c929ebf38ca3eedc631ca8808c8c292da7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PGHOST&lt;/code&gt;&lt;code&gt;PGPORT&lt;/code&gt;&lt;code&gt;PGUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="786ac7fea668d056bef279bd10627037bae6b210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PL&lt;/code&gt;, &lt;code&gt;SG&lt;/code&gt;, and &lt;code&gt;TH&lt;/code&gt; are PostgreSQL extensions.</source>
          <target state="translated">&lt;code&gt;PL&lt;/code&gt; , &lt;code&gt;SG&lt;/code&gt; 및 &lt;code&gt;TH&lt;/code&gt; 는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="f67e209b4f79f14b4aa2e6ae876921aa169a9feb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PLAIN&lt;/code&gt; prevents either compression or out-of-line storage; furthermore it disables use of single-byte headers for varlena types. This is the only possible strategy for columns of non-TOAST-able data types.</source>
          <target state="translated">&lt;code&gt;PLAIN&lt;/code&gt; 은 압축 또는 외부 저장을 방지합니다. 또한 varlena 유형에 단일 바이트 헤더 사용을 비활성화합니다. TOAST 불가능 데이터 유형의 컬럼에 가능한 유일한 전략입니다.</target>
        </trans-unit>
        <trans-unit id="b5f2a3f7313ee7839f65568a2f7565727218a8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is a PostgreSQL extension. It is intended for use by external transaction management systems, some of which are covered by standards (such as X/Open XA), but the SQL side of those systems is not standardized.</source>
          <target state="translated">&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 PostgreSQL 확장입니다. 외부 트랜잭션 관리 시스템에서 사용하기위한 것으로 일부는 표준 (예 : X / Open XA)에 의해 다루어 지지만 해당 시스템의 SQL 쪽은 ​​표준화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b64c7c93b47e43d55e0c0ac3aac08642f8bffa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; is not intended for use in applications or interactive sessions. Its purpose is to allow an external transaction manager to perform atomic global transactions across multiple databases or other transactional resources. Unless you're writing a transaction manager, you probably shouldn't be using &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 응용 프로그램 또는 대화식 세션에서 사용하기위한 것이 아닙니다. 외부 트랜잭션 관리자가 여러 데이터베이스 또는 기타 트랜잭션 자원에서 원자 전역 트랜잭션을 수행 할 수 있도록하기위한 것입니다. 트랜잭션 관리자를 작성하지 않으면 &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 을 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="28c63377c548812cc1c1b856610a262df5cb4375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; prepares the current transaction for two-phase commit. After this command, the transaction is no longer associated with the current session; instead, its state is fully stored on disk, and there is a very high probability that it can be committed successfully, even if a database crash occurs before the commit is requested.</source>
          <target state="translated">&lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 은 2 단계 커밋을 위해 현재 트랜잭션을 준비합니다. 이 명령 후에는 트랜잭션이 더 이상 현재 세션과 연관되지 않습니다. 대신 상태는 디스크에 완전히 저장되며 커밋이 요청되기 전에 데이터베이스 충돌이 발생하더라도 성공적으로 커밋 될 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="b108c5cac02b42d29a008a4ce832cfc8fba5571e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREPARE&lt;/code&gt; creates a prepared statement. A prepared statement is a server-side object that can be used to optimize performance. When the &lt;code&gt;PREPARE&lt;/code&gt; statement is executed, the specified statement is parsed, analyzed, and rewritten. When an &lt;code&gt;EXECUTE&lt;/code&gt; command is subsequently issued, the prepared statement is planned and executed. This division of labor avoids repetitive parse analysis work, while allowing the execution plan to depend on the specific parameter values supplied.</source>
          <target state="translated">&lt;code&gt;PREPARE&lt;/code&gt; 는 준비된 명령문을 작성합니다. 준비된 명령문은 성능을 최적화하는 데 사용할 수있는 서버 측 오브젝트입니다. 때 &lt;code&gt;PREPARE&lt;/code&gt; 문이 실행될, 지정된 문, 구문 분석, 분석 및 다시 작성됩니다. 때 &lt;code&gt;EXECUTE&lt;/code&gt; 이후에 발행 된 명령을 준비된 문은 계획되고 실행됩니다. 이 분업은 반복적 인 구문 분석 분석 작업을 피하면서 실행 계획이 제공된 특정 매개 변수 값에 의존하도록합니다.</target>
        </trans-unit>
        <trans-unit id="2ccce4dcff00b35d22e336a75f78aefbec833baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PRIMARY KEY&lt;/code&gt; (column constraint)&lt;code&gt;PRIMARY KEY ( column_name [, ... ] )&lt;/code&gt; [ INCLUDE ( &lt;code&gt;column_name&lt;/code&gt; [, ...]) ] (table constraint)</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; (열 제약 조건) &lt;code&gt;PRIMARY KEY ( column_name [, ... ] )&lt;/code&gt; [INCLUDE ( &lt;code&gt;column_name&lt;/code&gt; [, ...])] (테이블 제약 조건)</target>
        </trans-unit>
        <trans-unit id="d062e691a0f16dfe887bad98786d2bf1791fed1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints share the restrictions that &lt;code&gt;UNIQUE&lt;/code&gt; constraints have when placed on partitioned tables.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건은 분할 된 테이블에 배치 할 때 &lt;code&gt;UNIQUE&lt;/code&gt; 제약 조건 의 제한 사항을 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="973b293c7e5105338915e3ef583332305ae4a0ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PRIMARY KEY&lt;/code&gt; enforces the same data constraints as a combination of &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt;, but identifying a set of columns as the primary key also provides metadata about the design of the schema, since a primary key implies that other tables can rely on this set of columns as a unique identifier for rows.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 는 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;NOT NULL&lt;/code&gt; 의 조합과 동일한 데이터 제약 조건을 적용 하지만 기본 키로 열 집합을 식별하면 스키마 디자인에 대한 메타 데이터도 제공합니다. 기본 키는 다른 테이블이이 세트에 의존 할 수 있기 때문에 열을 행의 고유 식별자로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad0f85833ec199eaa2d234c01a06b3fee9089c4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PROMPT1&lt;/code&gt;&lt;code&gt;PROMPT2&lt;/code&gt;&lt;code&gt;PROMPT3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PROMPT1&lt;/code&gt;&lt;code&gt;PROMPT2&lt;/code&gt;&lt;code&gt;PROMPT3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56411cc756f821a0ed62aa4ae0a8c00c7275bd04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PSQL_EDITOR&lt;/code&gt;&lt;code&gt;EDITOR&lt;/code&gt;&lt;code&gt;VISUAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PSQL_EDITOR&lt;/code&gt;&lt;code&gt;EDITOR&lt;/code&gt;&lt;code&gt;VISUAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbe530d1a607b5271f42283cb71034d8012013f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PSQL_PAGER&lt;/code&gt;&lt;code&gt;PAGER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PSQL_PAGER&lt;/code&gt;&lt;code&gt;PAGER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f9573e13fb81ba5e84214ab91b5b77f9b79539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REASSIGN OWNED&lt;/code&gt; instructs the system to change the ownership of database objects owned by any of the &lt;code&gt;old_roles&lt;/code&gt; to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 의 모든 소유 객체 데이터베이스의 소유권 변경하도록 지시에게 시스템을 &lt;code&gt;old_roles&lt;/code&gt; 에 &lt;code&gt;new_role&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e45366c802078b050260b80ac7d5e87b44b6ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REASSIGN OWNED&lt;/code&gt; is often used to prepare for the removal of one or more roles. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; does not affect objects within other databases, it is usually necessary to execute this command in each database that contains objects owned by a role that is to be removed.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 는 종종 하나 이상의 역할 제거를 준비하는 데 사용됩니다. 때문에 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; 다른 데이터베이스 내의 개체에 영향을주지 않습니다, 그것을 제거 할 수있는 역할이 소유 객체가 포함 된 각 데이터베이스에서이 명령을 실행하는 것이 필요하다.</target>
        </trans-unit>
        <trans-unit id="77559c81a90445f28aba9506e5fb97a64be21e6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REASSIGN OWNED&lt;/code&gt; requires membership on both the source role(s) and the target role.</source>
          <target state="translated">&lt;code&gt;REASSIGN OWNED&lt;/code&gt; 는 소스 역할과 대상 역할 모두에 멤버십이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24d74c1dfb498197230927c7b3098fcafc7dd5fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REFERENCES reftable [ ( refcolumn ) ] [ MATCH matchtype ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ]&lt;/code&gt; (column constraint)&lt;code&gt;FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ] [ MATCH matchtype ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ]&lt;/code&gt; (table constraint)</source>
          <target state="translated">&lt;code&gt;REFERENCES reftable [ ( refcolumn ) ] [ MATCH matchtype ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ]&lt;/code&gt; (column constraint) &lt;code&gt;FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ] [ MATCH matchtype ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ]&lt;/code&gt; (테이블 제약 조건)</target>
        </trans-unit>
        <trans-unit id="586b95a2e3a5e6095a38d3813adc6eef67388efd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REFERENCING&lt;/code&gt; clause name for &lt;code&gt;NEW TABLE&lt;/code&gt;, or null if none</source>
          <target state="translated">&lt;code&gt;REFERENCING&lt;/code&gt; &lt;code&gt;NEW TABLE&lt;/code&gt; 의REFERENCING 절 이름. 없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="0764e1eebd939afe8650b6ce63de3e1c3c2c733e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REFERENCING&lt;/code&gt; clause name for &lt;code&gt;OLD TABLE&lt;/code&gt;, or null if none</source>
          <target state="translated">&lt;code&gt;REFERENCING&lt;/code&gt; &lt;code&gt;OLD TABLE&lt;/code&gt; 에 대한 REFERENCING 절 이름 또는없는 경우 널</target>
        </trans-unit>
        <trans-unit id="1c1eff880c036d37f0041f58f36c9777ee5fb441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; completely replaces the contents of a materialized view. To execute this command you must be the owner of the materialized view. The old contents are discarded. If &lt;code&gt;WITH DATA&lt;/code&gt; is specified (or defaults) the backing query is executed to provide the new data, and the materialized view is left in a scannable state. If &lt;code&gt;WITH NO DATA&lt;/code&gt; is specified no new data is generated and the materialized view is left in an unscannable state.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 는 구체화 된 뷰의 내용을 완전히 대체합니다. 이 명령을 실행하려면 구체화 된 뷰의 소유자 여야합니다. 오래된 내용은 폐기됩니다. &lt;code&gt;WITH DATA&lt;/code&gt; 가 지정 되면 (또는 기본값) 새 데이터를 제공하기 위해 백업 조회가 실행되고 구체화 된보기는 스캔 가능한 상태로 남아 있습니다. &lt;code&gt;WITH NO DATA&lt;/code&gt; 가 지정 되면 새 데이터가 생성되지 않으며 구체화 된보기는 스캔 할 수없는 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5d7f7025ec316e55ce72dd01c0ae5025cc0899" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; 는 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="05d71b10e260ac3a716a4cf5c798f5e13fe6021e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; is waiting for transactions with read locks on the table to finish, before dropping the old index. This phase is skipped when not in concurrent mode. Columns &lt;code&gt;lockers_total&lt;/code&gt;, &lt;code&gt;lockers_done&lt;/code&gt; and &lt;code&gt;current_locker_pid&lt;/code&gt; contain the progress information for this phase.</source>
          <target state="translated">&lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 는 이전 인덱스를 삭제하기 전에 테이블에서 읽기 잠금이있는 트랜잭션이 완료되기를 기다리고 있습니다. 동시 모드에 있지 않으면이 단계를 건너 뜁니다. &lt;code&gt;lockers_total&lt;/code&gt; , &lt;code&gt;lockers_done&lt;/code&gt; 및 &lt;code&gt;current_locker_pid&lt;/code&gt; 열에 는이 단계의 진행 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0ed8d667dbc8eff65da9090d344181b84d3d866a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; is waiting for transactions with read locks on the table to finish, before marking the old index dead. This phase is skipped when not in concurrent mode. Columns &lt;code&gt;lockers_total&lt;/code&gt;, &lt;code&gt;lockers_done&lt;/code&gt; and &lt;code&gt;current_locker_pid&lt;/code&gt; contain the progress information for this phase.</source>
          <target state="translated">&lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 는 테이블에서 읽기 잠금이있는 트랜잭션이 완료되기를 기다렸다가 이전 인덱스를 사용 불능으로 표시합니다. 동시 모드에 있지 않으면이 단계를 건너 뜁니다. &lt;code&gt;lockers_total&lt;/code&gt; , &lt;code&gt;lockers_done&lt;/code&gt; 및 &lt;code&gt;current_locker_pid&lt;/code&gt; 열에 는이 단계의 진행 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="073c345fe49a9dd2504687475ee20a1983109105" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REINDEX SYSTEM&lt;/code&gt; does not support &lt;code&gt;CONCURRENTLY&lt;/code&gt; since system catalogs cannot be reindexed concurrently.</source>
          <target state="translated">&lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 시스템 카탈로그를 동시에 재 색인 할 수 없으므로 REINDEX SYSTEM 은 &lt;code&gt;CONCURRENTLY&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e539d329d76f200376b0660b735cbdffd0709e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REINDEX&lt;/code&gt; is similar to a drop and recreate of the index in that the index contents are rebuilt from scratch. However, the locking considerations are rather different. &lt;code&gt;REINDEX&lt;/code&gt; locks out writes but not reads of the index's parent table. It also takes an exclusive lock on the specific index being processed, which will block reads that attempt to use that index. In contrast, &lt;code&gt;DROP INDEX&lt;/code&gt; momentarily takes an exclusive lock on the parent table, blocking both writes and reads. The subsequent &lt;code&gt;CREATE INDEX&lt;/code&gt; locks out writes but not reads; since the index is not there, no read will attempt to use it, meaning that there will be no blocking but reads might be forced into expensive sequential scans.</source>
          <target state="translated">&lt;code&gt;REINDEX&lt;/code&gt; 는 인덱스 내용이 처음부터 다시 작성된다는 점에서 인덱스 삭제 및 재 작성과 유사합니다. 그러나 잠금 고려 사항은 다소 다릅니다. &lt;code&gt;REINDEX&lt;/code&gt; 는 인덱스의 상위 테이블에 대한 쓰기를 잠그지 만 읽기는 잠급니다. 또한 처리중인 특정 인덱스에 대해 독점 잠금을 수행하여 해당 인덱스를 사용하려는 읽기를 차단합니다. 반대로 &lt;code&gt;DROP INDEX&lt;/code&gt; 는 일시적으로 부모 테이블에 독점 잠금을 수행하여 쓰기와 읽기를 모두 차단합니다. 후속 &lt;code&gt;CREATE INDEX&lt;/code&gt; 는 쓰기를 잠그지 만 읽기는 잠급니다. 인덱스가 없으므로 읽기가 인덱스를 사용하려고 시도하지 않습니다. 즉, 블로킹은 없지만 읽기는 비싼 순차적 스캔으로 강제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9349af6a3d4226b85e558f9a546f4b982b3687f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REINDEX&lt;/code&gt; rebuilds an index using the data stored in the index's table, replacing the old copy of the index. There are several scenarios in which to use &lt;code&gt;REINDEX&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REINDEX&lt;/code&gt; 는 인덱스 테이블에 저장된 데이터를 사용하여 인덱스의 이전 복사본을 대체하여 인덱스를 다시 작성합니다. &lt;code&gt;REINDEX&lt;/code&gt; 를 사용하는 몇 가지 시나리오가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac286fe90c41206cd6e6ecc49479a1bc69339b0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELATIVE 0&lt;/code&gt;, &lt;code&gt;FORWARD 0&lt;/code&gt;, and &lt;code&gt;BACKWARD 0&lt;/code&gt; all request fetching the current row without moving the cursor, that is, re-fetching the most recently fetched row. This will succeed unless the cursor is positioned before the first row or after the last row; in which case, no row is returned.</source>
          <target state="translated">&lt;code&gt;RELATIVE 0&lt;/code&gt; , &lt;code&gt;FORWARD 0&lt;/code&gt; 및 &lt;code&gt;BACKWARD 0&lt;/code&gt; 은 모두 커서를 이동하지 않고 현재 행을 페치 (즉, 가장 최근에 페치 된 행을 다시 페치)하도록 요청합니다. 커서가 첫 번째 행 앞이나 마지막 행 뒤에 위치하지 않으면 성공합니다. 이 경우 행이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d2a6b4e8e4d4c709e20d6612957d14d6513ada9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; also destroys all savepoints that were established after the named savepoint was established.</source>
          <target state="translated">&lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; 는 이름이 지정된 세이브 포인트가 설정된 후 설정된 모든 세이브 포인트도 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="3fad6b173e5dfa1ed5d7c7b9e7a3f293e34116d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; destroys a savepoint previously defined in the current transaction.</source>
          <target state="translated">&lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; 는 현재 트랜잭션에서 이전에 정의 된 저장 점을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="cd2bc3fc15eb03b892b0b529acc033602e3f3bde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REPLICATION&lt;/code&gt;&lt;code&gt;NOREPLICATION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLICATION&lt;/code&gt;&lt;code&gt;NOREPLICATION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4430a1591bb6fd5e2aaed3b33b71cd5ac337daec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RESET&lt;/code&gt; is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="bcb322e13a09d669ff39eba8aec5ffa8168fcb34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RESET&lt;/code&gt; restores run-time parameters to their default values. &lt;code&gt;RESET&lt;/code&gt; is an alternative spelling for</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 은 런타임 매개 변수를 기본값으로 복원합니다. &lt;code&gt;RESET&lt;/code&gt; 은 다른 철자입니다.</target>
        </trans-unit>
        <trans-unit id="652098da481dd794c0dea55a3431f5e7311713eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RETURNING&lt;/code&gt; lists are treated the same as &lt;code&gt;SELECT&lt;/code&gt; output lists for this purpose.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 목록은 이 목적 으로 &lt;code&gt;SELECT&lt;/code&gt; 출력 목록 과 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="0f49db78adc8b0543ef139005bc69c3bfe36f212" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RETURNS NULL ON NULL INPUT&lt;/code&gt; or &lt;code&gt;STRICT&lt;/code&gt; indicates that the function always returns null whenever any of its arguments are null. If this parameter is specified, the function is not executed when there are null arguments; instead a null result is assumed automatically.</source>
          <target state="translated">&lt;code&gt;RETURNS NULL ON NULL INPUT&lt;/code&gt; 또는 &lt;code&gt;STRICT&lt;/code&gt; 는 인수가 널이 될 때마다 함수가 항상 널을 리턴 함을 나타냅니다. 이 매개 변수를 지정하면 널 인수가있을 때 함수가 실행되지 않습니다. 대신 null 결과는 자동으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="3711e8c79001ecd68f92c13f2ae20d9371ae479a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REVOKE&lt;/code&gt; can also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privileges &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; on the object. In this case the command is performed as though it were issued by the containing role that actually owns the object or holds the privileges &lt;code&gt;WITH GRANT OPTION&lt;/code&gt;. For example, if table &lt;code&gt;t1&lt;/code&gt; is owned by role &lt;code&gt;g1&lt;/code&gt;, of which role &lt;code&gt;u1&lt;/code&gt; is a member, then &lt;code&gt;u1&lt;/code&gt; can revoke privileges on &lt;code&gt;t1&lt;/code&gt; that are recorded as being granted by &lt;code&gt;g1&lt;/code&gt;. This would include grants made by &lt;code&gt;u1&lt;/code&gt; as well as by other members of role &lt;code&gt;g1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; 는 영향을받는 개체의 소유자는 아니지만 개체를 ​​소유 한 역할의 구성원이거나 개체에 대해 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 권한을 가진 역할의 구성원 인 역할에 의해 수행 될 수도 있습니다 . 이 경우 명령은 실제로 오브젝트를 소유하거나 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 권한을 보유하는 포함 역할에 의해 발행 된 것처럼 수행됩니다 . 테이블의 경우, 예를 들어, &lt;code&gt;t1&lt;/code&gt; 역할에 의해 소유 &lt;code&gt;g1&lt;/code&gt; 역할 그 중, &lt;code&gt;u1&lt;/code&gt; 구성원 다음 &lt;code&gt;u1&lt;/code&gt; 에 취소 할 권한 &lt;code&gt;t1&lt;/code&gt; 에 의해 부여되는 것으로서 기록된다 &lt;code&gt;g1&lt;/code&gt; . 여기에는 &lt;code&gt;u1&lt;/code&gt; 과 다른 역할 멤버가 부여한 보조금이 포함됩니다. &lt;code&gt;g1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="162ef650858f311b9691712fffd9641aa9707d73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROLE&lt;/code&gt;&lt;code&gt;role_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ROLE&lt;/code&gt;&lt;code&gt;role_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fe856629eeac6f3507360a38c354f481e0b5428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; is a PostgreSQL extension. It is intended for use by external transaction management systems, some of which are covered by standards (such as X/Open XA), but the SQL side of those systems is not standardized.</source>
          <target state="translated">&lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 는 PostgreSQL 확장입니다. 외부 트랜잭션 관리 시스템에서 사용하기위한 것으로 일부는 표준 (예 : X / Open XA)에 의해 다루어 지지만 해당 시스템의 SQL 쪽은 ​​표준화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="899081c7e2a6abd33341d48a27e4481377b89bb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; rolls back a transaction that is in prepared state.</source>
          <target state="translated">&lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 는 준비 상태에있는 트랜잭션을 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="09a80fc811afc55eb6e6fe0b99f9ce895c11c532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt; implicitly destroys all savepoints that were established after the named savepoint.</source>
          <target state="translated">&lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt; 은 명명 된 세이브 포인트 이후에 설정된 모든 세이브 포인트를 암시 적으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="21ea064ebb27ca7460c2bbc78d516bdcf622922a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROLLBACK&lt;/code&gt; rolls back the current transaction and causes all the updates made by the transaction to be discarded.</source>
          <target state="translated">&lt;code&gt;ROLLBACK&lt;/code&gt; 은 현재 트랜잭션을 롤백하고 트랜잭션이 수행 한 모든 업데이트를 버립니다.</target>
        </trans-unit>
        <trans-unit id="ff27f702249bfe189b8dcbcc0199dc52a2ba1f85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROWS FROM( ... )&lt;/code&gt; is an extension of the SQL standard.</source>
          <target state="translated">&lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 은 SQL 표준의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="ffcb1af7f66e48c160d9be53136903c3048f8406" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ROWS&lt;/code&gt;&lt;code&gt;result_rows&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ROWS&lt;/code&gt;&lt;code&gt;result_rows&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83ea29b6bcfd869d7627ac5ff700db760d908c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RULES&lt;/code&gt; is the base name of the file containing the list of translation rules. This file must be stored in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). Its name must end in &lt;code&gt;.rules&lt;/code&gt; (which is not to be included in the &lt;code&gt;RULES&lt;/code&gt; parameter).</source>
          <target state="translated">&lt;code&gt;RULES&lt;/code&gt; 는 변환 규칙 목록이 포함 된 파일의 기본 이름입니다. 이 파일은 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 저장해야합니다 (여기서 &lt;code&gt;$SHAREDIR&lt;/code&gt; 은 PostgreSQL 설치의 공유 데이터 디렉토리를 의미합니다). 이름은 &lt;code&gt;.rules&lt;/code&gt; 로 끝나야합니다 ( &lt;code&gt;RULES&lt;/code&gt; 매개 변수에 포함되지 않음 ).</target>
        </trans-unit>
        <trans-unit id="324247d93372acaf03b610aa3d42bf92c32f6024" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SAVEPOINT&lt;/code&gt; establishes a new savepoint within the current transaction.</source>
          <target state="translated">&lt;code&gt;SAVEPOINT&lt;/code&gt; 는 현재 트랜잭션 내에서 새 저장 점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bfbf2807539ae0813366e09ff388f6c9acfb2660" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SAVEPOINT&lt;/code&gt;, &lt;code&gt;RELEASE&lt;/code&gt;, &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SAVEPOINT&lt;/code&gt; , &lt;code&gt;RELEASE&lt;/code&gt; , &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1af7b290867c44f9ff13240e74521509957c337c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCROLL&lt;/code&gt; specifies that the cursor can be used to retrieve rows in a nonsequential fashion (e.g., backward). Depending upon the complexity of the query's execution plan, specifying &lt;code&gt;SCROLL&lt;/code&gt; might impose a performance penalty on the query's execution time. &lt;code&gt;NO SCROLL&lt;/code&gt; specifies that the cursor cannot be used to retrieve rows in a nonsequential fashion. The default is to allow scrolling in some cases; this is not the same as specifying &lt;code&gt;SCROLL&lt;/code&gt;. See &lt;a href=&quot;sql-declare#SQL-DECLARE-NOTES&quot;&gt;Notes&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; 은 커서를 사용하여 비 순차적 방식으로 행을 검색 할 수 있도록 지정합니다 (예 : 뒤로). 쿼리 실행 계획의 복잡성에 따라 &lt;code&gt;SCROLL&lt;/code&gt; 을 지정 하면 쿼리 실행 시간에 성능이 저하 될 수 있습니다. &lt;code&gt;NO SCROLL&lt;/code&gt; 은 커서를 사용하여 비 순차적으로 행을 검색 할 수 없도록 지정합니다. 어떤 경우에는 기본적으로 스크롤이 허용됩니다. 이것은 &lt;code&gt;SCROLL&lt;/code&gt; 지정과는 다릅니다 . 자세한 내용은 &lt;a href=&quot;sql-declare#SQL-DECLARE-NOTES&quot;&gt;참고&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57f109bc9df4d1a8518fd8f2207af37e83feffac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCROLL&lt;/code&gt;&lt;code&gt;NO SCROLL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; &lt;code&gt;NO SCROLL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1221665e5c230f56af720754840fd9a06d45c99e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SECURITY INVOKER&lt;/code&gt; indicates that the function is to be executed with the privileges of the user that calls it. That is the default. &lt;code&gt;SECURITY DEFINER&lt;/code&gt; specifies that the function is to be executed with the privileges of the user that owns it.</source>
          <target state="translated">&lt;code&gt;SECURITY INVOKER&lt;/code&gt; 는 함수를 호출하는 사용자의 권한으로 함수가 실행됨을 나타냅니다. 이것이 기본값입니다. &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 는 기능을 소유 한 사용자의 권한으로 기능이 실행되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ef18c9b7eb10844546278a55037b3022636fdbbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SECURITY INVOKER&lt;/code&gt; indicates that the procedure is to be executed with the privileges of the user that calls it. That is the default. &lt;code&gt;SECURITY DEFINER&lt;/code&gt; specifies that the procedure is to be executed with the privileges of the user that owns it.</source>
          <target state="translated">&lt;code&gt;SECURITY INVOKER&lt;/code&gt; 는 프로 시저를 호출하는 사용자의 권한으로 프로 시저가 실행됨을 나타냅니다. 이것이 기본값입니다. &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 는 프로 시저를 소유 한 사용자의 권한으로 프로 시저를 실행하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9d966c23b812e6650495cbc08718461310e419f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SECURITY LABEL&lt;/code&gt; applies a security label to a database object. An arbitrary number of security labels, one per label provider, can be associated with a given database object. Label providers are loadable modules which register themselves by using the function &lt;code&gt;register_label_provider&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SECURITY LABEL&lt;/code&gt; 은 데이터베이스 레이블에 보안 레이블을 적용합니다. 레이블 제공자 당 하나씩 임의의 수의 보안 레이블을 지정된 데이터베이스 오브젝트와 연관시킬 수 있습니다. 라벨 제공자는 함수를 사용하여 자신을 등록로드 가능한 모듈이다 &lt;code&gt;register_label_provider&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="926baa3779b770be1fbdc2405b1919988f85bdc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT ... FOR SHARE | UPDATE&lt;/code&gt;, because row locks cannot be taken without updating the underlying data files.</source>
          <target state="translated">&lt;code&gt;SELECT ... FOR SHARE | UPDATE&lt;/code&gt; 기본 데이터 파일을 업데이트하지 않으면 행 잠금을 수행 할 수 없으므로 UPDATE</target>
        </trans-unit>
        <trans-unit id="5ffaac5980f225f9b9eed0981c50e6d635ffac0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT ON ( expression [, ...] )&lt;/code&gt; keeps only the first row of each set of rows where the given expressions evaluate to equal. The &lt;code&gt;DISTINCT ON&lt;/code&gt; expressions are interpreted using the same rules as for &lt;code&gt;ORDER BY&lt;/code&gt; (see above). Note that the &amp;ldquo;first row&amp;rdquo; of each set is unpredictable unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to ensure that the desired row appears first. For example:</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT ON ( expression [, ...] )&lt;/code&gt; 은 주어진 표현식이 동일한 것으로 평가되는 각 행 세트의 첫 번째 행만 유지합니다. &lt;code&gt;DISTINCT ON&lt;/code&gt; 의 표현식과 동일한 규칙을 사용하여 해석되는 &lt;code&gt;ORDER BY&lt;/code&gt; 를 (위 참조). &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하여 원하는 행을 먼저 표시 하지 않으면 각 세트의 &quot;첫 번째 행&quot;을 예측할 수 없습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16b80756221858126f9e45407672c5ece1513bd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT DISTINCT&lt;/code&gt; eliminates duplicate rows from the result. &lt;code&gt;SELECT DISTINCT ON&lt;/code&gt; eliminates rows that match on all the specified expressions. &lt;code&gt;SELECT ALL&lt;/code&gt; (the default) will return all candidate rows, including duplicates. (See &lt;a href=&quot;sql-select#SQL-DISTINCT&quot;&gt;&lt;code&gt;DISTINCT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;SELECT DISTINCT&lt;/code&gt; 는 결과에서 중복 행을 제거합니다. &lt;code&gt;SELECT DISTINCT ON&lt;/code&gt; 은 지정된 모든 표현식에서 일치하는 행을 제거합니다. &lt;code&gt;SELECT ALL&lt;/code&gt; (기본값)은 중복을 포함하여 모든 후보 행을 리턴합니다. (아래의 &lt;a href=&quot;sql-select#SQL-DISTINCT&quot;&gt; &lt;code&gt;DISTINCT&lt;/code&gt; 조항을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c6e3724b483edeb6f561971fb5a2ae2c6eda9d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT INTO&lt;/code&gt; creates a new table and fills it with data computed by a query. The data is not returned to the client, as it is with a normal &lt;code&gt;SELECT&lt;/code&gt;. The new table's columns have the names and data types associated with the output columns of the &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT INTO&lt;/code&gt; 는 새 테이블을 작성하고 쿼리로 계산 된 데이터로 채 웁니다. 데이터는 일반 &lt;code&gt;SELECT&lt;/code&gt; 와 같이 클라이언트에 반환되지 않습니다 . 새 테이블의 열에는 &lt;code&gt;SELECT&lt;/code&gt; 의 출력 열과 연관된 이름 및 데이터 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7955d5eee2bf312184e70b12d20f26aaae061057" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt; List</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 리스트 선택</target>
        </trans-unit>
        <trans-unit id="2bdaba83198640ca087510f2b2e283b4b7f020be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt; does not modify any rows so you cannot create &lt;code&gt;SELECT&lt;/code&gt; triggers. Rules and views may provide workable solutions to problems that seem to need &lt;code&gt;SELECT&lt;/code&gt; triggers.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 는 행을 수정하지 않으므로 &lt;code&gt;SELECT&lt;/code&gt; 트리거를 만들 수 없습니다 . 규칙과 뷰는 &lt;code&gt;SELECT&lt;/code&gt; 트리거 가 필요한 것으로 보이는 문제에 대한 실용적인 솔루션을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fc16ca05c37581a474c60cd8beddbddff18cc74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt; retrieves rows from zero or more tables. The general processing of &lt;code&gt;SELECT&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 는 0 개 이상의 테이블에서 행을 검색합니다. &lt;code&gt;SELECT&lt;/code&gt; 의 일반적인 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="891d861010fc633299057d73d15850426fcc03c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;REFERENCES&lt;/code&gt;&lt;code&gt;TRIGGER&lt;/code&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;code&gt;TEMPORARY&lt;/code&gt;&lt;code&gt;EXECUTE&lt;/code&gt;&lt;code&gt;USAGE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;REFERENCES&lt;/code&gt;&lt;code&gt;TRIGGER&lt;/code&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;code&gt;TEMPORARY&lt;/code&gt;&lt;code&gt;EXECUTE&lt;/code&gt;&lt;code&gt;USAGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a97cb4f9ebfe5c40b1d3bbcc74f65eef146fd192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SERIALIZABLE&lt;/code&gt; is the default transaction isolation level in the standard. In PostgreSQL the default is ordinarily &lt;code&gt;READ COMMITTED&lt;/code&gt;, but you can change it as mentioned above.</source>
          <target state="translated">&lt;code&gt;SERIALIZABLE&lt;/code&gt; 은 표준의 기본 트랜잭션 격리 수준입니다. PostgreSQL에서 기본값은 일반적으로 &lt;code&gt;READ COMMITTED&lt;/code&gt; 이지만 위에서 언급 한대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad11ed424de046d1ea54501c4aa105032801fa10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SERVER_VERSION_NAME&lt;/code&gt;&lt;code&gt;SERVER_VERSION_NUM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SERVER_VERSION_NAME&lt;/code&gt;&lt;code&gt;SERVER_VERSION_NUM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cf51e4539341a50938e9980d1b58fd71a037a44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET ( attribute_option = value [, ... ] )&lt;/code&gt;&lt;code&gt;RESET ( attribute_option [, ... ] )&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET ( attribute_option = value [, ... ] )&lt;/code&gt; &lt;code&gt;RESET ( attribute_option [, ... ] )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c436b0d4e3743ccf64ee605de8160214368e8c5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET ( view_option_name [= view_option_value] [, ... ] )&lt;/code&gt;&lt;code&gt;RESET ( view_option_name [, ... ] )&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET ( view_option_name [= view_option_value] [, ... ] )&lt;/code&gt; &lt;code&gt;RESET ( view_option_name [, ... ] )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12fbf3e8619f61d9a38376c5030b22b220510fc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET CONSTRAINTS&lt;/code&gt; sets the behavior of constraint checking within the current transaction. &lt;code&gt;IMMEDIATE&lt;/code&gt; constraints are checked at the end of each statement. &lt;code&gt;DEFERRED&lt;/code&gt; constraints are not checked until transaction commit. Each constraint has its own &lt;code&gt;IMMEDIATE&lt;/code&gt; or &lt;code&gt;DEFERRED&lt;/code&gt; mode.</source>
          <target state="translated">&lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 는 현재 트랜잭션 내에서 제약 조건 검사 동작을 설정합니다. &lt;code&gt;IMMEDIATE&lt;/code&gt; 제약 조건은 각 문의 끝에서 확인됩니다. 트랜잭션 커밋이 완료 될 때까지 &lt;code&gt;DEFERRED&lt;/code&gt; 제약 조건을 확인하지 않습니다. 각 제약 조건에는 자체 &lt;code&gt;IMMEDIATE&lt;/code&gt; 또는 &lt;code&gt;DEFERRED&lt;/code&gt; 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="09875f0da521ccb9eca0e6be85918ff0e8dbcaa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET CONSTRAINTS&lt;/code&gt; with a list of constraint names changes the mode of just those constraints (which must all be deferrable). Each constraint name can be schema-qualified. The current schema search path is used to find the first matching name if no schema name is specified. &lt;code&gt;SET CONSTRAINTS ALL&lt;/code&gt; changes the mode of all deferrable constraints.</source>
          <target state="translated">&lt;code&gt;SET CONSTRAINTS&lt;/code&gt; 제약 조건 이름 목록이있는 SET CONSTRAINTS 는 해당 제약 조건 (모두 연기 가능해야 함)의 모드 만 변경합니다. 각 제한 조건 이름은 스키마로 규정 될 수 있습니다. 현재 스키마 검색 경로는 스키마 이름이 지정되지 않은 경우 첫 번째 일치하는 이름을 찾는 데 사용됩니다. &lt;code&gt;SET CONSTRAINTS ALL&lt;/code&gt; 은 모든 지연 가능한 제한 조건의 모드를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5b72617953d2268fb0af0cd69e9abcc4e029c87b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET NAMES value&lt;/code&gt; is an alias for &lt;code&gt;SET client_encoding TO value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET NAMES value&lt;/code&gt; 은 &lt;code&gt;SET client_encoding TO value&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="6907355995e9cb355a2f1bb89b7a1ab2c77b718b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET NOT NULL&lt;/code&gt; may only be applied to a column providing none of the records in the table contain a &lt;code&gt;NULL&lt;/code&gt; value for the column. Ordinarily this is checked during the &lt;code&gt;ALTER TABLE&lt;/code&gt; by scanning the entire table; however, if a valid &lt;code&gt;CHECK&lt;/code&gt; constraint is found which proves no &lt;code&gt;NULL&lt;/code&gt; can exist, then the table scan is skipped.</source>
          <target state="translated">&lt;code&gt;SET NOT NULL&lt;/code&gt; 은 테이블의 레코드에 컬럼에 대한 &lt;code&gt;NULL&lt;/code&gt; 값이 없는 경우 컬럼에만 적용 할 수 있습니다 . 일반적으로 이것은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 동안 전체 테이블을 스캔하여 점검됩니다 . 그러나 &lt;code&gt;NULL&lt;/code&gt; 이 존재할 수 없음을 증명 하는 유효한 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건이 발견 되면 테이블 스캔을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1ca8775771890cfd6c3ce4af297219c271e7d9aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET ROLE&lt;/code&gt; cannot be used within a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 기능 내에서는 SET ROLE을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d7cb7d772f031c40db318be76f73a6ad5c03c4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET ROLE&lt;/code&gt; does not process session variables as specified by the role's &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; settings; this only happens during login.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; 은 역할의 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 설정에 지정된 세션 변수를 처리하지 않습니다 . 이것은 로그인 중에 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1fa80f41aec9a817985766e25245d183e618ebe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET ROLE&lt;/code&gt; has effects comparable to &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt;, but the privilege checks involved are quite different. Also, &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; determines which roles are allowable for later &lt;code&gt;SET ROLE&lt;/code&gt; commands, whereas changing roles with &lt;code&gt;SET ROLE&lt;/code&gt; does not change the set of roles allowed to a later &lt;code&gt;SET ROLE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SET ROLE&lt;/code&gt; 은 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; 과 비슷한 효과를 갖지만 관련된 권한 검사는 상당히 다릅니다. 또한 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 은 이후 &lt;code&gt;SET ROLE&lt;/code&gt; 명령에 허용되는 역할을 결정 하지만 &lt;code&gt;SET ROLE&lt;/code&gt; 로 역할을 변경해도 이후 &lt;code&gt;SET ROLE&lt;/code&gt; 에 허용 된 역할 세트는 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="624238adac95e6fcb219ed1bb2f52c350b42a1f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET SCHEMA 'value'&lt;/code&gt; is an alias for &lt;code&gt;SET search_path TO value&lt;/code&gt;. Only one schema can be specified using this syntax.</source>
          <target state="translated">&lt;code&gt;SET SCHEMA 'value'&lt;/code&gt; 는 &lt;code&gt;SET search_path TO value&lt;/code&gt; 의 별명입니다 . 이 구문을 사용하여 하나의 스키마 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde0b2f82e8f3d60fe73715147eaea0e2ee79f67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; cannot be used within a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; 은 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 기능 내에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="08e3d14444c4ca1dbe9aa0852c204d05d1b307be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET STATISTICS&lt;/code&gt; acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">&lt;code&gt;SET STATISTICS&lt;/code&gt; 는 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="94a42bef135c72101f7a8c9e95a45a5d8381a6df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET TIME ZONE value&lt;/code&gt; is an alias for &lt;code&gt;SET timezone TO value&lt;/code&gt;. The syntax &lt;code&gt;SET TIME ZONE&lt;/code&gt; allows special syntax for the time zone specification. Here are examples of valid values:</source>
          <target state="translated">&lt;code&gt;SET TIME ZONE value&lt;/code&gt; 은 &lt;code&gt;SET timezone TO value&lt;/code&gt; 의 별명입니다 . 구문 &lt;code&gt;SET TIME ZONE&lt;/code&gt; 은 시간대 지정을위한 특별한 구문을 할 수 있습니다. 유효한 값의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae37570be3cf840f45098deeb8573987dac0dd26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET TIME ZONE&lt;/code&gt; extends syntax defined in the SQL standard. The standard allows only numeric time zone offsets while PostgreSQL allows more flexible time-zone specifications. All other &lt;code&gt;SET&lt;/code&gt; features are PostgreSQL extensions.</source>
          <target state="translated">&lt;code&gt;SET TIME ZONE&lt;/code&gt; 은 SQL 표준에 정의 된 구문을 확장합니다. 표준은 숫자 시간대 오프셋 만 허용하고 PostgreSQL은보다 유연한 시간대 지정을 허용합니다. 다른 모든 &lt;code&gt;SET&lt;/code&gt; 기능은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="2f6442b82abffaf15f31026cd343f86dd22f3c71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET TRANSACTION READ WRITE&lt;/code&gt;, &lt;code&gt;SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET TRANSACTION READ WRITE&lt;/code&gt; 로 &lt;code&gt;SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="848cf382fac5f6808e4445703cdc2fecc761230b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET sequence_option&lt;/code&gt;&lt;code&gt;RESTART&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET sequence_option&lt;/code&gt; &lt;code&gt;RESTART&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc69a8c722cb50ce084422ecdd44b69d2048c693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET&lt;/code&gt;/&lt;code&gt;DROP DEFAULT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; / &lt;code&gt;DROP DEFAULT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13520b8fdd0c8d64755254ebcbc36c7c59ff4b89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET&lt;/code&gt;/&lt;code&gt;DROP NOT NULL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; / &lt;code&gt;DROP NOT NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93a189551cc62e26d5ac136a966d9567e9af5ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock will be taken for fillfactor, toast and autovacuum storage parameters, as well as the following planner related parameters: &lt;code&gt;effective_io_concurrency&lt;/code&gt;, &lt;code&gt;parallel_workers&lt;/code&gt;, &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt;, &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 의 : 잠금 FILLFACTOR, 토스트, 자동 진공 저장 매개 변수뿐만 아니라 다음과 같은 계획 관련 매개 변수에 대한 이동합니다 &lt;code&gt;effective_io_concurrency&lt;/code&gt; , &lt;code&gt;parallel_workers&lt;/code&gt; , &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; , &lt;code&gt;n_distinct&lt;/code&gt; 및 &lt;code&gt;n_distinct_inherited&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b581297f6514a5dab959adf4dd6075811eebf08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; (&lt;code&gt;a&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; ( &lt;code&gt;a&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95c0d4b15e9a091e7e48f83671201ea11daa50cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; (&lt;code&gt;o&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; ( &lt;code&gt;o&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b99a742632f23a751a402ff8f6befb452376385f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHARED_DEPENDENCY_PIN&lt;/code&gt; (&lt;code&gt;p&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;SHARED_DEPENDENCY_PIN&lt;/code&gt; ( &lt;code&gt;p&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8d9a6eaffafaf1c914fd8519ba212f470d702e64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHARED_DEPENDENCY_POLICY&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;SHARED_DEPENDENCY_POLICY&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd70ad588dc798059e0b46ac26a73b93d21b244b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHMALL&lt;/code&gt; is measured in 4 kB pages on this platform.</source>
          <target state="translated">&lt;code&gt;SHMALL&lt;/code&gt; 은이 플랫폼에서 4kB 페이지로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="87b2aba82a035bbafd5bd28ab477add56c88af68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHOW&lt;/code&gt; will display the current setting of run-time parameters. These variables can be set using the &lt;code&gt;SET&lt;/code&gt; statement, by editing the &lt;code&gt;postgresql.conf&lt;/code&gt; configuration file, through the &lt;code&gt;PGOPTIONS&lt;/code&gt; environmental variable (when using libpq or a libpq-based application), or through command-line flags when starting the &lt;code&gt;postgres&lt;/code&gt; server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;SHOW&lt;/code&gt; 는 현재 런타임 파라미터 설정을 표시합니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 구성 파일 을 편집하거나 &lt;code&gt;PGOPTIONS&lt;/code&gt; 환경 변수 (libpq 또는 libpq 기반 응용 프로그램을 사용하는 경우)를 통해 또는 &lt;code&gt;postgres&lt;/code&gt; 서버를 시작할 때 명령 줄 플래그를 통해 &lt;code&gt;SET&lt;/code&gt; 문을 사용하여 이러한 변수를 설정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e675622dcbb41a6be8062e395c0170ed66ff7df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SOME&lt;/code&gt; is a synonym for &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SOME&lt;/code&gt; 는 &lt;code&gt;ANY&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="532e3b42f95de518c131a4f06f7956694f7f8967" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SOME&lt;/code&gt; is a synonym for &lt;code&gt;ANY&lt;/code&gt;. &lt;code&gt;IN&lt;/code&gt; is equivalent to &lt;code&gt;= ANY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SOME&lt;/code&gt; 는 &lt;code&gt;ANY&lt;/code&gt; 와 동의어입니다 . &lt;code&gt;IN&lt;/code&gt; 은 &lt;code&gt;= ANY&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9f73873633df37af2d16880c68cade4baeda01a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SP&lt;/code&gt; suffix</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; 접미사</target>
        </trans-unit>
        <trans-unit id="4491e6fc341e9e33105aa4e732fa0718bd120d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STABLE&lt;/code&gt; indicates that the function cannot modify the database, and that within a single table scan it will consistently return the same result for the same argument values, but that its result could change across SQL statements. This is the appropriate selection for functions whose results depend on database lookups, parameter variables (such as the current time zone), etc. (It is inappropriate for &lt;code&gt;AFTER&lt;/code&gt; triggers that wish to query rows modified by the current command.) Also note that the &lt;code&gt;current_timestamp&lt;/code&gt; family of functions qualify as stable, since their values do not change within a transaction.</source>
          <target state="translated">&lt;code&gt;STABLE&lt;/code&gt; 은 함수가 데이터베이스를 수정할 수 없으며 단일 테이블 스캔에서 동일한 인수 값에 대해 동일한 결과를 일관되게 리턴하지만 결과는 SQL 문에서 변경 될 수 있음을 나타냅니다. 이는 데이터베이스 조회, 매개 변수 (예 : 현재 시간대) 등에 따라 결과가 달라지는 함수에 적합한 선택입니다. ( 현재 명령으로 수정 된 행을 쿼리하려는 &lt;code&gt;AFTER&lt;/code&gt; 트리거 에는 적합하지 않습니다 .) &lt;code&gt;current_timestamp&lt;/code&gt; 함수 계열은 트랜잭션 내에서 값이 변경되지 않으므로 안정적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7d363fb09e0f10d6b4a13d37db09e42b55f5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STORAGE&lt;/code&gt; settings for the copied column definitions will be copied. The default behavior is to exclude &lt;code&gt;STORAGE&lt;/code&gt; settings, resulting in the copied columns in the new table having type-specific default settings. For more on &lt;code&gt;STORAGE&lt;/code&gt; settings, see &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;STORAGE&lt;/code&gt; 복사 된 열 정의에 대한 STORAGE 설정이 복사됩니다. 기본 동작은 &lt;code&gt;STORAGE&lt;/code&gt; 설정 을 제외 하여 새 테이블의 복사 된 열이 유형별 기본 설정을 갖도록하는 것입니다. &lt;code&gt;STORAGE&lt;/code&gt; 설정 에 대한 자세한 내용 &lt;a href=&quot;storage-toast&quot;&gt;은 68.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c565301813a126e093286693fedf37b3aa985fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUPERUSER&lt;/code&gt;&lt;code&gt;NOSUPERUSER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SUPERUSER&lt;/code&gt;&lt;code&gt;NOSUPERUSER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b2059af27f740a2c1295a56da85051f51d3d043" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUPERUSER&lt;/code&gt;&lt;code&gt;NOSUPERUSER&lt;/code&gt;&lt;code&gt;CREATEDB&lt;/code&gt;&lt;code&gt;NOCREATEDB&lt;/code&gt;&lt;code&gt;CREATEROLE&lt;/code&gt;&lt;code&gt;NOCREATEROLE&lt;/code&gt;&lt;code&gt;INHERIT&lt;/code&gt;&lt;code&gt;NOINHERIT&lt;/code&gt;&lt;code&gt;LOGIN&lt;/code&gt;&lt;code&gt;NOLOGIN&lt;/code&gt;&lt;code&gt;REPLICATION&lt;/code&gt;&lt;code&gt;NOREPLICATION&lt;/code&gt;&lt;code&gt;BYPASSRLS&lt;/code&gt;&lt;code&gt;NOBYPASSRLS&lt;/code&gt;&lt;code&gt;CONNECTION LIMIT&lt;/code&gt;&lt;code&gt;connlimit&lt;/code&gt;[ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; '&lt;code&gt;password&lt;/code&gt;'&lt;code&gt;PASSWORD NULL&lt;/code&gt;&lt;code&gt;VALID UNTIL&lt;/code&gt; '&lt;code&gt;timestamp&lt;/code&gt;'</source>
          <target state="translated">&lt;code&gt;SUPERUSER&lt;/code&gt; &lt;code&gt;NOSUPERUSER&lt;/code&gt; &lt;code&gt;CREATEDB&lt;/code&gt; &lt;code&gt;NOCREATEDB&lt;/code&gt; &lt;code&gt;CREATEROLE&lt;/code&gt; &lt;code&gt;NOCREATEROLE&lt;/code&gt; &lt;code&gt;INHERIT&lt;/code&gt; &lt;code&gt;NOINHERIT&lt;/code&gt; &lt;code&gt;LOGIN&lt;/code&gt; &lt;code&gt;NOLOGIN&lt;/code&gt; &lt;code&gt;REPLICATION&lt;/code&gt; &lt;code&gt;NOREPLICATION&lt;/code&gt; &lt;code&gt;BYPASSRLS&lt;/code&gt; &lt;code&gt;NOBYPASSRLS&lt;/code&gt; &lt;code&gt;CONNECTION LIMIT&lt;/code&gt; &lt;code&gt;connlimit&lt;/code&gt; [ &lt;code&gt;ENCRYPTED&lt;/code&gt; ] &lt;code&gt;PASSWORD&lt;/code&gt; ' &lt;code&gt;password&lt;/code&gt; ' &lt;code&gt;PASSWORD NULL&lt;/code&gt; &lt;code&gt;VALID UNTIL&lt;/code&gt; ' &lt;code&gt;timestamp&lt;/code&gt; '</target>
        </trans-unit>
        <trans-unit id="15018d72148e48680f36dc365ce23c6035de9cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUPPORT&lt;/code&gt;&lt;code&gt;support_function&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SUPPORT&lt;/code&gt;&lt;code&gt;support_function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cdb79cf9c18608cd6a8cfcf3893230611cbca363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SYSID&lt;/code&gt;&lt;code&gt;uid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SYSID&lt;/code&gt;&lt;code&gt;uid&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf0ca00d34dd1763f0122657797fd88b06f5b1de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SYSTEM_ROWS&lt;/code&gt; does not support the &lt;code&gt;REPEATABLE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SYSTEM_ROWS&lt;/code&gt; 는 &lt;code&gt;REPEATABLE&lt;/code&gt; 절을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d6ae1868cb8250475ab16f26c8c13c917f41be80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SYSTEM_TIME&lt;/code&gt; does not support the &lt;code&gt;REPEATABLE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SYSTEM_TIME&lt;/code&gt; 은 &lt;code&gt;REPEATABLE&lt;/code&gt; 절을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3aa6d2d4e6b99427f5ba420e4d77c74f9237301b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ShortWord&lt;/code&gt;: words of this length or less will be dropped at the start and end of a headline. The default value of three eliminates common English articles.</source>
          <target state="translated">&lt;code&gt;ShortWord&lt;/code&gt; :이 길이 이하의 단어는 헤드 라인의 시작과 끝에서 삭제됩니다. 기본값 3은 일반적인 영어 기사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b9f7381ffac68f00bfe210e7df299bad65a89a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StartSel&lt;/code&gt;, &lt;code&gt;StopSel&lt;/code&gt;: the strings with which to delimit query words appearing in the document, to distinguish them from other excerpted words. You must double-quote these strings if they contain spaces or commas.</source>
          <target state="translated">&lt;code&gt;StartSel&lt;/code&gt; , &lt;code&gt;StopSel&lt;/code&gt; : 문서에 나타나는 쿼리 단어를 구분하여 다른 발췌 단어와 구별하는 문자열입니다. 공백이나 쉼표가 포함 된 문자열은 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ac366351a2fac2ba0f0d459a23eb6f26bc6bf32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TABLE&lt;/code&gt; (and table-like objects)</source>
          <target state="translated">&lt;code&gt;TABLE&lt;/code&gt; (및 테이블과 같은 객체)</target>
        </trans-unit>
        <trans-unit id="08b2eda27106e9c4cf7d15d2c50872320eeba764" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TABLE&lt;/code&gt; Command</source>
          <target state="translated">&lt;code&gt;TABLE&lt;/code&gt; 명령</target>
        </trans-unit>
        <trans-unit id="9790e5c027f1c75435ba57bb0921296e62cb82c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TABLE&lt;/code&gt;, table column</source>
          <target state="translated">&lt;code&gt;TABLE&lt;/code&gt; , 테이블 열</target>
        </trans-unit>
        <trans-unit id="9ef5d4e039fbc0adf20ebeff7ab003229f0b3021" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TABLESAMPLE&lt;/code&gt; Clause Restrictions</source>
          <target state="translated">&lt;code&gt;TABLESAMPLE&lt;/code&gt; 조항 제한 사항</target>
        </trans-unit>
        <trans-unit id="0219854354c570a1e3e102c431082ffb4649e4bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; 또는 &lt;code&gt;TEMP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27f3f7313a02252ec4462a3981ffe4dbcc976062" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TH&lt;/code&gt; does not convert values less than zero and does not convert fractional numbers.</source>
          <target state="translated">&lt;code&gt;TH&lt;/code&gt; 는 0보다 작은 값을 변환하지 않으며 소수를 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cf48504b7371a777f4b70ffb55d0bafc17f14e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TH&lt;/code&gt; or &lt;code&gt;th&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TH&lt;/code&gt; 또는 &lt;code&gt;th&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f453a25c11eabaa53b406db15644550dc0022ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TH&lt;/code&gt; suffix</source>
          <target state="translated">&lt;code&gt;TH&lt;/code&gt; 접미사</target>
        </trans-unit>
        <trans-unit id="0f1cadcf798089a8527b021c54aacfa80b877df4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TM&lt;/code&gt; does not include trailing blanks. &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; ignore the &lt;code&gt;TM&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;TM&lt;/code&gt; 은 후행 공백을 포함하지 않습니다. &lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 는 &lt;code&gt;TM&lt;/code&gt; 수정자를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="8300d89cf05c9cfc5ffba93fad676c1d7d058e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TM&lt;/code&gt; prefix</source>
          <target state="translated">&lt;code&gt;TM&lt;/code&gt; 접두사</target>
        </trans-unit>
        <trans-unit id="b682ec1ac36e787176afec8968411deb5b4316db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; can be adjusted for each table using &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ... SET (toast_tuple_target = N)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;TOAST_TUPLE_TARGET&lt;/code&gt; &lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ... SET (toast_tuple_target = N)&lt;/code&gt; &lt;/a&gt; 사용하여 각 테이블에 대해 TOAST_TUPLE_TARGET 을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4e321e4db41c21c3ad9f12d797fb9118e7c0bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; acquires an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on each table it operates on, which blocks all other concurrent operations on the table. When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, any sequences that are to be restarted are likewise locked exclusively. If concurrent access to a table is required, then the &lt;code&gt;DELETE&lt;/code&gt; command should be used instead.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 작동하는 각 테이블에서 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; 잠금을 획득하여 테이블의 다른 모든 동시 작업을 차단합니다. &lt;code&gt;RESTART IDENTITY&lt;/code&gt; 가 지정 되면 재시작 될 시퀀스도 마찬가지로 독점적으로 잠 깁니다. 테이블에 대한 동시 액세스가 필요한 경우 &lt;code&gt;DELETE&lt;/code&gt; 명령을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f737dd14c7b962708b71f93a19eaeb10a93b2f9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; cannot be used on a table that has foreign-key references from other tables, unless all such tables are also truncated in the same command. Checking validity in such cases would require table scans, and the whole point is not to do one. The &lt;code&gt;CASCADE&lt;/code&gt; option can be used to automatically include all dependent tables &amp;mdash; but be very careful when using this option, or else you might lose data you did not intend to!</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 다른 테이블에서 외래 키 참조가있는 테이블에서는 TRUNCATE를 사용할 수 없습니다. 이러한 테이블도 모두 같은 명령으로 잘리지 않습니다. 이러한 경우 유효성을 검사하려면 테이블 스캔이 필요하며 요점은 전체를 스캔하지 않는 것입니다. &lt;code&gt;CASCADE&lt;/code&gt; 의 옵션이 자동으로 사용되는 모든 종속 테이블을 포함 할 수있다 - 그러나이 옵션을 사용할 때 매우 조심, 그렇지 않으면 당신은 당신이 의도하지 않은 데이터가 손실 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c7249890e4bdede028186c1db675c4b99a2b527d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; has the same hazard.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 도 같은 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d25d87b89a0cbe792c866748601db2b99989ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; is not MVCC-safe. After truncation, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the truncation occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 MVCC 안전하지 않습니다. 자르기 후 자르기 전에 스냅 샷을 사용하는 경우 테이블은 동시 트랜잭션에 대해 비어있는 것으로 나타납니다. 자세한 내용 &lt;a href=&quot;mvcc-caveats&quot;&gt;은 13.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8266480b2d8f8e22961e74ef8ed7306d0a0e201d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; is not currently supported for foreign tables. This implies that if a specified table has any descendant tables that are foreign, the command will fail.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 현재 외부 테이블에 대해 지원되지 않습니다. 이는 지정된 테이블에 외부의 하위 테이블이 있으면 명령이 실패 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10c1371d53236c0e1cce9960a7226618afb726d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; is transaction-safe with respect to the data in the tables: the truncation will be safely rolled back if the surrounding transaction does not commit.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 테이블의 데이터와 관련하여 트랜잭션에 안전합니다. 주변 트랜잭션이 커밋되지 않으면 잘림이 안전하게 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="b01c3d9cf95c777316dd077a19311e3eda8e95ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; quickly removes all rows from a set of tables. It has the same effect as an unqualified &lt;code&gt;DELETE&lt;/code&gt; on each table, but since it does not actually scan the tables it is faster. Furthermore, it reclaims disk space immediately, rather than requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; operation. This is most useful on large tables.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 테이블 세트에서 모든 행을 빠르게 제거합니다. 각 테이블에서 규정되지 않은 &lt;code&gt;DELETE&lt;/code&gt; 와 동일한 효과를 갖지만 실제로 테이블을 스캔하지 않기 때문에 더 빠릅니다. 또한 후속 &lt;code&gt;VACUUM&lt;/code&gt; 작업을 수행 하지 않고 디스크 공간을 즉시 회수 합니다. 큰 테이블에서 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="580fb65e8e4bf0b6b45f5eb091b0e6bd2f110337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUNCATE&lt;/code&gt; will not fire any &lt;code&gt;ON DELETE&lt;/code&gt; triggers that might exist for the tables. But it will fire &lt;code&gt;ON TRUNCATE&lt;/code&gt; triggers. If &lt;code&gt;ON TRUNCATE&lt;/code&gt; triggers are defined for any of the tables, then all &lt;code&gt;BEFORE TRUNCATE&lt;/code&gt; triggers are fired before any truncation happens, and all &lt;code&gt;AFTER TRUNCATE&lt;/code&gt; triggers are fired after the last truncation is performed and any sequences are reset. The triggers will fire in the order that the tables are to be processed (first those listed in the command, and then any that were added due to cascading).</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 는 테이블에 존재할 수 있는 &lt;code&gt;ON DELETE&lt;/code&gt; 트리거를 발생시키지 않습니다 . 그러나 &lt;code&gt;ON TRUNCATE&lt;/code&gt; 트리거 를 발생 시킵니다. 경우 &lt;code&gt;ON TRUNCATE&lt;/code&gt; 의 트리거가 테이블의에 정의 된, 모든 &lt;code&gt;BEFORE TRUNCATE&lt;/code&gt; 의 트리거는 절단이 일어나기 전에 해고, 모든 &lt;code&gt;AFTER TRUNCATE&lt;/code&gt; 마지막 절단을 수행하고 시퀀스는 리셋 후 트리거가 발사된다. 트리거는 테이블이 처리되는 순서대로 실행됩니다 (먼저 명령에 나열된 트리거와 계단식으로 추가 된 트리거).</target>
        </trans-unit>
        <trans-unit id="147a02164b3eacdfbd4dae4d52063eedaac19933" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRUSTED&lt;/code&gt; specifies that the language does not grant access to data that the user would not otherwise have. If this key word is omitted when registering the language, only users with the PostgreSQL superuser privilege can use this language to create new functions.</source>
          <target state="translated">&lt;code&gt;TRUSTED&lt;/code&gt; 는 언어가 사용자에게없는 데이터에 대한 액세스 권한을 부여하지 않도록 지정합니다. 언어를 등록 할 때이 키워드를 생략하면 PostgreSQL 수퍼 유저 권한이있는 사용자 만이 언어를 사용하여 새 기능을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b467c0dd59093c1cdc8d64cec1eecea6a86719" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeZone&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;TimeZone&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dd215d6aa5b0ce92709e2d3e67c99ba571050df5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Timeout&lt;/code&gt;: The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; : 서버 프로세스가 시간 초과가 만료되기를 기다리고 있습니다. &lt;code&gt;wait_event&lt;/code&gt; 는 특정 대기 지점을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="5d7a1d4260f462cf79f83fc8fe3ff893f4882556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNION&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="c83b19c176c3c9da3aa996685e605c7868fe37e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;CASE&lt;/code&gt;, and related constructs</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;CASE&lt;/code&gt; 및 관련 구문</target>
        </trans-unit>
        <trans-unit id="5d66860e7e3c01a93e875bfc2448255f90e16aa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIQUE&lt;/code&gt; (column constraint)&lt;code&gt;UNIQUE ( column_name [, ... ] )&lt;/code&gt; [ INCLUDE ( &lt;code&gt;column_name&lt;/code&gt; [, ...]) ] (table constraint)</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; (열 제약 조건) &lt;code&gt;UNIQUE ( column_name [, ... ] )&lt;/code&gt; [INCLUDE ( &lt;code&gt;column_name&lt;/code&gt; [, ...])] (테이블 제약 조건)</target>
        </trans-unit>
        <trans-unit id="36076162fad6dd4faafd156f562b5a9b6bed1ad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; indicates that this is a deferred recheck of a row that was reported as a potential uniqueness violation. Although this is implemented by calling &lt;code&gt;aminsert&lt;/code&gt;, the access method must &lt;em&gt;not&lt;/em&gt; insert a new index entry in this case. The index entry is already present. Rather, the access method must check to see if there is another live index entry. If so, and if the target row is also still live, report error.</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 은 잠재적 고유성 위반으로보고 된 행의 지연된 재검사임을 나타냅니다. 이것은 &lt;code&gt;aminsert&lt;/code&gt; 를 호출하여 구현되지만이 경우 액세스 메소드는 새 색인 항목을 삽입 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . 색인 항목이 이미 존재합니다. 대신 액세스 방법은 다른 라이브 인덱스 항목이 있는지 확인해야합니다. 그렇다면 목표 행도 여전히 활성 상태 인 경우 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="556eb59ea8fee8ab1d0da2c121745aaeafaf3e14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIQUE_CHECK_NO&lt;/code&gt; indicates that no uniqueness checking should be done (this is not a unique index).</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_NO&lt;/code&gt; 는 고유성 검사를 수행하지 않아야 함을 나타냅니다 (고유 인덱스가 아님).</target>
        </trans-unit>
        <trans-unit id="d8296e731b860850faaf10e89bb06cedf6b0b16c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; indicates that the unique constraint is deferrable. PostgreSQL will use this mode to insert each row's index entry. The access method must allow duplicate entries into the index, and report any potential duplicates by returning false from &lt;code&gt;aminsert&lt;/code&gt;. For each row for which false is returned, a deferred recheck will be scheduled.</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_PARTIAL&lt;/code&gt; 은 고유 제한 조건을 연기 할 수 있음을 나타냅니다. PostgreSQL은이 모드를 사용하여 각 행의 색인 항목을 삽입합니다. 액세스 방법은 인덱스에 중복 항목을 허용하고 &lt;code&gt;aminsert&lt;/code&gt; 에서 false를 리턴하여 잠재적 중복을보고해야합니다 . false가 리턴되는 각 행에 대해 지연된 재검사가 스케줄됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef4aaf95f898440710a1f03005da795c3b59a32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIQUE_CHECK_YES&lt;/code&gt; indicates that this is a non-deferrable unique index, and the uniqueness check must be done immediately, as described above.</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_YES&lt;/code&gt; 는 이것이 지연 불가능한 고유 인덱스임을 나타내며 위에서 설명한대로 고유성 검사를 즉시 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd1e03a742070f86d818f2558d3109bd86f4ac8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNLISTEN&lt;/code&gt; is used to remove an existing registration for &lt;code&gt;NOTIFY&lt;/code&gt; events. &lt;code&gt;UNLISTEN&lt;/code&gt; cancels any existing registration of the current PostgreSQL session as a listener on the notification channel named &lt;code&gt;channel&lt;/code&gt;. The special wildcard &lt;code&gt;*&lt;/code&gt; cancels all listener registrations for the current session.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; 은 &lt;code&gt;NOTIFY&lt;/code&gt; 이벤트에 대한 기존 등록을 제거하는 데 사용됩니다 . &lt;code&gt;UNLISTEN&lt;/code&gt; 는 알림 채널라는 이름의 리스너로서 현재의 PostgreSQL 세션의 기존 등록을 취소 &lt;code&gt;channel&lt;/code&gt; . 특수 와일드 카드 &lt;code&gt;*&lt;/code&gt; 는 현재 세션에 대한 모든 리스너 등록을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="cce15d1b331394b1f98eb7d89df9e878715dc9f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UPDATE&lt;/code&gt; changes the values of the specified columns in all rows that satisfy the condition. Only the columns to be modified need be mentioned in the &lt;code&gt;SET&lt;/code&gt; clause; columns not explicitly modified retain their previous values.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 는 조건을 만족하는 모든 행에서 지정된 열의 값을 변경합니다. &lt;code&gt;SET&lt;/code&gt; 절 에는 수정 될 열만 언급하면됩니다 . 명시 적으로 수정되지 않은 열은 이전 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="099041914d1e673320b518264155fdb32e8f8b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands behave the same as &lt;code&gt;SELECT&lt;/code&gt; in terms of searching for target rows: they will only find target rows that were committed as of the command start time. However, such a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the would-be updater will wait for the first updating transaction to commit or roll back (if it is still in progress). If the first updater rolls back, then its effects are negated and the second updater can proceed with updating the originally found row. If the first updater commits, the second updater will ignore the row if the first updater deleted it, otherwise it will attempt to apply its operation to the updated version of the row. The search condition of the command (the &lt;code&gt;WHERE&lt;/code&gt; clause) is re-evaluated to see if the updated version of the row still matches the search condition. If so, the second updater proceeds with its operation using the updated version of the row. In the case of &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, this means it is the updated version of the row that is locked and returned to the client.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 명령은 &lt;code&gt;SELECT&lt;/code&gt; 와 동일하게 동작합니다.대상 행 검색과 관련하여 명령 시작 시간에 커밋 된 대상 행만 찾습니다. 그러나 이러한 목표 행은 발견 될 때까지 다른 동시 트랜잭션에 의해 이미 갱신 (또는 삭제 또는 잠김)되었을 수 있습니다. 이 경우, 유망 업데 이터는 첫 번째 업데이트 트랜잭션이 커밋 또는 롤백 될 때까지 기다립니다 (아직 진행중인 경우). 첫 번째 업데이터가 롤백되면 그 효과는 무시되고 두 번째 업데이터는 원래 찾은 행의 업데이트를 진행할 수 있습니다. 첫 번째 업데이터가 커밋하면 두 번째 업데이터는 첫 번째 업데이터가 삭제 한 경우 해당 행을 무시하고, 그렇지 않으면 업데이트 된 버전의 행에 작업을 적용하려고 시도합니다. 명령의 검색 조건 ( &lt;code&gt;WHERE&lt;/code&gt; 업데이트 된 버전의 행이 여전히 검색 조건과 일치하는지 확인하기 위해 절)을 다시 평가합니다. 그렇다면 두 번째 업데이터는 업데이트 된 버전의 행을 사용하여 작업을 진행합니다. 의 경우 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 와 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; , 잠겨 클라이언트에 반환되는 행의 업데이트 된 버전이 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9111f5fac310151883bf28652c4e3e00700ff711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands behave the same as &lt;code&gt;SELECT&lt;/code&gt; in terms of searching for target rows: they will only find target rows that were committed as of the transaction start time. However, such a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the repeatable read transaction will wait for the first updating transaction to commit or roll back (if it is still in progress). If the first updater rolls back, then its effects are negated and the repeatable read transaction can proceed with updating the originally found row. But if the first updater commits (and actually updated or deleted the row, not just locked it) then the repeatable read transaction will be rolled back with the message</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 및 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 명령은 &lt;code&gt;SELECT&lt;/code&gt; 와 동일하게 동작합니다.대상 행 검색과 관련하여 트랜잭션 시작 시간에 커밋 된 대상 행만 찾습니다. 그러나 이러한 목표 행은 발견 될 때까지 다른 동시 트랜잭션에 의해 이미 갱신 (또는 삭제 또는 잠김)되었을 수 있습니다. 이 경우 반복 가능한 읽기 트랜잭션은 첫 번째 업데이트 트랜잭션이 커밋 또는 롤백 될 때까지 기다립니다 (아직 진행중인 경우). 첫 번째 업데이터가 롤백하면 해당 효과가 무시되고 반복 가능한 읽기 트랜잭션이 원래 찾은 행을 업데이트 할 수 있습니다. 그러나 첫 번째 업데이터가 커밋 (및 실제로 행을 잠그지 않고 업데이트 또는 삭제 한 경우)하면 반복 가능한 읽기 트랜잭션이 메시지와 함께 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="0a5a454caecf27bbe6291441d0e1fe48bac2bedc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;USER&lt;/code&gt;&lt;code&gt;role_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;USER&lt;/code&gt;&lt;code&gt;role_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67a60ecbbd27c2b09e753a03b48077dde7c8fe0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;USING&lt;/code&gt; is reasonably safe from column changes in the joined relations since only the listed columns are combined. &lt;code&gt;NATURAL&lt;/code&gt; is considerably more risky since any schema changes to either relation that cause a new matching column name to be present will cause the join to combine that new column as well.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 나열된 열만 결합되므로 USING 은 조인 된 관계의 열 변경으로부터 합리적으로 안전합니다. 일치하는 새 열 이름이 존재하는 관계로 스키마를 변경하면 조인이 해당 새 열도 결합하게되므로 &lt;code&gt;NATURAL&lt;/code&gt; 은 훨씬 더 위험합니다.</target>
        </trans-unit>
        <trans-unit id="3a1ec878720dbc69a4150ba8c568bb3f73b7caba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;V&lt;/code&gt; with &lt;code&gt;to_char&lt;/code&gt; multiplies the input values by &lt;code&gt;10^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of digits following &lt;code&gt;V&lt;/code&gt;. &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;to_number&lt;/code&gt; divides in a similar manner. &lt;code&gt;to_char&lt;/code&gt; and &lt;code&gt;to_number&lt;/code&gt; do not support the use of &lt;code&gt;V&lt;/code&gt; combined with a decimal point (e.g., &lt;code&gt;99.9V99&lt;/code&gt; is not allowed).</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 와 &lt;code&gt;to_char&lt;/code&gt; 승산은 입력 값을 기준으로 &lt;code&gt;10^n&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 다음의 자리수 &lt;code&gt;V&lt;/code&gt; . &lt;code&gt;to_number&lt;/code&gt; 를 가진 &lt;code&gt;V&lt;/code&gt; 는 비슷한 방식으로 나눕니다. &lt;code&gt;to_char&lt;/code&gt; 및 &lt;code&gt;to_number&lt;/code&gt; 는 소수점과 결합 된 &lt;code&gt;V&lt;/code&gt; 의 사용을 지원하지 않습니다 (예 : &lt;code&gt;99.9V99&lt;/code&gt; 는 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="55a11e4aa1258c855805d2b47b7f449297ef0ae3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM ANALYZE&lt;/code&gt; performs a &lt;code&gt;VACUUM&lt;/code&gt; and then an &lt;code&gt;ANALYZE&lt;/code&gt; for each selected table. This is a handy combination form for routine maintenance scripts. See &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; for more details about its processing.</source>
          <target state="translated">&lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 을 수행에게 &lt;code&gt;VACUUM&lt;/code&gt; 한 다음은 &lt;code&gt;ANALYZE&lt;/code&gt; 선택된 각 테이블. 이것은 일상적인 유지 보수 스크립트를위한 편리한 조합 양식입니다. 참조 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 의 처리에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="7c8166acd604c2610b7642832cba33780e173eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 트랜잭션 블록 안에서 VACUUM 을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba2d01866894bc81939d3b5b8a1f9e668a2d4b32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; causes a substantial increase in I/O traffic, which might cause poor performance for other active sessions. Therefore, it is sometimes advisable to use the cost-based vacuum delay feature. See &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 I / O 트래픽을 크게 증가시켜 다른 활성 세션의 성능이 저하 될 수 있습니다. 따라서 때때로 비용 기반 진공 지연 기능을 사용하는 것이 좋습니다. 자세한 내용 &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;은 19.4.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="009f475b343679cb1aad5d8f6aac21bdb69bafa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; creates a substantial amount of I/O traffic, which can cause poor performance for other active sessions. There are configuration parameters that can be adjusted to reduce the performance impact of background vacuuming &amp;mdash; see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 상당한 양의 I / O 트래픽을 생성하여 다른 활성 세션의 성능이 저하 될 수 있습니다. 백그라운드 진공 청소기의 성능 영향을 줄이기 위해 조정할 수있는 구성 매개 변수가 있습니다 ( &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;섹션 19.4.4&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b0f9ed551b6354baf5723455d29183a345c3e4b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is currently cleaning up indexes. This occurs after the heap has been completely scanned and all vacuuming of the indexes and the heap has been completed.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 현재 인덱스를 정리하고 있습니다. 힙이 완전히 스캔되고 인덱스 및 힙의 모든 진공 청소기가 완료된 후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c0a22ee8a8050f3b0151c8b0a857fefaea99eb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is currently scanning the heap. It will prune and defragment each page if required, and possibly perform freezing activity. The &lt;code&gt;heap_blks_scanned&lt;/code&gt; column can be used to monitor the progress of the scan.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 현재 힙을 스캔하고 있습니다. 필요한 경우 각 페이지를 정리하고 조각 모음을 수행하며 정지 작업을 수행 할 수 있습니다. &lt;code&gt;heap_blks_scanned&lt;/code&gt; 열은 검사의 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9df08bca46feaa9001d912895cf6b57c381072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is currently truncating the heap so as to return empty pages at the end of the relation to the operating system. This occurs after cleaning up indexes.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 현재 운영 체제와의 관계가 끝날 때 빈 페이지를 리턴하기 위해 힙을 절단하고 있습니다. 인덱스를 정리 한 후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="acda59f0e0f6c6108ca2a4f6139517c1426fe725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is currently vacuuming the heap. Vacuuming the heap is distinct from scanning the heap, and occurs after each instance of vacuuming indexes. If &lt;code&gt;heap_blks_scanned&lt;/code&gt; is less than &lt;code&gt;heap_blks_total&lt;/code&gt;, the system will return to scanning the heap after this phase is completed; otherwise, it will begin cleaning up indexes after this phase is completed.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 현재 힙을 진공 청소기로 청소하고 있습니다. 힙을 진공 청소기로 청소하는 것은 힙을 스캔하는 것과는 별개이며, 진공 청소기로 청소하는 각 인스턴스 후에 발생합니다. 경우 &lt;code&gt;heap_blks_scanned&lt;/code&gt; 이 적은보다 &lt;code&gt;heap_blks_total&lt;/code&gt; , 시스템은이 단계가 완료된 후 힙을 스캔으로 돌아갑니다; 그렇지 않으면이 단계가 완료된 후 인덱스 정리가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f1cf61683bfc9a1f9d8624d9c87e495ae526c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is currently vacuuming the indexes. If a table has any indexes, this will happen at least once per vacuum, after the heap has been completely scanned. It may happen multiple times per vacuum if &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; is insufficient to store the number of dead tuples found.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 현재 인덱스를 정리하고 있습니다. 테이블에 인덱스가있는 경우 힙이 완전히 스캔 된 후 진공 당 한 번 이상 발생합니다. &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 이 발견 된 데드 튜플 수를 저장하기에 충분하지 않은 경우 진공 당 여러 번 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8362d3a834123ef9584c36d9f664fae31dfe13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is performing final cleanup. During this phase, &lt;code&gt;VACUUM&lt;/code&gt; will vacuum the free space map, update statistics in &lt;code&gt;pg_class&lt;/code&gt;, and report statistics to the statistics collector. When this phase is completed, &lt;code&gt;VACUUM&lt;/code&gt; will end.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 최종 정리를 수행하고 있습니다. 이 단계에서 &lt;code&gt;VACUUM&lt;/code&gt; 은 여유 공간 맵을 &lt;code&gt;pg_class&lt;/code&gt; 하고 pg_class의 통계를 업데이트 하며 통계를 통계 수집기에보고합니다. 이 단계가 완료되면 &lt;code&gt;VACUUM&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f40eccefc9091a18b1458933d57b109ab990e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; is preparing to begin scanning the heap. This phase is expected to be very brief.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 이 힙 스캔을 시작할 준비를하고 있습니다. 이 단계는 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="7b2836ec397ff055922c85642dd41af49391f922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; normally only scans pages that have been modified since the last vacuum, but &lt;code&gt;relfrozenxid&lt;/code&gt; can only be advanced when every page of the table that might contain unfrozen XIDs is scanned. This happens when &lt;code&gt;relfrozenxid&lt;/code&gt; is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, when &lt;code&gt;VACUUM&lt;/code&gt;'s &lt;code&gt;FREEZE&lt;/code&gt; option is used, or when all pages that are not already all-frozen happen to require vacuuming to remove dead row versions. When &lt;code&gt;VACUUM&lt;/code&gt; scans every page in the table that is not already all-frozen, it should set &lt;code&gt;age(relfrozenxid)&lt;/code&gt; to a value just a little more than the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; setting that was used (more by the number of transactions started since the &lt;code&gt;VACUUM&lt;/code&gt; started). If no &lt;code&gt;relfrozenxid&lt;/code&gt;-advancing &lt;code&gt;VACUUM&lt;/code&gt; is issued on the table until &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is reached, an autovacuum will soon be forced for the table.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 일반적으로 마지막 진공 이후 수정 된 페이지 만 스캔하지만 &lt;code&gt;relfrozenxid&lt;/code&gt; 는 고정되지 않은 XID를 포함 할 수있는 테이블의 모든 페이지가 스캔 될 때만 진행될 수 있습니다. 이 문제 는 &lt;code&gt;relfrozenxid&lt;/code&gt; 가 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 트랜잭션 보다 오래된 트랜잭션, &lt;code&gt;VACUUM&lt;/code&gt; 의 &lt;code&gt;FREEZE&lt;/code&gt; 옵션이 사용 된 경우 또는 아직 완전히 고정되지 않은 모든 페이지에서 데드 행 버전을 제거하기 위해 진공 처리가 필요한 경우에 발생합니다. &lt;code&gt;VACUUM&lt;/code&gt; 이 아직 완전히 고정되지 않은 테이블의 모든 페이지를 스캔 할 때 &lt;code&gt;age(relfrozenxid)&lt;/code&gt; 를 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 보다 약간 더 큰 값으로 설정해야합니다.사용 된 설정 ( &lt;code&gt;VACUUM&lt;/code&gt; 이 시작된 이후 시작된 트랜잭션 수에 따라 다름 ) &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 에 도달 할 때까지 테이블에 &lt;code&gt;relfrozenxid&lt;/code&gt; -advancing &lt;code&gt;VACUUM&lt;/code&gt; 이 발행 되지 않으면 곧 테이블에 대해 자동 진공 이 강제 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c712c96697ea586ab4c9c06b9a881cac6dd51355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; performs an aggressive scan if the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; field has reached the age specified by this setting. An aggressive scan differs from a regular &lt;code&gt;VACUUM&lt;/code&gt; in that it visits every page that might contain unfrozen XIDs or MXIDs, not just those that might contain dead tuples. The default is 150 million transactions. Although users can set this value anywhere from zero to two billions, &lt;code&gt;VACUUM&lt;/code&gt; will silently limit the effective value to 95% of &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;, so that a periodical manual &lt;code&gt;VACUUM&lt;/code&gt; has a chance to run before an anti-wraparound autovacuum is launched for the table. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 테이블의 &lt;code&gt;pg_class&lt;/code&gt; 인 경우 공격적인 스캔을 수행합니다 . &lt;code&gt;relfrozenxid&lt;/code&gt; 필드가이 설정으로 지정된 연령에 도달했습니다. 공격적인 스캔은 데드 튜플을 포함 할 수있는 페이지뿐만 아니라 고정되지 않은 XID 또는 MXID를 포함 할 수있는 모든 페이지를 방문한다는 점에서 일반 &lt;code&gt;VACUUM&lt;/code&gt; 과 다릅니다 . 기본값은 1 억 5 천만 건입니다. 사용자는이 값을 0에서 20 억 &lt;code&gt;VACUUM&lt;/code&gt; 설정할 수 있지만 VACUUM 은 유효 값을 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age의&lt;/a&gt; 95 %로 자동 제한 하므로 , 테이블에 대해 랩 어라운드 방지 autovacuum을 시작하기 전에 정기적 인 수동 &lt;code&gt;VACUUM&lt;/code&gt; 을 실행할 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dd76101bce62c4824bf1485662f9d2834f8e0ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; performs an aggressive scan if the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; field has reached the age specified by this setting. An aggressive scan differs from a regular &lt;code&gt;VACUUM&lt;/code&gt; in that it visits every page that might contain unfrozen XIDs or MXIDs, not just those that might contain dead tuples. The default is 150 million multixacts. Although users can set this value anywhere from zero to two billions, &lt;code&gt;VACUUM&lt;/code&gt; will silently limit the effective value to 95% of &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;, so that a periodical manual &lt;code&gt;VACUUM&lt;/code&gt; has a chance to run before an anti-wraparound is launched for the table. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 테이블의 &lt;code&gt;pg_class&lt;/code&gt; 인 경우 공격적인 스캔을 수행합니다 . &lt;code&gt;relminmxid&lt;/code&gt; 필드가이 설정으로 지정된 연령에 도달했습니다. 공격적인 스캔은 데드 튜플을 포함 할 수있는 페이지뿐만 아니라 고정되지 않은 XID 또는 MXID를 포함 할 수있는 모든 페이지를 방문한다는 점에서 일반 &lt;code&gt;VACUUM&lt;/code&gt; 과 다릅니다 . 기본값은 1 억 5 천만 멀티 플렉스입니다. 사용자는이 값을 0에서 20 억 &lt;code&gt;VACUUM&lt;/code&gt; 설정할 수 있지만 VACUUM 은 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; 의 유효 값을 자동으로 95 %로 제한 하므로 테이블에 랩 어라운드가 시작되기 전에 정기적 인 수동 &lt;code&gt;VACUUM&lt;/code&gt; 이 실행될 수 있습니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;24.1.5.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bde7de0c3a8204fa1eaab8d792657116d1d9a81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; reclaims storage occupied by dead tuples. In normal PostgreSQL operation, tuples that are deleted or obsoleted by an update are not physically removed from their table; they remain present until a &lt;code&gt;VACUUM&lt;/code&gt; is done. Therefore it's necessary to do &lt;code&gt;VACUUM&lt;/code&gt; periodically, especially on frequently-updated tables.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 죽은 튜플이 차지한 스토리지를 회수합니다. 일반적인 PostgreSQL 작업에서 업데이트에 의해 삭제되거나 폐기 된 튜플은 실제로 테이블에서 제거되지 않습니다. &lt;code&gt;VACUUM&lt;/code&gt; 이 완료 될 때까지 존재 합니다. 따라서 , 특히 자주 업데이트되는 테이블에서 &lt;code&gt;VACUUM&lt;/code&gt; 을 정기적으로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9509e6daa2d944355d94abefff6f2b1320c54b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VACUUM&lt;/code&gt; uses the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; to determine which pages of a table must be scanned. Normally, it will skip pages that don't have any dead row versions even if those pages might still have row versions with old XID values. Therefore, normal &lt;code&gt;VACUUM&lt;/code&gt;s won't always freeze every old row version in the table. Periodically, &lt;code&gt;VACUUM&lt;/code&gt; will perform an &lt;em&gt;aggressive vacuum&lt;/em&gt;, skipping only those pages which contain neither dead rows nor any unfrozen XID or MXID values. &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; controls when &lt;code&gt;VACUUM&lt;/code&gt; does that: all-visible but not all-frozen pages are scanned if the number of transactions that have passed since the last such scan is greater than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;. Setting &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; to 0 forces &lt;code&gt;VACUUM&lt;/code&gt; to use this more aggressive strategy for all scans.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 은 &lt;a href=&quot;storage-vm&quot;&gt;가시성 맵&lt;/a&gt; 을 사용하여 스캔 할 테이블의 페이지를 결정합니다. 일반적으로 이전 XID 값을 가진 행 버전이있는 페이지 일지라도 사용 가능한 행 버전이없는 페이지는 건너 뜁니다. 따라서 일반 &lt;code&gt;VACUUM&lt;/code&gt; 은 항상 테이블의 모든 이전 행 버전을 고정하지는 않습니다. &lt;code&gt;VACUUM&lt;/code&gt; 은 주기적 &lt;em&gt;으로 적극적인 진공&lt;/em&gt; 을 수행하여 데드 행이나 고정되지 않은 XID 또는 MXID 값이 포함되지 않은 페이지 만 건너 뜁니다. &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; 는 &lt;code&gt;VACUUM&lt;/code&gt; 이 다음을 수행하는 시기를 제어 합니다. 마지막으로 스캔 한 이후에 통과 한 트랜잭션 수가 이보다 큰 경우 모든 표시 가능하지만 완전히 고정되지 않은 페이지가 스캔됩니다. &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 빼기 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; . &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 를 0으로 설정하면 &lt;code&gt;VACUUM&lt;/code&gt; 이 모든 스캔에이보다 적극적인 전략을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c2a8aa36047724c3880b998478b069a0bb150f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALID UNTIL&lt;/code&gt; '&lt;code&gt;timestamp&lt;/code&gt;'</source>
          <target state="translated">&lt;code&gt;VALID UNTIL&lt;/code&gt; ' &lt;code&gt;timestamp&lt;/code&gt; '</target>
        </trans-unit>
        <trans-unit id="a333ee183ddb9a34cc375df204fa5e12108d3d97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALIDATOR&lt;/code&gt;&lt;code&gt;valfunction&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VALIDATOR&lt;/code&gt;&lt;code&gt;valfunction&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ba04c885bbb2f3268ce0ba6d01be5e736428d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES&lt;/code&gt; can also be used where a sub-&lt;code&gt;SELECT&lt;/code&gt; might be written, for example in a &lt;code&gt;FROM&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;VALUES&lt;/code&gt; 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 작성 될 수있는 위치 ( 예 : &lt;code&gt;FROM&lt;/code&gt; 절) 에서 VALUES를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d74f4cacc54a226c0d65a8cd146fc7d88afad9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES&lt;/code&gt; computes a row value or set of row values specified by value expressions. It is most commonly used to generate a &amp;ldquo;constant table&amp;rdquo; within a larger command, but it can be used on its own.</source>
          <target state="translated">&lt;code&gt;VALUES&lt;/code&gt; 는 값 표현식으로 지정된 행 값 또는 행 값 세트를 계산합니다. 더 큰 명령 내에서 &quot;일정한 테이블&quot;을 생성하는 데 가장 일반적으로 사용되지만 자체적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae950693f54d3b998ed7dbc20b3b3c0d958a6fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES&lt;/code&gt; conforms to the SQL standard. &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; are PostgreSQL extensions; see also under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VALUES&lt;/code&gt; 은 SQL 표준을 준수합니다. &lt;code&gt;LIMIT&lt;/code&gt; 및 &lt;code&gt;OFFSET&lt;/code&gt; 은 PostgreSQL 확장입니다. &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 아래도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb3f38acc90b713656e0ad7c171625d13dd8257c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES&lt;/code&gt; lists with very large numbers of rows should be avoided, as you might encounter out-of-memory failures or poor performance. &lt;code&gt;VALUES&lt;/code&gt; appearing within &lt;code&gt;INSERT&lt;/code&gt; is a special case (because the desired column types are known from the &lt;code&gt;INSERT&lt;/code&gt;'s target table, and need not be inferred by scanning the &lt;code&gt;VALUES&lt;/code&gt; list), so it can handle larger lists than are practical in other contexts.</source>
          <target state="translated">&lt;code&gt;VALUES&lt;/code&gt; 메모리가 부족하거나 성능이 저하 될 수 있으므로 행 수가 많은 VALUES 목록은 피해야합니다. &lt;code&gt;INSERT&lt;/code&gt; 에 나타나는 &lt;code&gt;VALUES&lt;/code&gt; 은 특별한 경우입니다 (원하는 열 유형이 &lt;code&gt;INSERT&lt;/code&gt; 의 대상 테이블 에서 알려 지고 &lt;code&gt;VALUES&lt;/code&gt; 목록 을 스캔하여 추론 할 필요가 없기 때문에). 따라서 다른 컨텍스트에서 실제보다 큰 목록을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a17bb893077f9684f46be6eda8d3f3ba46d539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES&lt;/code&gt; provides a way to generate a &amp;ldquo;constant table&amp;rdquo; that can be used in a query without having to actually create and populate a table on-disk. The syntax is</source>
          <target state="translated">&lt;code&gt;VALUES&lt;/code&gt; 는 실제로 디스크에 테이블을 작성하고 채울 필요없이 쿼리에 사용할 수있는 &quot;일정한 테이블&quot;을 생성하는 방법을 제공합니다. 문법은</target>
        </trans-unit>
        <trans-unit id="af3e1e00eef4e6314e5fdfaec5572c99cff832cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VARIADIC&lt;/code&gt;&lt;code&gt;&quot;any&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VARIADIC&lt;/code&gt;&lt;code&gt;&quot;any&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56efe2d3dd1fcd2103eea0fe5df69769b0e1d0f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt;&lt;code&gt;VERSION_NAME&lt;/code&gt;&lt;code&gt;VERSION_NUM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt;&lt;code&gt;VERSION_NAME&lt;/code&gt;&lt;code&gt;VERSION_NUM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae006510fd032c2e7108bab197e82cb0f6070ee0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VOLATILE&lt;/code&gt; indicates that the function value can change even within a single table scan, so no optimizations can be made. Relatively few database functions are volatile in this sense; some examples are &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;currval()&lt;/code&gt;, &lt;code&gt;timeofday()&lt;/code&gt;. But note that any function that has side-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away; an example is &lt;code&gt;setval()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VOLATILE&lt;/code&gt; 은 단일 테이블 스캔에서도 함수 값이 변경 될 수 있으므로 최적화를 수행 할 수 없음을 나타냅니다. 이러한 의미에서 일시적인 데이터베이스 기능은 상대적으로 적습니다. 몇 가지 예는 &lt;code&gt;random()&lt;/code&gt; , &lt;code&gt;currval()&lt;/code&gt; , &lt;code&gt;timeofday()&lt;/code&gt; 입니다. 그러나 부작용이있는 기능은 결과가 상당히 예측 가능하더라도 호출이 최적화되지 않도록 휘발성으로 분류되어야합니다. 예는 &lt;code&gt;setval()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2dac73cf86ceb68ba5ba013f4040a4865c1b6bb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WHERE&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="255c52db5d85094b6ce7c9ec47b25625c687e689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIN936&lt;/code&gt;, &lt;code&gt;Windows936&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIN936&lt;/code&gt; , &lt;code&gt;Windows936&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5a684cc205e043940cbed0b40d88337bd61cc46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIN949&lt;/code&gt;, &lt;code&gt;Windows949&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIN949&lt;/code&gt; , &lt;code&gt;Windows949&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acf25e99a5145fa8db481a0ea08cc1dfe9d8e4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIN950&lt;/code&gt;, &lt;code&gt;Windows950&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIN950&lt;/code&gt; , &lt;code&gt;Windows950&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7472d1e90394f1fb5065676a5be3df70c41fae9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WINDOW&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="ca72a29993b0b1044b978748dd47ae91a6ac77b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WINDOW&lt;/code&gt; indicates that the function is a &lt;em&gt;window function&lt;/em&gt; rather than a plain function. This is currently only useful for functions written in C. The &lt;code&gt;WINDOW&lt;/code&gt; attribute cannot be changed when replacing an existing function definition.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 는 함수가 일반 함수가 아닌 &lt;em&gt;윈도우 함수&lt;/em&gt; 임을 나타냅니다 . 이것은 현재 C로 작성된 함수에만 유용합니다 . 기존 함수 정의를 바꿀 때 &lt;code&gt;WINDOW&lt;/code&gt; 속성을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3065c16c1a6ed061c3ecca459fcac6421f56ce07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITH HOLD&lt;/code&gt; may not be specified when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WITH HOLD&lt;/code&gt; 쿼리에 &lt;code&gt;FOR UPDATE&lt;/code&gt; 또는 &lt;code&gt;FOR SHARE&lt;/code&gt; 가 포함되어 있으면 WITH HOLD를 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b37c12ca197e0d4d7e93c77057e285e61034d2e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITH HOLD&lt;/code&gt; specifies that the cursor can continue to be used after the transaction that created it successfully commits. &lt;code&gt;WITHOUT HOLD&lt;/code&gt; specifies that the cursor cannot be used outside of the transaction that created it. If neither &lt;code&gt;WITHOUT HOLD&lt;/code&gt; nor &lt;code&gt;WITH HOLD&lt;/code&gt; is specified, &lt;code&gt;WITHOUT HOLD&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;WITH HOLD&lt;/code&gt; 는 커서를 작성한 트랜잭션이 커미트 된 후에도 커서를 계속 사용할 수 있도록 지정합니다. &lt;code&gt;WITHOUT HOLD&lt;/code&gt; 는 커서를 만든 트랜잭션 외부에서 커서를 사용할 수 없도록 지정합니다. &lt;code&gt;WITHOUT HOLD&lt;/code&gt; 또는 &lt;code&gt;WITH HOLD&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;WITHOUT HOLD&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7fb666630267f1dc412cd03bb2382af6e1676a01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITH HOLD&lt;/code&gt;&lt;code&gt;WITHOUT HOLD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WITH HOLD&lt;/code&gt; &lt;code&gt;WITHOUT HOLD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ef0328d6dd75f9bf63dd9963faddfe630e63d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITH&lt;/code&gt; Clause</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="7b8c995bf2fcfa04aeddb00aa3bbb4a6f40cf509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITH&lt;/code&gt; provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query. Each auxiliary statement in a &lt;code&gt;WITH&lt;/code&gt; clause can be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;; and the &lt;code&gt;WITH&lt;/code&gt; clause itself is attached to a primary statement that can also be a &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 는 더 큰 쿼리에 사용할 보조 문을 작성하는 방법을 제공합니다. 흔히 공통 테이블 표현식 또는 CTE라고하는이 명령문은 하나의 쿼리에 대해서만 존재하는 임시 테이블을 정의하는 것으로 생각할 수 있습니다. &lt;code&gt;WITH&lt;/code&gt; 절의 각 보조 명령문은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 일 수 있습니다 . 그리고 &lt;code&gt;WITH&lt;/code&gt; 절 자체도 될 수있는 차 문에 부착 된 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 를 , 또는 &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67bbe170001be69d4e59b314e593595ba90d58e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WORK&lt;/code&gt;&lt;code&gt;TRANSACTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WORK&lt;/code&gt;&lt;code&gt;TRANSACTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c6845a2804d5d5a00ff90bce09c46f93ead1c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[ EXTERNAL ] SECURITY INVOKER&lt;/code&gt;&lt;code&gt;[ EXTERNAL ] SECURITY DEFINER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[ EXTERNAL ] SECURITY INVOKER&lt;/code&gt; &lt;code&gt;[ EXTERNAL ] SECURITY DEFINER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1350985f0b46a7b86ec5fcf9a6190f315082ee0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[-d] dbname&lt;/code&gt;&lt;code&gt;[--dbname=]dbname&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[-d] dbname&lt;/code&gt; &lt;code&gt;[--dbname=]dbname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e6133de9165856bec31a963923494e952b07a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d7a9561499865aaba1ff31c2d93cc67e7499a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt;&lt;code&gt;chars&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt;&lt;code&gt;chars&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e538177509b40bbb6afd7d470a3dc122709850d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[EXTERNAL] SECURITY INVOKER&lt;/code&gt;&lt;code&gt;[EXTERNAL] SECURITY DEFINER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[EXTERNAL] SECURITY INVOKER&lt;/code&gt; &lt;code&gt;[EXTERNAL] SECURITY DEFINER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68fc3cdef2a974e21e55770d4e30aab20e80be7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:alnum:]_]&lt;/code&gt; (note underscore is included)</source>
          <target state="translated">&lt;code&gt;[[:alnum:]_]&lt;/code&gt; (밑줄이 포함되어 있음)</target>
        </trans-unit>
        <trans-unit id="038dfef0afe6f9ac17621abc30786e664886947b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^[:alnum:]_]&lt;/code&gt; (note underscore is included)</source>
          <target state="translated">&lt;code&gt;[^[:alnum:]_]&lt;/code&gt; (밑줄이 포함되어 있음)</target>
        </trans-unit>
        <trans-unit id="cb138c59b50a639b5cf50e48b92b0c0d72e8990b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f206327e3cf80a16ae9805c2cb11e04e2846f6d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a18a86346195aa5fb3375ddfcbc7c728011b8643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;k&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23d31596b2e40c411dc5cc6581584e061c0c30f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57eb199aa3159dfae3d5b4d0771aa902500cdb45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;mnn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;mnn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660c2200ecad649abdd6fcea6939ea85d19c53b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;xy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;xy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87e09177a4751a8d9f034d0e2350b787c2daa154" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dfe62804016250566e45268f4ed12c9789470b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\H&lt;/code&gt; or &lt;code&gt;\html&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\H&lt;/code&gt; 또는 &lt;code&gt;\html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef87d08c7bed7b21f6acc4d9021f0e8834726a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\U&lt;/code&gt;&lt;code&gt;stuvwxyz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\U&lt;/code&gt;&lt;code&gt;stuvwxyz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67075ce048a869f22b01b55ade4df5929133eb72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; or &lt;code&gt;\connect [ -reuse-previous=on|off ] [ dbname [ username ] [ host ] [ port ] | conninfo ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt; 또는 &lt;code&gt;\connect [ -reuse-previous=on|off ] [ dbname [ username ] [ host ] [ port ] | conninfo ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cae36c49547b651f198a2a29fa9df015f3017b24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt;&lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt;&lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="608145b8c961099b2ee57031d929f80d059100ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\dE[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;&lt;code&gt;\di[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;&lt;code&gt;\dm[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;&lt;code&gt;\ds[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;&lt;code&gt;\dt[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;&lt;code&gt;\dv[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\dE[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt; &lt;code&gt;\di[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt; &lt;code&gt;\dm[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt; &lt;code&gt;\ds[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt; &lt;code&gt;\dt[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt; &lt;code&gt;\dv[S+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="444ba3dde2996198b10d820de6f19d1678ac0ff9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\dd&lt;/code&gt; displays descriptions for objects matching the &lt;code&gt;pattern&lt;/code&gt;, or of visible objects of the appropriate type if no argument is given. But in either case, only objects that have a description are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">&lt;code&gt;\dd&lt;/code&gt; 는 &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 객체에 대한 설명 또는 인수가 제공되지 않은 경우 적절한 유형의 보이는 객체에 대한 설명을 표시합니다. 그러나 두 경우 모두 설명이있는 개체 만 나열됩니다. 기본적으로 사용자가 만든 개체 만 표시됩니다. 시스템 오브젝트를 포함 하도록 패턴 또는 &lt;code&gt;S&lt;/code&gt; 수정자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="f6e22ed690bbf7578ec9874cfc12a0bc6d7a09c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\deu+&lt;/code&gt; might also display the user name and password of the remote user, so care should be taken not to disclose them.</source>
          <target state="translated">&lt;code&gt;\deu+&lt;/code&gt; 는 원격 사용자의 사용자 이름과 암호도 표시 할 수 있으므로 공개하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="36d92eba3108cd6c8c33d690295373e53268515b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; or &lt;code&gt;\edit&lt;/code&gt;&lt;code&gt;[ filename ] [ line_number ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 또는 &lt;code&gt;\edit&lt;/code&gt; &lt;code&gt;[ filename ] [ line_number ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c0e35ca346bae54d3d09156eede8ed2c31b4fe9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g [ filename ]&lt;/code&gt;&lt;code&gt;\g [ |command ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\g [ filename ]&lt;/code&gt; &lt;code&gt;\g [ |command ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a136507fe3cd2926732d87edeb1e2c527020617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\gx [ filename ]&lt;/code&gt;&lt;code&gt;\gx [ |command ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\gx [ filename ]&lt;/code&gt; &lt;code&gt;\gx [ |command ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e59c20763657abd76791f439aa9ff96b6552a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\gx&lt;/code&gt; is equivalent to &lt;code&gt;\g&lt;/code&gt;, but forces expanded output mode for this query. See &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\gx&lt;/code&gt; 는 &lt;code&gt;\g&lt;/code&gt; 와 동일 하지만이 쿼리에 대해 확장 된 출력 모드를 강제합니다. &lt;code&gt;\x&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6a7dde19333ae462b9d93382f5b829c29e2cbea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\h&lt;/code&gt; or &lt;code&gt;\help&lt;/code&gt;&lt;code&gt;[ command ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\h&lt;/code&gt; 또는 &lt;code&gt;\help&lt;/code&gt; &lt;code&gt;[ command ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4b3e084b9c478d947efa3e0b1e9955b5a6ea4b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\include&lt;/code&gt;&lt;code&gt;filename&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\i&lt;/code&gt; 또는 &lt;code&gt;\include&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a68780e323ca4c60df96caf10c2da06e4ca0acd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\if&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;\elif&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;\else&lt;/code&gt;&lt;code&gt;\endif&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\if&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;\elif&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;\else&lt;/code&gt;&lt;code&gt;\endif&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70fe13eba7f488861e770b41975b92bd544e7981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\ir&lt;/code&gt; or &lt;code&gt;\include_relative&lt;/code&gt;&lt;code&gt;filename&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\ir&lt;/code&gt; 또는 &lt;code&gt;\include_relative&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e8897f922e6cc9b23b640671be05bc0161c0b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\l[+]&lt;/code&gt; or &lt;code&gt;\list[+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\l[+]&lt;/code&gt; 또는 &lt;code&gt;\list[+] [ &lt;a href=&quot;app-psql#APP-PSQL-PATTERNS&quot;&gt;pattern&lt;/a&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f23bce51e748968efe348e34c5e0e0b5931d62c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\o&lt;/code&gt; or &lt;code&gt;\out [ filename ]&lt;/code&gt;&lt;code&gt;\o&lt;/code&gt; or &lt;code&gt;\out [ |command ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; 또는 &lt;code&gt;\out [ filename ]&lt;/code&gt; &lt;code&gt;\o&lt;/code&gt; 또는 &lt;code&gt;\out [ |command ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82c7b2d041dfc6c2c6a60fdbb9fb1869cb823e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\o&lt;/code&gt;, &lt;code&gt;\oo&lt;/code&gt;, &lt;code&gt;\ooo&lt;/code&gt; (&lt;code&gt;o&lt;/code&gt; = 0 - 7)</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; , &lt;code&gt;\oo&lt;/code&gt; , &lt;code&gt;\ooo&lt;/code&gt; ( &lt;code&gt;o&lt;/code&gt; = 0-7 )</target>
        </trans-unit>
        <trans-unit id="608c70ca95a08762647843acc0e881d4b97476f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\print&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 또는 &lt;code&gt;\print&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b8e39c47101f3f63552cdf3014dc44e0386ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pset&lt;/code&gt; without any arguments displays the current status of all printing options.</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; 인수없이 \ pset 은 모든 인쇄 옵션의 현재 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a1715bef43f4d42f53bf60a43b2282f6210326c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\q&lt;/code&gt; or &lt;code&gt;\quit&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\q&lt;/code&gt; 또는 &lt;code&gt;\quit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e9d72fd2cf51bc5e89c7bfdbbcc48def76d2992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; or &lt;code&gt;\reset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; 또는 &lt;code&gt;\reset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0508525815a7eba4b834b8e0e3a64c07971c0847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\set&lt;/code&gt; without any arguments displays the names and values of all currently-set psql variables.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; 인수없이 \ set 은 현재 설정된 모든 psql 변수의 이름과 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7ff278f9331a434bba30b82fac5f5f2ec5de4c70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\u0000&lt;/code&gt; is disallowed, as are non-ASCII Unicode escapes if database encoding is not UTF8</source>
          <target state="translated">&lt;code&gt;\u0000&lt;/code&gt; 데이터베이스 인코딩이 UTF8이 아닌 경우 비 ASCII 유니 코드 이스케이프와 같이 \ u0000 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10e4bd6aa6ba9ccfdc5dd4a037b0b2b266a21d40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\u&lt;/code&gt;&lt;code&gt;wxyz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\u&lt;/code&gt;&lt;code&gt;wxyz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbfd30f6cfec5158ea3499c0e28afcd26de26a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uxxxx&lt;/code&gt;, &lt;code&gt;\Uxxxxxxxx&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; = 0 - 9, A - F)</source>
          <target state="translated">&lt;code&gt;\uxxxx&lt;/code&gt; , &lt;code&gt;\Uxxxxxxxx&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; = 0-9, A-F)</target>
        </trans-unit>
        <trans-unit id="2d96d632a3259be5279b14030755bd882723f56f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\write&lt;/code&gt;&lt;code&gt;filename&lt;/code&gt;&lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\write&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;command&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;\write&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt; &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;\write&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;command&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba59b1282cf7bd9ea4755b20ff44d44c03a53f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt;&lt;code&gt;digits&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284f4625d91ffd872665af9837f7ee762515ada2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x&lt;/code&gt;&lt;code&gt;hhh&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt;&lt;code&gt;hhh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d74c125266ec91e3244980683e24be9321f3198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xh&lt;/code&gt;, &lt;code&gt;\xhh&lt;/code&gt; (&lt;code&gt;h&lt;/code&gt; = 0 - 9, A - F)</source>
          <target state="translated">&lt;code&gt;\xh&lt;/code&gt; , &lt;code&gt;\xhh&lt;/code&gt; ( &lt;code&gt;h&lt;/code&gt; = 0-9, A-F)</target>
        </trans-unit>
        <trans-unit id="5797a8db22c85a3da1778a2aaa961a7ffda1db2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xxx&lt;/code&gt; (octal value)</source>
          <target state="translated">&lt;code&gt;\xxx&lt;/code&gt; (8 진수)</target>
        </trans-unit>
        <trans-unit id="84bc8deee8a67657dae928a659631f4680823aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; (&amp;ldquo;append&amp;rdquo;)</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; (&amp;ldquo;첨부&amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="6d34f4e24f7fc96798246dd51e78bcbd485c3cb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; AND &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae1a398bdc5e908c340dc1901c5c69f392065997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; OR &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09f914491c9f7b0c84c95955924965b0e4132b72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;&lt;code&gt;x&lt;/code&gt;&lt;code&gt;AND&lt;/code&gt;&lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;&lt;code&gt;x&lt;/code&gt;&lt;code&gt;AND&lt;/code&gt;&lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a034c05fc6d5f537d35509def3c5377e584c9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;between32symmetric&quot;&gt;BETWEEN SYMMETRIC&lt;/code&gt;&lt;code&gt;x&lt;/code&gt;&lt;code&gt;AND&lt;/code&gt;&lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code id=&quot;between32symmetric&quot;&gt;BETWEEN SYMMETRIC&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; &lt;code&gt;AND&lt;/code&gt; &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b40995c9eb2c17d05dd39c65f97ac2b777a66f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;is32distinct32from&quot;&gt;IS DISTINCT FROM&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code id=&quot;is32distinct32from&quot;&gt;IS DISTINCT FROM&lt;/code&gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d47567aa175162db9da026578931a610eac9bcc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;is32not32distinct32from&quot;&gt;IS NOT DISTINCT FROM&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code id=&quot;is32not32distinct32from&quot;&gt;IS NOT DISTINCT FROM&lt;/code&gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df77d11c87feb169b3ebcb1622ae10c501069c13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;not32between&quot;&gt;NOT BETWEEN&lt;/code&gt;&lt;code&gt;x&lt;/code&gt;&lt;code&gt;AND&lt;/code&gt;&lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; &lt;code&gt;AND&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; &lt;code id=&quot;not32between&quot;&gt;NOT BETWEEN&lt;/code&gt; 가 아님</target>
        </trans-unit>
        <trans-unit id="7668a93abe7378306abbe8ce59f696c5632a2999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code id=&quot;not32between32symmetric&quot;&gt;NOT BETWEEN SYMMETRIC&lt;/code&gt;&lt;code&gt;x&lt;/code&gt;&lt;code&gt;AND&lt;/code&gt;&lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code id=&quot;not32between32symmetric&quot;&gt;NOT BETWEEN SYMMETRIC&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; &lt;code&gt;AND&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; 사이 가 아님</target>
        </trans-unit>
        <trans-unit id="5b61f9fa2dd886dd12383ed003c2256f2aab0816" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acldefault&lt;/code&gt; returns the built-in default access privileges for an object of type &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; belonging to role &lt;em&gt;&lt;code&gt;ownerId&lt;/code&gt;&lt;/em&gt;. These represent the access privileges that will be assumed when an object's ACL entry is null. (The default access privileges are described in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.) The &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; parameter is a &lt;code&gt;CHAR&lt;/code&gt;: write 'c' for &lt;code&gt;COLUMN&lt;/code&gt;, 'r' for &lt;code&gt;TABLE&lt;/code&gt; and table-like objects, 's' for &lt;code&gt;SEQUENCE&lt;/code&gt;, 'd' for &lt;code&gt;DATABASE&lt;/code&gt;, 'f' for &lt;code&gt;FUNCTION&lt;/code&gt; or &lt;code&gt;PROCEDURE&lt;/code&gt;, 'l' for &lt;code&gt;LANGUAGE&lt;/code&gt;, 'L' for &lt;code&gt;LARGE OBJECT&lt;/code&gt;, 'n' for &lt;code&gt;SCHEMA&lt;/code&gt;, 't' for &lt;code&gt;TABLESPACE&lt;/code&gt;, 'F' for &lt;code&gt;FOREIGN DATA WRAPPER&lt;/code&gt;, 'S' for &lt;code&gt;FOREIGN SERVER&lt;/code&gt;, or 'T' for &lt;code&gt;TYPE&lt;/code&gt; or &lt;code&gt;DOMAIN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;acldefault&lt;/code&gt; 는 &lt;em&gt; &lt;code&gt;ownerId&lt;/code&gt; &lt;/em&gt; 역할에 속하는 유형 &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 의 객체에 대한 기본 제공 기본 액세스 권한을 반환합니다 . 이는 객체의 ACL 항목이 null 일 때 가정되는 액세스 권한을 나타냅니다. (기본 액세스 권한은 &lt;a href=&quot;ddl-priv&quot;&gt;5.7 절&lt;/a&gt; 에 설명되어 있습니다.) &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 매개 변수는 &lt;code&gt;CHAR&lt;/code&gt; 입니다 . &lt;code&gt;COLUMN&lt;/code&gt; 의 경우 ' c' , &lt;code&gt;TABLE&lt;/code&gt; 및 테이블과 같은 오브젝트의 경우 ' r' , &lt;code&gt;SEQUENCE&lt;/code&gt; 의 경우 's' , &lt;code&gt;DATABASE&lt;/code&gt; 의 경우 ' d' , ' &lt;code&gt;FUNCTION&lt;/code&gt; 또는 &lt;code&gt;PROCEDURE&lt;/code&gt; 경우 f ' , &lt;code&gt;LANGUAGE&lt;/code&gt; 경우'l ', &lt;code&gt;LARGE OBJECT&lt;/code&gt; 경우' L ' ,'n ' &lt;code&gt;SCHEMA&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;위한 't' &lt;code&gt;TABLESPACE&lt;/code&gt; 위한 'F' &lt;code&gt;FOREIGN DATA WRAPPER&lt;/code&gt; 들어, 'S' &lt;code&gt;FOREIGN SERVER&lt;/code&gt; 용 또는 'T' &lt;code&gt;TYPE&lt;/code&gt; 또는 &lt;code&gt;DOMAIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6fd7aeae82f25e97d94c1468f2e76bd898a5dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aclexplode&lt;/code&gt; returns an &lt;code&gt;aclitem&lt;/code&gt; array as a set of rows. Output columns are grantor &lt;code&gt;oid&lt;/code&gt;, grantee &lt;code&gt;oid&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt; for &lt;code&gt;PUBLIC&lt;/code&gt;), granted privilege as &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt;, ...) and whether the privilege is grantable as &lt;code&gt;boolean&lt;/code&gt;. &lt;code&gt;makeaclitem&lt;/code&gt; performs the inverse operation.</source>
          <target state="translated">&lt;code&gt;aclexplode&lt;/code&gt; 는 &lt;code&gt;aclitem&lt;/code&gt; 배열을 행 집합으로 반환합니다 . 출력 열 수 여자입니다 &lt;code&gt;oid&lt;/code&gt; , 피부 &lt;code&gt;oid&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; 에 대한 &lt;code&gt;PUBLIC&lt;/code&gt; )으로 부여 된 권한 &lt;code&gt;text&lt;/code&gt; ( &lt;code&gt;SELECT&lt;/code&gt; , ...)와 특권으로 부여 할 여부 &lt;code&gt;boolean&lt;/code&gt; . &lt;code&gt;makeaclitem&lt;/code&gt; 은 역 연산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="eed58dc3acf43ca016cfa6fac0a64db6f8600c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active&lt;/code&gt;: The backend is executing a query.</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; : 백엔드가 쿼리를 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="e4e80d319cc0031f1425ae5691fbbcc3008dced5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;adminpack&lt;/code&gt; provides a number of support functions which pgAdmin and other administration and management tools can use to provide additional functionality, such as remote management of server log files. Use of all these functions is only allowed to the superuser by default but may be allowed to other users by using the &lt;code&gt;GRANT&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;adminpack&lt;/code&gt; 은 pgAdmin 및 기타 관리 및 관리 도구가 서버 로그 파일의 원격 관리와 같은 추가 기능을 제공하기 위해 사용할 수있는 많은 지원 기능을 제공합니다. 이러한 모든 기능의 사용은 기본적으로 수퍼 유저에게만 허용되지만 &lt;code&gt;GRANT&lt;/code&gt; 명령 을 사용하여 다른 사용자에게도 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae89c0a797b2397758394ba1be0c48b841b7041" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aes&lt;/code&gt; &amp;mdash; AES (Rijndael-128, -192 or -256)</source>
          <target state="translated">&lt;code&gt;aes&lt;/code&gt; &amp;mdash; AES (Rijndael-128, -192 또는 -256)</target>
        </trans-unit>
        <trans-unit id="4750275affff8310aabd784e94da9699b78e9666" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; &amp;mdash; short name of the token type</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; &amp;mdash; 토큰 유형의 짧은 이름</target>
        </trans-unit>
        <trans-unit id="10b1e514554703917dd5bea36f86739c85f73d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aligned&lt;/code&gt; format is the standard, human-readable, nicely formatted text output; this is the default.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 형식은 사람이 읽을 수있는 표준 형식의 텍스트 출력입니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ec2395364a445e61a5009766fd584054599f80fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allow_system_table_mods&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;allow_system_table_mods&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e0897f6db2b52160010a12920048194e3ba9f142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;amcheck&lt;/code&gt; can be effective at detecting various types of failure modes that &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data page checksums&lt;/a&gt; will always fail to catch. These include:</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 는 &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;데이터 페이지 체크섬&lt;/a&gt; 이 항상 포착하지 못하는 다양한 유형의 실패 모드를 감지하는 데 효과적 일 수 있습니다 . 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="df97802a1382e7f131f8d0eaa67148065551599b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;amcheck&lt;/code&gt; functions may only be used by superusers.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 기능은 수퍼 유저 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e28b3ec66f269c9e4f2f8e6628ea49467f3a7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;application_name&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;application_name&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="782a401641cf673d16a28c6a87f0305ad27486f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;archive_cleanup_command&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;archive_cleanup_command&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aae4b114e63103a00e0644603ade60b5d6e4f480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;archive_command&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;archive_command&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="188ca1ff65214880763cce5eb35c4a87081810d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;archive_mode&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c312286920fd0c3a325f3ee73a10c80fd4c4aef2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;archive_mode&lt;/code&gt; and &lt;code&gt;archive_command&lt;/code&gt; are separate variables so that &lt;code&gt;archive_command&lt;/code&gt; can be changed without leaving archiving mode. This parameter can only be set at server start. &lt;code&gt;archive_mode&lt;/code&gt; cannot be enabled when &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; 및 &lt;code&gt;archive_command&lt;/code&gt; 는 별도의 변수이므로 아카이빙 모드를 종료하지 않고 &lt;code&gt;archive_command&lt;/code&gt; 를 변경할 수 있습니다. 이 매개 변수는 서버 시작시에만 설정할 수 있습니다. &lt;code&gt;wal_level&lt;/code&gt; 이 &lt;code&gt;minimal&lt;/code&gt; 로 설정되어 있으면 &lt;code&gt;archive_mode&lt;/code&gt; 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="211e96072b600deece8a80e931f721b0d79169e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;archive_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;archive_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="18450fca7e1f4bb355860c0ca1847f796ec041be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_dims&lt;/code&gt; produces a &lt;code&gt;text&lt;/code&gt; result, which is convenient for people to read but perhaps inconvenient for programs. Dimensions can also be retrieved with &lt;code&gt;array_upper&lt;/code&gt; and &lt;code&gt;array_lower&lt;/code&gt;, which return the upper and lower bound of a specified array dimension, respectively:</source>
          <target state="translated">&lt;code&gt;array_dims&lt;/code&gt; 는 &lt;code&gt;text&lt;/code&gt; 결과를 생성하여 사람들이 읽기 편하지만 프로그램에는 불편할 수 있습니다. 지정된 배열 차원의 상한과 하한을 각각 반환하는 &lt;code&gt;array_upper&lt;/code&gt; 및 &lt;code&gt;array_lower&lt;/code&gt; 를 사용 하여 차원을 검색 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa436b8fc63d6630377d858b3fdaf2ceace823d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_length&lt;/code&gt; will return the length of a specified array dimension:</source>
          <target state="translated">&lt;code&gt;array_length&lt;/code&gt; 는 지정된 배열 차원의 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0da428682552cc4f93a3e1523e40cf79309102ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_nulls&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;array_nulls&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d70be6c23f2bdd813c66168a5a6f465943d804d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_to_json&lt;/code&gt; and &lt;code&gt;row_to_json&lt;/code&gt; have the same behavior as &lt;code&gt;to_json&lt;/code&gt; except for offering a pretty-printing option. The behavior described for &lt;code&gt;to_json&lt;/code&gt; likewise applies to each individual value converted by the other JSON creation functions.</source>
          <target state="translated">&lt;code&gt;array_to_json&lt;/code&gt; 및 &lt;code&gt;row_to_json&lt;/code&gt; 은 예쁜 인쇄 옵션을 제공하는 것을 제외하고 &lt;code&gt;to_json&lt;/code&gt; 과 동일한 동작을 갖습니다 . &lt;code&gt;to_json&lt;/code&gt; 에 대해 설명 된 동작은 마찬가지로 다른 JSON 작성 함수로 변환 된 각 개별 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdee2f2f8937f912a7386754055cff9851a03a19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ascii&lt;/code&gt; style uses plain ASCII characters. Newlines in data are shown using a &lt;code&gt;+&lt;/code&gt; symbol in the right-hand margin. When the &lt;code&gt;wrapped&lt;/code&gt; format wraps data from one line to the next without a newline character, a dot (&lt;code&gt;.&lt;/code&gt;) is shown in the right-hand margin of the first line, and again in the left-hand margin of the following line.</source>
          <target state="translated">&lt;code&gt;ascii&lt;/code&gt; 스타일은 일반 ASCII 문자를 사용합니다. 데이터의 줄 바꿈 은 오른쪽 여백에 &lt;code&gt;+&lt;/code&gt; 기호를 사용하여 표시됩니다 . &lt;code&gt;wrapped&lt;/code&gt; 형식이 개행 문자없이 한 행에서 다음 행으로 데이터를 랩핑 할 때 첫 번째 행의 오른쪽 여백에 점 ( &lt;code&gt;.&lt;/code&gt; )이 표시되고 다음 행의 왼쪽 여백에 점 ( . )이 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a3982015b8306395d567a34f1e680e1597446525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;: This standby server is asynchronous.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; :이 대기 서버는 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="699c96eddff45e143a75d817d89fe1593494a127" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attType&lt;/code&gt; is passed in order to support polymorphic index operator classes; for ordinary fixed-data-type operator classes, it will always have the same value and so can be ignored.</source>
          <target state="translated">&lt;code&gt;attType&lt;/code&gt; 다형성 인덱스 연산자 클래스를 지원하기 위해 attType 이 전달됩니다. 일반 고정 데이터 유형 연산자 클래스의 경우 항상 동일한 값을 가지므로 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe38a309398cda08b9d3c7d683bc2c0732bb065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attstattarget&lt;/code&gt; controls the level of detail of statistics accumulated for this column by &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;. A zero value indicates that no statistics should be collected. A negative value says to use the system default statistics target. The exact meaning of positive values is data type-dependent. For scalar data types, &lt;code&gt;attstattarget&lt;/code&gt; is both the target number of &amp;ldquo;most common values&amp;rdquo; to collect, and the target number of histogram bins to create.</source>
          <target state="translated">&lt;code&gt;attstattarget&lt;/code&gt; 는 의한 열이 축적 된 통계의 세부 사항의 레벨을 제어 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE를&lt;/a&gt; . 값이 0이면 통계를 수집하지 않아야 함을 나타냅니다. 음수 값은 시스템 기본 통계 대상을 사용하라는 메시지입니다. 양수 값의 정확한 의미는 데이터 유형에 따라 다릅니다. 스칼라 데이터 형식의 경우 &lt;code&gt;attstattarget&lt;/code&gt; 은 수집 할 &quot;가장 일반적인 값&quot;의 대상 수와 만들 히스토그램 저장소의 대상 수입니다.</target>
        </trans-unit>
        <trans-unit id="2fe3224df3366d97c6b99540b8594e163154959e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atttypmod&lt;/code&gt; records type-specific data supplied at table creation time (for example, the maximum length of a &lt;code&gt;varchar&lt;/code&gt; column). It is passed to type-specific input functions and length coercion functions. The value will generally be -1 for types that do not need &lt;code&gt;atttypmod&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atttypmod&lt;/code&gt; 는 테이블 작성시 제공된 유형별 데이터 (예 : &lt;code&gt;varchar&lt;/code&gt; 열의 최대 길이 )를 기록합니다. 유형별 입력 함수 및 길이 강제 함수로 전달됩니다. &lt;code&gt;atttypmod&lt;/code&gt; 가 필요없는 유형의 경우 일반적으로 값은 -1입니다 .</target>
        </trans-unit>
        <trans-unit id="3571fd2d48b0ac2ec69e622df343d503fd4d6785" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auth_delay.milliseconds&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auth_delay.milliseconds&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd61b03481638c83cc6a73c4c1208492ca22cada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auth_delay&lt;/code&gt; causes the server to pause briefly before reporting authentication failure, to make brute-force attacks on database passwords more difficult. Note that it does nothing to prevent denial-of-service attacks, and may even exacerbate them, since processes that are waiting before reporting authentication failure will still consume connection slots.</source>
          <target state="translated">&lt;code&gt;auth_delay&lt;/code&gt; 는 인증 실패를보고하기 전에 서버가 잠시 일시 중지되어 데이터베이스 암호에 대한 무차별 대입 공격을보다 어렵게 만듭니다. 인증 실패를보고하기 전에 대기중인 프로세스는 여전히 연결 슬롯을 사용하기 때문에 서비스 거부 공격을 막을 수있는 것은 아니며 공격을 악화시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dd9764b023901fdee4017d362b60baad79770e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;authentication_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;authentication_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="07746c1178877feea98d42d0f4d49a2d652a3694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_analyze&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_analyze&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="df1eabf7cabd9590ca0fe7babb0c44ed556651e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_analyze&lt;/code&gt; causes &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; output, rather than just &lt;code&gt;EXPLAIN&lt;/code&gt; output, to be printed when an execution plan is logged. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_analyze&lt;/code&gt; 의 원인 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 단지보다는 출력 &lt;code&gt;EXPLAIN&lt;/code&gt; 실행 계획이 기록 될 때 인쇄 될 출력한다. 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0226876cb466b4c6900adcba843b8df340835a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_buffers&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_buffers&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5c9cb3669b1a1d99efaf68364eb9e1c09f6cafb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_buffers&lt;/code&gt; controls whether buffer usage statistics are printed when an execution plan is logged; it's equivalent to the &lt;code&gt;BUFFERS&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;. This parameter has no effect unless &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; is enabled. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_buffers&lt;/code&gt; 는 실행 계획이 로그 될 때 버퍼 사용 통계가 인쇄되는지 여부를 제어합니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 의 &lt;code&gt;BUFFERS&lt;/code&gt; 옵션과 동일합니다 . &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; 를 사용 하지 않으면이 매개 변수가 적용되지 않습니다 . 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df12016846b8904a767e68008c7c31d6108d8b80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_format&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_format&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="857d4312482a9356701d7c180cd5ae4ad5be26d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_format&lt;/code&gt; selects the &lt;code&gt;EXPLAIN&lt;/code&gt; output format to be used. The allowed values are &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;yaml&lt;/code&gt;. The default is text. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_format&lt;/code&gt; 은 사용할 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 형식을 선택합니다 . 허용되는 값은 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;xml&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;yaml&lt;/code&gt; 입니다. 기본값은 텍스트입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daad34636b28679e85c4d16cbf6797af1cf1912c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_level&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_level&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ac289ad5d1d2d7c4717a6375a5b37eac4db407f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_level&lt;/code&gt; selects the log level at which auto_explain will log the query plan. Valid values are &lt;code&gt;DEBUG5&lt;/code&gt;, &lt;code&gt;DEBUG4&lt;/code&gt;, &lt;code&gt;DEBUG3&lt;/code&gt;, &lt;code&gt;DEBUG2&lt;/code&gt;, &lt;code&gt;DEBUG1&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;NOTICE&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt;, and &lt;code&gt;LOG&lt;/code&gt;. The default is &lt;code&gt;LOG&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_level&lt;/code&gt; 은 auto_explain이 쿼리 계획을 기록 할 로그 수준을 선택합니다. 유효한 값은 &lt;code&gt;DEBUG5&lt;/code&gt; , &lt;code&gt;DEBUG4&lt;/code&gt; , &lt;code&gt;DEBUG3&lt;/code&gt; , &lt;code&gt;DEBUG2&lt;/code&gt; , &lt;code&gt;DEBUG1&lt;/code&gt; , &lt;code&gt;INFO&lt;/code&gt; , &lt;code&gt;NOTICE&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; 및 &lt;code&gt;LOG&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;LOG&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="142179f1a4c1675c06cee774f4b2157fe8d444b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="25177f9912542038951c826afddf1bbe8000c725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; is the minimum statement execution time, in milliseconds, that will cause the statement's plan to be logged. Setting this to &lt;code&gt;0&lt;/code&gt; logs all plans. &lt;code&gt;-1&lt;/code&gt; (the default) disables logging of plans. For example, if you set it to &lt;code&gt;250ms&lt;/code&gt; then all statements that run 250ms or longer will be logged. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; 은 명령문의 계획이 로그되는 최소 명령문 실행 시간 (밀리 초)입니다. 이것을 &lt;code&gt;0&lt;/code&gt; 으로 설정하면 모든 계획 이 기록됩니다. &lt;code&gt;-1&lt;/code&gt; (기본값)은 계획 로깅을 비활성화합니다. 예를 들어, &lt;code&gt;250ms&lt;/code&gt; 로 설정하면 250ms 이상을 실행하는 모든 명령문이 기록됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06599ea7fae0868ee0187df4416e407838568269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_nested_statements&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_nested_statements&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b632691720445df2b0698decb2277b1fa222cab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_nested_statements&lt;/code&gt; causes nested statements (statements executed inside a function) to be considered for logging. When it is off, only top-level query plans are logged. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_nested_statements&lt;/code&gt; 는 중첩 명령문 (함수 내에서 실행 된 명령문)이 로깅을 고려하도록합니다. 해제되어 있으면 최상위 쿼리 계획 만 기록됩니다. 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aebb373819fbaa18e37a83d142b3786e5547e49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_settings&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_settings&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="946a08b3f3c712df51a41c2f3d69191b73e83708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_settings&lt;/code&gt; controls whether information about modified configuration options are printed when execution plan is logged. Only options affecting query planning with value different from the built-in default value are included in the output. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_settings&lt;/code&gt; 는 실행 계획이 기록 될 때 수정 된 구성 옵션에 대한 정보를 인쇄할지 여부를 제어합니다. 기본 제공 기본값과 다른 값으로 쿼리 계획에 영향을주는 옵션 만 출력에 포함됩니다. 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38088edfea90d6ff4883aaea9f7e359be8969da8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_timing&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_timing&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6c79bfc5856b2232f8a7990eb44faa9503aaaa82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_timing&lt;/code&gt; controls whether per-node timing information is printed when an execution plan is logged; it's equivalent to the &lt;code&gt;TIMING&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;. The overhead of repeatedly reading the system clock can slow down queries significantly on some systems, so it may be useful to set this parameter to off when only actual row counts, and not exact times, are needed. This parameter has no effect unless &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; is enabled. This parameter is on by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_timing&lt;/code&gt; 은 실행 계획이 로그 될 때 노드 별 타이밍 정보가 인쇄되는지 여부를 제어합니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 의 &lt;code&gt;TIMING&lt;/code&gt; 옵션과 동일합니다 . 시스템 클럭을 반복해서 읽는 오버 헤드로 인해 일부 시스템에서 쿼리 속도가 크게 느려질 수 있으므로 정확한 시간이 아닌 실제 행 개수 만 필요한 경우이 매개 변수를 off로 설정하면 유용 할 수 있습니다. &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; 를 사용 하지 않으면이 매개 변수가 적용되지 않습니다 . 이 매개 변수는 기본적으로 켜져 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0b41061dbc8ee0e73a5ac67aab0741c1ec920a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_triggers&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_triggers&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c7319e00e576c6af61b088d4b047a839648b930c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_triggers&lt;/code&gt; causes trigger execution statistics to be included when an execution plan is logged. This parameter has no effect unless &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; is enabled. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_triggers&lt;/code&gt; 는 실행 계획이 로깅 될 때 트리거 실행 통계가 포함되도록합니다. &lt;code&gt;auto_explain.log_analyze&lt;/code&gt; 를 사용 하지 않으면이 매개 변수가 적용되지 않습니다 . 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35dda9ba4ad0eb2207779945df4cd29fee410e45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_verbose&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.log_verbose&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7f743e528d4383a617a49a1c1a5dab08af781de2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.log_verbose&lt;/code&gt; controls whether verbose details are printed when an execution plan is logged; it's equivalent to the &lt;code&gt;VERBOSE&lt;/code&gt; option of &lt;code&gt;EXPLAIN&lt;/code&gt;. This parameter is off by default. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.log_verbose&lt;/code&gt; 는 실행 계획이 기록 될 때 자세한 정보가 인쇄되는지 여부를 제어합니다. &lt;code&gt;EXPLAIN&lt;/code&gt; 의 &lt;code&gt;VERBOSE&lt;/code&gt; 옵션과 동일합니다 . 이 매개 변수는 기본적으로 해제되어 있습니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b0d7023ac089772432b50475251b3c38824ea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.sample_rate&lt;/code&gt; (&lt;code&gt;real&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;auto_explain.sample_rate&lt;/code&gt; ( &lt;code&gt;real&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7c8938cc8c0974177ff37219009beb6725e680dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_explain.sample_rate&lt;/code&gt; causes auto_explain to only explain a fraction of the statements in each session. The default is 1, meaning explain all the queries. In case of nested statements, either all will be explained or none. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;auto_explain.sample_rate&lt;/code&gt; 는 auto_explain이 각 세션에서 명령문의 일부만 설명하도록합니다. 기본값은 1이며 모든 쿼리를 설명합니다. 중첩 된 명령문의 경우 모두 설명되거나 생략됩니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96416d25edfeeddea625a7476216332c5777d71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoinc()&lt;/code&gt; is a trigger that stores the next value of a sequence into an integer field. This has some overlap with the built-in &amp;ldquo;serial column&amp;rdquo; feature, but it is not the same: &lt;code&gt;autoinc()&lt;/code&gt; will override attempts to substitute a different field value during inserts, and optionally it can be used to increment the field during updates, too.</source>
          <target state="translated">&lt;code&gt;autoinc()&lt;/code&gt; 는 시퀀스의 다음 값을 정수 필드에 저장하는 트리거입니다. 이것은 내장&amp;ldquo;직렬 열&amp;rdquo;기능과 일부 겹치지 만 동일하지는 &lt;code&gt;autoinc()&lt;/code&gt; . autoinc () 는 삽입 중에 다른 필드 값을 대체하려는 시도를 무시하고 선택적으로 업데이트 중에 필드를 증가시키는 데 사용할 수 있습니다. 너무.</target>
        </trans-unit>
        <trans-unit id="d0e58733cfcebc12d3746115bee42558f03b7b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dadb0ad8317ba83114a9a999ccee83fc5b8ac347" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_analyze_scale_factor&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_analyze_scale_factor&lt;/code&gt; ( &lt;code&gt;float4&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dd22bf2a90030bc7a32f854f3064ac117a5722db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_analyze_scale_factor&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_analyze_scale_factor&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f7ca608cc79ecdd124467472b99e2963172707ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_analyze_threshold&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_analyze_threshold&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="caa5852d6f0172feccd2a32feab9e9ecc84fd8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_enabled&lt;/code&gt;, &lt;code&gt;toast.autovacuum_enabled&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_enabled&lt;/code&gt; , &lt;code&gt;toast.autovacuum_enabled&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fe330dc8fbc6b29b0548d8834e0a25e54535b243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a50a09d1284ea2db10fdd3a2dcd03c2141bef227" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_freeze_max_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_freeze_max_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9f867a7751939ad4cf4e38e8e6bca93faf25e1eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_freeze_min_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_freeze_min_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6cdaf29181abd954c62b6874f5a5d57d08642756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_freeze_table_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_freeze_table_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_table_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_freeze_table_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9c72cc5562d08044430c9ebf36320aef9236dfa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_max_workers&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_max_workers&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2fe364c555f9fe760954b1f038ee00380934cacf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9f3aa77e9f636f37c1569aac52b9c32d0d6ea551" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_multixact_freeze_max_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_multixact_freeze_max_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d7974de50ee8d9fd7b483a4d6cdf7b4365d3dbcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_multixact_freeze_min_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_multixact_freeze_min_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="69f261d06b2c11fb5da380d8e64bfdf0a3f81dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_multixact_freeze_table_age&lt;/code&gt;, &lt;code&gt;toast.autovacuum_multixact_freeze_table_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_multixact_freeze_table_age&lt;/code&gt; , &lt;code&gt;toast.autovacuum_multixact_freeze_table_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="446da8ef6226bb3cd7a19e15c4a304af9fe45289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_naptime&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_naptime&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="297ae6bf348a56f903b17a8c242da5415f095c1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="439c16b46b66e7d3b5a6141c68a80fd47fc162b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt;, &lt;code&gt;toast.autovacuum_vacuum_cost_delay&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; , &lt;code&gt;toast.autovacuum_vacuum_cost_delay&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ef998dc63ae2d5fc8768532ebb05a80dae8598d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8e36c2a126e9852338cd0ae94ad43735738c703b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt;, &lt;code&gt;toast.autovacuum_vacuum_cost_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; , &lt;code&gt;toast.autovacuum_vacuum_cost_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4ca509ace7b44facbfcbfe68f2478c9624aa61aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_scale_factor&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_scale_factor&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5e88b65acf4752ebd7952b1d4607f086e72dac9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_scale_factor&lt;/code&gt;, &lt;code&gt;toast.autovacuum_vacuum_scale_factor&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_scale_factor&lt;/code&gt; , &lt;code&gt;toast.autovacuum_vacuum_scale_factor&lt;/code&gt; ( &lt;code&gt;float4&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="55dd623d3d401d2b75b0a63a56dc92b829fdcfa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0981ff014f0c39e0a0123824ab3d71dd7023243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt;, &lt;code&gt;toast.autovacuum_vacuum_threshold&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_vacuum_threshold&lt;/code&gt; , &lt;code&gt;toast.autovacuum_vacuum_threshold&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5b19ad94f8ac63b3a5c9f2db61249eff910208fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autovacuum_work_mem&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;autovacuum_work_mem&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="832f208e1fe56a0e3072c31b006fbbc1919e3476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; = infix (&amp;ldquo;both&amp;rdquo;), &lt;code&gt;l&lt;/code&gt; = prefix (&amp;ldquo;left&amp;rdquo;), &lt;code&gt;r&lt;/code&gt; = postfix (&amp;ldquo;right&amp;rdquo;)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; = 접두사 (&amp;ldquo;둘 다&amp;rdquo;), &lt;code&gt;l&lt;/code&gt; = 접두사 (&amp;ldquo;왼쪽&amp;rdquo;), &lt;code&gt;r&lt;/code&gt; = 접두사 (&amp;ldquo;오른쪽&amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="7b58dbbb3f05bac6eed4ac4a6e771f37ed9a9fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backend_flush_after&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;backend_flush_after&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8470a0469f952ad8256d9641294f09446ffc626f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backslash_quote&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;backslash_quote&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b484cabf1eca7474233d0db299ce85c23790b276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backup&lt;/code&gt;: This WAL sender is sending a backup.</source>
          <target state="translated">&lt;code&gt;backup&lt;/code&gt; :이 WAL 발신자가 백업을 보내고 있습니다.</target>
        </trans-unit>
        <trans-unit id="df58ada35791361427d5a120be9f3d1310724333" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beta1&lt;/code&gt; in the context &lt;code&gt;postgresql-beta1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;beta1&lt;/code&gt; 컨텍스트에서 &lt;code&gt;postgresql-beta1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ce2ad3f3eaf3e21cb34b97f06aed64fb9ee72e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bf&lt;/code&gt; &amp;mdash; Blowfish</source>
          <target state="translated">&lt;code&gt;bf&lt;/code&gt; &amp;mdash; 복어</target>
        </trans-unit>
        <trans-unit id="98851a35aba684197cc1af65c983f28170d95eed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bgwriter_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bgwriter_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f22a842e85a2930479cfbbb2f5fc47693e172cb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bgwriter_flush_after&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bgwriter_flush_after&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b89e22542c99395482ec6333e50617b6566090c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b78a48f8ca885db4452ea4dc92b91aea7bab742d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8b976ae4bbe48727a68d6a4a780bd141b3997d1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; for &lt;code&gt;smallint&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; arguments, &lt;code&gt;numeric&lt;/code&gt; for &lt;code&gt;bigint&lt;/code&gt; arguments, otherwise the same as the argument data type</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; 위한 &lt;code&gt;smallint&lt;/code&gt; 또는 &lt;code&gt;int&lt;/code&gt; 인수 &lt;code&gt;numeric&lt;/code&gt; 위한 &lt;code&gt;bigint&lt;/code&gt; 인수 데이터 유형과 달리 동일한 인수</target>
        </trans-unit>
        <trans-unit id="37771ef10b2784d99304957cf3e0d75b239628ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bit&lt;/code&gt; type data must match the length &lt;code&gt;n&lt;/code&gt; exactly; it is an error to attempt to store shorter or longer bit strings. &lt;code&gt;bit varying&lt;/code&gt; data is of variable length up to the maximum length &lt;code&gt;n&lt;/code&gt;; longer strings will be rejected. Writing &lt;code&gt;bit&lt;/code&gt; without a length is equivalent to &lt;code&gt;bit(1)&lt;/code&gt;, while &lt;code&gt;bit varying&lt;/code&gt; without a length specification means unlimited length.</source>
          <target state="translated">&lt;code&gt;bit&lt;/code&gt; 유형 데이터는 길이 &lt;code&gt;n&lt;/code&gt; 과 정확히 일치해야합니다 . 더 짧거나 더 긴 비트 문자열을 저장하려고하면 오류가 발생합니다. &lt;code&gt;bit varying&lt;/code&gt; 데이터는 최대 길이 &lt;code&gt;n&lt;/code&gt; 까지 가변 길이 이고 ; 더 긴 문자열은 거부됩니다. 길이가없는 &lt;code&gt;bit&lt;/code&gt; 를 쓰는 것은 &lt;code&gt;bit(1)&lt;/code&gt; 과 동일하지만 길이 지정이없는 &lt;code&gt;bit varying&lt;/code&gt; 는 무제한 길이를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3e980ec53e76c9a58a51bc4cf151fc58e821608a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;block_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;block_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f9e2cbe094d03d37d71c2289dbd89ba3110a641a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bloom&lt;/code&gt; access method doesn't support &lt;code&gt;UNIQUE&lt;/code&gt; indexes.</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; 액세스 방법은 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1b1844f91bf9ef4bcfed26c35dda4b12b22932" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bloom&lt;/code&gt; access method doesn't support searching for &lt;code&gt;NULL&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; 액세스 방법은 &lt;code&gt;NULL&lt;/code&gt; 값 검색을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4224fa7a6abab2670249415b7c5ae343048793b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bloom&lt;/code&gt; provides an index access method based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;Bloom filters&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;Bloom 필터를&lt;/a&gt; 기반으로하는 인덱스 액세스 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="10e345bba46d160d2fc0a436cfcb9ae6ccd9b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bonjour&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bonjour&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6c84115bcca462310b12b1d94eb4b2720a4c1fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bonjour_name&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bonjour_name&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7fa79c530d81d7724234a40cee1088d5262c6975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32false&quot;&gt;IS FALSE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 이 &lt;code id=&quot;is32false&quot;&gt;IS FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88ab3251ee1678bc8765c6e496202e3212b15f73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32not32false&quot;&gt;IS NOT FALSE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 이 &lt;code id=&quot;is32not32false&quot;&gt;IS NOT FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69e87095585301206dd2c94448c6a27c7caa732c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32not32true&quot;&gt;IS NOT TRUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 이 &lt;code id=&quot;is32not32true&quot;&gt;IS NOT TRUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76e2933cfad0b5b43dfe5bddd22d208ebe4b7768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32not32unknown&quot;&gt;IS NOT UNKNOWN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 이 &lt;code id=&quot;is32not32unknown&quot;&gt;IS NOT UNKNOWN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd0d1c65aabd8b6da7f24eb1413990465520ebb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32true&quot;&gt;IS TRUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 은 &lt;code id=&quot;is32true&quot;&gt;IS TRUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3805825d6c071101663f804e977b321232306cc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boolean_expression&lt;/code&gt;&lt;code id=&quot;is32unknown&quot;&gt;IS UNKNOWN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;boolean_expression&lt;/code&gt; 은 &lt;code id=&quot;is32unknown&quot;&gt;IS UNKNOWN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="854acd2dc654bb711e270f5e1a15e0be3bf3f58b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;brin_metapage_info&lt;/code&gt; returns assorted information about a BRIN index metapage. For example:</source>
          <target state="translated">&lt;code&gt;brin_metapage_info&lt;/code&gt; 는 BRIN 색인 메타 페이지에 대한 여러 정보를 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d66b7e49654b569426bfcacb1ed8c9189893415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;brin_page_items&lt;/code&gt; returns the data stored in the BRIN data page. For example:</source>
          <target state="translated">&lt;code&gt;brin_page_items&lt;/code&gt; 는 BRIN 데이터 페이지에 저장된 데이터를 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9763fb3151f9796fa9c1366cc1650f5bbd50dd93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;brin_page_type&lt;/code&gt; returns the page type of the given BRIN index page, or throws an error if the page is not a valid BRIN page. For example:</source>
          <target state="translated">&lt;code&gt;brin_page_type&lt;/code&gt; 은 주어진 BRIN 색인 페이지의 페이지 유형을 리턴하거나 페이지가 유효한 BRIN 페이지가 아닌 경우 오류를 발생시킵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c66a876b091cf24e7b3b0da9bcf40e53b04a820" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;brin_revmap_data&lt;/code&gt; returns the list of tuple identifiers in a BRIN index range map page. For example:</source>
          <target state="translated">&lt;code&gt;brin_revmap_data&lt;/code&gt; 는 BRIN 색인 범위 맵 페이지에서 튜플 ID 목록을 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ef20daf8de678ac93323a75859af83bf9b5a590" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;brin_summarize_new_values&lt;/code&gt; accepts the OID or name of a BRIN index and inspects the index to find page ranges in the base table that are not currently summarized by the index; for any such range it creates a new summary index tuple by scanning the table pages. It returns the number of new page range summaries that were inserted into the index. &lt;code&gt;brin_summarize_range&lt;/code&gt; does the same, except it only summarizes the range that covers the given block number.</source>
          <target state="translated">&lt;code&gt;brin_summarize_new_values&lt;/code&gt; 는 BRIN 인덱스의 OID 또는 이름을 승인하고 인덱스를 검사하여 현재 인덱스에 의해 요약되지 않은 기본 테이블에서 페이지 범위를 찾습니다. 이러한 범위에 대해 테이블 ​​페이지를 스캔하여 새 요약 인덱스 튜플을 작성합니다. 색인에 삽입 된 새 페이지 범위 요약 수를 리턴합니다. &lt;code&gt;brin_summarize_range&lt;/code&gt; 는 주어진 블록 번호를 포괄하는 범위 만 요약한다는 점을 제외하고 동일하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6d700db4f310fd0f528a26d410b97a72cf7fffe5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_index_check&lt;/code&gt; acquires an &lt;code&gt;AccessShareLock&lt;/code&gt; on the target index and the heap relation it belongs to. This lock mode is the same lock mode acquired on relations by simple &lt;code&gt;SELECT&lt;/code&gt; statements. &lt;code&gt;bt_index_check&lt;/code&gt; does not verify invariants that span child/parent relationships, but will verify the presence of all heap tuples as index tuples within the index when &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;. When a routine, lightweight test for corruption is required in a live production environment, using &lt;code&gt;bt_index_check&lt;/code&gt; often provides the best trade-off between thoroughness of verification and limiting the impact on application performance and availability.</source>
          <target state="translated">&lt;code&gt;bt_index_check&lt;/code&gt; 는 대상 인덱스와 이에 속하는 힙 관계 에서 &lt;code&gt;AccessShareLock&lt;/code&gt; 을 획득합니다 . 이 잠금 모드는 간단한 &lt;code&gt;SELECT&lt;/code&gt; 문 으로 관계에서 획득 한 것과 동일한 잠금 모드 입니다. &lt;code&gt;bt_index_check&lt;/code&gt; 는 자식 / 부모 관계에 걸쳐있는 불변을 확인하지 않지만 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;true&lt;/code&gt; 일 때 인덱스 내에 튜플로 모든 힙 튜플이 있는지 확인 합니다 . 실제 프로덕션 환경에서 일상적인 가벼운 손상 테스트가 필요한 경우 &lt;code&gt;bt_index_check&lt;/code&gt; 를 사용 하면 검증의 철저 함과 응용 프로그램 성능 및 가용성에 대한 영향을 제한하는 것 사이에서 최상의 절충점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3073b5c6d0050feb8f3b2d622ac5b7b4c95ae56c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_index_check&lt;/code&gt; tests that its target, a B-Tree index, respects a variety of invariants. Example usage:</source>
          <target state="translated">&lt;code&gt;bt_index_check&lt;/code&gt; 는 목표 인 B- 트리 인덱스가 다양한 불변량을 존중 하는지 테스트합니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="ee34681a7f211bff0bbbdddf2f2e1f148e04d73d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_index_parent_check&lt;/code&gt; tests that its target, a B-Tree index, respects a variety of invariants. Optionally, when the &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; argument is &lt;code&gt;true&lt;/code&gt;, the function verifies the presence of all heap tuples that should be found within the index, and that there are no missing downlinks in the index structure. When the optional &lt;em&gt;&lt;code&gt;rootdescend&lt;/code&gt;&lt;/em&gt; argument is &lt;code&gt;true&lt;/code&gt;, verification re-finds tuples on the leaf level by performing a new search from the root page for each tuple. The checks that can be performed by &lt;code&gt;bt_index_parent_check&lt;/code&gt; are a superset of the checks that can be performed by &lt;code&gt;bt_index_check&lt;/code&gt;. &lt;code&gt;bt_index_parent_check&lt;/code&gt; can be thought of as a more thorough variant of &lt;code&gt;bt_index_check&lt;/code&gt;: unlike &lt;code&gt;bt_index_check&lt;/code&gt;, &lt;code&gt;bt_index_parent_check&lt;/code&gt; also checks invariants that span parent/child relationships. &lt;code&gt;bt_index_parent_check&lt;/code&gt; follows the general convention of raising an error if it finds a logical inconsistency or other problem.</source>
          <target state="translated">&lt;code&gt;bt_index_parent_check&lt;/code&gt; 는 목표 인 B- 트리 인덱스가 다양한 불변량을 존중 하는지 테스트합니다. 선택적으로 &lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우, 함수는 인덱스 내에서 찾아야하는 모든 힙 튜플의 존재를 확인하고 인덱스 구조에 누락 된 다운 링크가 없는지 확인합니다. 선택적 &lt;em&gt; &lt;code&gt;rootdescend&lt;/code&gt; &lt;/em&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 , 검증은 각 튜플의 루트 페이지에서 새로운 검색을 수행하여 리프 레벨에서 튜플을 다시 찾습니다. 수행 될 수있는 검사 &lt;code&gt;bt_index_parent_check&lt;/code&gt; 을 수행 할 수있는 수표의 수퍼 &lt;code&gt;bt_index_check&lt;/code&gt; . &lt;code&gt;bt_index_parent_check&lt;/code&gt; 더욱 철저한 변형으로 간주 할 수 있습니다 &lt;code&gt;bt_index_check&lt;/code&gt; 달리 : &lt;code&gt;bt_index_check&lt;/code&gt; , &lt;code&gt;bt_index_parent_check&lt;/code&gt; 그 범위의 상위 / 하위 관계도 확인 불변입니다. &lt;code&gt;bt_index_parent_check&lt;/code&gt; 는 논리적 불일치 또는 다른 문제가 발견되면 오류를 발생시키는 일반적인 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2a688aef3f03a30311b961d71a407b2d2beb7628" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_index_parent_check&lt;/code&gt;'s additional verification is more likely to detect various pathological cases. These cases may involve an incorrectly implemented B-Tree operator class used by the index that is checked, or, hypothetically, undiscovered bugs in the underlying B-Tree index access method code. Note that &lt;code&gt;bt_index_parent_check&lt;/code&gt; cannot be used when Hot Standby mode is enabled (i.e., on read-only physical replicas), unlike &lt;code&gt;bt_index_check&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bt_index_parent_check&lt;/code&gt; 의 추가 검증은 다양한 병리학 적 사례를 탐지 할 가능성이 높습니다. 이러한 경우 검사 된 색인에서 사용 된 B-Tree 연산자 클래스가 잘못 구현되었거나 기본 B-Tree 색인 액세스 방법 코드에서 발견되지 않은 버그가 발생할 수 있습니다. 참고 &lt;code&gt;bt_index_parent_check&lt;/code&gt; 가 상시 대기 모드가 활성화 된 경우 사용할 수 없습니다 (즉, 읽기 전용 물리적 복제본), 달리 &lt;code&gt;bt_index_check&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8172e2e08de4c6ade214b5ea7af4490404fc37c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_metap&lt;/code&gt; returns information about a B-tree index's metapage. For example:</source>
          <target state="translated">&lt;code&gt;bt_metap&lt;/code&gt; 은 B- 트리 인덱스의 메타 페이지에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1bb232a18950e74280cdae551a493c34a825aed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_page_items&lt;/code&gt; returns detailed information about all of the items on a B-tree index page. For example:</source>
          <target state="translated">&lt;code&gt;bt_page_items&lt;/code&gt; 는 B- 트리 인덱스 페이지의 모든 항목에 대한 자세한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07d473f9416583d2fffa8ef019c864278def2c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bt_page_stats&lt;/code&gt; returns summary information about single pages of B-tree indexes. For example:</source>
          <target state="translated">&lt;code&gt;bt_page_stats&lt;/code&gt; 는 B- 트리 인덱스의 단일 페이지에 대한 요약 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8eeacc05e8fd9e0d5dc8302233ac102b155be8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;btree_gin&lt;/code&gt; provides sample GIN operator classes that implement B-tree equivalent behavior for the data types &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time with time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;money&lt;/code&gt;, &lt;code&gt;&quot;char&quot;&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;bytea&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;varbit&lt;/code&gt;, &lt;code&gt;macaddr&lt;/code&gt;, &lt;code&gt;macaddr8&lt;/code&gt;, &lt;code&gt;inet&lt;/code&gt;, &lt;code&gt;cidr&lt;/code&gt;, &lt;code&gt;uuid&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;bpchar&lt;/code&gt;, and all &lt;code&gt;enum&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;btree_gin&lt;/code&gt; 은 데이터 유형 &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; , &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 &lt;code&gt;timestamp without time zone&lt;/code&gt; , 시간대가 없는 타임 스탬프 , &lt;code&gt;time with time zone&lt;/code&gt; , &lt;code&gt;time without time zone&lt;/code&gt; , 시간대가없는 시간 , &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;interval&lt;/code&gt; 대해 B- 트리 동등한 동작을 구현하는 샘플 GIN 연산자 클래스를 제공 합니다. , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;money&lt;/code&gt; , &lt;code&gt;&quot;char&quot;&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;bytea&lt;/code&gt; , &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;varbit&lt;/code&gt; , &lt;code&gt;macaddr&lt;/code&gt; , &lt;code&gt;macaddr8&lt;/code&gt; , &lt;code&gt;inet&lt;/code&gt; , &lt;code&gt;cidr&lt;/code&gt; , &lt;code&gt;uuid&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;bpchar&lt;/code&gt; 및 모든 &lt;code&gt;enum&lt;/code&gt; 형.</target>
        </trans-unit>
        <trans-unit id="fb912f8d74a266b155eee4dd2a337d5c55762543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;btree_gist&lt;/code&gt; provides GiST index operator classes that implement B-tree equivalent behavior for the data types &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time with time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;money&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;bytea&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;varbit&lt;/code&gt;, &lt;code&gt;macaddr&lt;/code&gt;, &lt;code&gt;macaddr8&lt;/code&gt;, &lt;code&gt;inet&lt;/code&gt;, &lt;code&gt;cidr&lt;/code&gt;, &lt;code&gt;uuid&lt;/code&gt;, and all &lt;code&gt;enum&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;btree_gist&lt;/code&gt; 는 데이터 유형 &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float4&lt;/code&gt; , &lt;code&gt;float8&lt;/code&gt; , &lt;code&gt;numeric&lt;/code&gt; , &lt;code&gt;timestamp with time zone&lt;/code&gt; 가있는 &lt;code&gt;timestamp without time zone&lt;/code&gt; , 시간대가 없는 타임 스탬프 , &lt;code&gt;time with time zone&lt;/code&gt; , &lt;code&gt;time without time zone&lt;/code&gt; , &lt;code&gt;date&lt;/code&gt; B- 트리 동등한 동작을 구현하는 GiST 인덱스 연산자 클래스를 제공 합니다. , &lt;code&gt;interval&lt;/code&gt; , &lt;code&gt;oid&lt;/code&gt; , &lt;code&gt;money&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;varchar&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;bytea&lt;/code&gt; , &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;varbit&lt;/code&gt; , &lt;code&gt;macaddr&lt;/code&gt; , &lt;code&gt;macaddr8&lt;/code&gt; , &lt;code&gt;inet&lt;/code&gt; , &lt;code&gt;cidr&lt;/code&gt; , &lt;code&gt;uuid&lt;/code&gt; 및 모든 &lt;code&gt;enum&lt;/code&gt; 형.</target>
        </trans-unit>
        <trans-unit id="7d4ab38621d4db61f1ac1f63e70bdc0259ea32ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytea_output&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bytea_output&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b09d802f6a971699e40541e1f90f924c31f7c3c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; = &lt;code&gt;char&lt;/code&gt; alignment, i.e., no alignment needed.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; = &lt;code&gt;char&lt;/code&gt; 정렬, 즉 정렬이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4cce9205064c88403bcd3b95b4459a33e224ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; = check constraint, &lt;code&gt;f&lt;/code&gt; = foreign key constraint, &lt;code&gt;p&lt;/code&gt; = primary key constraint, &lt;code&gt;u&lt;/code&gt; = unique constraint, &lt;code&gt;t&lt;/code&gt; = constraint trigger, &lt;code&gt;x&lt;/code&gt; = exclusion constraint</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; = 점검 제한 조건, &lt;code&gt;f&lt;/code&gt; = 외래 키 제약 조건, &lt;code&gt;p&lt;/code&gt; = 기본 키 제약 조건, &lt;code&gt;u&lt;/code&gt; = 고유 제약 조건, &lt;code&gt;t&lt;/code&gt; = 제약 조건 트리거, &lt;code&gt;x&lt;/code&gt; = 제외 제약 조건</target>
        </trans-unit>
        <trans-unit id="eb313d968aebdb1360de9c75ff1567d4b06f1ae9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&lt;code&gt;custom&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt;&lt;code&gt;custom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="118e7fc4764d240a9a44a4c89661dac3fec5a5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call_handler&lt;/code&gt; is the name of a previously registered function that will be called to execute the procedural language's functions. The call handler for a procedural language must be written in a compiled language such as C with version 1 call convention and registered with PostgreSQL as a function taking no arguments and returning the &lt;code&gt;language_handler&lt;/code&gt; type, a placeholder type that is simply used to identify the function as a call handler.</source>
          <target state="translated">&lt;code&gt;call_handler&lt;/code&gt; 는 절차 언어 기능을 실행하기 위해 호출 될 이전에 등록 된 기능의 이름입니다. 절차 언어에 대한 호출 처리기는 버전 1 호출 규칙을 사용하는 C와 같은 컴파일 된 언어로 작성되어야하며 PostgreSQL에 인수를 사용하지 않고 함수 를 식별하는 데 사용되는 자리 표시 자 형식 인 &lt;code&gt;language_handler&lt;/code&gt; 형식을 반환 하는 함수로 등록해야합니다. 콜 핸들러.</target>
        </trans-unit>
        <trans-unit id="98f8f92c6a53661501d60b82237a4abd46a6fa6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cardinality&lt;/code&gt; returns the total number of elements in an array across all dimensions. It is effectively the number of rows a call to &lt;code&gt;unnest&lt;/code&gt; would yield:</source>
          <target state="translated">&lt;code&gt;cardinality&lt;/code&gt; 는 모든 차원에서 배열의 총 요소 수를 반환합니다. 실제로 &lt;code&gt;unnest&lt;/code&gt; 에 대한 호출 이 생성 하는 행 수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="861907c8451cbc7f1e97cb6065f854b1279184ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catchup&lt;/code&gt;: This WAL sender's connected standby is catching up with the primary.</source>
          <target state="translated">&lt;code&gt;catchup&lt;/code&gt; :이 WAL 발신자의 연결된 대기가 기본을 따라 잡고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c577b6838026ced2d618a5de4e1b17e51d1be3a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cbc&lt;/code&gt; &amp;mdash; next block depends on previous (default)</source>
          <target state="translated">&lt;code&gt;cbc&lt;/code&gt; &amp;mdash; 다음 블록은 이전에 따라 다릅니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="afadc621abdf88efd1a135ef673cf0d9550882f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17&lt;/code&gt; plus room for other applications</source>
          <target state="translated">&lt;code&gt;ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17&lt;/code&gt; + 다른 응용 프로그램을위한 공간</target>
        </trans-unit>
        <trans-unit id="a6aee96a88eb265b7ca78c741276c679fe292528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_foreign_key()&lt;/code&gt; checks the referenced table. To use, create a &lt;code&gt;BEFORE DELETE OR UPDATE&lt;/code&gt; trigger using this function on a table referenced by other table(s). Specify as the trigger arguments: the number of referencing tables for which the function has to perform checking, the action if a referencing key is found (&lt;code&gt;cascade&lt;/code&gt; &amp;mdash; to delete the referencing row, &lt;code&gt;restrict&lt;/code&gt; &amp;mdash; to abort transaction if referencing keys exist, &lt;code&gt;setnull&lt;/code&gt; &amp;mdash; to set referencing key fields to null), the triggered table's column names which form the primary/unique key, then the referencing table name and column names (repeated for as many referencing tables as were specified by first argument). Note that the primary/unique key columns should be marked NOT NULL and should have a unique index.</source>
          <target state="translated">&lt;code&gt;check_foreign_key()&lt;/code&gt; 는 참조 된 테이블을 확인합니다. 사용하려면 다른 테이블에서 참조하는 테이블에서이 함수를 사용하여 &lt;code&gt;BEFORE DELETE OR UPDATE&lt;/code&gt; 트리거를 작성하십시오. 함수가 점검을 수행 &lt;code&gt;setnull&lt;/code&gt; 참조 테이블의 수, 참조 키가있는 경우의 조치 ( &lt;code&gt;cascade&lt;/code&gt; -참조 행 삭제, &lt;code&gt;restrict&lt;/code&gt; -참조 키가있는 경우 트랜잭션 중단, setnull) : 트리거 인수로 지정하십시오.&amp;mdash; 참조 키 필드를 null로 설정), 기본 / 고유 키를 형성하는 트리거 된 테이블의 열 이름, 참조 테이블 이름 및 열 이름 (첫 번째 인수에 지정된 수의 참조 테이블에 대해 반복됨). 기본 / 고유 키 열은 NOT NULL로 표시되어야하며 고유 인덱스가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="18734426d17a48e984495edcefe96762f1ef9055" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_function_bodies&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;check_function_bodies&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="24d080b6ada0fac195449d6e350a2ea2e6d86a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_option&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;check_option&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="af8b20152919ae3e5949ad1da6467a4f1744e42d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_primary_key()&lt;/code&gt; and &lt;code&gt;check_foreign_key()&lt;/code&gt; are used to check foreign key constraints. (This functionality is long since superseded by the built-in foreign key mechanism, of course, but the module is still useful as an example.)</source>
          <target state="translated">&lt;code&gt;check_primary_key()&lt;/code&gt; 및 &lt;code&gt;check_foreign_key()&lt;/code&gt; 는 외래 키 제약 조건을 확인하는 데 사용됩니다. (물론이 기능은 내장 외래 키 메커니즘으로 대체 된 지 오래되었지만 모듈은 여전히 ​​예로서 유용합니다.)</target>
        </trans-unit>
        <trans-unit id="36619b5a0396d046f4ddc93f61d9c4a9740d6157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_primary_key()&lt;/code&gt; checks the referencing table. To use, create a &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt; trigger using this function on a table referencing another table. Specify as the trigger arguments: the referencing table's column name(s) which form the foreign key, the referenced table name, and the column names in the referenced table which form the primary/unique key. To handle multiple foreign keys, create a trigger for each reference.</source>
          <target state="translated">&lt;code&gt;check_primary_key()&lt;/code&gt; 는 참조 테이블을 확인합니다. 사용하려면 다른 테이블을 참조하는 테이블에서이 함수를 사용하여 &lt;code&gt;BEFORE INSERT OR UPDATE&lt;/code&gt; 트리거를 작성 하십시오. 트리거 인수로 외래 키를 구성하는 참조 테이블의 열 이름, 참조 테이블 이름 및 기본 / 고유 키를 형성하는 참조 테이블의 열 이름을 트리거 인수로 지정하십시오. 여러 외래 키를 처리하려면 각 참조에 대한 트리거를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="00cadf215981f3416e447dc0503a8330a677e405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;checkpoint_completion_target&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;checkpoint_completion_target&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9180ce38e1168181204edce063810818220b18d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;checkpoint_flush_after&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;checkpoint_flush_after&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="15254516a016254c77b7f791550ae32885e5890a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;checkpoint_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;checkpoint_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6a0408da200f13e84ad0719e7a5ff086e022a1db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;checkpoint_warning&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;checkpoint_warning&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fbfd2e02df6063c924d72a696d3a8ff4add07dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cidr&lt;/code&gt; Input</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 입력</target>
        </trans-unit>
        <trans-unit id="a79893c21d873f2caa88b44807a45e98e17f42bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cidr&lt;/code&gt; Output</source>
          <target state="translated">&lt;code&gt;cidr&lt;/code&gt; 출력</target>
        </trans-unit>
        <trans-unit id="cb7dfc6e68db3be84b32d47fc3d1c3e339d59701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;citext&lt;/code&gt; doesn't help much if you need data to compare case-sensitively in some contexts and case-insensitively in other contexts. The standard answer is to use the &lt;code&gt;text&lt;/code&gt; type and manually use the &lt;code&gt;lower&lt;/code&gt; function when you need to compare case-insensitively; this works all right if case-insensitive comparison is needed only infrequently. If you need case-insensitive behavior most of the time and case-sensitive infrequently, consider storing the data as &lt;code&gt;citext&lt;/code&gt; and explicitly casting the column to &lt;code&gt;text&lt;/code&gt; when you want case-sensitive comparison. In either situation, you will need two indexes if you want both types of searches to be fast.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 는 일부 상황에서는 대소 문자를 구분하고 다른 상황에서는 대소 문자를 구분하지 않는 데이터가 필요한 경우 크게 도움이되지 않습니다. 표준 답변은 &lt;code&gt;text&lt;/code&gt; 유형 을 사용하고 대소 문자를 구분하지 않고 비교할 때 수동으로 &lt;code&gt;lower&lt;/code&gt; 기능을 사용하는 것입니다 . 대소 문자를 구분하지 않는 비교가 드물게 필요한 경우에 올바르게 작동합니다. 대소 문자를 구분하지 않는 경우가 많고 대소 문자를 구분하지 않는 경우가 &lt;code&gt;citext&lt;/code&gt; 대소 &lt;code&gt;text&lt;/code&gt; 를 구분할 때 데이터를 citext 로 저장 하고 열을 텍스트로 명시 적으로 캐스팅하는 것이 좋습니다. 두 경우 모두 빠른 검색을 원하면 두 개의 인덱스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e23f575a4cd4b19d77a19f71d54cef1fd6ae266f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;citext&lt;/code&gt; is not as efficient as &lt;code&gt;text&lt;/code&gt; because the operator functions and the B-tree comparison functions must make copies of the data and convert it to lower case for comparisons. It is, however, slightly more efficient than using &lt;code&gt;lower&lt;/code&gt; to get case-insensitive matching.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 연산자 함수와 B- 트리 비교 함수는 비교를 위해 데이터를 복사하여 소문자로 변환해야하기 때문에 citext 는 &lt;code&gt;text&lt;/code&gt; 만큼 효율적이지 않습니다 . 그러나 대소 문자를 구분하지 않는 매칭을 위해 &lt;code&gt;lower&lt;/code&gt; 를 사용하는 것보다 약간 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="4e11d9b93d984a515addd0f09bbd8a4472a5180a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;citext&lt;/code&gt; performs comparisons by converting each string to lower case (as though &lt;code&gt;lower&lt;/code&gt; were called) and then comparing the results normally. Thus, for example, two strings are considered equal if &lt;code&gt;lower&lt;/code&gt; would produce identical results for them.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 는 각 문자열을 소문자 ( &lt;code&gt;lower&lt;/code&gt; 가 호출 된 것처럼)로 변환 한 다음 결과를 정상적으로 비교하여 비교를 수행합니다. 따라서, 예를 들어, 2 개의 현이 &lt;code&gt;lower&lt;/code&gt; 동일한 결과가 나오면 동일한 것으로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="52feb2b8fa6a452bd033a275952455de6b3fa848" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;citext&lt;/code&gt;'s case-folding behavior depends on the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting of your database. How it compares values is therefore determined when the database is created. It is not truly case-insensitive in the terms defined by the Unicode standard. Effectively, what this means is that, as long as you're happy with your collation, you should be happy with &lt;code&gt;citext&lt;/code&gt;'s comparisons. But if you have data in different languages stored in your database, users of one language may find their query results are not as expected if the collation is for another language.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 의 대소 문자 구분 동작은 데이터베이스 의 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정에 따라 다릅니다 . 따라서 값을 비교하는 방법은 데이터베이스를 만들 때 결정됩니다. 유니 코드 표준에 의해 정의 된 용어에서는 대소 문자를 구분하지 않습니다. 효과적으로, 이것이 의미하는 것은 데이터 정렬에 만족하는 한 &lt;code&gt;citext&lt;/code&gt; 비교에 만족해야한다는 것 입니다. 그러나 데이터베이스에 다른 언어로 된 데이터가 저장된 경우 한 언어의 사용자가 데이터 정렬이 다른 언어에 대한 쿼리 인 경우 쿼리 결과가 예상과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c97e862d6146b5373a42e79a8bc18e1dccd1ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_encoding&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;client_encoding&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="96e089970021664fb50bc81577939f9e25ae525b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_encoding&lt;/code&gt; (this is automatically set from the local server encoding)</source>
          <target state="translated">&lt;code&gt;client_encoding&lt;/code&gt; (로컬 서버 인코딩에서 자동으로 설정 됨)</target>
        </trans-unit>
        <trans-unit id="71fa78b433ed2d3809b2304e3e3287dfe074a0eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_min_messages&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;client_min_messages&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="443a300b0f16a7b7e874c8fe71ecacaddb180a39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_name&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;cluster_name&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8ad65bc83503c8ef84e757ae9da4830f2878588b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clusterdb&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [ &lt;code&gt;--verbose&lt;/code&gt; | &lt;code&gt;-v&lt;/code&gt; ] &lt;code&gt;--all&lt;/code&gt; | &lt;code&gt;-a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;clusterdb&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;--verbose&lt;/code&gt; | &lt;code&gt;-v&lt;/code&gt; ] &lt;code&gt;--all&lt;/code&gt; | &lt;code&gt;-a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9809ca1fbdb31ed739362deb05b359a48da5921b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clusterdb&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [ &lt;code&gt;--verbose&lt;/code&gt; | &lt;code&gt;-v&lt;/code&gt; ] [ &lt;code&gt;--table&lt;/code&gt; | &lt;code&gt;-t&lt;/code&gt;&lt;code&gt;table&lt;/code&gt; ] ... [&lt;code&gt;dbname&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;clusterdb&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;--verbose&lt;/code&gt; | &lt;code&gt;-v&lt;/code&gt; ] [ &lt;code&gt;--table&lt;/code&gt; | &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;table&lt;/code&gt; ] ... [ &lt;code&gt;dbname&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="8093589d33528b3f04006c92c2af4e2024c514e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;col_description&lt;/code&gt; returns the comment for a table column, which is specified by the OID of its table and its column number. (&lt;code&gt;obj_description&lt;/code&gt; cannot be used for table columns since columns do not have OIDs of their own.)</source>
          <target state="translated">&lt;code&gt;col_description&lt;/code&gt; 은 테이블의 OID와 해당 열 번호로 지정된 테이블 열에 대한 주석을 리턴합니다. ( &lt;code&gt;obj_description&lt;/code&gt; 는 열이 자신의 OID를을 가지고 있지 않기 때문에 테이블 열을 사용할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="101afa5c5a3783cf320b560f051c4a4217818915" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; and each &lt;code&gt;argument&lt;/code&gt; can be either a text constant or a &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt; reference to a variable. If you want to use an &lt;code&gt;argument&lt;/code&gt; starting with a colon, write an additional colon at the beginning of &lt;code&gt;argument&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 각 &lt;code&gt;argument&lt;/code&gt; 문자 상수 또는 일 수있다 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; 변수를 참조. 당신이 사용하려는 경우 &lt;code&gt;argument&lt;/code&gt; 콜론으로 시작을,의 시작 부분에 추가 콜론 쓰기 &lt;code&gt;argument&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca13b88184618151306239551b88bf702887892d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; must be either a command string that is completely parsable by the server (i.e., it contains no psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands within a &lt;code&gt;-c&lt;/code&gt; option. To achieve that, you could use repeated &lt;code&gt;-c&lt;/code&gt; options or pipe the string into psql, for example:</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 는 서버에서 완전히 구문 분석 할 수있는 명령 문자열이거나 (예 : psql 관련 기능이 포함되어 있지 않음) 단일 백 슬래시 명령 이어야합니다. 따라서 &lt;code&gt;-c&lt;/code&gt; 옵션 내에서 SQL 및 psql 메타 명령을 혼합 할 수 없습니다 . 이를 위해 반복 된 &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하거나 문자열을 psql에 파이프 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a800a8fcf9cfac3d11a1c740b2cbe148e88b19da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commit_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="389b572db6f78a41dd3b99d07e2426aa6fd6dd82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commit_siblings&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;commit_siblings&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7efbc78f567442e6eb477be50a02a989fc7f8212" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config_file&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;config_file&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6a1e2edd3876081169f4b75b67102f7deb447399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configuration_parameter&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;configuration_parameter&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66e910a78d645658518d15ce97568e2a2a988684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="978159af1b4888867d8f5ed47da5fb3c2f74ab27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constraint_exclusion&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;constraint_exclusion&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d0435f768aff97ffed0bfad9fa926f4e5f6a950d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_data&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;copy_data&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a3ebfcf45a135ca56dd5f2a673fd26efe7ffef9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;correlation&lt;/code&gt; is the name of a table (possibly qualified with a schema name), or an alias for a table defined by means of a &lt;code&gt;FROM&lt;/code&gt; clause. The correlation name and separating dot can be omitted if the column name is unique across all the tables being used in the current query. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;correlation&lt;/code&gt; 는 테이블 이름 (스키마 이름으로 정규화 될 수 있음) 또는 &lt;code&gt;FROM&lt;/code&gt; 절 을 통해 정의 된 테이블의 별명입니다 . 열 이름이 현재 쿼리에서 사용중인 모든 테이블에서 고유 한 경우 상관 이름과 분리 점을 생략 할 수 있습니다. (또한 &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="65a46d2cd9da813de4812dc5db9a6a0ce7826611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; is a possibly-signed integer constant, determining the location or number of rows to fetch. For &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt; cases, specifying a negative &lt;code&gt;count&lt;/code&gt; is equivalent to changing the sense of &lt;code&gt;FORWARD&lt;/code&gt; and &lt;code&gt;BACKWARD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 는 부호있는 정수 상수이며 가져올 행의 위치 또는 수를 결정합니다. 들면 &lt;code&gt;FORWARD&lt;/code&gt; 및 &lt;code&gt;BACKWARD&lt;/code&gt; 경우, 음의 특정 &lt;code&gt;count&lt;/code&gt; 감 변경 동등 &lt;code&gt;FORWARD&lt;/code&gt; 및 &lt;code&gt;BACKWARD&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3afa553d62686101963c9a4065aac0c52b3dc270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 는 반환 할 최대 행 수를 지정하고 &lt;code&gt;start&lt;/code&gt; 는 행 반환을 시작 하기 전에 건너 뛸 행 수를 지정합니다. 둘 다 지정되면 리턴 될 &lt;code&gt;count&lt;/code&gt; 행 수 를 계산하기 전에 &lt;code&gt;start&lt;/code&gt; 행을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="39a57d4838b578ab0af32baf47affd61b2516894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5ac1a83d31665e15123b770e3623c557a7877299" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cpu_operator_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;cpu_operator_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="38f00d34193637d9ed1b51acc8400ef2fcebfee5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cpu_tuple_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;cpu_tuple_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8fbbeaaf66550b2525e410493e929014dd1963e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_slot&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;create_slot&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74b676df99946e3fab4fee02d295136f036b0875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createdb&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;dbname&lt;/code&gt; [&lt;code&gt;description&lt;/code&gt;]]</source>
          <target state="translated">&lt;code&gt;createdb&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;dbname&lt;/code&gt; [ &lt;code&gt;description&lt;/code&gt; ]]</target>
        </trans-unit>
        <trans-unit id="cd00db21b99be0432967f731fa171a4911ccd364" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createdb&lt;/code&gt; does no magic. It connects to the &lt;code&gt;postgres&lt;/code&gt; database and issues the &lt;code&gt;CREATE DATABASE&lt;/code&gt; command, exactly as described above. The &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; reference page contains the invocation details. Note that &lt;code&gt;createdb&lt;/code&gt; without any arguments will create a database with the current user name.</source>
          <target state="translated">&lt;code&gt;createdb&lt;/code&gt; 는 마술을하지 않습니다. &lt;code&gt;postgres&lt;/code&gt; 데이터베이스에 연결하고 위에서 설명한대로 &lt;code&gt;CREATE DATABASE&lt;/code&gt; 명령을 실행합니다. &lt;a href=&quot;app-createdb&quot;&gt;CREATEDB의&lt;/a&gt; 참조 페이지는 호출 대한 세부 사항이 포함되어 있습니다. 참고 &lt;code&gt;createdb&lt;/code&gt; 현재 사용자 이름으로 데이터베이스를 생성합니다 인수없이.</target>
        </trans-unit>
        <trans-unit id="aa3241e53f7336b199054e43c7a325e5593b8ef2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createuser&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;username&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;createuser&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;username&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="0ba0ce71d19fe2bf799d959975f5e898e3c3ea9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;crypt-bf&lt;/code&gt; numbers are taken using a simple program that loops over 1000 8-character passwords. That way I can show the speed with different numbers of iterations. For reference: &lt;code&gt;john -test&lt;/code&gt; shows 13506 loops/sec for &lt;code&gt;crypt-bf/5&lt;/code&gt;. (The very small difference in results is in accordance with the fact that the &lt;code&gt;crypt-bf&lt;/code&gt; implementation in &lt;code&gt;pgcrypto&lt;/code&gt; is the same one used in John the Ripper.)</source>
          <target state="translated">&lt;code&gt;crypt-bf&lt;/code&gt; 번호는 1000 개 이상의 8 문자 암호를 반복하는 간단한 프로그램을 사용하여 가져옵니다. 그렇게하면 다른 반복 횟수로 속도를 보여줄 수 있습니다. 참고로 &lt;code&gt;john -test&lt;/code&gt; 는 &lt;code&gt;crypt-bf/5&lt;/code&gt; 에 대해 13506 루프 / 초를 보여줍니다 . (결과의 아주 작은 차이는 &lt;code&gt;pgcrypto&lt;/code&gt; 의 &lt;code&gt;crypt-bf&lt;/code&gt; 구현 이 John the Ripper에서 사용 된 것과 동일 하다는 사실 에 따릅니다 .)</target>
        </trans-unit>
        <trans-unit id="1a28fc368bc65090a50bec41a0656581921809ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;crypt-des&lt;/code&gt; and &lt;code&gt;crypt-md5&lt;/code&gt; algorithm numbers are taken from John the Ripper v1.6.38 &lt;code&gt;-test&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;crypt-des&lt;/code&gt; 및 &lt;code&gt;crypt-md5&lt;/code&gt; 알고리즘 번호는 John the Ripper v1.6.38 &lt;code&gt;-test&lt;/code&gt; 출력 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="61b93541a6e986e3f11ad9875e724e92be30852e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;csv&lt;/code&gt; format  writes column values separated by commas, applying the quoting rules described in &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180&lt;/a&gt;. This output is compatible with the CSV format of the server's &lt;code&gt;COPY&lt;/code&gt; command. A header line with column names is generated unless the &lt;code&gt;tuples_only&lt;/code&gt; parameter is &lt;code&gt;on&lt;/code&gt;. Titles and footers are not printed. Each row is terminated by the system-dependent end-of-line character, which is typically a single newline (&lt;code&gt;\n&lt;/code&gt;) for Unix-like systems or a carriage return and newline sequence (&lt;code&gt;\r\n&lt;/code&gt;) for Microsoft Windows. Field separator characters other than comma can be selected with &lt;code&gt;\pset csv_fieldsep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;csv&lt;/code&gt; 형식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180에&lt;/a&gt; 설명 된 인용 규칙을 적용하여 열 값을 쉼표로 구분하여 기록합니다 . 이 출력은 서버 &lt;code&gt;COPY&lt;/code&gt; 명령 의 CSV 형식과 호환됩니다 . &lt;code&gt;tuples_only&lt;/code&gt; 매개 변수가 설정 &lt;code&gt;on&lt;/code&gt; 있지 않으면 열 이름이있는 헤더 행이 생성 됩니다 . 제목과 바닥 글이 인쇄되지 않습니다. 각 행은 시스템 종속 행 끝 문자로 종료되는데, 일반적으로 Unix 계열 시스템의 경우 단일 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; ) 또는 Microsoft Windows의 경우 캐리지 리턴 및 줄 바꿈 시퀀스 ( &lt;code&gt;\r\n&lt;/code&gt; )입니다. 쉼표 이외의 필드 구분 문자는 &lt;code&gt;\pset csv_fieldsep&lt;/code&gt; 로 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a854a6d0a336cd48135c1b1b71d555013fd66ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[2]) == '(3),(7)'&lt;/code&gt;&lt;code&gt;cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[3,2,1,1]) == '(5,3,1,1),(8,7,6,6)'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[2]) == '(3),(7)'&lt;/code&gt; &lt;code&gt;cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[3,2,1,1]) == '(5,3,1,1),(8,7,6,6)'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f19bf33bc7880cbd5824b79af7a72d7c715923f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cume_dist&lt;/code&gt; computes the fraction of partition rows that are less than or equal to the current row and its peers, while &lt;code&gt;percent_rank&lt;/code&gt; computes the fraction of partition rows that are less than the current row, assuming the current row does not exist in the partition.</source>
          <target state="translated">&lt;code&gt;cume_dist&lt;/code&gt; 는 현재 행과 그 피어보다 작거나 같은 파티션 행의 비율을 계산하는 반면, &lt;code&gt;percent_rank&lt;/code&gt; 는 현재 행이 파티션에 존재하지 않는다고 가정하고 현재 행보다 적은 파티션 행의 비율을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="74da38248c94ae8d28bab065bdf3a36cbbf56f6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_catalog&lt;/code&gt;, &lt;code&gt;current_role&lt;/code&gt;, &lt;code&gt;current_schema&lt;/code&gt;, &lt;code&gt;current_user&lt;/code&gt;, &lt;code&gt;session_user&lt;/code&gt;, and &lt;code&gt;user&lt;/code&gt; have special syntactic status in SQL: they must be called without trailing parentheses. (In PostgreSQL, parentheses can optionally be used with &lt;code&gt;current_schema&lt;/code&gt;, but not with the others.)</source>
          <target state="translated">&lt;code&gt;current_catalog&lt;/code&gt; , &lt;code&gt;current_role&lt;/code&gt; , &lt;code&gt;current_schema&lt;/code&gt; , &lt;code&gt;current_user&lt;/code&gt; , &lt;code&gt;session_user&lt;/code&gt; 및 &lt;code&gt;user&lt;/code&gt; 는 SQL에서 특수한 구문 상태를 갖습니다. 뒤에 괄호없이 호출해야합니다. PostgreSQL에서 괄호는 선택적으로 &lt;code&gt;current_schema&lt;/code&gt; 와 함께 사용할 수 있지만 다른 것과 함께 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="da002cc15739c3f47477a3fc3435b91e74968319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_logfiles&lt;/code&gt; is recreated when a new log file is created as an effect of rotation, and when &lt;code&gt;log_destination&lt;/code&gt; is reloaded. It is removed when neither stderr nor csvlog are included in &lt;code&gt;log_destination&lt;/code&gt;, and when the logging collector is disabled.</source>
          <target state="translated">&lt;code&gt;current_logfiles&lt;/code&gt; 는 회전의 영향으로 새 로그 파일을 만들 때와 &lt;code&gt;log_destination&lt;/code&gt; 을 다시로드 할 때 다시 만들어집니다. stderr 또는 csvlog가 &lt;code&gt;log_destination&lt;/code&gt; 에 포함되어 있지 않고 로깅 콜렉터가 사용 불가능한 경우 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef29c180f9796a3b0a9f2730de5755b773dcefea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_schema&lt;/code&gt; returns the name of the schema that is first in the search path (or a null value if the search path is empty). This is the schema that will be used for any tables or other named objects that are created without specifying a target schema. &lt;code&gt;current_schemas(boolean)&lt;/code&gt; returns an array of the names of all schemas presently in the search path. The Boolean option determines whether or not implicitly included system schemas such as &lt;code&gt;pg_catalog&lt;/code&gt; are included in the returned search path.</source>
          <target state="translated">&lt;code&gt;current_schema&lt;/code&gt; 는 검색 경로에서 첫 번째 인 스키마 이름을 반환합니다 (또는 검색 경로가 비어 있으면 null 값). 대상 스키마를 지정하지 않고 생성 된 테이블 또는 기타 명명 된 개체에 사용되는 스키마입니다. &lt;code&gt;current_schemas(boolean)&lt;/code&gt; 은 현재 검색 경로에있는 모든 스키마 이름의 배열을 반환합니다. 부울 옵션은 &lt;code&gt;pg_catalog&lt;/code&gt; 와 같이 내재적으로 포함 된 시스템 스키마 가 리턴 된 검색 경로에 포함되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="a85203d998c84542ce9a5b664e14429fc310c264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cursor_tuple_fraction&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;cursor_tuple_fraction&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0f5258b6d62cd693cecb2c52a40931486ea4cc62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; (Drop)</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; (드롭)</target>
        </trans-unit>
        <trans-unit id="87976f5933853c0c0f27f29d8bb1b3f5d33b9135" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; = &lt;code&gt;double&lt;/code&gt; alignment (8 bytes on many machines, but by no means all).</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; = &lt;code&gt;double&lt;/code&gt; 정렬 (많은 컴퓨터에서 8 바이트이지만 결코 아님).</target>
        </trans-unit>
        <trans-unit id="3c10a1df9d3c7f874f5757c86d4cdf69cb484d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;&lt;code&gt;directory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt;&lt;code&gt;directory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4d2615d940b126c9690acb77eafc244e6722787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_checksums&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;data_checksums&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98cd310c85b77dfb2432f39d8d8ab7280bde527e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_directory&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;data_directory&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="05114adf0459cd2ce9ad6bbfab12da623fe2ec0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_directory_mode&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;data_directory_mode&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e4ef45c62d49d2ef7e744bd6b4b213f612160894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_sync_retry&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;data_sync_retry&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="196040857cbb516e920fab33e4db45921e153391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;date&lt;/code&gt; , &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e30e63b70dc945d86dd4567a60c78e49f350495c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;date&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7dbc183f18251088eef50467a705fc1d36c3ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datestyle&lt;/code&gt; Setting</source>
          <target state="translated">&lt;code&gt;datestyle&lt;/code&gt; 설정</target>
        </trans-unit>
        <trans-unit id="390b39e52006eb04651b077c1c6f4c0e664d8912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datum&lt;/code&gt; is the original datum of &lt;code&gt;spgConfigIn&lt;/code&gt;.&lt;code&gt;attType&lt;/code&gt; type that was to be inserted into the index. &lt;code&gt;leafDatum&lt;/code&gt; is a value of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type, which is initially a result of method &lt;code&gt;compress&lt;/code&gt; applied to &lt;code&gt;datum&lt;/code&gt; when method &lt;code&gt;compress&lt;/code&gt; is provided, or the same value as &lt;code&gt;datum&lt;/code&gt; otherwise. &lt;code&gt;leafDatum&lt;/code&gt; can change at lower levels of the tree if the &lt;code&gt;choose&lt;/code&gt; or &lt;code&gt;picksplit&lt;/code&gt; methods change it. When the insertion search reaches a leaf page, the current value of &lt;code&gt;leafDatum&lt;/code&gt; is what will be stored in the newly created leaf tuple. &lt;code&gt;level&lt;/code&gt; is the current inner tuple's level, starting at zero for the root level. &lt;code&gt;allTheSame&lt;/code&gt; is true if the current inner tuple is marked as containing multiple equivalent nodes (see &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;). &lt;code&gt;hasPrefix&lt;/code&gt; is true if the current inner tuple contains a prefix; if so, &lt;code&gt;prefixDatum&lt;/code&gt; is its value. &lt;code&gt;nNodes&lt;/code&gt; is the number of child nodes contained in the inner tuple, and &lt;code&gt;nodeLabels&lt;/code&gt; is an array of their label values, or NULL if there are no labels.</source>
          <target state="translated">&lt;code&gt;datum&lt;/code&gt; 은 &lt;code&gt;spgConfigIn&lt;/code&gt; 의 원래 데이텀입니다 . 인덱스에 삽입 될 &lt;code&gt;attType&lt;/code&gt; 유형입니다. &lt;code&gt;leafDatum&lt;/code&gt; 는 값이다 &lt;code&gt;spgConfigOut&lt;/code&gt; . &lt;code&gt;leafType&lt;/code&gt; 유형은 처음에 메소드 &lt;code&gt;compress&lt;/code&gt; 이 제공 될 때 &lt;code&gt;datum&lt;/code&gt; 적용되는 메소드 &lt;code&gt;compress&lt;/code&gt; 의 결과 이거나 그렇지 않으면 &lt;code&gt;datum&lt;/code&gt; 과 동일한 값 입니다. &lt;code&gt;leafDatum&lt;/code&gt; 이 (가) 경우 나무의 낮은 수준에서 변경할 수 있습니다 &lt;code&gt;choose&lt;/code&gt; 또는 &lt;code&gt;picksplit&lt;/code&gt; 의 방법을 변경합니다. 삽입 검색이 리프 페이지에 도달하면 &lt;code&gt;leafDatum&lt;/code&gt; 의 현재 값새로 만든 리프 튜플에 저장됩니다. &lt;code&gt;level&lt;/code&gt; 은 현재 내부 튜플의 레벨이며 루트 레벨의 경우 0부터 시작합니다. 현재 내부 튜플에 여러 개의 등가 노드가 포함 된 것으로 표시되면 &lt;code&gt;allTheSame&lt;/code&gt; 은 true입니다 ( &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;섹션 65.4.3&lt;/a&gt; 참조 ). &lt;code&gt;hasPrefix&lt;/code&gt; 는 현재 내부 튜플에 접두사가 포함되어 있으면 true입니다. 그렇다면 &lt;code&gt;prefixDatum&lt;/code&gt; 이 그 값입니다. &lt;code&gt;nNodes&lt;/code&gt; 는 내부 튜플에 포함 된 자식 노드의 수이고 &lt;code&gt;nodeLabels&lt;/code&gt; 는 레이블 값의 배열이거나 레이블이없는 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="dae62a6513eef7ae831b63a183bb64a82dfd0440" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;day&lt;/code&gt;/&lt;code&gt;month&lt;/code&gt;/&lt;code&gt;year&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;day&lt;/code&gt;/&lt;code&gt;month&lt;/code&gt;/&lt;code&gt;year&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ced0c2b7eac01398a0c0f7a2c418280b91dd3e3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;db_user_namespace&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;db_user_namespace&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4c0b67e92fdcabdb5e577d188b484af0c2fe030c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;db_user_namespace&lt;/code&gt; causes the client's and server's user name representation to differ. Authentication checks are always done with the server's user name so authentication methods must be configured for the server's user name, not the client's. Because &lt;code&gt;md5&lt;/code&gt; uses the user name as salt on both the client and server, &lt;code&gt;md5&lt;/code&gt; cannot be used with &lt;code&gt;db_user_namespace&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;db_user_namespace&lt;/code&gt; 로 인해 클라이언트와 서버의 사용자 이름 표시가 달라집니다. 인증 확인은 항상 서버의 사용자 이름으로 수행되므로 클라이언트가 아닌 서버의 사용자 이름에 대해 인증 방법을 구성해야합니다. 때문에 &lt;code&gt;md5&lt;/code&gt; 클라이언트와 서버 모두에 소금과 같은 사용자 이름을 사용, &lt;code&gt;md5&lt;/code&gt; 사용할 수 없습니다 &lt;code&gt;db_user_namespace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7509a31c62bfa059992c62245072ac0bab01a5f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadlock_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;deadlock_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a53c5db2ce57de50dd33c28c1f32449e66ec61dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug_assertions&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;debug_assertions&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95a7d2c79908d5efd126ed39fd85d2fd72848d4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug_deadlocks&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;debug_deadlocks&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b741285fc8bda6d1dcf83ea48013edd5b7692dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug_pretty_print&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;debug_pretty_print&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="104cf882014b7efb139e777748908634f41e736b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debug_print_parse&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)  &lt;code&gt;debug_print_rewritten&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)  &lt;code&gt;debug_print_plan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;debug_print_parse&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; ) &lt;code&gt;debug_print_rewritten&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; ) &lt;code&gt;debug_print_plan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c95afa51c93addca33ca5f3452aa32f469bf9e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_statistics_target&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_statistics_target&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c6445a5038b7dbc991310103a509abae8b7aac45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_table_access_method&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_table_access_method&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c10293135b214f6b2a6018a5c2fcddc75a3c2d06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_tablespace&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_tablespace&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="301d7322310d509171bea5aedc8b8a0539cab3fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_text_search_config&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_text_search_config&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8167a790870d672ab28be73952092ac6d3af6f20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_transaction_deferrable&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_transaction_deferrable&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="58c1424768c5afae303ea70623e761b2d1be2039" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_transaction_isolation&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_transaction_isolation&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="09156ad3dc08b89238f3459723b4eea5129d48dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_transaction_read_only&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;default_transaction_read_only&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0c648fe8892b0fb34fa4fc3eddc0af9a8fa9a626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;description&lt;/code&gt;&lt;code&gt;text&lt;/code&gt; &amp;mdash; description of the token type</source>
          <target state="translated">&lt;code&gt;description&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; &amp;mdash; 토큰 유형에 대한 설명</target>
        </trans-unit>
        <trans-unit id="8c9de52644091c40fb6857a9e81e2dcb281c0e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict_int&lt;/code&gt; is an example of an add-on dictionary template for full-text search. The motivation for this example dictionary is to control the indexing of integers (signed and unsigned), allowing such numbers to be indexed while preventing excessive growth in the number of unique words, which greatly affects the performance of searching.</source>
          <target state="translated">&lt;code&gt;dict_int&lt;/code&gt; 는 전체 텍스트 검색을위한 애드온 사전 템플릿의 예입니다. 이 예제 사전의 동기는 정수 (부호 및 부호없는)의 색인 생성을 제어하여 고유 한 단어의 수가 과도하게 증가하는 것을 방지하면서 검색의 성능에 큰 영향을 미치는 이러한 숫자를 색인화 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd533f4e43081ceae8202f225f578838bd0484c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict_xsyn&lt;/code&gt; (Extended Synonym Dictionary) is an example of an add-on dictionary template for full-text search. This dictionary type replaces words with groups of their synonyms, and so makes it possible to search for a word using any of its synonyms.</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; (확장 동의어 사전)은 전체 텍스트 검색을위한 애드온 사전 템플릿의 예입니다. 이 사전 유형은 단어를 동의어 그룹으로 대체하므로 동의어를 사용하여 단어를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da066440a3ece8293c97eb31799a74a09e6a5b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dictionaries&lt;/code&gt;&lt;code&gt;regdictionary[]&lt;/code&gt; &amp;mdash; the dictionaries selected by the configuration for this token type</source>
          <target state="translated">&lt;code&gt;dictionaries&lt;/code&gt; &lt;code&gt;regdictionary[]&lt;/code&gt; &amp;mdash;이 토큰 유형의 구성에 의해 선택된 사전</target>
        </trans-unit>
        <trans-unit id="44420e184956056372b89e686f9ce2b5fb72ea1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dictionary&lt;/code&gt;&lt;code&gt;regdictionary&lt;/code&gt; &amp;mdash; the dictionary that recognized the token, or &lt;code&gt;NULL&lt;/code&gt; if none did</source>
          <target state="translated">&lt;code&gt;dictionary&lt;/code&gt; &lt;code&gt;regdictionary&lt;/code&gt; &amp;mdash; 토큰을 인식 한 사전. 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f56171c8166fd61c578b92d64f00fb9c8bd3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt; defines the fetch direction and number of rows to fetch. It can be one of the following:</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 은 페치 방향과 페치 할 행 수를 정의합니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6be239dd65aadb68a62f89721c30afc3dbaf454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;disabled&lt;/code&gt;: This state is reported if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; is disabled in this backend.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; : 이 백엔드에서 &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; 가 비활성화 된 경우이 상태가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="64107742690f8571d9eb3cc8cac71a55e51b4dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;document_expression&lt;/code&gt; provides the context item for the &lt;code&gt;row_expression&lt;/code&gt;. It must be a well-formed XML document; fragments/forests are not accepted. The &lt;code&gt;BY REF&lt;/code&gt; and &lt;code&gt;BY VALUE&lt;/code&gt; clauses are accepted but ignored, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;Section D.3.2&lt;/a&gt;. In the SQL standard, the &lt;code&gt;xmltable&lt;/code&gt; function evaluates expressions in the XML Query language, but PostgreSQL allows only XPath 1.0 expressions, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;document_expression&lt;/code&gt; 은 &lt;code&gt;row_expression&lt;/code&gt; 의 컨텍스트 항목을 제공합니다 . 올바른 형식의 XML 문서 여야합니다. 조각 / 숲은 허용되지 않습니다. &lt;code&gt;BY REF&lt;/code&gt; 와 &lt;code&gt;BY VALUE&lt;/code&gt; 에서 논의 조항은 인정하지만 무시됩니다 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-POSTGRESQL&quot;&gt;섹션 D.3.2&lt;/a&gt; . SQL 표준에서 &lt;code&gt;xmltable&lt;/code&gt; 함수는 XML 쿼리 언어로 표현식을 평가하지만 PostgreSQL은 &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;섹션 D.3.1&lt;/a&gt; 에서 논의 된 것처럼 XPath 1.0 표현식 만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="ef0e6d66d7ea914e844c628558157278ca1f2f36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double precision&lt;/code&gt; for floating-point arguments, otherwise &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;double precision&lt;/code&gt; 부동 소수점 인수의 배정도 , 그렇지 않은 경우 &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f2348a9101e3bd4156c3251f09e44967d13bbcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double precision&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;double precision&lt;/code&gt; 또는 &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb143d036cec976fe8045b474a5492eba8621fa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropdb&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] &lt;code&gt;dbname&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dropdb&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] &lt;code&gt;dbname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29cd9188e6d7ee3ef4bc67d3a9775cc4be986059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropuser&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;username&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;dropuser&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;username&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="2e9c1ca758c4d33985b0c8c7a1f9dae6dc0d6c7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_library_path&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;dynamic_library_path&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f9b19740d90c3ece0d1ef063c7b18cc5d751b4a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_shared_memory_type&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;dynamic_shared_memory_type&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="de2a00315094c098829d736fadb736a56c0652c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;: Value can be stored in a &amp;ldquo;secondary&amp;rdquo; relation (if relation has one, see &lt;code&gt;pg_class.reltoastrelid&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; : 값을 &quot;보조&quot;관계로 저장할 수 있습니다 (관계에 관계가있는 경우 &lt;code&gt;pg_class.reltoastrelid&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6965e43a8b9b46be31b0544ca6cc305a326b04ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ecb&lt;/code&gt; &amp;mdash; each block is encrypted separately (for testing only)</source>
          <target state="translated">&lt;code&gt;ecb&lt;/code&gt; &amp;mdash; 각 블록은 개별적으로 암호화됩니다 (테스트 전용)</target>
        </trans-unit>
        <trans-unit id="03202acfee3eff96095ca83c9d0bf4d868e640d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ecpg&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] &lt;code&gt;file&lt;/code&gt;...</source>
          <target state="translated">&lt;code&gt;ecpg&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] &lt;code&gt;file&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="1cac23101c1fc299dc36537b57c1d0b7bd49159d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ecpg&lt;/code&gt; accepts the following command-line arguments:</source>
          <target state="translated">&lt;code&gt;ecpg&lt;/code&gt; 는 다음 명령 줄 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8a34e3df98bbe231a0ff980ed4a4ed12c26e5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ecpg&lt;/code&gt; is the embedded SQL preprocessor for C programs. It converts C programs with embedded SQL statements to normal C code by replacing the SQL invocations with special function calls. The output files can then be processed with any C compiler tool chain.</source>
          <target state="translated">&lt;code&gt;ecpg&lt;/code&gt; 는 C 프로그램 용 내장 SQL 전 처리기입니다. SQL 호출을 특수 함수 호출로 대체하여 Embedded SQL 문이있는 C 프로그램을 일반 C 코드로 변환합니다. 그런 다음 출력 파일은 모든 C 컴파일러 도구 체인으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="53a9a44997b4f351c591fa7688d80b7cf6325983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ecpg&lt;/code&gt; will convert each input file given on the command line to the corresponding C output file. Input files preferably have the extension &lt;code&gt;.pgc&lt;/code&gt;. The extension will be replaced by &lt;code&gt;.c&lt;/code&gt; to determine the output file name. The output file name can also be overridden using the &lt;code&gt;-o&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;ecpg&lt;/code&gt; 는 명령 행에 주어진 각 입력 파일을 해당 C 출력 파일로 변환합니다. 입력 파일의 확장자는 &lt;code&gt;.pgc&lt;/code&gt; 입니다. 확장자는 &lt;code&gt;.c&lt;/code&gt; 로 바뀌어 출력 파일 이름을 결정합니다. &lt;code&gt;-o&lt;/code&gt; 옵션을 사용하여 출력 파일 이름을 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27843ae374c8d2d94bc44d52ff457ace8975cc37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;effective_cache_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;effective_cache_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59c9bd1f9f75d0d1fa6f405e533e70ef36b18b5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;effective_io_concurrency&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;effective_io_concurrency&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74dcab49d80f6f151e98aee8e67421a490ce9af4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;email&lt;/code&gt; does not support all valid email characters as defined by RFC 5322. Specifically, the only non-alphanumeric characters supported for email user names are period, dash, and underscore.</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; 은 RFC 5322에 정의 된 모든 유효한 이메일 문자를 지원하지 않습니다. 특히 이메일 사용자 이름에 지원되는 영숫자가 아닌 문자는 마침표, 대시 및 밑줄입니다.</target>
        </trans-unit>
        <trans-unit id="5b6e61feccff91e533ebb3494a2427c039987336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_bitmapscan = off&lt;/code&gt;, &lt;code&gt;enable_hashjoin = off&lt;/code&gt;, &lt;code&gt;enable_indexscan = off&lt;/code&gt;, &lt;code&gt;enable_mergejoin = off&lt;/code&gt;, &lt;code&gt;enable_nestloop = off&lt;/code&gt;, &lt;code&gt;enable_indexonlyscan = off&lt;/code&gt;, &lt;code&gt;enable_seqscan = off&lt;/code&gt;, &lt;code&gt;enable_tidscan = off&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enable_bitmapscan = off&lt;/code&gt; , &lt;code&gt;enable_hashjoin = off&lt;/code&gt; , &lt;code&gt;enable_indexscan = off&lt;/code&gt; , &lt;code&gt;enable_mergejoin = off&lt;/code&gt; , &lt;code&gt;enable_nestloop = off&lt;/code&gt; , &lt;code&gt;enable_indexonlyscan = off&lt;/code&gt; , &lt;code&gt;enable_seqscan = off&lt;/code&gt; , &lt;code&gt;enable_tidscan = off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8278d17183981fbe6741a6d076273b328af0ef7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_bitmapscan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_bitmapscan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b845efdae6d793f8652e694f5e46f483c70bf0bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_gathermerge&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_gathermerge&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="49a614dd47a68ea3b550104f67ead137080679f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_hashagg&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_hashagg&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7cdd361543f654126a4e4ff6f270020d885e3d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_hashjoin&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_hashjoin&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8bba890399985eb46fed5457e7005aad7a18da6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_indexonlyscan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_indexonlyscan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2bf8fef9825f922b01b407d6cfcb8e7f61001a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_indexscan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_indexscan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="75fd05d25c55ff779ae82b9deb18b6e9aee7ad56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_material&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_material&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fadf05bf43c140b785a38eb96781b0b059962972" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_mergejoin&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_mergejoin&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="de50508c66e57b5283037c55b89f050c8b2cba9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_nestloop&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_nestloop&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7dc0d3cbde59229ff9a499e5f9dca7553b367515" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_parallel_append&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_parallel_append&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8919e8d8de39307cdb1f345896e417c6bb63109b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_parallel_hash&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_parallel_hash&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5fd3713c44f0d751f9fb7da67f7fc215bc49d4c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_partition_pruning&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_partition_pruning&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2161c40f3e29e07892331b54b215168dfea279c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_partitionwise_aggregate&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_partitionwise_aggregate&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="27b8e85f6a0342e639e77db02528d26cfc7b6542" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_partitionwise_join&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_partitionwise_join&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3638e001dc805ae40581e809c79240e34a5287c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_seqscan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_seqscan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e20e57a77633a9f4c2605bc94e3769d740737c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_sort&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_sort&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="343496ae89616d7b53bea8a407cdd6cd4ba8090f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_tidscan&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enable_tidscan&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8ff695de553235a4e6aeca53edec63aee20e8e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enabled&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d3bafb9f87871d11625a18c9f77dcf97317e55a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;escape_string_warning&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;escape_string_warning&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f1c1b28fd2f2add99e1fd9dc7501c8690c904584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;event_source&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;event_source&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="946796441936b1213505f8563b3ff7a07193c61d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit_on_error&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;exit_on_error&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="89ae569974923f842f54eeedefafa0a2e98c0ae1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expanded&lt;/code&gt; (or &lt;code&gt;x&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;expanded&lt;/code&gt; (또는 &lt;code&gt;x&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="da162f3c5a006f7aaa27ad5c72ecf795f7e83d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;is32not32null&quot;&gt;IS NOT NULL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; &lt;code id=&quot;is32not32null&quot;&gt;IS NOT NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adb3645c4a99dc336e7baf88227a02492276730" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;is32null&quot;&gt;IS NULL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; &lt;code id=&quot;is32null&quot;&gt;IS NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5001bc5e6b41bc618aafd5485ffb7b394c9005e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;isnull&quot;&gt;ISNULL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;isnull&quot;&gt;ISNULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc598d904e98e677952813180101088c3f7239d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;notnull&quot;&gt;NOTNULL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt;&lt;code id=&quot;notnull&quot;&gt;NOTNULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e7d57830a2083d84aba8911dd19eadcbed8136c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt; (unary postfix operator)</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; (단일 접미사 연산자)</target>
        </trans-unit>
        <trans-unit id="852dc0bf706464549503fe0f06df7abc2625c81c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt; (binary infix operator)</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; (이진 삽입 연산자)</target>
        </trans-unit>
        <trans-unit id="9a5b08f5fa196ae60999b5f1c7970f4aeb0283dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extended&lt;/code&gt;: use extended query protocol.</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; : 확장 쿼리 프로토콜을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="581f8ababfb4a63619fa472e75d3962e311cf85e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;external_pid_file&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;external_pid_file&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e8b334cbbe94c9cc53e48dfb98322572433fc084" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extra_data&lt;/code&gt; is an output argument that allows &lt;code&gt;extractQuery&lt;/code&gt; to pass additional data to the &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;comparePartial&lt;/code&gt; methods. To use it, &lt;code&gt;extractQuery&lt;/code&gt; must allocate an array of &lt;code&gt;*nkeys&lt;/code&gt; pointers and store its address at &lt;code&gt;*extra_data&lt;/code&gt;, then store whatever it wants to into the individual pointers. The variable is initialized to &lt;code&gt;NULL&lt;/code&gt; before call, so this argument can simply be ignored by operator classes that do not require extra data. If &lt;code&gt;*extra_data&lt;/code&gt; is set, the whole array is passed to the &lt;code&gt;consistent&lt;/code&gt; method, and the appropriate element to the &lt;code&gt;comparePartial&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;extra_data&lt;/code&gt; 는 허용 출력 인자이다 &lt;code&gt;extractQuery&lt;/code&gt; 을 받는 부가적인 데이터를 전달하기 위해 &lt;code&gt;consistent&lt;/code&gt; 과 &lt;code&gt;comparePartial&lt;/code&gt; 방법. 이를 사용하려면 &lt;code&gt;extractQuery&lt;/code&gt; 는 &lt;code&gt;*nkeys&lt;/code&gt; 포인터 의 배열을 할당 하고 주소를 &lt;code&gt;*extra_data&lt;/code&gt; 에 저장 한 다음 원하는 것을 개별 포인터에 저장해야합니다. 변수는 호출 전에 &lt;code&gt;NULL&lt;/code&gt; 로 초기화 되므로이 인수는 추가 데이터가 필요하지 않은 연산자 클래스에 의해 무시 될 수 있습니다. 경우 &lt;code&gt;*extra_data&lt;/code&gt; 이 설정되고, 전체 배열에 전달 &lt;code&gt;consistent&lt;/code&gt; 방법 및 소자에 대한 적절한 &lt;code&gt;comparePartial&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="256e75369c5816134181355a0edafc4bfd99a97e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extra_float_digits&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;extra_float_digits&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98b9c0364dc666a61e60fa0912a5c0b078013a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; (create Foreign keys)</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; (외래 키 만들기)</target>
        </trans-unit>
        <trans-unit id="af1d7585a5d5f83e865e62cfb6b0ea36337a3fbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; for a normal function, &lt;code&gt;p&lt;/code&gt; for a procedure, &lt;code&gt;a&lt;/code&gt; for an aggregate function, or &lt;code&gt;w&lt;/code&gt; for a window function</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 일반적인 함수, &lt;code&gt;p&lt;/code&gt; 절차 들면 집계 기능 또는 &lt;code&gt;w&lt;/code&gt; 윈도우 함수 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74eb5ab66fbba2fac35908926e4f83b26bc1fe1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;&lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt;&lt;code&gt;fetch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="349e1e84dcb9b2d4bd4cba54a9bbf163babd07f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fallback_application_name&lt;/code&gt; (always set to &lt;code&gt;postgres_fdw&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;fallback_application_name&lt;/code&gt; (항상 &lt;code&gt;postgres_fdw&lt;/code&gt; 로 설정 )</target>
        </trans-unit>
        <trans-unit id="51d606c9628e97898330b3485e0fbfbe04d1112d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fastpath function call&lt;/code&gt;: The backend is executing a fast-path function.</source>
          <target state="translated">&lt;code&gt;fastpath function call&lt;/code&gt; : 백엔드가 빠른 경로 기능을 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="5a110167f398e332f7cd4a2cff8db52e0ca7a582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdatasync&lt;/code&gt; (call &lt;code&gt;fdatasync()&lt;/code&gt; at each commit)</source>
          <target state="translated">&lt;code&gt;fdatasync&lt;/code&gt; ( 커밋마다 &lt;code&gt;fdatasync()&lt;/code&gt; 호출 )</target>
        </trans-unit>
        <trans-unit id="ea7d2dcc853def6d884976702115592a9e071887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdt&lt;/code&gt; is the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. Rows that do not meet the search condition of the &lt;code&gt;WHERE&lt;/code&gt; clause are eliminated from &lt;code&gt;fdt&lt;/code&gt;. Notice the use of scalar subqueries as value expressions. Just like any other query, the subqueries can employ complex table expressions. Notice also how &lt;code&gt;fdt&lt;/code&gt; is referenced in the subqueries. Qualifying &lt;code&gt;c1&lt;/code&gt; as &lt;code&gt;fdt.c1&lt;/code&gt; is only necessary if &lt;code&gt;c1&lt;/code&gt; is also the name of a column in the derived input table of the subquery. But qualifying the column name adds clarity even when it is not needed. This example shows how the column naming scope of an outer query extends into its inner queries.</source>
          <target state="translated">&lt;code&gt;fdt&lt;/code&gt; 는 &lt;code&gt;FROM&lt;/code&gt; 절 에서 파생 된 테이블 입니다. &lt;code&gt;WHERE&lt;/code&gt; 절의 탐색 조건을 만족하지 않는 행 은 &lt;code&gt;fdt&lt;/code&gt; 에서 제거됩니다 . 스칼라 서브 쿼리를 값 표현식으로 사용하는 것에 주목하십시오. 다른 쿼리와 마찬가지로 하위 쿼리는 복잡한 테이블 식을 사용할 수 있습니다. 하위 쿼리에서 &lt;code&gt;fdt&lt;/code&gt; 가 어떻게 참조 되는지 확인 하십시오. 자격 &lt;code&gt;c1&lt;/code&gt; 같은 &lt;code&gt;fdt.c1&lt;/code&gt; 하는 경우에만 필요 &lt;code&gt;c1&lt;/code&gt; 또한 부질의 유도 입력 테이블의 열 이름이다. 그러나 열 이름을 한정하면 필요하지 않더라도 명확성이 추가됩니다. 이 예에서는 외부 쿼리의 열 명명 범위가 내부 쿼리로 확장되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="36f63f18996d3e3d5f7e8a4c66df09da1a5961a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fillfactor&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;fillfactor&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="76d5aeb8bd6e0d9a57797b2f1ae854fb0bc059c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; (optional)</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="255589109a12165c6f9a36fa119609e5ee4553fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force_parallel_mode&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;force_parallel_mode&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d3d02ba40d67bbd69247a951bd9f33bbae285ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format_type&lt;/code&gt; returns the SQL name of a data type that is identified by its type OID and possibly a type modifier. Pass NULL for the type modifier if no specific modifier is known.</source>
          <target state="translated">&lt;code&gt;format_type&lt;/code&gt; 은 유형 OID 및 가능하면 유형 수정 자로 식별되는 데이터 유형의 SQL 이름을 리턴합니다. 특정 수정자가 알려지지 않은 경우 유형 수정 자에 대해 NULL을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="4a7fa30fa1a4afe3752802b76cc3708d3e86be25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatstr&lt;/code&gt; is a format string that specifies how the result should be formatted. Text in the format string is copied directly to the result, except where &lt;em&gt;format specifiers&lt;/em&gt; are used. Format specifiers act as placeholders in the string, defining how subsequent function arguments should be formatted and inserted into the result. Each &lt;code&gt;formatarg&lt;/code&gt; argument is converted to text according to the usual output rules for its data type, and then formatted and inserted into the result string according to the format specifier(s).</source>
          <target state="translated">&lt;code&gt;formatstr&lt;/code&gt; 은 결과의 형식을 지정하는 형식 문자열입니다. &lt;em&gt;형식 지정&lt;/em&gt; 자가 사용되는 &lt;em&gt;경우를&lt;/em&gt; 제외하고 형식 문자열의 텍스트가 결과에 직접 복사 됩니다. 형식 지정자는 문자열에서 자리 표시 자로 작동하여 후속 함수 인수를 형식화하고 결과에 삽입하는 방법을 정의합니다. 각 &lt;code&gt;formatarg&lt;/code&gt; 인수는 해당 데이터 유형에 대한 일반적인 출력 규칙에 따라 텍스트로 변환 된 다음 형식 지정자에 따라 결과 문자열에 형식화되고 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="1dbc0557ae72588cfb4135d4456d2daafb61dde3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_collapse_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;from_collapse_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="598b65b2edeea2dcb4db0a87a77c7a2cbcd46f8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fsm_page_contents&lt;/code&gt; shows the internal node structure of a FSM page. For example:</source>
          <target state="translated">&lt;code&gt;fsm_page_contents&lt;/code&gt; 는 FSM 페이지의 내부 노드 구조를 보여줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bda491e37dea2e4937d4787200d85082aea44ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fsync&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="160aee1392308c2477d2dcf35ff3fc199e900f93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fsync&lt;/code&gt; (call &lt;code&gt;fsync()&lt;/code&gt; at each commit)</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; ( 각 커밋에서 &lt;code&gt;fsync()&lt;/code&gt; 호출 )</target>
        </trans-unit>
        <trans-unit id="562b528ba67fe0bc133a3a5e8722a5886cb83f2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fsync&lt;/code&gt; can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. If you turn this parameter off, also consider turning off &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fsync&lt;/code&gt; 는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 이 매개 변수를 끄면 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 도 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="58e17a456461edbee807702e13a2d01ab28d6b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fsync_writethrough&lt;/code&gt; (call &lt;code&gt;fsync()&lt;/code&gt; at each commit, forcing write-through of any disk write cache)</source>
          <target state="translated">&lt;code&gt;fsync_writethrough&lt;/code&gt; ( 각 커밋마다 &lt;code&gt;fsync()&lt;/code&gt; 를 호출 하여 디스크 쓰기 캐시를 강제로 기록)</target>
        </trans-unit>
        <trans-unit id="469793d9c2de77cc2f42f1636a45ba4887d151a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;full_page_writes&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;full_page_writes&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="edd57cf7b2a9480317c012924ce7672c0acf3b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; (Generate data)</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; (데이터 생성)</target>
        </trans-unit>
        <trans-unit id="920dee58503bf0364fa20288c6f92d027fbb3311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;genbki.pl&lt;/code&gt; resolves all symbolic references while it runs, and puts simple numeric OIDs into the emitted BKI file. There is therefore no need for the bootstrap backend to deal with symbolic references.</source>
          <target state="translated">&lt;code&gt;genbki.pl&lt;/code&gt; 은 실행되는 동안 모든 기호 참조를 해결하고 방출 된 BKI 파일에 간단한 숫자 OID를 넣습니다. 따라서 부트 스트랩 백엔드에서 기호 참조를 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="835687ec2375c732b2f7e4a3b8a2e55a0a26c20b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate_subscripts&lt;/code&gt; is a convenience function that generates the set of valid subscripts for the specified dimension of the given array. Zero rows are returned for arrays that do not have the requested dimension, or for NULL arrays (but valid subscripts are returned for NULL array elements). Some examples follow:</source>
          <target state="translated">&lt;code&gt;generate_subscripts&lt;/code&gt; 는 주어진 배열의 지정된 차원에 대해 유효한 첨자 집합을 생성하는 편리한 함수입니다. 요청 된 차원이없는 배열 또는 NULL 배열에 대해서는 0 개의 행이 반환되지만 NULL 배열 요소에는 유효한 첨자가 반환됩니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c646a9e5da3078d7e56561338a56be153d9b66ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b608a6662d3d86c97f769ae65834deb732532125" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_effort&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_effort&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a2887ccb216461e25762ca147317b8e2f3a91168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_effort&lt;/code&gt; doesn't actually do anything directly; it is only used to compute the default values for the other variables that influence GEQO behavior (described below). If you prefer, you can set the other parameters by hand instead.</source>
          <target state="translated">&lt;code&gt;geqo_effort&lt;/code&gt; 는 실제로 직접적으로 아무것도하지 않습니다. GEQO 동작에 영향을 미치는 다른 변수의 기본값을 계산하는 데만 사용됩니다 (아래 설명 참조). 원하는 경우 다른 매개 변수를 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab6548e01edaf1d7bf3f89f4c56f10afcf8b3ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_generations&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_generations&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="63efa38d17f06cf9f48b869c8ead5146288fa56a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_pool_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_pool_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="384f9600541b092a78449cd2cea84ad10d952202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_seed&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_seed&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4c59fcb7ec92c63d18a0345b085843cdd3dacee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_selection_bias&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_selection_bias&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="24a18f78147408ad78c888c3af2206b0dfbec85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;geqo_threshold&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;geqo_threshold&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="10d53d5c8af67ce67bf3dc79fc3fc009dcbf1d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_byte&lt;/code&gt; and &lt;code&gt;set_byte&lt;/code&gt; number the first byte of a binary string as byte 0. &lt;code&gt;get_bit&lt;/code&gt; and &lt;code&gt;set_bit&lt;/code&gt; number bits from the right within each byte; for example bit 0 is the least significant bit of the first byte, and bit 15 is the most significant bit of the second byte.</source>
          <target state="translated">&lt;code&gt;get_byte&lt;/code&gt; 및 &lt;code&gt;set_byte&lt;/code&gt; 는 이진 문자열의 첫 번째 바이트를 바이트 0으로 &lt;code&gt;get_bit&lt;/code&gt; 및 &lt;code&gt;set_bit&lt;/code&gt; 는 각 바이트 내에서 오른쪽 비트입니다. 예를 들어 비트 0은 첫 번째 바이트의 최하위 비트이고 비트 15는 두 번째 바이트의 최상위 비트입니다.</target>
        </trans-unit>
        <trans-unit id="964d4a7d51355f8a6e8c5e7a544a8ba59c946fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_raw_page&lt;/code&gt; reads the specified block of the named relation and returns a copy as a &lt;code&gt;bytea&lt;/code&gt; value. This allows a single time-consistent copy of the block to be obtained. &lt;code&gt;fork&lt;/code&gt; should be &lt;code&gt;'main'&lt;/code&gt; for the main data fork, &lt;code&gt;'fsm'&lt;/code&gt; for the free space map, &lt;code&gt;'vm'&lt;/code&gt; for the visibility map, or &lt;code&gt;'init'&lt;/code&gt; for the initialization fork.</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; 는 명명 된 관계의 지정된 블록을 읽고 &lt;code&gt;bytea&lt;/code&gt; 값으로 사본을 리턴 합니다. 이를 통해 블록의 단일 한 일관된 사본을 얻을 수 있습니다. &lt;code&gt;fork&lt;/code&gt; 는 기본 데이터 포크의 경우 &lt;code&gt;'main'&lt;/code&gt; , 여유 공간 맵의 경우 &lt;code&gt;'fsm'&lt;/code&gt; , 가시성 맵의 경우 &lt;code&gt;'vm'&lt;/code&gt; 또는 초기화 포크의 경우 &lt;code&gt;'init'&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2e85f6a97b5d8015186a4057a50ac83c2af5277" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_clean_pending_list&lt;/code&gt; accepts the OID or name of a GIN index and cleans up the pending list of the specified index by moving entries in it to the main GIN data structure in bulk. It returns the number of pages removed from the pending list. Note that if the argument is a GIN index built with the &lt;code&gt;fastupdate&lt;/code&gt; option disabled, no cleanup happens and the return value is 0, because the index doesn't have a pending list. Please see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; and &lt;a href=&quot;gin-tips&quot;&gt;Section 66.5&lt;/a&gt; for details of the pending list and &lt;code&gt;fastupdate&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;gin_clean_pending_list&lt;/code&gt; 는 GIN 인덱스의 OID 또는 이름을 승인하고 지정된 인덱스의 항목을 기본 GIN 데이터 구조로 대량 이동하여 지정된 인덱스의 보류 목록을 정리합니다. 보류 목록에서 제거 된 페이지 수를 리턴합니다. 인수가 &lt;code&gt;fastupdate&lt;/code&gt; 옵션을 사용하지 않고 빌드 된 GIN 인덱스 인 경우 인덱스에 보류 목록이 없기 때문에 정리가 수행되지 않고 리턴 값은 0입니다. 보류 목록 및 &lt;code&gt;fastupdate&lt;/code&gt; 대한 자세한 내용 은 &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;섹션 66.4.1&lt;/a&gt; 및 &lt;a href=&quot;gin-tips&quot;&gt;섹션 66.5&lt;/a&gt; 를 참조하십시오. 옵션에 .</target>
        </trans-unit>
        <trans-unit id="fd07c377d3a16664f5ca93f06aabcc776639a482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;gin_fuzzy_search_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b6e226c42bc316133d411e62886d89fc417871cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_leafpage_items&lt;/code&gt; returns information about the data stored in a GIN leaf page. For example:</source>
          <target state="translated">&lt;code&gt;gin_leafpage_items&lt;/code&gt; 는 GIN 리프 페이지에 저장된 데이터에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8046c1ef327a8308484345e9ba7ef68132f6fc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_metapage_info&lt;/code&gt; returns information about a GIN index metapage. For example:</source>
          <target state="translated">&lt;code&gt;gin_metapage_info&lt;/code&gt; 는 GIN 인덱스 메타 페이지에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96a76926af5c893aabd1f2f27cb69445589a46ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_page_opaque_info&lt;/code&gt; returns information about a GIN index opaque area, like the page type. For example:</source>
          <target state="translated">&lt;code&gt;gin_page_opaque_info&lt;/code&gt; 는 페이지 유형과 같은 GIN 인덱스 불투명 영역에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7b5d7b520a2d3407d68d03eb309ef4bfb360d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_pending_list_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;gin_pending_list_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c3fe6864fd028020e8c4432ab94d95c9f7df5d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gin_pending_list_limit&lt;/code&gt; can be overridden for individual GIN indexes by changing storage parameters, and which allows each GIN index to have its own cleanup threshold. For example, it's possible to increase the threshold only for the GIN index which can be updated heavily, and decrease it otherwise.</source>
          <target state="translated">&lt;code&gt;gin_pending_list_limit&lt;/code&gt; 스토리지 매개 변수를 변경하여 개별 GIN 인덱스에 대해 를 대체하고 각 GIN 인덱스가 자체 정리 임계 값을 갖도록 할 수 있습니다. 예를 들어, 과도하게 업데이트 할 수있는 GIN 인덱스에 대한 임계 값 만 늘리고 그렇지 않으면 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18dcdd0479c784a354bc972290f35b64dea62a9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;granted&lt;/code&gt; is true in a row representing a lock held by the indicated process. False indicates that this process is currently waiting to acquire this lock, which implies that at least one other process is holding or waiting for a conflicting lock mode on the same lockable object. The waiting process will sleep until the other lock is released (or a deadlock situation is detected). A single process can be waiting to acquire at most one lock at a time.</source>
          <target state="translated">&lt;code&gt;granted&lt;/code&gt; 지정된 프로세스가 보유한 잠금을 나타내는 행에서 는 true입니다. False는이 프로세스가 현재이 잠금을 획득하기 위해 대기 중임을 나타냅니다. 이는 하나 이상의 다른 프로세스가 동일한 잠금 가능 오브젝트에서 충돌하는 잠금 모드를 보류 중이거나 대기 중임을 의미합니다. 대기 프로세스는 다른 잠금이 해제 될 때까지 (또는 교착 상태 상황이 감지 될 때까지) 휴면 상태가됩니다. 단일 프로세스는 한 번에 최대 하나의 잠금을 획득하기 위해 대기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aadf91743daab3a8f16402c9208e9e77d4898da5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_function&lt;/code&gt; is the name (possibly schema-qualified) of a previously registered function that represents the access method. The handler function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and its return type depends on the type of access method; for &lt;code&gt;TABLE&lt;/code&gt; access methods, it must be &lt;code&gt;table_am_handler&lt;/code&gt; and for &lt;code&gt;INDEX&lt;/code&gt; access methods, it must be &lt;code&gt;index_am_handler&lt;/code&gt;. The C-level API that the handler function must implement varies depending on the type of access method. The table access method API is described in &lt;a href=&quot;tableam&quot;&gt;Chapter 60&lt;/a&gt; and the index access method API is described in &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;Chapter 61&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler_function&lt;/code&gt; 은 액세스 방법을 나타내는 이전에 등록 된 함수의 이름 (아마도 스키마 한정)입니다. handler 함수는 &lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 사용하도록 선언해야하며 반환 유형은 액세스 방법 유형에 따라 다릅니다. 대한 &lt;code&gt;TABLE&lt;/code&gt; 액세스 방법, 그것은해야 &lt;code&gt;table_am_handler&lt;/code&gt; 및 대한 &lt;code&gt;INDEX&lt;/code&gt; 의 접근 방법, 그것은해야합니다 &lt;code&gt;index_am_handler&lt;/code&gt; . 핸들러 함수가 구현해야하는 C 레벨 API는 액세스 방법의 유형에 따라 다릅니다. 테이블 액세스 방법 API는 &lt;a href=&quot;tableam&quot;&gt;60 장에&lt;/a&gt; 설명되어 있으며 인덱스 액세스 방법 API는 &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;61 장에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="69c57d913c86068eeb416d7e397dc00817bd0010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_function&lt;/code&gt; is the name of a previously registered function that will be called to retrieve the execution functions for foreign tables. The handler function must take no arguments, and its return type must be &lt;code&gt;fdw_handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;handler_function&lt;/code&gt; 은 외부 테이블의 실행 함수를 검색하기 위해 호출 될 이전에 등록 된 함수의 이름입니다. 핸들러 함수는 인수를 취하지 않아야하며 리턴 유형은 &lt;code&gt;fdw_handler&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b49dccec93ae3cbe4cc49694d811a9342cc39558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_any_column_privilege&lt;/code&gt; checks whether a user can access any column of a table in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;, except that the desired access privilege type must evaluate to some combination of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;REFERENCES&lt;/code&gt;. Note that having any of these privileges at the table level implicitly grants it for each column of the table, so &lt;code&gt;has_any_column_privilege&lt;/code&gt; will always return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;has_table_privilege&lt;/code&gt; does for the same arguments. But &lt;code&gt;has_any_column_privilege&lt;/code&gt; also succeeds if there is a column-level grant of the privilege for at least one column.</source>
          <target state="translated">&lt;code&gt;has_any_column_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 테이블의 모든 열에 액세스 할 수 있는지 확인합니다. 원하는 액세스 권한 유형이 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;REFERENCES&lt;/code&gt; 의 일부 조합으로 평가되어야한다는 점을 제외하면 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사 합니다 . 테이블 레벨에서 이러한 특권 중 하나를 갖는 것은 테이블의 각 컬럼에 대해 내재적으로 권한을 부여하므로 &lt;code&gt;has_any_column_privilege&lt;/code&gt; 는 동일한 인수에 대해 &lt;code&gt;has_table_privilege&lt;/code&gt; 가 수행하는 경우 항상 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그러나 &lt;code&gt;has_any_column_privilege&lt;/code&gt; 또한 하나 이상의 열에 대한 열 수준의 권한 부여가 있으면 성공합니다.</target>
        </trans-unit>
        <trans-unit id="c71da1f6a37d0fa08d9d7ff82f6b7ec850e43bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_column_privilege&lt;/code&gt; checks whether a user can access a column in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;, with the addition that the column can be specified either by name or attribute number. The desired access privilege type must evaluate to some combination of &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;REFERENCES&lt;/code&gt;. Note that having any of these privileges at the table level implicitly grants it for each column of the table.</source>
          <target state="translated">&lt;code&gt;has_column_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 열에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사 하며 열은 이름 또는 속성 번호로 지정할 수 있습니다. 원하는 액세스 권한 유형은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;REFERENCES&lt;/code&gt; 조합으로 평가되어야합니다 . 테이블 레벨에서 이러한 특권 중 하나를 갖는 것은 테이블의 각 컬럼에 대해 내재적으로 부여합니다.</target>
        </trans-unit>
        <trans-unit id="cfeb88472e66778685d280dc83b4fa1ec3c43516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_database_privilege&lt;/code&gt; checks whether a user can access a database in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to some combination of &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, or &lt;code&gt;TEMP&lt;/code&gt; (which is equivalent to &lt;code&gt;TEMPORARY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;has_database_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 데이터베이스에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;CONNECT&lt;/code&gt; , &lt;code&gt;TEMPORARY&lt;/code&gt; 또는 &lt;code&gt;TEMP&lt;/code&gt; ( &lt;code&gt;TEMPORARY&lt;/code&gt; 와 동일 )의 조합으로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d01b42515cfa64dae225d1b8bbb493031a7f7bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_foreign_data_wrapper_privilege&lt;/code&gt; checks whether a user can access a foreign-data wrapper in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_foreign_data_wrapper_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 외부 데이터 래퍼에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8c495f7d2222f655d0e6a2efc8cef2401ad75bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_function_privilege&lt;/code&gt; checks whether a user can access a function in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. When specifying a function by a text string rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). The desired access privilege type must evaluate to &lt;code&gt;EXECUTE&lt;/code&gt;. An example is:</source>
          <target state="translated">&lt;code&gt;has_function_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 함수에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 텍스트 문자열이 아닌 함수가 OID를 지정하는 경우, 허용 입력이와 동일 &lt;code&gt;regprocedure&lt;/code&gt; 의 데이터 타입 (참조 &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; ). 원하는 액세스 권한 유형은 &lt;code&gt;EXECUTE&lt;/code&gt; 로 평가되어야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d47b233190d4678ce467af03889c325a77957fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_language_privilege&lt;/code&gt; checks whether a user can access a procedural language in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_language_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 절차 언어에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf476a2f2a32df5983d9730a318210931901896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_schema_privilege&lt;/code&gt; checks whether a user can access a schema in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to some combination of &lt;code&gt;CREATE&lt;/code&gt; or &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_schema_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 스키마에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;CREATE&lt;/code&gt; 또는 &lt;code&gt;USAGE&lt;/code&gt; 조합으로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="829aa83f72c73b380314670b50557460cfa77c5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_sequence_privilege&lt;/code&gt; checks whether a user can access a sequence in a particular way. The possibilities for its arguments are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to one of &lt;code&gt;USAGE&lt;/code&gt;, &lt;code&gt;SELECT&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_sequence_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 시퀀스에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; , &lt;code&gt;SELECT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 중 하나로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4da7ebe14d8e8b915ab38c9a114089bd7253e1a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_server_privilege&lt;/code&gt; checks whether a user can access a foreign server in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_server_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 외부 서버에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5114469cb7dcdfd546f38575e5d80ccdac2612b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_table_privilege&lt;/code&gt; checks whether a user can access a table in a particular way. The user can be specified by name, by OID (&lt;code&gt;pg_authid.oid&lt;/code&gt;), &lt;code&gt;public&lt;/code&gt; to indicate the PUBLIC pseudo-role, or if the argument is omitted &lt;code&gt;current_user&lt;/code&gt; is assumed. The table can be specified by name or by OID. (Thus, there are actually six variants of &lt;code&gt;has_table_privilege&lt;/code&gt;, which can be distinguished by the number and types of their arguments.) When specifying by name, the name can be schema-qualified if necessary. The desired access privilege type is specified by a text string, which must evaluate to one of the values &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, or &lt;code&gt;TRIGGER&lt;/code&gt;. Optionally, &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; can be added to a privilege type to test whether the privilege is held with grant option. Also, multiple privilege types can be listed separated by commas, in which case the result will be &lt;code&gt;true&lt;/code&gt; if any of the listed privileges is held. (Case of the privilege string is not significant, and extra whitespace is allowed between but not within privilege names.) Some examples:</source>
          <target state="translated">&lt;code&gt;has_table_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 테이블에 액세스 할 수 있는지 여부를 확인합니다. 사용자는 이름, OID ( &lt;code&gt;pg_authid.oid&lt;/code&gt; ), &lt;code&gt;public&lt;/code&gt; 으로 PUBLIC 의사 역할을 나타내거나 인수가 생략 된 경우 &lt;code&gt;current_user&lt;/code&gt; 를 가정 할 수 있습니다. 테이블은 이름 또는 OID로 지정할 수 있습니다. (따라서 실제로 인수의 수와 유형으로 구별 할 수있는 &lt;code&gt;has_table_privilege&lt;/code&gt; 의 6 가지 변형 이 있습니다.) 이름으로 지정할 때, 필요한 경우 이름을 스키마로 규정 할 수 있습니다. 원하는 액세스 권한 유형은 텍스트 문자열로 지정되며 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 값 중 하나로 평가되어야합니다., &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REFERENCES&lt;/code&gt; 또는 &lt;code&gt;TRIGGER&lt;/code&gt; 입니다. 선택적으로 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 을 권한 유형에 추가하여 권한이 권한 부여 옵션으로 보유되는지 테스트 할 수 있습니다. 또한 여러 권한 유형을 쉼표로 구분하여 나열 할 수 있으며,이 경우 나열된 권한 중 하나라도 보유하면 결과가 &lt;code&gt;true&lt;/code&gt; 됩니다. (권한 문자열의 대소 문자는 중요하지 않으며 권한 이름 사이에는 허용되지 않는 여분의 공백이 있습니다.) 일부 예 :</target>
        </trans-unit>
        <trans-unit id="8a7ddc4b934ed4eca1eec2a1bef571ba5f575ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_tablespace_privilege&lt;/code&gt; checks whether a user can access a tablespace in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. The desired access privilege type must evaluate to &lt;code&gt;CREATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_tablespace_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 테이블 스페이스에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . 원하는 액세스 권한 유형은 &lt;code&gt;CREATE&lt;/code&gt; 로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="68d33a30498134156da0d44aeef09278f9468fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_type_privilege&lt;/code&gt; checks whether a user can access a type in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;. When specifying a type by a text string rather than by OID, the allowed input is the same as for the &lt;code&gt;regtype&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). The desired access privilege type must evaluate to &lt;code&gt;USAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_type_privilege&lt;/code&gt; 는 사용자가 특정 방식으로 유형에 액세스 할 수 있는지 여부를 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사합니다 . OID가 아닌 텍스트 문자열로 유형을 지정할 때 허용되는 입력은 &lt;code&gt;regtype&lt;/code&gt; 데이터 유형 과 동일 합니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;8.19 절&lt;/a&gt; 참조 ). 원하는 액세스 권한 유형은 &lt;code&gt;USAGE&lt;/code&gt; 로 평가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="925a8cc73d4d4c9e7f4c443cb4591a7505a499dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_bitmap_info&lt;/code&gt; shows the status of a bit in the bitmap page for a particular overflow page of HASH index. For example:</source>
          <target state="translated">&lt;code&gt;hash_bitmap_info&lt;/code&gt; 는 HASH 인덱스의 특정 오버 플로우 페이지에 대한 비트 맵 페이지의 비트 상태를 보여줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3eff38539ebcb82ad70c11dcf0e9a38db1ac061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_metapage_info&lt;/code&gt; returns information stored in meta page of a HASH index. For example:</source>
          <target state="translated">&lt;code&gt;hash_metapage_info&lt;/code&gt; 는 HASH 인덱스의 메타 페이지에 저장된 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b6c88e5c03b8a5912f5ce2658cc2c1f5ffff300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_page_items&lt;/code&gt; returns information about the data stored in a bucket or overflow page of a HASH index page. For example:</source>
          <target state="translated">&lt;code&gt;hash_page_items&lt;/code&gt; 는 HASH 인덱스 페이지의 버킷 또는 오버플로 페이지에 저장된 데이터에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="881601e295b0b07ce3a4e8cb0e71feea84d4ec73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_page_stats&lt;/code&gt; returns information about a bucket or overflow page of a HASH index. For example:</source>
          <target state="translated">&lt;code&gt;hash_page_stats&lt;/code&gt; 는 HASH 인덱스의 버킷 또는 오버플로 페이지에 대한 정보를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="943313969bcf416e28cf96189d05b7426af40e5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_page_type&lt;/code&gt; returns page type of the given HASH index page. For example:</source>
          <target state="translated">&lt;code&gt;hash_page_type&lt;/code&gt; 은 주어진 HASH 인덱스 페이지의 페이지 유형을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79714565df249ba78cec96ea2ebfd2a19e55eb15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hba_file&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;hba_file&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="da237b220389716f79d63434781dec3838f361ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;heap_page_item_attrs&lt;/code&gt; is equivalent to &lt;code&gt;heap_page_items&lt;/code&gt; except that it returns tuple raw data as an array of attributes that can optionally be detoasted by &lt;em&gt;&lt;code&gt;do_detoast&lt;/code&gt;&lt;/em&gt; which is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;heap_page_item_attrs&lt;/code&gt; 는 동등 &lt;code&gt;heap_page_items&lt;/code&gt; 가 선택적으로 detoasted 수있는 속성의 배열로 튜플 원시 데이터를 반환하는 것을 제외 &lt;em&gt; &lt;code&gt;do_detoast&lt;/code&gt; &lt;/em&gt; 이다 &lt;code&gt;false&lt;/code&gt; 기본적.</target>
        </trans-unit>
        <trans-unit id="0ba5daf18d31434afe310c11a3226a9134c7e33a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;heap_page_items&lt;/code&gt; shows all line pointers on a heap page. For those line pointers that are in use, tuple headers as well as tuple raw data are also shown. All tuples are shown, whether or not the tuples were visible to an MVCC snapshot at the time the raw page was copied.</source>
          <target state="translated">&lt;code&gt;heap_page_items&lt;/code&gt; 는 힙 페이지의 모든 행 포인터를 표시합니다. 사용중인 선 포인터의 경우 튜플 헤더와 튜플 원시 데이터도 표시됩니다. 원시 페이지를 복사 할 때 튜플이 MVCC 스냅 샷에 표시되었는지 여부에 관계없이 모든 튜플이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c31194d7ad1a239a6310ad48c41265298dfce38e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hostname&lt;/code&gt; is the fully qualified host name of the server machine. The service principal's realm is the preferred realm of the server machine.</source>
          <target state="translated">&lt;code&gt;hostname&lt;/code&gt; 은 서버 시스템의 완전한 호스트 이름입니다. 서비스 주체의 영역은 서버 컴퓨터의 기본 영역입니다.</target>
        </trans-unit>
        <trans-unit id="f39cccd602aca62bfd8970630c575588e6419b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot_standby&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;hot_standby&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7059027456afd748fbb0326a17c40e8fa4488da4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot_standby_feedback&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;hot_standby_feedback&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="048035795e496c3bd2188a04f4dab8b36985090c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt; also supports &lt;code&gt;btree&lt;/code&gt; or &lt;code&gt;hash&lt;/code&gt; indexes for the &lt;code&gt;=&lt;/code&gt; operator. This allows &lt;code&gt;hstore&lt;/code&gt; columns to be declared &lt;code&gt;UNIQUE&lt;/code&gt;, or to be used in &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;DISTINCT&lt;/code&gt; expressions. The sort ordering for &lt;code&gt;hstore&lt;/code&gt; values is not particularly useful, but these indexes may be useful for equivalence lookups. Create indexes for &lt;code&gt;=&lt;/code&gt; comparisons as follows:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 는 &lt;code&gt;=&lt;/code&gt; 연산자에 대한 &lt;code&gt;btree&lt;/code&gt; 또는 &lt;code&gt;hash&lt;/code&gt; 인덱스 도 지원합니다 . 이를 통해 &lt;code&gt;hstore&lt;/code&gt; 컬럼을 &lt;code&gt;UNIQUE&lt;/code&gt; 로 선언 하거나 &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;DISTINCT&lt;/code&gt; 표현식에서 사용할 수 있습니다. &lt;code&gt;hstore&lt;/code&gt; 값 의 정렬 순서 는 특별히 유용하지 않지만 이러한 색인은 동등성 조회에 유용 할 수 있습니다. 다음과 같이 &lt;code&gt;=&lt;/code&gt; 비교에 대한 색인을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="76c596db31e59852973f2f3deeaac13a262117c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt; has GiST and GIN index support for the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;?&amp;amp;&lt;/code&gt; and &lt;code&gt;?|&lt;/code&gt; operators. For example:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 는 에 대한 GIST 및 GIN 인덱스 지원이 &lt;code&gt;@&amp;gt;&lt;/code&gt; 을 , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;?&amp;amp;&lt;/code&gt; 및 &lt;code&gt;?|&lt;/code&gt; 연산자. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fcd643ad16547fceeb841b670e3a29725bd20c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e35010231154aaa4965d2f91ef93ec8ed3eac86b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b644228a71e9a08e715e5f3d496483d8a0a10202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc4f59f8d0cac68e69fc72fea93246673925e0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45df399e5d3fd59cb2795c245b2e11729c701e9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db11a45446f183011d414584f670be95636e84aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ea72858f11fc73fdc070e84665cb1ece8fc008a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?&amp;amp;&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?&amp;amp;&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="103819f79bc3ad36c8f07511f836d3fd8c439c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98991275a745ee31eba8b654a9d5866c27873fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?|&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;?|&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f91b9a66e2b69af458181f3bb3017a71d5356ce2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4da2966833097426159c1bde51ff80ba4173db1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9647f6b77eef7054ca67ef90301dc25ab4aaf3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;huge_pages&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;huge_pages&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1cde0396063e4eff02dc263a9dd2cc0341c8d0ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; = &lt;code&gt;int&lt;/code&gt; alignment (4 bytes on most machines).</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; = &lt;code&gt;int&lt;/code&gt; alignment (대부분의 컴퓨터에서 4 바이트).</target>
        </trans-unit>
        <trans-unit id="2b7aec3640bb7be23d41a40154d5349185acb99e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ident_file&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ident_file&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="eb41135eee4ad3df93f5e4488f71c9e8e0359d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle in transaction (aborted)&lt;/code&gt;: This state is similar to &lt;code&gt;idle in transaction&lt;/code&gt;, except one of the statements in the transaction caused an error.</source>
          <target state="translated">&lt;code&gt;idle in transaction (aborted)&lt;/code&gt; :이 상태는 &lt;code&gt;idle in transaction&lt;/code&gt; 의 명령문 중 하나가 오류를 일으킨다는 점을 제외하고 는 트랜잭션의 유휴 상태와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ee9c5b114a2acf8865725c01cf4e1e451af89e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle in transaction&lt;/code&gt;: The backend is in a transaction, but is not currently executing a query.</source>
          <target state="translated">&lt;code&gt;idle in transaction&lt;/code&gt; : 백엔드가 트랜잭션에 있지만 현재 쿼리를 실행하고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45c50b8305648a2a66593083286cc416537ed157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle&lt;/code&gt;: The backend is waiting for a new client command.</source>
          <target state="translated">&lt;code&gt;idle&lt;/code&gt; : 백엔드가 새로운 클라이언트 명령을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceae670548de2cf4eed16a4a9adeaacff663e5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle_in_transaction_session_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;idle_in_transaction_session_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5eaabd95ca436da9e621890ec9363fa984f1fcaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore_checksum_failure&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ignore_checksum_failure&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4dfd64f5eb89493949e4dc09fc8561c72ee1df82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore_system_indexes&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ignore_system_indexes&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0cc12c03555bb5d4005154ec068fd6847b80d547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in_range&lt;/code&gt; functions need not handle NULL inputs, and typically will be marked strict.</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 함수는 NULL 입력을 처리 할 필요가 없으며 일반적으로 엄격으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d63bed29721e33049e514c1472d0d389139d890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inet&lt;/code&gt;, &lt;code&gt;cidr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; , &lt;code&gt;cidr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae5d3171d34546b0ca0442665a5500bc41f8677" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inet_client_addr&lt;/code&gt; returns the IP address of the current client, and &lt;code&gt;inet_client_port&lt;/code&gt; returns the port number. &lt;code&gt;inet_server_addr&lt;/code&gt; returns the IP address on which the server accepted the current connection, and &lt;code&gt;inet_server_port&lt;/code&gt; returns the port number. All these functions return NULL if the current connection is via a Unix-domain socket.</source>
          <target state="translated">&lt;code&gt;inet_client_addr&lt;/code&gt; 은 현재 클라이언트의 IP 주소를 반환 하고 &lt;code&gt;inet_client_port&lt;/code&gt; 는 포트 번호를 반환합니다. &lt;code&gt;inet_server_addr&lt;/code&gt; 은 서버가 현재 연결을 수락 한 IP 주소를 반환 하고 &lt;code&gt;inet_server_port&lt;/code&gt; 는 포트 번호를 반환합니다. 현재 연결이 Unix 도메인 소켓을 통한 경우 이러한 모든 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5834e048e0013825fdcdc5794f7b7b43d91e6e4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;directory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;directory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43f232fd5c5179cae7bb7ba7afbcb6ee4c3b7768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; also initializes the default locale for the database cluster. Normally, it will just take the locale settings in the environment and apply them to the initialized database. It is possible to specify a different locale for the database; more information about that can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;. The default sort order used within the particular database cluster is set by &lt;code&gt;initdb&lt;/code&gt;, and while you can create new databases using different sort order, the order used in the template databases that initdb creates cannot be changed without dropping and recreating them. There is also a performance impact for using locales other than &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. Therefore, it is important to make this choice correctly the first time.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 또한 데이터베이스 클러스터의 기본 로케일을 초기화합니다. 일반적으로 환경의 로케일 설정 만 사용하여 초기화 된 데이터베이스에 적용합니다. 데이터베이스에 다른 로케일을 지정할 수 있습니다. 이에 대한 자세한 정보는 &lt;a href=&quot;locale&quot;&gt;섹션 23.1&lt;/a&gt; 에서 찾을 수 있습니다 . 특정 데이터베이스 클러스터 내에서 사용되는 기본 정렬 순서는 &lt;code&gt;initdb&lt;/code&gt; 에 의해 설정되며 , 다른 정렬 순서를 사용하여 새 데이터베이스를 작성할 수 있지만 initdb가 작성하는 템플리트 데이터베이스에서 사용되는 순서는 삭제 및 재 작성없이 변경 될 수 없습니다. &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;POSIX&lt;/code&gt; 이외의 로케일을 사용하면 성능에 영향을 줍니다. 따라서이 선택을 처음으로 올바르게하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="46e7d56245285b39213066fb38c447262f325896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; also sets the default character set encoding for the database cluster. Normally this should be chosen to match the locale setting. For details see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 데이터베이스 클러스터의 기본 문자 세트 인코딩도 설정합니다. 일반적으로 로케일 설정과 일치하도록 선택해야합니다. 자세한 내용은 &lt;a href=&quot;multibyte&quot;&gt;23.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89e75108c38ae85d1eec121d73533e961034b69b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; can also be invoked via &lt;code&gt;pg_ctl initdb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 &lt;code&gt;pg_ctl initdb&lt;/code&gt; 를 통해 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b3a51ff2f952517fff946f18ffa28fcc99191bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; creates a new PostgreSQL database cluster. A database cluster is a collection of databases that are managed by a single server instance.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 새로운 PostgreSQL 데이터베이스 클러스터를 생성합니다. 데이터베이스 클러스터는 단일 서버 인스턴스로 관리되는 데이터베이스 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b648d5f2ee182c20f10eec9d1407498f8db0c968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; defines the default character set (encoding) for a PostgreSQL cluster. For example,</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 PostgreSQL 클러스터의 기본 문자 세트 (인코딩)를 정의합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a7f045517f19cee9c428a5ffbf1896e22eb00144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; initializes the database cluster's default locale and character set encoding. The character set encoding, collation order (&lt;code&gt;LC_COLLATE&lt;/code&gt;) and character set classes (&lt;code&gt;LC_CTYPE&lt;/code&gt;, e.g. upper, lower, digit) can be set separately for a database when it is created. &lt;code&gt;initdb&lt;/code&gt; determines those settings for the &lt;code&gt;template1&lt;/code&gt; database, which will serve as the default for all other databases.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 데이터베이스 클러스터의 기본 로케일 및 문자 세트 인코딩을 초기화합니다. 문자 세트 인코딩, 조합 순서 ( &lt;code&gt;LC_COLLATE&lt;/code&gt; ) 및 문자 세트 클래스 ( &lt;code&gt;LC_CTYPE&lt;/code&gt; , 예를 들어 상위, 하위, 숫자)는 데이터베이스를 작성할 때 데이터베이스에 대해 별도로 설정할 수 있습니다. &lt;code&gt;initdb&lt;/code&gt; 는 &lt;code&gt;template1&lt;/code&gt; 데이터베이스에 대한 설정을 결정합니다.이 설정은 다른 모든 데이터베이스의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e0770a6b0251660b276043f28ba9f4f48233a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; must be run as the user that will own the server process, because the server needs to have access to the files and directories that &lt;code&gt;initdb&lt;/code&gt; creates. Since the server cannot be run as root, you must not run &lt;code&gt;initdb&lt;/code&gt; as root either. (It will in fact refuse to do so.)</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 서버는 &lt;code&gt;initdb&lt;/code&gt; 가 작성 하는 파일 및 디렉토리에 액세스 할 수 있어야하므로 서버 프로세스를 소유 할 사용자로 initdb 를 실행해야합니다 . 서버를 루트로 실행할 수 없으므로 &lt;code&gt;initdb&lt;/code&gt; 를 루트로 실행해서는 안됩니다 . (실제로 그렇게 거부합니다.)</target>
        </trans-unit>
        <trans-unit id="001ae24e3673b68bc293d6b72d82d6dff279bc46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; will attempt to create the directory you specify if it does not already exist. Of course, this will fail if &lt;code&gt;initdb&lt;/code&gt; does not have permissions to write in the parent directory. It's generally recommendable that the PostgreSQL user own not just the data directory but its parent directory as well, so that this should not be a problem. If the desired parent directory doesn't exist either, you will need to create it first, using root privileges if the grandparent directory isn't writable. So the process might look like this:</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 는 지정한 디렉토리가 존재하지 않는 경우 지정한 디렉토리를 작성하려고 시도합니다. 물론, &lt;code&gt;initdb&lt;/code&gt; 에 부모 디렉토리에 쓸 수있는 권한이 없으면 실패합니다 . 일반적으로 PostgreSQL 사용자는 데이터 디렉토리뿐만 아니라 상위 디렉토리도 소유하므로 문제가되지 않도록 권장합니다. 원하는 상위 디렉토리가 없으면 조부모 디렉토리에 쓰기 가능하지 않은 경우 루트 권한을 사용하여 먼저 작성해야합니다. 따라서 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="676bf77e9ad2c087a6e4c720856193e3f1dbd5cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initdb&lt;/code&gt; will refuse to run if the data directory exists and already contains files; this is to prevent accidentally overwriting an existing installation.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; 데이터 디렉토리가 존재하고 이미 파일이 들어 있으면 initdb 는 실행을 거부합니다. 이는 실수로 기존 설치를 덮어 쓰지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d43822caf757ead44eb5f39c768ef15d451f9ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline_handler&lt;/code&gt; is the name of a previously registered function that will be called to execute an anonymous code block (&lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt; command) in this language. If no &lt;code&gt;inline_handler&lt;/code&gt; function is specified, the language does not support anonymous code blocks. The handler function must take one argument of type &lt;code&gt;internal&lt;/code&gt;, which will be the &lt;code&gt;DO&lt;/code&gt; command's internal representation, and it will typically return &lt;code&gt;void&lt;/code&gt;. The return value of the handler is ignored.</source>
          <target state="translated">&lt;code&gt;inline_handler&lt;/code&gt; 는 이 언어로 익명 코드 블록 ( &lt;a href=&quot;sql-do&quot;&gt;DO&lt;/a&gt; 명령) 을 실행하기 위해 호출 될 이전에 등록 된 함수의 이름입니다 . 어떤 경우 &lt;code&gt;inline_handler&lt;/code&gt; 의 기능이 지정되지 않은 언어는 익명 코드 블록을 지원하지 않습니다. 핸들러 함수는 &lt;code&gt;internal&lt;/code&gt; 유형의 인수 하나를 가져와야합니다.이 인수 는 &lt;code&gt;DO&lt;/code&gt; 명령의 내부 표현이며 일반적으로 &lt;code&gt;void&lt;/code&gt; 를 리턴 합니다. 핸들러의 리턴 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd68691a84634eb5d83b41f2d50a8fff510fc617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_username()&lt;/code&gt; is a trigger that stores the current user's name into a text field. This can be useful for tracking who last modified a particular row within a table.</source>
          <target state="translated">&lt;code&gt;insert_username()&lt;/code&gt; 은 현재 사용자 이름을 텍스트 필드에 저장하는 트리거입니다. 테이블에서 특정 행을 마지막으로 수정 한 사람을 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44763bab87be822afb72fdd07ce3537e7926fbfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt; or &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 또는 &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="350b0c201108cfdab51dec38570223cac3273f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e188b4421b80111d5d5ac942762d05921a992c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intarray&lt;/code&gt; provides index support for the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, and &lt;code&gt;@@&lt;/code&gt; operators, as well as regular array equality.</source>
          <target state="translated">&lt;code&gt;intarray&lt;/code&gt; 는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; 및 &lt;code&gt;@@&lt;/code&gt; 연산자에 대한 인덱스 지원 과 일반 배열 동일성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fbf91b86add3d17a05bd29d99786cabd55261a60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer '3'&lt;/code&gt; (days)</source>
          <target state="translated">&lt;code&gt;integer '3'&lt;/code&gt; (일)</target>
        </trans-unit>
        <trans-unit id="58ee64a373b860372a62ecb4257715b8eba9d622" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer_datetimes&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;integer_datetimes&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="516893827a21b7608110c5376e6e7f92da229423" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; values can be written using the following verbose syntax:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 다음과 같은 자세한 구문을 사용하여 간격 값을 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd54d114de2f599969c9c4747682f9f88142af8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="81711706c9d98b1591f5574c0e725af9e3c9825b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_above_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_above_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="861fec9d34c86479ecdd1b034e6cb045ac6c481a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_debugging_support&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_debugging_support&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="feafeac24244487a580fb8f7576c3df3cbacd216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_dump_bitcode&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_dump_bitcode&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="471257c36efa89fc91292a45afe6a42956c31270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_expressions&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_expressions&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93499a75d09a745f1f2bd94752d3929af0be3288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_inline_above_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_inline_above_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c3f98b4c137aef8acf1a1db59e11538ad0e85bc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_optimize_above_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_optimize_above_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="903dff5cd0abb961d776a524070ab9c62235a0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_profiling_support&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_profiling_support&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a73ab9cdb8974f12d3fe489562167e24adae2f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_provider&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_provider&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ff2d2dc035020dd0f2ae478afacdc76076c91f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jit_tuple_deforming&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jit_tuple_deforming&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f7da9f7154d935b4d98d3d27d35656116083d9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_collapse_limit&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;join_collapse_limit&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5a37182e8ea9ee100a024ccab165e27f310ce796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_condition&lt;/code&gt; is an expression resulting in a value of type &lt;code&gt;boolean&lt;/code&gt; (similar to a &lt;code&gt;WHERE&lt;/code&gt; clause) that specifies which rows in a join are considered to match.</source>
          <target state="translated">&lt;code&gt;join_condition&lt;/code&gt; 은 조인에서 일치하는 것으로 간주되는 행을 지정하는 &lt;code&gt;boolean&lt;/code&gt; 유형 ( &lt;code&gt;WHERE&lt;/code&gt; 절 과 유사) 의 값을 생성하는 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="6177cf689759ceab1df6a3eec3f73f3250ab214b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95eacaa192f18d94d4b7c16fc8d4b4f6c8b235b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jsonb&lt;/code&gt; also has an &lt;em&gt;existence&lt;/em&gt; operator, which is a variation on the theme of containment: it tests whether a string (given as a &lt;code&gt;text&lt;/code&gt; value) appears as an object key or array element at the top level of the &lt;code&gt;jsonb&lt;/code&gt; value. These examples return true except as noted:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; 에는 &lt;em&gt;존재&lt;/em&gt; 연산자가 있는데, 이것은 포함 주제를 변형 한 것입니다. 문자열 ( &lt;code&gt;text&lt;/code&gt; 값 으로 주어진 )이 &lt;code&gt;jsonb&lt;/code&gt; 값 의 최상위 레벨에서 객체 키 또는 배열 요소로 나타나는지 테스트 합니다. 이 예제는 명시된 경우를 제외하고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3358b99c5907d871cde32b9834e8bb7e60059012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jsonb&lt;/code&gt; also supports &lt;code&gt;btree&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt; indexes. These are usually useful only if it's important to check equality of complete JSON documents. The &lt;code&gt;btree&lt;/code&gt; ordering for &lt;code&gt;jsonb&lt;/code&gt; datums is seldom of great interest, but for completeness it is:</source>
          <target state="translated">&lt;code&gt;jsonb&lt;/code&gt; 는 &lt;code&gt;btree&lt;/code&gt; 및 &lt;code&gt;hash&lt;/code&gt; 인덱스 도 지원 합니다. 이들은 일반적으로 완전한 JSON 문서가 동일한 지 확인하는 것이 중요한 경우에만 유용합니다. &lt;code&gt;btree&lt;/code&gt; 대한 주문 &lt;code&gt;jsonb&lt;/code&gt; 데이텀은 큰 관심의 거의 없지만, 완성도를 위해이다 :</target>
        </trans-unit>
        <trans-unit id="3f940572221afd1132f73f2ae85c88042a64ae69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;jsonpath&lt;/code&gt; &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;섹션 9.15.2.3에&lt;/a&gt; 나열된 jsonpath 연산자 및 메소드</target>
        </trans-unit>
        <trans-unit id="68c2654d19f9a054ac4aa2746dec03c8c49988d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keeporig&lt;/code&gt; controls whether the original word is included in the dictionary's output. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;keeporig&lt;/code&gt; 는 원래 단어가 사전의 출력에 포함되는지 여부를 제어합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ad6f1255cbf3cd54b0a87c4d5e1139487fa7565d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keepsynonyms&lt;/code&gt; controls whether the synonyms are included in the dictionary's output. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;keepsynonyms&lt;/code&gt; 는 동의어가 사전의 출력에 포함되는지 여부를 제어합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="013ca863e71b9f524032b2cbc0f74a3c12b7a144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill&lt;/code&gt; mode sends a signal to a specified process. This is primarily valuable on Microsoft Windows which does not have a built-in kill command. Use &lt;code&gt;--help&lt;/code&gt; to see a list of supported signal names.</source>
          <target state="translated">&lt;code&gt;kill&lt;/code&gt; 모드는 지정된 프로세스로 신호를 보냅니다. 이는 기본적으로 kill 명령이없는 Microsoft Windows에서 중요합니다. 지원되는 신호 이름 목록을 보려면 &lt;code&gt;--help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a239d6939a98413a611db13ae4bc8f00c04d3e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;krb_caseins_users&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;krb_caseins_users&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9f9b605f77515a387c886560784cb0275c97b94e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;krb_server_keyfile&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;krb_server_keyfile&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="92f617ad6e40ee89e98e61a8580597138f5f27e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&amp;oacute;gico&lt;/code&gt; or &lt;code&gt;matem&amp;aacute;tica&lt;/code&gt; in the context &lt;code&gt;l&amp;oacute;gico-matem&amp;aacute;tica&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l&amp;oacute;gico&lt;/code&gt; 문맥에서 l&amp;oacute;gico 또는 &lt;code&gt;matem&amp;aacute;tica&lt;/code&gt; &lt;code&gt;l&amp;oacute;gico-matem&amp;aacute;tica&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10018993bf6931f02e063488d9336416d2759a43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_collate&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_collate&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e11eab7b3c2031cb1062bfe8a486305149f5fcc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_ctype&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_ctype&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d7896d5ad8aba3468a4fdf2767be119af5d2c4dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_messages&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_messages&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="daf108cb2c9aa51a695b236959b16148a29ab577" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_monetary&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_monetary&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8d51c18c10b4c0e7c1d7cc8e2d61df5631da7dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_numeric&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_numeric&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ce2123b6888100aa1b3f64e87fc507d055cfea54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lc_time&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lc_time&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ed798ed7c3779a88d3f4965993f4d27a59ee797e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;leafType&lt;/code&gt; is typically the same as &lt;code&gt;attType&lt;/code&gt;. For the reasons of backward compatibility, method &lt;code&gt;config&lt;/code&gt; can leave &lt;code&gt;leafType&lt;/code&gt; uninitialized; that would give the same effect as setting &lt;code&gt;leafType&lt;/code&gt; equal to &lt;code&gt;attType&lt;/code&gt;. When &lt;code&gt;attType&lt;/code&gt; and &lt;code&gt;leafType&lt;/code&gt; are different, then optional method &lt;code&gt;compress&lt;/code&gt; must be provided. Method &lt;code&gt;compress&lt;/code&gt; is responsible for transformation of datums to be indexed from &lt;code&gt;attType&lt;/code&gt; to &lt;code&gt;leafType&lt;/code&gt;. Note: both consistent functions will get &lt;code&gt;scankeys&lt;/code&gt; unchanged, without transformation using &lt;code&gt;compress&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;leafType&lt;/code&gt; 은 일반적으로 &lt;code&gt;attType&lt;/code&gt; 과 동일합니다 . 이전 버전과의 호환성을 위해 메소드 &lt;code&gt;config&lt;/code&gt; 은 &lt;code&gt;leafType&lt;/code&gt; 을 초기화되지 않은 상태로 둘 수 있습니다 . 로 설정 즉, 동일한 효과를 줄 것이다 &lt;code&gt;leafType&lt;/code&gt; 가 동일 &lt;code&gt;attType&lt;/code&gt; . 때 &lt;code&gt;attType&lt;/code&gt; 및 &lt;code&gt;leafType&lt;/code&gt; 는 다른, 다음 선택 방법 &lt;code&gt;compress&lt;/code&gt; 제공해야합니다. 방법 &lt;code&gt;compress&lt;/code&gt; 데이텀 변환에서 인덱싱 할 책임이있다 &lt;code&gt;attType&lt;/code&gt; 에 &lt;code&gt;leafType&lt;/code&gt; . 참고 : 두 가지 일관된 함수는 &lt;code&gt;compress&lt;/code&gt; 를 사용하여 변환하지 않고 &lt;code&gt;scankeys&lt;/code&gt; 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0687afde5592bc7f45a78dd862e4c560ce1632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_type&lt;/code&gt;&lt;code&gt;right_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;left_type&lt;/code&gt;&lt;code&gt;right_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60d83a50f921fce9a15344d3acf305852b9da7e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshtein_less_equal&lt;/code&gt; is an accelerated version of the Levenshtein function for use when only small distances are of interest. If the actual distance is less than or equal to &lt;code&gt;max_d&lt;/code&gt;, then &lt;code&gt;levenshtein_less_equal&lt;/code&gt; returns the correct distance; otherwise it returns some value greater than &lt;code&gt;max_d&lt;/code&gt;. If &lt;code&gt;max_d&lt;/code&gt; is negative then the behavior is the same as &lt;code&gt;levenshtein&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;levenshtein_less_equal&lt;/code&gt; 은 작은 거리에만 관심이있을 때 사용할 수있는 가속 버전의 Levenshtein 기능입니다. 실제 거리 미만이거나 동일하면 &lt;code&gt;max_d&lt;/code&gt; 다음 &lt;code&gt;levenshtein_less_equal&lt;/code&gt; 복귀 정확한 거리; 그렇지 않으면 &lt;code&gt;max_d&lt;/code&gt; 보다 큰 값을 반환합니다 . 경우 &lt;code&gt;max_d&lt;/code&gt; 은 부정적이다 후 동작과 동일 &lt;code&gt;levenshtein&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeaf4891210399d0832741e8f2905a219cae6c2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexemes&lt;/code&gt;&lt;code&gt;text[]&lt;/code&gt; &amp;mdash; the lexeme(s) produced by the dictionary that recognized the token, or &lt;code&gt;NULL&lt;/code&gt; if none did; an empty array (&lt;code&gt;{}&lt;/code&gt;) means it was recognized as a stop word</source>
          <target state="translated">&lt;code&gt;lexemes&lt;/code&gt; &lt;code&gt;text[]&lt;/code&gt; &amp;mdash; 토큰을 인식 한 사전에 의해 생성 된 lexeme, 또는 없는 경우 &lt;code&gt;NULL&lt;/code&gt; . 빈 배열 ( &lt;code&gt;{}&lt;/code&gt; )은 중지 단어로 인식되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cf92996f280a947e41f7035c74e9f77e8883ea0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list-file&lt;/code&gt; is normally created by editing the output of a previous &lt;code&gt;-l&lt;/code&gt; operation. Lines can be moved or removed, and can also be commented out by placing a semicolon (&lt;code&gt;;&lt;/code&gt;) at the start of the line. See below for examples.</source>
          <target state="translated">&lt;code&gt;list-file&lt;/code&gt; 은 일반적으로 이전 &lt;code&gt;-l&lt;/code&gt; 조작 의 출력을 편집하여 작성됩니다 . 줄을 이동하거나 제거 할 수 있으며 줄 의 시작 부분에 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )을 넣어 주석 처리 할 수도 있습니다 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e4879dae19ee0410e8f673b8b66e8f59f9d12aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listen_addresses&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;listen_addresses&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="77b922316f078c8086b5235db98a0986b6b896c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lo_compat_privileges&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lo_compat_privileges&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a0d2b84b5471cba03c4c64a42e21e8e18723e50b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local_preload_libraries&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;local_preload_libraries&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b478b556ed68ac9bc065675bf47dae5237c52c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_timeout&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;lock_timeout&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e10ded8b86a2a12c365fd08dbd9b4cb00264d621" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_autovacuum_min_duration&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_autovacuum_min_duration&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="15bb7f176dedfa942719e1ddbd79322401e7986f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_autovacuum_min_duration&lt;/code&gt;, &lt;code&gt;toast.log_autovacuum_min_duration&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_autovacuum_min_duration&lt;/code&gt; , &lt;code&gt;toast.log_autovacuum_min_duration&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7c717e625f13806ddcee7973586ede7b22107167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_btree_build_stats&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_btree_build_stats&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="56e987cb14bb2ffb561502059f143dd0da601ceb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_checkpoints&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_checkpoints&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6762da1e2aa5471e5be652598a9fa05bd83e1b46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_connections&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_connections&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="530f778694dab371568762164393bc78a8d25fb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_destination&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a81fa99f6f34e462da9ac97debf55daebcdc9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_directory&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_directory&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="350df7bf7b0ddb4f996bdfe47aa37a608664fd37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_disconnections&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_disconnections&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4bdb860a9711a0613d00e74be9a275e137eb36ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_duration&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_duration&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c826696375b53d0c8cd2ce397f6a993ac171287f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_error_verbosity&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_error_verbosity&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ad34c37ed0525dc226201e8951d834639dd42b6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_file_mode&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_file_mode&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="38649ffd9706c182e0e064b3e9fed131cd6e7576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_filename&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_filename&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8f0df8a8557dd5b2c862a02d7b225066f242601b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_hostname&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_hostname&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0a5014a9c4f95e93ab6babf9a770313b108f41d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_line_prefix&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_line_prefix&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6620f6d7fa5775e2f3f2346b3e67cea337bd2234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_lock_waits&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_lock_waits&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e1043f8a69d132ccf008fa25fe2e5d7bb1091180" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_min_duration_statement&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_min_duration_statement&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1b07b83679c270c1829cc681f7c6d9d4220760f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_min_error_statement&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_min_error_statement&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11882f7ae5e4032de0daa525a1c51dae2fa16c87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_min_messages&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_min_messages&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="43c1b3fd48925ac441db68e3388f601293f5827a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_parser_stats = on&lt;/code&gt;, &lt;code&gt;log_planner_stats = on&lt;/code&gt;, &lt;code&gt;log_executor_stats = on&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log_parser_stats = on&lt;/code&gt; , &lt;code&gt;log_planner_stats = on&lt;/code&gt; , &lt;code&gt;log_executor_stats = on&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e50803b9654b2d176d4908d54119c2c4cf236214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_replication_commands&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_replication_commands&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0f3e84a4b2ff078eb85256d1ce5fd758381b2599" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_rotation_age&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_rotation_age&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8307ad4b9369fa25cc7e30b8370983873b64c451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_rotation_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_rotation_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="34e08a48c15f245d9b88d7a0784e015f43ce2e8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_statement&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_statement&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b24e49d2b1e709644c805f6880853ab84166a5fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_statement_stats&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)  &lt;code&gt;log_parser_stats&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)  &lt;code&gt;log_planner_stats&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)  &lt;code&gt;log_executor_stats&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_statement_stats&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; ) &lt;code&gt;log_parser_stats&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; ) &lt;code&gt;log_planner_stats&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; ) &lt;code&gt;log_executor_stats&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="609d37a4039ecd05038ea47619387045d739f551" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_temp_files&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_temp_files&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c79999d8c8d00320536f70d7350c41ea59a05162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_timezone&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_timezone&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="307bd946a86f9b4f336f2f473c26fe250adde340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_transaction_sample_rate&lt;/code&gt; (&lt;code&gt;real&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_transaction_sample_rate&lt;/code&gt; ( &lt;code&gt;real&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2946759057dfb5d4d61348ddf0d41fc073014c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_truncate_on_rotation&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;log_truncate_on_rotation&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5a92a0740927d9a99697b5ffc17993abcb27279d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logging_collector&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3c405ed8723ba8ba2fc19708556bfb7e70168ee0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logrotate&lt;/code&gt; mode rotates the server log file. For details on how to use this mode with external log rotation tools, see &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;logrotate&lt;/code&gt; 모드는 서버 로그 파일을 회전시킵니다. 이 모드를 외부 로그 회전 도구와 함께 사용하는 방법에 대한 자세한 내용 &lt;a href=&quot;logfile-maintenance&quot;&gt;은 24.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3603d76f8b842d4f0f099832432440480fab9f66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lquery&lt;/code&gt; represents a regular-expression-like pattern for matching &lt;code&gt;ltree&lt;/code&gt; values. A simple word matches that label within a path. A star symbol (&lt;code&gt;*&lt;/code&gt;) matches zero or more labels. For example:</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; 는 &lt;code&gt;ltree&lt;/code&gt; 값 을 일치시키기위한 정규식과 유사한 패턴을 나타냅니다 . 간단한 단어가 경로 내의 해당 레이블과 일치합니다. 별표 기호 ( &lt;code&gt;*&lt;/code&gt; )는 0 개 이상의 레이블과 일치합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83f37c7bb74a01de5d41489475b6162da54dbcd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lquery&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0058b9537891d33bc60cf43fe318ff82a584876b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lquery&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c82d6102bd22776f4ef80920b16ae1e9699499d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lquery[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lquery[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f0993bc3a11d383765fb8d6e7767214355d6761" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lquery[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lquery[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d48716da30d2c2db7edb6b84420cd90c86711fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt; stores a label path.</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 는 레이블 경로를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="820faf63f0dac8a15b27d082789f7a7c0986e7ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt; supports several types of indexes that can speed up the indicated operators:</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 는 표시된 연산자의 속도를 높일 수있는 여러 유형의 색인을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="41237918f09bb512502274ea872320ecc1ad90de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab542d26a63241dfbe9ee789f5983c39f0f9a52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4f5c39bdd9d80f9f3d3f6fb3b8284e7534c77b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;lquery[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;lquery[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e672b2e250225f49099958286ec873cb928b726" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5770793ae9b5cbe99eefde87e524494e6649d08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="085990014bbf0b1dfb3d17bcdafbab64fb7e6ecc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbe3edb8d405f0748d99003c67f9551b908001ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96a6be831d5493067e065407a77c72c82be8ff1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae07083d89ff15720902195709d906ad19c3e3a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5147853874e38336a0c8b975f5f3ad2118d90a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e676c07ac15b4c95194e9f3f043dc096d3f6c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?&amp;lt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19f276fc6c6918c8e4c79c5658637085ccb9b939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;lquery[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?&lt;/code&gt;&lt;code&gt;lquery[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba44468d32fd25dfa90d60682b04400f7ff349ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2854026887b0186e958d50197a6361cb54fc1eeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88aa97cec6453ecc4b3cce9e099285c94ecfe401" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;?~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f757cea553f320455dd943e5dd5bcef6a106cdf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a283a522f2e2c121ae71ed7f0c16498b9313a2ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltxtquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfbbe52f02c6d2c8ae758cda75237a8f61c4c617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree[]&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;lquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d2a791097604da4e506d02c68b746d849b92410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltxtquery&lt;/code&gt; represents a full-text-search-like pattern for matching &lt;code&gt;ltree&lt;/code&gt; values. An &lt;code&gt;ltxtquery&lt;/code&gt; value contains words, possibly with the modifiers &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; at the end; the modifiers have the same meanings as in &lt;code&gt;lquery&lt;/code&gt;. Words can be combined with &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), &lt;code&gt;!&lt;/code&gt; (NOT), and parentheses. The key difference from &lt;code&gt;lquery&lt;/code&gt; is that &lt;code&gt;ltxtquery&lt;/code&gt; matches words without regard to their position in the label path.</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt; 는 &lt;code&gt;ltree&lt;/code&gt; 값 을 일치시키기위한 전체 텍스트 검색과 유사한 패턴을 나타냅니다 . &lt;code&gt;ltxtquery&lt;/code&gt; 의 값이 아마도 개질제와 단어가 포함 &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 말; 수정자는 &lt;code&gt;lquery&lt;/code&gt; 와 동일한 의미를 갖 습니다 . 단어는 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (또는) &lt;code&gt;!&lt;/code&gt; (아니요) 및 괄호. 에서 중요한 차이점 &lt;code&gt;lquery&lt;/code&gt; 은 즉 &lt;code&gt;ltxtquery&lt;/code&gt; 이 레이블 경로에서의 위치에 관계없이 단어를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5525454f25ac999a9ea770054b4e6e9f78570c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltxtquery&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltree&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d15e02685cb240a4f59cf836c8161abb7208aa23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ltxtquery&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt;&lt;code&gt;@&lt;/code&gt;&lt;code&gt;ltree[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ced310c28fb8293b55da28f283eaabbdb1b5f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;: Value can be stored compressed inline.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; : 압축 인라인으로 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d9d0ffbb953d3d59437a26d572ff1d787cf2d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maintenance_work_mem&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;maintenance_work_mem&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="332020ec43ad3b89ad7d9af43b32eca23ecd2923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matchorig&lt;/code&gt; controls whether the original word is accepted by the dictionary. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matchorig&lt;/code&gt; 는 사전에서 원래 단어를 수락할지 여부를 제어합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b779615f5ec2a317b354d1f1f24ae3f368cfee0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matchsynonyms&lt;/code&gt; controls whether the synonyms are accepted by the dictionary. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matchsynonyms&lt;/code&gt; 는 동의어가 사전에서 허용되는지 여부를 제어합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2da7e658ce488d0bffd5949f9e753444e63357ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_connections&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_connections&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e3f5a0f1be5c666431ad972909df3bdd4705d0b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_files_per_process&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_files_per_process&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3072f973227480e5f969df72a13e6c92ae0478e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_function_args&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_function_args&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3b26883ebd9ee86036a128233a8ebd11135c7e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_identifier_length&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_identifier_length&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1d7553fb0e9487e750b26d58acabc156adaede30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_index_keys&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_index_keys&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b105e16edcfcb1e58a4f8648c238a6ed1ab7a292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_locks_per_transaction&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_locks_per_transaction&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="24bb1dc77ec0566dc4f63416f436666f37368aea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_logical_replication_workers&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_logical_replication_workers&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1549fc9e830f139946aadecd7eaba41f69a57955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel_maintenance_workers&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_parallel_maintenance_workers&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0c7451c77db330b90ad4925e243018de82a44b6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel_workers&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_parallel_workers&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="70cbc58b8dec1a84b89bc88986e1c8b317d3757d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel_workers_per_gather&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_parallel_workers_per_gather&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7ca4d4484b58866da25d1188336cce3f92f1a176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_pred_locks_per_page&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_pred_locks_per_page&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cd174b36cc15883c6f78c215283dd33efb5560e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_pred_locks_per_relation&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_pred_locks_per_relation&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c90ec3d79fde7b257b910585dcdbf843f158e306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9611fdea70036f4cb5415739060eefb9c4c55890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_prepared_transactions&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_prepared_transactions&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc742f2fa39eabe2b5f755018d3ff500612e88cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_replication_slots&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_replication_slots&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fa6bb1cb41bbab909d43bfd82f00acaa94c2f40f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_stack_depth&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_stack_depth&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ffdcd931a0baea11ef2110d228782f9576b87045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_standby_archive_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_standby_archive_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6d9897714f83842c4bc4ac0806c38e8ede86c6d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_standby_streaming_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_standby_streaming_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c821fc253a20ad709ca3048fa75c9e64b21f5734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_sync_workers_per_subscription&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_sync_workers_per_subscription&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="87431cd6134277984fab37d22984edff31366ff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_wal_senders&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_wal_senders&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98c2c8ca70311dabdea5676432f3bb3de59c7d6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_wal_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_wal_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8f715c62cdb9002e26f31c8753ae634741a3bb0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_worker_processes&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;max_worker_processes&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e8619d8edf6d299d85ff71bd0a2dd98135d6b9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxvalue&lt;/code&gt;&lt;code&gt;NO MAXVALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;maxvalue&lt;/code&gt; &lt;code&gt;NO MAXVALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="177e760283a4b704b59952248582706dd97b4a14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;md5 hash&lt;/code&gt; numbers are from mdcrack 1.2.</source>
          <target state="translated">&lt;code&gt;md5 hash&lt;/code&gt; 번호는 mdcrack 1.2의 것입니다.</target>
        </trans-unit>
        <trans-unit id="f530576481aa905fc0e0d446495c3ffb8f4b2a10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;md5&lt;/code&gt; (hash)</source>
          <target state="translated">&lt;code&gt;md5&lt;/code&gt; (해시)</target>
        </trans-unit>
        <trans-unit id="8418b9a6624207791bfa07f46457cec915915fe9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_parallel_index_scan_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;min_parallel_index_scan_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="71279623d2981d4f5ef2f2c86c12cf6d8d000998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_parallel_table_scan_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;min_parallel_table_scan_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e1577500d28f5493b380e3aca7e8007f03a47cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_wal_size&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;min_wal_size&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e80af198ce8c54ff6489a6d1a0eab3d398636f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minvalue&lt;/code&gt;&lt;code&gt;NO MINVALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;minvalue&lt;/code&gt; &lt;code&gt;NO MINVALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07793781b183947e6a6aa2730c463e258af796ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moddatetime()&lt;/code&gt; is a trigger that stores the current time into a &lt;code&gt;timestamp&lt;/code&gt; field. This can be useful for tracking the last modification time of a particular row within a table.</source>
          <target state="translated">&lt;code&gt;moddatetime()&lt;/code&gt; 은 현재 시간을 &lt;code&gt;timestamp&lt;/code&gt; 필드에 저장하는 트리거입니다 . 테이블 내 특정 행의 마지막 수정 시간을 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c30e15e6981f5978f40095cab5a0d13f8e7b133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month&lt;/code&gt;/&lt;code&gt;day&lt;/code&gt;/&lt;code&gt;year&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;month&lt;/code&gt;/&lt;code&gt;day&lt;/code&gt;/&lt;code&gt;year&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d8e6fe16ec02f3d91a27b7da467f98a51d89cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mythesaurus&lt;/code&gt; is the base name of the thesaurus configuration file. (Its full name will be &lt;code&gt;$SHAREDIR/tsearch_data/mythesaurus.ths&lt;/code&gt;, where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the installation shared-data directory.)</source>
          <target state="translated">&lt;code&gt;mythesaurus&lt;/code&gt; 는 동의어 사전 구성 파일의 기본 이름입니다. (전체 이름은 &lt;code&gt;$SHAREDIR/tsearch_data/mythesaurus.ths&lt;/code&gt; . 여기서 &lt;code&gt;$SHAREDIR&lt;/code&gt; 은 설치 공유 데이터 디렉토리를 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="8cf65e9b97f9a2834003ae7be69851405535ee0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;&lt;code&gt;none&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt;&lt;code&gt;none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="330f7bbdbcf24ac88ee42950814b6fc360daf2ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nNodes&lt;/code&gt; must be set to the number of child nodes that need to be visited by the search, and &lt;code&gt;nodeNumbers&lt;/code&gt; must be set to an array of their indexes. If the operator class keeps track of levels, set &lt;code&gt;levelAdds&lt;/code&gt; to an array of the level increments required when descending to each node to be visited. (Often these increments will be the same for all the nodes, but that's not necessarily so, so an array is used.) If value reconstruction is needed, set &lt;code&gt;reconstructedValues&lt;/code&gt; to an array of the values of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type reconstructed for each child node to be visited; otherwise, leave &lt;code&gt;reconstructedValues&lt;/code&gt; as NULL. If ordered search is performed, set &lt;code&gt;distances&lt;/code&gt; to an array of distance values according to &lt;code&gt;orderbys&lt;/code&gt; array (nodes with lowest distances will be processed first). Leave it NULL otherwise. If it is desired to pass down additional out-of-band information (&amp;ldquo;traverse values&amp;rdquo;) to lower levels of the tree search, set &lt;code&gt;traversalValues&lt;/code&gt; to an array of the appropriate traverse values, one for each child node to be visited; otherwise, leave &lt;code&gt;traversalValues&lt;/code&gt; as NULL. Note that the &lt;code&gt;inner_consistent&lt;/code&gt; function is responsible for palloc'ing the &lt;code&gt;nodeNumbers&lt;/code&gt;, &lt;code&gt;levelAdds&lt;/code&gt;, &lt;code&gt;distances&lt;/code&gt;, &lt;code&gt;reconstructedValues&lt;/code&gt;, and &lt;code&gt;traversalValues&lt;/code&gt; arrays in the current memory context. However, any output traverse values pointed to by the &lt;code&gt;traversalValues&lt;/code&gt; array should be allocated in &lt;code&gt;traversalMemoryContext&lt;/code&gt;. Each traverse value must be a single palloc'd chunk.</source>
          <target state="translated">&lt;code&gt;nNodes&lt;/code&gt; 는 검색에서 방문해야하는 하위 노드 수로 설정되어야하며 &lt;code&gt;nodeNumbers&lt;/code&gt; 는 색인 배열로 설정되어야합니다. 연산자 클래스가 레벨을 추적 하는 경우 방문 할 각 노드로 내려갈 때 필요한 레벨 증분의 배열에 &lt;code&gt;levelAdds&lt;/code&gt; 를 설정 하십시오 . (이러한 증가분은 모든 노드에서 동일하지만 반드시 그렇지는 않으므로 배열이 사용됩니다.) 값 재구성이 필요한 경우 &lt;code&gt;reconstructedValues&lt;/code&gt; 를 &lt;code&gt;spgConfigOut&lt;/code&gt; 값의 배열로 설정 하십시오 . 방문 할 각 하위 노드에 대해 재구성 된 &lt;code&gt;leafType&lt;/code&gt; 유형. 그렇지 않으면 &lt;code&gt;reconstructedValues&lt;/code&gt; 를 NULL로 두십시오 . 순서 검색을 수행하는 경우 &lt;code&gt;distances&lt;/code&gt; 설정하십시오 &lt;code&gt;orderbys&lt;/code&gt; 배열 에 따라 거리 값의 배열로 (거리가 가장 낮은 노드가 먼저 처리됨). 그렇지 않으면 NULL로 두십시오. 추가 대역 외 정보 ( &quot;횡단 값&quot;)를 트리 검색의 하위 레벨로 전달하려면 &lt;code&gt;traversalValues&lt;/code&gt; 를 방문 할 각 하위 노드마다 하나씩 적절한 순회 값의 배열로 설정하십시오. 그렇지 않으면 &lt;code&gt;traversalValues&lt;/code&gt; 를 NULL로 두십시오 . 참고 것을 &lt;code&gt;inner_consistent&lt;/code&gt; 기능은 palloc'ing에 대한 책임 &lt;code&gt;nodeNumbers&lt;/code&gt; , &lt;code&gt;levelAdds&lt;/code&gt; , &lt;code&gt;distances&lt;/code&gt; , &lt;code&gt;reconstructedValues&lt;/code&gt; 및 &lt;code&gt;traversalValues&lt;/code&gt; 을현재 메모리 컨텍스트의 배열 그러나, 임의의 출력 이송 값이 가리키는 &lt;code&gt;traversalValues&lt;/code&gt; 의 배열에 할당되어야 &lt;code&gt;traversalMemoryContext&lt;/code&gt; . 각 트래버스 값은 하나의 palloc'd 덩어리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="40749108dfe1803b90cd8a75e52acc4cfe839e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nTuples&lt;/code&gt; is the number of leaf tuples provided. &lt;code&gt;datums&lt;/code&gt; is an array of their datum values of &lt;code&gt;spgConfigOut&lt;/code&gt;.&lt;code&gt;leafType&lt;/code&gt; type. &lt;code&gt;level&lt;/code&gt; is the current level that all the leaf tuples share, which will become the level of the new inner tuple.</source>
          <target state="translated">&lt;code&gt;nTuples&lt;/code&gt; 는 제공되는 리프 튜플의 수입니다. &lt;code&gt;datums&lt;/code&gt; 그들의 데이텀 값들의 배열이다 &lt;code&gt;spgConfigOut&lt;/code&gt; . &lt;code&gt;leafType&lt;/code&gt; 타입. &lt;code&gt;level&lt;/code&gt; 은 모든 리프 튜플이 공유하는 현재 레벨이며 새로운 내부 튜플의 레벨이됩니다.</target>
        </trans-unit>
        <trans-unit id="62fcefc622def08da03a7170a5b210d5acd7432d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; follows the rules for SQL identifiers: either unadorned without special characters, or double-quoted. (In practice, you will usually want to add additional options, such as &lt;code&gt;LOGIN&lt;/code&gt;, to the command. More details appear below.) To remove an existing role, use the analogous &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; command:</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 특수 문자없이 꾸미지 않거나 큰 따옴표로 묶인 SQL 식별자 규칙을 따릅니다. 실제로는 일반적으로 &lt;code&gt;LOGIN&lt;/code&gt; 과 같은 추가 옵션 을 명령에 추가하려고합니다. 자세한 내용은 아래에 나와 있습니다. 기존 역할을 제거하려면 유사한 &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d24e0336d41da8c9507adf7f1c174bf6536ae0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ndoc&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; &amp;mdash; number of documents (&lt;code&gt;tsvector&lt;/code&gt;s) the word occurred in</source>
          <target state="translated">&lt;code&gt;ndoc&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; &amp;mdash; 단어가 발생한 문서 수 ( &lt;code&gt;tsvector&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="63895d410f36a094c726961ecf1a1d57a3324208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nentry&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; &amp;mdash; total number of occurrences of the word</source>
          <target state="translated">&lt;code&gt;nentry&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; &amp;mdash; 단어의 총 발생 횟수</target>
        </trans-unit>
        <trans-unit id="4dd2ceb4fd8026384aa2d7c6b816469f4fc57e44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;none&lt;/code&gt; &amp;mdash; data must be multiple of cipher block size</source>
          <target state="translated">&lt;code&gt;none&lt;/code&gt; &amp;mdash; 데이터는 암호 블록 크기의 배수 여야합니다</target>
        </trans-unit>
        <trans-unit id="efcf431fdaab6b51693379cd0242837c4ce52db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal_rand&lt;/code&gt; produces a set of normally distributed random values (Gaussian distribution).</source>
          <target state="translated">&lt;code&gt;normal_rand&lt;/code&gt; 는 정규 분포 랜덤 값 세트를 생성합니다 (가우스 분포).</target>
        </trans-unit>
        <trans-unit id="6feadbde7d618ad3ba8bdd329ae0eb42679d21b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;numeric&lt;/code&gt; for any integer-type argument, &lt;code&gt;double precision&lt;/code&gt; for a floating-point argument, otherwise the same as the argument data type</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 정수형 인수의 경우 숫자 , 부동 소수점 인수의 경우 &lt;code&gt;double precision&lt;/code&gt; , 그렇지 않은 경우 인수 데이터 형식과 동일</target>
        </trans-unit>
        <trans-unit id="7607c5ff772cf8ea92d28197914403e6736fc4c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;operator_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;operator_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="365830057becc6e617f24c79694d09d10b9b1488" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;relation_name&lt;/code&gt;.&lt;code&gt;column_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;operator_name&lt;/code&gt;&lt;code&gt;policy_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;&lt;code&gt;rule_name&lt;/code&gt;&lt;code&gt;trigger_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;relation_name&lt;/code&gt;.&lt;code&gt;column_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;operator_name&lt;/code&gt;&lt;code&gt;policy_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;&lt;code&gt;rule_name&lt;/code&gt;&lt;code&gt;trigger_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2f38fa17b07144b83be482a5dfbce7acc47ee8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;table_name.column_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;object_name&lt;/code&gt;&lt;code&gt;table_name.column_name&lt;/code&gt;&lt;code&gt;aggregate_name&lt;/code&gt;&lt;code&gt;function_name&lt;/code&gt;&lt;code&gt;procedure_name&lt;/code&gt;&lt;code&gt;routine_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="657b8542d659411cb611b3ab070621fc401fe86c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old-ascii&lt;/code&gt; style uses plain ASCII characters, using the formatting style used in PostgreSQL 8.4 and earlier. Newlines in data are shown using a &lt;code&gt;:&lt;/code&gt; symbol in place of the left-hand column separator. When the data is wrapped from one line to the next without a newline character, a &lt;code&gt;;&lt;/code&gt; symbol is used in place of the left-hand column separator.</source>
          <target state="translated">&lt;code&gt;old-ascii&lt;/code&gt; 스타일은 PostgreSQL 8.4 및 이전 버전에서 사용 된 서식 스타일을 사용하여 일반 ASCII 문자를 사용합니다. 데이터의 줄 바꿈 은 왼쪽 열 구분 기호 대신 &lt;code&gt;:&lt;/code&gt; 기호를 사용하여 표시 됩니다. 줄 바꿈 문자없이 데이터를 한 줄에서 다음 줄로 줄 바꿈하는 경우 &lt;code&gt;;&lt;/code&gt; 왼쪽 열 구분 기호 대신 기호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36d8c0ec397af33212d35841f061ffa597543174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_snapshot_threshold&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;old_snapshot_threshold&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e926168fe22ff139015a6783a03a7b78384d8eae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_datasync&lt;/code&gt; (write WAL files with &lt;code&gt;open()&lt;/code&gt; option &lt;code&gt;O_DSYNC&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;open_datasync&lt;/code&gt; ( &lt;code&gt;open()&lt;/code&gt; 옵션 &lt;code&gt;O_DSYNC&lt;/code&gt; 로 WAL 파일 쓰기 )</target>
        </trans-unit>
        <trans-unit id="8dad6890a0bfac02b44dad5054d55dfe4497fed5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_sync&lt;/code&gt; (write WAL files with &lt;code&gt;open()&lt;/code&gt; option &lt;code&gt;O_SYNC&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;open_sync&lt;/code&gt; ( &lt;code&gt;open()&lt;/code&gt; 옵션 &lt;code&gt;O_SYNC&lt;/code&gt; 로 WAL 파일 쓰기 )</target>
        </trans-unit>
        <trans-unit id="4291506d305cf1a45f978181776987e57b849509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;expression&lt;/code&gt; (unary prefix operator)</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; (단일 접두사 연산자)</target>
        </trans-unit>
        <trans-unit id="6ac2914bb3978deb47e982aa3084dfde8de6504f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator_precedence_warning&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;operator_precedence_warning&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9e8d42fce7c4f02e6628300bb35a8453644fc576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; (create Primary keys)</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; (기본 키 생성)</target>
        </trans-unit>
        <trans-unit id="ffa0a961c6544b8934258c3c45680b7b731c6d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; = permanent table, &lt;code&gt;u&lt;/code&gt; = unlogged table, &lt;code&gt;t&lt;/code&gt; = temporary table</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; = 영구 테이블, &lt;code&gt;u&lt;/code&gt; = 로그되지 않은 테이블, &lt;code&gt;t&lt;/code&gt; = 임시 테이블</target>
        </trans-unit>
        <trans-unit id="c1f27a2ab42c63a6cd1b7a82e8cda2db4defd1de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;: Value must always be stored plain.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; : 값은 항상 평범하게 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="d22cf04af498f731fbb9345426827ce10a5f3a00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;&lt;code&gt;plain&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt;&lt;code&gt;plain&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abdedf374bc658e73730b6829fd76b29b532e4fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;page = GenericXLogRegisterBuffer(state, buffer, flags)&lt;/code&gt; &amp;mdash; register a buffer to be modified within the current generic WAL record. This function returns a pointer to a temporary copy of the buffer's page, where modifications should be made. (Do not modify the buffer's contents directly.) The third argument is a bit mask of flags applicable to the operation. Currently the only such flag is &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt;, which indicates that a full-page image rather than a delta update should be included in the WAL record. Typically this flag would be set if the page is new or has been rewritten completely. &lt;code&gt;GenericXLogRegisterBuffer&lt;/code&gt; can be repeated if the WAL-logged action needs to modify multiple pages.</source>
          <target state="translated">&lt;code&gt;page = GenericXLogRegisterBuffer(state, buffer, flags)&lt;/code&gt; &amp;mdash; 현재 일반 WAL 레코드 내에서 수정할 버퍼를 등록합니다. 이 함수는 수정해야하는 버퍼 페이지의 임시 사본에 대한 포인터를 리턴합니다. (버퍼 내용을 직접 수정하지 마십시오.) 세 번째 인수는 작업에 적용 가능한 플래그의 비트 마스크입니다. 현재 이러한 플래그는 &lt;code&gt;GENERIC_XLOG_FULL_IMAGE&lt;/code&gt; 뿐이며 델타 업데이트가 아닌 전체 페이지 이미지가 WAL 레코드에 포함되어야 함을 나타냅니다. 일반적으로이 플래그는 페이지가 새 페이지이거나 완전히 다시 작성된 경우에 설정됩니다. WAL 로깅 조치가 여러 페이지를 수정해야하는 경우 &lt;code&gt;GenericXLogRegisterBuffer&lt;/code&gt; 를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d630fe24886ccd80987a5dfd89779172dfd647" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;page_checksum&lt;/code&gt; computes the checksum for the page, as if it was located at the given block.</source>
          <target state="translated">&lt;code&gt;page_checksum&lt;/code&gt; 은 페이지가 지정된 블록에있는 것처럼 페이지의 체크섬을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1529c7be35d0125bbcf573d7fbe521d60f24ce5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;page_header&lt;/code&gt; shows fields that are common to all PostgreSQL heap and index pages.</source>
          <target state="translated">&lt;code&gt;page_header&lt;/code&gt; 는 모든 PostgreSQL 힙 및 인덱스 페이지에 공통적 인 필드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b39af746f3bd3c9ae72d759a71d484f4695defed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_leader_participation&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;parallel_leader_participation&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0545b614595b679b87da93fb8f63078325220102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_setup_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;parallel_setup_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="82aee93da84176fae778941260b78b6fe45e6d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_tuple_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;parallel_tuple_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4ccccee9d0d5d56270d428d44c82cdc79aca601b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_workers&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;parallel_workers&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="558516e8f5335526105a075040eb00c7fd0277da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition_bound_expr&lt;/code&gt; is any variable-free expression (subqueries, window functions, aggregate functions, and set-returning functions are not allowed). Its data type must match the data type of the corresponding partition key column. The expression is evaluated once at table creation time, so it can even contain volatile expressions such as &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;partition_bound_expr&lt;/code&gt; 은 변수가없는 표현식입니다 (서브 쿼리, 창 함수, 집계 함수 및 집합 반환 함수는 허용되지 않음). 데이터 유형은 해당 파티션 키 열의 데이터 유형과 일치해야합니다. 표현식은 테이블 작성시 한 번 평가되므로 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 와 같은 일시적인 표현식도 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="792ca4df79b8494afc6f5298c813f70ee8916736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password_encryption&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;password_encryption&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="40d37aa32d9ffd06e0b1ab4411a1355fe8f9b712" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_lock&lt;/code&gt; locks an application-defined resource, which can be identified either by a single 64-bit key value or two 32-bit key values (note that these two key spaces do not overlap). If another session already holds a lock on the same resource identifier, this function will wait until the resource becomes available. The lock is exclusive. Multiple lock requests stack, so that if the same resource is locked three times it must then be unlocked three times to be released for other sessions' use.</source>
          <target state="translated">&lt;code&gt;pg_advisory_lock&lt;/code&gt; 은 단일 64 비트 키 값 또는 2 개의 32 비트 키 값으로 식별 할 수있는 응용 프로그램 정의 자원을 잠급니다 (이 두 키 공간은 겹치지 않습니다). 다른 세션이 이미 동일한 리소스 식별자에 대한 잠금을 보유한 경우이 기능은 리소스를 사용할 수있을 때까지 기다립니다. 자물쇠는 독점적입니다. 여러 잠금 요청이 스택되므로 동일한 리소스가 세 번 잠긴 경우 다른 세션에서 사용할 수 있도록 해제하려면 세 번 잠금을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb230669da1075fe0475409a92577b4a4c77d07f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_lock_shared&lt;/code&gt; works the same as &lt;code&gt;pg_advisory_lock&lt;/code&gt;, except the lock can be shared with other sessions requesting shared locks. Only would-be exclusive lockers are locked out.</source>
          <target state="translated">&lt;code&gt;pg_advisory_lock_shared&lt;/code&gt; 은 동일하게 작동 &lt;code&gt;pg_advisory_lock&lt;/code&gt; 공유 잠금을 요청하는 다른 세션과 잠금을 공유 할 수 있다는 점을 제외하고 . 독점 사물함 만 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="b772d2339133190d7304f8d06f04bcd50055828e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_unlock&lt;/code&gt; will release a previously-acquired exclusive session level advisory lock. It returns &lt;code&gt;true&lt;/code&gt; if the lock is successfully released. If the lock was not held, it will return &lt;code&gt;false&lt;/code&gt;, and in addition, an SQL warning will be reported by the server.</source>
          <target state="translated">&lt;code&gt;pg_advisory_unlock&lt;/code&gt; 은 이전에 획득 한 독점 세션 레벨 권고 잠금을 해제합니다. 잠금이 해제되면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 잠금이 유지되지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다. 하고 서버에서 SQL 경고를보고합니다.</target>
        </trans-unit>
        <trans-unit id="24980a443af7f2e9fc8c263294ae4f6382f3bab8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_unlock_all&lt;/code&gt; will release all session level advisory locks held by the current session. (This function is implicitly invoked at session end, even if the client disconnects ungracefully.)</source>
          <target state="translated">&lt;code&gt;pg_advisory_unlock_all&lt;/code&gt; 은 현재 세션이 보유한 모든 세션 레벨 권고 잠금을 해제합니다. (이 기능은 클라이언트가 비정상적으로 연결을 끊어도 세션 종료시 내재적으로 호출됩니다.)</target>
        </trans-unit>
        <trans-unit id="c764408b745f38930e787e4a1101eea983ff95b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_unlock_shared&lt;/code&gt; works the same as &lt;code&gt;pg_advisory_unlock&lt;/code&gt;, except it releases a shared session level advisory lock.</source>
          <target state="translated">&lt;code&gt;pg_advisory_unlock_shared&lt;/code&gt; 는 공유 세션 레벨 권고 잠금을 해제한다는 점을 제외하고 &lt;code&gt;pg_advisory_unlock&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fe487ef215951f74e00dd5f9e6d9b24978bbe7df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_xact_lock&lt;/code&gt; works the same as &lt;code&gt;pg_advisory_lock&lt;/code&gt;, except the lock is automatically released at the end of the current transaction and cannot be released explicitly.</source>
          <target state="translated">&lt;code&gt;pg_advisory_xact_lock&lt;/code&gt; 은 현재 트랜잭션이 끝날 때 잠금이 자동으로 해제되고 명시 적으로 해제 할 수 없다는 점을 제외하고 &lt;code&gt;pg_advisory_lock&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e94075001fd1891afb45662a9a6d2a0144932649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_advisory_xact_lock_shared&lt;/code&gt; works the same as &lt;code&gt;pg_advisory_lock_shared&lt;/code&gt;, except the lock is automatically released at the end of the current transaction and cannot be released explicitly.</source>
          <target state="translated">&lt;code&gt;pg_advisory_xact_lock_shared&lt;/code&gt; 는 같은 작동 &lt;code&gt;pg_advisory_lock_shared&lt;/code&gt; 잠금이 자동으로 현재 트랜잭션의 끝에서 해제되고 명시 적으로 해제 할 수 없습니다 제외.</target>
        </trans-unit>
        <trans-unit id="738ae7c398bbc30d037797ff649f107bacc8015c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_archivecleanup&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] &lt;code&gt;archivelocation&lt;/code&gt;&lt;code&gt;oldestkeptwalfile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_archivecleanup&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] &lt;code&gt;archivelocation&lt;/code&gt; &lt;code&gt;oldestkeptwalfile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df1549a1317d46a927100c573c24f408b50bff73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_basebackup&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_basebackup&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="58f0ce27492fc490ac90e76613f942ac4b5116d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_blocking_pids&lt;/code&gt; returns an array of the process IDs of the sessions that are blocking the server process with the specified process ID, or an empty array if there is no such server process or it is not blocked. One server process blocks another if it either holds a lock that conflicts with the blocked process's lock request (hard block), or is waiting for a lock that would conflict with the blocked process's lock request and is ahead of it in the wait queue (soft block). When using parallel queries the result always lists client-visible process IDs (that is, &lt;code&gt;pg_backend_pid&lt;/code&gt; results) even if the actual lock is held or awaited by a child worker process. As a result of that, there may be duplicated PIDs in the result. Also note that when a prepared transaction holds a conflicting lock, it will be represented by a zero process ID in the result of this function. Frequent calls to this function could have some impact on database performance, because it needs exclusive access to the lock manager's shared state for a short time.</source>
          <target state="translated">&lt;code&gt;pg_blocking_pids&lt;/code&gt; 는 지정된 프로세스 ID로 서버 프로세스를 차단하고있는 세션의 프로세스 ID 배열 또는 그러한 서버 프로세스가 없거나 차단되지 않은 경우 빈 배열을 반환합니다. 한 서버 프로세스는 차단 된 프로세스의 잠금 요청 (하드 블록)과 충돌하는 잠금을 보유하거나 차단 된 프로세스의 잠금 요청과 충돌 할 잠금을 대기 중이고 대기 큐에서 대기중인 경우 다른 서버를 차단합니다 (소프트 블록). 병렬 쿼리를 사용하면 결과에 항상 클라이언트 표시 프로세스 ID (즉, &lt;code&gt;pg_backend_pid&lt;/code&gt; ) 가 나열됩니다결과) 실제 잠금이 하위 작업자 프로세스에 의해 보류되거나 대기하는 경우에도 마찬가지입니다. 결과적으로 결과에 중복 된 PID가있을 수 있습니다. 또한 준비된 트랜잭션이 충돌 잠금을 보유하면이 기능의 결과에서 프로세스 ID가 0으로 표시됩니다. 이 기능을 자주 호출하면 잠금 관리자의 공유 상태에 짧은 시간 동안 독점 액세스해야하므로 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5a228b6dd7bd938c20751f15ab25b0cfc01dae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_cancel_backend()&lt;/code&gt; and &lt;code&gt;pg_terminate_backend()&lt;/code&gt; will work on user backends, but not the Startup process, which performs recovery. &lt;code&gt;pg_stat_activity&lt;/code&gt; does not show recovering transactions as active. As a result, &lt;code&gt;pg_prepared_xacts&lt;/code&gt; is always empty during recovery. If you wish to resolve in-doubt prepared transactions, view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; on the primary and issue commands to resolve transactions there or resolve them after the end of recovery.</source>
          <target state="translated">&lt;code&gt;pg_cancel_backend()&lt;/code&gt; 및 &lt;code&gt;pg_terminate_backend()&lt;/code&gt; 는 사용자 백엔드에서 작동하지만 복구를 수행하는 시작 프로세스에서는 작동하지 않습니다. &lt;code&gt;pg_stat_activity&lt;/code&gt; 는 트랜잭션 복구를 활성으로 표시하지 않습니다. 결과적으로 &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 는 복구 중에 항상 비어 있습니다. &lt;code&gt;pg_prepared_xacts&lt;/code&gt; 우트 (in-doubt) 준비된 트랜잭션을 해결 하려면 기본에서 pg_prepared_xacts 를 보고 명령을 실행하여 트랜잭션을 해결하거나 복구가 끝난 후에 트랜잭션을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="4e8e18dcd37224b6c87d715315f647f30405ded5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_cancel_backend&lt;/code&gt; and &lt;code&gt;pg_terminate_backend&lt;/code&gt; send signals (SIGINT or SIGTERM respectively) to backend processes identified by process ID. The process ID of an active backend can be found from the &lt;code&gt;pid&lt;/code&gt; column of the &lt;code&gt;pg_stat_activity&lt;/code&gt; view, or by listing the &lt;code&gt;postgres&lt;/code&gt; processes on the server (using ps on Unix or the Task Manager on Windows). The role of an active backend can be found from the &lt;code&gt;usename&lt;/code&gt; column of the &lt;code&gt;pg_stat_activity&lt;/code&gt; view.</source>
          <target state="translated">&lt;code&gt;pg_cancel_backend&lt;/code&gt; 및 &lt;code&gt;pg_terminate_backend&lt;/code&gt; 는 프로세스 ID로 식별 된 백엔드 프로세스에 신호 (각각 SIGINT 또는 SIGTERM)를 보냅니다. 활성 백엔드의 프로세스 ID는 &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기 의 &lt;code&gt;pid&lt;/code&gt; 열 에서 찾 거나 서버 에서 &lt;code&gt;postgres&lt;/code&gt; 프로세스를 나열하여 찾을 수 있습니다 (Unix의 ps 또는 Windows의 작업 관리자 사용). 활성 백엔드의 역할은 &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기 의 &lt;code&gt;usename&lt;/code&gt; 열 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c530ecbc7e92a5b997c7fc79dd314a0ccd9cb343" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_catalog.english_stem&lt;/code&gt; is the subdictionary (here, a Snowball English stemmer) to use for thesaurus normalization. Notice that the subdictionary will have its own configuration (for example, stop words), which is not shown here.</source>
          <target state="translated">&lt;code&gt;pg_catalog.english_stem&lt;/code&gt; 은 동의어 사전 정규화에 사용할 대체 (여기서는 Snowball English 형태소 분석기)입니다. 사전은 여기에 표시되지 않은 자체 구성 (예 : 중지 단어)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="02d03f42232a0f4a045daed27a52493b8691303e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_checksums&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [[ &lt;code&gt;-D&lt;/code&gt; | &lt;code&gt;--pgdata&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_checksums&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [[ &lt;code&gt;-D&lt;/code&gt; | &lt;code&gt;--pgdata&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="6694d6444121e7a0039295efbc157a8d5a523674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_class.relchecks&lt;/code&gt; needs to agree with the number of check-constraint entries found in this table for each relation.</source>
          <target state="translated">&lt;code&gt;pg_class.relchecks&lt;/code&gt; 는 각 관계에 대해이 표에서 찾은 점검 제한 조건 항목의 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="db58a5e60b8a2fd0559cb9e294736660e98c16c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_class.relhasrules&lt;/code&gt; must be true if a table has any rules in this catalog.</source>
          <target state="translated">&lt;code&gt;pg_class.relhasrules&lt;/code&gt; 테이블에이 카탈로그에 규칙이 있으면 pg_class.relhasrules 는 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5c6ccf7ae14303a3b1150c3602f96520dc21bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_class.relhastriggers&lt;/code&gt; must be true if a relation has any triggers in this catalog.</source>
          <target state="translated">&lt;code&gt;pg_class.relhastriggers&lt;/code&gt; 관계에이 카탈로그에 트리거가 있으면 pg_class.relhastriggers 는 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3aaa926809e851ac996f34913b8f54b03900c1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_collation_actual_version&lt;/code&gt; returns the actual version of the collation object as it is currently installed in the operating system. If this is different from the value in &lt;code&gt;pg_collation.collversion&lt;/code&gt;, then objects depending on the collation might need to be rebuilt. See also &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_collation_actual_version&lt;/code&gt; 은 현재 운영 체제에 설치된 콜 레이션 오브젝트의 실제 버전을 리턴합니다. 이것이 &lt;code&gt;pg_collation.collversion&lt;/code&gt; 의 값과 다른 경우 데이터 정렬에 따른 객체를 다시 작성해야 할 수 있습니다. &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e73d79985a5ea47db6b330feb2d5efabb35dbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_column_size&lt;/code&gt; shows the space used to store any individual data value.</source>
          <target state="translated">&lt;code&gt;pg_column_size&lt;/code&gt; 는 개별 데이터 값을 저장하는 데 사용 된 공간을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="29a3e3043e942925f59c4fdc2782905b0d35ad98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_conf_load_time&lt;/code&gt; returns the &lt;code&gt;timestamp with time zone&lt;/code&gt; when the server configuration files were last loaded. (If the current session was alive at the time, this will be the time when the session itself re-read the configuration files, so the reading will vary a little in different sessions. Otherwise it is the time when the postmaster process re-read the configuration files.)</source>
          <target state="translated">&lt;code&gt;pg_conf_load_time&lt;/code&gt; 은 서버 구성 파일이 마지막으로로드 된 &lt;code&gt;timestamp with time zone&lt;/code&gt; 의 타임 스탬프를 반환합니다 . (현재 세션이 활성 상태 인 경우 세션 자체가 구성 파일을 다시 읽을 때가되므로 읽기에 따라 세션마다 조금씩 다를 수 있습니다. 그렇지 않으면 포스트 마스터 프로세스가 다시 읽히는 시간입니다. 구성 파일.)</target>
        </trans-unit>
        <trans-unit id="fe7b94a2047d8f8a0233268fa42c747199c00345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_config&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_config&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="b03a1f147791f9f1280ff130755710638debaa8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_control_checkpoint&lt;/code&gt; returns a record, shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-CHECKPOINT&quot;&gt;Table 9.78&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pg_control_checkpoint&lt;/code&gt; 는 &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-CHECKPOINT&quot;&gt;표 9.78에&lt;/a&gt; 표시된 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f8f67105aa8d002730c51a538c3087894189699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_control_init&lt;/code&gt; returns a record, shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-INIT&quot;&gt;Table 9.80&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pg_control_init&lt;/code&gt; 는 &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-INIT&quot;&gt;표 9.80에&lt;/a&gt; 표시된 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aed7219d08b66a1b4d71983acba1985f663456fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_control_recovery&lt;/code&gt; returns a record, shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-RECOVERY&quot;&gt;Table 9.81&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pg_control_recovery&lt;/code&gt; 는 &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-RECOVERY&quot;&gt;표 9.81에&lt;/a&gt; 표시된 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18a439fd61f5bddff800cb4b69620ea8b2cd3e07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_control_system&lt;/code&gt; returns a record, shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-SYSTEM&quot;&gt;Table 9.79&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pg_control_system&lt;/code&gt; 은 &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-SYSTEM&quot;&gt;표 9.79에&lt;/a&gt; 표시된 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f83a45ff3501491b343ebaaf4a9e1e33474b330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_controldata&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;] [[ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_controldata&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ] [[ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="97d4e131cfdaf03c658d1657d96e763c9a28a654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_controldata&lt;/code&gt; prints information initialized during &lt;code&gt;initdb&lt;/code&gt;, such as the catalog version. It also shows information about write-ahead logging and checkpoint processing. This information is cluster-wide, and not specific to any one database.</source>
          <target state="translated">&lt;code&gt;pg_controldata&lt;/code&gt; 는 카탈로그 버전과 같이 &lt;code&gt;initdb&lt;/code&gt; 동안 초기화 된 정보를 인쇄합니다 . 또한 미리 쓰기 로깅 및 검사 점 처리에 대한 정보도 표시합니다. 이 정보는 클러스터 전체이며 특정 데이터베이스에만 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22114bc73ab522b5ec81e0921c632d56e3700d75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_create_restore_point&lt;/code&gt; creates a named write-ahead log record that can be used as recovery target, and returns the corresponding write-ahead log location. The given name can then be used with &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-NAME&quot;&gt;recovery_target_name&lt;/a&gt; to specify the point up to which recovery will proceed. Avoid creating multiple restore points with the same name, since recovery will stop at the first one whose name matches the recovery target.</source>
          <target state="translated">&lt;code&gt;pg_create_restore_point&lt;/code&gt; 는 복구 대상으로 사용할 수있는 명명 된 미리 쓰기 로그 레코드를 생성하고 해당 미리 쓰기 로그 위치를 반환합니다. 그런 다음 주어진 이름을 &lt;a href=&quot;runtime-config-wal#GUC-RECOVERY-TARGET-NAME&quot;&gt;recovery_target_name&lt;/a&gt; 과 함께 사용하여 복구가 진행될 시점을 지정할 수 있습니다. 이름이 복구 대상과 일치하는 첫 번째 지점에서 복구가 중지되므로 동일한 이름으로 여러 복원 지점을 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ee93c8cf0f74d1db0b24dcd63bf56edac8009ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; 은 대부분의 다른 PostgreSQL 유틸리티와 마찬가지로 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8118b06e50594869cd2ee54a961f8aad6e2edc12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;init[db]&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;] [&lt;code&gt;-o&lt;/code&gt;&lt;code&gt;initdb-options&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;init[db]&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ] [ &lt;code&gt;-o&lt;/code&gt; &lt;code&gt;initdb-options&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="a0918da12fee272c221043989a068cf7311af71c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;kill&lt;/code&gt;&lt;code&gt;signal_name&lt;/code&gt;&lt;code&gt;process_id&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;kill&lt;/code&gt;&lt;code&gt;signal_name&lt;/code&gt;&lt;code&gt;process_id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="078942601c7a74b126e8badbe09f067d309aa1ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;logrotate&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;logrotate&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="9db7c7fe9a220d652209eb9e023c248785d25663" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;promote&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-W&lt;/code&gt;] [&lt;code&gt;-t&lt;/code&gt;&lt;code&gt;seconds&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;promote&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-W&lt;/code&gt; ] [ &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;seconds&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="46ca7678b3ec10cec4e87aed3f487e6ab75ac616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;register&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-N&lt;/code&gt;&lt;code&gt;servicename&lt;/code&gt;] [&lt;code&gt;-U&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;] [&lt;code&gt;-P&lt;/code&gt;&lt;code&gt;password&lt;/code&gt;] [&lt;code&gt;-S&lt;/code&gt;&lt;code&gt;a[uto]&lt;/code&gt; | &lt;code&gt;d[emand]&lt;/code&gt; ] [&lt;code&gt;-e&lt;/code&gt;&lt;code&gt;source&lt;/code&gt;] [&lt;code&gt;-W&lt;/code&gt;] [&lt;code&gt;-t&lt;/code&gt;&lt;code&gt;seconds&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;] [&lt;code&gt;-o&lt;/code&gt;&lt;code&gt;options&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;register&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-N&lt;/code&gt; &lt;code&gt;servicename&lt;/code&gt; ] [ &lt;code&gt;-U&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; ] [ &lt;code&gt;-P&lt;/code&gt; &lt;code&gt;password&lt;/code&gt; ] [ &lt;code&gt;-S&lt;/code&gt; &lt;code&gt;a[uto]&lt;/code&gt; | &lt;code&gt;d[emand]&lt;/code&gt; ] [ &lt;code&gt;-e&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; ] [ &lt;code&gt;-W&lt;/code&gt; ] [ &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;seconds&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ] [ &lt;code&gt;-o&lt;/code&gt; &lt;code&gt;options&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="39b7644b2ccc1935ac47c3f9199c3965ed190845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;reload&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;reload&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="8ee544da497fec4fa0786c6c068aa44c9e7b8ce2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;restart&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-m&lt;/code&gt;&lt;code&gt;s[mart]&lt;/code&gt; | &lt;code&gt;f[ast]&lt;/code&gt; | &lt;code&gt;i[mmediate]&lt;/code&gt; ] [&lt;code&gt;-W&lt;/code&gt;] [&lt;code&gt;-t&lt;/code&gt;&lt;code&gt;seconds&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;] [&lt;code&gt;-o&lt;/code&gt;&lt;code&gt;options&lt;/code&gt;] [&lt;code&gt;-c&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;restart&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-m&lt;/code&gt; &lt;code&gt;s[mart]&lt;/code&gt; | &lt;code&gt;f[ast]&lt;/code&gt; | &lt;code&gt;i[mmediate]&lt;/code&gt; ] [ &lt;code&gt;-W&lt;/code&gt; ] [ &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;seconds&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ] [ &lt;code&gt;-o&lt;/code&gt; &lt;code&gt;options&lt;/code&gt; ] [ &lt;code&gt;-c&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="a13c91b19a496d868ba86d4b88baa9d88965601d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;start&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-l&lt;/code&gt;&lt;code&gt;filename&lt;/code&gt;] [&lt;code&gt;-W&lt;/code&gt;] [&lt;code&gt;-t&lt;/code&gt;&lt;code&gt;seconds&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;] [&lt;code&gt;-o&lt;/code&gt;&lt;code&gt;options&lt;/code&gt;] [&lt;code&gt;-p&lt;/code&gt;&lt;code&gt;path&lt;/code&gt;] [&lt;code&gt;-c&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;start&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-l&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt; ] [ &lt;code&gt;-W&lt;/code&gt; ] [ &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;seconds&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ] [ &lt;code&gt;-o&lt;/code&gt; &lt;code&gt;options&lt;/code&gt; ] [ &lt;code&gt;-p&lt;/code&gt; &lt;code&gt;path&lt;/code&gt; ] [ &lt;code&gt;-c&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="ea9e1dae9c4280af860d037ed301985ed6acc3fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;status&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;status&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="d40b9744f4cae7d224006d2b3a6c0ea412bd60c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;stop&lt;/code&gt; [&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;datadir&lt;/code&gt;] [&lt;code&gt;-m&lt;/code&gt;&lt;code&gt;s[mart]&lt;/code&gt; | &lt;code&gt;f[ast]&lt;/code&gt; | &lt;code&gt;i[mmediate]&lt;/code&gt; ] [&lt;code&gt;-W&lt;/code&gt;] [&lt;code&gt;-t&lt;/code&gt;&lt;code&gt;seconds&lt;/code&gt;] [&lt;code&gt;-s&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;stop&lt;/code&gt; [ &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;datadir&lt;/code&gt; ] [ &lt;code&gt;-m&lt;/code&gt; &lt;code&gt;s[mart]&lt;/code&gt; | &lt;code&gt;f[ast]&lt;/code&gt; | &lt;code&gt;i[mmediate]&lt;/code&gt; ] [ &lt;code&gt;-W&lt;/code&gt; ] [ &lt;code&gt;-t&lt;/code&gt; &lt;code&gt;seconds&lt;/code&gt; ] [ &lt;code&gt;-s&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="6802b42a273d09859632069d5e2a651520b2ccd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ctl&lt;/code&gt;&lt;code&gt;unregister&lt;/code&gt; [&lt;code&gt;-N&lt;/code&gt;&lt;code&gt;servicename&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_ctl&lt;/code&gt; &lt;code&gt;unregister&lt;/code&gt; [ &lt;code&gt;-N&lt;/code&gt; &lt;code&gt;servicename&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="ff3db680f6e36db915b7a60acacc283b6f5b03f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_current_logfile&lt;/code&gt; returns, as &lt;code&gt;text&lt;/code&gt;, the path of the log file(s) currently in use by the logging collector. The path includes the &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; directory and the log file name. Log collection must be enabled or the return value is &lt;code&gt;NULL&lt;/code&gt;. When multiple log files exist, each in a different format, &lt;code&gt;pg_current_logfile&lt;/code&gt; called without arguments returns the path of the file having the first format found in the ordered list: stderr, csvlog. &lt;code&gt;NULL&lt;/code&gt; is returned when no log file has any of these formats. To request a specific file format supply, as &lt;code&gt;text&lt;/code&gt;, either csvlog or stderr as the value of the optional parameter. The return value is &lt;code&gt;NULL&lt;/code&gt; when the log format requested is not a configured &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination&lt;/a&gt;. The &lt;code&gt;pg_current_logfile&lt;/code&gt; reflects the contents of the &lt;code&gt;current_logfiles&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_current_logfile&lt;/code&gt; 은 로깅 콜렉터가 현재 사용중인 로그 파일의 경로 를 &lt;code&gt;text&lt;/code&gt; 로 리턴합니다 . 경로에는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; 디렉토리 및 로그 파일 이름이 포함됩니다. 로그 콜렉션이 사용 가능해야하거나 리턴 값이 &lt;code&gt;NULL&lt;/code&gt; 입니다. 인수없이 호출 된 &lt;code&gt;pg_current_logfile&lt;/code&gt; 은 각각 다른 형식의 여러 로그 파일이 존재하는 경우 순서 목록 (stderr, csvlog)에서 찾은 첫 번째 형식의 파일 경로를 리턴합니다. 이러한 형식의 로그 파일이없는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 선택적 파일 형식 공급을 &lt;code&gt;text&lt;/code&gt; 로 요청하려면 선택적 매개 변수의 값으로 csvlog 또는 stderr을 사용하십시오. 반환 값은 &lt;code&gt;NULL&lt;/code&gt; 요청 된 로그 형식은 구성되지 않은 경우 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;의 log_destination&lt;/a&gt; . &lt;code&gt;pg_current_logfile&lt;/code&gt; 는 의 내용을 반영 &lt;code&gt;current_logfiles&lt;/code&gt; 의 파일을.</target>
        </trans-unit>
        <trans-unit id="de43d3f3839908b993be012942579776d9eb211f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_current_wal_lsn&lt;/code&gt; displays the current write-ahead log write location in the same format used by the above functions. Similarly, &lt;code&gt;pg_current_wal_insert_lsn&lt;/code&gt; displays the current write-ahead log insertion location and &lt;code&gt;pg_current_wal_flush_lsn&lt;/code&gt; displays the current write-ahead log flush location. The insertion location is the &amp;ldquo;logical&amp;rdquo; end of the write-ahead log at any instant, while the write location is the end of what has actually been written out from the server's internal buffers and flush location is the location guaranteed to be written to durable storage. The write location is the end of what can be examined from outside the server, and is usually what you want if you are interested in archiving partially-complete write-ahead log files. The insertion and flush locations are made available primarily for server debugging purposes. These are both read-only operations and do not require superuser permissions.</source>
          <target state="translated">&lt;code&gt;pg_current_wal_lsn&lt;/code&gt; 은 현재 미리 쓰기 로그 쓰기 위치를 위 기능에서 사용 된 것과 동일한 형식으로 표시합니다. 마찬가지로 &lt;code&gt;pg_current_wal_insert_lsn&lt;/code&gt; 은 현재 미리 쓰기 로그 삽입 위치와 &lt;code&gt;pg_current_wal_flush_lsn&lt;/code&gt; 을 표시합니다.현재 미리 쓰기 로그 플러시 위치를 표시합니다. 삽입 위치는 모든 순간에 미리 쓰기 로그의 &quot;논리적&quot;끝이며, 쓰기 위치는 서버의 내부 버퍼에서 실제로 기록 된 것의 끝이며, 플러시 위치는 내구성에 기록되도록 보장 된 위치입니다 저장. 쓰기 위치는 서버 외부에서 검사 할 수있는 것의 끝이며 부분적으로 완전한 미리 쓰기 로그 파일을 아카이브하려는 경우 원하는 것입니다. 삽입 및 플러시 위치는 주로 서버 디버깅 목적으로 사용 가능합니다. 이들은 모두 읽기 전용 작업이며 수퍼 유저 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7911139f7bdb20d0a35ff52fc1f5550213cd23db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_database_size&lt;/code&gt; and &lt;code&gt;pg_tablespace_size&lt;/code&gt; accept the OID or name of a database or tablespace, and return the total disk space used therein. To use &lt;code&gt;pg_database_size&lt;/code&gt;, you must have &lt;code&gt;CONNECT&lt;/code&gt; permission on the specified database (which is granted by default), or be a member of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role. To use &lt;code&gt;pg_tablespace_size&lt;/code&gt;, you must have &lt;code&gt;CREATE&lt;/code&gt; permission on the specified tablespace, or be a member of the &lt;code&gt;pg_read_all_stats&lt;/code&gt; role unless it is the default tablespace for the current database.</source>
          <target state="translated">&lt;code&gt;pg_database_size&lt;/code&gt; 및 &lt;code&gt;pg_tablespace_size&lt;/code&gt; 는 데이터베이스 또는 테이블 스페이스의 OID 또는 이름을 승인하고 사용 된 총 디스크 공간을 리턴합니다. 사용하려면 &lt;code&gt;pg_database_size&lt;/code&gt; 을 , 당신은 있어야합니다 &lt;code&gt;CONNECT&lt;/code&gt; 의 (기본적으로 부여됩니다) 지정된 데이터베이스에 대한 권한을, 또는의 구성원 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 의 역할. 사용하려면 &lt;code&gt;pg_tablespace_size&lt;/code&gt; 을 , 당신은 있어야합니다 &lt;code&gt;CREATE&lt;/code&gt; 지정된 테이블에 권한을, 또는의 구성원 &lt;code&gt;pg_read_all_stats&lt;/code&gt; 의 는 현재 데이터베이스의 기본 테이블 스페이스가 아닌 역할.</target>
        </trans-unit>
        <trans-unit id="0e0e1665d56536eeae5a26fb97640fab55b049d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_describe_object&lt;/code&gt; returns a textual description of a database object specified by catalog OID, object OID, and sub-object ID (such as a column number within a table; the sub-object ID is zero when referring to a whole object). This description is intended to be human-readable, and might be translated, depending on server configuration. This is useful to determine the identity of an object as stored in the &lt;code&gt;pg_depend&lt;/code&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_describe_object&lt;/code&gt; 는 카탈로그 OID, 객체 OID 및 하위 객체 ID (예 : 테이블 내의 열 번호, 전체 객체를 참조 할 때 하위 객체 ID가 0 임)로 지정된 데이터베이스 객체의 텍스트 설명을 반환합니다. 이 설명은 사람이 읽을 수 있도록 작성되었으며 서버 구성에 따라 번역 될 수 있습니다. &lt;code&gt;pg_depend&lt;/code&gt; 카탈로그에 저장된 객체의 아이덴티티를 결정하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6c5ed6ccf34b6be002a034c6a9ede2b800f9fcc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_dump&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;dbname&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_dump&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;dbname&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="80a1c50caa1d4f9ba825c04c455e2f8ee1668bad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_dumpall&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_dumpall&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="703f41c399ddefb0e42e06a6652f89eeed59078f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_file_rename&lt;/code&gt; renames a file. If &lt;em&gt;&lt;code&gt;archivename&lt;/code&gt;&lt;/em&gt; is omitted or NULL, it simply renames &lt;em&gt;&lt;code&gt;oldname&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;newname&lt;/code&gt;&lt;/em&gt; (which must not already exist). If &lt;em&gt;&lt;code&gt;archivename&lt;/code&gt;&lt;/em&gt; is provided, it first renames &lt;em&gt;&lt;code&gt;newname&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;archivename&lt;/code&gt;&lt;/em&gt; (which must not already exist), and then renames &lt;em&gt;&lt;code&gt;oldname&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;newname&lt;/code&gt;&lt;/em&gt;. In event of failure of the second rename step, it will try to rename &lt;em&gt;&lt;code&gt;archivename&lt;/code&gt;&lt;/em&gt; back to &lt;em&gt;&lt;code&gt;newname&lt;/code&gt;&lt;/em&gt; before reporting the error. Returns true on success, false if the source file(s) are not present or not writable; other cases throw errors.</source>
          <target state="translated">&lt;code&gt;pg_file_rename&lt;/code&gt; 은 파일 이름을 바꿉니다. 경우 &lt;em&gt; &lt;code&gt;archivename&lt;/code&gt; 이&lt;/em&gt; 생략되거나 NULL, 그것은 단순히 이름을 변경 &lt;em&gt; &lt;code&gt;oldname&lt;/code&gt; &lt;/em&gt; 에 &lt;em&gt; &lt;code&gt;newname&lt;/code&gt; 의&lt;/em&gt; (이미 존재하지 않아야 함). 경우 &lt;em&gt; &lt;code&gt;archivename&lt;/code&gt; 가&lt;/em&gt; 제공되고, 먼저 이름을 변경 &lt;em&gt; &lt;code&gt;newname&lt;/code&gt; 의&lt;/em&gt; 에 &lt;em&gt; &lt;code&gt;archivename&lt;/code&gt; &lt;/em&gt; (이미 존재하지 않아야합니다), 다음 이름을 변경 &lt;em&gt; &lt;code&gt;oldname&lt;/code&gt; &lt;/em&gt; 에 &lt;em&gt; &lt;code&gt;newname&lt;/code&gt; 의&lt;/em&gt; . 두 번째 이름 바꾸기 단계가 실패 하면 오류를보고하기 전에 &lt;em&gt; &lt;code&gt;archivename&lt;/code&gt; 의&lt;/em&gt; 이름 을 &lt;em&gt; &lt;code&gt;newname&lt;/code&gt; 으로&lt;/em&gt; 다시 바꾸려고 시도합니다 . 성공하면 true를, 소스 파일이 없거나 쓸 수 없으면 false를 반환합니다. 다른 경우에는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a474a19464f9618c614537c462dff6566449078c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_file_unlink&lt;/code&gt; removes the specified file. Returns true on success, false if the specified file is not present or the &lt;code&gt;unlink()&lt;/code&gt; call fails; other cases throw errors.</source>
          <target state="translated">&lt;code&gt;pg_file_unlink&lt;/code&gt; 는 지정된 파일을 제거합니다. 성공하면 true를, 지정된 파일이 없거나 &lt;code&gt;unlink()&lt;/code&gt; 호출이 실패하면 false를 반환 합니다. 다른 경우에는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c46b9ab68bc31da80c1d6d387b1c1e73c5f08c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_file_write&lt;/code&gt; writes the specified &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt; into the file named by &lt;em&gt;&lt;code&gt;filename&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;append&lt;/code&gt;&lt;/em&gt; is false, the file must not already exist. If &lt;em&gt;&lt;code&gt;append&lt;/code&gt;&lt;/em&gt; is true, the file can already exist, and will be appended to if so. Returns the number of bytes written.</source>
          <target state="translated">&lt;code&gt;pg_file_write&lt;/code&gt; 는 지정된 &lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 를 &lt;em&gt; &lt;code&gt;filename&lt;/code&gt; &lt;/em&gt; 이라는 파일에 씁니다 . 경우 &lt;em&gt; &lt;code&gt;append&lt;/code&gt; &lt;/em&gt; 거짓 파일이 이미 존재하지 않아야합니다. &lt;em&gt; &lt;code&gt;append&lt;/code&gt; &lt;/em&gt; 가 true이면 파일이 이미 존재할 수 있으며 파일이 있으면 &lt;em&gt;추가&lt;/em&gt; 됩니다. 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa6d2b828c3e9de697a18913a3c165c168a49e39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_filenode_relation&lt;/code&gt; is the reverse of &lt;code&gt;pg_relation_filenode&lt;/code&gt;. Given a &amp;ldquo;tablespace&amp;rdquo; OID and a &amp;ldquo;filenode&amp;rdquo;, it returns the associated relation's OID. For a table in the database's default tablespace, the tablespace can be specified as 0.</source>
          <target state="translated">&lt;code&gt;pg_filenode_relation&lt;/code&gt; 은 &lt;code&gt;pg_relation_filenode&lt;/code&gt; 의 반대입니다 . &amp;ldquo;tablespace&amp;rdquo;OID와&amp;ldquo;filenode&amp;rdquo;가 주어지면 연관된 관계의 OID를 반환합니다. 데이터베이스의 기본 테이블 스페이스에있는 테이블의 경우 테이블 스페이스를 0으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f6b0cb216dbaaa22a79f05efd84fd9fa3ba391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_constraintdef&lt;/code&gt;, &lt;code&gt;pg_get_indexdef&lt;/code&gt;, &lt;code&gt;pg_get_ruledef&lt;/code&gt;, &lt;code&gt;pg_get_statisticsobjdef&lt;/code&gt;, and &lt;code&gt;pg_get_triggerdef&lt;/code&gt;, respectively reconstruct the creating command for a constraint, index, rule, extended statistics object, or trigger. (Note that this is a decompiled reconstruction, not the original text of the command.) &lt;code&gt;pg_get_expr&lt;/code&gt; decompiles the internal form of an individual expression, such as the default value for a column. It can be useful when examining the contents of system catalogs. If the expression might contain Vars, specify the OID of the relation they refer to as the second parameter; if no Vars are expected, zero is sufficient. &lt;code&gt;pg_get_viewdef&lt;/code&gt; reconstructs the &lt;code&gt;SELECT&lt;/code&gt; query that defines a view. Most of these functions come in two variants, one of which can optionally &amp;ldquo;pretty-print&amp;rdquo; the result. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of PostgreSQL; avoid using pretty-printed output for dump purposes. Passing &lt;code&gt;false&lt;/code&gt; for the pretty-print parameter yields the same result as the variant that does not have the parameter at all.</source>
          <target state="translated">&lt;code&gt;pg_get_constraintdef&lt;/code&gt; , &lt;code&gt;pg_get_indexdef&lt;/code&gt; , &lt;code&gt;pg_get_ruledef&lt;/code&gt; , &lt;code&gt;pg_get_statisticsobjdef&lt;/code&gt; 및 &lt;code&gt;pg_get_triggerdef&lt;/code&gt; 는 각각 제한 조건, 색인, 규칙, 확장 통계 오브젝트 또는 트리거에 대한 작성 명령을 재구성합니다. (이것은 명령의 원래 텍스트가 아니라 디 컴파일 된 재구성입니다.) &lt;code&gt;pg_get_expr&lt;/code&gt; 은 열의 기본값과 같은 개별 표현식의 내부 형식을 디 컴파일합니다. 시스템 카탈로그의 내용을 검사 할 때 유용 할 수 있습니다. 표현식에 Var이 포함될 수 있으면 두 번째 매개 변수라고하는 관계의 OID를 지정하십시오. Vars가 예상되지 않으면 0이면 충분합니다. &lt;code&gt;pg_get_viewdef&lt;/code&gt; 는 &lt;code&gt;SELECT&lt;/code&gt; 뷰를 정의하는 SELECT 쿼리 이러한 기능의 대부분은 두 가지 변형이 있으며 그 중 하나는 선택적으로 결과를 &quot;꽤 인쇄&quot;할 수 있습니다. 정교하게 인쇄 된 형식은 더 읽기 쉽지만 기본 형식은 이후 버전의 PostgreSQL에서 같은 방식으로 해석 될 가능성이 높습니다. 덤프 목적으로 예쁜 인쇄 출력을 사용하지 마십시오. pretty-print 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달하면 매개 변수가없는 변형과 동일한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9c2882fef851c07081d98c8d04056c67931e352d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_functiondef&lt;/code&gt; returns a complete &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; statement for a function. &lt;code&gt;pg_get_function_arguments&lt;/code&gt; returns the argument list of a function, in the form it would need to appear in within &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. &lt;code&gt;pg_get_function_result&lt;/code&gt; similarly returns the appropriate &lt;code&gt;RETURNS&lt;/code&gt; clause for the function. &lt;code&gt;pg_get_function_identity_arguments&lt;/code&gt; returns the argument list necessary to identify a function, in the form it would need to appear in within &lt;code&gt;ALTER FUNCTION&lt;/code&gt;, for instance. This form omits default values.</source>
          <target state="translated">&lt;code&gt;pg_get_functiondef&lt;/code&gt; 는 함수에 대한 완전한 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 문을 리턴 합니다. &lt;code&gt;pg_get_function_arguments&lt;/code&gt; 는 함수의 인수 목록을 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 내에 나타나는 형식으로 반환합니다 . &lt;code&gt;pg_get_function_result&lt;/code&gt; 는 유사하게 함수에 대한 적절한 &lt;code&gt;RETURNS&lt;/code&gt; 절을 리턴합니다 . &lt;code&gt;pg_get_function_identity_arguments&lt;/code&gt; 는 함수를 식별하는 데 필요한 인수 목록 을 예를 들어 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 내에 표시해야하는 형식으로 반환합니다 . 이 양식은 기본값을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="540025a892685d9e434d34f3ab5acf017491173d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_keywords&lt;/code&gt; returns a set of records describing the SQL keywords recognized by the server. The &lt;code&gt;word&lt;/code&gt; column contains the keyword. The &lt;code&gt;catcode&lt;/code&gt; column contains a category code: &lt;code&gt;U&lt;/code&gt; for unreserved, &lt;code&gt;C&lt;/code&gt; for column name, &lt;code&gt;T&lt;/code&gt; for type or function name, or &lt;code&gt;R&lt;/code&gt; for reserved. The &lt;code&gt;catdesc&lt;/code&gt; column contains a possibly-localized string describing the category.</source>
          <target state="translated">&lt;code&gt;pg_get_keywords&lt;/code&gt; 는 서버가 인식 한 SQL 키워드를 설명하는 레코드 세트를 리턴합니다. &lt;code&gt;word&lt;/code&gt; 열은 키워드가 포함되어 있습니다. &lt;code&gt;catcode&lt;/code&gt; 의 열은 카테고리 코드를 포함 &lt;code&gt;U&lt;/code&gt; 를 제한없이 기술을 위해 &lt;code&gt;C&lt;/code&gt; 열 이름 용 &lt;code&gt;T&lt;/code&gt; 형 또는 함수 이름 또는 대한 &lt;code&gt;R&lt;/code&gt; 예약합니다. &lt;code&gt;catdesc&lt;/code&gt; 의 열이 카테고리를 기술하는 가능성 지역화 문자열을 포함한다.</target>
        </trans-unit>
        <trans-unit id="c81135f96a1d3591c179d3202e4d71eeeb247607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_object_address&lt;/code&gt; returns a row containing enough information to uniquely identify the database object specified by its type and object name and argument arrays. The returned values are the ones that would be used in system catalogs such as &lt;code&gt;pg_depend&lt;/code&gt; and can be passed to other system functions such as &lt;code&gt;pg_identify_object&lt;/code&gt; or &lt;code&gt;pg_describe_object&lt;/code&gt;. &lt;em&gt;&lt;code&gt;classid&lt;/code&gt;&lt;/em&gt; is the OID of the system catalog containing the object; &lt;em&gt;&lt;code&gt;objid&lt;/code&gt;&lt;/em&gt; is the OID of the object itself, and &lt;em&gt;&lt;code&gt;objsubid&lt;/code&gt;&lt;/em&gt; is the sub-object ID, or zero if none. This function is the inverse of &lt;code&gt;pg_identify_object_as_address&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_get_object_address&lt;/code&gt; 는 유형과 객체 이름 및 인수 배열로 지정된 데이터베이스 객체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 리턴 된 값은 &lt;code&gt;pg_depend&lt;/code&gt; 와 같은 시스템 카탈로그에서 사용 되며 &lt;code&gt;pg_identify_object&lt;/code&gt; 또는 &lt;code&gt;pg_describe_object&lt;/code&gt; 와 같은 다른 시스템 기능으로 전달 될 수있는 값 입니다. &lt;em&gt; &lt;code&gt;classid&lt;/code&gt; &lt;/em&gt; 는 객체를 포함하는 시스템 카탈로그의 OID입니다. &lt;em&gt; &lt;code&gt;objid&lt;/code&gt; &lt;/em&gt; 는 객체 자체의 OID이고 &lt;em&gt; &lt;code&gt;objsubid&lt;/code&gt; &lt;/em&gt; 는 하위 객체 ID이며,없는 경우 0입니다. 이 함수는 &lt;code&gt;pg_identify_object_as_address&lt;/code&gt; 와 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="6bfac404b60dbe21eb8d7a4485998487fffa9fb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_serial_sequence&lt;/code&gt; returns the name of the sequence associated with a column, or NULL if no sequence is associated with the column. If the column is an identity column, the associated sequence is the sequence internally created for the identity column. For columns created using one of the serial types (&lt;code&gt;serial&lt;/code&gt;, &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;bigserial&lt;/code&gt;), it is the sequence created for that serial column definition. In the latter case, this association can be modified or removed with &lt;code&gt;ALTER SEQUENCE OWNED BY&lt;/code&gt;. (The function probably should have been called &lt;code&gt;pg_get_owned_sequence&lt;/code&gt;; its current name reflects the fact that it has typically been used with &lt;code&gt;serial&lt;/code&gt; or &lt;code&gt;bigserial&lt;/code&gt; columns.) The first input parameter is a table name with optional schema, and the second parameter is a column name. Because the first parameter is potentially a schema and table, it is not treated as a double-quoted identifier, meaning it is lower cased by default, while the second parameter, being just a column name, is treated as double-quoted and has its case preserved. The function returns a value suitably formatted for passing to sequence functions (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;). A typical use is in reading the current value of a sequence for an identity or serial column, for example:</source>
          <target state="translated">&lt;code&gt;pg_get_serial_sequence&lt;/code&gt; 는 열과 관련된 시퀀스의 이름을 반환하거나 열과 연결된 시퀀스가 ​​없으면 NULL을 반환합니다. 컬럼이 ID 컬럼 인 경우 연관된 시퀀스는 ID 컬럼에 대해 내부적으로 작성된 시퀀스입니다. 직렬 유형 ( &lt;code&gt;serial&lt;/code&gt; , &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;bigserial&lt;/code&gt; ) 중 하나를 사용하여 작성된 열의 경우 해당 직렬 열 정의에 대해 작성된 순서입니다. 후자의 경우,이 연관은 &lt;code&gt;ALTER SEQUENCE OWNED BY&lt;/code&gt; 로 수정하거나 제거 할 수 있습니다 . (이 함수는 아마도 &lt;code&gt;pg_get_owned_sequence&lt;/code&gt; 라고 불렀을 것입니다 ; 현재 이름은 일반적으로 &lt;code&gt;serial&lt;/code&gt; 또는 &lt;code&gt;bigserial&lt;/code&gt; 직렬 로 사용되었다는 사실을 반영합니다첫 번째 입력 매개 변수는 선택적 스키마가있는 테이블 이름이고 두 번째 매개 변수는 열 이름입니다. 첫 번째 매개 변수는 잠재적으로 스키마 및 테이블이므로 큰 따옴표로 식별되지 않습니다. 즉, 기본적으로 소문자로 표시되며 열 이름 인 두 번째 매개 변수는 큰 따옴표로 처리되며 사례 보존. 이 함수는 시퀀스 함수에 전달하기에 적합한 형식의 값을 반환합니다 ( &lt;a href=&quot;functions-sequence&quot;&gt;9.16 절&lt;/a&gt; 참조 ). 일반적으로 ID 또는 일련 열에 대한 시퀀스의 현재 값을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af5796b1b36562b31220c58f591806f3414c81c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_triggerdef&lt;/code&gt;(&lt;em&gt;&lt;code&gt;trigger_oid&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code&gt;pretty_bool&lt;/code&gt;&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;pg_get_triggerdef&lt;/code&gt; ( &lt;em&gt; &lt;code&gt;trigger_oid&lt;/code&gt; &lt;/em&gt; , &lt;em&gt; &lt;code&gt;pretty_bool&lt;/code&gt; &lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="23016aa0392a8899f78b5450146d26e3d6f6f6eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_get_userbyid&lt;/code&gt; extracts a role's name given its OID.</source>
          <target state="translated">&lt;code&gt;pg_get_userbyid&lt;/code&gt; 는 OID가 부여 된 역할의 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e4752deb54eb1e154ad6fc8d7f086c2390e6ae11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_has_role&lt;/code&gt; checks whether a user can access a role in a particular way. Its argument possibilities are analogous to &lt;code&gt;has_table_privilege&lt;/code&gt;, except that &lt;code&gt;public&lt;/code&gt; is not allowed as a user name. The desired access privilege type must evaluate to some combination of &lt;code&gt;MEMBER&lt;/code&gt; or &lt;code&gt;USAGE&lt;/code&gt;. &lt;code&gt;MEMBER&lt;/code&gt; denotes direct or indirect membership in the role (that is, the right to do &lt;code&gt;SET ROLE&lt;/code&gt;), while &lt;code&gt;USAGE&lt;/code&gt; denotes whether the privileges of the role are immediately available without doing &lt;code&gt;SET ROLE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_has_role&lt;/code&gt; 은 사용자가 특정 방식으로 역할에 액세스 할 수 있는지 확인합니다. 인수 가능성은 &lt;code&gt;has_table_privilege&lt;/code&gt; 와 유사 하지만 &lt;code&gt;public&lt;/code&gt; 은 사용자 이름으로 허용되지 않습니다. 원하는 액세스 권한 유형은 &lt;code&gt;MEMBER&lt;/code&gt; 또는 &lt;code&gt;USAGE&lt;/code&gt; 조합으로 평가되어야합니다 . &lt;code&gt;MEMBER&lt;/code&gt; 역할에 직접 또는 간접 회원 (즉, 바로이해야 할 의미 &lt;code&gt;SET ROLE&lt;/code&gt; 하면서) &lt;code&gt;USAGE&lt;/code&gt; 나타냅니다에게 역할의 권한을 수행하지 않고 즉시 사용할 수 있는지 여부를 &lt;code&gt;SET ROLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c698d47605cf698dfd5e9581420027860d43ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_hba.conf&lt;/code&gt; needs to be adjusted to allow replication (the values here depend on your actual network configuration and user you want to use for connecting):</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 는 복제를 허용하도록 조정해야합니다 (여기서 값은 실제 네트워크 구성 및 연결에 사용하려는 사용자에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="561349478698bcb2123798fe7da493a2741a8969" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_identify_object&lt;/code&gt; returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and sub-object ID. This information is intended to be machine-readable, and is never translated. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; identifies the type of database object; &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; is the schema name that the object belongs in, or &lt;code&gt;NULL&lt;/code&gt; for object types that do not belong to schemas; &lt;em&gt;&lt;code&gt;name&lt;/code&gt;&lt;/em&gt; is the name of the object, quoted if necessary, if the name (along with schema name, if pertinent) is sufficient to uniquely identify the object, otherwise &lt;code&gt;NULL&lt;/code&gt;; &lt;em&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/em&gt; is the complete object identity, with the precise format depending on object type, and each name within the format being schema-qualified and quoted as necessary.</source>
          <target state="translated">&lt;code&gt;pg_identify_object&lt;/code&gt; 는 카탈로그 OID, 객체 OID 및 하위 객체 ID로 지정된 데이터베이스 객체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 이 정보는 기계가 읽을 수 있도록 작성되었으며 절대 번역되지 않습니다. &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 데이터베이스 객체의 유형을 식별합니다. &lt;em&gt; &lt;code&gt;schema&lt;/code&gt; &lt;/em&gt; 는 객체가 속한 스키마 이름이거나 스키마에 속하지 않는 객체 유형의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다. &lt;em&gt; &lt;code&gt;name&lt;/code&gt; &lt;/em&gt; 은 이름 (해당되는 경우 스키마 이름과 함께)이 오브젝트를 고유하게 식별하기에 충분하면 필요한 경우 인용되는 오브젝트의 이름입니다 . 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 입니다 . &lt;em&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/em&gt;는 객체 유형에 따라 정확한 형식과 필요에 따라 스키마로 규정되고 인용되는 형식 내의 각 이름과 함께 완전한 객체 ID입니다.</target>
        </trans-unit>
        <trans-unit id="c98dc17b0da97cf61f078d8d63652adf0e447052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_identify_object_as_address&lt;/code&gt; returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and sub-object ID. The returned information is independent of the current server, that is, it could be used to identify an identically named object in another server. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; identifies the type of database object; &lt;em&gt;&lt;code&gt;object_names&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;object_args&lt;/code&gt;&lt;/em&gt; are text arrays that together form a reference to the object. These three values can be passed to &lt;code&gt;pg_get_object_address&lt;/code&gt; to obtain the internal address of the object. This function is the inverse of &lt;code&gt;pg_get_object_address&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_identify_object_as_address&lt;/code&gt; 는 카탈로그 OID, 객체 OID 및 하위 객체 ID로 지정된 데이터베이스 객체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 리턴 된 정보는 현재 서버와 독립적입니다. 즉, 다른 서버에서 동일한 이름의 오브젝트를 식별하는 데 사용될 수 있습니다. &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 데이터베이스 객체의 유형을 식별합니다. &lt;em&gt; &lt;code&gt;object_names&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;object_args&lt;/code&gt; &lt;/em&gt; 는 함께 객체에 대한 참조를 형성하는 텍스트 배열입니다. 이 세 값은 &lt;code&gt;pg_get_object_address&lt;/code&gt; 로 전달되어 객체의 내부 주소를 얻을 수 있습니다 . 이 함수는 &lt;code&gt;pg_get_object_address&lt;/code&gt; 와 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="65022b62c3c3af3138aec18191347835e167a693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_import_system_collations&lt;/code&gt; adds collations to the system catalog &lt;code&gt;pg_collation&lt;/code&gt; based on all the locales it finds in the operating system. This is what &lt;code&gt;initdb&lt;/code&gt; uses; see &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;Section 23.2.2&lt;/a&gt; for more details. If additional locales are installed into the operating system later on, this function can be run again to add collations for the new locales. Locales that match existing entries in &lt;code&gt;pg_collation&lt;/code&gt; will be skipped. (But collation objects based on locales that are no longer present in the operating system are not removed by this function.) The &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; parameter would typically be &lt;code&gt;pg_catalog&lt;/code&gt;, but that is not a requirement; the collations could be installed into some other schema as well. The function returns the number of new collation objects it created.</source>
          <target state="translated">&lt;code&gt;pg_import_system_collations&lt;/code&gt; 는 운영 체제에서 찾은 모든 로캘을 기반으로 시스템 카탈로그 &lt;code&gt;pg_collation&lt;/code&gt; 에 데이터 정렬을 추가 합니다. 이것이 &lt;code&gt;initdb&lt;/code&gt; 가 사용하는 것입니다; 자세한 내용 &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;은 23.2.2 단원&lt;/a&gt; 을 참조하십시오. 나중에 운영 체제에 추가 로캘이 설치된 경우이 기능을 다시 실행하여 새 로캘에 대한 데이터 정렬을 추가 할 수 있습니다. &lt;code&gt;pg_collation&lt;/code&gt; 의 기존 항목과 일치하는 로캘은 건너 뜁니다. 그러나 운영 체제에 더 이상 존재하지 않는 로케일을 기반으로 한 데이터 정렬 오브젝트는이 기능으로 제거되지 않습니다. &lt;em&gt; &lt;code&gt;schema&lt;/code&gt; &lt;/em&gt; 매개 변수는 일반적으로 &lt;code&gt;pg_catalog&lt;/code&gt; 입니다.그러나 그것은 요구 사항이 아닙니다. 데이터 정렬은 다른 스키마에도 설치 될 수 있습니다. 이 함수는 작성된 새 데이터 정렬 오브젝트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3719d716d1e3119a20e1303547fdfd727f8aeec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_index_column_has_property&lt;/code&gt;, &lt;code&gt;pg_index_has_property&lt;/code&gt;, and &lt;code&gt;pg_indexam_has_property&lt;/code&gt; return whether the specified index column, index, or index access method possesses the named property. &lt;code&gt;NULL&lt;/code&gt; is returned if the property name is not known or does not apply to the particular object, or if the OID or column number does not identify a valid object. Refer to &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-COLUMN-PROPS&quot;&gt;Table 9.69&lt;/a&gt; for column properties, &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-PROPS&quot;&gt;Table 9.70&lt;/a&gt; for index properties, and &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEXAM-PROPS&quot;&gt;Table 9.71&lt;/a&gt; for access method properties. (Note that extension access methods can define additional property names for their indexes.)</source>
          <target state="translated">&lt;code&gt;pg_index_column_has_property&lt;/code&gt; , &lt;code&gt;pg_index_has_property&lt;/code&gt; 및 &lt;code&gt;pg_indexam_has_property&lt;/code&gt; 는 지정된 인덱스 열, 인덱스 또는 인덱스 액세스 방법에 명명 된 속성이 있는지 여부를 반환합니다. 등록 정보 이름을 알 수 없거나 특정 객체에 적용되지 않거나 OID 또는 열 번호가 유효한 객체를 식별하지 않으면 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다. 열 속성 은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-COLUMN-PROPS&quot;&gt;표 9.69&lt;/a&gt; , 인덱스 속성은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEX-PROPS&quot;&gt;표 9.70&lt;/a&gt; , 액세스 방법 속성은 &lt;a href=&quot;functions-info#FUNCTIONS-INFO-INDEXAM-PROPS&quot;&gt;표 9.71&lt;/a&gt; 을 참조하십시오 . 확장 액세스 방법은 색인에 대한 추가 특성 이름을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebc1fbbbc2b69fe60e75631d3a42483ad2e77c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_indexes_size&lt;/code&gt; accepts the OID or name of a table and returns the total disk space used by all the indexes attached to that table.</source>
          <target state="translated">&lt;code&gt;pg_indexes_size&lt;/code&gt; 는 테이블의 OID 또는 이름을 승인하고 해당 테이블에 첨부 된 모든 인덱스가 사용하는 총 디스크 공간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fc3b4c69b14387405657b905f26f99b47853af7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_internal.init&lt;/code&gt; files can be omitted from the backup whenever a file of that name is found. These files contain relation cache data that is always rebuilt when recovering.</source>
          <target state="translated">&lt;code&gt;pg_internal.init&lt;/code&gt; 파일은 해당 이름의 파일을 찾을 때마다 백업에서 생략 될 수 있습니다. 이러한 파일에는 복구시 항상 재 구축되는 관계 캐시 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7cb89b09214dbfcd1efeff3eed48f41fb71a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_isready&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_isready&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="09ac4954dabeab1b515829080f9920b808c166d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_isready&lt;/code&gt;, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;pg_isready&lt;/code&gt; 는 대부분의 다른 PostgreSQL 유틸리티와 마찬가지로 libpq에서 지원하는 환경 변수도 사용합니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;33.14 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8a8e0b1021ac872b5fc0398c1878b626961ca2bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_listening_channels&lt;/code&gt; returns a set of names of asynchronous notification channels that the current session is listening to. &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; returns the fraction of the total available space for notifications currently occupied by notifications that are waiting to be processed, as a &lt;code&gt;double&lt;/code&gt; in the range 0-1. See &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;pg_listening_channels&lt;/code&gt; 는 현재 세션이 수신중인 비동기 알림 채널의 이름 세트를 리턴합니다. &lt;code&gt;pg_notification_queue_usage&lt;/code&gt; 는 처리 대기중인 알림이 현재 사용중인 알림에 대해 사용 가능한 총 공간의 일부를 0-1 범위 의 &lt;code&gt;double&lt;/code&gt; 반환합니다 . 자세한 내용은 &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; 및 &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7ddd14707d2e33a20c2f5aa8d09bfa8610b50c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_locks&lt;/code&gt; contains one row per active lockable object, requested lock mode, and relevant process. Thus, the same lockable object might appear many times, if multiple processes are holding or waiting for locks on it. However, an object that currently has no locks on it will not appear at all.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 는 활성 잠금 가능 객체, 요청 된 잠금 모드 및 관련 프로세스 당 하나의 행을 포함합니다. 따라서 여러 프로세스가 잠금을 보유하거나 대기중인 경우 동일한 잠금 가능 오브젝트가 여러 번 나타날 수 있습니다. 그러나 현재 잠금이 설정되지 않은 개체는 전혀 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb0e876d331c63cc1ef3923395280aa77ec3a74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_locks&lt;/code&gt; provides a global view of all locks in the database cluster, not only those relevant to the current database. Although its &lt;code&gt;relation&lt;/code&gt; column can be joined against &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;oid&lt;/code&gt; to identify locked relations, this will only work correctly for relations in the current database (those for which the &lt;code&gt;database&lt;/code&gt; column is either the current database's OID or zero).</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 는 현재 데이터베이스와 관련된 잠금뿐만 아니라 데이터베이스 클러스터의 모든 잠금에 대한 전체 뷰를 제공합니다. 그 &lt;code&gt;relation&lt;/code&gt; 에도 불구하고 열은 &lt;code&gt;pg_class&lt;/code&gt; 에 대해 결합 될 수 . &lt;code&gt;oid&lt;/code&gt; 잠겨 관계를 식별하는 데, 이것은 단지합니다 (그되는 현재 데이터베이스의 관계에 대해 제대로 작동 &lt;code&gt;database&lt;/code&gt; 열이 중 현재 데이터베이스의 OID 또는 제로).</target>
        </trans-unit>
        <trans-unit id="3bd26449020d36403ce0dc42d84d7ec20216a31b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_locks&lt;/code&gt; will show locks held by backends, as normal. &lt;code&gt;pg_locks&lt;/code&gt; also shows a virtual transaction managed by the Startup process that owns all &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by transactions being replayed by recovery. Note that the Startup process does not acquire locks to make database changes, and thus locks other than &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; do not show in &lt;code&gt;pg_locks&lt;/code&gt; for the Startup process; they are just presumed to exist.</source>
          <target state="translated">&lt;code&gt;pg_locks&lt;/code&gt; 는 정상적으로 백엔드가 보유한 잠금을 표시합니다. &lt;code&gt;pg_locks&lt;/code&gt; 는 또한 시작 프로세스가 관리하는 가상 트랜잭션을 보여줍니다. &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 이 트랜잭션은 복구에 의해 재생되는 트랜잭션이 AccessExclusiveLock . 시작 프로세스는 데이터베이스를 변경하기 위해 잠금을 획득하지 않으므로 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; 이외의 잠금 은 시작 프로세스의 &lt;code&gt;pg_locks&lt;/code&gt; 에 표시되지 않습니다 . 그들은 단지 존재하는 것으로 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="37537391330ff73e271cfe85d6c3406aeaf461f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_logdir_ls&lt;/code&gt; returns the start timestamps and path names of all the log files in the &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; directory. The &lt;a href=&quot;runtime-config-logging#GUC-LOG-FILENAME&quot;&gt;log_filename&lt;/a&gt; parameter must have its default setting (&lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;) to use this function.</source>
          <target state="translated">&lt;code&gt;pg_logdir_ls&lt;/code&gt; 는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; 에있는 모든 로그 파일의 시작 타임 스탬프 및 경로 이름을 반환합니다 디렉토리 . &lt;a href=&quot;runtime-config-logging#GUC-LOG-FILENAME&quot;&gt;LOG_FILENAME의&lt;/a&gt; 파라미터의 초기 설정을한다 ( &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; )이 기능을 사용.</target>
        </trans-unit>
        <trans-unit id="6c67f845da18f0c9e21fb6b41ea32d8c2875ed1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ls_archive_statusdir&lt;/code&gt; returns the name, size, and last modified time (mtime) of each file in the WAL archive status directory &lt;code&gt;pg_wal/archive_status&lt;/code&gt;. By default only superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role can use this function. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ls_archive_statusdir&lt;/code&gt; 은 WAL 아카이브 상태 디렉토리 &lt;code&gt;pg_wal/archive_status&lt;/code&gt; 에있는 각 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다 . 기본적으로 수퍼 유저와 &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원 만이 기능을 사용할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9e1af99cc37b4b73e412d7d722e82c3a110d918" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ls_dir&lt;/code&gt; returns the names of all files (and directories and other special files) in the specified directory. The &lt;em&gt;&lt;code&gt;include_dot_dirs&lt;/code&gt;&lt;/em&gt; indicates whether &amp;ldquo;.&amp;rdquo; and &amp;ldquo;..&amp;rdquo; are included in the result set. The default is to exclude them (&lt;code&gt;false&lt;/code&gt;), but including them can be useful when &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, to distinguish an empty directory from an non-existent directory.</source>
          <target state="translated">&lt;code&gt;pg_ls_dir&lt;/code&gt; 은 지정된 디렉토리에있는 모든 파일 (및 디렉토리 및 기타 특수 파일)의 이름을 반환합니다. &lt;em&gt; &lt;code&gt;include_dot_dirs&lt;/code&gt; 이&lt;/em&gt; 있는지 여부를 나타냅니다 &quot;.&quot; 결과 집합에 &quot;..&quot;이 포함됩니다. 기본값은 제외 ( &lt;code&gt;false&lt;/code&gt; )이지만 빈 디렉토리를 존재하지 않는 디렉토리와 구별하기 위해 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우이를 포함하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1a182412a3d53b1e753d911b46c230035af1dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ls_logdir&lt;/code&gt; returns the name, size, and last modified time (mtime) of each file in the log directory. By default, only superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role can use this function. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ls_logdir&lt;/code&gt; 은 로그 디렉토리에있는 각 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다. 기본적으로 &lt;code&gt;pg_monitor&lt;/code&gt; 역할 의 수퍼 유저 및 구성원 만이 기능을 사용할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="169bed956fa6b53bf37d7b038c26c16852c811b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ls_tmpdir&lt;/code&gt; returns the name, size, and last modified time (mtime) of each file in the temporary file directory for the specified &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. By default only superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role can use this function. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ls_tmpdir&lt;/code&gt; 은 지정된 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 의 임시 파일 디렉토리에있는 각 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다 . 경우 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 제공되지는 &lt;code&gt;pg_default&lt;/code&gt; 의 테이블 스페이스가 사용됩니다. 기본적으로 슈퍼 유저와 &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 기능을 사용할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81711f6565961149351fda152141662bf3fa96fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_ls_waldir&lt;/code&gt; returns the name, size, and last modified time (mtime) of each file in the write ahead log (WAL) directory. By default only superusers and members of the &lt;code&gt;pg_monitor&lt;/code&gt; role can use this function. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ls_waldir&lt;/code&gt; 는 WAL (Write Forward Log) 디렉토리에있는 각 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다. 기본적으로 수퍼 유저와 &lt;code&gt;pg_monitor&lt;/code&gt; 역할의 구성원 만이 기능을 사용할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2ce1e87a59f7d9c41d272b771b7728f7452014" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_mcv_list_items&lt;/code&gt; returns a list of all items stored in a multi-column MCV list, and returns the following columns:</source>
          <target state="translated">&lt;code&gt;pg_mcv_list_items&lt;/code&gt; 는 다중 열 MCV 목록에 저장된 모든 항목의 목록을 반환하고 다음 열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="447443f032118334fb8951c0d744c772989bb0b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_my_temp_schema&lt;/code&gt; returns the OID of the current session's temporary schema, or zero if it has none (because it has not created any temporary tables). &lt;code&gt;pg_is_other_temp_schema&lt;/code&gt; returns true if the given OID is the OID of another session's temporary schema. (This can be useful, for example, to exclude other sessions' temporary tables from a catalog display.)</source>
          <target state="translated">&lt;code&gt;pg_my_temp_schema&lt;/code&gt; 는 현재 세션 임시 스키마의 OID를 반환하거나 존재하지 않는 경우 0을 반환합니다 (임시 테이블을 생성하지 않았기 때문에). 주어진 OID가 다른 세션의 임시 스키마의 OID이면 &lt;code&gt;pg_is_other_temp_schema&lt;/code&gt; 는 true를 반환합니다. (예를 들어, 다른 세션의 임시 테이블을 카탈로그 표시에서 제외하는 데 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7f4936cdb2063f48974e3137605d3f439e0c3ea5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_options_to_table&lt;/code&gt; returns the set of storage option name/value pairs (&lt;code&gt;option_name&lt;/code&gt;/&lt;code&gt;option_value&lt;/code&gt;) when passed &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reloptions&lt;/code&gt; or &lt;code&gt;pg_attribute&lt;/code&gt;.&lt;code&gt;attoptions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_options_to_table&lt;/code&gt; 은 &lt;code&gt;pg_class&lt;/code&gt; 가 전달 될 때 스토리지 옵션 이름 / 값 쌍 세트 ( &lt;code&gt;option_name&lt;/code&gt; / &lt;code&gt;option_value&lt;/code&gt; )를 리턴합니다 . &lt;code&gt;reloptions&lt;/code&gt; 또는 &lt;code&gt;pg_attribute&lt;/code&gt; . &lt;code&gt;attoptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f016d9be5901950f2744c90efa12cfeeac2ba008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_postmaster_start_time&lt;/code&gt; returns the &lt;code&gt;timestamp with time zone&lt;/code&gt; when the server started.</source>
          <target state="translated">&lt;code&gt;pg_postmaster_start_time&lt;/code&gt; 은 &lt;code&gt;timestamp with time zone&lt;/code&gt; 서버가 시작된 시간대와 타임 스탬프를 .</target>
        </trans-unit>
        <trans-unit id="eadf0675461503466f0c0d1706771cc02d5e1e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_prepared_statements&lt;/code&gt; contains one row for each prepared statement. Rows are added to the view when a new prepared statement is created and removed when a prepared statement is released (for example, via the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command).</source>
          <target state="translated">&lt;code&gt;pg_prepared_statements&lt;/code&gt; 에는 준비된 각 문마다 하나의 행이 있습니다. 새로운 준비된 명령문이 작성 될 때 행이보기에 추가되고 준비된 명령문이 해제 될 때 (예 :&lt;a href=&quot;sql-deallocate&quot;&gt; DEALLOCATE&lt;/a&gt; 명령을 .</target>
        </trans-unit>
        <trans-unit id="c4b109e1725e96e356f03c52f2ef35c83cba5747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_prepared_xacts&lt;/code&gt; contains one row per prepared transaction. An entry is removed when the transaction is committed or rolled back.</source>
          <target state="translated">&lt;code&gt;pg_prepared_xacts&lt;/code&gt; 는 준비된 트랜잭션 당 하나의 행을 포함합니다. 트랜잭션이 커밋되거나 롤백 될 때 항목이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5d806cc3b8706a9d0040e35a180ceb5796fc7de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_prewarm.autoprewarm&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_prewarm.autoprewarm&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="71340e603659e9d6dff6b7d146fe01eab238efa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_prewarm.autoprewarm_interval&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_prewarm.autoprewarm_interval&lt;/code&gt; ( &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="53bf86eb4757ba4af5d483ebd4aedd02cebab301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_proc&lt;/code&gt; OID of the aggregate function</source>
          <target state="translated">&lt;code&gt;pg_proc&lt;/code&gt; 집계 함수의 pg_proc OID</target>
        </trans-unit>
        <trans-unit id="26e7d82fbacbdbcb6ca3e5aae11891847695af24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_read_binary_file&lt;/code&gt; is similar to &lt;code&gt;pg_read_file&lt;/code&gt;, except that the result is a &lt;code&gt;bytea&lt;/code&gt; value; accordingly, no encoding checks are performed. In combination with the &lt;code&gt;convert_from&lt;/code&gt; function, this function can be used to read a file in a specified encoding:</source>
          <target state="translated">&lt;code&gt;pg_read_binary_file&lt;/code&gt; 은 결과가 &lt;code&gt;bytea&lt;/code&gt; 라는 점을 제외하고 &lt;code&gt;pg_read_file&lt;/code&gt; 과 유사합니다. 값 합니다. 따라서 인코딩 검사가 수행되지 않습니다. 와 함께 &lt;code&gt;convert_from&lt;/code&gt; 의 기능이 기능은 지정된 인코딩 된 파일을 판독하는데 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="d0c564db8ed85645af5d4441cafa54aa1989999a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_read_file&lt;/code&gt; returns part of a text file, starting at the given &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, returning at most &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; bytes (less if the end of file is reached first). If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, it is relative to the end of the file. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; are omitted, the entire file is returned. The bytes read from the file are interpreted as a string in the server encoding; an error is thrown if they are not valid in that encoding.</source>
          <target state="translated">&lt;code&gt;pg_read_file&lt;/code&gt; 은 텍스트 파일의 일부를 주어진 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작 하여 최대 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 바이트를 반환 합니다 (파일의 끝에 도달 한 경우는 적음). 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정적이고, 파일의 끝 부분에 상대적입니다. 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 및&lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 생략, 전체 파일이 반환됩니다. 파일에서 읽은 바이트는 서버 인코딩에서 문자열로 해석됩니다. 해당 인코딩에서 유효하지 않은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e64fa0050eb2f17a97eb3ce6d6a7b327423310f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_receivewal&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_receivewal&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="7317167e90f7dbcfab15ba896caa04f88ff5f94f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_recvlogical&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_recvlogical&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="3ca4b21c729c30369ff7d592756e4484b982f7a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_recvlogical&lt;/code&gt; controls logical decoding replication slots and streams data from such replication slots.</source>
          <target state="translated">&lt;code&gt;pg_recvlogical&lt;/code&gt; 은 논리적 디코딩 복제 슬롯을 제어하고 이러한 복제 슬롯에서 데이터를 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="6de5ffc72a7873ff23f10dd67080c793b150efbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_recvlogical&lt;/code&gt; has no equivalent to the logical decoding SQL interface's peek and get modes. It sends replay confirmations for data lazily as it receives it and on clean exit. To examine pending data on a slot without consuming it, use &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt;&lt;code&gt;pg_logical_slot_peek_changes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_recvlogical&lt;/code&gt; 은 논리적 디코딩 SQL 인터페이스의 엿보기 및 가져 오기 모드와 동일하지 않습니다. 데이터가 수신되고 깨끗하게 종료 될 때 데이터에 대한 재생 확인을 느리게 보냅니다. 슬롯에서 보류중인 데이터를 소비하지 않고 검사하려면 &lt;a href=&quot;functions-admin#FUNCTIONS-REPLICATION&quot;&gt; &lt;code&gt;pg_logical_slot_peek_changes&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="a76fd1ac2635bbf1382ca2ee084230925252ec6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_relation_filenode&lt;/code&gt; accepts the OID or name of a table, index, sequence, or toast table, and returns the &amp;ldquo;filenode&amp;rdquo; number currently assigned to it. The filenode is the base component of the file name(s) used for the relation (see &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt; for more information). For most tables the result is the same as &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt;, but for certain system catalogs &lt;code&gt;relfilenode&lt;/code&gt; is zero and this function must be used to get the correct value. The function returns NULL if passed a relation that does not have storage, such as a view.</source>
          <target state="translated">&lt;code&gt;pg_relation_filenode&lt;/code&gt; 는 테이블, 인덱스, 시퀀스 또는 토스트 테이블의 OID 또는 이름을 승인하고 현재 지정된 &quot;filenode&quot;번호를 리턴합니다. 파일 노드는 관계에 사용되는 파일 이름의 기본 구성 요소입니다 (자세한 내용 &lt;a href=&quot;storage-file-layout&quot;&gt;은 68.1 절&lt;/a&gt; 참조 ). 대부분의 테이블에서 결과는 &lt;code&gt;pg_class&lt;/code&gt; 와 같습니다 . &lt;code&gt;relfilenode&lt;/code&gt; 이지만 특정 시스템 카탈로그의 경우 &lt;code&gt;relfilenode&lt;/code&gt; 는 0 이며이 함수를 사용하여 올바른 값을 가져와야 합니다. 뷰와 같이 저장 영역이없는 관계를 전달하면 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8bac7ad34dec765d669e937e70477e68b12b58f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_relation_filepath&lt;/code&gt; is similar to &lt;code&gt;pg_relation_filenode&lt;/code&gt;, but it returns the entire file path name (relative to the database cluster's data directory &lt;code&gt;PGDATA&lt;/code&gt;) of the relation.</source>
          <target state="translated">&lt;code&gt;pg_relation_filepath&lt;/code&gt; 는 pg_relation_filenode 와 유사 하지만 &lt;code&gt;pg_relation_filenode&lt;/code&gt; 의 전체 파일 경로 이름 (데이터베이스 클러스터의 데이터 디렉토리 &lt;code&gt;PGDATA&lt;/code&gt; 에 대한 )을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="08313493d91f0b4d2ee33c8e0687238a3829590a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_relation_size&lt;/code&gt; accepts the OID or name of a table, index or toast table, and returns the on-disk size in bytes of one fork of that relation. (Note that for most purposes it is more convenient to use the higher-level functions &lt;code&gt;pg_total_relation_size&lt;/code&gt; or &lt;code&gt;pg_table_size&lt;/code&gt;, which sum the sizes of all forks.) With one argument, it returns the size of the main data fork of the relation. The second argument can be provided to specify which fork to examine:</source>
          <target state="translated">&lt;code&gt;pg_relation_size&lt;/code&gt; 는 테이블, 인덱스 또는 토스트 테이블의 OID 또는 이름을 허용하고 해당 관계의 한 포크에 대한 디스크 크기를 바이트 단위로 반환합니다. (대부분 의 경우 모든 포크의 크기를 합산 하는 더 높은 레벨의 함수 &lt;code&gt;pg_total_relation_size&lt;/code&gt; 또는 &lt;code&gt;pg_table_size&lt;/code&gt; 를 사용하는 것이 더 편리합니다 .) 하나의 인수로 관계의 기본 데이터 포크의 크기를 리턴합니다. 검사 할 포크를 지정하기 위해 두 번째 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3537855120c00b24585020abbfee475585f74d93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_reload_conf&lt;/code&gt; sends a SIGHUP signal to the server, causing configuration files to be reloaded by all server processes.</source>
          <target state="translated">&lt;code&gt;pg_reload_conf&lt;/code&gt; 는 SIGHUP 신호를 서버로 전송하여 모든 서버 프로세스에서 구성 파일을 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="2df2d3b50640eac98903b3f088aaf29fae48de2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_relpages&lt;/code&gt; returns the number of pages in the relation.</source>
          <target state="translated">&lt;code&gt;pg_relpages&lt;/code&gt; 는 관계의 페이지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5013c1f55852e276d4fab74268631eca65a7122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_resetwal&lt;/code&gt; [ &lt;code&gt;--force&lt;/code&gt; | &lt;code&gt;-f&lt;/code&gt; ] [ &lt;code&gt;--dry-run&lt;/code&gt; | &lt;code&gt;-n&lt;/code&gt; ] [&lt;code&gt;option&lt;/code&gt;...] [ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; [ &lt;code&gt;--force&lt;/code&gt; | &lt;code&gt;-f&lt;/code&gt; ] [ &lt;code&gt;--dry-run&lt;/code&gt; | &lt;code&gt;-n&lt;/code&gt; ] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;--pgdata&lt;/code&gt; | &lt;code&gt;-D&lt;/code&gt; ] &lt;code&gt;datadir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de9071b6a11a21da32fdf12fafddf7bd0ffb0487" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_resetwal&lt;/code&gt; clears the write-ahead log (WAL) and optionally resets some other control information stored in the &lt;code&gt;pg_control&lt;/code&gt; file. This function is sometimes needed if these files have become corrupted. It should be used only as a last resort, when the server will not start due to such corruption.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 은 미리 쓰기 로그 (WAL)를 지우고 &lt;code&gt;pg_control&lt;/code&gt; 파일에 저장된 다른 제어 정보를 선택적으로 재설정 합니다. 이러한 파일이 손상된 경우이 기능이 필요할 수 있습니다. 이러한 손상으로 인해 서버가 시작되지 않는 최후의 수단으로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a914732c0b2766d95484c0aa61608b09056bd0bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_resetwal&lt;/code&gt; itself looks at the files in &lt;code&gt;pg_wal&lt;/code&gt; and chooses a default &lt;code&gt;-l&lt;/code&gt; setting beyond the last existing file name. Therefore, manual adjustment of &lt;code&gt;-l&lt;/code&gt; should only be needed if you are aware of WAL segment files that are not currently present in &lt;code&gt;pg_wal&lt;/code&gt;, such as entries in an offline archive; or if the contents of &lt;code&gt;pg_wal&lt;/code&gt; have been lost entirely.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 자체는 &lt;code&gt;pg_wal&lt;/code&gt; 의 파일을 보고 마지막 기존 파일 이름 이외의 기본 &lt;code&gt;-l&lt;/code&gt; 설정을 선택합니다 . 따라서 오프라인 아카이브의 항목과 같이 현재 &lt;code&gt;pg_wal&lt;/code&gt; 에 없는 WAL 세그먼트 파일을 알고있는 경우에만 &lt;code&gt;-l&lt;/code&gt; 을 수동으로 조정 해야합니다 . 또는 &lt;code&gt;pg_wal&lt;/code&gt; 의 내용이 완전히 손실 된 경우.</target>
        </trans-unit>
        <trans-unit id="b5b028f795bb92a1a1ade43f205839ac071cb380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_resetwal&lt;/code&gt; works only with servers of the same major version.</source>
          <target state="translated">&lt;code&gt;pg_resetwal&lt;/code&gt; 은 동일한 주 버전의 서버에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61fe9ad835c580db0dcae39e405cf53097b5a802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_restore&lt;/code&gt; [&lt;code&gt;connection-option&lt;/code&gt;...] [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;filename&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pg_restore&lt;/code&gt; [ &lt;code&gt;connection-option&lt;/code&gt; ...] [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;filename&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="f82281ab4fce923592e75f914128012db07fd4b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_rewind&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] { &lt;code&gt;-D&lt;/code&gt; | &lt;code&gt;--target-pgdata&lt;/code&gt; } &lt;code&gt;directory&lt;/code&gt; { &lt;code&gt;--source-pgdata=directory&lt;/code&gt; | &lt;code&gt;--source-server=connstr&lt;/code&gt; }</source>
          <target state="translated">&lt;code&gt;pg_rewind&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] { &lt;code&gt;-D&lt;/code&gt; | &lt;code&gt;--target-pgdata&lt;/code&gt; } &lt;code&gt;directory&lt;/code&gt; { &lt;code&gt;--source-pgdata=directory&lt;/code&gt; | &lt;code&gt;--source-server=connstr&lt;/code&gt; }</target>
        </trans-unit>
        <trans-unit id="110bfe5a1b634bb3b1e51adc31ada96435052744" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_rotate_logfile&lt;/code&gt; signals the log-file manager to switch to a new output file immediately. This works only when the built-in log collector is running, since otherwise there is no log-file manager subprocess.</source>
          <target state="translated">&lt;code&gt;pg_rotate_logfile&lt;/code&gt; 은 로그 파일 관리자에게 새로운 출력 파일로 즉시 전환하도록 신호를 보냅니다. 내장 로그 수집기가 실행중인 경우에만 작동합니다. 그렇지 않으면 로그 파일 관리자 하위 프로세스가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ef06b668e75446d5ab27fa6e1f816cef5bd494cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_safe_snapshot_blocking_pids&lt;/code&gt; returns an array of the process IDs of the sessions that are blocking the server process with the specified process ID from acquiring a safe snapshot, or an empty array if there is no such server process or it is not blocked. A session running a &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions. Frequent calls to this function could have some impact on database performance, because it needs access to the predicate lock manager's shared state for a short time.</source>
          <target state="translated">&lt;code&gt;pg_safe_snapshot_blocking_pids&lt;/code&gt; 는 지정된 프로세스 ID로 서버 프로세스가 안전한 스냅 샷을 얻지 못하도록 차단하는 세션의 프로세스 ID 배열을 반환하거나 서버 프로세스가 없거나 차단되지 않은 경우 빈 배열을 반환합니다. &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션을 실행하는 세션 은 &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션이 스냅 샷이 술어 잠금을 사용하지 않는 것이 안전하다고 판단 될 때까지 스냅 샷을 확보하지 못하도록 차단합니다. 직렬화 가능하고 지연 가능한 트랜잭션에 대한 자세한 내용은 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3 단원을&lt;/a&gt; 참조하십시오 . 이 함수를 자주 호출하면 술어 잠금 관리자의 공유 상태에 짧은 시간 동안 액세스해야하므로 데이터베이스 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="720546cef4e4deacbd8a5c4f89c71db3fa1d7b2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_size_bytes&lt;/code&gt; can be used to get the size in bytes from a string in human-readable format. The input may have units of bytes, kB, MB, GB or TB, and is parsed case-insensitively. If no units are specified, bytes are assumed.</source>
          <target state="translated">&lt;code&gt;pg_size_bytes&lt;/code&gt; 는 사람이 읽을 수있는 형식의 문자열에서 크기를 바이트 단위로 가져 오는 데 사용할 수 있습니다. 입력은 바이트 단위, kB, MB, GB 또는 TB를 가질 수 있으며 대소 문자를 구분하지 않고 구문 분석됩니다. 단위를 지정하지 않으면 바이트가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="4aeb1a78a02c20e5c9f933fe1d67b6e0d8230926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_size_pretty&lt;/code&gt; can be used to format the result of one of the other functions in a human-readable way, using bytes, kB, MB, GB or TB as appropriate.</source>
          <target state="translated">&lt;code&gt;pg_size_pretty&lt;/code&gt; 는 바이트, kB, MB, GB 또는 TB를 적절히 사용하여 사람이 읽을 수있는 방식으로 다른 함수 중 하나의 결과를 형식화하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4703d0d71ec0a4a90434cdf8ed812011e79b8127" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_sleep&lt;/code&gt; makes the current session's process sleep until &lt;code&gt;seconds&lt;/code&gt; seconds have elapsed. &lt;code&gt;seconds&lt;/code&gt; is a value of type &lt;code&gt;double precision&lt;/code&gt;, so fractional-second delays can be specified. &lt;code&gt;pg_sleep_for&lt;/code&gt; is a convenience function for larger sleep times specified as an &lt;code&gt;interval&lt;/code&gt;. &lt;code&gt;pg_sleep_until&lt;/code&gt; is a convenience function for when a specific wake-up time is desired. For example:</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; 가 될 때까지 현재 세션의 프로세스 잠을 수 &lt;code&gt;seconds&lt;/code&gt; 초 경과. &lt;code&gt;seconds&lt;/code&gt; 는 &lt;code&gt;double precision&lt;/code&gt; 유형의 값이므로 초 단위 지연을 지정할 수 있습니다. &lt;code&gt;pg_sleep_for&lt;/code&gt; 는 &lt;code&gt;interval&lt;/code&gt; 지정된 더 큰 수면 시간을위한 편의 기능입니다 . &lt;code&gt;pg_sleep_until&lt;/code&gt; 은 특정 웨이크 업 시간이 필요할 때 편리한 기능입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3601c9b240355b0e935ec2f19c7d0d4f6817e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_start_backup&lt;/code&gt; accepts an arbitrary user-defined label for the backup. (Typically this would be the name under which the backup dump file will be stored.) When used in exclusive mode, the function writes a backup label file (&lt;code&gt;backup_label&lt;/code&gt;) and, if there are any links in the &lt;code&gt;pg_tblspc/&lt;/code&gt; directory, a tablespace map file (&lt;code&gt;tablespace_map&lt;/code&gt;) into the database cluster's data directory, performs a checkpoint, and then returns the backup's starting write-ahead log location as text. The user can ignore this result value, but it is provided in case it is useful. When used in non-exclusive mode, the contents of these files are instead returned by the &lt;code&gt;pg_stop_backup&lt;/code&gt; function, and should be written to the backup by the caller.</source>
          <target state="translated">&lt;code&gt;pg_start_backup&lt;/code&gt; 은 백업에 임의의 사용자 정의 레이블을 허용합니다. (일반적으로이 이름은 백업 덤프 파일이 저장 될 이름입니다.) 독점 모드에서 사용될 경우, 함수는 백업 레이블 파일 ( &lt;code&gt;backup_label&lt;/code&gt; )을 작성하며 &lt;code&gt;pg_tblspc/&lt;/code&gt; 디렉토리에 링크가있는 경우 테이블 스페이스 맵 파일 ( &lt;code&gt;tablespace_map&lt;/code&gt; )을 데이터베이스 클러스터의 데이터 디렉토리에 넣고 검사 점을 수행 한 다음 백업의 시작 미리 쓰기 로그 위치를 텍스트로 반환합니다. 사용자는이 결과 값을 무시할 수 있지만 유용한 경우에 제공됩니다. 비 독점 모드에서 사용되는 &lt;code&gt;pg_stop_backup&lt;/code&gt; 파일의 내용은 pg_stop_backup 함수에 의해 대신 반환되며 호출자가 백업에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="99a3f9fa7f8557236bb969356fc9a52f8a51ebbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_file&lt;/code&gt; returns a record containing the file size, last accessed time stamp, last modified time stamp, last file status change time stamp (Unix platforms only), file creation time stamp (Windows only), and a &lt;code&gt;boolean&lt;/code&gt; indicating if it is a directory. Typical usages include:</source>
          <target state="translated">&lt;code&gt;pg_stat_file&lt;/code&gt; 은 파일 크기, 마지막 액세스 타임 스탬프, 마지막 수정 타임 스탬프, 마지막 파일 상태 변경 타임 스탬프 (Unix 플랫폼 만 해당), 파일 작성 타임 스탬프 (Windows 만 해당) 및 디렉토리인지를 나타내는 &lt;code&gt;boolean&lt;/code&gt; 포함하는 레코드를 리턴합니다 . 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8841fa0e1e88258d031ec7923ec95618d10b0a3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_get_activity&lt;/code&gt;, the underlying function of the &lt;code&gt;pg_stat_activity&lt;/code&gt; view, returns a set of records containing all the available information about each backend process. Sometimes it may be more convenient to obtain just a subset of this information. In such cases, an older set of per-backend statistics access functions can be used; these are shown in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-BACKEND-FUNCS-TABLE&quot;&gt;Table 27.21&lt;/a&gt;. These access functions use a backend ID number, which ranges from one to the number of currently active backends. The function &lt;code&gt;pg_stat_get_backend_idset&lt;/code&gt; provides a convenient way to generate one row for each active backend for invoking these functions. For example, to show the PIDs and current queries of all backends:</source>
          <target state="translated">&lt;code&gt;pg_stat_get_activity&lt;/code&gt; 보기 의 기본 함수 인 &lt;code&gt;pg_stat_activity&lt;/code&gt; 는 각 백엔드 프로세스에 대해 사용 가능한 모든 정보를 포함하는 레코드 세트를 리턴합니다. 때때로이 정보의 일부만 얻는 것이 더 편리 할 수 ​​있습니다. 이러한 경우, 이전의 백엔드 당 통계 액세스 기능 세트를 사용할 수 있습니다. 이들은 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-BACKEND-FUNCS-TABLE&quot;&gt;표 27.21&lt;/a&gt; 에 나와 있습니다. 이러한 액세스 기능은 1에서 현재 활성화 된 백엔드 수에 이르는 백엔드 ID 번호를 사용합니다. &lt;code&gt;pg_stat_get_backend_idset&lt;/code&gt; 함수 는 이러한 함수를 호출하기 위해 각 활성 백엔드마다 하나의 행을 생성하는 편리한 방법을 제공합니다. 예를 들어 모든 백엔드의 PID 및 현재 쿼리를 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="999782864908e4bc39845c96e902436aa7d762bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.max&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.max&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc0099d2eebe33a92d1f42bf5c17ee0f13b57350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.max&lt;/code&gt; is the maximum number of statements tracked by the module (i.e., the maximum number of rows in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view). If more distinct statements than that are observed, information about the least-executed statements is discarded. The default value is 5000. This parameter can only be set at server start.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.max&lt;/code&gt; 는 모듈이 추적하는 최대 명령문 수입니다 (예 : &lt;code&gt;pg_stat_statements&lt;/code&gt; 뷰 의 최대 행 수). 그보다 더 분명한 명령문이 관찰되면 가장 적게 실행 된 명령문에 대한 정보가 삭제됩니다. 기본값은 5000입니다.이 매개 변수는 서버 시작시에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc20a2d7eec4ddfb6eba454870440e40bab03688" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.save&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.save&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b02fd0552e62caeba0b706a349eb5b0f32c556ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.save&lt;/code&gt; specifies whether to save statement statistics across server shutdowns. If it is &lt;code&gt;off&lt;/code&gt; then statistics are not saved at shutdown nor reloaded at server start. The default value is &lt;code&gt;on&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.save&lt;/code&gt; 는 서버 종료시 명령문 통계를 저장할지 여부를 지정합니다. &lt;code&gt;off&lt;/code&gt; 있으면 통계는 종료시 저장되거나 서버 시작시 다시로드되지 않습니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17b3bc77ade467a9226b48876b253390a8cdb436" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.track&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.track&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c2cff2ddb1d51dbbd436f01776a6dcefc8c8ce9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.track&lt;/code&gt; controls which statements are counted by the module. Specify &lt;code&gt;top&lt;/code&gt; to track top-level statements (those issued directly by clients), &lt;code&gt;all&lt;/code&gt; to also track nested statements (such as statements invoked within functions), or &lt;code&gt;none&lt;/code&gt; to disable statement statistics collection. The default value is &lt;code&gt;top&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.track&lt;/code&gt; 은 모듈이 계산하는 명령문을 제어합니다. 지정 &lt;code&gt;top&lt;/code&gt; , 최상위 문 (클라이언트가 직접 발행하는)을 추적하기 위해 &lt;code&gt;all&lt;/code&gt; , 또는 (예 : 함수 내에서 호출 문으로) 중첩 된 문을 추적 할 수 &lt;code&gt;none&lt;/code&gt; 해제 문 통계 수집합니다. 기본값은 &lt;code&gt;top&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e266dcca3cd76fe2ea9d4b367563937e046804f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.track_utility&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.track_utility&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="364c0aaab15fe4985ffc64059557463814f0c9fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements.track_utility&lt;/code&gt; controls whether utility commands are tracked by the module. Utility commands are all those other than &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. The default value is &lt;code&gt;on&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements.track_utility&lt;/code&gt; 는 모듈이 유틸리티 명령을 추적하는지 여부를 제어합니다. 유틸리티 명령은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 이외의 명령 입니다. 기본값은 &lt;code&gt;on&lt;/code&gt; 입니다. 수퍼 유저 만이 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653d24ebfe1d8a35f8f24ad7140d633551e29ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stat_statements_reset&lt;/code&gt; discards statistics gathered so far by &lt;code&gt;pg_stat_statements&lt;/code&gt; corresponding to the specified &lt;code&gt;userid&lt;/code&gt;, &lt;code&gt;dbid&lt;/code&gt; and &lt;code&gt;queryid&lt;/code&gt;. If any of the parameters are not specified, the default value &lt;code&gt;0&lt;/code&gt;(invalid) is used for each of them and the statistics that match with other parameters will be reset. If no parameter is specified or all the specified parameters are &lt;code&gt;0&lt;/code&gt;(invalid), it will discard all statistics. By default, this function can only be executed by superusers. Access may be granted to others using &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stat_statements_reset&lt;/code&gt; 은 지정된 &lt;code&gt;userid&lt;/code&gt; , &lt;code&gt;dbid&lt;/code&gt; 및 &lt;code&gt;queryid&lt;/code&gt; 에 해당하는 &lt;code&gt;pg_stat_statements&lt;/code&gt; 가 지금까지 수집 한 통계를 버립니다 . 매개 변수를 지정하지 않으면 각 매개 변수에 대해 기본값 &lt;code&gt;0&lt;/code&gt; (유효하지 않음)이 사용되며 다른 매개 변수와 일치하는 통계가 재설정됩니다. 매개 변수를 지정하지 않거나 지정된 모든 매개 변수가 &lt;code&gt;0&lt;/code&gt; (유효하지 않은)이면 모든 통계를 버립니다. 기본적으로이 기능은 수퍼 유저 만 실행할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 다른 사람에게 액세스 권한이 부여 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d21df48f93c381a4503422864507188131c7c8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_statistic&lt;/code&gt; also stores statistical data about the values of index expressions. These are described as if they were actual data columns; in particular, &lt;code&gt;starelid&lt;/code&gt; references the index. No entry is made for an ordinary non-expression index column, however, since it would be redundant with the entry for the underlying table column. Currently, entries for index expressions always have &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 은 인덱스 표현식 값에 대한 통계 데이터도 저장합니다. 이들은 실제 데이터 열인 것처럼 설명됩니다. 특히, &lt;code&gt;starelid&lt;/code&gt; 는 색인을 참조합니다. 그러나 일반 비 표현식 인덱스 열은 기본 테이블 열의 항목과 중복되므로 항목이 작성되지 않습니다. 현재 인덱스 표현식의 항목은 항상 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef93916e067f1fd4381bb59ffc18d3cb17877b75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_statistic&lt;/code&gt; should not be readable by the public, since even statistical information about a table's contents might be considered sensitive. (Example: minimum and maximum values of a salary column might be quite interesting.) &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic&lt;/code&gt; that only exposes information about those tables that are readable by the current user.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 테이블 내용에 대한 통계 정보조차도 민감한 것으로 간주 될 수 있기 때문에 pg_statistic 은 일반인이 읽을 수 없어야합니다. (예 : 급여 열의 최소값과 최대 값은 매우 흥미로울 수 있습니다.) &lt;a href=&quot;view-pg-stats&quot;&gt; &lt;code&gt;pg_stats&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;pg_statistic&lt;/code&gt; 에서 공개적으로 읽을 수있는보기 로, 현재 사용자가 읽을 수있는 테이블에 대한 정보 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="acc28c7ebf574586e8c25bfe14c2489c87511eb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stats&lt;/code&gt; is also designed to present the information in a more readable format than the underlying catalog &amp;mdash; at the cost that its schema must be extended whenever new slot types are defined for &lt;code&gt;pg_statistic&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stats&lt;/code&gt; 는 또한 새로운 카탈로그 유형이 &lt;code&gt;pg_statistic&lt;/code&gt; 에 대해 정의 될 때마다 스키마를 확장해야하는 비용으로 기본 카탈로그보다 더 읽기 쉬운 형식으로 정보를 표시하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="80c0fccb907b43a5727930b9ed2a4f792a3503ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_stats_ext&lt;/code&gt; is also designed to present the information in a more readable format than the underlying catalogs &amp;mdash; at the cost that its schema must be extended whenever new types of extended statistics are added to &lt;code&gt;pg_statistic_ext&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_stats_ext&lt;/code&gt; 는 또한 새로운 유형의 확장 된 통계가 &lt;code&gt;pg_statistic_ext&lt;/code&gt; 에 추가 될 때마다 스키마를 확장해야하는 비용으로 기본 카탈로그보다 더 읽기 쉬운 형식으로 정보를 표시하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ab1c1c7367a5d53c62e7ee54111551ce20440b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_switch_wal&lt;/code&gt; moves to the next write-ahead log file, allowing the current file to be archived (assuming you are using continuous archiving). The return value is the ending write-ahead log location + 1 within the just-completed write-ahead log file. If there has been no write-ahead log activity since the last write-ahead log switch, &lt;code&gt;pg_switch_wal&lt;/code&gt; does nothing and returns the start location of the write-ahead log file currently in use.</source>
          <target state="translated">&lt;code&gt;pg_switch_wal&lt;/code&gt; 은 다음 미리 쓰기 로그 파일로 이동하여 현재 파일을 아카이브 할 수 있습니다 (연속 아카이브를 사용한다고 가정). 리턴 값은 방금 완료된 미리 쓰기 로그 파일 내의 종료 미리 쓰기 로그 위치 + 1입니다. 마지막 미리 쓰기 로그 스위치 이후 미리 쓰기 로그 작업이 &lt;code&gt;pg_switch_wal&lt;/code&gt; 은 아무 것도 수행하지 않고 현재 사용중인 미리 쓰기 로그 파일의 시작 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f4cabb263bdc491b0ad82998517a86530271cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_table_size&lt;/code&gt; accepts the OID or name of a table and returns the disk space needed for that table, exclusive of indexes. (TOAST space, free space map, and visibility map are included.)</source>
          <target state="translated">&lt;code&gt;pg_table_size&lt;/code&gt; 는 테이블의 OID 또는 이름을 승인하고 인덱스를 제외하고 해당 테이블에 필요한 디스크 공간을 리턴합니다. (TOAST 공간, 여유 공간 맵 및 가시성 맵이 포함됩니다.)</target>
        </trans-unit>
        <trans-unit id="ab1409b141cf34a70a6f37674b4053e05b3d00e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_tablespace_databases&lt;/code&gt; allows a tablespace to be examined. It returns the set of OIDs of databases that have objects stored in the tablespace. If this function returns any rows, the tablespace is not empty and cannot be dropped. To display the specific objects populating the tablespace, you will need to connect to the databases identified by &lt;code&gt;pg_tablespace_databases&lt;/code&gt; and query their &lt;code&gt;pg_class&lt;/code&gt; catalogs.</source>
          <target state="translated">&lt;code&gt;pg_tablespace_databases&lt;/code&gt; 를 사용하면 테이블 스페이스를 검사 할 수 있습니다. 테이블 스페이스에 오브젝트가 저장된 데이터베이스의 OID 세트를 리턴합니다. 이 함수가 행을 리턴하면 테이블 스페이스가 비어 있지 않고 삭제할 수 없습니다. 테이블 스페이스를 채우는 특정 객체를 표시하려면 &lt;code&gt;pg_tablespace_databases&lt;/code&gt; 로 식별 된 데이터베이스에 연결하고 해당 &lt;code&gt;pg_class&lt;/code&gt; 카탈로그를 쿼리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="11904833a89ff3967739f7d549d15e4a7b60990c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_test_fsync&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_test_fsync&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="2c91e8781241b17134436b014de211f748307e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_test_timing&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_test_timing&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="f6ee71ad80fc8fb506f31ed4fc92c5d19b0f80cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_total_relation_size&lt;/code&gt; accepts the OID or name of a table or toast table, and returns the total on-disk space used for that table, including all associated indexes. This function is equivalent to &lt;code&gt;pg_table_size&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;pg_indexes_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_total_relation_size&lt;/code&gt; 는 테이블 또는 토스트 테이블의 OID 또는 이름을 승인하고 연관된 모든 인덱스를 포함하여 해당 테이블에 사용 된 총 디스크 공간을 반환합니다. 이 함수는 &lt;code&gt;pg_table_size&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;pg_indexes_size&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="35292604d7088fa50aca89913bfbf0daa6fc0ec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt; (&lt;code&gt;real&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt; ( &lt;code&gt;real&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e123d9f2e880a61ba3ad44eda1a85e0f88daff4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_trgm.strict_word_similarity_threshold&lt;/code&gt; (&lt;code&gt;real&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_trgm.strict_word_similarity_threshold&lt;/code&gt; ( &lt;code&gt;real&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b2cbc1ba977ece60e8b7745939b36c25a3bdbfac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_trgm.word_similarity_threshold&lt;/code&gt; (&lt;code&gt;real&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pg_trgm.word_similarity_threshold&lt;/code&gt; ( &lt;code&gt;real&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4844d7362eb3ff5e3ff879d5ac3dd8efbc094873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_trgm&lt;/code&gt; ignores non-word characters (non-alphanumerics) when extracting trigrams from a string. Each word is considered to have two spaces prefixed and one space suffixed when determining the set of trigrams contained in the string. For example, the set of trigrams in the string &amp;ldquo;&lt;code&gt;cat&lt;/code&gt;&amp;rdquo; is &amp;ldquo; &lt;code&gt;c&lt;/code&gt;&amp;rdquo;, &amp;ldquo; &lt;code&gt;ca&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;cat&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;&lt;code&gt;at&lt;/code&gt; &amp;rdquo;. The set of trigrams in the string &amp;ldquo;&lt;code&gt;foo|bar&lt;/code&gt;&amp;rdquo; is &amp;ldquo; &lt;code&gt;f&lt;/code&gt;&amp;rdquo;, &amp;ldquo; &lt;code&gt;fo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;oo&lt;/code&gt; &amp;rdquo;, &amp;ldquo; &lt;code&gt;b&lt;/code&gt;&amp;rdquo;, &amp;ldquo; &lt;code&gt;ba&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;bar&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;&lt;code&gt;ar&lt;/code&gt; &amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;pg_trgm&lt;/code&gt; 은 문자열에서 트라이 그램을 추출 할 때 단어가 아닌 문자 (영숫자가 아닌)를 무시합니다. 각 단어는 문자열에 포함 된 트라이 그램 세트를 결정할 때 접두사 두 개와 접미사 한 개가있는 것으로 간주됩니다. 예를 들어, 문자열 &quot; &lt;code&gt;cat&lt;/code&gt; &quot; 의 트라이 그램 세트 는 &quot; &lt;code&gt;c&lt;/code&gt; &quot;, &quot; &lt;code&gt;ca&lt;/code&gt; &quot;, &quot; &lt;code&gt;cat&lt;/code&gt; &quot;및 &quot; &lt;code&gt;at&lt;/code&gt; &quot;입니다. 문자열 &quot; &lt;code&gt;foo|bar&lt;/code&gt; &quot; 의 트라이 그램 세트 는 &quot; &lt;code&gt;f&lt;/code&gt; &quot;, &quot; &lt;code&gt;fo&lt;/code&gt; &quot;, &quot; &lt;code&gt;foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;oo&lt;/code&gt; &quot;, &quot; &lt;code&gt;b&lt;/code&gt; &quot;, &quot; &lt;code&gt;ba&lt;/code&gt; &quot;, &quot; &lt;code&gt;bar&lt;/code&gt; &quot;및 &quot; &lt;code&gt;ar&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="64122ff3b434dece31913b4b42f24170123930dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_try_advisory_lock&lt;/code&gt; is similar to &lt;code&gt;pg_advisory_lock&lt;/code&gt;, except the function will not wait for the lock to become available. It will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; if the lock cannot be acquired immediately.</source>
          <target state="translated">&lt;code&gt;pg_try_advisory_lock&lt;/code&gt; 은 &lt;code&gt;pg_advisory_lock&lt;/code&gt; 과 비슷하지만 , 함수가 잠금을 사용할 수있을 때까지 기다리지 않습니다. 잠금을 즉시 확보하고 &lt;code&gt;true&lt;/code&gt; 를 리턴하거나 잠금을 즉시 확보 할 수 없으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4a68c0ba7617672e4be81b8d2585fdb51ce1ab65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_try_advisory_lock_shared&lt;/code&gt; works the same as &lt;code&gt;pg_try_advisory_lock&lt;/code&gt;, except it attempts to acquire a shared rather than an exclusive lock.</source>
          <target state="translated">&lt;code&gt;pg_try_advisory_lock_shared&lt;/code&gt; 은 동일하게 작동 &lt;code&gt;pg_try_advisory_lock&lt;/code&gt; 을 그것이이 배타적 잠금이 아닌 공유 획득 시도를 제외하고.</target>
        </trans-unit>
        <trans-unit id="e5d035f1923c9fd0e176ca2ebbfd44e23b43c051" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_try_advisory_xact_lock&lt;/code&gt; works the same as &lt;code&gt;pg_try_advisory_lock&lt;/code&gt;, except the lock, if acquired, is automatically released at the end of the current transaction and cannot be released explicitly.</source>
          <target state="translated">&lt;code&gt;pg_try_advisory_xact_lock&lt;/code&gt; 가 동일하게 작동 &lt;code&gt;pg_try_advisory_lock&lt;/code&gt; 을 구입 한 경우 잠금을 제외하고, 자동으로 현재 트랜잭션의 끝에서 해제되고 명시 적으로 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7aabb459cc823250a19f9915e0852b1d01ea62b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_try_advisory_xact_lock_shared&lt;/code&gt; works the same as &lt;code&gt;pg_try_advisory_lock_shared&lt;/code&gt;, except the lock, if acquired, is automatically released at the end of the current transaction and cannot be released explicitly.</source>
          <target state="translated">&lt;code&gt;pg_try_advisory_xact_lock_shared&lt;/code&gt; 는 같은 작동 &lt;code&gt;pg_try_advisory_lock_shared&lt;/code&gt; 구입 한 경우 자동으로 현재의 트랜잭션 (transaction)의 끝에서 해제, 잠금 제외하고, 명시 적으로 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="097730ae1a41d7c6b9bc8ac35346c19b3f576df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_typeof&lt;/code&gt; returns the OID of the data type of the value that is passed to it. This can be helpful for troubleshooting or dynamically constructing SQL queries. The function is declared as returning &lt;code&gt;regtype&lt;/code&gt;, which is an OID alias type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); this means that it is the same as an OID for comparison purposes but displays as a type name. For example:</source>
          <target state="translated">&lt;code&gt;pg_typeof&lt;/code&gt; 는 전달 된 값의 데이터 유형에 대한 OID를 반환합니다. 이는 SQL 쿼리 문제를 해결하거나 동적으로 구성하는 데 도움이 될 수 있습니다. 이 함수는 OID 별명 유형 인 &lt;code&gt;regtype&lt;/code&gt; 반환으로 선언됩니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 이는 비교 목적으로 OID와 동일하지만 유형 이름으로 표시됨을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e3aa094921b9bc15be021b830a2240db661776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_upgrade&lt;/code&gt; will connect to the old and new servers several times, so you might want to set authentication to &lt;code&gt;peer&lt;/code&gt; in &lt;code&gt;pg_hba.conf&lt;/code&gt; or use a &lt;code&gt;~/.pgpass&lt;/code&gt; file (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;Section 33.15&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; 는 기존 서버와 새로운 서버에 여러 번 연결되므로 &lt;code&gt;pg_hba.conf&lt;/code&gt; 에서 &lt;code&gt;peer&lt;/code&gt; 로 인증하도록 설정 하거나 &lt;code&gt;~/.pgpass&lt;/code&gt; &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-pgpass.html&quot;&gt;.pgpass&lt;/a&gt; 파일을 사용하고 싶을 수도 있습니다 ( 33.15 절 참조 ).</target>
        </trans-unit>
        <trans-unit id="9246844e0a4b44a19fbbf37dfbe75a875c07f2f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_upgrade&lt;/code&gt;&lt;code&gt;-b&lt;/code&gt;&lt;code&gt;oldbindir&lt;/code&gt;&lt;code&gt;-B&lt;/code&gt;&lt;code&gt;newbindir&lt;/code&gt;&lt;code&gt;-d&lt;/code&gt;&lt;code&gt;oldconfigdir&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt;&lt;code&gt;newconfigdir&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; &lt;code&gt;-b&lt;/code&gt; &lt;code&gt;oldbindir&lt;/code&gt; &lt;code&gt;-B&lt;/code&gt; &lt;code&gt;newbindir&lt;/code&gt; &lt;code&gt;-d&lt;/code&gt; &lt;code&gt;oldconfigdir&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; &lt;code&gt;newconfigdir&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="6b824ecc36104d997c9e7b1e01da4a5df5c0d42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; calculates the difference in bytes between two write-ahead log locations. It can be used with &lt;code&gt;pg_stat_replication&lt;/code&gt; or some functions shown in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; to get the replication lag.</source>
          <target state="translated">&lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; 는 두 미리 쓰기 로그 위치 간의 바이트 차이를 계산합니다. 복제 지연을 얻기 위해 &lt;code&gt;pg_stat_replication&lt;/code&gt; 또는 &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;표 9.84&lt;/a&gt; 에 표시된 일부 기능 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="837fd5bff999da4235758db0901b701c5c8ca9d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_waldump&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;startseg&lt;/code&gt; [&lt;code&gt;endseg&lt;/code&gt;]]</source>
          <target state="translated">&lt;code&gt;pg_waldump&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;startseg&lt;/code&gt; [ &lt;code&gt;endseg&lt;/code&gt; ]]</target>
        </trans-unit>
        <trans-unit id="8448727980656c0bfd86da716d56a4b2d7b6a39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pg_waldump&lt;/code&gt; displays the write-ahead log (WAL) and is mainly useful for debugging or educational purposes.</source>
          <target state="translated">&lt;code&gt;pg_waldump&lt;/code&gt; 는 미리 쓰기 로그 (WAL)를 표시하며 주로 디버깅 또는 교육 목적에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5257e102ed7509f56d1384efe6e0127c1a6139de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgbench -i&lt;/code&gt; creates four tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;, destroying any existing tables of these names. Be very careful to use another database if you have tables having these names!</source>
          <target state="translated">&lt;code&gt;pgbench -i&lt;/code&gt; 는 &lt;code&gt;pgbench_accounts&lt;/code&gt; , &lt;code&gt;pgbench_branches&lt;/code&gt; , &lt;code&gt;pgbench_history&lt;/code&gt; 및 &lt;code&gt;pgbench_tellers&lt;/code&gt; 네 개의 테이블을 작성 하여 이러한 이름의 기존 테이블을 삭제합니다. 이러한 이름을 가진 테이블이있는 경우 다른 데이터베이스를 사용하도록주의하십시오!</target>
        </trans-unit>
        <trans-unit id="be8553f50acddd9a91e9c6d325362d9fcbb56e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgbench&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;dbname&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pgbench&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;dbname&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="66cef9947920144393aa39654a94aad37d3aa6df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgbench&lt;/code&gt;&lt;code&gt;-i&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;dbname&lt;/code&gt;]</source>
          <target state="translated">&lt;code&gt;pgbench&lt;/code&gt; &lt;code&gt;-i&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;dbname&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="cad3097c55a5ca5fbcdea82d2f258d710baf1fac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgcrypto&lt;/code&gt; configures itself according to the findings of the main PostgreSQL &lt;code&gt;configure&lt;/code&gt; script. The options that affect it are &lt;code&gt;--with-zlib&lt;/code&gt; and &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pgcrypto&lt;/code&gt; 는 기본 PostgreSQL &lt;code&gt;configure&lt;/code&gt; 스크립트 의 결과에 따라 자체적으로 구성 됩니다. 영향을주는 옵션은 &lt;code&gt;--with-zlib&lt;/code&gt; 및 &lt;code&gt;--with-openssl&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d074d4a2aedde13cc764215ca76da9b7f488e9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgcrypto&lt;/code&gt; uses code from the following sources:</source>
          <target state="translated">&lt;code&gt;pgcrypto&lt;/code&gt; 는 다음 소스의 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5b7f23b69be461b1a4bdef63d549d6d895e9dea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgp_armor_headers()&lt;/code&gt; extracts the armor headers from &lt;em&gt;&lt;code&gt;data&lt;/code&gt;&lt;/em&gt;. The return value is a set of rows with two columns, key and value. If the keys or values contain any non-ASCII characters, they are treated as UTF-8.</source>
          <target state="translated">&lt;code&gt;pgp_armor_headers()&lt;/code&gt; 는 &lt;em&gt; &lt;code&gt;data&lt;/code&gt; &lt;/em&gt; 에서 armor 헤더를 추출합니다 . 리턴 값은 키와 값이라는 두 개의 열이있는 행 세트입니다. 키 또는 값에 ASCII가 아닌 문자가 포함 된 경우 UTF-8로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a0a39866951b81bb7287778711d952cc0f26d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgp_key_id&lt;/code&gt; extracts the key ID of a PGP public or secret key. Or it gives the key ID that was used for encrypting the data, if given an encrypted message.</source>
          <target state="translated">&lt;code&gt;pgp_key_id&lt;/code&gt; 는 PGP 공개 또는 비밀 키의 키 ID를 추출합니다. 또는 암호화 된 메시지가 제공된 경우 데이터를 암호화하는 데 사용 된 키 ID를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="894f86406633a6b193dda5d212c7fcb480467c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgrowlocks&lt;/code&gt; does not show the contents of locked rows. If you want to take a look at the row contents at the same time, you could do something like this:</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; 는 잠긴 행의 내용을 표시하지 않습니다. 행 내용을 동시에 보려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa5f0bb86df5a130bb3963ced3951d706ae8fe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgrowlocks&lt;/code&gt; is not guaranteed to produce a self-consistent snapshot. It is possible that a new row lock is taken, or an old lock is freed, during its execution.</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; 가 일관된 스냅 샷을 생성한다고 보장하지는 않습니다. 실행 중에 새 행 잠금이 수행되거나 이전 잠금이 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b3b08f13a4596b092f6a501eb7383efd3ffd573" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgrowlocks&lt;/code&gt; takes &lt;code&gt;AccessShareLock&lt;/code&gt; for the target table and reads each row one by one to collect the row locking information. This is not very speedy for a large table. Note that:</source>
          <target state="translated">&lt;code&gt;pgrowlocks&lt;/code&gt; 는 대상 테이블에 대해 &lt;code&gt;AccessShareLock&lt;/code&gt; 을 가져 와서 각 행을 하나씩 읽어 행 잠금 정보를 수집합니다. 큰 테이블에서는 속도가 그리 빠르지 않습니다. 참고 :</target>
        </trans-unit>
        <trans-unit id="c996e10b7bc0b41411344c526713d85942fb1418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstatginindex&lt;/code&gt; returns a record showing information about a GIN index. For example:</source>
          <target state="translated">&lt;code&gt;pgstatginindex&lt;/code&gt; 는 GIN 인덱스에 대한 정보를 보여주는 레코드를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8aa55fe170ddf63f79e6fdd4cb8139eb0714f72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstathashindex&lt;/code&gt; returns a record showing information about a HASH index. For example:</source>
          <target state="translated">&lt;code&gt;pgstathashindex&lt;/code&gt; 는 HASH 인덱스에 대한 정보를 보여주는 레코드를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dda2bd5c21d39996f0a0373b600c8b8a1bc1b9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstatindex&lt;/code&gt; returns a record showing information about a B-tree index. For example:</source>
          <target state="translated">&lt;code&gt;pgstatindex&lt;/code&gt; 는 B- 트리 인덱스에 대한 정보를 보여주는 레코드를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="866dce9c48ad83a29a828f0f9552b79322dce174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstattuple&lt;/code&gt; acquires only a read lock on the relation. So the results do not reflect an instantaneous snapshot; concurrent updates will affect them.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; 은 관계에 대한 읽기 잠금 만 획득합니다. 따라서 결과는 즉각적인 스냅 샷을 반영하지 않습니다. 동시 업데이트가 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="4f37b9dd5331331a2cd95a863a322399789b2c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstattuple&lt;/code&gt; judges a tuple is &amp;ldquo;dead&amp;rdquo; if &lt;code&gt;HeapTupleSatisfiesDirty&lt;/code&gt; returns false.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; 은 &lt;code&gt;HeapTupleSatisfiesDirty&lt;/code&gt; 가 false를 반환 하면 튜플이 &quot;죽었다&quot;고 판단합니다 .</target>
        </trans-unit>
        <trans-unit id="f0187fa9d11dbd102eed31565412bce055641615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstattuple&lt;/code&gt; returns a relation's physical length, percentage of &amp;ldquo;dead&amp;rdquo; tuples, and other info. This may help users to determine whether vacuum is necessary or not. The argument is the target relation's name (optionally schema-qualified) or OID. For example:</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; 은 관계의 물리적 길이, &quot;죽은&quot;튜플의 백분율 및 기타 정보를 반환합니다. 이를 통해 사용자는 진공이 필요한지 여부를 판단 할 수 있습니다. 인수는 대상 관계의 이름 (선택적으로 스키마 규정) 또는 OID입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bca4859199af8eabba232987be2b918c8202ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pgstattuple_approx&lt;/code&gt; is a faster alternative to &lt;code&gt;pgstattuple&lt;/code&gt; that returns approximate results. The argument is the target relation's name or OID. For example:</source>
          <target state="translated">&lt;code&gt;pgstattuple_approx&lt;/code&gt; 는 대략적인 결과를 반환 하는 &lt;code&gt;pgstattuple&lt;/code&gt; 의 빠른 대안 입니다. 인수는 대상 관계의 이름 또는 OID입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7c54df587fd7c1bebaad424ca6663f1c11423fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phraseto_tsquery&lt;/code&gt; behaves much like &lt;code&gt;plainto_tsquery&lt;/code&gt;, except that it inserts the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) operator between surviving words instead of the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) operator. Also, stop words are not simply discarded, but are accounted for by inserting &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; operators rather than &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; operators. This function is useful when searching for exact lexeme sequences, since the FOLLOWED BY operators check lexeme order not just the presence of all the lexemes.</source>
          <target state="translated">&lt;code&gt;phraseto_tsquery&lt;/code&gt; 는 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) 연산자 대신 생존 단어 사이에 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) 연산자를 삽입한다는 점을 제외하면 &lt;code&gt;plainto_tsquery&lt;/code&gt; 와 매우 유사하게 작동합니다. 또한 중지 단어는 단순히 삭제되지 않고 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 연산자가 아닌 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 연산자 를 삽입하여 설명됩니다 . 이 함수는 정확한 lexeme 시퀀스를 검색 할 때 유용합니다. FOLLOWED BY 연산자는 모든 lexemes의 존재 만이 아니라 lexeme 순서를 확인하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c3fcb92e980161f6874a4bcc9d901a1157781cc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;picksplit&lt;/code&gt; can be applied to a single leaf tuple only in the case that the &lt;code&gt;config&lt;/code&gt; function set &lt;code&gt;longValuesOK&lt;/code&gt; to true and a larger-than-a-page input value has been supplied. In this case the point of the operation is to strip off a prefix and produce a new, shorter leaf datum value. The call will be repeated until a leaf datum short enough to fit on a page has been produced. See &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;Section 65.4.1&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;picksplit&lt;/code&gt; &lt;code&gt;config&lt;/code&gt; 함수가 &lt;code&gt;longValuesOK&lt;/code&gt; 를 true로 설정 하고 페이지보다 큰 입력 값이 제공된 경우에만 picksplit 을 단일 리프 튜플에 적용 할 수 있습니다 . 이 경우 작업의 핵심은 접두사를 제거하고 더 짧은 새 잎 데이텀 값을 생성하는 것입니다. 페이지에 맞도록 충분한 잎 데이텀이 생성 될 때까지 호출이 반복됩니다. 자세한 정보는 &lt;a href=&quot;spgist-implementation#SPGIST-LIMITS&quot;&gt;섹션 65.4.1&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d33d037cfdc30a26665b737ebe468911ea4d3256" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pkcs&lt;/code&gt; &amp;mdash; data may be any length (default)</source>
          <target state="translated">&lt;code&gt;pkcs&lt;/code&gt; &amp;mdash; 데이터는 임의 길이 일 수 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="9674bdc270a2a7ea6c8cf9c54d7b466a7f831fa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plainto_tsquery&lt;/code&gt; transforms the unformatted text &lt;code&gt;querytext&lt;/code&gt; to a &lt;code&gt;tsquery&lt;/code&gt; value. The text is parsed and normalized much as for &lt;code&gt;to_tsvector&lt;/code&gt;, then the &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) &lt;code&gt;tsquery&lt;/code&gt; operator is inserted between surviving words.</source>
          <target state="translated">&lt;code&gt;plainto_tsquery&lt;/code&gt; 는 형식화되지 않은 텍스트 &lt;code&gt;querytext&lt;/code&gt; 텍스트 를 &lt;code&gt;tsquery&lt;/code&gt; 값 으로 변환 합니다. 텍스트는 &lt;code&gt;to_tsvector&lt;/code&gt; 와 마찬가지로 구문 분석되고 정규화 된 다음 생존 단어 사이에 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND) &lt;code&gt;tsquery&lt;/code&gt; 연산자가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="24b56aa7eb93042b66d68969abdb820ea244a3e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plan_cache_mode&lt;/code&gt; (&lt;code&gt;enum&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;plan_cache_mode&lt;/code&gt; ( &lt;code&gt;enum&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59c8b64763ed52b6e225c8bc7bf9b695931c328c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pmatch&lt;/code&gt; is an output argument for use when partial match is supported. To use it, &lt;code&gt;extractQuery&lt;/code&gt; must allocate an array of &lt;code&gt;*nkeys&lt;/code&gt;&lt;code&gt;bool&lt;/code&gt;s and store its address at &lt;code&gt;*pmatch&lt;/code&gt;. Each element of the array should be set to true if the corresponding key requires partial match, false if not. If &lt;code&gt;*pmatch&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt; then GIN assumes partial match is not required. The variable is initialized to &lt;code&gt;NULL&lt;/code&gt; before call, so this argument can simply be ignored by operator classes that do not support partial match.</source>
          <target state="translated">&lt;code&gt;pmatch&lt;/code&gt; 는 부분 일치가 지원 될 때 사용하기위한 출력 인수입니다. 이를 사용하려면 &lt;code&gt;extractQuery&lt;/code&gt; 는 &lt;code&gt;*nkeys&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; 의 배열을 할당 하고 주소를 &lt;code&gt;*pmatch&lt;/code&gt; 에 저장해야합니다 . 해당 키에 부분 일치가 필요한 경우 배열의 각 요소를 true로 설정하고 그렇지 않으면 false를 설정해야합니다. 경우 &lt;code&gt;*pmatch&lt;/code&gt; 가 설정되어 &lt;code&gt;NULL&lt;/code&gt; 다음 GIN은 부분 일치가 필요하지 않습니다 가정합니다. 변수는 호출 전에 &lt;code&gt;NULL&lt;/code&gt; 로 초기화 되므로이 인수는 부분 일치를 지원하지 않는 연산자 클래스에서 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a7ecf876b1e0f56d4b29ec70634bc80d6da49d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;point&lt;/code&gt;&lt;code&gt;&amp;lt;@&amp;gt;&lt;/code&gt;&lt;code&gt;point&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt;&lt;code&gt;&amp;lt;@&amp;gt;&lt;/code&gt;&lt;code&gt;point&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70e4157ec4509526171c18f216644a3548eb463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="968b83a743c7471266ddf2f896a00f906dfb77fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;position&lt;/code&gt; (optional)</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="ce6897887472ae7aa11c5d9bde5df1690e04e2ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;post_auth_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;post_auth_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3cae3d26e1d3ba553b68d7f0e49f942e0fc9c224" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="0b0293d084d149ea9be733ff13b838d96ac655dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres&lt;/code&gt; accepts the following command-line arguments. For a detailed discussion of the options consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. You can save typing most of these options by setting up a configuration file. Some (safe) options can also be set from the connecting client in an application-dependent way to apply only for that session. For example, if the environment variable &lt;code&gt;PGOPTIONS&lt;/code&gt; is set, then libpq-based clients will pass that string to the server, which will interpret it as &lt;code&gt;postgres&lt;/code&gt; command-line options.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 는 다음 명령 줄 인수를 허용합니다. 옵션에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 을 참조하십시오 . 구성 파일을 설정하여 이러한 옵션의 대부분을 입력하여 저장할 수 있습니다. 응용 프로그램에 따라 연결 세션에서 일부 (안전한) 옵션을 설정하여 해당 세션에만 적용 할 수도 있습니다. 예를 들어, 환경 변수 &lt;code&gt;PGOPTIONS&lt;/code&gt; 가 설정되면 libpq 기반 클라이언트는 해당 문자열을 서버로 전달하여 &lt;code&gt;postgres&lt;/code&gt; 명령 행 옵션 으로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="d62385604c96a6269bd2eb0664e40a4fe492f3de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres&lt;/code&gt; is the PostgreSQL database server. In order for a client application to access a database it connects (over a network or locally) to a running &lt;code&gt;postgres&lt;/code&gt; instance. The &lt;code&gt;postgres&lt;/code&gt; instance then starts a separate server process to handle the connection.</source>
          <target state="translated">&lt;code&gt;postgres&lt;/code&gt; 는 PostgreSQL 데이터베이스 서버입니다. 클라이언트 응용 프로그램이 데이터베이스에 액세스하려면 (네트워크를 통해 또는 로컬로) 실행중인 &lt;code&gt;postgres&lt;/code&gt; 인스턴스에 연결됩니다. &lt;code&gt;postgres&lt;/code&gt; 인스턴스는 다음 연결을 처리하기 위해 별도의 서버 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3188fb02add8200e89562679940a946765e24a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; attempts to optimize remote queries to reduce the amount of data transferred from foreign servers. This is done by sending query &lt;code&gt;WHERE&lt;/code&gt; clauses to the remote server for execution, and by not retrieving table columns that are not needed for the current query. To reduce the risk of misexecution of queries, &lt;code&gt;WHERE&lt;/code&gt; clauses are not sent to the remote server unless they use only data types, operators, and functions that are built-in or belong to an extension that's listed in the foreign server's &lt;code&gt;extensions&lt;/code&gt; option. Operators and functions in such clauses must be &lt;code&gt;IMMUTABLE&lt;/code&gt; as well. For an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; query, &lt;code&gt;postgres_fdw&lt;/code&gt; attempts to optimize the query execution by sending the whole query to the remote server if there are no query &lt;code&gt;WHERE&lt;/code&gt; clauses that cannot be sent to the remote server, no local joins for the query, no row-level local &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; triggers or stored generated columns on the target table, and no &lt;code&gt;CHECK OPTION&lt;/code&gt; constraints from parent views. In &lt;code&gt;UPDATE&lt;/code&gt;, expressions to assign to target columns must use only built-in data types, &lt;code&gt;IMMUTABLE&lt;/code&gt; operators, or &lt;code&gt;IMMUTABLE&lt;/code&gt; functions, to reduce the risk of misexecution of the query.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 원격 쿼리를 최적화하여 외부 서버에서 전송되는 데이터의 양을 줄입니다. 실행을 위해 쿼리 &lt;code&gt;WHERE&lt;/code&gt; 절을 원격 서버 에 전송 하고 현재 쿼리에 필요하지 않은 테이블 열을 검색하지 않습니다. 쿼리가 잘못 실행될 위험을 줄이기 위해 &lt;code&gt;WHERE&lt;/code&gt; 절은 외부 서버의 &lt;code&gt;extensions&lt;/code&gt; 옵션에 나열된 확장에 속하는 데이터 형식, 연산자 및 함수 만 사용하지 않는 한 원격 서버로 전송되지 않습니다 . 그러한 절의 연산자와 함수도 &lt;code&gt;IMMUTABLE&lt;/code&gt; 이어야합니다 . 를 들어 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 쿼리, &lt;code&gt;postgres_fdw&lt;/code&gt; 원격 서버 로 보낼 수 없는 쿼리 &lt;code&gt;WHERE&lt;/code&gt; 절이 없거나 쿼리 에 대한 로컬 조인이 없거나 행 수준의 로컬 &lt;code&gt;BEFORE&lt;/code&gt; 또는 &lt;code&gt;AFTER&lt;/code&gt; 트리거가 없거나 저장된 생성 된 경우 전체 쿼리를 원격 서버로 전송하여 쿼리 실행을 최적화합니다. 대상 테이블의 열 및 상위 뷰의 &lt;code&gt;CHECK OPTION&lt;/code&gt; 제한 조건이 없습니다 . 에서 &lt;code&gt;UPDATE&lt;/code&gt; , 표현은 사용하는 경우에만 내장 데이터 유형 있어야 목표 컬럼에 할당 할 &lt;code&gt;IMMUTABLE&lt;/code&gt; 연산자 또는 &lt;code&gt;IMMUTABLE&lt;/code&gt; 기능, 쿼리의 misexecution의 위험을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbd8477894d58b7a9998cb847f19222e64d5b957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; can be used with remote servers dating back to PostgreSQL 8.3. Read-only capability is available back to 8.1. A limitation however is that &lt;code&gt;postgres_fdw&lt;/code&gt; generally assumes that immutable built-in functions and operators are safe to send to the remote server for execution, if they appear in a &lt;code&gt;WHERE&lt;/code&gt; clause for a foreign table. Thus, a built-in function that was added since the remote server's release might be sent to it for execution, resulting in &amp;ldquo;function does not exist&amp;rdquo; or a similar error. This type of failure can be worked around by rewriting the query, for example by embedding the foreign table reference in a sub-&lt;code&gt;SELECT&lt;/code&gt; with &lt;code&gt;OFFSET 0&lt;/code&gt; as an optimization fence, and placing the problematic function or operator outside the sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 PostgreSQL 8.3으로 거슬러 올라가는 원격 서버와 함께 사용할 수 있습니다. 읽기 전용 기능은 8.1로 다시 제공됩니다. 그러나 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 일반적으로 불변의 내장 함수와 연산자가 외부 테이블 의 &lt;code&gt;WHERE&lt;/code&gt; 절에 나타나는 경우 실행을 위해 원격 서버로 전송하는 것이 안전하다고 가정 합니다. 따라서 원격 서버의 릴리스 이후에 추가 된 내장 기능이 실행을 위해 전송되어 &quot;기능이 존재하지 않습니다&quot;또는 유사한 오류가 발생할 수 있습니다. 이러한 유형의 실패는 하위의 외부 테이블 참조 매립 예를 들어, 쿼리를 다시 작성함으로써 해결할 수 &lt;code&gt;SELECT&lt;/code&gt; 하여 &lt;code&gt;OFFSET 0&lt;/code&gt; 최적화 펜스로 사용하고 문제가있는 함수 또는 연산자를 하위 &lt;code&gt;SELECT&lt;/code&gt; 외부에 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="162b404fe2c77d26eaf73b2dfa14d197eca60478" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; establishes a connection to a foreign server during the first query that uses a foreign table associated with the foreign server. This connection is kept and re-used for subsequent queries in the same session. However, if multiple user identities (user mappings) are used to access the foreign server, a connection is established for each user mapping.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 외부 서버와 연결된 외부 테이블을 사용하는 첫 번째 쿼리 중에 외부 서버에 대한 연결을 설정합니다. 이 연결은 동일한 세션에서 후속 쿼리에 대해 유지 및 재사용됩니다. 그러나 외부 서버에 액세스하기 위해 여러 사용자 ID (사용자 맵핑)를 사용하는 경우 각 사용자 맵핑에 대한 연결이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="98be7482e7e4385042cdafc0b7023d0f30dc8e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; is able to import foreign table definitions using &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt;. This command creates foreign table definitions on the local server that match tables or views present on the remote server. If the remote tables to be imported have columns of user-defined data types, the local server must have compatible types of the same names.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA를&lt;/a&gt; 사용하여 외부 테이블 정의를 가져올 수 있습니다. 이 명령은 원격 서버에 존재하는 테이블 또는 뷰와 일치하는 외부 서버 정의를 로컬 서버에 작성합니다. 가져올 원격 테이블에 사용자 정의 데이터 유형의 컬럼이있는 경우 로컬 서버는 동일한 이름의 호환 가능한 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a144d434d04777bb955b06ac2f6a2a6f28320f77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; likewise establishes remote session settings for various parameters:</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 도 마찬가지로 다양한 매개 변수에 대한 원격 세션 설정을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f39bf7f44a9aae44021af2700a395b6647530db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres_fdw&lt;/code&gt; retrieves remote data by executing queries against remote servers, so ideally the estimated cost of scanning a foreign table should be whatever it costs to be done on the remote server, plus some overhead for communication. The most reliable way to get such an estimate is to ask the remote server and then add something for overhead &amp;mdash; but for simple queries, it may not be worth the cost of an additional remote query to get a cost estimate. So &lt;code&gt;postgres_fdw&lt;/code&gt; provides the following options to control how cost estimation is done:</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 원격 서버에 대해 쿼리를 실행하여 원격 데이터를 검색하므로 원격 서버에서 수행해야하는 비용과 통신에 대한 오버 헤드에 대한 외래 테이블 스캔 비용이 이상적입니다. 이러한 예상치를 얻는 가장 신뢰할 수있는 방법은 원격 서버에 요청한 다음 오버 헤드를 추가하는 것입니다. 그러나 간단한 쿼리의 경우 추가 원격 쿼리 비용으로 비용을 계산할 가치가 없습니다. 따라서 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 비용 산정 방법을 제어하기 위해 다음 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21bb65bff17ec9449f13c4e88f00b36e8eb11402" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgresql&lt;/code&gt; in the context &lt;code&gt;postgresql-beta1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;postgresql&lt;/code&gt; 컨텍스트에서 &lt;code&gt;postgresql-beta1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a96c93549da012546deee085842302306139c20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postmaster&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...]</source>
          <target state="translated">&lt;code&gt;postmaster&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...]</target>
        </trans-unit>
        <trans-unit id="84101a50037ca5eb661216150a2dfbdfc8d1e798" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postmaster&lt;/code&gt; is a deprecated alias of &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postmaster&lt;/code&gt; 는 더 이상 사용되지 않는 &lt;code&gt;postgres&lt;/code&gt; 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="132c63a507f35c96cceb9ea9304d27a59b794404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;potential&lt;/code&gt;: This standby server is now asynchronous, but can potentially become synchronous if one of current synchronous ones fails.</source>
          <target state="translated">&lt;code&gt;potential&lt;/code&gt; :이 대기 서버는 이제 비동기식이지만 현재 동기식 서버 중 하나가 실패하면 잠재적으로 동기식이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a93e9f6a7a100aea5e9386b9886005170429ff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(2.0, 10)&lt;/code&gt;, &lt;code&gt;power(2.0, 10)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(2.0, 10)&lt;/code&gt; , &lt;code&gt;power(2.0, 10)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7df15e9889249beeb390c2d75e875505ea90bdfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pre_auth_delay&lt;/code&gt; (&lt;code&gt;integer&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pre_auth_delay&lt;/code&gt; ( &lt;code&gt;integer&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fbad76bc679f7f2b3ef8cdba90047eef00226c6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepared&lt;/code&gt;: use extended query protocol with prepared statements.</source>
          <target state="translated">&lt;code&gt;prepared&lt;/code&gt; : 준비된 명령문과 함께 확장 쿼리 프로토콜을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8b1193d5e7c20083f7690091bfb8eb43613db9d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primary_conninfo&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;primary_conninfo&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0accde02febd84b68923d6f2c5180a6f27381800" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primary_slot_name&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;primary_slot_name&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0b9d6b34a40ef51a93fe11d46f54376bfe582253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;promote&lt;/code&gt; mode commands the standby server that is running in the specified data directory to end standby mode and begin read-write operations.</source>
          <target state="translated">&lt;code&gt;promote&lt;/code&gt; 모드는 지정된 데이터 디렉토리에서 실행중인 대기 서버가 대기 모드를 종료하고 읽기-쓰기 조작을 시작하도록 명령합니다.</target>
        </trans-unit>
        <trans-unit id="1ae9cbabe201c127a36634a09aa8e11b041cdd46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;promote_trigger_file&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;promote_trigger_file&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9885064801b7aa44bd53e6b333eba188a0adee0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proparallel&lt;/code&gt; tells whether the function can be safely run in parallel mode. It is &lt;code&gt;s&lt;/code&gt; for functions which are safe to run in parallel mode without restriction. It is &lt;code&gt;r&lt;/code&gt; for functions which can be run in parallel mode, but their execution is restricted to the parallel group leader; parallel worker processes cannot invoke these functions. It is &lt;code&gt;u&lt;/code&gt; for functions which are unsafe in parallel mode; the presence of such a function forces a serial execution plan.</source>
          <target state="translated">&lt;code&gt;proparallel&lt;/code&gt; 은 함수를 병렬 모드에서 안전하게 실행할 수 있는지 여부를 알려줍니다. 그것은이다 &lt;code&gt;s&lt;/code&gt; 제한없이 병렬 모드에서 실행하는 안전 기능. 병렬 모드에서 실행할 수있는 기능 은 &lt;code&gt;r&lt;/code&gt; 이지만 병렬 그룹 리더로 실행이 제한됩니다. 병렬 작업자 프로세스는 이러한 기능을 호출 할 수 없습니다. 병렬 모드에서 안전하지 않은 기능 은 &lt;code&gt;u&lt;/code&gt; 입니다. 그러한 기능의 존재는 일련의 실행 계획을 강요합니다.</target>
        </trans-unit>
        <trans-unit id="295f073b40f4156e134e6d1a4d873100db128254" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provolatile&lt;/code&gt; tells whether the function's result depends only on its input arguments, or is affected by outside factors. It is &lt;code&gt;i&lt;/code&gt; for &amp;ldquo;immutable&amp;rdquo; functions, which always deliver the same result for the same inputs. It is &lt;code&gt;s&lt;/code&gt; for &amp;ldquo;stable&amp;rdquo; functions, whose results (for fixed inputs) do not change within a scan. It is &lt;code&gt;v&lt;/code&gt; for &amp;ldquo;volatile&amp;rdquo; functions, whose results might change at any time. (Use &lt;code&gt;v&lt;/code&gt; also for functions with side-effects, so that calls to them cannot get optimized away.)</source>
          <target state="translated">&lt;code&gt;provolatile&lt;/code&gt; 은 함수의 결과가 입력 인수에만 의존하는지 아니면 외부 요인의 영향을 받는지 알려줍니다. 그것은이다 &lt;code&gt;i&lt;/code&gt; 항상 동일한 입력에 대해 동일한 결과를 제공하는 &quot;불변&quot;기능에 대한. 그것은이다 &lt;code&gt;s&lt;/code&gt; 결과 (고정 입력에 대해) 내 주사 변경하지 않는 &quot;안정&quot;기능에 대한. 그것은이다 &lt;code&gt;v&lt;/code&gt; 결과 언제든지 변경 될 수 있습니다 &quot;휘발성&quot;기능에 대한. ( 부작용이있는 함수에도 &lt;code&gt;v&lt;/code&gt; 를 사용 하여 호출을 최적화 할 수 없도록합니다.)</target>
        </trans-unit>
        <trans-unit id="d425f7eaa1d950a1abde312ad00284438064e1d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;psql&lt;/code&gt; [&lt;code&gt;option&lt;/code&gt;...] [&lt;code&gt;dbname&lt;/code&gt; [&lt;code&gt;username&lt;/code&gt;]]</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; [ &lt;code&gt;option&lt;/code&gt; ...] [ &lt;code&gt;dbname&lt;/code&gt; [ &lt;code&gt;username&lt;/code&gt; ]]</target>
        </trans-unit>
        <trans-unit id="9102cc5c32d8af6caa824cd56070a45acc442394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;psqlrc&lt;/code&gt; and &lt;code&gt;~/.psqlrc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;psqlrc&lt;/code&gt; &lt;code&gt;~/.psqlrc&lt;/code&gt; 와 ~ / .psqlrc</target>
        </trans-unit>
        <trans-unit id="3b6fa5b7a2eae48f64d8ac40c9f22966581eb82c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;publish&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;publish&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="79126e71f887e4e40b37a78d037b10171e8a7a15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query1&lt;/code&gt; and &lt;code&gt;query2&lt;/code&gt; are queries that can use any of the features discussed up to this point. Set operations can also be nested and chained, for example</source>
          <target state="translated">&lt;code&gt;query1&lt;/code&gt; 및 &lt;code&gt;query2&lt;/code&gt; 는 지금까지 설명한 기능을 사용할 수있는 쿼리입니다. 예를 들어, 설정 작업을 중첩 및 연결 가능</target>
        </trans-unit>
        <trans-unit id="583e63cd15809240939dbf670653cef539a57273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quorum&lt;/code&gt;: This standby server is considered as a candidate for quorum standbys.</source>
          <target state="translated">&lt;code&gt;quorum&lt;/code&gt; :이 대기 서버는 쿼럼 대기의 후보로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d9e5eb6da9316074cdcfaf14f0d52271f875e1d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote_all_identifiers&lt;/code&gt; (&lt;code&gt;boolean&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;quote_all_identifiers&lt;/code&gt; ( &lt;code&gt;boolean&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f35c65a6727a3569fd01f953235cd12e0883919b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; (&amp;ldquo;read&amp;rdquo;)</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ( &quot;읽기&quot;)</target>
        </trans-unit>
        <trans-unit id="fcc2a007e009d8ad276584f1336b85d8d4a806a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; = ordinary table, &lt;code&gt;i&lt;/code&gt; = index, &lt;code&gt;S&lt;/code&gt; = sequence, &lt;code&gt;t&lt;/code&gt; = TOAST table, &lt;code&gt;v&lt;/code&gt; = view, &lt;code&gt;m&lt;/code&gt; = materialized view, &lt;code&gt;c&lt;/code&gt; = composite type, &lt;code&gt;f&lt;/code&gt; = foreign table, &lt;code&gt;p&lt;/code&gt; = partitioned table, &lt;code&gt;I&lt;/code&gt; = partitioned index</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; = 일반 테이블, &lt;code&gt;i&lt;/code&gt; = 인덱스, &lt;code&gt;S&lt;/code&gt; = 시퀀스, &lt;code&gt;t&lt;/code&gt; = TOAST 테이블, &lt;code&gt;v&lt;/code&gt; = 뷰, &lt;code&gt;m&lt;/code&gt; = 구체화 된 뷰, &lt;code&gt;c&lt;/code&gt; = 복합 유형, &lt;code&gt;f&lt;/code&gt; = 외부 테이블, &lt;code&gt;p&lt;/code&gt; = 분할 된 테이블, &lt;code&gt;I&lt;/code&gt; = 분할 된 인덱스</target>
        </trans-unit>
        <trans-unit id="a4a150097fd7778f11a9a1855fdc016250ff0f52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;random_page_cost&lt;/code&gt; (&lt;code&gt;floating point&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;random_page_cost&lt;/code&gt; ( &lt;code&gt;floating point&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d53246bf9e6e9cfe1d57e165285d6717dc38cfbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;random_zipfian&lt;/code&gt; generates a bounded Zipfian distribution. &lt;code&gt;parameter&lt;/code&gt; defines how skewed the distribution is. The larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values closer to the beginning of the interval are drawn. The distribution is such that, assuming the range starts from 1, the ratio of the probability of drawing &lt;code&gt;k&lt;/code&gt; versus drawing &lt;code&gt;k+1&lt;/code&gt; is &lt;code&gt;((k+1)/k)**parameter&lt;/code&gt;. For example, &lt;code&gt;random_zipfian(1, ..., 2.5)&lt;/code&gt; produces the value &lt;code&gt;1&lt;/code&gt; about &lt;code&gt;(2/1)**2.5 = 5.66&lt;/code&gt; times more frequently than &lt;code&gt;2&lt;/code&gt;, which itself is produced &lt;code&gt;(3/2)**2.5 = 2.76&lt;/code&gt; times more frequently than &lt;code&gt;3&lt;/code&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;random_zipfian&lt;/code&gt; 은 제한된 Zipfian 분포를 생성합니다. &lt;code&gt;parameter&lt;/code&gt; 는 분포의 왜곡 정도를 정의합니다. &lt;code&gt;parameter&lt;/code&gt; 클수록 간격의 시작 부분에 더 가까운 값이 더 자주 그려집니다. 분포는 범위가 1에서 시작한다고 가정 할 때 묘화 &lt;code&gt;k&lt;/code&gt; 대 묘화 &lt;code&gt;k+1&lt;/code&gt; 의 확률의 비율 이 &lt;code&gt;((k+1)/k)**parameter&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;random_zipfian(1, ..., 2.5)&lt;/code&gt; 값을 생성한다 &lt;code&gt;1&lt;/code&gt; 에 대해 &lt;code&gt;(2/1)**2.5 = 5.66&lt;/code&gt; 보다 자주 시간 &lt;code&gt;2&lt;/code&gt; 자신이 제조되는, &lt;code&gt;(3/2)**2.5 = 2.76&lt;/code&gt; 회 이상 자주 &lt;code&gt;3&lt;/code&gt; 보다, 등등.</target>
        </trans-unit>
        <trans-unit id="ecd24c6cdf600d9e05bb94030dc43e05160a56a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;record&lt;/code&gt;&lt;code&gt;#=&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;record&lt;/code&gt;&lt;code&gt;#=&lt;/code&gt;&lt;code&gt;hstore&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
